(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@protobufjs/aspromise/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/***/ (function(module) {

"use strict";

module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}


/***/ }),

/***/ "./node_modules/@protobufjs/base64/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};


/***/ }),

/***/ "./node_modules/@protobufjs/eventemitter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/***/ (function(module) {

"use strict";

module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};


/***/ }),

/***/ "./node_modules/@protobufjs/float/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/***/ (function(module) {

"use strict";


module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}


/***/ }),

/***/ "./node_modules/@protobufjs/inquire/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/***/ (function(module) {

"use strict";

module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}


/***/ }),

/***/ "./node_modules/@protobufjs/pool/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/***/ (function(module) {

"use strict";

module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}


/***/ }),

/***/ "./node_modules/@protobufjs/utf8/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};


/***/ }),

/***/ "./node_modules/protobufjs/minimal.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// minimal library entry point.


module.exports = __webpack_require__(/*! ./src/index-minimal */ "./node_modules/protobufjs/src/index-minimal.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
protobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ "./node_modules/protobufjs/src/writer_buffer.js");
protobuf.Reader       = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
protobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ "./node_modules/protobufjs/src/reader_buffer.js");

// Utility
protobuf.util         = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");
protobuf.rpc          = __webpack_require__(/*! ./rpc */ "./node_modules/protobufjs/src/rpc.js");
protobuf.roots        = __webpack_require__(/*! ./roots */ "./node_modules/protobufjs/src/roots.js");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = Reader;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};


/***/ }),

/***/ "./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = BufferReader;

// extends Reader
var Reader = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/***/ (function(module) {

"use strict";

module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = __webpack_require__(/*! ./rpc/service */ "./node_modules/protobufjs/src/rpc/service.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = Service;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = LongBits;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ "./node_modules/@protobufjs/aspromise/index.js");

// converts to / from base64 encoded strings
util.base64 = __webpack_require__(/*! @protobufjs/base64 */ "./node_modules/@protobufjs/base64/index.js");

// base class of rpc.Service
util.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ "./node_modules/@protobufjs/eventemitter/index.js");

// float handling accross browsers
util.float = __webpack_require__(/*! @protobufjs/float */ "./node_modules/@protobufjs/float/index.js");

// requires modules optionally and hides the call from bundlers
util.inquire = __webpack_require__(/*! @protobufjs/inquire */ "./node_modules/@protobufjs/inquire/index.js");

// converts to / from utf8 encoded strings
util.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ "./node_modules/@protobufjs/utf8/index.js");

// provides a node-like buffer pool in the browser
util.pool = __webpack_require__(/*! @protobufjs/pool */ "./node_modules/@protobufjs/pool/index.js");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = __webpack_require__(/*! ./longbits */ "./node_modules/protobufjs/src/util/longbits.js");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof __webpack_require__.g !== "undefined"
                   && __webpack_require__.g
                   && __webpack_require__.g.process
                   && __webpack_require__.g.process.versions
                   && __webpack_require__.g.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && __webpack_require__.g
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};


/***/ }),

/***/ "./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = Writer;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};


/***/ }),

/***/ "./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = BufferWriter;

// extends Writer
var Writer = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();


/***/ }),

/***/ "./sdk/code/zh/ZegoExpressDataChannel.web.ts":
/*!***************************************************!*\
  !*** ./sdk/code/zh/ZegoExpressDataChannel.web.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoRealTimeSequentialDataManager = void 0;
var manager_1 = __webpack_require__(/*! ../../src/modules/datachannel/manager */ "./sdk/src/modules/datachannel/manager.ts");
/**
 * 实时有序数据对象
 *
 * 实时有序数据，依托于 ZEGO RTC 服务，可为开发者提供 实时、有序、高频 的数据传输与分发功能
 *
 */
var ZegoRealTimeSequentialDataManager = /** @class */ (function () {
    function ZegoRealTimeSequentialDataManager(zegoWebRTC, roomID) {
        this.dataChannelManager = new manager_1.DataChannelListener(zegoWebRTC, roomID);
    }
    /**
     * 开始广播
     *
     * Note: 支持版本：2.12.2 及以上
     *
     * Note: 详情描述： 开始广播名为 streamID 的实时有序数据通道。
     *
     * Note: 业务场景：远程控制场景中由控制端发送指令到受控端。
     *
     * Note: 注意事项:  可复用 RTC 推流通道。
     *
     * Note: 调用时机：调用接口 createRealTimeSequentialDataManager 创建 ZegoRealTimeSequentialDataManager实例后。
     *
     * @param streamID 推流 ID，长度不超过256的字符串，仅支持数字，英文字符 和 '~', '!', '@', '#', '$', '', '^', '&', '*', '(', ')', '_', '+', '=', '-', ', ';', '’', ',', '.', '<', '>', '/', ''
     *
     * @return true 表示客户端发送请求成功，流成功推送到服务器需要通过流状态回调接口判断。
     */
    ZegoRealTimeSequentialDataManager.prototype.startBroadcasting = function (streamID) {
        return this.dataChannelManager.startBroadcasting(streamID);
    };
    /**
     * 停止广播
     *
     * Note: 支持版本：2.12.2 及以上
     *
     * Note: 详情描述：停止广播 名为 streamID 的实时有序数据通道。
     *
     * Note: 业务场景：远程控制场景控制端停止传输指令到受控端。
     *
     * Note: 注意事项:  在复用 RTC 通道的情况下，停止实时有序数据的广播不会影响 RTC 通道。
     *
     * Note: 调用时机：调用接口 createRealTimeSequentialDataManager 创建 ZegoRealTimeSequentialDataManager实例后。
     *
     * @param streamID 推流 ID,和广播 streamID保持一致
     *
     * @return 布尔值
     */
    ZegoRealTimeSequentialDataManager.prototype.stopBroadcasting = function (streamID) {
        return this.dataChannelManager.stopBroadcasting(streamID);
    };
    /**
     * 发送实时有序数据
     *
     * Note: 支持版本：2.12.2 及以上
     *
     * Note: 详情描述：发送 实时有序数据。
     *
     * Note: 业务场景：远程控制场景中由控制端发送指令到受控端。
     *
     * Note: 注意事项:  在弱网下数据可能存在丢失。
     *
     * Note: 调用时机：调用接口 createRealTimeSequentialDataManager 创建 ZegoRealTimeSequentialDataManager实例后，并调用 startBroadcasting 进行广播后。
     *
     * @param streamID 流 ID
     * @param data 数据
     *
     * @return 布尔值
     */
    ZegoRealTimeSequentialDataManager.prototype.sendRealTimeSequentialData = function (streamID, data) {
        return this.dataChannelManager.sendRealTimeSequentialData(streamID, data);
    };
    /**
     * 开始订阅
     *
     * Note: 支持版本：2.12.2 及以上
     *
     * Note: 详情描述：开始订阅通道为 streamID 的实时有序数据频道。
     *
     * Note: 业务场景：远程控制场景中，受控端从控制端接收指令。
     *
     * Note: 注意事项:  可复用 RTC 推流通道。
     *
     * Note: 调用时机：调用接口 createRealTimeSequentialDataManager 创建 ZegoRealTimeSequentialDataManager实例后。
     *
     * @param streamID 流 ID
     *
     * @return 布尔值
     */
    ZegoRealTimeSequentialDataManager.prototype.startSubscribing = function (streamID) {
        return this.dataChannelManager.startSubscribing(streamID);
    };
    /**
     * 停止订阅
     *
     * Note: 支持版本：2.12.2 及以上
     *
     * Note: 详情描述：停止订阅名为 streamID 的实时有序数据频道。
     *
     * Note: 业务场景：远程控制场景中，受控端停止从控制端接收指令。
     *
     * Note: 注意事项:  在复用 RTC 通道的情况下，停止实时有序数据的广播不会影响 RTC 通道。
     *
     * Note: 调用时机：调用接口 createRealTimeSequentialDataManager 创建 ZegoRealTimeSequentialDataManager实例后。
     *
     * @param streamID 流 ID
     *
     * @return 布尔值
     */
    ZegoRealTimeSequentialDataManager.prototype.stopSubscribing = function (streamID) {
        return this.dataChannelManager.stopSubscribing(streamID);
    };
    /**
     * 注册回调事件。
     *
     * Note: 支持版本：2.12.2 及以上
     *
     * Note: 详情描述：用于处理 SDK 主动通知开发者回调的接口，通过注册不同 event 的事件，可以收到不同功能的回调。可监听的事件回调可以通过 ZegoDataChannelEvent查看。
     *
     * Note: 业务场景：用于注册实时有序数据功能相关的业务事件的回调处理。
     *
     * Note: 调用时机：调用接口 createRealTimeSequentialDataManager 创建实例之后。
     *
     * Note: 注意事项：同样的事件可以注册多个, 相同的注册事件，会根据注册的先后顺序依次触发。
     *
     * Note: 相关接口：调用接口 off 来注销对应回调事件处理。
     *
     * @param event 监听事件名。
     * @param callBack 回调函数。
     *
     * @return 注册是否成功。
     */
    ZegoRealTimeSequentialDataManager.prototype.on = function (event, callBack) {
        this.dataChannelManager.on(event, callBack);
    };
    /**
     * 注销回调事件。
     *
     * Note: 支持版本：2.12.2 及以上
     *
     * Note: 详情描述：用于处理 SDK 主动通知开发者回调的接口，通过注册不同 event 的事件，可以收到不同功能的回调。可监听的事件回调可以通过 ZegoDataChannelEvent查看。
     *
     * Note: 业务场景：用于注销实时有序数据功能相关的业务事件的回调处理。
     *
     * Note: 调用时机：调用接口 createRealTimeSequentialDataManager 创建实例之后。
     *
     * Note: 注意事项：同样的事件可以注册多个, 相同的注册事件，会根据注册的先后顺序依次触发。
     *
     * Note: 相关接口：调用接口 off 来注销对应回调事件处理。
     *
     * @param event 监听事件名。
     * @param callBack 回调函数。
     *
     * @return 注册是否成功。
     */
    ZegoRealTimeSequentialDataManager.prototype.off = function (event, callBack) {
        this.dataChannelManager.off(event, callBack);
    };
    return ZegoRealTimeSequentialDataManager;
}());
exports.ZegoRealTimeSequentialDataManager = ZegoRealTimeSequentialDataManager;


/***/ }),

/***/ "./sdk/code/zh/ZegoExpressEntity.web.ts":
/*!**********************************************!*\
  !*** ./sdk/code/zh/ZegoExpressEntity.web.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoRangeAudioMode = exports.ZegoRangeAudioMicrophoneState = exports.ZegoMixStreamRenderMode = void 0;
/**
 * 混流视频渲染模式
 *
 * 详情描述：混流视频渲染模式。
 *
 */
var ZegoMixStreamRenderMode;
(function (ZegoMixStreamRenderMode) {
    /**
     * 填充模式，等比填充布局，画面可能有部分被裁剪。
     */
    ZegoMixStreamRenderMode[ZegoMixStreamRenderMode["AspectFill"] = 0] = "AspectFill";
    /**
     * 适应模式，等比缩放画面，布局内可能有留白。
     */
    ZegoMixStreamRenderMode[ZegoMixStreamRenderMode["AspectFit"] = 1] = "AspectFit";
})(ZegoMixStreamRenderMode = exports.ZegoMixStreamRenderMode || (exports.ZegoMixStreamRenderMode = {}));
/**
 * 麦克风发送声音状态。
 *
 * 详情描述：麦克风发送声音状态。
 *
 * 业务场景：获取麦克风开关状态。
 *
 */
var ZegoRangeAudioMicrophoneState;
(function (ZegoRangeAudioMicrophoneState) {
    /**
     * 关闭状态
     */
    ZegoRangeAudioMicrophoneState[ZegoRangeAudioMicrophoneState["Off"] = 0] = "Off";
    /**
     * 开启中
     */
    ZegoRangeAudioMicrophoneState[ZegoRangeAudioMicrophoneState["TurningOn"] = 1] = "TurningOn";
    /**
     * 开启状态
     */
    ZegoRangeAudioMicrophoneState[ZegoRangeAudioMicrophoneState["On"] = 2] = "On";
})(ZegoRangeAudioMicrophoneState = exports.ZegoRangeAudioMicrophoneState || (exports.ZegoRangeAudioMicrophoneState = {}));
/**
 * 范围语音模式
 *
 * 详情描述：范围语音模式。
 *
 */
var ZegoRangeAudioMode;
(function (ZegoRangeAudioMode) {
    /**
     * 所有人模式，可以与房间内所有人交流
     */
    ZegoRangeAudioMode[ZegoRangeAudioMode["World"] = 0] = "World";
    /**
     * 仅小队模式，只与小队内的成员交流
     */
    ZegoRangeAudioMode[ZegoRangeAudioMode["Team"] = 1] = "Team";
})(ZegoRangeAudioMode = exports.ZegoRangeAudioMode || (exports.ZegoRangeAudioMode = {}));


/***/ }),

/***/ "./sdk/code/zh/ZegoExpressRangeAudio.web.ts":
/*!**************************************************!*\
  !*** ./sdk/code/zh/ZegoExpressRangeAudio.web.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoExpressRangeAudio = void 0;
var ZegoAudioListener_1 = __importDefault(__webpack_require__(/*! ../../src/modules/rangeaudio/ZegoAudioListener */ "./sdk/src/modules/rangeaudio/ZegoAudioListener.ts"));
/**
 * 范围语音
 *
 * 详情描述: 常用于语音游戏场景中，用户可通过创建的范围语音实例对象使用范围语音相关功能。
 *
 */
var ZegoExpressRangeAudio = /** @class */ (function () {
    function ZegoExpressRangeAudio(engine) {
        this.zegoAudioListener = ZegoAudioListener_1.default.getInstance(engine);
    }
    ZegoExpressRangeAudio.getInstance = function (engine) {
        if (!ZegoExpressRangeAudio.instance) {
            if (!engine) {
                throw Error("create instance failed.");
            }
            ZegoExpressRangeAudio.instance = new ZegoExpressRangeAudio(engine);
        }
        return ZegoExpressRangeAudio.instance;
    };
    /**
     * 注册回调事件。
     *
     * Note: 支持版本：2.10.0 及以上
     *
     * Note: 详情描述：用于处理 SDK 主动通知开发者回调的接口，通过注册不同 event 的事件，可以收到不同功能的回调。可监听的事件回调可以通过 ZegoRangeAudioEvent 查看。
     *
     * Note: 业务场景：用于注册范围语音功能相关的业务事件的回调处理。
     *
     * Note: 调用时机：调用接口 createRangeAudioInstance 创建实例之后并且在调用接口 loginRoom 登录房间之前。
     *
     * Note: 注意事项：同样的事件可以注册多个, 相同的注册事件，会根据注册的先后顺序依次触发。
     *
     * Note: 相关接口：调用接口 off 来注销对应回调事件处理。
     *
     * @param event 监听事件名。
     * @param callBack 回调函数。
     *
     * @return 注册是否成功。
     */
    ZegoExpressRangeAudio.prototype.on = function (event, callBack) {
        return this.zegoAudioListener.on(event, callBack);
    };
    /**
     * 注销回调事件。
     *
     * Note: 支持版本：2.10.0 及以上
     *
     * Note: 详情描述：用于处理 SDK 主动通知开发者回调的接口，通过注册不同 event 的事件，可以收到不同功能的回调。用于删除注册的同一类回调事件。
     *
     * Note: 业务场景：用于注销范围语音功能相关的业务事件的回调处理。
     *
     * Note: 调用时机：调用接口 createRangeAudioInstance 创建实例之后。
     *
     * Note: 注意事项：如果没有传要注销的回调方法，将会注销所有该事件的回调。
     *
     * @param event 监听事件名。
     * @param callBack 回调函数。
     *
     * @return 注销回调是否成功。
     */
    ZegoExpressRangeAudio.prototype.off = function (event, callBack) {
        return this.zegoAudioListener.off(event, callBack);
    };
    /**
     * 设置音频接收距离的最大范围。
     *
     * Note: 支持版本：2.10.0 及以上
     *
     * Note: 详情描述：设置音频接收最大距离范围，超过该范围的音源声音会听不见，不设置的情况默认是无限范围。
     *
     * Note: 业务场景：范围语音中设置收听者的听觉范围。
     *
     * Note: 默认值：没有调用接口时默认是无距离限制，即听见房间内所有人的声音。
     *
     * Note: 注意事项: 该范围只对小队以外的人生效。
     *
     * Note: 调用时机：调用接口 createRangeAudioInstance 创建 ZegoExpressRangeAudio 实例后。
     *
     * @param range 音频范围, 取值必须大于等于 0。
     */
    ZegoExpressRangeAudio.prototype.setAudioReceiveRange = function (range) {
        this.zegoAudioListener.setAudioReceiveRange(range);
    };
    /**
     * 更新听者的位置和朝向。
     *
     * Note: 支持版本：2.10.0 及以上
     *
     * Note: 详情描述: 自身的位置和朝向，以便 SDK 计算出用户与音源距离以及左右耳立体声效果。
     *
     * Note: 业务场景：当用户在游戏中操作的角色在世界地图中移动时，更新角色的位置信息以及头部朝向。
     *
     * Note: 注意事项：在调用 enableSpeaker 打开扬声器之前如果没有调用该接口设置位置信息，则无法接收除小队以为其他人的声音。
     *
     * Note: 调用时机：创建 ZegoExpressRangeAudio 实例后和调用接口，调用接口 enableSpeaker 之前。
     *
     * @param position 自身在世界坐标系中的坐标，参数是长度为 3 的 number 数组，三个值依次表示前、右、上的坐标值。
     * @param axisForward 自身坐标系前轴的单位向量，参数是长度为 3 的 number 数组，三个值依次表示前、右、上的坐标值。
     * @param axisRight 自身坐标系右轴的单位向量，参数是长度为 3 的 number 数组，三个值依次表示前、右、上的坐标值。
     * @param axisUp 自身坐标系上轴的单位向量，参数是长度为 3 的 number 数组，三个值依次表示前、右、上的坐标值。
     */
    ZegoExpressRangeAudio.prototype.updateSelfPosition = function (position, axisForward, axisRight, axisUp) {
        this.zegoAudioListener.updateSelfPosition(position, axisForward, axisRight, axisUp);
    };
    /**
     * 添加或更新音源位置信息。
     *
     * Note: 支持版本：2.10.0 及以上
     *
     * Note: 详情描述：设置 userID 对应的音源在世界地图位置，以便 SDK 计算听者与音源的距离和方位。
     *
     * Note: 业务场景：更新发声用户在游戏地图坐标中的位置。
     *
     * Note: 调用时机：调用 loginRoom 登录房间后调用，登出房间后会清空记录的音源信息。
     *
     * @param userID 发声者用户 ID。
     * @param position 发声者在世界坐标系中的坐标，参数是长度为 3 的 number 数组，三个值依次表示前、右、上的坐标值。
     */
    ZegoExpressRangeAudio.prototype.updateAudioSource = function (userID, position) {
        this.zegoAudioListener.updateAudioSource(userID, position);
    };
    /**
     * 开关 3D 音效。
     *
     * Note: 支持版本：2.10.0 及以上
     *
     * Note: 详情描述：开启3D音效后将根据发声者相当于听者的位置模拟实际空间中的声音效果，直观的感受就是音源远近和方位发生变化时声音大小和左右声音差也会发生变化。enable 为true 时开启 3D 音效，为 false 时关闭 3D 音效。
     *
     * Note: 业务场景：第一人称射击游戏或社交场景游戏中听声辨位功能。
     *
     * Note: 默认值：在没有调用该接口前，默认是关闭3D音效。
     *
     * Note: 使用限制: 3D 音效只对小队以外的人的声音起作用。
     *
     * Note: 调用时机：调用接口 createRangeAudioInstance 初始化实例后。
     *
     * Note: 相关接口:  开启 3D 音效后可以调用 updateSelfPositon 和 updateAudioSource 更新位置和朝向来改变立体声效果。
     *
     * @param enable 是否开启，默认值是 true
     */
    ZegoExpressRangeAudio.prototype.enableSpatializer = function (enable) {
        return this.zegoAudioListener.enableSpatializer(enable);
    };
    /**
     * 开关麦克风。
     *
     * Note: 支持版本：2.10.0 及以上
     *
     * Note: 详情描述：enable 为 true 时开启麦克风并推送音频流，为 false 时关闭麦克风并停止推送音频流。
     *
     * Note: 业务场景：用户在房间内打开或关闭麦克风交流。
     *
     * Note: 默认值：在没有调用接口前，默认是关闭麦克风。
     *
     * Note: 调用时机：调用接口 createRangeAudioInstance 创建实例和调用接口 loginRoom 登录房间成功后。
     *
     * Note: 相关回调：通过回调 microphoneStateUpdate 来获取麦克风开关状态变化。
     *
     * @param enable 是否开启，默认值是 true
     */
    ZegoExpressRangeAudio.prototype.enableMicrophone = function (enable) {
        return this.zegoAudioListener.enableMicrophone(enable);
    };
    /**
     * 开关扬声器。
     *
     * Note: 支持版本：2.10.0 及以上
     *
     * Note: 详情描述：开启扬声器后会接收房间内其他开启麦克风的音源声音，enable 为true 时开始拉取和播放可拉取的音频流，为 false 时停止拉取和播放音频流。
     *
     * Note: 业务场景：用户选择是否接收其他人的发声。
     *
     * Note: 默认值：在没有调用接口前，默认是关闭接收音频。
     *
     * Note: 调用时机：调用接口 createRangeAudioInstance 创建实例和调用接口 loginRoom 登录房间成功后。
     *
     * @param enable 是否开启，默认值是 true
     */
    ZegoExpressRangeAudio.prototype.enableSpeaker = function (enable) {
        return this.zegoAudioListener.enableSpeaker(enable);
    };
    /**
     * 设置范围语音模式。
     *
     * Note: 支持版本：2.10.0 及以上
     *
     * Note: 详情描述：设置收听模式，可设置为“全世界”模式或“仅小队”模式。
     *
     * Note: 业务场景：用户想要只在小队范围交流或与房间内所有人交流。
     *
     * Note: 默认值：在不调接口设置时默认是“全世界”，可以与所有人交流。
     *
     * Note: 调用时机：通过 createRangeAudioInstance 初始化实例后。
     *
     * Note: 相关接口：要调接口 setTeamID 加入对应小队才能听到小队内的声音。
     *
     * @param mode 收听模式，mode 为 0 表示收听所有人，为 1 表示仅小队
     */
    ZegoExpressRangeAudio.prototype.setRangeAudioMode = function (mode) {
        this.zegoAudioListener.setRangeAudioMode(mode);
    };
    /**
     * 设置小队 ID。
     *
     * Note: 支持版本：2.10.0 及以上
     *
     * Note: 详情描述：设置队伍 ID 后，将能与同一队伍其他用户交流，且声音不会随距离方向产生变化。
     *
     * Note: 业务场景：用户想要加入队伍交流或退出队伍。
     *
     * Note: 默认值：默认值是 undefined , 表示不加入队伍。
     *
     * Note: 调用时机：通过 createRangeAudioInstance 初始化实例后。
     *
     * Note: 相关接口：调接口 etRangeAudioMode 设置为”仅小队“模式时只有队伍内进行交流。
     *
     * @param teamID 队伍 ID
     */
    ZegoExpressRangeAudio.prototype.setTeamID = function (teamID) {
        this.zegoAudioListener.setRangeAudioTeamID(teamID);
    };
    /**
     * 判断 AudioContext 对象是否已启用。
     *
     * Note: 支持版本：2.10.0 及以上
     *
     * Note: 详情描述：该接口主要是为了处理浏览器对自动播放策略的兼容性问题。通过接口 isAudioContextRunning 检测当前的 AudioContext 对象是否启用，如果没有启用将不支持自动播放声音。
     *
     * Note: 调用时机：调用 createRangeAudioInstance 创建实例后。
     *
     * Note: 相关接口：如果 AudioContext 对象没有启用，可以通过接口 resumeAudioContext 重新启用 AudioContext 对象。
     *
     * @return AudioContext 对象是否启用
     */
    ZegoExpressRangeAudio.prototype.isAudioContextRunning = function () {
        return this.zegoAudioListener.getAudioContextState() === "running";
    };
    /**
     * 重新启用内部的 AudioContext 对象。
     *
     * Note: 支持版本：2.10.0 及以上
     *
     * Note: 详情描述：该接口主要是为了处理浏览器对自动播放策略的兼容性问题。通过接口 isAudioContextRunning 检测当前的 AudioContext 对象没有启用，可以通过该接口重新启用。
     *
     * Note: 调用时机：调用 createRangeAudioInstance 创建实例后。
     *
     * Note: 注意事项：该接口必须要在 JavaScript 的点击事件中调用才会生效。
     *
     * Note: 相关接口：通过接口 isAudioContextRunning 检测当前的 AudioContext 对象没有启用。
     *
     * @return 是否重启成功
     */
    ZegoExpressRangeAudio.prototype.resumeAudioContext = function () {
        return this.zegoAudioListener.resumeAudioContext();
    };
    return ZegoExpressRangeAudio;
}());
exports.ZegoExpressRangeAudio = ZegoExpressRangeAudio;


/***/ }),

/***/ "./sdk/code/zh/index.ts":
/*!******************************!*\
  !*** ./sdk/code/zh/index.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoExpressEngine = exports.ClientUtil = void 0;
//@ts-nocheck
var zego_client_web_1 = __webpack_require__(/*! ./zego.client.web */ "./sdk/code/zh/zego.client.web.ts");
var message_1 = __importDefault(__webpack_require__(/*! zego-express-engine-webrtm/message */ "../zego_express_web_rtm/dist/message/index.js"));
var live_1 = __importDefault(__webpack_require__(/*! zego-express-engine-webrtm/live */ "../zego_express_web_rtm/dist/live/index.js"));
var advance_1 = __importDefault(__webpack_require__(/*! ../../src/modules/advance */ "./sdk/src/modules/advance/index.ts"));
var audioMix_1 = __importDefault(__webpack_require__(/*! ../../src/modules/audioMix */ "./sdk/src/modules/audioMix/index.ts"));
var mixstream_1 = __importDefault(__webpack_require__(/*! ../../src/modules/mixstream */ "./sdk/src/modules/mixstream/index.ts"));
var rangeaudio_1 = __webpack_require__(/*! ../../src/modules/rangeaudio */ "./sdk/src/modules/rangeaudio/index.ts");
var datachannel_1 = __webpack_require__(/*! ../../src/modules/datachannel */ "./sdk/src/modules/datachannel/index.ts");
var videoEffect_1 = __webpack_require__(/*! ../../src/modules/videoEffect */ "./sdk/src/modules/videoEffect/index.ts");
zego_client_web_1.ZegoExpressEngine.use(message_1.default);
zego_client_web_1.ZegoExpressEngine.use(live_1.default);
zego_client_web_1.ZegoExpressEngine.use(advance_1.default);
zego_client_web_1.ZegoExpressEngine.use(audioMix_1.default);
zego_client_web_1.ZegoExpressEngine.use(mixstream_1.default);
zego_client_web_1.ZegoExpressEngine.use(rangeaudio_1.RangeAudio);
zego_client_web_1.ZegoExpressEngine.use(datachannel_1.DataChannel);
zego_client_web_1.ZegoExpressEngine.use(videoEffect_1.BeautyEffect);
var zego_client_web_2 = __webpack_require__(/*! ./zego.client.web */ "./sdk/code/zh/zego.client.web.ts");
Object.defineProperty(exports, "ClientUtil", ({ enumerable: true, get: function () { return zego_client_web_2.ClientUtil; } }));
var ZegoExpressEngine = /** @class */ (function (_super) {
    __extends(ZegoExpressEngine, _super);
    function ZegoExpressEngine() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ZegoExpressEngine;
}(zego_client_web_1.ZegoExpressEngine));
exports.ZegoExpressEngine = ZegoExpressEngine;


/***/ }),

/***/ "./sdk/code/zh/zego.client.web.ts":
/*!****************************************!*\
  !*** ./sdk/code/zh/zego.client.web.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientUtil = exports.ZegoExpressEngine = void 0;
var zego_express_engine_webrtm_1 = __webpack_require__(/*! zego-express-engine-webrtm */ "../zego_express_web_rtm/dist/ZegoExpressWebRTM.js");
var index_1 = __webpack_require__(/*! ../../src/webrtc/index */ "./sdk/src/webrtc/index.ts");
/**
 * 实时音视频引擎
 *
 * Note: 详情描述：该类用于初始化 Express SDK 引擎实例。
 *
 */
var ZegoExpressEngine = /** @class */ (function (_super) {
    __extends(ZegoExpressEngine, _super);
    /**
       * 初始化 Engine
       *
       * Note: 支持版本：1.0.0
       *
       * Note: 详情描述：实例化对象。
       *
       * Note: 业务场景：所有场景必须。
       *
       * Note: 默认值：无默认值，所有参数必须填写。
       *
       * Note: 调用时机：第一个调用。
       *
       * Note: 使用限制：无
       *
       * Note: 注意事项：server 建议填写数组，备用域名抗弱网能力更强。
       *
       * Note: 影响范围：无
       *
       * Note: 相关回调：无
       *
       * Note: 相关接口：无
       *
       * Note: 平台差异：无
       *
       * @param appID 用于区分不同客户和项目的唯一标识（必须为 number 类型），且必须从即构控制台获取。一个 appID 对应一个客户项目，不同端共有一个 appID 实现互通 ，一个客户可以申请多个 appID。
  
       * @param server 表示 SDK 连接的即构服务器地址（支持备用域名），必须从控制台获取，SDK 内的大多数功能都通过该服务器地址交互 。同一个 appID 可以填写多个 server。
       */
    function ZegoExpressEngine(appID, server) {
        var _this = this;
        zego_express_engine_webrtm_1.ZegoExpressWebRTMEngine.version = "2.13.0";
        _this = _super.call(this, appID, server, 0, arguments[2]) || this;
        _this.zegoWebRTC = new index_1.ZegoWebRTC(_this.logger, _this.dataReport, _this.zegoWebRTM);
        return _this;
    }
    /**
     * 引入模块，可以通过该接口按需引入其他模块
     *
     * Note: 支持版本：2.10.0
     *
     * Note: 详情描述：如果 ZegoExpressEngine 是引用的是 core.js 的核心功能接口模块时，可以通过该接口来按需引入其他功能模块。
     *
     * Note: 调用时机：初始化 ZegoExpressEngine 实例后。
     *
     * @param module 功能模块
     */
    ZegoExpressEngine.use = function (module) {
        zego_express_engine_webrtm_1.ZegoExpressWebRTMEngine.use(module);
        index_1.ZegoWebRTC.use(module);
    };
    /**
     * 支持能力检测接口
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述：检测浏览器兼容性。
     *
     * Note: 业务场景：音视频中很多功能只有较新版本的主流浏览器才支持，可以通过该接口来检测。
     *
     * Note: 默认值：none
     *
     * Note: 调用时机：初始化之后，创建流之前调用。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项：真实支持度除了依赖浏览器外，还依赖系统， 因此有较低概率监测不准的情况。
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：无
     *
     * Note: 相关接口：无
     *
     * Note: 平台差异：无
     *
     * @param checkType? 浏览器所能支持能力的其中一个能力如: webRTC, VP8... 或者使用新方式检测浏览器能力支持
     * @param checkLevel 检测编码格式的等级，0 表示快速检测，准确率高。1 表示精准检测但可能消耗时间长，准确率更高。
     */
    ZegoExpressEngine.prototype.checkSystemRequirements = function (checkType, checkLevel) {
        if (checkLevel === void 0) { checkLevel = 0; }
        return this.zegoWebRTC.checkSystemRequirements(checkLevel, checkType);
    };
    /**
     * 删除注册过的回调事件
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述：ZegoEvent 包括了 [ZegoRTCEvent](https://doc-zh.zego.im/article/api?doc=Express_Video_SDK_API~javascript_web~interface~ZegoRTCEvent)  与 [ZegoRTMEvent](https://doc-zh.zego.im/article/api?doc=Express_Video_SDK_API~javascript_web~interface~ZegoRTMEvent)  ，用于处理 SDK 主动通知开发者回调的接口，用于删除注册的同一类回调事件。
     *
     * Note: 业务场景：通用接口，必选。
     *
     * Note: 调用时机：注册之后，退出房间之前。
     *
     * Note: 默认值：无
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项：同类事件有多个时，都会被删除。
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：无
     *
     * Note: 相关接口：无
     *
     * Note: 平台差异：无
     *
     * @param event 监听事件名
     * @param callBack? 回调函数，可选
     */
    ZegoExpressEngine.prototype.off = function (event, callBack) {
        if (this.zegoWebRTM.stateCenter.listenerList[event]) {
            return this.zegoWebRTM.off(event, callBack);
        }
        else if (this.zegoWebRTC.stateCenter.listenerList[event]) {
            return this.zegoWebRTC.off(event, callBack);
        }
        else {
            return false;
        }
    };
    /**
     * 注册回调事件
     *
     * Note: 支持版本：1.0.0 及以上
     *
     * Note: 详情描述：ZegoEvent 包括了 [ZegoRTCEvent](https://doc-zh.zego.im/article/api?doc=Express_Video_SDK_API~javascript_web~interface~ZegoRTCEvent) 与 [ZegoRTMEvent](https://doc-zh.zego.im/article/api?doc=Express_Video_SDK_API~javascript_web~interface~ZegoRTMEvent) ，用于处理 SDK 主动通知开发者回调的接口，通过注册不同 event 的事件，可以收到不同功能的回调。
     *
     * Note: 业务场景：通用接口，用于监听 SDK 的业务事件。
     *
     * Note: 调用时机：初始化实例之后，调用接口 loginRoom 登录房间之前。
     *
     * Note: 注意事项：同样的事件可以注册多个, 相同的注册事件，会根据注册的先后顺序依次触发。
     *
     * Note: 相关接口：调用接口 off 来注销对应回调事件处理。
     *
     * @param event 监听事件名。
     * @param callBack 回调函数。
     *
     * @return 注册是否成功。
     */
    ZegoExpressEngine.prototype.on = function (event, callBack) {
        if (this.zegoWebRTM.stateCenter.listenerList[event]) {
            return this.zegoWebRTM.on(event, callBack);
        }
        else if (this.zegoWebRTC.stateCenter.listenerList[event]) {
            return this.zegoWebRTC.on(event, callBack);
        }
        else {
            return false;
        }
    };
    /**
     * 创建推流数据源，包括摄像头麦克风采集源数据，屏幕共享数据，第三方源数据（能在页面播放的其他源数据）
     *
     * Note: 支持版本：1.0.0 及以上。
     *
     * Note: 详情描述：创建媒体流并设置推流相关参数，包括摄像头采集流、屏幕共享捕捉流、本地或者在线媒体流等多种类型。
     *
     * Note: 业务场景：用于获取摄像头画面或者当前屏幕画面。
     *
     * Note: 默认值：默认为摄像头采集流，默认为高清格式。
     *
     * Note: 调用时机：初始化且调用接口 checkSystemRequirements 检测返回的结果支持后可调用。
     *
     * Note: 注意事项：
     * 1. 移动端和 pc 端对视频宽高的理解不一样，两者恰好相反，同样的分辩率在 pc 端是横屏，在移动端就是竖屏。
     * 2. 必须在安全域名下（https,localhost,127.0.0.1）调用该接口。
     * 3. 推第三方流时，传入的  <video>  标签对应资源，必须加载成功后（媒体标签的 oncanplay 回调）才能调用该接口。
     * 4. 创建流时如果设置 video 为 false，即没有视频轨道，safari 拉流时也必须拉纯音频，否则无法播放。
     * 5. 如果有临时开闭音频或视频的需求，建议先推音视频流，再将对应不需要的音轨或视轨的 enable 设为 false, 推流后要开启音轨或视轨可以调用 replaceTrack 接口。
     * 6. 屏幕共享设置 source.screen.audio 为 true 时（仅windows 支持），只推送系统声音，不推送麦克风声音。
     * 7. 虽然 API 支持设置分辩率，但是很多设备对于自定义的分辨率并不支持，推荐使用参数 source.camera.videoQuality 或 source.screen.videoQuality 预设的几种分辨率。
     * 8. camera.channelCount 和 custom.channelCount 仅 chrome 内核浏览器支持。
     * 9. 设置开始码率参数 startBitrate 为 “target” (仅 chrome 内核支持)，推流时码率将快速上升，网络较差的情况可能会出现卡顿或花屏，所以建议使用默认缓慢上升的方式。
     *
     * Note: 相关回调：推流质量回调 publishQualityUpdate 的质量报文内容会跟设置参数相关；屏幕共享中断回调 screenSharingEnded 触发时会自动将媒体流销毁。
     *
     * Note: 相关接口：销毁创建的媒体流接口 destroyStream，开始推流接口 startPublishingStream。
     *
     * @param source? 创建媒体流的来源相关参数配置，不传默认是创建摄像头的媒体流
     *
     * @return promise 异步返回流媒体对象。
     */
    ZegoExpressEngine.prototype.createStream = function (source) {
        return this.zegoWebRTC.createStream(source);
    };
    /**
     * 在 Electron 框架时需要屏幕共享时调用，返回屏幕列表数据
     *
     * Note: 支持版本：2.11.0
     *
     * Note: 详情描述：在 Electron 框架时需要屏幕共享时调用，返回屏幕列表数据。
     *
     * Note: 业务场景：在 Electron 框架时需要屏幕共享时调用。
     *
     * Note: 调用时机：初始化之后。
     *
     * Note: 注意事项：无。
     *
     * Note: 相关回调：无。
     *
     * Note: 相关接口：createStream。
     *
     * @return electron 屏幕源列表数据
     */
    ZegoExpressEngine.prototype.getElectronScreenSources = function () {
        return this.zegoWebRTC.getElectronScreenSources();
    };
    /**
     * 销毁创建的流数据
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述：销毁流后对应的相关设备也会关闭，如摄像头、麦克风。
     *
     * Note: 业务场景：本地预览和推流必选。
     *
     * Note: 默认值：无
     *
     * Note: 调用时机：创建流后才能调用。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项： 推流过程中，销毁流会导致推流中断，销毁流之前请先停止推流，否则对端画面会卡住。
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：无
     *
     * Note: 相关接口：创建推流数据源 createStream。
     *
     * Note: 平台差异：无
     *
     * @param localStream 创建流得到的 stream
     */
    ZegoExpressEngine.prototype.destroyStream = function (localStream) {
        return this.zegoWebRTC.destroyStream(localStream);
    };
    /**
     * 开始推流
     *
     * Note: 支持版本：1.0.0 及以上。
     *
     * Note: 详情描述：将本地流推送到远端（即构服务器），推流状态回调通知推流成功后同一房间的其他用户可以通过 streamID 进行拉流。
     *
     * Note: 业务场景：推流时必选。
     *
     * Note: 默认值：publishOption.videoCodec 默认使用 H.264 推流，如果有特殊需求可选择 VP8，更多场景选择方案请先咨询 ZEGO 售前工程师。
     *
     * Note: 调用时机：调用接口 createStream 创建流成功后。
     *
     * Note: 相关回调：推流质量回调 publishQualityUpdate，推流状态回调 publisherStateUpdate（可通过该接口来判断推流是否成功）。
     *
     * Note: 相关接口：通过调用接口 stopPublishingStream 结束推流。
     *
     * @param streamID 推流 ID，长度不超过256的字符串，仅支持数字，英文字符 和 '~', '!', '@', '#', '$', '', '^', '&', '*', '(', ')', '_', '+', '=', '-', ', ';', '’', ',', '.', '<', '>', '/', ''
     * @param localStream 创建流得到的 stream。
     * @param publishOption? 推拉附加参数（鉴权、视频编码），可选。
     *
     * @return true 表示客户端发送请求成功，流成功推送到服务器需要通过流状态回调接口判断。
     */
    ZegoExpressEngine.prototype.startPublishingStream = function (streamID, localStream, publishOption) {
        return this.zegoWebRTC.startPublishingStream(streamID, localStream, publishOption);
    };
    /**
     * 停止将本地流推送到远端（即构服务器）
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述：停止推流。
     *
     * Note: 业务场景：推流时必选。
     *
     * Note: 默认值：无
     *
     * Note: 调用时机：推流成功后。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项： 停止推流不会导致渲染的 <video> 画面暂停，开发者需自行销毁 <video>。
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：推流质量回调 publishQualityUpdate，推流状态回调 publisherStateUpdate。
     *
     * Note: 相关接口：开始推流 startPublishingStream。
     *
     * Note: 平台差异：无
     *
     * @param streamID 推流 ID,和推流streamID保持一致
     */
    ZegoExpressEngine.prototype.stopPublishingStream = function (streamID) {
        return this.zegoWebRTC.stopPublishingStream(streamID);
    };
    /**
     * 修改推流参数
     *
     * Note: 支持版本：1.14.0
     *
     * Note: 详情描述：推流中修改推流相关参数，不建议频繁修改。
     *
     * Note: 业务场景：推流不是主 C 位时，降低分辨率节省带宽。
     *
     * Note: 默认值：无
     *
     * Note: 调用时机：推流成功后才能调用该接口。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项： 被修改的 localStream 必须是通过 SDK 调用 createStream 方法得到的。
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：推流质量回调 publishQualityUpdate。
     *
     * Note: 相关接口：无
     *
     * Note: 平台差异：无
     *
     * @param localStream 创建流得到的 stream
     * @param constraints 流的约束
     */
    ZegoExpressEngine.prototype.setVideoConfig = function (localStream, constraints) {
        return this.zegoWebRTC.setVideoConfig(localStream, constraints);
    };
    /**
     * 修改推流音频相关参数
     *
     * Note: 支持版本：1.14.0
     *
     * Note: 详情描述：推流中修改推流相关参数，不建议频繁修改。
     *
     * Note: 业务场景：主播外放背景音乐时，暂时关闭3A，防止被当做噪声消除。
     *
     * Note: 默认值：无
     *
     * Note: 调用时机：推流成功后才能调用该接口。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项： 被修改的 localStream 必须是通过 SDK 调用 createStream 方法得到的。
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：推流质量回调 publishQualityUpdate。
     *
     * Note: 相关接口：无
     *
     * Note: 平台差异：无
     *
     * @param localStream 创建流得到的 stream
     * @param constraints 流的约束
     */
    ZegoExpressEngine.prototype.setAudioConfig = function (localStream, constraints) {
        return this.zegoWebRTC.setAudioConfig(localStream, constraints);
    };
    /**
     * 替换媒体流的音视频轨道
     *
     * Note: 支持版本：1.13.0
     *
     * Note: 详情描述：替换已经创建的推流视轨或音轨
     *
     * Note: 业务场景：例如可以在摄像头、屏幕共享或视频之间切换视频轨道，在麦克风和 mp3 之间切换音频轨道。
     *
     * Note: 默认值：无
     *
     * Note: 调用时机：创建流成功后才能调用该接口。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项：被替换的 localStream 必须是通过 SDK 调用 createStream 方法得到的。
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：无
     *
     * Note: 相关接口：无
     *
     * Note: 平台差异：无
     *
     * @param localStream 创建流得到的 stream
     * @param mediaStreamTrack 音视频轨道
     */
    ZegoExpressEngine.prototype.replaceTrack = function (localStream, mediaStreamTrack) {
        return this.zegoWebRTC.replaceTrack(localStream, mediaStreamTrack);
    };
    /**
     * 创建流后可通过该接口调节采集音量
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述：调节当前采集的音量大小。
     *
     * Note: 业务场景：需要中途动态控制推流声音大小时。
     *
     * Note: 默认值：无
     *
     * Note: 调用时机：创建流成功后。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项： 创建流成功后才能调用该接口，进行混音后仅对采集的音轨有效，混音部分音量请使用setMixingAudioVolume 接口进行调节。
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：无
     *
     * Note: 相关接口：无
     *
     * Note: 平台差异：无
     *
     * @param localStream 需要修改音量的流对象
     * @param volume 音量大小，0-100
     */
    ZegoExpressEngine.prototype.setCaptureVolume = function (localStream, volume) {
        return this.zegoWebRTC.setCaptureVolume(localStream, volume);
    };
    /**
     * 设置流的附加信息
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述： 更改流附加信息。
     *
     * Note: 业务场景：需要对推流进行更丰富的描述，且希望拉流端能接受到这些信息时使用。
     *
     * Note: 默认值：无
     *
     * Note: 调用时机：推流成功后。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项： 只支持字符串。
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：流附加信息回调 streamExtraInfoUpdate。
     *
     * Note: 相关接口：无
     *
     * Note: 平台差异：无
     *
     * @param streamID 推流 ID
     * @param extraInfo 流附加信息; extraInfo为json格式字符串
     */
    ZegoExpressEngine.prototype.setStreamExtraInfo = function (streamID, extraInfo) {
        return this.zegoWebRTC.setStreamExtraInfo(streamID, extraInfo);
    };
    /**
     * 通知即构服务器将流转推到CDN
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述：当需要将音视频流转推到其它指定的 CDN 时，需要调用此接口进行设置（调用前请先联系 ZEGO 技术支持配置转推 CDN 功能）。
     *
     * Note: 业务场景：单向直播场景，拉流端使用 CDN 拉流。
     *
     * Note: 默认值：无
     *
     * Note: 调用时机：推流成功后。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项：
     *      建议使用服务端动态转推 CDN 中的增加转推 CDN 地址 API 替代该客户端 API。
     *      该接口调用有可能会失败，若返回成功，仅代表通知即构服务器成功，无法判断即构服务器是否转推 CDN 成功。
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：无
     *
     * Note: 相关接口：通知即构服务器停止将流转推到 CDN removePublishCdnUrl。
     *
     * Note: 平台差异：无
     *
     * @param streamID 推流 ID
     * @param targetURL CDN 转推地址，支持的转推地址格式有 rtmp
     */
    ZegoExpressEngine.prototype.addPublishCdnUrl = function (streamID, targetURL) {
        if (arguments.length === 3) {
            return this.zegoWebRTC.addPublishCdnUrl(
            // eslint-disable-next-line prefer-rest-params
            arguments[0], 
            // eslint-disable-next-line prefer-rest-params
            arguments[2]);
        }
        else {
            return this.zegoWebRTC.addPublishCdnUrl(streamID, targetURL);
        }
    };
    /**
     * 通知即构服务器停止将流转推到 CDN
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述： 当已经添加了某个 CDN 转推地址，需要停止将流转推至该 CDN 时调用此接口（调用前请先联系 ZEGO 技术支持配置转推 CDN 功能）。
     *
     * Note: 业务场景：单向直播场景，拉流端使用 CDN 拉流。
     *
     * Note: 默认值：无
     *
     * Note: 调用时机：转推成功后
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项：
     *      建议使用服务端动态转推 CDN 中的增加转推 CDN 地址 API 替代该客户端 API。
     *      该接口调用有可能会失败，若返回成功，仅代表通知即构服务器成功，无法判断即构服务器是否转推 CDN 成功。
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：无
     *
     * Note: 相关接口：通知即构服务器将流转推到 CDN addPublishCdnUrl。
     *
     * Note: 平台差异：无
     *
     * @param streamID 推流 ID
     * @param targetURL CDN 转推地址，支持的转推地址格式有 rtmp
     */
    ZegoExpressEngine.prototype.removePublishCdnUrl = function (streamID, targetURL) {
        if (arguments.length === 3) {
            return this.zegoWebRTC.removePublishCdnUrl(
            // eslint-disable-next-line prefer-rest-params
            arguments[0], 
            // eslint-disable-next-line prefer-rest-params
            arguments[2]);
        }
        else {
            return this.zegoWebRTC.removePublishCdnUrl(streamID, targetURL);
        }
    };
    /**
     * 关闭/打开正在推流的流画面
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述： 只是将数据降低为很小，视频轨还在。
     *
     * Note: 业务场景：主播在某一时段画面，不希望被拉流端看到时调用。
     *
     * Note: 调用时机：创建流成功后。
     *
     * Note: 注意事项：打开/关闭流画面的前提是原始流必须有视频轨道，创建流时不能为纯音频。
     *
     * Note: 相关回调：拉流摄像头状态回调 remoteCameraStatusUpdate。
     *
     * Note: 相关接口： 打开/关闭正在推流的流声音 mutePublishStreamAudio。
     *
     * @param localStream 创建流获取的 stream
     * @param mute 是否停止发送视频流；true 表示不发送视频流；false 表示发送视频流；默认为 false
     * @param retain 是否保留预览画面，布尔值，默认保留为 false 不保留预览画面
     *
     * @return 标识是否成功关闭推流画面
     */
    ZegoExpressEngine.prototype.mutePublishStreamVideo = function (localStream, mute, retain) {
        return this.zegoWebRTC.mutePublishStreamVideo(localStream, mute, retain);
    };
    /**
     * 打开/关闭正在推流的流声音，包括麦克风、混音背景音乐的声音
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述： 打开/关闭正在推流的流所有声音，包括麦克风、混音背景音乐的声音，音频轨依旧保留。
     *
     * Note: 业务场景：主播在某一时段不想让观众端听到声音。
     *
     * Note: 调用时机：创建流成功后。
     *
     * Note: 注意事项：
     * 1. 打开/关闭流声音的前提是原始流必须有音频轨道，创建流时不能为纯视频。
     * 2. 该接口会关闭所有流声音，包括麦克风、混流的背景音乐等声音，而 muteMicrophone 只会关闭麦克风的声音。
     *
     * Note: 相关回调：拉流麦克风状态回调 remoteMicStatusUpdate。
     *
     * Note: 相关接口： 关闭/打开正在推流的流画面 mutePublishStreamVideo；关闭/打开麦克风声音接口 muteMicrophone。
     *
     * @param localStream 创建流获取的 stream
     * @param mute 是否停止发送音频流；true 表示不发送音频流；false 表示发送音频流；默认为 false
     */
    ZegoExpressEngine.prototype.mutePublishStreamAudio = function (localStream, mute) {
        return this.zegoWebRTC.mutePublishStreamAudio(localStream, mute);
    };
    /**
     * 开启或关闭美颜
     *
     * Note: 支持版本：1.13.0 及以上。
     *
     * Note: 详情描述：可以通过该接口开关美颜和调整美颜参数，实现自然的美颜效果。
     *
     * Note: 业务场景：摄像头画面进行人像美颜。
     *
     * Note: 调用时机：调用接口 createStream 获取到媒体流后。
     *
     * Note: 注意事项：
     * 1. 美颜效果与对应的 MediaStream 绑定，当调用 useVideoDevice、replaceTrack 时不改变作用流的美颜效果。
     * 2. 美颜处理占用资源并消耗性能，当不需要使用美颜时需要及时调用 setEffectsBeauty(localStream,false) 关闭。
     * 3. 当调用 destroyStream 销毁流的同时 SDK 会关闭美颜效果, 其他情况 SDK 不会主动关闭美颜处理，需要自行调用 setEffectsBeauty(localStream,false) 关闭。
     * 4. 移动端设备的浏览器不支持开启美颜。
     *
     * Note: 相关回调：无.
     *
     * @param localStream 创建流得到的 MediaStream 对象。
     * @param enable 是否开启美颜，true 表示开启，false 表示关闭。
     * @param options 美颜选项，包含 smoothIntensity（磨皮）、whitenIntensity（美白）、rosyIntensity（红润）、sharpenIntensity（锐化）四个参数，可用来实现美颜效果。四个强度参数范围 0 - 100，默认值为 50, options 参数非必填。
     */
    ZegoExpressEngine.prototype.setEffectsBeauty = function (localStream, enable, options) {
        return this.zegoWebRTC.setBeautyEffect(localStream, enable, options);
    };
    /**
     * 开始拉流
     *
     * Note: 支持版本：1.0.0 及以上。
     *
     * Note: 详情描述：通过流 ID 拉取远端用户的媒体流。
     *
     * Note: 业务场景：拉流时必选。
     *
     * Note: 调用时机：收到新增拉流，即 roomStreamUpdate 回调后。
     *
     * Note: 注意事项：
     * 1. 拉流前确保该条流已经推成功（推送到 ZEGO 服务器），即拉流是在 roomStreamUpdate 回调后。
     * 2. 若推流端为单主播模式需通过 CDN 拉流 （不是该接口）。
     *
     * Note: 相关回调：拉流质量回调 playQualityUpdate，拉流状态回调 playerStateUpdate （可通过该回调来判断拉流是否成功）。
     *
     * Note: 相关接口：调用接口 stopPlayStream 结束拉流。
     *
     * @param streamID 流 ID ，必填。
     * @param playOption? 拉流附加参数，可选。
     *
     * @return promise 异步返回流媒体对象。
     */
    ZegoExpressEngine.prototype.startPlayingStream = function (streamID, playOption) {
        return this.zegoWebRTC.startPlayingStream(streamID, playOption);
    };
    /**
     * 停止拉取远端流（即构服务器）
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述：停止拉流，断开和即构服务器之间的连接，不再产生带宽。
     *
     * Note: 业务场景：拉流必选。
     *
     * Note: 默认值：无
     *
     * Note: 调用时机：拉流成功后。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项： 停止拉流后不会销毁播放器，播放器销毁需要开发者自己实现。
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：拉流质量回调 playQualityUpdate，拉流状态回调 playerStateUpdate。
     *
     * Note: 相关接口：开始拉流 startPlayStream。
     *
     * Note: 平台差异：无
     *
     * @param streamID 流 ID
     */
    ZegoExpressEngine.prototype.stopPlayingStream = function (streamID) {
        return this.zegoWebRTC.stopPlayingStream(streamID);
    };
    /**
     * 停止或恢复拉取视频流
     *
     * Note: 支持版本：1.15.0
     *
     * Note: 详情描述： 只是将数据降低为很小，视频轨还在。
     *
     * Note: 业务场景：观众在某一时段画面，不想看到主播画面时调用。
     *
     * Note: 默认值：无
     *
     * Note: 调用时机：拉流成功后。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项：停止或恢复拉取视频流的前提是原始流必须有视频轨道，拉流时不能为纯音频。
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：无
     *
     * Note: 相关接口： 停止或恢复拉取音频流 mutePlayStreamAudio。
     *
     * Note: 平台差异：无
     *
     * @param streamID 流ID
     * @param mute 是否拉取视频流，true 表示停止拉取；false 表示恢复拉取
     */
    ZegoExpressEngine.prototype.mutePlayStreamVideo = function (streamID, mute) {
        return this.zegoWebRTC.mutePlayStreamVideo(streamID, mute);
    };
    /**
     * 停止或恢复拉取音频流
     *
     * Note: 支持版本：1.15.0
     *
     * Note: 详情描述： 只是将数据降低为很小，音频轨还在。
     *
     * Note: 业务场景：观众在某一时段画面，不想听到主播声音时调用。
     *
     * Note: 默认值：无
     *
     * Note: 调用时机：拉流成功后。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项：停止或恢复拉取音频流的前提是原始流必须有音频轨道，拉流时不能为纯视频。
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：无
     *
     * Note: 相关接口： 停止或恢复拉取视频流 mutePlayStreamVideo。
     *
     * Note: 平台差异：无
     *
     * @param streamID 流ID
     * @param mute 是否拉取音频流，true 表示停止拉取；false 表示恢复拉取
     */
    ZegoExpressEngine.prototype.mutePlayStreamAudio = function (streamID, mute) {
        return this.zegoWebRTC.mutePlayStreamAudio(streamID, mute);
    };
    /**
     * 开始混流任务
     *
     * Note: 支持版本：1.5.2 及以上。
     *
     * Note: 详情描述：将多条流按照调用要求合成一条流。 由那个点于实际动作是在服务端操作，没有浏览器性能上的限制，且各个流之间延迟低，可以保证被混的多条流画面和声音同步。
     *
     * Note: 业务场景：通常用于多个主播连麦PK的场景，将多个主播的音视频流混合成一条流，观众端只需要拉这一条流。
     *
     * Note: 调用时机：调用接口 startPublishingStream 推流成功后。
     *
     * Note: 使用限制：混流前需要保证流还存在，避免发起混流和流删除操作同时触发，以免混流失败。被混的流如果中止推流，需要重新做混流处理，否则对端画面会卡住。
     *
     * Note: 注意事项：1. 应用对应的 AppID 开启了混流功能；2. 被混的流必须在 ZEGO 服务器上存在；3. 混流输入流列表接口 inputList 中的 “contentType” 均为 “AUDIO” 时，ZegoMixStreamOutputConfig 类下的 outputBitrate 、outputFPS 、outputWidth 、outputHeight 属性可不设置，默认设置为 “1”。
     *
     * Note: 安全性提醒：请勿在此接口填写用户敏感信息，包括但不限于手机号、身份证号、护照编号、真实姓名等。
     *
     * Note: 相关接口： 使用接口 stopMixerTask 来停止服务端混流，未及时停止混流功能会影响计费。
     *
     * @param mixStreamConfig 混流参数配置
     */
    ZegoExpressEngine.prototype.startMixerTask = function (mixStreamConfig) {
        return this.zegoWebRTC.startMixerTask(mixStreamConfig);
    };
    /**
     * 停止服务端混流
     *
     * Note: 支持版本：1.5.2 及以上。
     *
     * Note: 详情描述：用于停止 taskID 对应的服务端混流任务。
     *
     * Note: 业务场景：通常用于多个主播连麦 PK 的场景，混流画面使用结束后停止混流。
     *
     * Note: 调用时机：调用接口 startMixerTask 混流成功之后。
     *
     * Note: 注意事项：关闭页面一定要发起停止混流，避免异常关闭导致混流没有停止，影响计费；被混的流若中止推流，需要重新做混流处理，否则对端画面会卡住。
     *
     * Note: 安全性提醒：请勿在此接口填写用户敏感信息，包括但不限于手机号、身份证号、护照编号、真实姓名等。
     *
     * Note: 相关接口： 开始混流任务接口 startMixerTask
     *
     * @param taskID 混流任务 ID（客户自定义，务必保证唯一），必填，最大长度为 256 个字符，仅支持数字、英文字符 和 '~', '!', '@', '#', '$', '', '^', '&', '*', '(', ')', '_', '+', '=', '-', ', ';', '’', ',', '
     */
    ZegoExpressEngine.prototype.stopMixerTask = function (taskID) {
        return this.zegoWebRTC.stopMixerTask(taskID);
    };
    /**
     * 混流高级配置
     *
     * Note: 支持版本：1.5.2 及以上。
     *
     * Note: 详情描述：混流功能进阶设置，可以设置视频背景和视频编码格式。
     *
     * Note: 业务场景：1. 设置混流画面背景；2. 视频编码转换来兼容部分浏览器的播放。
     *
     * Note: 调用时机：推流成功后，而且需在使用 startMixerTask 之前调用才能生效。
     *
     * Note: 安全性提醒：请勿在此接口填写用户敏感信息，包括但不限于手机号、身份证号、护照编号、真实姓名等。
     *
     * Note: 相关接口：开始混流接口 startMixerTask
     *
     * @param config 混流高级功能设置。
     */
    ZegoExpressEngine.prototype.setMixerTaskConfig = function (config) {
        return this.zegoWebRTC.setMixerTaskConfig(config);
    };
    /**
     * 开始混音
     *
     * Note: 支持版本：1.7.0 及以上。
     *
     * Note: 详情描述：将 HTMLMediaElement 对象正在播放的声音混入对应 streamID 的推流中，使正在推的流中包含混入的声音。
     *
     * Note: 业务场景：通常用于背景音乐和音效。
     *
     * Note: 调用时机：调用 startPublishingStream 接口推流成功后。
     *
     * Note: 使用限制：混音不要同时包含 6 个以上，及 mediaList 长度不要大于 6，否则会出现性能问题，导致页面卡顿。
     *
     * Note: 注意事项：Chrome 浏览器自 86 版本起本地音频标签设置为静音，拉流端也无法听到混入的背景音。
     *
     * Note: 安全性提醒：请勿在此接口填写用户敏感信息，包括但不限于手机号、身份证号、护照编号、真实姓名等。
     *
     * Note: 影响范围：大部分接口都需要在登录房间后才能调用。
     *
     * Note: 相关接口：可调用接口 stopMixingAudio 来停止混音。
     *
     * @param streamID 需要混音的流 ID。
     * @param mediaList 1. 本地的 <audio> 或 <video> 对象数组。
     *                  2. 对音效的操作（包括暂停/恢复）需要通过操作 <audio> 或 <video> 对象来完成。
     */
    ZegoExpressEngine.prototype.startMixingAudio = function (streamID, mediaList) {
        return this.zegoWebRTC.startMixingAudio(streamID, mediaList);
    };
    /**
     * 停止混音
     *
     * Note: 支持版本：1.7.0 及以上。
     *
     * Note: 详情描述：通过传入的 mediaList ，控制对某个或多个背景音乐或音效的暂停，不传入该参数则停止该流的所有混音。
     *
     * Note: 业务场景：通常用于控制背景音乐和音效的暂停。
     *
     * Note: 调用时机：调用 stratMixingAudio 后。
     *
     * Note: 注意事项：通过能力检测接口 checkSystemRequirements 检查到 "customCapture" 为 false ，即浏览器不支持获取媒体元素的 MediaStream，则不能使用该接口。
     *
     * Note: 安全性提醒：请勿在此接口填写用户敏感信息，包括但不限于手机号、身份证号、护照编号、真实姓名等。
     *
     * Note: 影响范围：大部分接口都需要在登录房间后才能调用。
     *
     * Note: 相关接口： 开始混音接口 startMixingAudio
     *
     * @param streamID 正在混音的流 ID。
     * @param mediaList? 1. 本地的 <audio> 或 <video> 对象数组，可选。
     *                   2. 对音效的操作（包括暂停/恢复）需要通过操作 <audio> 或 <video> 对象来完成。
     */
    ZegoExpressEngine.prototype.stopMixingAudio = function (streamID, mediaList) {
        return this.zegoWebRTC.stopMixingAudio(streamID, mediaList);
    };
    /**
     * 设置混音音量
     *
     * Note: 支持版本：1.18.0 及以上。
     *
     * Note: 详情描述：通过传入的音量值和媒体元素，调节指定媒体元素的混入音量。
     *
     * Note: 业务场景：通常用于调节背景音乐或音效的音量大小。
     *
     * Note: 调用时机：调用接口 startMixingAudio 混音成功之后。
     *
     * Note: 注意事项：Chrome 浏览器自 86 版本起本地音频标签设置为静音，拉流端得到的混入音频没有声音。
     *
     * Note: 安全性提醒：请勿在此接口填写用户敏感信息，包括但不限于手机号、身份证号、护照编号、真实姓名等。
     *
     * Note: 影响范围：大部分接口都需要在登录房间后才能调用。
     *
     * Note: 相关接口：开始混音接口 startMixingAudio
     *
     * @param streamID 推流 ID。
     * @param volume 音量值，范围为 0～100，100 表示原始音量。
     * @param media 媒体标签 <video> 或 <audio>。
     */
    ZegoExpressEngine.prototype.setMixingAudioVolume = function (streamID, volume, media) {
        return this.zegoWebRTC.setMixingAudioVolume(streamID, volume, media);
    };
    /**
     * 获取设备硬件信息，为控制硬件设备接口，提供设备id参数。
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述：获取设备硬件信息，为控制硬件设备接口，提供设备 id 参数。
     *
     * Note: 业务场景：需要指定采集设备和输出设备时使用。
     *
     * Note: 默认值：无
     *
     * Note: 调用时机：初始化之后，创建流之前调用。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项：
     * 需要在安全域名下（https,localhost,127.0.0.1）调用该接口。
     * 不能完全信赖该接口，要对获取不到设备信息的情况做降级处理，例如：提示客户更换浏览器。
     * 某些平台浏览器（如：Safari，iOS）可能获取到的设备名称为空，建议再次调用此接口，即可获取到正确的设备名称。
     * 页面刷新后设备 ID 可能会有变化，需要重新获取。
     * 部分浏览器需要在调用 createStream 接口获取权限后，才可以获取到设备 ID。
     * safari 不支持获取扬声器信息。
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：无
     *
     * Note: 相关接口：createStream、useAudioDevice、useVideoDevice。
     *
     * Note: 平台差异：无
     */
    ZegoExpressEngine.prototype.enumDevices = function () {
        return this.zegoWebRTC.enumDevices();
    };
    /**
     * 切换摄像头
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述：切换当前推流使用的设备。
     *
     * Note: 业务场景：主播切换外接麦克风，使用硬件自带的音效处理。
     *
     * Note: 默认值：无
     *
     * Note: 调用时机：创建流成功后，且流类型必须是摄像头类型采集流。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项：如果切换摄像头失败，原来的流会保留，并返回错误。
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：无
     *
     * Note: 相关接口：切换麦克风 useAudioDevice。
     *
     * Note: 平台差异：无
     *
     * @param localStream 创建流获取的 stream
     * @param deviceID 需要切换的摄像头设备 ID
     */
    ZegoExpressEngine.prototype.useVideoDevice = function (localStream, deviceID) {
        return this.zegoWebRTC.useVideoDevice(localStream, deviceID);
    };
    /**
     * 切换麦克风
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述：切换当前推流使用的麦克风设备。
     *
     * Note: 业务场景：主播切换外接麦克风，使用硬件自带的音效处理。
     *
     * Note: 默认值：无
     *
     * Note: 调用时机：创建流成功后，且流类型必须是摄像头类型采集流。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项：如果切换麦克风失败，原来的流会保留，并返回错误。
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：无
     *
     * Note: 相关接口：切换麦克风 useVideoDevice。
     *
     * Note: 平台差异：无
     *
     * @param localStream 创建流获取的 stream
     * @param deviceID 需要切换的麦克风设备 ID
     */
    ZegoExpressEngine.prototype.useAudioDevice = function (localStream, deviceID) {
        return this.zegoWebRTC.useAudioDevice(localStream, deviceID);
    };
    /**
     * 设置是否监听音浪及音浪回调间隔时间
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述：设置后将通过 soundLevelUpdate 回调流的音量大小。
     *
     * Note: 业务场景：图形化显示拉流音浪时调用。
     *
     * Note: 默认值：无
     *
     * Note: 调用时机：初始化实例后。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项： 无
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：推拉流音浪回调 soundLevelUpdate 、本地预览流音浪回调 capturedSoundLevelUpdate。
     *
     * Note: 相关接口：无
     *
     * Note: 平台差异：无
     *
     * @param bool 开启或关闭音浪回调
     * @param interval? 需要回调的时间间隔，默认1000ms，可选
     */
    ZegoExpressEngine.prototype.setSoundLevelDelegate = function (bool, interval) {
        return this.zegoWebRTC.setSoundLevelDelegate(bool, interval);
    };
    /**
     * 获取麦克风静音状态
     *
     * Note: 支持版本：2.8.0 及以上。
     *
     * Note: 详情描述： 获取麦克风静音状态。
     *
     * Note: 业务场景：用于判断主播自己的麦克风是否打开了。
     *
     * Note: 调用时机：调用 loginRoom 接口登录房间成功后。
     *
     * Note: 相关接口： 调用 muteMicrophone 关闭/打开麦克风声音接口。
     *
     * @return 是否静音，true 为静音，false 为打开麦克风声音。
     */
    ZegoExpressEngine.prototype.isMicrophoneMuted = function () {
        return this.zegoWebRTC.isMicrophoneMuted();
    };
    /**
     * 是否静音麦克风声音
     *
     * Note: 支持版本：2.8.0 及以上。
     *
     * Note: 详情描述：将麦克风的声音静音，推流时也不会带上麦克风采集的声音。
     *
     * Note: 业务场景：主播在某一时段内，不希望被拉流端听到麦克风声音时调用。
     *
     * Note: 调用时机：初始化实例后。
     *
     * Note: 注意事项：是否静音麦克风的前提是原始流必须有音频轨道，创建流时不能为纯视频。
     *
     * Note: 相关接口：调用 isMicrophoneMuted 接口获取麦克风静音状态；调用 mutePublishStreamAudio 接口关闭/打开正在推流的声音 。
     *
     * @param mute 是否静音麦克风；true 表示静音麦克风；false 表示打开麦克风；不设置默认为 false。
     */
    ZegoExpressEngine.prototype.muteMicrophone = function (mute) {
        return this.zegoWebRTC.muteMicrophone(mute);
    };
    /**
     * 创建范围语音实例对象。
     *
     * Note: 支持版本：2.10.0 及以上
     *
     * Note: 详情描述：创建范围语音实例对象。
     *
     * Note: 业务场景：常用于语音游戏场景中，用户可通过创建的范围语音实例对象使用范围语音相关功能。
     *
     * Note: 调用时机：创建 ZegoExpressEngine 实例后并在调用接口 loginRoom 登录房间前调用。
     *
     * Note: 注意事项:  使用范围语音功能不能再调用 startPublishingStream 、startPlayingStream 这些推拉流接口以及相关回调。
     *
     * @return 范围语音实例对象
     */
    ZegoExpressEngine.prototype.createRangeAudioInstance = function () {
        return this.zegoWebRTC.createRangeAudioInstance();
    };
    /**
     * 创建实时有序数据实例对象
     *
     * Note: 支持版本：2.12.2 及以上
     *
     * Note: 详情描述：实时有序数据实例对象。
     *
     * Note: 业务场景：常用于远程控制场景中，用户可通过创建的实时有序数据实例对象使用实时有序数据令相关功能。
     *
     * Note: 调用时机：创建 ZegoExpressEngine 实例后调用。
     *
     * @param roomID 房间ID
     *
     * @return 实时有序数据实例对象
     */
    ZegoExpressEngine.prototype.createRealTimeSequentialDataManager = function (roomID) {
        return this.zegoWebRTC.createRealTimeSequentialDataManager(roomID);
    };
    /**
     * 销毁实时有序数据实例对象
     *
     * Note: 支持版本：2.12.2 及以上
     *
     * Note: 详情描述：销毁实时有序数据实例对象。
     *
     * Note: 业务场景：常用于远程控制场景中，用户可通过创建的实时有序数据实例对象使用实时有序数据相关功能。
     *
     * Note: 调用时机：创建 ZegoExpressEngine 实例及 createRealTimeSequentialDataManager 后调用。
     *
     * @param manager 实时有序数据对象
     */
    ZegoExpressEngine.prototype.destroyRealTimeSequentialDataManager = function (manager) {
        this.zegoWebRTC.destroyRealTimeSequentialDataManager(manager);
    };
    return ZegoExpressEngine;
}(zego_express_engine_webrtm_1.ZegoExpressWebRTMEngine));
exports.ZegoExpressEngine = ZegoExpressEngine;
var client_util_1 = __webpack_require__(/*! ../../src/util/client-util */ "./sdk/src/util/client-util.ts");
Object.defineProperty(exports, "ClientUtil", ({ enumerable: true, get: function () { return client_util_1.ClientUtil; } }));


/***/ }),

/***/ "./sdk/src/common/action.ts":
/*!**********************************!*\
  !*** ./sdk/src/common/action.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// import * as fs from "fs";
// import * as path from "path";
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZEGO_WECHATMINI_ACTION = exports.ZEGO_WEBRTC_ACTION = void 0;
// ****** sdk函数映射************//
var ZEGO_WEBRTC_ACTION;
(function (ZEGO_WEBRTC_ACTION) {
    ZEGO_WEBRTC_ACTION["CONSTRUCTOR"] = "zc.0";
    ZEGO_WEBRTC_ACTION["CHECK_SUPPORT"] = "zc.csr";
    ZEGO_WEBRTC_ACTION["CREATE_STREAM"] = "zc.cs";
    ZEGO_WEBRTC_ACTION["DESTROY_STREAM"] = "zc.ds";
    ZEGO_WEBRTC_ACTION["START_PUBLISHING_STREAM"] = "zc.sps.0";
    ZEGO_WEBRTC_ACTION["START_PLAYING_STREAM"] = "zc.sps.1";
    ZEGO_WEBRTC_ACTION["STOP_PUBLISHING_STREAM"] = "zc.sps.0.0";
    ZEGO_WEBRTC_ACTION["STOP_PLAYING_STREAM"] = "zc.sps.1.0";
    ZEGO_WEBRTC_ACTION["ON_STREAM"] = "zc.os";
    ZEGO_WEBRTC_ACTION["ON_PUSH_STREAM_UPDATE"] = "zc.opsu";
    ZEGO_WEBRTC_ACTION["BIND_WINDOW_LISTENER"] = "zc.wl";
    ZEGO_WEBRTC_ACTION["SET_AUDIO_OUTPUT"] = "zc.sao";
    ZEGO_WEBRTC_ACTION["SET_CUSTOM_SIGNAL_URL"] = "zc.scsu";
    ZEGO_WEBRTC_ACTION["SET_TURN_OVER_TCP_ONLY"] = "zc.stoto";
    ZEGO_WEBRTC_ACTION["RDH_ACTIVE"] = "zc.rdh.a";
    ZEGO_WEBRTC_ACTION["RDH_MAX_TIME"] = "zc.rdh.m";
    ZEGO_WEBRTC_ACTION["RDH_WEBRTC_URL_RSP"] = "zc.rdh.hfwur";
    ZEGO_WEBRTC_ACTION["PUBLISH_STATE_HANDLE"] = "zc.psh.0";
    ZEGO_WEBRTC_ACTION["PLAY_STATE_HANDLE"] = "zc.psh.1";
    ZEGO_WEBRTC_ACTION["STATECENTER_ACTION_LISTENER"] = "zc.sc.al";
    ZEGO_WEBRTC_ACTION["STATECENTER_SET_SETTING"] = "zc.sc.ss";
    ZEGO_WEBRTC_ACTION["SIGNAL_SET_SESSION_INFO"] = "zc.s.ssi";
    ZEGO_WEBRTC_ACTION["SIGNAL_RESET_CONNECT_TIMER"] = "zc.s.rct";
    ZEGO_WEBRTC_ACTION["SIGNAL_BIND_WEBSOCKET_HANDLE"] = "zc.s.bwh";
    ZEGO_WEBRTC_ACTION["SIGNAL_RESET_CHECK_MESSAGE"] = "zc.s.rcm";
    ZEGO_WEBRTC_ACTION["SIGNAL_UPDATE_TOKEN"] = "zc.s.ut";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_MESSAGE_WITH_CALLBACK"] = "zc.s.smwc";
    ZEGO_WEBRTC_ACTION["SIGNAL_CONNECT_SERVER"] = "zc.s.cs.0";
    ZEGO_WEBRTC_ACTION["SIGNAL_START_CONNECT_TIMER"] = "zc.s.sct";
    ZEGO_WEBRTC_ACTION["SIGNAL_DISCONNECT_SERVER"] = "zc.s.dc";
    ZEGO_WEBRTC_ACTION["SIGNAL_CREATE_SESSION"] = "zc.s.cs.1";
    ZEGO_WEBRTC_ACTION["SIGNAL_REMOVE_SESSION"] = "zc.s.rs";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_REMOVE_SESSION"] = "zc.s.srs";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_MESSAGE"] = "zc.s.sm";
    ZEGO_WEBRTC_ACTION["SIGNAL_HANDLE_RESPOND_DATA"] = "zc.s.hrd";
    ZEGO_WEBRTC_ACTION["SIGNAL_ADD_SESSION"] = "zc.s.as";
    ZEGO_WEBRTC_ACTION["SIGNAL_HANDLE_PUSH_DATA"] = "zc.s.hpd";
    ZEGO_WEBRTC_ACTION["SIGNAL_HANDLE_PUSH_RESET_SESSION_DATA"] = "zc.s.hprsd";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_MEDIA_DESC"] = "zc.s.smd";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_CANDIDATE_INFO"] = "zc.s.sci";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_MEDIA_DESC_ACK"] = "zc.s.smda";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_CANDIDATE_INFO_ACK"] = "zc.s.scia";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_CLOSE_SESSION_ACK"] = "zc.s.scsa";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_RESET_SESSION_ACK"] = "zc.s.srsa";
    ZEGO_WEBRTC_ACTION["SIGNAL_REGISTER_PUSH_CALLBACK"] = "zc.s.rpc";
    ZEGO_WEBRTC_ACTION["SIGNAL_CHECK_MESSAGE_TIMEOUT"] = "zc.s.cmt";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_HEARTBEAT"] = "zc.s.sh";
    ZEGO_WEBRTC_ACTION["SIGNAL_QUALITY_REPORT"] = "zc.s.qr";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_STREAM_STATUS"] = "zc.s.sss";
    ZEGO_WEBRTC_ACTION["SIGNAL_ACTIVE_PLAY_VIDEO_STREAM"] = "zc.s.apvs";
    ZEGO_WEBRTC_ACTION["SIGNAL_ACTIVE_PLAY_AUDIO_STREAM"] = "zc.s.apas";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_BROADCAST_STATUS"] = "zc.s.sbs";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_NET_PROBE"] = "zc.s.snp";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_NET_QUALITY_INFO_PUSH_ACK"] = "zc.s.npa";
    ZEGO_WEBRTC_ACTION["PUBLISHER_START_PUBLISH"] = "zc.p.0.sp.0";
    ZEGO_WEBRTC_ACTION["PUBLISHER_PUBLISH_SUCCESS"] = "zc.p.ps";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS"] = "zc.p.0.ocpss";
    ZEGO_WEBRTC_ACTION["PUBLISHER_HANDLE_CREATE_SESSION_WITH_SDP"] = "zc.p.0.hcsws";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_CREATE_OFFER_SUCCESS"] = "zc.p.0.ocos";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_SET_LOCAL_DESCRIPTION_SUCCESS"] = "zc.p.0.oslds";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_GET_REMOTE_DESCRIPTION"] = "zc.p.0.ogrd";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_RECV_MEDIA_DESC"] = "zc.p.0.ormd";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_RECV_CANDIDATE_INFO"] = "zc.p.0.orci.0";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_RECV_PUBLISH_EVENT"] = "zc.p.0.orpe";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_RECV_CLIENT_INFO"] = "zc.p.0.orci.1";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_ICE_CANDIDATE"] = "zc.p.0.oic";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_CONNECTION_STATE_CHANGE"] = "zc.p.0.ocsc";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_ICE_CONNECTION_STATE_CHANGE"] = "zc.p.0.oicsc";
    ZEGO_WEBRTC_ACTION["PUBLISHER_RESET_PUBLISH"] = "zc.p.0.rp";
    ZEGO_WEBRTC_ACTION["PUBLISHER_SET_PLAYER_QUALITY_TIMER"] = "zc.p.0.spqt";
    ZEGO_WEBRTC_ACTION["PUBLISHER_UPLOAD_PUBLISH_QUALITY"] = "zc.p.0.upq";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_RECV_RESET_SESSION"] = "zc.p.0.orrs";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_RECV_CLOSE_SESSION"] = "zc.p.0.orcs";
    ZEGO_WEBRTC_ACTION["PUBLISHER_SEND_CANDIDATE_INFO"] = "zc.p.0.sci";
    ZEGO_WEBRTC_ACTION["PUBLISHER_STATE_ERROR"] = "zc.p.0.psr";
    ZEGO_WEBRTC_ACTION["PUBLISHER_STOP_PUBLISH"] = "zc.p.0.sp.1";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_DISCONNECT"] = "zc.p.0.od";
    ZEGO_WEBRTC_ACTION["PUBLISHER_START_SOUND_LEVEL"] = "zc.p.0.ssl.0";
    ZEGO_WEBRTC_ACTION["PUBLISHER_STOP_SOUND_LEVEL"] = "zc.p.0.ssl.1";
    ZEGO_WEBRTC_ACTION["PUBLISHER_HANDLE_ENC_BITRATE"] = "zc.p.0.heb";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_RECV_NET_QUALITY_INFO"] = "zc.p.0.nqi";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_RECV_UPDATE_MEDIA_DESC"] = "zc.p.0.orumd";
    ZEGO_WEBRTC_ACTION["PLAYER_START_PLAY"] = "zc.p.1.sp.0";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS"] = "zc.p.ocpss.1";
    ZEGO_WEBRTC_ACTION["PLAYER_HANDLE_CREATE_SESSION_WITH_SDP"] = "zc.p.hcsws.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_CREATE_OFFER_SUCCESS"] = "zc.p.ocos.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_SET_LOCAL_DESCRIPTION_SUCCESS"] = "zc.p.oslds.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_RECV_MEDIA_DESC"] = "zc.p.ormd.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_RECV_CANDIDATE_INFO"] = "zc.p.orci.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_RECV_PLAY_EVENT"] = "zc.p.orpe.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_RECV_CLIENT_INFO"] = "zc.p.orci.1.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_ICE_CANDIDATE"] = "zc.p.oic.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_CONNECTION_STATE_CHANGE"] = "zc.p.ocsc.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_ICE_CONNECTION_STATE_CHANGE"] = "zc.p.oicsc.1";
    ZEGO_WEBRTC_ACTION["PLAYER_RESET_PLAY"] = "zc.p.rp.1";
    ZEGO_WEBRTC_ACTION["PLAYER_SET_PLAYER_QUALITY_TIMER"] = "zc.p.spqt.1";
    ZEGO_WEBRTC_ACTION["PLAYER_UPLOAD_PLAYER_QUALITY"] = "zc.p.upq.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_RECV_RESET_SESSION"] = "zc.p.orrs.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_RECV_CLOSE_SESSION"] = "zc.p.orcs.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_RECV_STREAM_STATUS"] = "zc.p.orss.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_GOT_REMOTE_STREAM"] = "zc.p.ogrs.1";
    ZEGO_WEBRTC_ACTION["PLAYER_SEND_CANDIDATE_INFO"] = "zc.p.sci.1";
    ZEGO_WEBRTC_ACTION["PLAYER_STATE_ERROR"] = "zc.p.psr.1";
    ZEGO_WEBRTC_ACTION["PLAYER_STOP_PLAY"] = "zc.p.1.sp.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_DISCONNECT"] = "zc.p.od.1";
    ZEGO_WEBRTC_ACTION["PLAYER_START_SOUND_LEVEL"] = "zc.p.ssl.1";
    ZEGO_WEBRTC_ACTION["PLAYER_STOP_SOUND_LEVEL"] = "zc.p.ssl.1.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_RECV_NET_QUALITY_INFO"] = "zc.p.1.nqi";
    ZEGO_WEBRTC_ACTION["PUBLISH_SET_CAPTURE_VOLUME"] = "zc.p.scv";
    ZEGO_WEBRTC_ACTION["PUBLISH_SET_BEAUTY_EFFECT"] = "zc.p.0.sbe";
    ZEGO_WEBRTC_ACTION["STREAMHANDLER_MERGE_STREAM_BY_STREAM_SEQ"] = "zc.sh.msbss";
    ZEGO_WEBRTC_ACTION["STREAMHANDLER_MERGE_STREAM"] = "zc.sh.ms";
    ZEGO_WEBRTC_ACTION["STREAMHANDLER_PATCH_STREAM_LIST"] = "zc.sh.psl"; //心跳流处理
})(ZEGO_WEBRTC_ACTION = exports.ZEGO_WEBRTC_ACTION || (exports.ZEGO_WEBRTC_ACTION = {}));
var ZEGO_WECHATMINI_ACTION;
(function (ZEGO_WECHATMINI_ACTION) {
    ZEGO_WECHATMINI_ACTION["ADD_PUBLISH_CDN_URL"] = "zw.apcu";
    ZEGO_WECHATMINI_ACTION["REMOVE_PUBLISH_CDN_URL"] = "zw.rpcu";
    ZEGO_WECHATMINI_ACTION["STOP_MIXER_TASK"] = "zw.smt";
    ZEGO_WECHATMINI_ACTION["ON_STREAM"] = "zw.os";
    ZEGO_WECHATMINI_ACTION["ON_PUSH_STREAM_UPDATE"] = "zw.opsu";
    ZEGO_WECHATMINI_ACTION["ON_PUBLISH_STATE_UPDATE"] = "zw.w.opsu";
    ZEGO_WECHATMINI_ACTION["ON_PUBLISH_STATE_UPDATE_HANDLE"] = "zw.w.opsuh";
    ZEGO_WECHATMINI_ACTION["WECHATMINI_SETPREFERPLAYSOURCETYPE"] = "zw.w.sppst.1";
    ZEGO_WECHATMINI_ACTION["WECHATMINI_BIND_LISTENER"] = "zw.w.bl";
    ZEGO_WECHATMINI_ACTION["WECHATMINI_DELETE_LISTENER"] = "zw.w.dl";
    ZEGO_WECHATMINI_ACTION["WECHATMINI_UPDATE_PLAYER_STATE"] = "zw.w.ups";
    ZEGO_WECHATMINI_ACTION["WECHATMINI_UPDATE_PLAYER_NET_STATUS"] = "zw.w.upns";
    ZEGO_WECHATMINI_ACTION["WECHATMINI_SET_CUSTOM_SIGNAL_URL"] = "zw.w.scsu";
    ZEGO_WECHATMINI_ACTION["WECHATMINI_GET_NEXT_URL"] = "zw.w.gnu";
    ZEGO_WECHATMINI_ACTION["WECHATMINI_BIND_STREAM_CENTER_HANDLER"] = "zw.w.bsch";
    ZEGO_WECHATMINI_ACTION["WECHATMINI_BIND_RTM_LISTENER"] = "zw.w.brl";
    ZEGO_WECHATMINI_ACTION["PUBLISHMODULE_SET_PREFER_PUBLISH_SOURCE_TYPE"] = "zw.pu.sppst.0";
    ZEGO_WECHATMINI_ACTION["PUBLISHMODULE_START_PUBLISHING_STREAM"] = "zw.pu.sps.0";
    ZEGO_WECHATMINI_ACTION["PUBLISHMODULE_STOP_PUBLISHING_STREAM"] = "zw.pu.sps.0.0";
    ZEGO_WECHATMINI_ACTION["PUBLISHMODULE_FETCH_PUBLISH_STREAM_URL"] = "zw.pu.fpsu.0";
    ZEGO_WECHATMINI_ACTION["PUBLISHMODULE_HANDLE_FETCH_STREAM_PUBLISH_URL_RSP"] = "zw.pu.hfspur.0";
    ZEGO_WECHATMINI_ACTION["PUBLISHMODULE_DO_PUBLISH_STREAM"] = "zw.pu.dps.0";
    ZEGO_WECHATMINI_ACTION["PUBLISHMODULE_UPDATE_STREAM_INFO"] = "zw.pu.upi";
    ZEGO_WECHATMINI_ACTION["PUBLISHMODULE_HANDLE_STREAM_UPDATE_RSP"] = "zw.pu.hsur";
    ZEGO_WECHATMINI_ACTION["PLAYMODULE_START_PLAYING_STREAM"] = "zw.pl.sps.1";
    ZEGO_WECHATMINI_ACTION["PLAYMODULE_STOP_PLAYING_STREAM"] = "zw.pl.sps.1.0";
    ZEGO_WECHATMINI_ACTION["PLAYMODULE_START_PLAYING_STREAM_FROM_CDN"] = "zw.pl.spsfc";
    ZEGO_WECHATMINI_ACTION["PLAYMODULE_START_PLAYING_STREAM_FROM_BGP"] = "zw.pl.spsfb";
    ZEGO_WECHATMINI_ACTION["PLAYMODULE_DO_PLAY_STREAM"] = "zw.pl.dps";
    ZEGO_WECHATMINI_ACTION["PLAYMODULE_FETCH_PLAY_STREAM_URL"] = "zw.pl.fpsu";
    ZEGO_WECHATMINI_ACTION["PLAYMODULE_HANDLE_FETCH_STREAM_URL_RSP"] = "zw.pl.hfsur";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_RESET"] = "zw.scw.r.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_START_PUBLISHING_STREAM"] = "zw.scw.sps.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_START_PLAYING_STREAM"] = "zw.scw.sps.1";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_START_PLAYER"] = "zw.scw.sp.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_ON_STREAM_URL_UPDATE"] = "zw.scw.opuu.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_UPDATE_PLAYER_STATE"] = "zw.scw.ups.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_UPDATE_PLAYER_NET_STATUS"] = "zw.scw.upns";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_UPDATE_PUBLISHING_STATE"] = "zw.scw.ups.0.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_UPDATE_PLAYING_STATE"] = "zw.scw.ups.1.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_GET_NEXT_URL"] = "zw.scw.gnu";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_STOP_PUBLISHING_STREAM"] = "zw.scw.sps.0.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_STOP_PLAYING_STREAM"] = "zw.scw.sps.1.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_STOP_PLAYER"] = "zw.scw.sp.1";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_ON_PLAY_START"] = "zw.scw.ops.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_ON_PLAY_STOP"] = "zw.scw.ops.1";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_ON_PLAY_RETRY"] = "zw.scw.opr";
    ZEGO_WECHATMINI_ACTION["PLAYWECHAT_TRY_START_PLAYER"] = "zw.pw.tsp.0";
    ZEGO_WECHATMINI_ACTION["PLAYWECHAT_UPDATE_EVENT"] = "zw.pw.ue";
    ZEGO_WECHATMINI_ACTION["PLAYWECHAT_GET_PLAY_URL"] = "zw.pw.gpu"; //获取地址
    // PLAYMODULE_
})(ZEGO_WECHATMINI_ACTION = exports.ZEGO_WECHATMINI_ACTION || (exports.ZEGO_WECHATMINI_ACTION = {}));
// const _path = path.resolve(__dirname, "action.ts");
// fs.readFile(_path, "utf8", (err, data) => {
//   if (err) {
//     console.error(err);
//   } else {
//     const actionArr: Array<string> = [];
//     const reg = /([A-Z])\w+ = "(.*)".*\/\/([\u4e00-\u9fa5_a-zA-Z0-9]+)/g;
//     data.replace(reg, (target, p, key, value, _content): any => {
//       actionArr.push(`${key} : ${value}`);
//     });
//     fs.writeFile(
//       path.resolve(__dirname, "../../../doc/action.log"),
//       actionArr.join("\r"),
//       "utf8",
//       err => {
//         console.log(err);
//       }
//     );
//   }
// });


/***/ }),

/***/ "./sdk/src/common/setting.config.ts":
/*!******************************************!*\
  !*** ./sdk/src/common/setting.config.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RTC = exports.ZegoSettingConfig = void 0;
var ZegoSettingConfig = /** @class */ (function () {
    function ZegoSettingConfig() {
        this.defaultSetting = {
            publish_video_codec: "H264",
            // publish_stream_video_bitrate: 800,
            camera_video_bitrate: 800,
            screen_video_bitrate: 1500,
            custom_video_bitrate: 0,
            l3_play_buffer_ms: 500,
            AEC: true,
            AGC: true,
            ANS: true,
            resource_mode: 0,
            bitrate_mode: "default"
        };
        this.setting = JSON.parse(JSON.stringify(this.defaultSetting));
    }
    ZegoSettingConfig.getInstance = function () {
        if (!ZegoSettingConfig.instance) {
            ZegoSettingConfig.instance = new ZegoSettingConfig();
        }
        return ZegoSettingConfig.instance;
    };
    ZegoSettingConfig.prototype.setSetting = function (settingFile, changeItems) {
        var isDynamic = Array.isArray(changeItems) && changeItems.length > 0;
        for (var settingGroup in settingFile) {
            for (var settingItem in settingFile[settingGroup]) {
                // 配置项不以 _enable 结尾，覆盖默认项固定以 _enable 结尾，强制覆盖项以 _force 结尾
                if (!settingItem.endsWith("_ctrlmode")) {
                    if (isDynamic && changeItems.indexOf(settingItem) == -1) {
                        continue;
                    }
                    var _mode = settingFile[settingGroup][settingItem + "_ctrlmode"];
                    if (_mode === 1 || _mode === 2) {
                        this.setting[settingItem] = settingFile[settingGroup][settingItem];
                    }
                    else {
                        this.defaultSetting[settingItem] &&
                            (this.setting[settingItem] = this.defaultSetting[settingItem]);
                    }
                    typeof _mode === "number" &&
                        (this.setting[settingItem + "_ctrlmode"] =
                            settingFile[settingGroup][settingItem + "_ctrlmode"]);
                }
            }
        }
    };
    ZegoSettingConfig.prototype.getSetting = function (key, force) {
        if (force === void 0) { force = false; }
        if (force) {
            if (this.setting[key + "_ctrlmode"] == 2) {
                return this.setting[key];
            }
            else {
                return undefined;
            }
        }
        return this.setting[key];
    };
    return ZegoSettingConfig;
}());
exports.ZegoSettingConfig = ZegoSettingConfig;
exports.RTC = "rtc";


/***/ }),

/***/ "./sdk/src/common/stateCenter.ts":
/*!***************************************!*\
  !*** ./sdk/src/common/stateCenter.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StateCenter = void 0;
var zego_entity_1 = __webpack_require__(/*! ../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var client_util_1 = __webpack_require__(/*! ../util/client-util */ "./sdk/src/util/client-util.ts");
var action_1 = __webpack_require__(/*! ./action */ "./sdk/src/common/action.ts");
var setting_config_1 = __webpack_require__(/*! ./setting.config */ "./sdk/src/common/setting.config.ts");
var zego_entity_2 = __webpack_require__(/*! ./zego.entity */ "./sdk/src/common/zego.entity.ts");
var zego_log_event_1 = __webpack_require__(/*! ./zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var StateCenter = /** @class */ (function () {
    function StateCenter(logger, dataReport) {
        this.logger = logger;
        this.dataReport = dataReport;
        this.debug = false;
        this.testEnvironment = false;
        this.pullLimited = true;
        // 是否使用统一接入
        this.useNetAgent = true;
        this.configOK = false;
        this.relateService = [];
        this.role = 2;
        this.maxMemberCount = 0;
        this.roomCreateFlag = 1;
        //runState: ENUM_RUN_STATE = ENUM_RUN_STATE.logout;
        //lastRunState: ENUM_RUN_STATE = ENUM_RUN_STATE.logout;
        this.callbackList = {};
        this.publishStreamList = {};
        this.streamUrlMap = {};
        this.cmdCallback = {};
        this.customUrl = [];
        this.customPlayUrl = [];
        this.turnOverTcpOnly = false;
        this.customSetTcpOrUdp = false;
        this.supportUdp = false;
        //音效相关
        this.audioEffectBuffer = {};
        this.audioBitRate = 48000;
        //动态转推cdn相关
        this.cdnSeq = 0;
        //回调相关
        this.listenerList = {
            roomStreamUpdate: [],
            streamExtraInfoUpdate: [],
            playerStateUpdate: [],
            publisherStateUpdate: [],
            screenSharingEnded: [],
            publishQualityUpdate: [],
            playQualityUpdate: [],
            remoteCameraStatusUpdate: [],
            remoteMicStatusUpdate: [],
            soundLevelUpdate: [],
            capturedSoundLevelUpdate: [],
            videoDeviceStateChanged: [],
            audioDeviceStateChanged: [],
            deviceError: [],
            _deviceError: [],
            _remoteCameraStatusUpdate: [],
            _remoteMicStatusUpdate: [],
            _streamUpdated: [],
            receiveRealTimeSequentialData: [],
            beautyEffectOverload: []
        };
        // log event
        this.reportList = {};
        this.reportSeqList = {
            startPublish: {},
            rePublish: {},
            startPlay: {},
            rePlay: {},
            stopPublish: {},
            stopPlay: {}
        };
        this.streamTrigger = {};
        // 混流配置相关
        this.audioStreamList = {};
        // 设备信息
        this.deviceInfos = null;
        this.deviceChangeTimer = null;
        this.deviceStateOut = false;
        this.networkState = zego_entity_2.ENUM_NETWORK_STATE.offline;
        this.streamRetryTime = 300;
        this.checkList = [];
        this.anchor_info = {
            anchor_id: "",
            anchor_id_name: "",
            anchor_nick_name: ""
        };
        this.streamConnectTime = 0;
        this.clientIP = "";
        //区分公有私有
        this.type = "PUBLIC";
        this.roomList = [];
        this.isMultiRoom = false;
        this.browser = "";
        this.playAccelerate = false;
        this.logReportCallback = client_util_1.ClientUtil.logReportCallback;
        this.unregisterCallback = client_util_1.ClientUtil.unregisterCallback;
        this.checkIllegalCharacters = client_util_1.ClientUtil.checkIllegalCharacters;
        this.decodeServerError = client_util_1.ClientUtil.decodeServerError;
        this.getLiveRoomError = client_util_1.ClientUtil.getLiveRoomError;
        this.getServerError = client_util_1.ClientUtil.getServerError;
        this.mergeStreamList = client_util_1.ClientUtil.mergeStreamList;
        this.checkInteger = client_util_1.ClientUtil.checkInteger;
        this.isUrl = client_util_1.ClientUtil.isUrl;
        this.actionSuccessCallback = client_util_1.ClientUtil.actionSuccessCallback;
        this.checkValidNumber = client_util_1.ClientUtil.checkValidNumber;
        this.getDevices = client_util_1.ClientUtil.getDevices;
        this.settingConfig = new setting_config_1.ZegoSettingConfig();
    }
    // //是否登录
    // isLogin() {
    //     return this.runState === ENUM_RUN_STATE.login;
    // }
    //requestId
    StateCenter.prototype.getRequestId = function () {
        return this.idName + "-" + zego_entity_2.getSeq();
    };
    StateCenter.prototype.getSignalCmdContent = function (roomID, requestId, dest_id_name, result) {
        var data = {
            request_id: requestId,
            room_id: roomID,
            from_userid: this.idName,
            from_username: this.nickName,
            to_userid: dest_id_name
        };
        if (result != undefined) {
            data["result"] = result;
        }
        return JSON.stringify(data);
    };
    StateCenter.prototype.actionListener = function (listener) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (![
            "playQualityUpdate",
            "publishQualityUpdate",
            "soundLevelUpdate",
            "capturedSoundLevelUpdate"
        ].includes(listener) &&
            this.listenerList[listener]) {
            var reportSeq = zego_entity_1.getReportSeq();
            this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoListener.event);
            this.dataReport.addMsgInfo(reportSeq, {
                listener: listener,
                params: args
            });
            this.dataReport.uploadReport(reportSeq);
        }
        this.listenerList[listener] &&
            this.listenerList[listener].forEach(function (func) {
                try {
                    setTimeout(function () {
                        func.apply(void 0, args);
                    }, 0);
                }
                catch (error) {
                    _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.STATECENTER_ACTION_LISTENER +
                        " " +
                        listener +
                        " " +
                        error);
                }
            });
    };
    StateCenter.prototype.getRoomByRoomID = function (roomID) {
        return this.roomList.find(function (room) { return room.roomID == roomID; });
    };
    StateCenter.prototype.getPlayRoom = function (streamID) {
        return this.roomList.find(function (room) {
            return !!room.streamList.find(function (streamInfo) { return streamInfo.stream_id == streamID; });
        });
    };
    return StateCenter;
}());
exports.StateCenter = StateCenter;


/***/ }),

/***/ "./sdk/src/common/streamCenter.ts":
/*!****************************************!*\
  !*** ./sdk/src/common/streamCenter.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoStreamCenter = void 0;
var ZegoStreamCenter = /** @class */ (function () {
    function ZegoStreamCenter() {
        this.publisherList = {};
        this.playerList = {};
    }
    return ZegoStreamCenter;
}());
exports.ZegoStreamCenter = ZegoStreamCenter;


/***/ }),

/***/ "./sdk/src/common/streamHandler.ts":
/*!*****************************************!*\
  !*** ./sdk/src/common/streamHandler.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StreamHandler = void 0;
var zego_entity_1 = __webpack_require__(/*! ./zego.entity */ "./sdk/src/common/zego.entity.ts");
var zego_error_1 = __webpack_require__(/*! ./zego.error */ "./sdk/src/common/zego.error.ts");
var action_1 = __webpack_require__(/*! ./action */ "./sdk/src/common/action.ts");
// import { BusinessService } from "zego-express-engine-webrtm/sdk/src/modules/net/index";
// interface MixStreamConfig extends ZegoMixStreamConfig {
//   noTaskID?: boolean;
// }
// declare const $PROTO_VERSION: any;
// const PROTO_VERSION = $PROTO_VERSION;
// const REPORT_ACTION = {
//   eventStart: "eventStart",
//   eventEndWithMsgInfo: "eventEndWithMsgInfo",
//   addEventMsg: "addEventMsg",
//   addEvent: "addEvent",
//   eventEnd: "eventEnd",
//   addMsgInfo: "addMsgInfo"
// };
var StreamHandler = /** @class */ (function () {
    function StreamHandler(logger, stateCenter, rtm, streamCenter, roomID) {
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.rtm = rtm;
        this.streamCenter = streamCenter;
        this.roomID = roomID;
        this.minStreamSeq = 0;
        this.streamSeq = 0;
        this.streamQuerying = false;
        this.streamSeqMergeMap = null;
        this.streamListHBMergeInterval = 2000;
        this.streamListMergeInterval = 5000;
    }
    //空实现 被sdk覆盖
    StreamHandler.prototype.setCDNInfo = function (streamInfo, streamItem) {
        streamInfo.urlFlv =
            streamItem.urls_flv instanceof Array
                ? streamItem.urls_flv[0]
                : typeof streamItem.urls_flv == "string"
                    ? streamItem.urls_flv
                    : "";
        streamInfo.urlHls =
            streamItem.urls_m3u8 instanceof Array
                ? streamItem.urls_m3u8[0]
                : typeof streamItem.urls_m3u8 == "string"
                    ? streamItem.urls_m3u8
                    : "";
        streamInfo.urlHttpsFlv =
            streamItem.urls_https_flv instanceof Array
                ? streamItem.urls_https_flv[0]
                : typeof streamItem.urls_https_flv == "string"
                    ? streamItem.urls_https_flv
                    : "";
        streamInfo.urlHttpsHls =
            streamItem.urls_https_m3u8 instanceof Array
                ? streamItem.urls_https_m3u8[0]
                : typeof streamItem.urls_https_m3u8 == "string"
                    ? streamItem.urls_https_m3u8
                    : "";
        streamInfo.urlRtmp =
            streamItem.urls_rtmp instanceof Array
                ? streamItem.urls_rtmp[0]
                : typeof streamItem.urls_rtmp == "string"
                    ? streamItem.urls_rtmp
                    : "";
    };
    //空实现 被sdk覆盖
    StreamHandler.prototype.onStreamUpdated = function (roomid, type, streamList) { };
    //空实现 被sdk覆盖
    StreamHandler.prototype.onStreamExtraInfoUpdated = function (roomid, streamList) { };
    StreamHandler.prototype.handleStreamStart = function (msg, room) {
        this.logger.info("zb.sh.hss call stream update");
        this.room = room;
        if (!msg.body) {
            this.logger.error("zb.sh.hss server response wrong");
            return;
        }
        this.streamListHBMergeInterval =
            msg.body.stream_list_hb_wait_merge_time || 2000;
        this.streamListMergeInterval =
            msg.body.stream_list_push_merge_timeout || 5000;
        this.streamQuerying = false;
        this.handleFullUpdateStream(msg.body.stream_seq, msg.body.stream_info || []);
        /* 流媒体推流正常，房间连接成功后，需要对比服务端返回的流信息，如果没有自己的推流信息，则需要发送流新增
            流媒体推流失败，房间连接成功后，需要对比服务端返回的流信息，如果有自己的推流信息，则要发送流删除 */
        this.handleReconnectStream(msg.body.stream_info);
        this.logger.info("zb.sh.hss call end");
    };
    //空实现 被sdk覆盖
    StreamHandler.prototype.onPublishStateUpdate = function (type, streamId, error) { };
    //流更新信令  退出上次推的自己的流
    StreamHandler.prototype.updateStreamInfo = function (streamid, cmd, stream_extra_info, error) {
        var _this = this;
        var _a, _b;
        if (stream_extra_info === void 0) { stream_extra_info = ""; }
        this.logger.info("zb.sh.usi call");
        var extra_info = stream_extra_info;
        var streamInfo = (_a = this.room) === null || _a === void 0 ? void 0 : _a.streamList.find(function (item) { return item.streamid === streamid; });
        if (!streamInfo) {
            this.logger.warn("zb.sh.usi stream not in room cmd " + cmd);
        }
        console.error("updateStreamInfo", JSON.stringify(streamInfo));
        var data = {
            stream_id: streamid,
            extra_info: extra_info
        };
        if (cmd === 2002 || cmd === 2003) {
            data["stream_sid"] = (streamInfo === null || streamInfo === void 0 ? void 0 : streamInfo["stream_sid"]) || "";
        }
        var stream_msg = JSON.stringify(data);
        var bodyData = {
            sub_cmd: cmd,
            stream_msg: stream_msg,
            third_token: (_b = this.room) === null || _b === void 0 ? void 0 : _b.token
        };
        var streamCmd = "stream";
        var room = this.room;
        this.room.streamInfoList[streamid] = {};
        var sucCallBack = function (msg, seq) {
            // if (this.stateCenter.useNetAgent) {
            //   this.handleStreamUpdateRsp(msg);
            // } else {
            _this.handleStreamUpdateRsp(msg, streamid);
            // }
        };
        var failCallBack = function (result, seq) {
            var room = _this.room;
            if (room &&
                !room.isResetRoom &&
                !_this.rtm.isDisConnect() &&
                result.code &&
                result.code == zego_error_1.errorCodeList.TIMEOUT.code &&
                room.streamInfoList[streamid].seq == seq) {
                if ((cmd == 2001 &&
                    _this.stateCenter.publishStreamList[streamid] &&
                    _this.stateCenter.publishStreamList[streamid].state ==
                        zego_entity_1.ENUM_PUBLISH_STREAM_STATE.update_info) ||
                    cmd == 2002) {
                    //若不加setTimeout则可能导致在resetCheckMessageList时导致死循环
                    setTimeout(function () {
                        _this.updateStreamInfo(streamid, cmd, stream_extra_info, error);
                    }, 0);
                }
                else {
                    error && error(zego_error_1.errorCodeList.TIMEOUT);
                }
            }
            else {
                if (result.body && result.body.err_code) {
                    // TODO: 这里的 getServerError 得到的不是对外错误码，目前是直接抛出，需要优化
                    var err = _this.stateCenter.getServerError(result.body.err_code);
                    // 处理为对外 token 过期错误码
                    if ([1011, 1000002002].includes(err.code)) {
                        err = zego_error_1.errorCodeList.TOKEN_EXPIRED;
                    }
                    error && error(err, seq);
                    // 通知流新增失败,回调客户推流失败,但是不主动停止流
                    cmd === zego_entity_1.ENUM_STREAM_SUB_CMD.liveBegin &&
                        _this.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.error, streamid, err);
                }
            }
        };
        if (this.stateCenter.useNetAgent) {
            this.rtm.liveRoomHandler.sendStreamUpdate(bodyData, sucCallBack, failCallBack, {
                sessionID: room === null || room === void 0 ? void 0 : room.sessionID,
                roomID: room === null || room === void 0 ? void 0 : room.roomID,
                roomSessionID: room === null || room === void 0 ? void 0 : room.roomSessionID
            });
        }
        else {
            this.room.streamInfoList[streamid].seq = this.rtm.service.sendMessage(streamCmd, bodyData, sucCallBack, failCallBack, undefined, {
                sessionID: room === null || room === void 0 ? void 0 : room.sessionID,
                roomID: room === null || room === void 0 ? void 0 : room.roomID,
                roomSessionID: room === null || room === void 0 ? void 0 : room.roomSessionID
            });
        }
        this.logger.info("zb.sh.usi call success cmd " + cmd);
    };
    //流更新回包
    StreamHandler.prototype.handleStreamUpdateRsp = function (msg, streamid) {
        var _a, _b, _c;
        if (this.rtm.isDisConnect()) {
            this.logger.error("zb.sh.hsur not login");
            return;
        }
        if (msg.body.err_code != 0) {
            this.logger.error("zb.sh.hsur stream update error " + msg.body.err_code);
            return;
        }
        this.logger.info("zb.sh.hsur stream seq " +
            this.streamSeq +
            " server seq " +
            msg.body.stream_seq);
        this.streamSeq = msg.body.stream_seq;
        var room = this.room;
        if (!room) {
            this.logger.info("hsur.0 room no found");
            return;
        }
        // 处理流新增时返回 token 剩余有效时长
        var remainTime = (_a = msg === null || msg === void 0 ? void 0 : msg.body) === null || _a === void 0 ? void 0 : _a.token_remain_time;
        if (remainTime) {
            var room_1 = this.stateCenter.getRoomByRoomID((_b = msg === null || msg === void 0 ? void 0 : msg.header) === null || _b === void 0 ? void 0 : _b.room_id);
            if (!room_1) {
                this.logger.error("zb.sh.hsur room no found ignore " +
                    JSON.stringify((_c = msg.header) === null || _c === void 0 ? void 0 : _c.room_id));
            }
            else {
                // 将房间的 token 更新
                this.rtm.resetRoomTokenTimer(msg.header.room_id, msg.body.token_remain_time);
            }
        }
        if (this.stateCenter.useNetAgent) {
            // TODO stream_ver
            this.handleStreamSync(msg, streamid);
        }
        else {
            //流删除时，publishStreamList已经删除了
            for (var i = 0; i < msg.body.stream_info.length; i++) {
                var streamid_1 = msg.body.stream_info[i].stream_id;
                this.handleStreamRsp(room, streamid_1, msg.body.stream_info[i]);
                delete room.streamInfoList[streamid_1];
            }
        }
    };
    StreamHandler.prototype.handleStreamSync = function (msg, streamID) {
        if (msg.body.stream_seq > this.streamSeq) {
            this.fetchStreamList();
            return;
        }
        var streamInfo = this.room.streamList.find(function (streamInfo) { return streamInfo.stream_id == streamID; });
        if (streamInfo && msg.body.stream_ver > streamInfo.stream_ver) {
            this.fetchStreamList(streamID);
            return;
        }
        this.handleStreamRsp(this.room, streamID, {
            streamid: streamID,
            stream_sid: msg.body.stream_sid,
            stream_ver: msg.body.stream_ver,
            stream_nid: msg.body.stream_nid
        });
    };
    StreamHandler.prototype.handleStreamRsp = function (room, streamID, streamInfo) {
        var publish = this.stateCenter.publishStreamList[streamID];
        if (!publish) {
            this.logger.info("hsur.0 stream is not exist");
            return;
        }
        if (publish.state == zego_entity_1.ENUM_PUBLISH_STREAM_STATE.update_info) {
            publish.state = zego_entity_1.ENUM_PUBLISH_STREAM_STATE.publishing;
            if (!room.streamList.find(function (streamInfo) { return streamInfo.stream_id == streamID; })) {
                room.streamList.push(streamInfo);
            }
            this.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.start, streamID, {
                code: 0,
                message: ""
            });
        }
    };
    StreamHandler.prototype.handleFetchStreamListRsp = function (msg, updateStreamID) {
        this.logger.info("zb.sh.hfslr call");
        this.streamQuerying = false;
        if (msg.body.err_code !== 0) {
            this.logger.info("zb.sh.hfslr server error=", msg.body.err_code);
            return;
        }
        if (this.streamSeq === msg.body.stream_seq) {
            this.logger.info("zb.sh.hfslr same seq");
            return;
        }
        var _streams = msg.body.stream_info;
        if (updateStreamID) {
            _streams = msg.body.stream_info.filter(function (stream) { return stream.stream_id === updateStreamID; });
        }
        this.handleFullUpdateStream(msg.body.stream_seq, _streams);
        this.logger.info("zb.sh.hfslr call success");
    };
    StreamHandler.prototype.handleFullUpdateStream = function (serverStreamSeq, serverStreamList) {
        var _this = this;
        this.logger.info("zb.sh.hfus call");
        this.streamSeq = serverStreamSeq;
        this.logger.debug("zb.sh.hfus server seq " + this.streamSeq);
        this.stateCenter.mergeStreamList(this.stateCenter.idName, this.room.streamList, serverStreamList, function (addStreamList, delStreamList, updateStreamList) {
            if (addStreamList.length !== 0) {
                _this.logger.debug("zb.sh.hfus callback addstream");
                _this.onStreamUpdated(_this.roomID, zego_entity_1.ENUM_STREAM_UPDATE_TYPE.added, _this.makeCallbackStreamList(addStreamList));
            }
            if (delStreamList.length !== 0) {
                _this.logger.debug("zb.sh.hfus callback delstream");
                _this.onStreamUpdated(_this.roomID, zego_entity_1.ENUM_STREAM_UPDATE_TYPE.deleted, _this.makeCallbackStreamList(delStreamList));
            }
            if (updateStreamList.length !== 0) {
                _this.logger.debug("zb.sh.hfus callback updatestream");
                _this.onStreamExtraInfoUpdated(_this.roomID, _this.makeCallbackStreamList(updateStreamList));
            }
        });
        //this.room!.streamList = serverStreamList;
        this.logger.info("zb.sh.hfus call success");
    };
    StreamHandler.prototype.handlePushStreamUpdateMsg = function (msg) {
        this.logger.info("zb.sh.hpsum call");
        if (!msg.body.stream_info || msg.body.stream_info.length === 0) {
            this.logger.info("zb.sh.hpsum, emtpy list");
            return;
        }
        if (msg.body.stream_info.length + this.streamSeq !== msg.body.stream_seq) {
            this.logger.info("zb.sh.hpsum call updatestream");
            //this.mergeStreamByStreamSeq(msg.body.stream_cmd, msg.body.stream_seq, msg.body.stream_info)
            this.fetchStreamList();
            return;
        }
        this.streamSeq = msg.body.stream_seq;
        switch (msg.body.stream_cmd) {
            case zego_entity_1.ENUM_STREAM_UPDATE_CMD.added:
                this.handleAddedStreamList(msg.body.stream_info);
                break;
            case zego_entity_1.ENUM_STREAM_UPDATE_CMD.deleted:
                this.handleDeletedStreamList(msg.body.stream_info);
                break;
            case zego_entity_1.ENUM_STREAM_UPDATE_CMD.updated:
                this.handleUpdatedStreamList(msg.body.stream_info);
                break;
        }
        this.logger.info("zb.sh.hpsum call success");
    };
    StreamHandler.prototype.handlePriPushStreamUpdateMsg = function (msg) {
        this.logger.info("zb.sh.hpsum call");
        if (!msg.body.streams_info || msg.body.streams_info.length === 0) {
            this.logger.info("zb.sh.hpsum, emtpy list");
            return;
        }
        if (msg.body.streams_info.length + this.streamSeq !== msg.body.stream_seq) {
            this.logger.info("zb.sh.hpsum call updatestream");
            //   this.fetchStreamList()
            this.mergeStreamByStreamSeq(msg.body.stream_cmd, msg.body.stream_seq, msg.body.streams_info);
            return;
        }
        this.streamSeq = msg.body.stream_seq;
        switch (msg.body.stream_cmd) {
            case zego_entity_1.ENUM_STREAM_UPDATE_CMD_PRI.added:
                this.handleAddedStreamList(msg.body.streams_info);
                break;
            case zego_entity_1.ENUM_STREAM_UPDATE_CMD_PRI.deleted:
                this.handleDeletedStreamList(msg.body.streams_info);
                break;
            case zego_entity_1.ENUM_STREAM_UPDATE_CMD_PRI.updated:
                this.handleUpdatedStreamList(msg.body.streams_info);
                break;
        }
        this.logger.info("zb.sh.hpsum call success");
    };
    StreamHandler.prototype.handleAddedStreamList = function (streamList) {
        this.logger.debug("zb.sh.hasl call");
        var addStreamList = [];
        var flag;
        for (var i = 0; i < streamList.length; i++) {
            if (streamList[i].anchor_id_name == this.stateCenter.idName ||
                streamList[i].id_name == this.stateCenter.idName ||
                streamList[i].user_id === this.stateCenter.idName) {
                this.logger.debug("hdsl.0 have self stream added");
                continue;
            }
            flag = false;
            for (var j = 0; j < this.room.streamList.length; j++) {
                if (streamList[i].stream_id === this.room.streamList[j].stream_id) {
                    flag = true;
                    break;
                }
            }
            if (!flag) {
                addStreamList.push(streamList[i]);
            }
        }
        if (addStreamList.length !== 0) {
            this.logger.debug("zb.sh.hasl callback addstream");
            // this.room!.streamList.concat(addStreamList);
            for (var k = 0; k < addStreamList.length; k++) {
                this.room.streamList.push(addStreamList[k]);
            }
            this.onStreamUpdated(this.roomID, zego_entity_1.ENUM_STREAM_UPDATE_TYPE.added, this.makeCallbackStreamList(addStreamList));
        }
        this.logger.info("zb.sh.hasl call success");
    };
    StreamHandler.prototype.handleDeletedStreamList = function (streamList) {
        this.logger.debug("zb.sh.hdsl call");
        var delStreamList = [];
        for (var i = 0; i < streamList.length; i++) {
            if (streamList[i].anchor_id_name == this.stateCenter.idName ||
                streamList[i].id_name == this.stateCenter.idName ||
                streamList[i].user_id === this.stateCenter.idName) {
                this.logger.debug("zb.sh.hdsl have self stream deleted");
                continue;
            }
            for (var j = this.room.streamList.length - 1; j >= 0; j--) {
                if (streamList[i].stream_id === this.room.streamList[j].stream_id) {
                    this.room.streamList.splice(j--, 1);
                    delStreamList.push(streamList[i]);
                    break;
                }
            }
        }
        if (delStreamList.length !== 0) {
            this.logger.debug("zb.sh.hdsl callback delstream");
            this.onStreamUpdated(this.roomID, zego_entity_1.ENUM_STREAM_UPDATE_TYPE.deleted, this.makeCallbackStreamList(delStreamList));
        }
        this.logger.info("zb.sh.hdsl call");
    };
    StreamHandler.prototype.handleUpdatedStreamList = function (streamList) {
        this.logger.debug("zb.sh.husl call");
        var updateStreamList = [];
        for (var i = 0; i < streamList.length; i++) {
            if (streamList[i].anchor_id_name == this.stateCenter.idName ||
                streamList[i].id_name == this.stateCenter.idName ||
                streamList[i].user_id === this.stateCenter.idName) {
                this.logger.debug("hsul.0 have self stream updated");
                continue;
            }
            for (var j = 0; j < this.room.streamList.length; j++) {
                if (streamList[i].stream_id === this.room.streamList[j].stream_id) {
                    if (streamList[i].extra_info !== this.room.streamList[j].extra_info) {
                        this.room.streamList[j] = streamList[i];
                        updateStreamList.push(streamList[i]);
                    }
                    break;
                }
            }
        }
        if (updateStreamList.length !== 0) {
            this.logger.debug("zb.sh.husl callback updatestream");
            this.onStreamExtraInfoUpdated(this.roomID, this.makeCallbackStreamList(updateStreamList));
        }
        this.logger.info("zb.sh.husl call success");
    };
    // 拉取服务端流信息
    StreamHandler.prototype.fetchStreamList = function (streamID) {
        var _this = this;
        var _a, _b, _c;
        this.logger.info("zb.sh.fsl call");
        // 不是处于登录状态，不让拉流
        if (this.rtm.isDisConnect()) {
            this.logger.info("zb.sh.fsl state error");
            return;
        }
        // 是否正处于拉流状态 false 为完成， true为正在拉流
        if (this.streamQuerying) {
            this.logger.info("zb.sh.fsl already doing");
            return;
        }
        this.streamQuerying = true;
        this.logger.debug("zb.sh.fsl send fetch request");
        if (this.stateCenter.useNetAgent) {
            this.rtm.liveRoomHandler.getStreamList({}, function (msg) {
                _this.handleFetchStreamListRsp(msg, streamID);
            }, function (err) { }, {
                roomID: (_a = this.room) === null || _a === void 0 ? void 0 : _a.roomID,
                sessionID: (_b = this.room) === null || _b === void 0 ? void 0 : _b.sessionID,
                roomSessionID: (_c = this.room) === null || _c === void 0 ? void 0 : _c.roomSessionID
            });
        }
        else {
            var bodyData = {
                reserve: 0
            };
            // 发送消息
            var room = this.room;
            this.rtm.service.sendMessage("stream_info", bodyData, this.handleFetchStreamListRsp.bind(this), function (err, seq) { }, undefined, {
                roomID: room === null || room === void 0 ? void 0 : room.roomID,
                sessionID: room === null || room === void 0 ? void 0 : room.sessionID,
                roomSessionID: room === null || room === void 0 ? void 0 : room.roomSessionID
            });
        }
        this.logger.info("zb.sh.fsl call success");
        // }
    };
    StreamHandler.prototype.handleReconnectStream = function (newStreamList) {
        this.logger.info("zb.sh.hrs call");
        var publisherList = this.streamCenter.publisherList;
        var playerList = this.streamCenter.playerList;
        var _loop_1 = function (streamID) {
            // 当前推流成功但服务端无该流信息则补发上报流新增
            if (publisherList[streamID].roomID !== this_1.roomID)
                return "continue";
            if (publisherList[streamID].publisher.state ==
                zego_entity_1.ENUM_PUBLISH_STATE.publishing &&
                !newStreamList.find(function (stream) { return stream.stream_id == streamID; })) {
                var cmd = void 0;
                this_1.stateCenter.type === "PUBLIC"
                    ? (cmd = zego_entity_1.ENUM_STREAM_SUB_CMD.liveBegin)
                    : (cmd = zego_entity_1.ENUM_STREAM_CMD_PRI.liveBegin);
                this_1.updateStreamInfo(streamID, cmd, this_1.stateCenter.publishStreamList[streamID].extra_info);
                //推流失败但服务端还有该流信息则补发流删除
            }
            else if (publisherList[streamID].publisher.state == zego_entity_1.ENUM_PUBLISH_STATE.stop &&
                newStreamList.find(function (stream) { return stream.stream_id == streamID; })) {
                var cmd = void 0;
                this_1.stateCenter.type === "PUBLIC"
                    ? (cmd = zego_entity_1.ENUM_STREAM_SUB_CMD.liveEnd)
                    : (cmd = zego_entity_1.ENUM_STREAM_CMD_PRI.liveEnd);
                this_1.updateStreamInfo(streamID, cmd);
                //上报流删除时需将statecenter.streamList中对应的流删除
                for (var i = 0; i < this_1.room.streamList.length; i++) {
                    if (this_1.room.streamList[i].stream_id == streamID) {
                        this_1.room.streamList.splice(i--, 1);
                        break;
                    }
                }
            }
        };
        var this_1 = this;
        for (var streamID in publisherList) {
            _loop_1(streamID);
        }
        //部分流需重新调度
        for (var streamID in publisherList) {
            if (publisherList[streamID].roomID !== this.roomID)
                continue;
            if (publisherList[streamID].isReDispatch) {
                this.logger.info("zb.sh.hrs " + streamID + "retry dispatch");
                var retryDispatchHandler = publisherList[streamID].retryDispatchHandler;
                retryDispatchHandler.stopMaxTime();
                retryDispatchHandler.invalid();
                retryDispatchHandler.initStream(streamID, publisherList[streamID].publishOption, true);
                retryDispatchHandler.active(0);
                publisherList[streamID].isReDispatch = false;
            }
        }
        for (var streamID in playerList) {
            if (playerList[streamID].roomID !== this.roomID)
                continue;
            if (playerList[streamID].isReDispatch) {
                this.logger.info("zb.sh.hrs " + streamID + "retry dispatch");
                var retryDispatchHandler = playerList[streamID].retryDispatchHandler;
                retryDispatchHandler.stopMaxTime();
                retryDispatchHandler.invalid();
                retryDispatchHandler.initStream(streamID, playerList[streamID].playOption, false);
                retryDispatchHandler.active(0);
                playerList[streamID].isReDispatch = false;
            }
        }
        this.logger.info("zb.sh.hrs end");
    };
    StreamHandler.prototype.makeCallbackStreamList = function (streamList) {
        var callbackStreamList = [];
        // if (this.stateCenter.type === "PUBLIC") {
        var resource_info = this.stateCenter.appConfig.media_config.play_config.resource_info;
        console.warn("resource_info", resource_info);
        var cdns = resource_info.find(function (item) {
            return item.resource_type === zego_entity_1.ResourceType.CDN;
        });
        // const stream = { urls_flv: flvs, urls_m3u8: hls, urls_rtmp: rtmps };
        if (streamList && streamList.length > 0) {
            for (var i = 0; i < streamList.length; i++) {
                var flvs = [];
                var hls = [];
                var rtmps = [];
                var streamID = streamList[i].stream_id;
                if (cdns) {
                    for (var i_1 = 0; i_1 < cdns.service_info.length; i_1++) {
                        var _a = cdns.service_info[i_1], protocol = _a.protocol, url_template = _a.url_template;
                        switch (protocol) {
                            case zego_entity_1.ProtocolType.FLV:
                                var flvUrl = url_template.replace("{STREAM_NAME}", streamID);
                                flvs.push(flvUrl);
                                break;
                            case zego_entity_1.ProtocolType.HLS:
                                var hlsUrl = url_template.replace("{STREAM_NAME}", streamID);
                                hls.push(hlsUrl);
                                break;
                            case zego_entity_1.ProtocolType.RTMP:
                                var rtmpUrl = url_template.replace("{STREAM_NAME}", streamID);
                                rtmps.push(rtmpUrl);
                                break;
                        }
                    }
                }
                streamList[i].urls_flv = flvs;
                streamList[i].urls_m3u8 = hls;
                streamList[i].urls_rtmp = rtmps;
                var streamInfo = {
                    user: {
                        userID: streamList[i].anchor_id_name || streamList[i].id_name,
                        userName: streamList[i].anchor_nick_name || streamList[i].nick_name
                    },
                    extraInfo: streamList[i].extra_info,
                    streamID: streamList[i].stream_id,
                    roomID: "",
                    urlFlv: "",
                    urlRtmp: "",
                    urlHls: "",
                    urlHttpsFlv: "",
                    urlHttpsHls: "",
                    streamGID: streamList[i].stream_gid,
                    closeType: streamList[i].close_type
                };
                this.setCDNInfo(streamInfo, streamList[i]);
                callbackStreamList.push(streamInfo);
            }
        }
        // } else {
        //   if (streamList && streamList.length > 0) {
        //     for (let i = 0; i < streamList.length; i++) {
        //       const streamInfo = {
        //         user_id: streamList[i].user_id,
        //         user_name: streamList[i].user_name,
        //         stream_id: streamList[i].stream_id,
        //         stream_sid: streamList[i].stream_sid,
        //         extra_info: streamList[i].extra_info,
        //         title: streamList[i].title,
        //         stream_ver: streamList[i].stream_ver
        //       };
        //       //this.setCDNInfo(streamInfo, streamList[i]);
        //       callbackStreamList.push(streamInfo);
        //     }
        //   }
        // }
        return callbackStreamList;
    };
    StreamHandler.prototype.sendBizChannelRequest = function (reqBody, success, error, isRetry) {
        var _this = this;
        if (isRetry === void 0) { isRetry = false; }
        reqBody = Object.assign(reqBody, { is_retry_req: isRetry ? 1 : 0 });
        var room = this.room;
        this.rtm.service.sendMessage("biz_channel", reqBody, function (msg, seq) {
            success(msg.header.seq, msg.body.cmd, msg.body.rsp_body);
        }, function (msg, seq) {
            var err = msg.body.err_code;
            var rspBody = msg.body.rsp_body;
            // retry
            if (typeof err == "number" && err === 2002) {
                _this.sendBizChannelRequest(reqBody, success, error, true);
                return;
            }
            error(err, seq, rspBody);
        }, undefined, {
            roomID: room === null || room === void 0 ? void 0 : room.roomID,
            sessionID: room === null || room === void 0 ? void 0 : room.sessionID,
            roomSessionID: room === null || room === void 0 ? void 0 : room.roomSessionID
        });
    };
    StreamHandler.prototype.sendBizChannelRequestV2 = function (requestInfo, reqBody, successCb, errorCb) {
        var _this = this;
        var server = requestInfo.server, location = requestInfo.location, cmd = requestInfo.cmd, channel = requestInfo.channel;
        var netAgent = this.rtm.netAgent;
        var httpIO = netAgent.getHttpRequest(server);
        var room = this.room;
        var bodyStr = undefined;
        var timestamp = reqBody.timestamp;
        if (reqBody) {
            bodyStr = JSON.stringify(reqBody);
        }
        var reqWrapBody = {
            cmd: cmd,
            req_body: bodyStr,
            appid: this.stateCenter.appid,
            timestamp: timestamp || Math.ceil(new Date().getTime() / 1000),
            // 鉴权参数
            token: room === null || room === void 0 ? void 0 : room.token,
            user_id: this.stateCenter.idName,
            channel: channel || "media"
        };
        console.error("token", room === null || room === void 0 ? void 0 : room.token);
        console.error("sendBizChannelRequestV2", reqWrapBody, requestInfo);
        httpIO === null || httpIO === void 0 ? void 0 : httpIO.sendRequest({
            headers: [],
            body: reqWrapBody,
            idName: this.stateCenter.idName,
            method_no: 2,
            ack: false,
            location: location
        }, function (res) {
            console.error("sendBizChannelRequestV2", res);
            var status_code = res.status_code, body = res.body;
            if (status_code !== 200) {
                errorCb(status_code);
                return;
            }
            var bodyWrap = body;
            if (typeof body === "string") {
                try {
                    bodyWrap = JSON.parse(body);
                }
                catch (error) {
                    errorCb(status_code);
                    throw error;
                }
            }
            var err_code = bodyWrap.err_code, rsp_body = bodyWrap.rsp_body;
            var rspBodyObj = undefined;
            try {
                rspBodyObj = JSON.parse(rsp_body);
            }
            catch (error) {
                rspBodyObj = rsp_body;
            }
            if (err_code !== 0) {
                if (typeof err_code == "number" && err_code === 2002) {
                    _this.sendBizChannelRequest(reqBody, successCb, errorCb, true);
                    return;
                }
                errorCb(status_code, err_code, rspBodyObj);
                return;
            }
            successCb(rspBodyObj);
        }, function (res, txid, errorCode) {
            errorCb(-1, -1, undefined, errorCode);
        });
    };
    StreamHandler.prototype.sendRTMPRequest = function (requestInfo, reqBody) {
        var location = "/v1/rtmp/dispatch/" + this.stateCenter.appid + "/777/push";
        var netAgent = this.rtm.netAgent;
        var httpIO = netAgent.getHttpRequest(1);
        var room = this.room;
        httpIO === null || httpIO === void 0 ? void 0 : httpIO.sendRequest({
            headers: [
                { name: "Token-Appid", val: this.stateCenter.appid + "" },
                { name: "Token-Str", val: (room === null || room === void 0 ? void 0 : room.token) || "" },
                { name: "Token-Userid", val: this.stateCenter.idName },
                { name: "Token-Biztype", val: "2" }
            ],
            body: {},
            idName: this.stateCenter.idName,
            method_no: 1,
            ack: false,
            location: location
        }, function (res) {
            console.log("rspBody", JSON.parse(res.body));
            // 处理rtmp请求url
            debugger;
        }, function (res, txid, error) { });
    };
    StreamHandler.prototype.updateStreamExtraInfo = function (streamid, extraInfo, success, error) { };
    StreamHandler.prototype.setStreamExtraInfo = function (streamID, extraInfo, success, error) { };
    StreamHandler.prototype._publishTarget = function (cdnPushConfig, success, error) { };
    StreamHandler.prototype.patchStreamList = function (msg) {
        var _this = this;
        if (typeof msg.body.StreamRefresh === "number" &&
            msg.body.StreamRefresh !== 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STREAMHANDLER_PATCH_STREAM_LIST + " stream refresh ");
            this.fetchStreamList();
            return;
        }
        if (msg.body.stream_seq !== this.streamSeq && !this.streamSeqMergeMap) {
            // 如果超过上次全量同步用户的等待时间则立即同步，否则等待差值后再同步
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STREAMHANDLER_PATCH_STREAM_LIST +
                " call update stream " +
                this.streamSeq +
                " server " +
                msg.body.stream_seq);
            this.streamSeqMergeTimer && clearTimeout(this.streamSeqMergeTimer);
            this.streamSeqMergeTimer = setTimeout(function () {
                _this.handleMergeTimeout();
            }, this.streamListHBMergeInterval);
        }
        this.minStreamSeq = msg.body.stream_seq;
    };
    StreamHandler.prototype.mergeStreamByStreamSeq = function (cmd, streamSeq, streamList) {
        var _this = this;
        if (!this.streamSeqMergeMap) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.STREAMHANDLER_MERGE_STREAM_BY_STREAM_SEQ +
                " new merge stream list " +
                this.streamSeq +
                " server " +
                streamSeq);
            this.streamSeqMergeMap = {};
            // 添加定时器，检查 streamSeq 连续性
            this.streamSeqMergeTimer && clearTimeout(this.streamSeqMergeTimer);
            this.streamSeqMergeTimer = setTimeout(function () {
                _this.handleMergeTimeout();
            }, this.streamListMergeInterval);
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STREAMHANDLER_MERGE_STREAM_BY_STREAM_SEQ +
            (" " + this.streamSeqMergeMap + " " + cmd + " " + streamSeq + " " + streamList));
        this.streamSeqMergeMap[streamSeq] = { cmd: cmd, streamList: streamList };
    };
    StreamHandler.prototype.handleMergeTimeout = function () {
        if (!this.streamSeqMergeMap)
            return;
        var streamSeqList = Object.keys(this.streamSeqMergeMap)
            .map(function (key) { return +key; })
            .sort(function (a, b) { return a - b; });
        // streamSeq 连续
        if (streamSeqList[streamSeqList.length - 1] - streamSeqList[0] + 1 ===
            streamSeqList.length ||
            streamSeqList[streamSeqList.length - 1] >= this.minStreamSeq) {
            this.mergeStream(streamSeqList);
        }
        else {
            this.streamSeqMergeMap = null;
            this.fetchStreamList();
        }
    };
    StreamHandler.prototype.mergeStream = function (streamSeqList) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STREAMHANDLER_MERGE_STREAM +
            " merge streamList " +
            this.streamSeq +
            " streamSeqList " +
            streamSeqList.join(","));
        var streamSeq = streamSeqList[streamSeqList.length - 1];
        // 一段时间内同一个用户多次进出房间，以最后一次为准（因为合并了推送消息，streamSeq升序）
        var streamList = [];
        streamSeqList.forEach(function (seq) {
            if (_this.streamSeqMergeMap && _this.streamSeqMergeMap[seq]) {
                switch (_this.streamSeqMergeMap[seq].cmd) {
                    case zego_entity_1.ENUM_STREAM_UPDATE_CMD.added:
                        _this.streamSeqMergeMap[seq].streamList.forEach(function (stream) {
                            var index = streamList.findIndex(function (_stream) { return _stream.stream_id == stream.stream_id; });
                            index !== -1 && streamList.splice(index);
                            streamList.push(stream);
                        });
                        break;
                    case zego_entity_1.ENUM_STREAM_UPDATE_CMD.deleted:
                        _this.streamSeqMergeMap[seq].streamList.forEach(function (stream) {
                            var index = streamList.findIndex(function (_stream) { return _stream.stream_id == stream.stream_id; });
                            index !== -1 && streamList.splice(index);
                        });
                        break;
                    case zego_entity_1.ENUM_STREAM_UPDATE_CMD.updated:
                        _this.streamSeqMergeMap[seq].streamList.forEach(function (stream) {
                            var index = streamList.findIndex(function (_stream) { return _stream.stream_id == stream.stream_id; });
                            index !== -1 && streamList.splice(index);
                            streamList.push(stream);
                        });
                        break;
                }
            }
        });
        this.streamSeqMergeMap = null;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STREAMHANDLER_MERGE_STREAM + " " + streamList);
        this.handleFullUpdateStream(streamSeq, streamList);
    };
    StreamHandler.prototype.reset = function () {
        this.minStreamSeq = 0;
        this.streamSeqMergeMap = null;
        if (this.streamSeqMergeTimer) {
            clearTimeout(this.streamSeqMergeTimer);
            this.streamSeqMergeTimer = undefined;
        }
        this.streamListHBMergeInterval = 2000;
        this.streamListMergeInterval = 5000;
    };
    return StreamHandler;
}());
exports.StreamHandler = StreamHandler;


/***/ }),

/***/ "./sdk/src/common/zego.entity.ts":
/*!***************************************!*\
  !*** ./sdk/src/common/zego.entity.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.E_CLIENT_TYPE = exports.ENUM_SOURCE_TYPE = exports.ENUM_DISPATCH_TYPE = exports.ENUM_BROADCASTER_STATUS = exports.ENUM_PLAY_SOURCE_TYPE = exports.ENUM_PUBLISH_STATE_NEGO = exports.ENUM_PUSH_SIGNAL_SUB_CMD = exports.ENUM_SIGNAL_SUB_CMD = exports.QUALITYLEVEL = exports.SERVER_ERROR_CODE = exports.ENUM_STREAM_UPDATE_CMD_PRI = exports.ENUM_STREAM_UPDATE_CMD = exports.MINIUM_HEARTBEAT_INTERVAL = exports.STREAM_DELETE_REASON = exports.ENUM_NETWORK_STATE = exports.ENUM_RUN_STATE = exports.ENUM_STREAM_UPDATE_TYPE = exports.ENUM_STREAM_CMD_PRI = exports.ENUM_STREAM_SUB_CMD = exports.ENUM_PUBLISH_STREAM_STATE = exports.MAX_RETRY_CONNECT_INTERVAL = exports.MAX_TRANS_DATA_LENGTH = exports.MAX_TRANS_TYPE_LENGTH = exports.MAX_MESSAGE_LENGTH = exports.MAX_ROOM_ID_LENGTH = exports.MAX_USER_NAME_LENGTH = exports.MAX_USER_ID_LENGTH = exports.MAX_STREAM_ID_LENGTH = exports.MAX_TRY_HEARTBEAT_COUNT = exports.SEND_MSG_TIMEOUT = exports.SEND_MSG_RESET = exports.MAX_TRY_CONNECT_COUNT = exports.streamMap = exports.ENUM_CONNECT_STATE = exports.ProtocolType = exports.ResourceType = exports.ENUM_PROBE_STATE = exports.ENUM_PLAY_STATE_NEGO = exports.ENUM_PLAYER_STATE = exports.ENUM_PLAY_STATE = exports.ENUM_PUBLISH_STATE = exports.ENUM_SCREEM_RESOLUTION_TYPE = exports.ENUM_RESOLUTION_TYPE = exports.ENUM_SIGNAL_STATE = exports.ERROR_CODES = exports.ENUM_REMOTE_TYPE = exports.LOG_LEVEL = exports.ENUM_LOG_LEVEL = exports.ROOMVERSION = exports.PROTO_VERSION = void 0;
exports.ZegoExpressWebRTM = exports.ZegoDataReport = exports.ZegoLogger = exports.ZegoExpressWebRTMEngine = exports.getReportSeq = exports.getSeq = exports.QUALITY_CONSTANT = exports.QualityGrade = exports.REPORT_ACTION = exports.ENUM_RETRY_STATE = exports.ENUM_PLAY_STATE_UPDATE = exports.ENUM_PUBLISH_STATE_UPDATE = exports.LinkedList = exports.ListNode = void 0;
exports.PROTO_VERSION = "2.13.0";
exports.ROOMVERSION = "V1";
var ENUM_LOG_LEVEL;
(function (ENUM_LOG_LEVEL) {
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["debug"] = 0] = "debug";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["info"] = 1] = "info";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["warn"] = 2] = "warn";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["error"] = 3] = "error";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["report"] = 99] = "report";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["disable"] = 100] = "disable";
})(ENUM_LOG_LEVEL = exports.ENUM_LOG_LEVEL || (exports.ENUM_LOG_LEVEL = {}));
exports.LOG_LEVEL = {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3,
    report: 99,
    disable: 100
};
var ENUM_REMOTE_TYPE;
(function (ENUM_REMOTE_TYPE) {
    ENUM_REMOTE_TYPE[ENUM_REMOTE_TYPE["disable"] = 0] = "disable";
    ENUM_REMOTE_TYPE[ENUM_REMOTE_TYPE["websocket"] = 1] = "websocket";
    ENUM_REMOTE_TYPE[ENUM_REMOTE_TYPE["https"] = 2] = "https";
})(ENUM_REMOTE_TYPE = exports.ENUM_REMOTE_TYPE || (exports.ENUM_REMOTE_TYPE = {}));
exports.ERROR_CODES = {
    ROOM_SESSION_ID_ERR: 1000000152,
    FETCH_TRANS_UNKNOWN_CHANNEL: 1000001108,
    FETCH_TRANS_UNKNOWN_TYPE: 1000001109,
    FETCH_TRANS_WRONG_SEQ: 1000001110
};
var ENUM_SIGNAL_STATE;
(function (ENUM_SIGNAL_STATE) {
    ENUM_SIGNAL_STATE[ENUM_SIGNAL_STATE["disconnected"] = 0] = "disconnected";
    ENUM_SIGNAL_STATE[ENUM_SIGNAL_STATE["connecting"] = 1] = "connecting";
    ENUM_SIGNAL_STATE[ENUM_SIGNAL_STATE["connected"] = 2] = "connected";
})(ENUM_SIGNAL_STATE = exports.ENUM_SIGNAL_STATE || (exports.ENUM_SIGNAL_STATE = {}));
exports.ENUM_RESOLUTION_TYPE = {
    LOW: {
        width: 320,
        height: 240,
        frameRate: 15,
        bitRate: 300
    },
    MEDIUM: {
        width: 640,
        height: 480,
        frameRate: 15,
        bitRate: 800
    },
    HIGH: {
        width: 1280,
        height: 720,
        frameRate: 20,
        bitRate: 1500
    }
};
exports.ENUM_SCREEM_RESOLUTION_TYPE = {
    LOW: {
        frameRate: 20,
        bitRate: 800
    },
    MEDIUM: {
        frameRate: 15,
        bitRate: 1500
    },
    HIGH: {
        frameRate: 5,
        bitRate: 2000
    }
};
exports.ENUM_PUBLISH_STATE = {
    start: 0,
    waitingSessionRsp: 1,
    waitingOfferRsp: 2,
    waitingServerAnswer: 3,
    waitingServerICE: 4,
    connecting: 5,
    publishing: 6,
    stop: 7,
    didNotStart: 8
};
exports.ENUM_PLAY_STATE = {
    start: 0,
    waitingSessionRsp: 1,
    waitingOfferRsp: 2,
    waitingServerAnswer: 3,
    waitingServerICE: 4,
    connecting: 5,
    playing: 6,
    stop: 7,
    didNotStart: 8
};
// 小程序状态
exports.ENUM_PLAYER_STATE = {
    start: 0,
    playing: 1,
    stop: 2
};
exports.ENUM_PLAY_STATE_NEGO = {
    stop: 0,
    start: 1,
    waiterAnswer: 2,
    waitingCandidate: 3,
    sendCandidate: 4,
    iceConnected: 5,
    iceDisconnected: 6,
    iceClosed: 7,
    iceFailed: 8
};
var ENUM_PROBE_STATE;
(function (ENUM_PROBE_STATE) {
    ENUM_PROBE_STATE[ENUM_PROBE_STATE["tryProbe"] = 0] = "tryProbe";
    ENUM_PROBE_STATE[ENUM_PROBE_STATE["probed"] = 2] = "probed";
})(ENUM_PROBE_STATE = exports.ENUM_PROBE_STATE || (exports.ENUM_PROBE_STATE = {}));
var ResourceType;
(function (ResourceType) {
    ResourceType[ResourceType["CDN"] = 0] = "CDN";
    ResourceType[ResourceType["RTC"] = 1] = "RTC";
    ResourceType[ResourceType["L3"] = 2] = "L3";
})(ResourceType = exports.ResourceType || (exports.ResourceType = {}));
var ProtocolType;
(function (ProtocolType) {
    ProtocolType[ProtocolType["UDP"] = 0] = "UDP";
    ProtocolType[ProtocolType["RTMP"] = 1] = "RTMP";
    ProtocolType[ProtocolType["FLV"] = 2] = "FLV";
    ProtocolType[ProtocolType["HLS"] = 3] = "HLS";
    ProtocolType[ProtocolType["WEBRTC"] = 4] = "WEBRTC";
})(ProtocolType = exports.ProtocolType || (exports.ProtocolType = {}));
exports.ENUM_CONNECT_STATE = {
    disconnect: 0,
    connecting: 1,
    connected: 2
};
exports.streamMap = {
    "/lr/push/stream_add": 12001,
    "/lr/push/stream_delete": 12002,
    "/lr/push/stream_update": 12003
};
exports.MAX_TRY_CONNECT_COUNT = 3;
exports.SEND_MSG_RESET = 2;
exports.SEND_MSG_TIMEOUT = 1;
exports.MAX_TRY_HEARTBEAT_COUNT = 5;
exports.MAX_STREAM_ID_LENGTH = 256;
exports.MAX_USER_ID_LENGTH = 64;
exports.MAX_USER_NAME_LENGTH = 256;
exports.MAX_ROOM_ID_LENGTH = 128;
exports.MAX_MESSAGE_LENGTH = 1024;
exports.MAX_TRANS_TYPE_LENGTH = 128;
exports.MAX_TRANS_DATA_LENGTH = 1024 * 4;
exports.MAX_RETRY_CONNECT_INTERVAL = 12;
exports.ENUM_PUBLISH_STREAM_STATE = {
    waiting_url: 1,
    tryPublish: 2,
    update_info: 3,
    publishing: 4,
    stop: 5,
    retryPublish: 6
};
exports.ENUM_STREAM_SUB_CMD = {
    liveNone: 0,
    liveBegin: 2001,
    liveEnd: 2002,
    liveUpdate: 2003
};
exports.ENUM_STREAM_CMD_PRI = {
    liveBegin: "zegochat_js.room_stream_create_req",
    liveEnd: "zegochat_js.room_stream_delete_req",
    liveUpdate: "zegochat_js.room_stream_update_req"
};
exports.ENUM_STREAM_UPDATE_TYPE = {
    added: 1,
    deleted: 0
};
//运行状态
var ENUM_RUN_STATE;
(function (ENUM_RUN_STATE) {
    ENUM_RUN_STATE[ENUM_RUN_STATE["logout"] = 0] = "logout";
    ENUM_RUN_STATE[ENUM_RUN_STATE["trylogin"] = 1] = "trylogin";
    ENUM_RUN_STATE[ENUM_RUN_STATE["login"] = 2] = "login";
})(ENUM_RUN_STATE = exports.ENUM_RUN_STATE || (exports.ENUM_RUN_STATE = {}));
var ENUM_NETWORK_STATE;
(function (ENUM_NETWORK_STATE) {
    ENUM_NETWORK_STATE[ENUM_NETWORK_STATE["offline"] = 0] = "offline";
    ENUM_NETWORK_STATE[ENUM_NETWORK_STATE["online"] = 1] = "online";
})(ENUM_NETWORK_STATE = exports.ENUM_NETWORK_STATE || (exports.ENUM_NETWORK_STATE = {}));
exports.STREAM_DELETE_REASON = {
    0: {
        code: 1,
        description: "user_stop_publishing_stream_normal"
    },
    1: {
        code: 2,
        description: "user_heart_beat_timeout"
    },
    2: {
        code: 3,
        description: "user_repeat_login"
    },
    3: {
        code: 4,
        description: "user_kicked_out"
    },
    4: {
        code: 5,
        description: "user_offline"
    },
    100: {
        code: 6,
        description: "remove_by_server"
    }
    // 1000: {
    //     code: 0,
    //     description: 'unknown',
    // },
};
exports.MINIUM_HEARTBEAT_INTERVAL = 3000; //最小心跳尝试间隔
exports.ENUM_STREAM_UPDATE_CMD = {
    added: 12001,
    deleted: 12002,
    updated: 12003
};
exports.ENUM_STREAM_UPDATE_CMD_PRI = {
    added: 1,
    updated: 2,
    deleted: 3
};
exports.SERVER_ERROR_CODE = 10000;
var QUALITYLEVEL;
(function (QUALITYLEVEL) {
    QUALITYLEVEL[QUALITYLEVEL["low"] = 1] = "low";
    QUALITYLEVEL[QUALITYLEVEL["stantard"] = 2] = "stantard";
    QUALITYLEVEL[QUALITYLEVEL["hight"] = 3] = "hight";
    QUALITYLEVEL[QUALITYLEVEL["custome"] = 4] = "custome";
})(QUALITYLEVEL = exports.QUALITYLEVEL || (exports.QUALITYLEVEL = {}));
exports.ENUM_SIGNAL_SUB_CMD = {
    none: 0,
    joinLiveRequest: 1001,
    joinLiveResult: 1002,
    joinLiveInvite: 1003,
    joinLiveStop: 1004
};
exports.ENUM_PUSH_SIGNAL_SUB_CMD = {
    none: 0,
    pushJoinLiveRequest: 11001,
    pushJoinLiveResult: 11002,
    pushJoinLiveInvite: 11003,
    pushJoinLiveStop: 11004
};
exports.ENUM_PUBLISH_STATE_NEGO = {
    stop: 0,
    start: 1,
    waiterAnswer: 2,
    waitingCandidate: 3,
    sendCandidate: 4,
    iceConnected: 5,
    iceDisconnected: 6,
    iceClosed: 7,
    iceFailed: 8
};
//拉流选择
var ENUM_PLAY_SOURCE_TYPE;
(function (ENUM_PLAY_SOURCE_TYPE) {
    ENUM_PLAY_SOURCE_TYPE[ENUM_PLAY_SOURCE_TYPE["cdn"] = 0] = "cdn";
    ENUM_PLAY_SOURCE_TYPE[ENUM_PLAY_SOURCE_TYPE["ultra"] = 1] = "ultra";
})(ENUM_PLAY_SOURCE_TYPE = exports.ENUM_PLAY_SOURCE_TYPE || (exports.ENUM_PLAY_SOURCE_TYPE = {}));
//拉流连麦状态
var ENUM_BROADCASTER_STATUS;
(function (ENUM_BROADCASTER_STATUS) {
    ENUM_BROADCASTER_STATUS[ENUM_BROADCASTER_STATUS["stop"] = 0] = "stop";
    ENUM_BROADCASTER_STATUS[ENUM_BROADCASTER_STATUS["start"] = 1] = "start";
})(ENUM_BROADCASTER_STATUS = exports.ENUM_BROADCASTER_STATUS || (exports.ENUM_BROADCASTER_STATUS = {}));
//推流选择
var ENUM_DISPATCH_TYPE;
(function (ENUM_DISPATCH_TYPE) {
    ENUM_DISPATCH_TYPE[ENUM_DISPATCH_TYPE["cdn"] = 0] = "cdn";
    ENUM_DISPATCH_TYPE[ENUM_DISPATCH_TYPE["ultra"] = 1] = "ultra";
    ENUM_DISPATCH_TYPE[ENUM_DISPATCH_TYPE["customUrl"] = 2] = "customUrl";
})(ENUM_DISPATCH_TYPE = exports.ENUM_DISPATCH_TYPE || (exports.ENUM_DISPATCH_TYPE = {}));
var ENUM_SOURCE_TYPE;
(function (ENUM_SOURCE_TYPE) {
    ENUM_SOURCE_TYPE[ENUM_SOURCE_TYPE["CDN"] = 0] = "CDN";
    ENUM_SOURCE_TYPE[ENUM_SOURCE_TYPE["BGP"] = 1] = "BGP";
})(ENUM_SOURCE_TYPE = exports.ENUM_SOURCE_TYPE || (exports.ENUM_SOURCE_TYPE = {}));
var E_CLIENT_TYPE;
(function (E_CLIENT_TYPE) {
    E_CLIENT_TYPE[E_CLIENT_TYPE["ClientType_None"] = 0] = "ClientType_None";
    E_CLIENT_TYPE[E_CLIENT_TYPE["ClientType_H5"] = 1] = "ClientType_H5";
    E_CLIENT_TYPE[E_CLIENT_TYPE["ClientType_SmallPragram"] = 2] = "ClientType_SmallPragram";
    E_CLIENT_TYPE[E_CLIENT_TYPE["ClientType_Webrtc"] = 3] = "ClientType_Webrtc"; //webrtc
})(E_CLIENT_TYPE = exports.E_CLIENT_TYPE || (exports.E_CLIENT_TYPE = {}));
var ListNode = /** @class */ (function () {
    function ListNode(id, data) {
        if (id === void 0) { id = null; }
        if (data === void 0) { data = null; }
        this._id = null;
        this.next = null;
        this.prev = null;
        this._id = id;
        this._data = data;
    }
    Object.defineProperty(ListNode.prototype, "id", {
        get: function () {
            if (this._id) {
                return this._id;
            }
            else {
                return null;
            }
        },
        set: function (id) {
            this._id = id;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ListNode.prototype, "data", {
        get: function () {
            return this._data;
        },
        set: function (data) {
            this._data = data;
        },
        enumerable: false,
        configurable: true
    });
    ListNode.prototype.hasNext = function () {
        return this.next && this.next.id;
    };
    ListNode.prototype.hasPrev = function () {
        return this.prev && this.prev.id;
    };
    return ListNode;
}());
exports.ListNode = ListNode;
var LinkedList = /** @class */ (function () {
    function LinkedList() {
        //initialize end buffer nodes
        this.start = new ListNode();
        this.end = new ListNode();
        //initialize counters
        this._idCounter = 0;
        this._numNodes = 0;
        //initialize node pointers
        this.start.next = this.end;
        this.start.prev = null;
        this.end.prev = this.start;
        this.end.next = null;
    }
    /**
     *   Inserts a node before another node in the linked list
     *   @param {Node} toInsertBefore
     *   @param {Node} node
     */
    LinkedList.prototype.insertBefore = function (toInsertBefore, data) {
        var newNode = new ListNode(this._idCounter, data);
        newNode.next = toInsertBefore;
        newNode.prev = toInsertBefore.prev;
        if (toInsertBefore.prev)
            toInsertBefore.prev.next = newNode;
        toInsertBefore.prev = newNode;
        ++this._idCounter;
        ++this._numNodes;
        return newNode;
    };
    /**
     *   Adds data wrapped in a Node object to the end of the linked list
     *   @param {object} data
     */
    LinkedList.prototype.addLast = function (data) {
        return this.insertBefore(this.end, data);
    };
    /**
     *   Alias for addLast
     *   @param {object} data
     */
    LinkedList.prototype.add = function (data) {
        return this.addLast(data);
    };
    /**
     *   Gets and returns the first node in the linked list or null
     *   @return {Node/null}
     */
    LinkedList.prototype.getFirst = function () {
        if (this._numNodes === 0) {
            return null;
        }
        else {
            return this.start.next;
        }
    };
    /**
     *   Gets and returns the last node in the linked list or null
     *   @return {Node/null}
     */
    LinkedList.prototype.getLast = function () {
        if (this._numNodes === 0) {
            return null;
        }
        else {
            return this.end.prev;
        }
    };
    /**
     *   Gets and returns the size of the linked list
     *   @return {number}
     */
    LinkedList.prototype.size = function () {
        return this._numNodes;
    };
    /**
     *   (Internal) Gets and returns the node at the specified index starting from the first in the linked list
     *   Use getAt instead of this function
     *   @param {number} index
     */
    LinkedList.prototype.getFromFirst = function (index) {
        var count = 0, temp = this.start.next;
        if (index >= 0) {
            while (count < index && temp !== null) {
                temp = temp.next;
                ++count;
            }
        }
        else {
            temp = null;
        }
        if (temp === null) {
            throw "Index out of bounds.";
        }
        return temp;
    };
    /**
     *   Gets and returns the Node at the specified index in the linked list
     *   @param {number} index
     */
    LinkedList.prototype.get = function (index) {
        var temp = null;
        if (index === 0) {
            temp = this.getFirst();
        }
        else if (index === this._numNodes - 1) {
            temp = this.getLast();
        }
        else {
            temp = this.getFromFirst(index);
        }
        return temp;
    };
    /**
     *   Removes and returns node from the linked list by rearranging pointers
     *   @param {Node} node
     *   @return {Node}
     */
    LinkedList.prototype.remove = function (node) {
        if (node.prev)
            node.prev.next = node.next;
        if (node.next)
            node.next.prev = node.prev;
        --this._numNodes;
        return node;
    };
    /**
     *   Removes and returns the first node in the linked list if it exists, otherwise returns null
     *   @return {Node/null}
     */
    LinkedList.prototype.removeFirst = function () {
        var temp = null;
        if (this._numNodes > 0 && this.start.next) {
            temp = this.remove(this.start.next);
        }
        return temp;
    };
    /**
     *   Removes and returns the last node in the linked list if it exists, otherwise returns null
     *   @return {Node/null}
     */
    LinkedList.prototype.removeLast = function () {
        var temp = null;
        if (this._numNodes > 0 && this.end.prev) {
            temp = this.remove(this.end.prev);
        }
        return temp;
    };
    /**
     *   Removes all nodes from the list
     */
    LinkedList.prototype.removeAll = function () {
        this.start.next = this.end;
        this.end.prev = this.start;
        this._numNodes = 0;
        this._idCounter = 0;
    };
    /**
     *    Iterates the list calling the given fn for each node
     *    @param {function} fn
     */
    LinkedList.prototype.each = function (iterator) {
        var temp = this.start;
        while (temp.hasNext()) {
            temp = temp.next;
            iterator(temp);
        }
    };
    LinkedList.prototype.find = function (iterator) {
        var temp = this.start, found = false, result = null;
        while (temp.hasNext() && !found) {
            temp = temp.next;
            if (iterator(temp)) {
                result = temp;
                found = true;
            }
        }
        return result;
    };
    LinkedList.prototype.map = function (iterator) {
        var temp = this.start;
        var results = [];
        while (temp.hasNext()) {
            temp = temp.next;
            if (iterator(temp)) {
                results.push(temp);
            }
        }
        return results;
    };
    /**
     *    Alias for addLast
     *    @param {object} data
     */
    LinkedList.prototype.push = function (data) {
        return this.addLast(data);
    };
    /**
     *    Performs insertBefore on the first node
     *    @param {object} data
     */
    LinkedList.prototype.unshift = function (data) {
        if (this._numNodes > 0) {
            this.insertBefore(this.start.next, data);
        }
        else {
            this.insertBefore(this.end, data);
        }
    };
    /**
     *    Alias for removeLast
     */
    LinkedList.prototype.pop = function () {
        return this.removeLast();
    };
    /**
     *    Alias for removeFirst()
     */
    LinkedList.prototype.shift = function () {
        return this.removeFirst();
    };
    return LinkedList;
}());
exports.LinkedList = LinkedList;
exports.ENUM_PUBLISH_STATE_UPDATE = {
    start: 0,
    error: 1,
    retry: 2
};
exports.ENUM_PLAY_STATE_UPDATE = {
    start: 0,
    error: 1,
    retry: 2,
    stop: 3
};
exports.ENUM_RETRY_STATE = {
    didNotStart: 0,
    retrying: 1,
    finished: 2
};
exports.REPORT_ACTION = {
    eventStart: "eventStart",
    eventEndWithMsgInfo: "eventEndWithMsgInfo",
    addEventMsg: "addEventMsg",
    addEvent: "addEvent",
    eventEnd: "eventEnd",
    addMsgInfo: "addMsgInfo"
};
var QualityGrade;
(function (QualityGrade) {
    QualityGrade[QualityGrade["Unknown"] = -1] = "Unknown";
    QualityGrade[QualityGrade["Excellent"] = 0] = "Excellent";
    QualityGrade[QualityGrade["Good"] = 1] = "Good";
    QualityGrade[QualityGrade["Middle"] = 2] = "Middle";
    QualityGrade[QualityGrade["Poor"] = 3] = "Poor";
    QualityGrade[QualityGrade["Die"] = 4] = "Die";
})(QualityGrade = exports.QualityGrade || (exports.QualityGrade = {}));
var QUALITY_CONSTANT;
(function (QUALITY_CONSTANT) {
    QUALITY_CONSTANT[QUALITY_CONSTANT["MinQuality"] = 0] = "MinQuality";
    QUALITY_CONSTANT[QUALITY_CONSTANT["DieQuality"] = 0] = "DieQuality";
    QUALITY_CONSTANT[QUALITY_CONSTANT["PoorMinQuality"] = 1] = "PoorMinQuality";
    QUALITY_CONSTANT[QUALITY_CONSTANT["MiddleMinQuality"] = 30] = "MiddleMinQuality";
    QUALITY_CONSTANT[QUALITY_CONSTANT["GoodMinQuality"] = 60] = "GoodMinQuality";
    QUALITY_CONSTANT[QUALITY_CONSTANT["ExcellentMinQuality"] = 85] = "ExcellentMinQuality";
    QUALITY_CONSTANT[QUALITY_CONSTANT["MaxQuality"] = 100] = "MaxQuality";
})(QUALITY_CONSTANT = exports.QUALITY_CONSTANT || (exports.QUALITY_CONSTANT = {}));
var zego_express_engine_webrtm_1 = __webpack_require__(/*! zego-express-engine-webrtm */ "../zego_express_web_rtm/dist/ZegoExpressWebRTM.js");
Object.defineProperty(exports, "getSeq", ({ enumerable: true, get: function () { return zego_express_engine_webrtm_1.getSeq; } }));
Object.defineProperty(exports, "getReportSeq", ({ enumerable: true, get: function () { return zego_express_engine_webrtm_1.getReportSeq; } }));
Object.defineProperty(exports, "ZegoExpressWebRTMEngine", ({ enumerable: true, get: function () { return zego_express_engine_webrtm_1.ZegoExpressWebRTMEngine; } }));
Object.defineProperty(exports, "ZegoLogger", ({ enumerable: true, get: function () { return zego_express_engine_webrtm_1.ZegoLogger; } }));
Object.defineProperty(exports, "ZegoDataReport", ({ enumerable: true, get: function () { return zego_express_engine_webrtm_1.ZegoDataReport; } }));
Object.defineProperty(exports, "ZegoExpressWebRTM", ({ enumerable: true, get: function () { return zego_express_engine_webrtm_1.ZegoExpressWebRTM; } }));


/***/ }),

/***/ "./sdk/src/common/zego.error.ts":
/*!**************************************!*\
  !*** ./sdk/src/common/zego.error.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorCodeList = void 0;
exports.errorCodeList = {
    // commonErr
    NOT_LOGIN: {
        code: 1000002,
        message: "not login room"
    },
    STREAMID_TOO_LONG: {
        code: 1000014,
        message: "stream ID is too long"
    },
    STREAM_ID_NULL: {
        code: 1000015,
        message: "streamID is empty"
    },
    STREAM_ID_INVALID_CHARACTER: {
        code: 1000016,
        message: "stream ID contains illegal characters"
    },
    NETWORK_BROKEN: {
        code: 1000017,
        message: "network is broken"
    },
    LOCALSTREAM_WRONG: {
        code: 1000018,
        message: "local stream wrong"
    },
    GET_CONFIG_FAIL: {
        code: 1103069,
        message: "get app config fail"
    },
    // 通用错误码
    INPUT_PARAM: {
        code: 1100001,
        message: "input param error."
    },
    TIMEOUT: {
        code: 1100002,
        message: "network timeout."
    },
    SOCKET_CLOSE: {
        code: 1100003,
        msg: "socket close"
    },
    // rtc 码
    INIT_SDK_WRONG: {
        code: 1101000,
        message: "init sdk wrong"
    },
    WX_GET_SETTING_FAIL: {
        code: 1101001,
        message: "wx get setting fail"
    },
    // roomErr
    // NONE_APP_ID: {
    //     code: 1001000,
    //     message: 'app id can not be 0',
    // },
    // ROOM_COUNT_EXCEED: {
    //     code: 1002001,
    //     message: 'login rooms exceeds the upper limit',
    // },
    USER_ID_NULL: {
        code: 1002005,
        message: "user ID is empty"
    },
    USER_ID_INVALID_CHARACTER: {
        code: 1002006,
        message: "user ID contains illegal characters"
    },
    USER_ID_TOO_LONG: {
        code: 1002007,
        message: "user ID is too long"
    },
    USER_NAME_NULL: {
        code: 1002008,
        message: "username is empty"
    },
    // USER_NAME_INVALID_CHARACTER: {
    //     code: 1002009,
    //     message: 'username contains illegal characters',
    // },
    USER_NAME_TOO_LONG: {
        code: 1002010,
        message: "username is too long"
    },
    ROOM_ID_NULL: {
        code: 1002011,
        message: "room ID is empty"
    },
    ROOM_ID_INVALID_CHARACTER: {
        code: 1002012,
        message: "room ID contains illegal characters"
    },
    ROOM_ID_TOO_LONG: {
        code: 1002013,
        message: "room ID is too long"
    },
    LOGIN_TIMEOUT: {
        code: 1002031,
        message: "login timeout"
    },
    ROOM_MAX_USER_COUNT: {
        code: 1002034,
        message: "users logging into the room exceeds the maximum number"
    },
    MULTIPLE_LOGIN_KICKOUT: {
        code: 1002050,
        message: "kickout may be the same user ID login other"
    },
    ROOM_RETRY_TIMEOUT: {
        code: 1002053,
        message: "network is broken and login fail."
    },
    MANUAL_KICKOUT: {
        code: 1002055,
        message: "server has sent a signal to kick out"
    },
    ROOM_INNER_ERROR: {
        code: 1002099,
        message: "room inner error"
    },
    // web
    HEARTBEAT_TIMEOUT: {
        code: 1102001,
        message: "heartbeat timeout."
    },
    // access_svr
    PARSE_JSON_ERROR: {
        code: 1102011,
        message: "parse json error."
    },
    LOGIN_PROCESSING: {
        code: 1102012,
        message: "login is processing."
    },
    LIVEROOM_REQUEST_ERROR: {
        code: 1102013,
        message: "liveroom request error."
    },
    ZPUSH_REQUEST_FAIL: {
        code: 1102014,
        message: "zpush request fail."
    },
    LOGIN_STATE_WRONG: {
        code: 1102015,
        message: "user login state is wrong."
    },
    TOKEN_ERROR: {
        code: 1102016,
        message: "token error"
    },
    DISPATCH_ERROR: {
        code: 1102017,
        message: "dispatch error"
    },
    TOKEN_EXPIRED: {
        code: 1102018,
        message: "token expired"
    },
    SUBCMD_ERROR: {
        code: 1102019,
        message: "subcmd error."
    },
    ZEGO_AUTH_ERROR: {
        code: 1102020,
        message: "zego auth error."
    },
    BIZ_CHANNEL_ERROR: {
        code: 1102021,
        message: "biz channel error."
    },
    DISPATCH_TIMEOUT: {
        code: 1102022,
        message: "dispatch request timeout"
    },
    CONNECT_FAILED: {
        code: 1102023,
        message: "connect signal fail"
    },
    // ROOM_INNER_ERROR: {
    //     code: 1102099,
    //     message: 'unknown error.',
    // },
    // publishStreamErr
    PUBLISHER_MEDIA_SERVER_FORBID: {
        code: 1003025,
        message: "stream is forbided by media server"
    },
    PUBLISHER_EXTRA_INFO_TOO_LONG: {
        code: 1003051,
        message: "stream extra info is too long"
    },
    PUBLISHER_PARAM: {
        code: 1103001,
        message: "input param error"
    },
    PUBLISHER_BROWSER_NOT_SUPPORT: {
        code: 1103002,
        message: "browser do not support"
    },
    PUBLISHER_DISPATCH_FAIL: {
        code: 1103003,
        message: "dispatch request error"
    },
    PUBLISHER_SCREEN_FAILED: {
        code: 1103010,
        message: "screen fail"
    },
    ENUMERATE_DEVICES_FAIL: {
        code: 1103011,
        message: "enumerate devices fail"
    },
    PUBLISHER_DISPATCH_REQUEST_FAIL: {
        code: 1103020,
        message: "dispatch request fail"
    },
    PUBLISHER_SESSION_REQUEST_FAIL: {
        code: 1103021,
        message: "session request fail"
    },
    PUBLISHER_CREATE_OFFER_ERROR: {
        code: 1103022,
        message: "create offer error"
    },
    PUBLISHER_SET_LOCAL_DESC_ERROR: {
        code: 1103023,
        message: "setLocalDescription error"
    },
    PUBLISHER_MEDIA_DESC_ERROR: {
        code: 1103024,
        message: "mediaDesc error"
    },
    PUBLISHER_SET_REMOTE_DESC_ERROR: {
        code: 1103025,
        message: "other side offer error"
    },
    PUBLISHER_CANDIDATE_ERROR: {
        code: 1103026,
        message: "candidate error"
    },
    PUBLISHER_SESSION_CLOSED: {
        code: 1103027,
        message: "server session closed"
    },
    PUBLISHER_MEDIA_CONNECTION_ERROR: {
        code: 1103028,
        message: "ice connection error"
    },
    PUBLISHER_SERVER_NEGO_TIMEOUT: {
        code: 1103030,
        message: "negotiation timeout"
    },
    PUBLISH_DEVICE_OUT_ERR: {
        code: 1103041,
        message: "device change "
    },
    PUBLISH_SCREEN_CANCELED: {
        code: 1103042,
        message: "screen canceled"
    },
    PUBLISH_SCREEN_NOT_SUPPORT: {
        code: 1103043,
        message: "screen not support"
    },
    PUBLISH_NO_PREVIEW: {
        code: 1103044,
        message: "stream is not from zego"
    },
    REPEATED_PULL: {
        code: 1103049,
        message: "repeated pull same stream"
    },
    PUBLISHER_WEBSOCKET_DISCONNECTED: {
        code: 1103050,
        message: "websocket disconnected"
    },
    PUBLISHER_RETRY_TIMEOUT: {
        code: 1103051,
        message: "publisher retry timeout"
    },
    PUBLISHER_HTTPS_REQUIRED: {
        code: 1103053,
        message: "https is required"
    },
    PUBLISHER_NO_PREVIEW: {
        code: 1103054,
        message: "no preview"
    },
    PUBLISHER_STREAM_NO_FOUND: {
        code: 1103055,
        message: "publish stream no found"
    },
    PUBLISHER_IS_PUBLISHING: {
        code: 1103056,
        message: "publish is publishing"
    },
    PUBLISHER_CLIENT_IP_CHANGED: {
        code: 1103058,
        message: "client ip changed"
    },
    PUBLISHER_TTL_OVERTIME: {
        code: 1103059,
        message: "ttl over time"
    },
    PUBLISHER_SESSION_TIMEOUT: {
        code: 1103060,
        message: "session request timeout"
    },
    PUBLISHER_GET_USER_MEDIA_FAIL: {
        code: 1103061,
        message: "get media fail"
    },
    PUBLISHER_DEVICE_NO_ALLOWED: {
        code: 1103064,
        message: "get device not allowed"
    },
    PUBLISHER_DEVICE_NO_READABLE: {
        code: 1103065,
        message: "device is not readable"
    },
    PUBLISHER_OVER_CONSTRAINED: {
        code: 1103066,
        message: "device does not meet constraints"
    },
    PUBLISHER_UPDATE_SDP_TIMEOUT: {
        code: 1103067,
        message: "update sdp time out"
    },
    PUBLISHER_UPDATE_SDP_FAIL: {
        code: 1103068,
        message: "update sdp fail"
    },
    // play
    PLAYER_PARAM: {
        code: 1104001,
        message: "input parm error"
    },
    PLAYER_DISPATCH_REQUEST_FAIL: {
        code: 1104020,
        message: "dispatch request fail"
    },
    PLAYER_SESSION_REQUEST_FAIL: {
        code: 1104021,
        message: "session request fail"
    },
    PLAYER_CREATE_OFFER_ERROR: {
        code: 1104022,
        message: "create offer error"
    },
    PLAYER_SET_LOCAL_DESC_ERROR: {
        code: 1104023,
        message: "setLocalDescription error"
    },
    PLAYER_MEDIA_DESC_ERROR: {
        code: 1104024,
        message: "mediaDesc error"
    },
    PLAYER_SET_REMOTE_DESC_ERROR: {
        code: 1104025,
        message: "other side offer error"
    },
    PLAYER_CANDIDATE_ERROR: {
        code: 1104026,
        message: "candidate error"
    },
    PLAYER_SESSION_CLOSED: {
        code: 1104027,
        message: "server session closed"
    },
    PLAYER_MEDIA_CONNECTION_ERROR: {
        code: 1104028,
        message: "ice connection error"
    },
    PLAYER_WEBSOCKET_DISCONNECTED: {
        code: 1104029,
        message: "websocket disconnected"
    },
    PLAYER_SERVER_NEGO_TIMEOUT: {
        code: 1104030,
        message: "negotiation timeout"
    },
    PLAYER_RETRY_TIMEOUT: {
        code: 1104031,
        message: "player retry timeout"
    },
    PLAYER_IS_PLAYING: {
        code: 1104032,
        message: "player is playing"
    },
    PLAYER_CLIENT_IP_CHANGED: {
        code: 1104033,
        message: "client ip changed"
    },
    PLAYER_TTL_OVERTIME: {
        code: 1104034,
        message: "ttl is over time"
    },
    PLAYER_SESSION_RESET: {
        code: 1104035,
        message: "reset session push"
    },
    PLAYER_SESSION_TIMEOUT: {
        code: 1104036,
        message: "session request timeout"
    },
    PLAYER_PROBE_TIMEOUT: {
        code: 1104037,
        message: "probe time out"
    },
    PLAYER_UNSUPPORTED_PROTOCOL: {
        code: 1104038,
        message: "resource mode is not supported"
    },
    DEVICE_ERROR_TYPE_UNPLUGGED: {
        code: 1006006,
        message: "the device is unplugged"
    },
    // imErr
    IM_CONTENT_NULL: {
        code: 1009001,
        message: "message content is empty"
    },
    IM_CONTENT_TOO_LONG: {
        code: 1009002,
        message: "message content is too long"
    },
    IM_SEND_FAILED: {
        code: 1009010,
        message: "failed to send message"
    },
    // web
    FREQ_LIMITED: {
        code: 1109001,
        message: "frequency limited."
    }
};


/***/ }),

/***/ "./sdk/src/common/zego.log.event.ts":
/*!******************************************!*\
  !*** ./sdk/src/common/zego.log.event.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoWechatLogEvent = exports.ZegoRTCLogEvent = void 0;
var zego_error_1 = __webpack_require__(/*! ./zego.error */ "./sdk/src/common/zego.error.ts");
// import * as fs from "fs";
// import * as path from "path";
var getItem = function (item) { return item; };
exports.ZegoRTCLogEvent = {
    kZegoTaskCreateStream: {
        event: "/sdk/create_stream",
        error: {
            kBrowserNotSupportError: zego_error_1.errorCodeList.PUBLISHER_BROWSER_NOT_SUPPORT,
            kParamError: zego_error_1.errorCodeList.PUBLISHER_PARAM,
            kScreenCancelError: zego_error_1.errorCodeList.PUBLISH_SCREEN_CANCELED,
            kScreenFailedError: zego_error_1.errorCodeList.PUBLISHER_SCREEN_FAILED,
            kScreenNotSupportError: zego_error_1.errorCodeList.PUBLISH_SCREEN_NOT_SUPPORT,
            kHttpsRequiredError: zego_error_1.errorCodeList.PUBLISHER_HTTPS_REQUIRED,
            kGetUserMediaError: zego_error_1.errorCodeList.PUBLISHER_GET_USER_MEDIA_FAIL,
            kDeviceNoAllowedError: zego_error_1.errorCodeList.PUBLISHER_DEVICE_NO_ALLOWED,
            kDeviceNoReadableError: zego_error_1.errorCodeList.PUBLISHER_DEVICE_NO_READABLE,
            kDeviceOverConstrainedError: zego_error_1.errorCodeList.PUBLISHER_OVER_CONSTRAINED
        },
        stream_type: getItem,
        screen: getItem,
        camera: getItem,
        custom: getItem
    },
    kZegoTaskPublishStart: {
        event: "/sdk/api/publish_request",
        error: {
            kPublishParamError: zego_error_1.errorCodeList.PUBLISHER_PARAM,
            kPublishNetworkTimeoutError: zego_error_1.errorCodeList.TIMEOUT,
            kPublishDispatchTimeoutError: zego_error_1.errorCodeList.DISPATCH_TIMEOUT,
            kPublishDispatchError: zego_error_1.errorCodeList.DISPATCH_ERROR,
            kPublishNetworkBrokenError: zego_error_1.errorCodeList.NETWORK_BROKEN,
            kPublishNoPreviewError: zego_error_1.errorCodeList.PUBLISH_NO_PREVIEW,
            kPublishNoLoginError: zego_error_1.errorCodeList.NOT_LOGIN,
            kPublishRetryTimeoutError: zego_error_1.errorCodeList.PUBLISHER_RETRY_TIMEOUT,
            kMediaServerForbidError: zego_error_1.errorCodeList.PUBLISHER_MEDIA_SERVER_FORBID,
            kPublishTokenExpiredError: zego_error_1.errorCodeList.TOKEN_EXPIRED,
            kPublishSessionClosedError: zego_error_1.errorCodeList.PUBLISHER_SESSION_CLOSED,
            kPublishNegoTimeoutError: zego_error_1.errorCodeList.PUBLISHER_SERVER_NEGO_TIMEOUT,
            kCreateOfferError: zego_error_1.errorCodeList.PUBLISHER_CREATE_OFFER_ERROR,
            kSetLocalDescError: zego_error_1.errorCodeList.PUBLISHER_SET_LOCAL_DESC_ERROR,
            kSessionTimeoutError: zego_error_1.errorCodeList.PUBLISHER_SESSION_TIMEOUT,
            kSessionRequestError: zego_error_1.errorCodeList.PUBLISHER_SESSION_REQUEST_FAIL,
            kSetRemoteDescError: zego_error_1.errorCodeList.PUBLISHER_SET_REMOTE_DESC_ERROR,
            kMediaConnectionError: zego_error_1.errorCodeList.PUBLISHER_MEDIA_CONNECTION_ERROR,
            kWebsocketDisconnectedError: zego_error_1.errorCodeList.PUBLISHER_WEBSOCKET_DISCONNECTED,
            kMediaDescError: zego_error_1.errorCodeList.PUBLISHER_MEDIA_DESC_ERROR,
            kCandidateError: zego_error_1.errorCodeList.PUBLISHER_CANDIDATE_ERROR,
            kIsPublishing: zego_error_1.errorCodeList.PUBLISHER_IS_PUBLISHING,
            kClientIPChangedError: zego_error_1.errorCodeList.PUBLISHER_CLIENT_IP_CHANGED,
            kTTLOverTimeError: zego_error_1.errorCodeList.PUBLISHER_TTL_OVERTIME,
            kUpdateMediaDescriptionTimeOut: zego_error_1.errorCodeList.PUBLISHER_UPDATE_SDP_TIMEOUT,
            kUpdateMediaDescriptionError: zego_error_1.errorCodeList.PUBLISHER_UPDATE_SDP_FAIL
        },
        publishOption: getItem,
        message: getItem,
        session_id: getItem,
        stream: getItem,
        video_en_codec_id: getItem,
        cap_w: getItem,
        cap_h: getItem,
        w: getItem,
        h: getItem,
        video_en_fps: getItem,
        video_en_bps: getItem,
        audio_c_channel_count: getItem,
        audio_en_bps: getItem,
        aec_level: getItem,
        ans_level: getItem,
        agc: getItem,
        traffic_control_min_video_bitrate: getItem
    },
    kZegoTaskVideoCaptureSize: {
        event: "/sdk/api/publish_video_c_size",
        session_id: getItem,
        w: getItem,
        h: getItem
    },
    kZegoTaskVideoPlaySize: {
        event: "/sdk/play_video_size_changed",
        session_id: getItem,
        w: getItem,
        h: getItem
    },
    kZegoTaskRePublish: {
        event: "/sdk/republish",
        stream: getItem
    },
    kZegoTaskPublishStop: {
        event: "/sdk/stop_publish",
        error: {
            kParamError: zego_error_1.errorCodeList.PUBLISHER_PARAM
        },
        stream: getItem
    },
    // kZegoTaskRtcPublishStateUpdate: '/rtc/publish_stat_report', ///< 推流质量更新
    // kZegoTaskCdnPublishStateUpdate: '/cdn/publish_stat_report', ///< 推流质量更新
    kZegoTaskPlayStart: {
        event: "/sdk/api/play_request",
        error: {
            kStreamIDNullError: zego_error_1.errorCodeList.STREAM_ID_NULL,
            kPlayParamError: zego_error_1.errorCodeList.PLAYER_PARAM,
            kPlayStreamIDToLongError: zego_error_1.errorCodeList.STREAMID_TOO_LONG,
            kPlayStreamIDInvalidCharacterError: zego_error_1.errorCodeList.STREAM_ID_INVALID_CHARACTER,
            kPlayNoLoginError: zego_error_1.errorCodeList.NOT_LOGIN,
            kPlayRepeatedPullError: zego_error_1.errorCodeList.REPEATED_PULL,
            kPlayNetworkTimeoutError: zego_error_1.errorCodeList.TIMEOUT,
            kPlayDispatchTimeoutError: zego_error_1.errorCodeList.DISPATCH_TIMEOUT,
            kPlayDispatchError: zego_error_1.errorCodeList.DISPATCH_ERROR,
            kPlayNetworkBrokenError: zego_error_1.errorCodeList.NETWORK_BROKEN,
            kPlayUnsupportedResourceMode: zego_error_1.errorCodeList.PLAYER_UNSUPPORTED_PROTOCOL,
            kPlayRetryTimeoutError: zego_error_1.errorCodeList.PLAYER_RETRY_TIMEOUT,
            kPlaySessionClosedError: zego_error_1.errorCodeList.PLAYER_SESSION_CLOSED,
            kPlaySessionResetError: zego_error_1.errorCodeList.PLAYER_SESSION_RESET,
            kPlayNegoTimeoutError: zego_error_1.errorCodeList.PLAYER_SERVER_NEGO_TIMEOUT,
            kCreateOfferError: zego_error_1.errorCodeList.PLAYER_CREATE_OFFER_ERROR,
            kSetLocalDescError: zego_error_1.errorCodeList.PLAYER_SET_LOCAL_DESC_ERROR,
            kSessionRequestError: zego_error_1.errorCodeList.PLAYER_SESSION_REQUEST_FAIL,
            kSessionTimeoutError: zego_error_1.errorCodeList.PLAYER_SESSION_TIMEOUT,
            kSetRemoteDescError: zego_error_1.errorCodeList.PLAYER_SET_REMOTE_DESC_ERROR,
            kMediaConnectionError: zego_error_1.errorCodeList.PLAYER_MEDIA_CONNECTION_ERROR,
            kWebsocketDisconnectedError: zego_error_1.errorCodeList.PLAYER_WEBSOCKET_DISCONNECTED,
            kCandidateError: zego_error_1.errorCodeList.PLAYER_CANDIDATE_ERROR,
            kMediaDescError: zego_error_1.errorCodeList.PLAYER_MEDIA_DESC_ERROR,
            kIsPlaying: zego_error_1.errorCodeList.PLAYER_IS_PLAYING,
            kClientIPChangedError: zego_error_1.errorCodeList.PLAYER_CLIENT_IP_CHANGED,
            kTTLOverTimeError: zego_error_1.errorCodeList.PLAYER_TTL_OVERTIME,
            kProbeTimeOutError: zego_error_1.errorCodeList.PLAYER_PROBE_TIMEOUT
        },
        playOption: getItem,
        message: getItem,
        session_id: getItem,
        stream: getItem,
        audio_activate: getItem,
        video_activate: getItem
    },
    kZegoTaskRePlay: {
        event: "/sdk/replay",
        stream: getItem
    },
    kZegoTaskPlayStop: {
        event: "/sdk/stop_play",
        error: {
            kParamError: zego_error_1.errorCodeList.PUBLISHER_PARAM
        },
        stream: getItem
    },
    // kZegoTaskDispatch: '/rtc/dispatch', ///< Dispatch
    kZegoTaskEnumDevices: {
        event: "/device/list",
        error: {
            kBrowserNotSupportError: zego_error_1.errorCodeList.PUBLISHER_BROWSER_NOT_SUPPORT,
            kEnumDevicesError: zego_error_1.errorCodeList.ENUMERATE_DEVICES_FAIL
        },
        dev_list: getItem
    },
    kZegoTaskAudioOutput: {
        event: "/device/audio_capture",
        error: {
            kBrowserNotSupportError: zego_error_1.errorCodeList.PUBLISHER_BROWSER_NOT_SUPPORT,
            kEnumDevicesError: zego_error_1.errorCodeList.ENUMERATE_DEVICES_FAIL
        },
        session_id: getItem,
        device: getItem
    },
    kZegoTaskVideoCapture: {
        event: "/device/video_capture",
        error: {
            kBrowserNotSupportError: zego_error_1.errorCodeList.PUBLISHER_BROWSER_NOT_SUPPORT,
            kEnumDevicesError: zego_error_1.errorCodeList.ENUMERATE_DEVICES_FAIL
        },
        session_id: getItem,
        device: getItem
    },
    kZegoTaskDeviceInterrupt: {
        event: "/device/interrupt",
        error: {
            kBrowserNotSupportError: zego_error_1.errorCodeList.PUBLISHER_BROWSER_NOT_SUPPORT,
            kEnumDevicesError: zego_error_1.errorCodeList.ENUMERATE_DEVICES_FAIL
        },
        session_id: getItem,
        interrupt: getItem
    },
    kZegoTaskSetDebug: "/sdk/set_debug",
    kZegoTaskSetLog: "/sdk/set_log_config",
    kZegoTaskCheckSystemRequirements: {
        event: "/sdk/check_system",
        capability: getItem
    },
    kZegoTaskRemoteCameraUpdate: {
        event: "/sdk/remote_camera_update",
        stream: getItem,
        status: getItem
    },
    kZegoTaskRemoteMicUpdate: {
        event: "/sdk/remote_mic_update",
        stream: getItem,
        status: getItem
    },
    kZegoTaskDestroyStream: {
        event: "/sdk/destroy_stream",
        error: {
            kLocalStreamError: zego_error_1.errorCodeList.LOCALSTREAM_WRONG
        }
    },
    kZegoTaskScreenSharingEnded: "/sdk/screen_share_end",
    kZegoTaskAudioOutputChanged: {
        event: "/device/api/audio_output",
        session_id: getItem,
        stream: getItem,
        device: getItem,
        reason: getItem
    },
    kZegoEventPublishStat: "/sdk/publish_stat_report",
    kZegoEventPlayStat: "/sdk/play_stat_report",
    kZegoTaskLiveRoomGetStreamUpdateInfo: {
        event: "/liveroom/get_stream_update_info",
        stream_update_type: getItem,
        update_stream: getItem
    },
    kZegoTaskLiveRoomGetStreamExtraInfo: {
        event: "/liveroom/get_stream_extra_info",
        update_stream: getItem
    },
    kZegoTaskPlayDecodeFirstVideoFrame: {
        event: "/sdk/play_decode_first_video_frame",
        session_id: getItem,
        fft_consumed: getItem
    },
    kZegoVisibilityChange: {
        event: "/app/background"
    },
    kZegoSetCaptureVolume: {
        event: "/sdk/set_capture_volume",
        error: {
            kParamError: zego_error_1.errorCodeList.INPUT_PARAM
        }
    },
    kZegoListener: {
        event: "/sdk/listener"
    },
    kZegoNetProbe: {
        event: "/sdk/net_probe"
    },
    kZegoNetProbeResult: {
        event: "/sdk/net_probe_result"
    },
    kZegoTaskCloudSettingCache: {
        event: "/cloud_setting/cache"
    },
    kZegoTaskCloudSettingRefresh: {
        event: "/cloud_setting/refresh"
    }
};
exports.ZegoWechatLogEvent = {
    kZegoTaskCheckSystemRequirements: {
        event: "/sdk/check_system",
        error: {
            kCheckSystemGetSettingFailError: zego_error_1.errorCodeList.WX_GET_SETTING_FAIL
        },
        capability: getItem
    },
    kZegoTaskPublishStart: {
        event: "/sdk/api/publish_request",
        error: {
            kPublishStreamIDNullError: zego_error_1.errorCodeList.STREAM_ID_NULL,
            kPublishParamError: zego_error_1.errorCodeList.PUBLISHER_PARAM,
            kPublishStreamIDTooLongError: zego_error_1.errorCodeList.STREAMID_TOO_LONG,
            kPublishStreamIDInvalidCharacterError: zego_error_1.errorCodeList.STREAM_ID_INVALID_CHARACTER,
            kPublishNetworkTimeoutError: zego_error_1.errorCodeList.TIMEOUT,
            kPublishDispatchTimeoutError: zego_error_1.errorCodeList.DISPATCH_TIMEOUT,
            kPublishDispatchError: zego_error_1.errorCodeList.DISPATCH_ERROR,
            kPublishNetworkBrokenError: zego_error_1.errorCodeList.NETWORK_BROKEN,
            kPublishNoLoginError: zego_error_1.errorCodeList.NOT_LOGIN,
            kPublishRetryTimeoutError: zego_error_1.errorCodeList.PUBLISHER_RETRY_TIMEOUT,
            kIsPublishing: zego_error_1.errorCodeList.PUBLISHER_IS_PUBLISHING
        },
        publishOption: getItem,
        stream: getItem,
        message: getItem
    },
    kZegoTaskPlayStart: {
        event: "/sdk/api/play_request",
        error: {
            kPlayStreamIDNullError: zego_error_1.errorCodeList.STREAM_ID_NULL,
            kPlayParamError: zego_error_1.errorCodeList.PLAYER_PARAM,
            kPlayStreamIDTooLongError: zego_error_1.errorCodeList.STREAMID_TOO_LONG,
            kPlayStreamIDInvalidCharacterError: zego_error_1.errorCodeList.STREAM_ID_INVALID_CHARACTER,
            kPlayNoLoginError: zego_error_1.errorCodeList.NOT_LOGIN,
            kPlayRepeatedPullError: zego_error_1.errorCodeList.REPEATED_PULL,
            kPlayNetworkTimeoutError: zego_error_1.errorCodeList.TIMEOUT,
            kPlayDispatchTimeoutError: zego_error_1.errorCodeList.DISPATCH_TIMEOUT,
            kPlayDispatchError: zego_error_1.errorCodeList.DISPATCH_ERROR,
            kPlayNetworkBrokenError: zego_error_1.errorCodeList.NETWORK_BROKEN,
            kPlayRetryTimeoutError: zego_error_1.errorCodeList.PLAYER_RETRY_TIMEOUT,
            kIsPlaying: zego_error_1.errorCodeList.PLAYER_IS_PLAYING
        },
        playOption: getItem,
        message: getItem,
        session_id: getItem,
        stream: getItem,
        audio_activate: getItem,
        video_activate: getItem
    },
    kZegoEventPublishStat: "/sdk/publish_stat_report",
    kZegoEventPlayStat: "/sdk/play_stat_report",
    kZegoTaskRePublish: "/sdk/republish",
    kZegoTaskRePlay: "/sdk/replay",
    kZegoTaskPublishStop: {
        event: "/sdk/stop_publish",
        error: {
            kParamError: zego_error_1.errorCodeList.PUBLISHER_PARAM
        },
        stream: getItem
    },
    kZegoTaskPlayStop: {
        event: "/sdk/stop_play",
        error: {
            kParamError: zego_error_1.errorCodeList.PUBLISHER_PARAM
        },
        stream: getItem
    },
    kZegoTaskLiveRoomGetStreamUpdateInfo: {
        event: "/liveroom/get_stream_update_info",
        stream_update_type: getItem,
        update_stream: getItem
    },
    kZegoTaskLiveRoomGetStreamExtraInfo: {
        event: "/liveroom/get_stream_extra_info",
        update_stream: getItem
    }
};
// fs.writeFile(
//   path.resolve(__dirname, "../../../doc/logevent.json"),
//   JSON.stringify(ZegoRTCLogEvent),
//   "utf8",
//   err => {
//     console.log(err);
//   }
// );


/***/ }),

/***/ "./sdk/src/modules/advance/action.ts":
/*!*******************************************!*\
  !*** ./sdk/src/modules/advance/action.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZEGO_WEBRTC_ACTION = void 0;
var ZEGO_WEBRTC_ACTION;
(function (ZEGO_WEBRTC_ACTION) {
    ZEGO_WEBRTC_ACTION["SET_VIDEO_CONFIG"] = "zc.svc";
    ZEGO_WEBRTC_ACTION["SET_AUDIO_CONFIG"] = "zc.sac";
    ZEGO_WEBRTC_ACTION["REPLACE_TRACK"] = "zc.rp";
    ZEGO_WEBRTC_ACTION["SET_BEAUTY_EFFECT"] = "zc.sbe";
    ZEGO_WEBRTC_ACTION["ENABLE_STREAM"] = "zc.es";
    ZEGO_WEBRTC_ACTION["ENABLE_MIC_ONLY"] = "zc.emo";
    ZEGO_WEBRTC_ACTION["ACTIVATE_SEI_INSERT"] = "zc.asi";
    ZEGO_WEBRTC_ACTION["MUTE_PUBLISH_STREAM_VIDEO"] = "zc.mpsv.0";
    ZEGO_WEBRTC_ACTION["MUTE_PUBLISH_STREAM_AUDIO"] = "zc.mpsa.0";
    ZEGO_WEBRTC_ACTION["MUTE_MIC"] = "zc.mm";
    ZEGO_WEBRTC_ACTION["MUTE_PLAY_STREAM_VIDEO"] = "zc.mpsv.1";
    ZEGO_WEBRTC_ACTION["MUTE_PLAY_STREAM_AUDIO"] = "zc.mpsa.1";
    ZEGO_WEBRTC_ACTION["ADD_TRACK"] = "zc.at";
    ZEGO_WEBRTC_ACTION["REMOVE_TRACK"] = "zc.rt";
    ZEGO_WEBRTC_ACTION["HANDLE_TRACK"] = "zc.ht"; //处理轨道
})(ZEGO_WEBRTC_ACTION = exports.ZEGO_WEBRTC_ACTION || (exports.ZEGO_WEBRTC_ACTION = {}));


/***/ }),

/***/ "./sdk/src/modules/advance/advancedModule.ts":
/*!***************************************************!*\
  !*** ./sdk/src/modules/advance/advancedModule.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdvancedModule = void 0;
var action_1 = __webpack_require__(/*! ./action */ "./sdk/src/modules/advance/action.ts");
var error_1 = __webpack_require__(/*! ./error */ "./sdk/src/modules/advance/error.ts");
var log_event_1 = __webpack_require__(/*! ./log.event */ "./sdk/src/modules/advance/log.event.ts");
var AdvancedModule = /** @class */ (function () {
    function AdvancedModule(logger, dataReport, streamCenter, stateCenter) {
        this.logger = logger;
        this.dataReport = dataReport;
        this.streamCenter = streamCenter;
        this.stateCenter = stateCenter;
        this.screenShotReady = false;
    }
    //修改推流参数
    AdvancedModule.prototype.setVideoConfig = function (localStream, constraints) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SET_VIDEO_CONFIG + " call");
        return new Promise(function (resolve, reject) {
            var reportSeq = _this.stateCenter.getReportSeq();
            _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.event);
            if (!(localStream instanceof MediaStream)) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_VIDEO_CONFIG + " localStream not found");
                _this.dataReport.addMsgInfo(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kLocalStreamError);
                _this.dataReport.uploadReport(reportSeq);
                reject({
                    errorCode: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.code,
                    extendedData: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.message +
                        " localStream no found"
                });
                return;
            }
            if (!constraints ||
                typeof constraints !== "object" ||
                Object.keys(constraints).length == 0) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_VIDEO_CONFIG + " constraints wrong");
                _this.dataReport.addMsgInfo(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError);
                _this.dataReport.uploadReport(reportSeq);
                reject({
                    errorCode: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.code,
                    extendedData: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.message +
                        " constraints wrong"
                });
                return;
            }
            if (constraints.width &&
                !_this.stateCenter.checkValidNumber(constraints.width)) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_VIDEO_CONFIG +
                    " constraints width integer number, range[1, 10000]");
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.code,
                    message: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.message +
                        " constraints width integer number, range[1, 10000]"
                });
                _this.dataReport.uploadReport(reportSeq);
                reject({
                    errorCode: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.code,
                    extendedData: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.message +
                        " constraints wrong"
                });
                return;
            }
            if (constraints.height &&
                !_this.stateCenter.checkValidNumber(constraints.height)) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_VIDEO_CONFIG +
                    " constraints height integer number, range[1, 10000]");
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.code,
                    message: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.message +
                        " constraints height integer number, range[1, 10000]"
                });
                _this.dataReport.uploadReport(reportSeq);
                reject({
                    errorCode: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.code,
                    extendedData: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.message +
                        " constraints wrong"
                });
                return;
            }
            var interResolve = function (result) {
                _this.dataReport.uploadReport(reportSeq);
                resolve(result);
            };
            _this.setPublishStreamConstraints(localStream, constraints, interResolve);
        });
    };
    AdvancedModule.prototype.setAudioConfig = function (localStream, constraints) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SET_AUDIO_CONFIG + " call");
        return new Promise(function (resolve) {
            var reportSeq = _this.stateCenter.getReportSeq();
            _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoSetAudioConfig.event);
            if (!(localStream instanceof MediaStream)) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_AUDIO_CONFIG + " localStream not found");
                _this.dataReport.addMsgInfo(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoSetAudioConfig.error.kParamError);
                _this.dataReport.uploadReport(reportSeq);
                resolve({
                    errorCode: log_event_1.ZegoRTCLogEvent.kZegoSetAudioConfig.error.kParamError.code,
                    extendedData: log_event_1.ZegoRTCLogEvent.kZegoSetAudioConfig.error.kParamError.message +
                        " localStream no found"
                });
                return;
            }
            if (!constraints ||
                typeof constraints !== "object" ||
                Object.keys(constraints).length == 0 ||
                (constraints.AEC !== undefined &&
                    typeof constraints.AEC !== "boolean") ||
                (constraints.AGC !== undefined &&
                    typeof constraints.AGC !== "boolean") ||
                (constraints.ANS !== undefined && typeof constraints.ANS !== "boolean")) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_AUDIO_CONFIG + " constraints wrong");
                _this.dataReport.addMsgInfo(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoSetAudioConfig.error.kParamError);
                _this.dataReport.uploadReport(reportSeq);
                resolve({
                    errorCode: log_event_1.ZegoRTCLogEvent.kZegoSetAudioConfig.error.kParamError.code,
                    extendedData: log_event_1.ZegoRTCLogEvent.kZegoSetAudioConfig.error.kParamError.message +
                        " constraints wrong"
                });
                return;
            }
            var interResolve = function (result) {
                _this.dataReport.uploadReport(reportSeq);
                resolve(result);
            };
            _this.setPublishStreamConstraints(localStream, constraints, interResolve);
        });
    };
    AdvancedModule.prototype.enableStream = function (localStream, option) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.ENABLE_STREAM + " call");
        if (typeof option.video !== "boolean" &&
            typeof option.audio !== "boolean") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.ENABLE_STREAM + " option error");
            return false;
        }
        var video = true, audio = true;
        if (typeof option.video == "boolean") {
            video = this.enableCamera(localStream, option.video, option.retain);
        }
        if (typeof option.audio == "boolean") {
            audio = this.enableMicrophone(localStream, option.audio);
        }
        return video && audio;
    };
    AdvancedModule.prototype.enableMicrophoneOnly = function (enable) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.ENABLE_MIC_ONLY + " call");
        if (typeof enable !== "boolean") {
            // this.logger.error(ZEGO_WEBRTC_ACTION.ENABLE_STREAM + " option error");
            return false;
        }
        var changedCount = 0;
        for (var index = 0; index < this.streamCenter.previewStreamList.length; index++) {
            var preview = this.streamCenter.previewStreamList[index];
            var result = preview.enableMicrophoneOnly(enable, this.streamCenter);
            if (result) {
                changedCount++;
            }
            else {
                this.logger.error("zsc.emo.0 previewer " + index + " change mic mute state failed");
                return false;
            }
        }
        this.streamCenter.isMicEnabled = enable;
        return true;
    };
    AdvancedModule.prototype.replaceTrack = function (localStream, mediaStreamTrack) {
        return __awaiter(this, void 0, void 0, function () {
            var seq, result;
            return __generator(this, function (_a) {
                seq = this.stateCenter.getReportSeq();
                this.dataReport.newReport(seq, log_event_1.ZegoRTCLogEvent.kZegoReplaceTrack.event);
                if (!(localStream instanceof MediaStream)) {
                    this.logger.error(action_1.ZEGO_WEBRTC_ACTION.REPLACE_TRACK + " localStream not found");
                    this.dataReport.uploadReport(seq, undefined, log_event_1.ZegoRTCLogEvent.kZegoReplaceTrack.error.kParamError);
                    return [2 /*return*/, {
                            errorCode: log_event_1.ZegoRTCLogEvent.kZegoReplaceTrack.error.kParamError.code,
                            extendedData: log_event_1.ZegoRTCLogEvent.kZegoReplaceTrack.error.kParamError.message +
                                " localStream no found"
                        }];
                }
                if (!mediaStreamTrack || !(mediaStreamTrack instanceof MediaStreamTrack)) {
                    this.logger.error(action_1.ZEGO_WEBRTC_ACTION.REPLACE_TRACK + " mediastream track no found");
                    this.dataReport.uploadReport(seq, undefined, log_event_1.ZegoRTCLogEvent.kZegoReplaceTrack.error.kParamError);
                    return [2 /*return*/, {
                            errorCode: log_event_1.ZegoRTCLogEvent.kZegoReplaceTrack.error.kParamError.code,
                            extendedData: log_event_1.ZegoRTCLogEvent.kZegoReplaceTrack.error.kParamError.message +
                                " mediastream track no found"
                        }];
                }
                result = this._replaceTrack(localStream, mediaStreamTrack);
                this.dataReport.uploadReport(seq);
                return [2 /*return*/, result];
            });
        });
    };
    AdvancedModule.prototype.setPublishStreamConstraints = function (stream, constraints, success) {
        var _this = this;
        var publisher = null;
        this.logger.info("zsc.spsc.0 constraints", JSON.stringify(constraints));
        for (var i in this.streamCenter.publisherList) {
            this.streamCenter.publisherList[i].localStream == stream &&
                (publisher = this.streamCenter.publisherList[i]);
        }
        if (!publisher) {
            this.logger.error("zsc.spsc.0 publisher not found");
            success &&
                success({
                    errorCode: error_1.errorCodeList.PUBLISH_NOT_PUBLISH.code,
                    extendedData: error_1.errorCodeList.PUBLISH_NOT_PUBLISH.message
                });
            return;
        }
        this.logger.info("zsc.spsc.0 streamId ", publisher.streamID);
        var preview = publisher === null || publisher === void 0 ? void 0 : publisher.publisher.previewer;
        if (!preview) {
            this.logger.error("zsc.spsc.0 preview no found");
            success &&
                success({
                    errorCode: error_1.errorCodeList.PUBLISH_NO_PREVIEW.code,
                    extendedData: error_1.errorCodeList.PUBLISH_NO_PREVIEW.message
                });
            return;
        }
        // if ((constraints.width && constraints.width < 100) || (constraints.height && constraints.height < 100)) {
        //     this.logger.error('zsc.spsc.0 constraints wrong');
        //     error && error(errorCodeList.INPUT_PARAM);
        //     return;
        // }
        var applyVideo = false;
        var applyAudio = false;
        if (constraints.width || constraints.height || constraints.frameRate) {
            preview.mediaStreamConfig.videoQuality = 4;
            applyVideo = true;
        }
        if (constraints.ANS !== undefined ||
            constraints.AGC !== undefined ||
            constraints.AEC !== undefined) {
            applyAudio = true;
        }
        var localStream = preview.localStream;
        var videoTrack = preview.videoTrack;
        var audioTrack = preview.audioTrack;
        if (applyVideo && !videoTrack) {
            this.logger.error("zsc.spsc.0 video track not found");
            success &&
                success({
                    errorCode: error_1.errorCodeList.TRACK_NOT_FOUND.code,
                    extendedData: error_1.errorCodeList.TRACK_NOT_FOUND.message
                });
        }
        else {
            constraints.video = true;
        }
        if (applyAudio && !audioTrack) {
            this.logger.error("zsc.spsc.0 audio track not found");
            success &&
                success({
                    errorCode: error_1.errorCodeList.TRACK_NOT_FOUND.code,
                    extendedData: error_1.errorCodeList.TRACK_NOT_FOUND.message
                });
        }
        else {
            constraints.audio = true;
        }
        var oldMediaStreamConfig = JSON.parse(JSON.stringify(preview.mediaStreamConfig));
        var mediaStreamConfig = Object.assign(preview.mediaStreamConfig, constraints);
        var mediaStreamConstraints = preview.getMediaStreamConstraints(mediaStreamConfig, true);
        this.logger.info("zsc.spsc.0 applyConstraints ", JSON.stringify(mediaStreamConstraints));
        var promiseList = [];
        if (applyVideo) {
            promiseList.push(videoTrack.applyConstraints(mediaStreamConstraints.video));
        }
        if (applyAudio) {
            audioTrack.stop();
            promiseList.push(navigator.mediaDevices.getUserMedia({
                video: false,
                audio: mediaStreamConstraints.audio
            }));
        }
        if (constraints.maxBitrate) {
            var sender = publisher.publisher.peerConnection
                .getSenders()
                .find(function (s) { return s.track && s.track.kind === "video"; });
            var parameters = sender.getParameters();
            if (sender) {
                if (!parameters.encodings) {
                    parameters.encodings = [{}];
                }
                // parameters.encodings[0].minBitrate = minBitRate * 1e3;
                parameters.encodings[0].maxBitrate = constraints.maxBitrate * 1e3;
                promiseList.push(sender.setParameters(parameters));
            }
            else {
                this.logger.error("zsc.spsc.0 video sender no found");
            }
        }
        if (promiseList.length > 0) {
            Promise.all(promiseList)
                .then(function (values) {
                _this.logger.info("zsc.spsc.0 set constraints success", values[1]);
                var stream;
                if (applyAudio) {
                    if (applyVideo) {
                        stream = values[1];
                    }
                    else {
                        stream = values[0];
                    }
                    var audioTrack_1 = stream.getAudioTracks()[0];
                    audioTrack_1.enabled = publisher.publisher.mic_status === 0;
                    var sender = publisher.publisher.peerConnection
                        .getSenders()
                        .find(function (s) { return s.track.kind === "audio"; });
                    if (sender) {
                        sender.replaceTrack(audioTrack_1);
                        if (localStream) {
                            var preview_1 = _this.streamCenter.checkPreview(localStream);
                            if (preview_1) {
                                preview_1.replacePreviewTrack(audioTrack_1);
                                preview_1.gainNode = null;
                            }
                        }
                    }
                }
                //最大码率发生变化
                if (constraints.maxBitrate) {
                    publisher.publisher &&
                        (publisher.publisher.videoInfo.bitRate = constraints.maxBitrate);
                }
                success && success({ errorCode: 0, extendedData: "" });
            })
                .catch(function (err) {
                _this.logger.error("zsc.spsc.0 fail reason ", err.name, JSON.stringify(err));
                success &&
                    success({
                        errorCode: error_1.errorCodeList.PUBLISHER_CONSTRAINTS_ERROR.code,
                        extendedData: err.name + " " + (err.constraint ? "constraint:" + err.constraint : "")
                    });
            });
        }
        else {
            this.logger.warn("zsc.spsc.0 constaints is no changes");
            if (applyAudio) {
                var oldMediaStreamConstraints = preview.getMediaStreamConstraints(oldMediaStreamConfig);
                this.logger.info("zsc.spsc.0 oldMediaStreamConstraints ", JSON.stringify(oldMediaStreamConstraints));
                navigator.mediaDevices
                    .getUserMedia({
                    video: false,
                    audio: oldMediaStreamConstraints.audio
                })
                    .then(function (_stream) {
                    var backAudioTrack = _stream.getAudioTracks()[0];
                    var localAudioTrack = preview.audioTrack || audioTrack;
                    var sender = publisher.publisher.peerConnection
                        .getSenders()
                        .find(function (s) {
                        return s.track !== null && s.track.kind === audioTrack.kind;
                    });
                    if (sender) {
                        sender.replaceTrack(backAudioTrack);
                        var previewer = _this.streamCenter.checkPreview(localStream);
                        previewer && previewer.replacePreviewTrack(backAudioTrack);
                    }
                    _this.logger.info("zsc.spsc.0.1 setbackup suc ");
                })
                    .catch(function (_err) {
                    _this.logger.error("zsc.spsc.0.1 setbackup fail " + _err.name);
                });
            }
            success &&
                success({
                    errorCode: error_1.errorCodeList.PUBLISHER_CONSTRAINTS_ERROR.code,
                    extendedData: "constraints is no changes"
                });
        }
    };
    AdvancedModule.prototype.useVideoDevice = function (localStream, deviceID) {
        var _this = this;
        this.logger.info("zc.uvd.0 call");
        return new Promise(function (resolve) {
            var reportSeq = _this.stateCenter.getReportSeq();
            _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.event);
            _this.dataReport.addMsgInfo(reportSeq, {
                device: log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.device(deviceID)
            });
            if (!(localStream instanceof MediaStream)) {
                _this.logger.error("zc.uvd.0 localStream not found");
                _this.dataReport.addMsgInfo(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.error.kLocalStreamError);
                _this.dataReport.uploadReport(reportSeq);
                resolve({
                    errorCode: log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.error.kParamError.code,
                    extendedData: log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.error.kParamError.message
                });
                return;
            }
            if (typeof deviceID !== "string") {
                _this.logger.error("zc.uvd.0 deviceID must be string");
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.error.kParamError.code,
                    message: log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.error.kParamError.message +
                        " deviceID must be string"
                });
                _this.dataReport.uploadReport(reportSeq);
                resolve({
                    errorCode: log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.error.kParamError.code,
                    extendedData: log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.error.kParamError.message
                });
                return;
            }
            var interResolve = function (res) {
                var _a, _b;
                _this.dataReport.uploadReport(reportSeq);
                var publisher = _this.streamCenter.checkPublish(localStream);
                if (publisher) {
                    publisher.cameraLabel =
                        ((_b = (_a = publisher.publisher.previewer) === null || _a === void 0 ? void 0 : _a.videoTrack) === null || _b === void 0 ? void 0 : _b.label) ||
                            publisher.cameraLabel;
                }
                resolve(res);
            };
            _this.stateCenter.getDevices(function (devicesInfos) {
                var cameras = devicesInfos.cameras;
                if (!cameras.find(function (camera) { return camera.deviceID == deviceID; })) {
                    _this.logger.error("zc.uvd.0 device is not found");
                    resolve({
                        errorCode: log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.error
                            .kDevicesNoFoundError.code,
                        extendedData: log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.error
                            .kDevicesNoFoundError.message
                    });
                    return;
                }
                _this.switchDevice("video", localStream, deviceID, interResolve);
            }, function (err) {
                _this.logger.warn("zc.uvd.0 getDevices err:", err);
                _this.switchDevice("video", localStream, deviceID, interResolve);
            });
        });
        // return this.setPublishStreamConstraints(localStream, {
        //     videoInput: deviceID,
        // });
    };
    AdvancedModule.prototype.useAudioDevice = function (localStream, deviceID) {
        var _this = this;
        this.logger.info("zc.uad.1 call");
        return new Promise(function (resolve) {
            var reportSeq = _this.stateCenter.getReportSeq();
            _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskUseAudioDevice.event);
            _this.dataReport.addMsgInfo(reportSeq, {
                device: log_event_1.ZegoRTCLogEvent.kZegoTaskUseAudioDevice.device(deviceID)
            });
            var interReject = function (error, msg) {
                _this.logger.error("zc.uad.1 " + msg);
                var err = error;
                err.message = err.message + (msg ? " " + msg : "");
                _this.dataReport.addMsgInfo(reportSeq, err);
                _this.dataReport.uploadReport(reportSeq);
                resolve({
                    errorCode: err.code,
                    extendedData: err.message
                });
            };
            var interResolve = function (result) {
                var _a;
                _this.dataReport.uploadReport(reportSeq);
                var publisher = _this.streamCenter.checkPublish(localStream);
                if (publisher) {
                    publisher.microLabel =
                        ((_a = localStream.getAudioTracks()[0]) === null || _a === void 0 ? void 0 : _a.label) || publisher.microLabel;
                }
                resolve(result);
            };
            if (!(localStream instanceof MediaStream)) {
                interReject(log_event_1.ZegoRTCLogEvent.kZegoTaskUseAudioDevice.error.kLocalStreamError, "localStream not found");
                return;
            }
            if (typeof deviceID !== "string") {
                interReject(log_event_1.ZegoRTCLogEvent.kZegoTaskUseAudioDevice.error.kParamError, "deviceID must be string");
                return;
            }
            _this.stateCenter.getDevices(function (devicesInfos) {
                var microphones = devicesInfos.microphones;
                if (!microphones.find(function (microphone) { return microphone.deviceID == deviceID; })) {
                    _this.logger.error("zc.uad.1 device is not found");
                    resolve({
                        errorCode: log_event_1.ZegoRTCLogEvent.kZegoTaskUseAudioDevice.error
                            .kDevicesNoFoundError.code,
                        extendedData: log_event_1.ZegoRTCLogEvent.kZegoTaskUseAudioDevice.error
                            .kDevicesNoFoundError.message
                    });
                    return;
                }
                _this.switchDevice("audio", localStream, deviceID, interResolve);
            }, function (err) {
                _this.logger.warn("zc.uad.1 getDevices err:", err);
                _this.switchDevice("audio", localStream, deviceID, interResolve);
            });
        });
        // return this.setPublishStreamConstraints(localStream, {
        //     audioInput: deviceID,
        // });
    };
    AdvancedModule.prototype.publishTarget = function (cdnPushConfig) {
        var _this = this;
        var reportSeq = this.stateCenter.getReportSeq();
        switch (cdnPushConfig.type) {
            case "addpush":
                this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskAddPublishCdnUrl.event);
                break;
            case "delpush":
                this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskRemovePublishCdnUrl.event);
                break;
            case "clearpush":
                this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskRemovePublishCdnUrl.event);
                break;
        }
        this.dataReport.addMsgInfo(reportSeq, {
            stream: log_event_1.ZegoRTCLogEvent.kZegoTaskRemovePublishCdnUrl.stream(cdnPushConfig.streamID),
            target_url: log_event_1.ZegoRTCLogEvent.kZegoTaskRemovePublishCdnUrl.target_url(cdnPushConfig.pushUrl)
        });
        return new Promise(function (resolve, reject) {
            var innerReject = function (err, externMsg) {
                _this.logger.error("zb.pt" + (externMsg || err.message));
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: err.code,
                    message: err.message + (externMsg || "")
                });
                _this.dataReport.uploadReport(reportSeq);
                reject({
                    errorCode: err.code,
                    extendedData: err.message + (externMsg ? " " + externMsg : "")
                });
            };
            if (["addpush", "delpush", "clearpush"].indexOf(cdnPushConfig.type) == -1) {
                _this.logger.error("zb.sh.pt cdn push type error");
                innerReject(error_1.errorCodeList.PUBLISHER_CDN_PUSH_ERROR, "type error");
                return;
            }
            if (!cdnPushConfig.streamID ||
                typeof cdnPushConfig.streamID !== "string") {
                innerReject(log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kParamError, "stream id type error");
                return;
            }
            if (!cdnPushConfig.pushUrl || typeof cdnPushConfig.pushUrl !== "string") {
                innerReject(log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kParamError, "push url error");
                return;
            }
            if (!_this.stateCenter.publishStreamList[cdnPushConfig.streamID]) {
                innerReject(log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error
                    .kPublishStreamNoFoundError);
                return;
            }
            var room = _this.streamCenter.getRoomByStreamID(cdnPushConfig.streamID);
            if (!room) {
                innerReject(log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kNoLoginError);
                return;
            }
            var innerResolve = function (res) {
                _this.dataReport.uploadReport(reportSeq);
                resolve(res);
            };
            room.streamHandler._publishTarget(cdnPushConfig, innerResolve, innerReject);
        });
    };
    AdvancedModule.prototype.handleTrack = function (type, stream, track, success, error) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var preview, publish, publisher_1, previewer_1, pc, sender_1, transceiver, videoInfo, trackPreview, desc;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(stream instanceof MediaStream)) {
                            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK + " stream wrong");
                            error({
                                errorCode: error_1.errorCodeList.INPUT_PARAM.code,
                                extendedData: error_1.errorCodeList.INPUT_PARAM.message
                            });
                            return [2 /*return*/];
                        }
                        if (!(track instanceof MediaStreamTrack) || track.kind == "audio") {
                            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK + " only can handle video track");
                            error({
                                errorCode: error_1.errorCodeList.INPUT_PARAM.code,
                                extendedData: error_1.errorCodeList.INPUT_PARAM.message
                            });
                            return [2 /*return*/];
                        }
                        preview = this.streamCenter.checkPreview(stream);
                        if (!preview) {
                            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK + " stream no found");
                            error &&
                                error({
                                    errorCode: error_1.errorCodeList.PUBLISH_NO_PREVIEW.code,
                                    extendedData: error_1.errorCodeList.PUBLISH_NO_PREVIEW.message
                                });
                            return [2 /*return*/];
                        }
                        else if (track.kind === "video" && ((_a = preview.videoEffect) === null || _a === void 0 ? void 0 : _a.enabled)) {
                            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK +
                                " need to disable video beauty effect first");
                            error &&
                                error({
                                    errorCode: error_1.errorCodeList.VIDEO_EFFECT_IS_RUNNING.code,
                                    extendedData: "need to disable video beauty effect before add or remove track"
                                });
                            return [2 /*return*/];
                        }
                        if (type == "ADD" &&
                            (stream.getTracks().length >= 2 ||
                                stream.getTracks().find(function (localTrack) { return localTrack.kind == track.kind; }))) {
                            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK +
                                " only stream which have one track and kind no exist can add track");
                            error &&
                                error({
                                    errorCode: error_1.errorCodeList.TRACK_CAN_NOT_ADD.code,
                                    extendedData: error_1.errorCodeList.TRACK_CAN_NOT_ADD.message
                                });
                            return [2 /*return*/];
                        }
                        else if (type == "REMOVE" &&
                            (stream.getTracks().length == 1 || !stream.getTracks().includes(track))) {
                            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK + " not supported");
                            error({
                                errorCode: error_1.errorCodeList.HANDLE_TRACK_NOT_SUPPORTED.code,
                                extendedData: error_1.errorCodeList.HANDLE_TRACK_NOT_SUPPORTED.message
                            });
                            return [2 /*return*/];
                        }
                        publish = this.streamCenter.checkPublish(stream);
                        //协商未完成
                        if (publish &&
                            (publish.publisher.stateNego !== 5 ||
                                publish.publisher.isUpdateSDP == true)) {
                            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK + " publish state wrong");
                            error &&
                                error({
                                    errorCode: error_1.errorCodeList.PUBLISHER_STATE_WRONG.code,
                                    extendedData: error_1.errorCodeList.PUBLISHER_STATE_WRONG.message
                                });
                            return [2 /*return*/];
                        }
                        if (!publish) return [3 /*break*/, 6];
                        publisher_1 = publish.publisher;
                        previewer_1 = preview;
                        pc = publish.publisher.peerConnection;
                        publisher_1.isUpdateSDP = true;
                        if (!(type == "ADD")) return [3 /*break*/, 1];
                        // console.error("pc视轨增加");
                        pc.addTrack(track, stream);
                        return [3 /*break*/, 4];
                    case 1:
                        if (!window.RTCPeerConnection ||
                            //@ts-ignore
                            !window.RTCPeerConnection.prototype.getTransceivers ||
                            !window.RTCRtpTransceiver.prototype.stop) {
                            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK + " not supported getTransceivers");
                            error({
                                errorCode: error_1.errorCodeList.HANDLE_TRACK_NOT_SUPPORTED.code,
                                extendedData: error_1.errorCodeList.HANDLE_TRACK_NOT_SUPPORTED.message
                            });
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, pc
                                .getSenders()
                                .find(function (s) { return s.track && s.track == track; })];
                    case 2:
                        sender_1 = _b.sent();
                        return [4 /*yield*/, pc
                                .getTransceivers()
                                .find(function (tran) { return tran.sender == sender_1; })];
                    case 3:
                        transceiver = _b.sent();
                        if (sender_1 && transceiver && transceiver.stop) {
                            try {
                                pc.removeTrack(sender_1);
                                transceiver.stop();
                            }
                            catch (error) {
                                this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK + " " + error);
                                error &&
                                    error({
                                        errorCode: error_1.errorCodeList.PUBLISHER_UPDATE_SDP_FAIL.code,
                                        extendedData: error_1.errorCodeList.PUBLISHER_UPDATE_SDP_FAIL.message + " " + error
                                    });
                            }
                        }
                        else {
                            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK + " sender no found");
                            error &&
                                error({
                                    errorCode: error_1.errorCodeList.TRACK_NOT_FOUND.code,
                                    extendedData: error_1.errorCodeList.TRACK_NOT_FOUND.message
                                });
                            return [2 /*return*/];
                        }
                        _b.label = 4;
                    case 4:
                        videoInfo = {};
                        trackPreview = this.streamCenter.previewStreamList.find(function (preview) {
                            return preview.localStream
                                .getTracks()
                                .find(function (_track) { return _track == track; });
                        });
                        if (trackPreview && type == "ADD") {
                            videoInfo = trackPreview.videoInfo;
                        }
                        else {
                            videoInfo = {};
                        }
                        return [4 /*yield*/, pc.createOffer()];
                    case 5:
                        desc = _b.sent();
                        publisher_1.onCreateOfferSuccess(desc, true, videoInfo, function (result) { return __awaiter(_this, void 0, void 0, function () {
                            var trackKey;
                            return __generator(this, function (_a) {
                                if (result !== 0) {
                                    error &&
                                        error({
                                            errorCode: error_1.errorCodeList.PUBLISHER_UPDATE_SDP_FAIL.code,
                                            extendedData: error_1.errorCodeList.PUBLISHER_UPDATE_SDP_FAIL.message
                                        });
                                }
                                else {
                                    trackKey = track.kind == "video" ? "videoTrack" : "audioTrack";
                                    if (type == "ADD") {
                                        // console.error("本地视轨增加");
                                        // 替换预览流视轨
                                        stream.addTrack(track);
                                        previewer_1[trackKey] = track;
                                        // 发送新状态
                                        if (track.kind == "video" && track.enabled == true) {
                                            publisher_1.sendStreamStatus(0, publisher_1.mic_status);
                                        }
                                        else if (track.enabled == true) {
                                            publisher_1.sendStreamStatus(publisher_1.camera_status, 0);
                                        }
                                    }
                                    else {
                                        // 发送新状态
                                        if (track.kind == "video") {
                                            publisher_1.sendStreamStatus(2, publisher_1.mic_status);
                                        }
                                        else {
                                            publisher_1.sendStreamStatus(publisher_1.camera_status, 2);
                                        }
                                        // 替换预览流轨
                                        stream.removeTrack(track);
                                        previewer_1[trackKey] = null;
                                    }
                                    if (type == "ADD") {
                                        preview.mediaStreamConfig.video = true;
                                    }
                                    else {
                                        preview.mediaStreamConfig.video = false;
                                    }
                                    success({ errorCode: 0, extendedData: "" });
                                }
                                return [2 /*return*/];
                            });
                        }); });
                        return [3 /*break*/, 7];
                    case 6:
                        type == "ADD" ? stream.addTrack(track) : stream.removeTrack(track);
                        success({ errorCode: 0, extendedData: "" });
                        if (type == "ADD") {
                            preview.mediaStreamConfig.video = true;
                        }
                        else {
                            preview.mediaStreamConfig.video = false;
                        }
                        _b.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    AdvancedModule.prototype.switchDevice = function (type, localStream, deviceId, callBack) {
        var _this = this;
        // let sender;
        var publisherInfo = this.streamCenter.checkPublish(localStream);
        if (publisherInfo &&
            publisherInfo.publisher &&
            publisherInfo.publisher.stateNego !== 5) {
            this.logger.error("zsc.sd.0 stream is publishing");
            callBack &&
                callBack({
                    errorCode: error_1.errorCodeList.PUBLISHER_STREAM_NO_FOUND.code,
                    extendedData: error_1.errorCodeList.PUBLISHER_STREAM_NO_FOUND.message
                });
            return;
        }
        var preview = this.streamCenter.checkPreview(localStream);
        if (!preview) {
            this.logger.error("zsc.sd.0 preview no found");
            callBack &&
                callBack({
                    errorCode: error_1.errorCodeList.PUBLISH_NO_PREVIEW.code,
                    extendedData: error_1.errorCodeList.PUBLISH_NO_PREVIEW.message
                });
            return;
        }
        if (type === "video" && preview.mediaStreamConfig.video == false) {
            this.logger.error("zsc.sd.0 camera can not be changed when video is false");
            callBack &&
                callBack({
                    errorCode: error_1.errorCodeList.VIDEO_DEVICE_FALSE.code,
                    extendedData: error_1.errorCodeList.VIDEO_DEVICE_FALSE.message
                });
            return;
        }
        if (type === "audio" && preview.mediaStreamConfig.audio == false) {
            this.logger.error("zsc.sd.0 microphone can not be changed when audio is false");
            callBack &&
                callBack({
                    errorCode: error_1.errorCodeList.AUDIO_DEVICE_FALSE.code,
                    extendedData: error_1.errorCodeList.AUDIO_DEVICE_FALSE.message
                });
            return;
        }
        if (preview.mediaStreamConfig.videoInput !== deviceId) {
            delete preview.mediaStreamConfig.facingMode;
        }
        var mediaStreamConfig = {};
        var lastTrack;
        if (type === "video") {
            mediaStreamConfig.videoInput = deviceId;
            lastTrack = preview.videoTrack;
        }
        else {
            mediaStreamConfig.audioInput = deviceId;
            lastTrack = preview.audioTrack;
        }
        // const isSafari: boolean = /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
        // 部分手机不关闭上次的流的音视频轨 会导致预览失败（比如 小米8），safari不关闭
        // FireFox 不停止可能会NotReadableError: Concurrent mic process limit
        // !isSafari && lastTrack.stop();
        var bro = this.stateCenter.browser;
        this.logger.info("zsc.sd.0 browser " + bro);
        bro === "firefox" && lastTrack.stop();
        var constraints = __assign(__assign({}, preview.mediaStreamConfig), mediaStreamConfig);
        var mediaStreamConstraints = preview.getMediaStreamConstraints(constraints);
        /**替换本地流和远端流的音轨和视轨 */
        var replaceStreamTracks = function (originStream, newStream) {
            newStream.getTracks().forEach(function (track) {
                if (track.kind === type) {
                    var key = type === "video" ? "videoTrack" : "audioTrack";
                    var localTrack = preview[key];
                    track.enabled = localTrack.enabled;
                    localTrack && localTrack.stop();
                    if (publisherInfo) {
                        publisherInfo.publisher.replacePublishedTrack(track);
                    }
                    else if (preview) {
                        preview.replacePreviewTrack(track);
                    }
                }
                // if (publisherInfo) {
                //   const sender = publisherInfo.publisher.peerConnection
                //     ?.getSenders()
                //     .find((s: any) => s.track !== null && s.track.kind === track.kind);
                //   if (localTrack.kind === type) {
                //     if (sender) {
                //       sender.replaceTrack(track);
                //       preview.gainNode = null;
                //     } else {
                //       this.logger.warn(
                //         "zsc.sd.0 no sender found, only switching device on localMediaElement"
                //       );
                //     }
                //   }
                //   const enable = track.enabled ? 0 : 20;
                //   const publisher = publisherInfo.publisher;
                //   const camera_status = publisher.camera_status;
                //   const mic_status = publisher.mic_status;
                //   if (type == "video" && enable !== camera_status) {
                //     publisher.sendStreamStatus(enable, mic_status);
                //   }
                //   if (type == "audio" && enable !== mic_status) {
                //     publisher.sendStreamStatus(camera_status, enable);
                //   }
                // }
            });
            // 切换设备后修改localStream 需要重新获取音浪
            preview.restartSoundLevel();
        };
        type == "audio"
            ? (mediaStreamConstraints.video = false)
            : (mediaStreamConstraints.audio = false);
        navigator.mediaDevices.getUserMedia(mediaStreamConstraints).then(function (stream) {
            Object.assign(preview.mediaStreamConfig, mediaStreamConfig);
            replaceStreamTracks(localStream, stream);
            _this.logger.info("zsc.sd.0 swtich " + type + " device success");
            callBack && callBack({ errorCode: 0, extendedData: "" });
        }, function (err) {
            var _a, _b;
            // 停止之前的视轨或音轨，进行重新获取设备
            type == "video"
                ? (_a = preview.videoTrack) === null || _a === void 0 ? void 0 : _a.stop() : (_b = preview.audioTrack) === null || _b === void 0 ? void 0 : _b.stop();
            _this.logger.warn("zsc.sd.0 swtich " +
                type +
                " device failed, stop last device and retry. ", err + "");
            navigator.mediaDevices.getUserMedia(mediaStreamConstraints).then(function (stream1) {
                Object.assign(preview.mediaStreamConfig, mediaStreamConfig);
                replaceStreamTracks(localStream, stream1);
                _this.logger.info("zsc.sd.0 swtich " + type + " device success");
                callBack && callBack({ errorCode: 0, extendedData: "" });
            }, function (err1) {
                _this.logger.warn("zsc.sd.0 swtich " +
                    type +
                    " device failed and recover last device. ", err1 + "");
                // recover
                var lastConstraints = preview.getMediaStreamConstraints(preview.mediaStreamConfig);
                var errCode = error_1.errorCodeList.VIDEO_DEVICE_FALSE;
                if (type === "audio") {
                    errCode = error_1.errorCodeList.AUDIO_DEVICE_FALSE;
                }
                navigator.mediaDevices.getUserMedia(lastConstraints).then(function (stream2) {
                    replaceStreamTracks(localStream, stream2);
                    _this.logger.info("zsc.sd.0 recover last " + type + " device success");
                    callBack &&
                        callBack({
                            errorCode: errCode.code,
                            extendedData: errCode.message + " " + JSON.stringify(err1)
                        });
                }, function (err2) {
                    _this.logger.error("zsc.sd.0 swtich " +
                        type +
                        " device and recover failed, please recreate stream. ", err2 + "");
                    callBack &&
                        callBack({
                            errorCode: errCode.code,
                            extendedData: errCode.message + " " + JSON.stringify(err2)
                        });
                });
            });
        });
    };
    AdvancedModule.prototype._replaceTrack = function (localStream, mediaStreamTrack
    // callBack?: (result: { errorCode: number; extendedData: string }) => void
    ) {
        var preview = this.streamCenter.checkPreview(localStream);
        var publisher = this.streamCenter.checkPublish(localStream);
        // const isSafari: boolean =
        //   /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
        if (!publisher) {
            if (!preview) {
                this.logger.error("zc.rt.0 preview no found");
                return {
                    errorCode: error_1.errorCodeList.PUBLISH_NO_PREVIEW.code,
                    extendedData: error_1.errorCodeList.PUBLISH_NO_PREVIEW.message
                };
            }
            var localStream_1 = preview.localStream;
            var localTrack = localStream_1
                .getTracks()
                .find(function (t) { return t.kind === mediaStreamTrack.kind; });
            if (!localTrack) {
                this.logger.error("zc.rt.0 track no found");
                return {
                    errorCode: error_1.errorCodeList.TRACK_NOT_FOUND.code,
                    extendedData: error_1.errorCodeList.TRACK_NOT_FOUND.message
                };
            }
            // !isSafari && localTrack.stop();
            // 替换预览流
            preview.replacePreviewTrack(mediaStreamTrack);
            return { errorCode: 0, extendedData: "" };
        }
        else {
            var result = publisher.publisher.replacePublishedTrack(mediaStreamTrack);
            return result;
        }
    };
    AdvancedModule.prototype.enableMicrophone = function (localStream, enable) {
        var preview = this.streamCenter.checkPreview(localStream);
        if (!preview) {
            this.logger.error("zsc.em.0 no preview");
            return false;
        }
        return preview.enableMicrophone(enable, this.streamCenter);
    };
    AdvancedModule.prototype.enableCamera = function (localStream, enable, retain) {
        var preview = this.streamCenter.checkPreview(localStream);
        if (!preview) {
            this.logger.error("zsc.ec.0 no preview");
            return false;
        }
        return preview.enableCamera(enable, this.streamCenter, retain);
    };
    AdvancedModule.prototype.setBeautyEffect = function (localStream, enable, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // const seq = this.stateCenter.getReportSeq();
            // this.dataReport.newReport(seq, ZegoRTCLogEvent.kZegoReplaceTrack.event);
            // 参数校验
            if (!(localStream instanceof MediaStream)) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_BEAUTY_EFFECT + " localStream not found");
                // this.dataReport.uploadReport(
                //   seq,
                //   undefined,
                //   ZegoRTCLogEvent.kZegoReplaceTrack.error.kParamError
                // );
                reject({
                    errorCode: log_event_1.ZegoRTCLogEvent.kZegoReplaceTrack.error.kParamError.code,
                    extendedData: log_event_1.ZegoRTCLogEvent.kZegoReplaceTrack.error.kParamError.message +
                        " localStream no found"
                });
                return;
            }
            enable = !!enable;
            var resolveResult = function (result) {
                // this.dataReport.uploadReport(seq);
                resolve(result);
            };
            // this._replaceTrack(localStream, mediaStreamTrack, resolveResult);
            var preview = _this.streamCenter.checkPreview(localStream);
            if (!preview) {
                _this.logger.error("zc.sbe.0 preview no found");
                resolveResult({
                    errorCode: error_1.errorCodeList.PUBLISH_NO_PREVIEW.code,
                    extendedData: error_1.errorCodeList.PUBLISH_NO_PREVIEW.message
                });
                return;
            }
            preview
                .setBeautyEffect(enable, options)
                .then(function () {
                resolveResult({ errorCode: 0, extendedData: "" });
            })
                .catch(function (err) {
                reject({
                    errorCode: -1,
                    extendedData: err.toString()
                });
            });
        });
    };
    return AdvancedModule;
}());
exports.AdvancedModule = AdvancedModule;


/***/ }),

/***/ "./sdk/src/modules/advance/content.ts":
/*!********************************************!*\
  !*** ./sdk/src/modules/advance/content.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.signal = exports.publisher = exports.publishModule = exports.playModule = exports.preview = exports.streamHandler = exports.zegoWebRTC = exports.ENUM_PUBLISH_STREAM_STATE = exports.ENUM_STREAM_CMD_PRI = exports.ENUM_STREAM_SUB_CMD = exports.PROTO_VERSION = void 0;
//@ts-nocheck
var action_1 = __webpack_require__(/*! ./action */ "./sdk/src/modules/advance/action.ts");
var error_1 = __webpack_require__(/*! ./error */ "./sdk/src/modules/advance/error.ts");
var log_event_1 = __webpack_require__(/*! ./log.event */ "./sdk/src/modules/advance/log.event.ts");
var mediaUtil_1 = __webpack_require__(/*! ./mediaUtil */ "./sdk/src/modules/advance/mediaUtil.ts");
var SEND_MSG_TIMEOUT = 1;
exports.PROTO_VERSION = "2.13.0";
exports.ENUM_STREAM_SUB_CMD = {
    liveNone: 0,
    liveBegin: 2001,
    liveEnd: 2002,
    liveUpdate: 2003
};
exports.ENUM_STREAM_CMD_PRI = {
    liveBegin: "zegochat_js.room_stream_create_req",
    liveEnd: "zegochat_js.room_stream_delete_req",
    liveUpdate: "zegochat_js.room_stream_update_req"
};
exports.ENUM_PUBLISH_STREAM_STATE = {
    waiting_url: 1,
    tryPublish: 2,
    update_info: 3,
    publishing: 4,
    stop: 5,
    retryPublish: 6
};
//ZegoWebRTC
exports.zegoWebRTC = {
    mutePublishStreamVideo: function (localStream, mute, retain) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_PUBLISH_STREAM_VIDEO + " call");
        var reportSeq = this.stateCenter.getReportSeq();
        this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskMutePublishVideo);
        if (typeof mute !== "boolean" ||
            (retain !== undefined && typeof retain !== "boolean")) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.MUTE_PUBLISH_STREAM_VIDEO + " option error");
            return false;
        }
        var res = this.rtcModules.advancedModule.enableStream(localStream, {
            video: !mute,
            retain: retain
        });
        this.dataReport.uploadReport(reportSeq);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_PUBLISH_STREAM_VIDEO + " end");
        return res;
    },
    mutePublishStreamAudio: function (localStream, mute) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_PUBLISH_STREAM_AUDIO + " call");
        var reportSeq = this.stateCenter.getReportSeq();
        this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskMutePublishAudio);
        if (typeof mute !== "boolean") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.MUTE_PUBLISH_STREAM_AUDIO + " option error");
            return false;
        }
        var res = this.rtcModules.advancedModule.enableStream(localStream, {
            audio: !mute
        });
        this.dataReport.uploadReport(reportSeq);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_PUBLISH_STREAM_AUDIO + " end");
        return res;
    },
    mutePlayStreamVideo: function (streamID, mute) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_PLAY_STREAM_VIDEO +
            " call " +
            streamID +
            " " +
            mute);
        var reportSeq = this.stateCenter.getReportSeq();
        this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskMutePlayVideo);
        var res = this.rtcModules.playModule.mutePlayStream(streamID, "video", mute);
        this.dataReport.uploadReport(reportSeq);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_PLAY_STREAM_VIDEO + " end");
        return res;
    },
    mutePlayStreamAudio: function (streamID, mute) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_PLAY_STREAM_AUDIO +
            " call " +
            streamID +
            " " +
            mute);
        var reportSeq = this.stateCenter.getReportSeq();
        this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskMutePlayAudio);
        var res = this.rtcModules.playModule.mutePlayStream(streamID, "audio", mute);
        this.dataReport.uploadReport(reportSeq);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_PLAY_STREAM_AUDIO + "end");
        return res;
    },
    muteMicrophone: function (mute) {
        // return false
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_MIC + " call");
        var reportSeq = this.stateCenter.getReportSeq();
        this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskMuteMicrophone);
        if (typeof mute !== "boolean") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.MUTE_MIC + " option error");
            return false;
        }
        var res = this.rtcModules.advancedModule.enableMicrophoneOnly(!mute);
        this.dataReport.uploadReport(reportSeq);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_MIC + " end");
        return res;
    },
    activateSEIInsert: function (config) {
        var stream = config.stream, action = config.action, infoType = config.infoType;
        return this.rtcModules.publishModule.activateSEIInsert(stream, action, infoType);
    },
    getAudioInfo: function (localStream, errCallBack, option) {
        if (!localStream) {
            this.logger.error("localStream is empty!");
            return false;
        }
        var _option = __assign({}, option);
        return new mediaUtil_1.MediaUtil(this.ac, _option).connectToSource(localStream, function (e) {
            errCallBack(e);
        });
    },
    startRecord: function (stream) {
        var _this = this;
        var preview = this.streamCenter.checkPreview(stream);
        if (!preview) {
            this.logger.error("stream is not from zego!");
            return;
        }
        var playStreamClone = stream.clone();
        var audioTracksClone = playStreamClone.getAudioTracks();
        if (audioTracksClone.length > 0 && preview.hasEmptyAudioTrack) {
            audioTracksClone.forEach(function (track) {
                playStreamClone.removeTrack(track);
            });
        }
        this.recordedBlobs = [];
        var options = { mimeType: "video/webm;codecs=vp9" };
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
            options = { mimeType: "video/webm;codecs=vp8,opus" };
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                options = { mimeType: "video/webm;codecs=vp8" };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options = { mimeType: "video/webm" };
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options = { mimeType: "" };
                    }
                }
            }
        }
        try {
            this.mediaRecorder = new MediaRecorder(playStreamClone, options);
        }
        catch (e) {
            this.logger.error("Exception while creating ZegoMediaRecorder:", e);
            return;
        }
        this.mediaRecorder.onstop = function (event) {
            _this.logger.warn("Recorder stopped: " + event);
        };
        this.mediaRecorder.ondataavailable = this.handleDataAvailable.bind(this);
        this.mediaRecorder.start(10); // collect 10ms of data
    },
    stopRecord: function () {
        if (this.mediaRecorder) {
            this.mediaRecorder.stop();
        }
        else {
            this.logger.warn("please invoke startRecord first");
        }
    },
    resumeRecord: function () {
        if (this.mediaRecorder) {
            this.mediaRecorder.resume();
        }
        else {
            this.logger.warn("please invoke startRecord first");
        }
    },
    pauseRecord: function () {
        if (this.mediaRecorder) {
            this.mediaRecorder.pause();
        }
        else {
            this.logger.warn("please invoke startRecord first");
        }
    },
    saveRecord: function (name) {
        if (this.mediaRecorder && this.recordedBlobs) {
            var blob = new Blob(this.recordedBlobs, { type: "video/webm" });
            var url_1 = window.URL.createObjectURL(blob);
            var a_1 = document.createElement("a");
            a_1.style.display = "none";
            a_1.href = url_1;
            a_1.download = name + ".webm";
            document.body.appendChild(a_1);
            a_1.click();
            setTimeout(function () {
                document.body.removeChild(a_1);
                window.URL.revokeObjectURL(url_1);
            }, 100);
        }
        else {
            this.logger.warn("please invoke startRecord first");
        }
    },
    handleDataAvailable: function (event) {
        if (event.data && event.data.size > 0) {
            this.recordedBlobs.push(event.data);
        }
    },
    takeSnapShot: function (el, img) {
        if (el && el.videoHeight !== 0) {
            var canvas = document.createElement("canvas");
            canvas.width = el.videoWidth;
            canvas.height = el.videoHeight;
            var canvasContext = canvas.getContext("2d");
            canvasContext &&
                canvasContext.drawImage(el, 0, 0, canvas.width, canvas.height);
            img.src = canvas.toDataURL("image/jpeg");
        }
        else {
            this.logger.error("video can not empty");
        }
    },
    saveSnapShot: function (el, name) {
        if (el && el.videoHeight !== 0) {
            var canvas = document.createElement("canvas");
            canvas.width = el.videoWidth;
            canvas.height = el.videoHeight;
            var canvasContext = canvas.getContext("2d");
            canvasContext &&
                canvasContext.drawImage(el, 0, 0, canvas.width, canvas.height);
            canvas.toBlob(function (blob) {
                var url = window.URL.createObjectURL(blob);
                var a = document.createElement("a");
                a.style.display = "none";
                a.href = url;
                a.download = name + ".jpeg";
                document.body.appendChild(a);
                a.click();
                setTimeout(function () {
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                }, 100);
            });
        }
        else {
            this.logger.error("video can not empty");
        }
    },
    setStreamExtraInfo: function (streamID, extraInfo) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var reportSeq = _this.stateCenter.getReportSeq();
            _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.event);
            _this.dataReport.addMsgInfo(reportSeq, {
                stream: log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.stream(streamID),
                stream_extra_info: log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.stream_extra_info(extraInfo)
            });
            var handleError = function (err, errMsg) {
                _this.logger.error("zb.ssei " + errMsg);
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: err.code,
                    message: err.message + " " + errMsg
                });
                _this.dataReport.uploadReport(reportSeq);
                reject({
                    errorCode: err.code,
                    extendedData: err.message + " " + errMsg
                });
            };
            if (typeof streamID !== "string" || streamID == "") {
                handleError(log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.error
                    .kParamError, "streamID must be string and not empty");
                return;
            }
            if (typeof extraInfo !== "string" || extraInfo == "") {
                handleError(log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.error
                    .kParamError, "extraInfo must be string and no empty");
                return;
            }
            if (_this.RTM.isDisConnect()) {
                handleError(log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.error
                    .kNoLoginError, "not login");
                return;
            }
            if (!_this.stateCenter.publishStreamList[streamID]) {
                handleError(log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.error
                    .kPublishStreamNoFoundError, "publish stream no found");
                return;
            }
            var room = _this.streamCenter.getRoomByStreamID(streamID);
            if (!room) {
                handleError(log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.error
                    .kNoLoginError, "not login");
                return;
            }
            _this.dataReport.addMsgInfo(reportSeq, {
                room_sid: log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.room_sid(room.sessionID)
            });
            room.streamHandler.setStreamExtraInfo(streamID, extraInfo, resolve, handleError);
            _this.dataReport.uploadReport(reportSeq);
        });
    },
    addTrack: function (stream, track) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.ADD_TRACK + " call");
            _this.rtcModules.advancedModule.handleTrack("ADD", stream, track, resolve, reject);
        });
    },
    removeTrack: function (stream, track) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.REMOVE_TRACK + " call");
            _this.rtcModules.advancedModule.handleTrack("REMOVE", stream, track, resolve, reject);
        });
    }
};
//streamHandler
exports.streamHandler = {
    _publishTarget: function (cdnPushConfig, success, error) {
        var _this = this;
        this.logger.info("zb.sh.pt" + "call");
        var timestamp = Math.ceil(new Date().getTime() / 1000);
        var totalStreamId = cdnPushConfig.streamID;
        if (this.stateCenter.testEnvironment) {
            totalStreamId =
                "zegotest-" + this.stateCenter.appid + "-" + cdnPushConfig.streamID;
        }
        var req_body = {
            appid: this.stateCenter.appid,
            biz_type: 0,
            timestamp: timestamp,
            // signature: cdnPushConfig.signature,
            seq: this.stateCenter.cdnSeq++,
            version: exports.PROTO_VERSION * 1,
            stream_id: totalStreamId,
            pushurl: cdnPushConfig.pushUrl
            // 没传参数 guid signature session_secret AppSecret stream
        };
        this.logger.debug("zb.sh.pt" + " send command");
        var useNetAgent = this.stateCenter.useNetAgent;
        if (!useNetAgent) {
            var body = {
                channel: "media",
                cmd: cdnPushConfig.type,
                req_body: JSON.stringify(req_body)
            };
            this.sendBizChannelRequest(body, function (seq, cmd, rspBody) {
                _this.logger.info("zb.sh.pt" + " receive message");
                if (rspBody.length == 0) {
                    error(log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kNoResponseError);
                    return;
                }
                var data = JSON.parse(rspBody);
                var code = data.code, message = data.message;
                if (!code || code == 0) {
                    _this.logger.info("zb.sh.pt " + cdnPushConfig.type + " success");
                    success && success({ errorCode: 0, extendedData: "" });
                }
                else {
                    _this.logger.error("zb.sh.pt " +
                        cdnPushConfig.type +
                        " error code: " +
                        code +
                        " " +
                        message);
                    error(error_1.errorCodeList.UNKNOWN_SERVER_ERROR, " cmd: " + cdnPushConfig.type + " " + code + " " + message);
                }
            }, function (err, seq, rspbody) {
                _this.logger.info("zb.sh.pt error: " + err);
                var message = "";
                var errorCode = log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kUnknownServerError;
                if (err == 2001) {
                    errorCode =
                        log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kInvalidChannelError;
                }
                else if (err == 2002) {
                    errorCode =
                        log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kBizChannelError;
                }
                _this.logger.error("zb.sh.pt " + message);
                error(errorCode, " cmd: " + cdnPushConfig.type + " " + err + " " + message + "  ");
            });
        }
        else {
            this.sendBizChannelRequestV2({
                server: 1,
                location: "/liveroomcmd/push",
                cmd: cdnPushConfig.type
            }, req_body, function (rspBody) {
                _this.logger.info("zb.sh.pt" + " receive message");
                var _a = rspBody || {}, code = _a.code, message = _a.message;
                if (!code || code == 0) {
                    _this.logger.info("zb.sh.pt " + cdnPushConfig.type + " success");
                    success && success({ errorCode: 0, extendedData: "" });
                }
                else {
                    _this.logger.error("zb.sh.pt " +
                        cdnPushConfig.type +
                        " error code: " +
                        code +
                        " " +
                        message);
                    error(error_1.errorCodeList.UNKNOWN_SERVER_ERROR, " cmd: " + cdnPushConfig.type + " " + code + " " + message);
                }
            }, function (httpCode, bizError, rspBody, errorCode) {
                var message = "";
                // 判断是否为SDK错误码
                if (errorCode) {
                    error && error(errorCode, message);
                    return;
                }
                else {
                    errorCode =
                        log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kUnknownServerError;
                }
                if (httpCode === 200) {
                    _this.logger.info("zb.sh.pt error: " + bizError);
                    errorCode =
                        log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kUnknownServerError;
                    if (bizError == 2001) {
                        errorCode =
                            log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error
                                .kInvalidChannelError;
                    }
                    else if (bizError == 2002) {
                        errorCode =
                            log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kBizChannelError;
                    }
                    message = "cmd: " + cdnPushConfig.type + ", biz_code: " + bizError;
                }
                else {
                    message = "request media server fail, error: " + httpCode;
                }
                _this.logger.error("zb.sh.pt " + message);
                error && error(errorCode, message);
            });
            // this.sendRTMPRequest(
            //   {},
            //   req_body,
            //   (httpCode: number, rspBody: any) => {},
            //   (error: { code: string; message: "" }) => {}
            // );
        }
    },
    updateStreamExtraInfo: function (streamid, extraInfo, success, error) {
        this.logger.info("zb.sh.usei call");
        var cmd;
        this.stateCenter.type === "PUBLIC"
            ? (cmd = exports.ENUM_STREAM_SUB_CMD.liveUpdate)
            : (cmd = exports.ENUM_STREAM_CMD_PRI.liveUpdate);
        if (this.stateCenter.publishStreamList[streamid] &&
            this.stateCenter.publishStreamList[streamid].state >=
                exports.ENUM_PUBLISH_STREAM_STATE.update_info) {
            this.stateCenter.publishStreamList[streamid].extra_info = extraInfo;
            this.updateStreamInfo(streamid, cmd, extraInfo);
            success({ errorCode: 0 });
        }
        else if (this.stateCenter.publishStreamList[streamid] &&
            this.stateCenter.publishStreamList[streamid].state ===
                exports.ENUM_PUBLISH_STREAM_STATE.tryPublish) {
            this.stateCenter.publishStreamList[streamid].extra_info = extraInfo;
            success({ errorCode: 0 });
        }
        else {
            error(log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.error
                .kUpdateStreamInfoFailError);
        }
    },
    setStreamExtraInfo: function (streamID, extraInfo, success, error) {
        this.updateStreamExtraInfo(streamID, extraInfo, success, error);
    }
};
//preview
exports.preview = {
    enableCamera: function (enable, streamCenter, retain) {
        var _this = this;
        var _a, _b, _c;
        if (!this.localStream) {
            this.logger.error("zp.ec.2 no localStream");
            return false;
        }
        var track = this.videoTrack;
        if ((!retain || enable) && track) {
            track.enabled = enable;
            // fix chrome 87 版本下高分辨率摄像头开关卡顿，chrome 92 已无法复现
            if (this.stateCenter.browser === "chrome" &&
                enable &&
                typeof track.getSettings().width !== undefined &&
                track.getSettings().width > 0) {
                var videoWidth = track.getSettings().width - 1;
                var videoHeight = track.getSettings().height - 1;
                track.applyConstraints({ width: videoWidth, height: videoHeight });
                setTimeout(function () {
                    track.applyConstraints({
                        width: _this.videoInfo.width,
                        height: _this.videoInfo.height
                    });
                }, 200);
            }
        }
        var publisher = (_a = streamCenter.checkPublish(this.localStream)) === null || _a === void 0 ? void 0 : _a.publisher;
        if (publisher) {
            var sender = (_b = publisher.peerConnection) === null || _b === void 0 ? void 0 : _b.getSenders().find(function (s) { var _a; return ((_a = s.track) === null || _a === void 0 ? void 0 : _a.kind) === "video"; });
            if (retain && !enable) {
                var _track = this.videoTrack.clone();
                sender === null || sender === void 0 ? void 0 : sender.replaceTrack(_track);
                _track.stop();
            }
            else if (enable) {
                if (((_c = this.videoEffect) === null || _c === void 0 ? void 0 : _c.enabled) && this.videoEffect.output) {
                    sender === null || sender === void 0 ? void 0 : sender.replaceTrack(this.videoEffect.output);
                }
                else {
                    sender === null || sender === void 0 ? void 0 : sender.replaceTrack(this.videoTrack);
                }
            }
            var camera_status = enable ? 0 : 20;
            var mic_status = this.isAudioEnabled && streamCenter.isMicEnabled ? 0 : 20;
            if (publisher.signal &&
                (publisher.camera_status !== camera_status ||
                    publisher.mic_status !== mic_status)) {
                publisher.sendStreamStatus(camera_status, mic_status);
            }
        }
        this.logger.info("zp.ec.2 call success");
        return true;
    },
    enableMicrophone: function (enable, streamCenter) {
        var _a;
        if (!this.localStream) {
            this.logger.error("zp.em.2 no localStream");
            return false;
        }
        this.localStream.getAudioTracks().forEach(function (track) {
            track.enabled = enable;
        });
        this.audioTrack &&
            (this.audioTrack.enabled = enable && streamCenter.isMicEnabled);
        var publisher = (_a = streamCenter.checkPublish(this.localStream)) === null || _a === void 0 ? void 0 : _a.publisher;
        if (publisher && publisher.signal) {
            // wait signal connected
            var camera_status = publisher.camera_status;
            var mic_status = enable && streamCenter.isMicEnabled ? 0 : 20;
            if (publisher.camera_status !== camera_status ||
                publisher.mic_status !== mic_status) {
                publisher.sendStreamStatus(camera_status, mic_status);
            }
        }
        this.isAudioEnabled = enable;
        this.logger.debug("zp.em.2 call success");
        return true;
    },
    /**
     * 替换本地预览流的视轨
     * @param track 新视轨
     * @param isEffectTrack 是否为美颜视轨
     * @returns
     */
    replacePreviewTrack: function (track, isEffectTrack) {
        var _a;
        if (isEffectTrack === void 0) { isEffectTrack = false; }
        return __awaiter(this, void 0, void 0, function () {
            var type, localTrack;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!track || !track.kind || !this.localStream)
                            return [2 /*return*/];
                        type = track.kind === "audio" ? "audioTrack" : "videoTrack";
                        if (!(!isEffectTrack && ((_a = this.videoEffect) === null || _a === void 0 ? void 0 : _a.enabled) && track.kind === "video")) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.videoEffect.setInput(track)];
                    case 1:
                        _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        localTrack = this.localStream
                            .getTracks()
                            .find(function (item) { return item.kind === track.kind; });
                        if (localTrack) {
                            this.localStream.removeTrack(localTrack);
                        }
                        this.localStream.addTrack(track);
                        _b.label = 3;
                    case 3:
                        if (!isEffectTrack) {
                            this[type] = track;
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
};
//playModule
exports.playModule = {
    mutePlayStream: function (streamID, type, mute) {
        var _this = this;
        this.logger.info("zsc.mps.0 call " + type + " " + mute);
        return new Promise(function (resolve, reject) {
            if (typeof streamID !== "string" || streamID == "") {
                _this.logger.error("zsc.mps.0 streamID must be string and not empty");
                reject(false);
                return;
            }
            if (typeof mute !== "boolean") {
                _this.logger.error("zsc.mps.0 mute must be boolean");
                reject(false);
                return;
            }
            var player = _this.streamCenter.playerList[streamID];
            if (!player) {
                _this.logger.error("zsc.mps.0 player not found");
                reject(false);
                return;
            }
            if (type === "video") {
                if (
                // @ts-ignore
                (player.playOption && player.playOption.video === false) ||
                    (player.player && player.player.cameraStatus !== 0)) {
                    _this.logger.error("zsc.mps.0 stream no contain video");
                    reject(false);
                    return;
                }
                player.player.signal.ActivatePlayVideoStream(_this.stateCenter.getSeq(), player.player.sessionId, mute, function () {
                    _this.logger.info("zsc.mps.0 suc");
                    //上报拉流动态变化，拉视频或拉音频
                    var reportSeq = _this.stateCenter.getReportSeq();
                    player.player.playMediaStatus.video = !mute;
                    _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoPlayContentChanged.event);
                    _this.dataReport.addMsgInfo(reportSeq, {
                        session_id: log_event_1.ZegoRTCLogEvent.kZegoPlayContentChanged.session_id(player.player.sessionId),
                        video_activate: log_event_1.ZegoRTCLogEvent.kZegoPlayContentChanged.video_activate(player.player.playMediaStatus.video ? 1 : 0),
                        audio_activate: log_event_1.ZegoRTCLogEvent.kZegoPlayContentChanged.audio_activate(player.player.playMediaStatus.audio ? 1 : 0)
                    });
                    _this.playVideoStatus = _this.dataReport.uploadReport(reportSeq);
                    resolve(true);
                }, function () {
                    _this.logger.error("zsc.mps.0 fail");
                    reject(false);
                });
            }
            else if (type === "audio") {
                if (
                // @ts-ignore
                (player.playOption && player.playOption.audio === false) ||
                    (player.player && player.player.micStatus !== 0)) {
                    _this.logger.error("zsc.mps.0 stream no contain audio");
                    reject(false);
                    return;
                }
                player.player.signal.ActivatePlayAudioStream(_this.stateCenter.getSeq(), player.player.sessionId, mute, function () {
                    _this.logger.info("zsc.mps.0 suc");
                    //上报拉流动态变化，拉视频或拉音频
                    var reportSeq = _this.stateCenter.getReportSeq();
                    player.player.playMediaStatus.audio = !mute;
                    _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoPlayContentChanged.event);
                    _this.dataReport.addMsgInfo(reportSeq, {
                        session_id: log_event_1.ZegoRTCLogEvent.kZegoPlayContentChanged.session_id(player.player.sessionId),
                        video_activate: log_event_1.ZegoRTCLogEvent.kZegoPlayContentChanged.video_activate(player.player.playMediaStatus.video ? 1 : 0),
                        audio_activate: log_event_1.ZegoRTCLogEvent.kZegoPlayContentChanged.audio_activate(player.player.playMediaStatus.audio ? 1 : 0)
                    });
                    _this.dataReport.uploadReport(reportSeq);
                    resolve(true);
                }, function () {
                    _this.logger.error("zsc.mps.0 fail");
                    reject(false);
                });
            }
            else {
                reject(false);
            }
        });
    },
    setStreamAudioOutput: function (localVideo, audioOutput) {
        var _this = this;
        if (audioOutput != undefined && audioOutput.length != 0 && localVideo) {
            this.logger.debug("zsc.ssao.0 device " + audioOutput);
            if (!localVideo) {
                this.logger.error("zsc.ssao.0 no localVideo");
                return false;
            }
            if (localVideo.sinkId !== "undefined") {
                localVideo
                    .setSinkId(audioOutput)
                    .then(function () {
                    _this.logger.info("zsc.ssao.0 success device: " + audioOutput);
                    // _this.audioOutput = audioOutput;
                })
                    .catch(function (error) {
                    _this.logger.info("zsc.ssao.0 " + error.name);
                });
                return true;
            }
            else {
                this.logger.error("zsc.ssao.0 browser does not suppport");
                return false;
            }
        }
        return false;
    }
};
//publishModule
exports.publishModule = {
    activateSEIInsert: function (stream, action, infoType) {
        if (infoType === void 0) { infoType = 0; }
        var previewStream = this.streamCenter.checkPreview(stream);
        if (!previewStream) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.ACTIVATE_SEI_INSERT + " stream is not created");
            return false;
        }
        if (action === 0 || action === 1) {
            previewStream.activatesSEIConfig = {
                action: action,
                infoType: infoType
            };
        }
        else {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.ACTIVATE_SEI_INSERT +
                " value of “action” should be 0 or 1");
            return false;
        }
        var publisher = this.streamCenter.checkPublish(stream);
        if (publisher) {
            publisher === null || publisher === void 0 ? void 0 : publisher.publisher.activateSEIInsert(action, infoType);
        }
        return true;
    }
};
//publisher
exports.publisher = {
    activateSEIInsert: function (action, infoType) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (!_this.signal) {
                return resolve(false);
            }
            _this.signal &&
                _this.signal.activateSEIInsert(_this.stateCenter.getSeq(), _this.sessionId, _this.peerID, action, infoType, function (seq, sessionID, body) {
                    // 0 success, 1 invalid param, 2 peer not exist
                    var result = false;
                    if (body.result === 0) {
                        _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.ACTIVATE_SEI_INSERT + " called success");
                        result = true;
                    }
                    else if (body.result === 1) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.ACTIVATE_SEI_INSERT +
                            " " +
                            body.peer_id +
                            " invalid param.");
                        result = false;
                    }
                    else if (body.result === 2) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.ACTIVATE_SEI_INSERT + " peer not exist");
                        result = false;
                    }
                    resolve(result);
                }, function (errcode) {
                    if (SEND_MSG_TIMEOUT === errcode) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.ACTIVATE_SEI_INSERT + " request timeout");
                    }
                });
            return false;
        });
    },
    replacePublishedTrack: function (mediaStreamTrack, isEffectTrack) {
        var _a, _b;
        if (isEffectTrack === void 0) { isEffectTrack = false; }
        return __awaiter(this, void 0, void 0, function () {
            var localStream, previewer, videoEffect, kind, localTrack, sender, cameraStatus, micStatus;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        localStream = this.localStream;
                        previewer = this.previewer;
                        videoEffect = previewer === null || previewer === void 0 ? void 0 : previewer.videoEffect;
                        kind = mediaStreamTrack.kind;
                        localTrack = previewer[kind + "Track"];
                        sender = (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.getSenders().find(function (s) { return s.track.kind === kind; });
                        if (!localTrack) return [3 /*break*/, 2];
                        cameraStatus = 0;
                        micStatus = 0;
                        if (kind === "video") {
                            // 切换为美颜视轨，摄像头状态使用原状态
                            if (isEffectTrack) {
                                cameraStatus = localTrack.enabled === true ? 0 : 20;
                            }
                            else {
                                cameraStatus = mediaStreamTrack.enabled === true ? 0 : 20;
                            }
                            micStatus =
                                localStream.getAudioTracks()[0] &&
                                    localStream.getAudioTracks()[0].enabled == true
                                    ? 0
                                    : 20;
                        }
                        else if (kind === "audio") {
                            micStatus = mediaStreamTrack.enabled === true ? 0 : 20;
                            cameraStatus = ((_b = previewer.videoTrack) === null || _b === void 0 ? void 0 : _b.enabled) == true ? 0 : 20;
                        }
                        // !isSafari && localTrack.stop();
                        // 替换预览流
                        return [4 /*yield*/, previewer.replacePreviewTrack(mediaStreamTrack, isEffectTrack)];
                    case 1:
                        // !isSafari && localTrack.stop();
                        // 替换预览流
                        _c.sent();
                        // 替换远端流
                        if (sender) {
                            if (kind === "audio" || isEffectTrack || !(videoEffect === null || videoEffect === void 0 ? void 0 : videoEffect.enabled)) {
                                sender.replaceTrack(mediaStreamTrack);
                            }
                            if (this.camera_status !== cameraStatus ||
                                this.mic_status !== micStatus) {
                                this.sendStreamStatus(cameraStatus, micStatus);
                            }
                        }
                        else {
                            this.logger.info("zc.rt.1 replace remote track will work after stream published");
                        }
                        this.logger.info("zc.rt.1 replace remote track success");
                        return [2 /*return*/, { errorCode: 0, extendedData: "" }];
                    case 2:
                        this.logger.error("zc.rt.1 publisher track no found");
                        return [2 /*return*/, {
                                errorCode: error_1.errorCodeList.TRACK_NOT_FOUND.code,
                                extendedData: error_1.errorCodeList.TRACK_NOT_FOUND.message
                            }];
                }
            });
        });
    }
};
exports.signal = {
    activateSEIInsert: function (seq, sessionID, peerID, action, infoType, success, error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.ACTIVATE_SEI_INSERT + " call " + sessionID);
        var cmd = "ActivateSEIInsertReq";
        var body = {
            peer_id: peerID,
            action: action,
            info_type: infoType
        };
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    }
};


/***/ }),

/***/ "./sdk/src/modules/advance/error.ts":
/*!******************************************!*\
  !*** ./sdk/src/modules/advance/error.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorCodeList = void 0;
exports.errorCodeList = {
    NOT_LOGIN: {
        code: 1000002,
        message: "not login room"
    },
    INPUT_PARAM: {
        code: 1100001,
        message: "input param error."
    },
    PUBLISH_NOT_PUBLISH: {
        code: 1103040,
        message: "publisher not found"
    },
    PUBLISH_NO_PREVIEW: {
        code: 1103044,
        message: "stream is not from zego"
    },
    TRACK_NOT_FOUND: {
        code: 1103047,
        message: "track is not found"
    },
    DEVICE_NOT_FOUND: {
        code: 1103048,
        message: "device is not found"
    },
    PUBLISHER_CONSTRAINTS_ERROR: {
        code: 1103029,
        message: "constraint error"
    },
    PUBLISHER_CDN_PUSH_ERROR: {
        code: 1103052,
        message: "publisher cdn push error"
    },
    VIDEO_DEVICE_FALSE: {
        code: 1103045,
        message: "video is false"
    },
    AUDIO_DEVICE_FALSE: {
        code: 1103046,
        message: "audio is false"
    },
    UNKNOWN_SERVER_ERROR: {
        code: 1100999,
        message: "unknown server error"
    },
    LOCALSTREAM_WRONG: {
        code: 1000018,
        message: "local stream wrong"
    },
    PUBLISHER_STREAM_NO_FOUND: {
        code: 1103055,
        message: "publish stream no found"
    },
    PUBLISH_TARGET_NO_RESPONSE: {
        code: 1103063,
        message: "publish target no response"
    },
    BIZ_CHANNEL_ERROR: {
        code: 1102021,
        message: "biz channel error."
    },
    INVALID_CHANNEL: {
        code: 1102024,
        message: "invalid channel"
    },
    PUBLISHER_EXTRA_INFO_NULL: {
        code: 1003050,
        message: "extra info of publishing stream is null"
    },
    PUBLISHER_UPDATE_STREAM_INFO_FAIL: {
        code: 1103062,
        message: "update stream info fail"
    },
    TRACK_CAN_NOT_ADD: {
        code: 1103063,
        message: "only stream which have one track and kind no exist can add track"
    },
    TRACK_CAN_NOT_REMOVE: {
        code: 1103064,
        message: "stream which only has one track can not remove "
    },
    PUBLISHER_UPDATE_SDP_FAIL: {
        code: 1103068,
        message: "update sdp fail"
    },
    PUBLISHER_STATE_WRONG: {
        code: 1103069,
        message: "publisher state wrong"
    },
    HANDLE_TRACK_NOT_SUPPORTED: {
        code: 1103070,
        message: "not support remove track"
    },
    VIDEO_EFFECT_IS_RUNNING: {
        code: 1103071,
        message: "video effect processor is running"
    }
};


/***/ }),

/***/ "./sdk/src/modules/advance/index.ts":
/*!******************************************!*\
  !*** ./sdk/src/modules/advance/index.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//@ts-nocheck
var advancedModule_1 = __webpack_require__(/*! ./advancedModule */ "./sdk/src/modules/advance/advancedModule.ts");
var content_1 = __webpack_require__(/*! ./content */ "./sdk/src/modules/advance/content.ts");
exports["default"] = {
    type: "Advance",
    install: function (ZegoWebRTC, RTCModules, StreamHandler, Preview, PlayModule, PublishModule, Publisher, Signal) {
        Object.defineProperty(RTCModules.prototype, "initAdvance", {
            value: function () {
                this.advancedModule = new advancedModule_1.AdvancedModule(this.logger, this.dataReport, this.streamCenter, this.stateCenter);
            },
            writable: false
        });
        for (var key in content_1.zegoWebRTC) {
            Object.defineProperty(ZegoWebRTC.prototype, key, {
                value: content_1.zegoWebRTC[key],
                writable: false
            });
        }
        for (var key in content_1.streamHandler) {
            Object.defineProperty(StreamHandler.prototype, key, {
                value: content_1.streamHandler[key],
                writable: false
            });
        }
        for (var key in content_1.preview) {
            Object.defineProperty(Preview.prototype, key, {
                value: content_1.preview[key],
                writable: false
            });
        }
        for (var key in content_1.playModule) {
            Object.defineProperty(PlayModule.prototype, key, {
                value: content_1.playModule[key],
                writable: false
            });
        }
        for (var key in content_1.publishModule) {
            Object.defineProperty(PublishModule.prototype, key, {
                value: content_1.publishModule[key],
                writable: false
            });
        }
        for (var key in content_1.publisher) {
            Object.defineProperty(Publisher.prototype, key, {
                value: content_1.publisher[key],
                writable: false
            });
        }
        for (var key in content_1.signal) {
            Object.defineProperty(Signal.prototype, key, {
                value: content_1.signal[key],
                writable: false
            });
        }
    }
};


/***/ }),

/***/ "./sdk/src/modules/advance/log.event.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/advance/log.event.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoRTCLogEvent = void 0;
var error_1 = __webpack_require__(/*! ./error */ "./sdk/src/modules/advance/error.ts");
var getItem = function (item) { return item; };
exports.ZegoRTCLogEvent = {
    kZegoSetVideoConfig: {
        event: "/sdk/set_video_config",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM,
            kLocalStreamError: error_1.errorCodeList.LOCALSTREAM_WRONG
        }
    },
    kZegoSetAudioConfig: {
        event: "/sdk/set_audio_config",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM
        }
    },
    kZegoReplaceTrack: {
        event: "/sdk/replace_track",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM
        }
    },
    kZegoTaskUseVideoDevice: {
        event: "/device/api/video_c",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM,
            kDevicesNoFoundError: error_1.errorCodeList.DEVICE_NOT_FOUND,
            kLocalStreamError: error_1.errorCodeList.LOCALSTREAM_WRONG
        },
        device: getItem
    },
    kZegoTaskUseAudioDevice: {
        event: "/device/api/audio_c",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM,
            kDevicesNoFoundError: error_1.errorCodeList.DEVICE_NOT_FOUND,
            kLocalStreamError: error_1.errorCodeList.LOCALSTREAM_WRONG
        },
        device: getItem
    },
    kZegoTaskPublishTarget: {
        event: "/sdk/publish_target",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM,
            kPublishStreamNoFoundError: error_1.errorCodeList.PUBLISHER_STREAM_NO_FOUND,
            kNoLoginError: error_1.errorCodeList.NOT_LOGIN,
            kNoResponseError: error_1.errorCodeList.PUBLISH_TARGET_NO_RESPONSE,
            kBizChannelError: error_1.errorCodeList.BIZ_CHANNEL_ERROR,
            kInvalidChannelError: error_1.errorCodeList.INVALID_CHANNEL,
            kUnknownServerError: error_1.errorCodeList.UNKNOWN_SERVER_ERROR
        }
    },
    kZegoTaskAddPublishCdnUrl: {
        event: "/sdk/add_publish_cdn_url",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM
        }
    },
    kZegoTaskRemovePublishCdnUrl: {
        event: "/sdk/remove_publish_cdn_url",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM
        },
        stream: getItem,
        target_url: getItem
    },
    kZegoTaskClearPublishCdnUrl: {
        event: "/sdk/clear_publish_cdn_url",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM
        }
    },
    kZegoPlayContentChanged: {
        event: "/sdk/play_content_changed",
        session_id: getItem,
        video_activate: getItem,
        audio_activate: getItem
    },
    kZegoTaskMutePublishVideo: "/sdk/mute_publish_video",
    kZegoTaskMutePublishAudio: "/sdk/mute_publish_audio",
    kZegoTaskMuteMicrophone: "/sdk/mute_microphone",
    kZegoTaskMutePlayVideo: "/sdk/mute_play_video",
    kZegoTaskMutePlayAudio: "/sdk/mute_play_audio",
    kZegoTaskLiveRoomSendStreamExtraInfo: {
        event: "/liveroom/send_stream_extra_info",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM,
            kExtraInfoNullError: error_1.errorCodeList.PUBLISHER_EXTRA_INFO_NULL,
            kNoLoginError: error_1.errorCodeList.NOT_LOGIN,
            kPublishStreamNoFoundError: error_1.errorCodeList.PUBLISHER_STREAM_NO_FOUND,
            kUpdateStreamInfoFailError: error_1.errorCodeList.PUBLISHER_UPDATE_STREAM_INFO_FAIL
        },
        stream: getItem,
        stream_extra_info: getItem,
        room_sid: getItem
    }
};


/***/ }),

/***/ "./sdk/src/modules/advance/mediaUtil.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/advance/mediaUtil.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MediaUtil = void 0;
var MediaUtil = /** @class */ (function () {
    function MediaUtil(context, _a) {
        var _this = this;
        var type = _a.type, _b = _a.channels, channels = _b === void 0 ? 1 : _b, _c = _a.bufferSize, bufferSize = _c === void 0 ? 0 : _c, _d = _a.sampleBit, sampleBit = _d === void 0 ? 16 : _d, _e = _a.sampleRate, sampleRate = _e === void 0 ? 44100 : _e;
        this.instant = 0.0;
        this.slow = 0.0;
        this.clip = 0.0;
        this.context = context;
        this.type = type;
        this.channels = channels;
        this.bufferSize = bufferSize;
        this.sampleBit = sampleBit;
        this.sampleRate = sampleRate;
        this.script = context.createScriptProcessor(bufferSize, channels, channels);
        var audioprocessTime = new Date().getTime();
        this.script.addEventListener("audioprocess", function (event) {
            var input = event.inputBuffer.getChannelData(0);
            var i;
            var sum = 0.0;
            var clipcount = 0;
            for (i = 0; i < input.length; ++i) {
                sum += input[i] * input[i];
                if (Math.abs(input[i]) > 0.99) {
                    clipcount += 1;
                }
            }
            _this.instant = Math.sqrt(sum / input.length);
            _this.slow = 0.95 * _this.slow + 0.05 * _this.instant;
            _this.clip = clipcount / input.length;
            // 需要获取音频数据
            if (type === "pcm" || type === "wav") {
                var buffer = [];
                for (var i_1 = 0; i_1 < _this.channels; i_1++) {
                    buffer.push(event.inputBuffer.getChannelData(i_1));
                }
                _this.recorderBuffer(buffer);
            }
        });
        // 需要获取音频数据,准备worker环境
        if (type === "pcm" || type === "wav") {
            this.initRecorderBuffer(type);
        }
    }
    MediaUtil.prototype.connectToSource = function (stream, callback) {
        try {
            this.mic = this.context.createMediaStreamSource(stream);
            this.mic.connect(this.script);
            // necessary to make sample run, but should not be.
            this.script.connect(this.context.destination);
            if (typeof callback !== "undefined") {
                callback(null);
            }
        }
        catch (e) {
            console.error(e);
            if (typeof callback !== "undefined") {
                callback(e);
            }
        }
        return this;
    };
    MediaUtil.prototype.recorderBuffer = function (audioBuffer) {
        this.worker.postMessage({
            command: "record",
            val: audioBuffer
        });
    };
    MediaUtil.prototype.initRecorderBuffer = function (type) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var outSelf = this;
        this.worker = this.inlineWorker(function () {
            var record = [], sampleChannel, sampleBit, sampleRate, oldSampleRate, bufferSize, type;
            function init(option) {
                sampleChannel = option.sampleChannel;
                sampleBit = option.sampleBit;
                sampleRate = option.sampleRate;
                oldSampleRate = option.oldSampleRate;
                bufferSize = option.bufferSize;
                type = option.type;
            }
            function floatTo16BitPCM(output, offset, input) {
                for (var i = 0; i < input.length; i++, offset += 2) {
                    var s = Math.max(-1, Math.min(1, input[i]));
                    output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
                }
            }
            function floatTo8BitPCM(output, offset, input) {
                for (var i = 0; i < input.length; i++, offset++) {
                    //这里只能加1了
                    var s = Math.max(-1, Math.min(1, input[i]));
                    var val = s < 0 ? s * 0x80 : s * 0x7f;
                    val += 128;
                    output.setInt8(offset, val);
                }
            }
            function floatToPCM(samples, _sampleBit) {
                var dataLength;
                if (_sampleBit == 8) {
                    dataLength = samples.length;
                }
                else if (_sampleBit == 16) {
                    //16位的需要两倍空间
                    dataLength = samples.length;
                    dataLength = dataLength * 2;
                }
                var buffer = new ArrayBuffer(dataLength);
                var view = new DataView(buffer);
                if (_sampleBit == 8) {
                    floatTo8BitPCM(view, 0, samples);
                }
                else if (sampleBit == 16) {
                    floatTo16BitPCM(view, 0, samples);
                }
                return view;
            }
            function writeString(view, offset, string) {
                for (var i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }
            function encodeWave(samples, _sampleBit) {
                var dataLength;
                if (_sampleBit == 8) {
                    dataLength = samples.length;
                }
                else if (sampleBit == 16) {
                    //16位的需要两倍空间
                    dataLength = samples.length;
                    dataLength = dataLength * 2;
                }
                var buffer = new ArrayBuffer(dataLength + 44);
                var view = new DataView(buffer);
                var newSamepleRate = sampleRate;
                var newSampleBits = sampleBit;
                var newSampleChannel = sampleChannel;
                writeString(view, 0, "RIFF");
                view.setUint32(4, 36 + dataLength, true);
                writeString(view, 8, "WAVE");
                writeString(view, 12, "fmt ");
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, newSampleChannel, true);
                view.setUint32(24, newSamepleRate, true);
                view.setUint32(28, newSamepleRate * newSampleChannel * (newSampleBits / 8), true);
                view.setUint16(32, newSampleChannel * (newSampleBits / 8), true);
                view.setUint16(34, newSampleBits, true);
                writeString(view, 36, "data");
                view.setUint32(40, dataLength, true);
                if (sampleBit == 8) {
                    floatTo8BitPCM(view, 44, samples);
                }
                else if (sampleBit == 16) {
                    floatTo16BitPCM(view, 44, samples);
                }
                return view;
            }
            //压缩
            function compressHandler(compressRate, data) {
                var result = new Float32Array(data.length / compressRate);
                var index = 0, j = 0;
                while (index < result.length) {
                    result[index] = data[j];
                    j += compressRate;
                    index++;
                }
                return result;
            }
            //获取buffer
            function getAudioBuffer(data, _bufferSize, _record) {
                var result = new Float32Array(_bufferSize * data.length);
                var offset = 0;
                for (var i = 0; i < _record[0].length; i++) {
                    result.set(_record[0][i], offset);
                    offset += _record[0][i].length;
                    //console.log(offset);
                }
                return result;
            }
            //合并声道
            function combineChannels(channelL, channelR) {
                var result = new Float32Array(channelL.length + channelR.length);
                for (var i = 0; i < channelL.length + channelR.length; i += 2) {
                    result[i] = channelL[(i / 2) >> 0];
                    result[i + 1] = channelR[(i / 2) >> 0];
                }
                return result;
            }
            function collectBuffer(compressRate) {
                var collect_record, compress_collect_record;
                if (sampleChannel == 1) {
                    //单声道
                    collect_record = getAudioBuffer(record[0], bufferSize, record);
                    if (compressRate != 1) {
                        //压缩比
                        compress_collect_record = compressHandler(compressRate, collect_record);
                    }
                }
                else if (sampleChannel == 2) {
                    //双声道
                    //处理声道1,处理声道2
                    var collect_record_1 = getAudioBuffer(record[0], bufferSize, record);
                    var collect_record_2 = getAudioBuffer(record[1], bufferSize, record);
                    var compress_collect_record_1 = void 0, compress_collect_record_2 = void 0;
                    if (compressRate != 1) {
                        //压缩声道1，2
                        compress_collect_record_1 = compressHandler(compressRate, collect_record_1);
                        compress_collect_record_2 = compressHandler(compressRate, collect_record_2);
                        compress_collect_record = combineChannels(compress_collect_record_1, compress_collect_record_2);
                    }
                    else {
                        collect_record = combineChannels(collect_record_1, collect_record_2);
                    }
                }
                if (compressRate != 1) {
                    //输入采集概和输出采集率不同，需要压缩采集点
                    return compress_collect_record;
                }
                else {
                    return collect_record;
                }
            }
            function collectPCM(compressRate) {
                var result = collectBuffer(compressRate);
                var interleaveData = floatToPCM(result, sampleBit);
                // @ts-ignore
                self.postMessage({
                    command: "exportPcmLive",
                    val: interleaveData
                });
            }
            function collectWAV(compressRate) {
                var result = collectBuffer(compressRate);
                var interleaveData = encodeWave(result, sampleBit);
                // @ts-ignore
                self.postMessage({
                    command: "exportWav",
                    val: interleaveData
                });
            }
            function recordData(buffer) {
                for (var i = 0; i < sampleChannel; i++) {
                    if (!record[i]) {
                        record[i] = [];
                    }
                    record[i].push(buffer[i]);
                }
                var compressRate = Math.round(oldSampleRate / sampleRate);
                if (type === "pcm") {
                    collectPCM(compressRate);
                }
                else if (type === "wav") {
                    collectWAV(compressRate);
                }
                record = []; //清空
            }
            //@ts-ignore
            this.onmessage = function (e) {
                switch (e.data.command) {
                    case "init":
                        init(e.data.val);
                        break;
                    case "record":
                        recordData(e.data.val);
                        break;
                }
            };
        });
        this.worker.postMessage({
            command: "init",
            val: {
                sampleChannel: this.channels,
                sampleBit: this.sampleBit,
                sampleRate: this.sampleRate,
                oldSampleRate: this.context.sampleRate,
                bufferSize: this.bufferSize,
                type: type
            }
        });
        this.worker.onmessage = function (e) {
            switch (e.data.command) {
                case "exportPcmLive":
                    outSelf.onReceiveBuffer(e.data.val);
                    break;
                case "exportWav":
                    outSelf.onReceiveWav(e.data.val);
                    break;
            }
        };
    };
    MediaUtil.prototype.onReceiveBuffer = function (val) { };
    MediaUtil.prototype.onReceiveWav = function (wavBlob) { };
    MediaUtil.prototype.writeString = function (view, offset, string) {
        for (var i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    };
    MediaUtil.prototype.writeBuffer = function (view, offset, buffer) {
        for (var i = 0; i < buffer.byteLength; i++) {
            view.setUint8(offset + i, buffer[i]);
        }
    };
    MediaUtil.prototype.concatenation = function (segments) {
        var sumLength = 0;
        for (var i = 0; i < segments.length; ++i) {
            sumLength += segments[i].buffer.byteLength;
        }
        var whole = new Uint8Array(sumLength);
        var pos = 0;
        for (var i = 0; i < segments.length; ++i) {
            whole.set(new Uint8Array(segments[i].buffer), pos);
            pos += segments[i].buffer.byteLength;
        }
        return whole;
    };
    MediaUtil.prototype.encodeWave = function (samples) {
        var wholeBuffer = this.concatenation(samples);
        var dataLength = wholeBuffer.byteLength;
        var buffer = new ArrayBuffer(dataLength + 44);
        var view = new DataView(buffer);
        var newSamepleRate = this.sampleRate;
        var newSampleBits = this.sampleBit;
        var newSampleChannel = this.channels;
        this.writeString(view, 0, "RIFF");
        view.setUint32(4, 36 + dataLength, true);
        this.writeString(view, 8, "WAVE");
        this.writeString(view, 12, "fmt ");
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, newSampleChannel, true);
        view.setUint32(24, newSamepleRate, true);
        view.setUint32(28, newSamepleRate * newSampleChannel * (newSampleBits / 8), true);
        view.setUint16(32, newSampleChannel * (newSampleBits / 8), true);
        view.setUint16(34, newSampleBits, true);
        this.writeString(view, 36, "data");
        view.setUint32(40, dataLength, true);
        this.writeBuffer(view, 44, wholeBuffer);
        return view;
    };
    MediaUtil.prototype.stop = function () {
        this.mic.disconnect();
        this.script.disconnect();
    };
    MediaUtil.prototype.inlineWorker = function (func) {
        //内联worker
        if (Worker && func) {
            var functionBody = func
                .toString()
                .trim()
                .match(/^function\s*\w*\s*\([\w\s,]*\)\s*{([\w\W]*?)}$/)[1];
            var url = URL.createObjectURL(new window.Blob([functionBody], {
                type: "text/javascript"
            }));
            return new Worker(url);
        }
        return null;
    };
    return MediaUtil;
}());
exports.MediaUtil = MediaUtil;


/***/ }),

/***/ "./sdk/src/modules/audioMix/action.ts":
/*!********************************************!*\
  !*** ./sdk/src/modules/audioMix/action.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZEGO_WEBRTC_ACTION = void 0;
var ZEGO_WEBRTC_ACTION;
(function (ZEGO_WEBRTC_ACTION) {
    ZEGO_WEBRTC_ACTION["PRELOAD_EFFECT"] = "zc.pe.0";
    ZEGO_WEBRTC_ACTION["PLAY_EFFECT"] = "zc.pe.1";
    ZEGO_WEBRTC_ACTION["PAUSE_EFFECT"] = "zc.pe.2";
    ZEGO_WEBRTC_ACTION["RESUME_EFFECT"] = "zc.re";
    ZEGO_WEBRTC_ACTION["STOP_EFFECT"] = "zc.se";
    ZEGO_WEBRTC_ACTION["UNLOAD_EFFECT"] = "zc.ue";
    ZEGO_WEBRTC_ACTION["SET_EFFECT_VOLUME"] = "zc.sev";
    ZEGO_WEBRTC_ACTION["START_MIXING_AUDIO"] = "zc.sma.0";
    ZEGO_WEBRTC_ACTION["STOP_MIXING_AUDIO"] = "zc.sma.1";
    ZEGO_WEBRTC_ACTION["MIXING_BUFFER"] = "zc.mb";
    ZEGO_WEBRTC_ACTION["STOP_MIXING_BUFFER"] = "zc.smb";
    ZEGO_WEBRTC_ACTION["SET_MIXING_AUDIO_VOLUME"] = "zc.smav";
    ZEGO_WEBRTC_ACTION["PUBLISHER_PLAY_EFFECT"] = "zc.p.0.pe.0";
    ZEGO_WEBRTC_ACTION["PUBLISHER_PAUSE_EFFECT"] = "zc.p.0.pe.1";
    ZEGO_WEBRTC_ACTION["PUBLISHER_RESUME_EFFECT"] = "zc.p.0.re";
    ZEGO_WEBRTC_ACTION["PUBLISHER_STOP_EFFECT"] = "zc.p.0.se";
    ZEGO_WEBRTC_ACTION["PUBLISHER_START_MIXING_AUDIO"] = "zc.p.0.sma.0";
    ZEGO_WEBRTC_ACTION["PUBLISHER_STOP_MIXING_AUDIO"] = "zc.p.0.sma.1";
    ZEGO_WEBRTC_ACTION["PUBLISHER_MIXING_BUFFER"] = "zc.p.0.mb";
    ZEGO_WEBRTC_ACTION["PUBLISHER_SET_MIXING_AUDIO_VOLUME"] = "zc.p.0.smav"; //设置混音音量
})(ZEGO_WEBRTC_ACTION = exports.ZEGO_WEBRTC_ACTION || (exports.ZEGO_WEBRTC_ACTION = {}));


/***/ }),

/***/ "./sdk/src/modules/audioMix/audioMix.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/audioMix/audioMix.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AudioMix = void 0;
var error_1 = __webpack_require__(/*! ./error */ "./sdk/src/modules/audioMix/error.ts");
var AudioMix = /** @class */ (function () {
    function AudioMix(logger, stateCenter, ac, mediaEleSources) {
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.ac = ac;
        this.mediaEleSources = mediaEleSources;
        this.audioBufferList = [];
        this.loop = false;
        this.replace = false;
        this.effectEndedCallBack = null;
        this.effectEndedListener = null;
        this.startTimes = 0;
        this.startOffset = 0;
        this.pauseTimes = 0;
        this.resumeOffset = 0;
        //混音
        this.paused = false;
        this.isMixAudio = false;
        this.isMixingBuffer = false;
        this.audioCurrentTimer = null;
    }
    //预加载音效
    AudioMix.prototype.preloadEffect = function (effectUrl, callBack) {
        var _this = this;
        this.logger.info("amu.pe.0 start preload effect");
        var xhr = new XMLHttpRequest();
        xhr.open("GET", effectUrl, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = function () {
            if (xhr.status == 200 || xhr.status == 304) {
                var buffer = xhr.response;
                _this.ac.resume();
                _this.ac.decodeAudioData(buffer, function (ab) {
                    _this.logger.info("amu.pe.0 effect preload success");
                    callBack("", ab);
                }, function (err) {
                    callBack(err);
                });
            }
            else {
                var err = xhr.statusText;
                callBack(err);
            }
        };
        xhr.send();
    };
    AudioMix.prototype.playEffect = function (playTime, loop, replace, start, end) {
        var _this = this;
        if (this.isMixAudio === true) {
            this.logger.error("amu.pe.1 audio is mixing");
            return;
        }
        if (!this.audioBuffer) {
            this.logger.error("amu.pe.1 no audio buffer found");
            return;
        }
        this.startOffset = playTime || 0;
        this.loop = loop || false;
        this.replace = replace || false;
        this.effectEndedCallBack = end;
        this.mixEffect(this.audioBuffer, function () {
            loop ? (_this.buffSource.loop = true) : (_this.buffSource.loop = false);
            playTime
                ? _this.buffSource.start(0, playTime / 1e3)
                : _this.buffSource.start(0);
            _this.startTimes = Date.now();
            _this.effectEndedListener = _this.effectEndedHandler.bind(_this);
            _this.buffSource.addEventListener("ended", _this.effectEndedListener);
            start && start();
        });
    };
    AudioMix.prototype.mixingBuffer = function (ab, callBack) {
        var _this = this;
        if (this.isMixAudio === true &&
            this.audioBufferList.length == 0 &&
            this.isMixingBuffer == false) {
            this.logger.error("amu.mb.0 audio is mixing");
            return;
        }
        this.ac.resume();
        this.ac.decodeAudioData(ab, function (audioBuffer) {
            _this.audioBufferList.push(audioBuffer);
            _this.audioBufferList.length == 1 &&
                _this.playRealTimeEffect(_this.audioBufferList[0]);
            _this.isMixingBuffer = true;
            callBack && callBack();
        }, function (err) {
            _this.logger.error("amu.mb.0 " + err);
            callBack &&
                callBack({
                    code: error_1.errorCodeList.PUBLISHER_DECODE_AUDIO_FAIL.code,
                    message: error_1.errorCodeList.PUBLISHER_DECODE_AUDIO_FAIL.message + " " + err
                });
        });
    };
    AudioMix.prototype.stopMingBuffer = function () {
        this.isMixingBuffer = false;
        return this.stopMixingAudio();
    };
    AudioMix.prototype.playRealTimeEffect = function (ab) {
        var _this = this;
        this.mixEffect(ab, function () {
            _this.buffSource && _this.buffSource.start(0);
            _this.buffSource &&
                _this.buffSource.addEventListener("ended", function () {
                    _this.audioBufferList.shift();
                    _this.audioBufferList.length > 0 &&
                        _this.isMixAudio &&
                        _this.playRealTimeEffect(_this.audioBufferList[0]);
                });
        });
    };
    AudioMix.prototype.pauseEffect = function () {
        if (this.audioBufferList.length > 0) {
            this.logger.error("amu.pe.0 real time buffer can not be paused");
            return;
        }
        this.stopMixingAudio();
        this.resumeOffset =
            (this.pauseTimes - this.startTimes + this.startOffset) %
                (this.audioBuffer.duration * 1e3);
        this.paused = true;
    };
    AudioMix.prototype.resumeEffect = function () {
        if (this.audioBufferList.length > 0) {
            this.logger.error("amu.pe.0 real time buffer can not be resume");
            return;
        }
        this.playEffect(this.resumeOffset, this.loop, this.replace, undefined, this.effectEndedCallBack);
        this.startOffset = this.resumeOffset;
        this.paused = false;
    };
    AudioMix.prototype.mixEffect = function (audioBuffer, callBack) {
        if (!this.localStream) {
            this.logger.error("amu.me.0 localStream can not be found");
            return;
        }
        this.ac.resume();
        this.gainNode = this.ac.createGain();
        this.buffSource = this.ac.createBufferSource();
        this.buffSource.buffer = audioBuffer;
        this.buffSource.connect(this.gainNode);
        this.gainNode.connect(this.ac.destination);
        this.replaceTrack() && callBack();
    };
    //开始混音
    AudioMix.prototype.startMixingAudio = function (audio, replace) {
        this.replace = replace || false;
        if (this.isMixAudio) {
            this.logger.error("amu.sma.0 audio is mixing");
            return false;
        }
        if (!this.localStream) {
            this.logger.error("amu.sma.0 localStream can not be found");
            return false;
        }
        audio.captureStream =
            audio.captureStream ||
                audio.mozCaptureStream ||
                audio.webkitCaptureStream;
        //混音
        this.ac.resume();
        this.gainNode = this.ac.createGain();
        var bro = this.stateCenter.browser;
        if (bro === "safari") {
            var mediaEle = this.mediaEleSources.find(function (item) { return item.audio === audio; });
            if (mediaEle) {
                this.mixAudio = mediaEle.node;
            }
            else {
                var node = this.ac.createMediaElementSource(audio);
                this.mixAudio = node;
                this.mediaEleSources.push({ audio: audio, node: node });
            }
            audio.currentTime = audio.currentTime;
            this.audioCurrentTimer = setInterval(function () {
                audio.currentTime = audio.currentTime + 0.45;
            }, 6000);
        }
        else {
            this.mixAudio = this.ac.createMediaStreamSource(audio.captureStream());
        }
        this.mixAudio.connect(this.gainNode);
        return this.replaceTrack();
    };
    AudioMix.prototype.replaceTrack = function () {
        this.streamSource = this.ac.createMediaStreamSource(this.localStream);
        this.destination = this.ac.createMediaStreamDestination();
        !this.replace && this.streamSource.connect(this.destination);
        this.gainNode.connect(this.destination);
        //替换推流音轨
        var audioTrack = this.destination.stream.getAudioTracks()[0];
        var sender = this.peerConnection
            .getSenders()
            .find(function (s) { return s.track.kind === audioTrack.kind; });
        if (!sender) {
            this.logger.error("amu.rt.0 no sender");
            return false;
        }
        this.micTrack = this.localStream.getAudioTracks()[0];
        sender.replaceTrack(audioTrack);
        this.localStream.removeTrack(this.micTrack);
        this.localStream.addTrack(audioTrack);
        this.isMixAudio = true;
        return true;
    };
    AudioMix.prototype.stopMixingAudio = function () {
        var _this = this;
        if (this.paused) {
            this.logger.info("amu.sma.1 audioEffect paused");
            return true;
        }
        if (!this.isMixAudio) {
            this.logger.warn("amu.sma.1 no mixing audio found");
            return true;
        }
        if (!this.localStream) {
            this.logger.error("amu.sma.1 localStream can not be found");
            return false;
        }
        var sender = this.peerConnection
            .getSenders()
            .find(function (s) { return s.track.kind === _this.micTrack.kind; });
        // sender.replaceTrack(this.micTrack);
        // this.localStream.removeTrack(this.localStream.getAudioTracks()[0]);
        // this.localStream.addTrack(this.micTrack!);
        if (this.mixAudio) {
            this.mixAudio.disconnect(this.gainNode);
            this.mixAudio = null;
            if (this.audioCurrentTimer) {
                clearInterval(this.audioCurrentTimer);
                this.audioCurrentTimer = null;
            }
        }
        else if (this.buffSource) {
            this.buffSource.removeEventListener("ended", this.effectEndedListener);
            this.buffSource.stop();
            this.pauseTimes = Date.now();
            this.buffSource.disconnect(this.gainNode);
            this.buffSource = null;
        }
        this.gainNode.disconnect(this.destination);
        //this.micTrack = null;
        this.isMixAudio = false;
        this.audioBufferList = [];
        return true;
    };
    AudioMix.prototype.setMixingAudioVolume = function (volume) {
        if (!this.gainNode) {
            this.logger.error("amu.sma.2 no mixing audio found");
            return false;
        }
        this.gainNode.gain.value = volume;
        return true;
    };
    AudioMix.prototype.effectEndedHandler = function () {
        this.stopMixingAudio();
        this.effectEndedCallBack && this.effectEndedCallBack();
    };
    return AudioMix;
}());
exports.AudioMix = AudioMix;


/***/ }),

/***/ "./sdk/src/modules/audioMix/audioModule.ts":
/*!*************************************************!*\
  !*** ./sdk/src/modules/audioMix/audioModule.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AudioMixModule = void 0;
var action_1 = __webpack_require__(/*! ./action */ "./sdk/src/modules/audioMix/action.ts");
var logevent_1 = __webpack_require__(/*! ./logevent */ "./sdk/src/modules/audioMix/logevent.ts");
var AudioMixModule = /** @class */ (function () {
    function AudioMixModule(logger, dataReport, stateCenter, streamCenter, ac) {
        this.logger = logger;
        this.dataReport = dataReport;
        this.stateCenter = stateCenter;
        this.streamCenter = streamCenter;
        this.ac = ac;
        this.buffer = null;
        this.blank = null;
        if (this.stateCenter.browser == "safari" &&
            this.blank == null &&
            this.buffer == null) {
            this.ac.resume();
            this.buffer = this.ac.createBuffer(1, 1, this.ac.sampleRate);
            this.blank = this.ac.createBufferSource();
            this.blank.buffer = this.buffer;
            this.blank.connect(this.ac.destination);
            this.blank.start();
        }
    }
    //预加载音效
    AudioMixModule.prototype.preloadEffect = function (id, effectUrl, callBack) {
        if (!id ||
            typeof id !== "string" ||
            !effectUrl ||
            typeof effectUrl !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PRELOAD_EFFECT + " params error");
            return;
        }
        if (this.stateCenter.audioEffectBuffer[id]) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PRELOAD_EFFECT + " audio buffer already exists");
            return;
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PRELOAD_EFFECT + " start preload effect");
        this._preloadEffect(this.ac, id, effectUrl, callBack);
    };
    AudioMixModule.prototype.playEffect = function (audioMixConfig, start, end) {
        if (!audioMixConfig.streamID ||
            typeof audioMixConfig.streamID !== "string" ||
            !audioMixConfig.effectID ||
            typeof audioMixConfig.effectID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAY_EFFECT + " params error");
            return;
        }
        if (!this.stateCenter.audioEffectBuffer[audioMixConfig.effectID]) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAY_EFFECT + " audio buffer doesn't exists");
            return;
        }
        this._playEffect(audioMixConfig, start, end);
    };
    AudioMixModule.prototype.pauseEffect = function (streamID, effectID) {
        if (!streamID || typeof streamID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PAUSE_EFFECT + " streamID format error");
            return false;
        }
        if (effectID && typeof effectID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PAUSE_EFFECT + " effect ");
        }
        return this._pauseEffect(streamID, effectID);
    };
    AudioMixModule.prototype.resumeEffect = function (streamID, effectID) {
        if (!streamID || typeof streamID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.RESUME_EFFECT + " streamID format error");
            return false;
        }
        if (effectID && typeof effectID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.RESUME_EFFECT + " effect ");
        }
        return this._resumeEffect(streamID, effectID);
    };
    AudioMixModule.prototype.stopEffect = function (streamID, effectID) {
        if (!streamID || typeof streamID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.STOP_EFFECT + " streamID format error");
            return false;
        }
        if (effectID && typeof effectID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.STOP_EFFECT + " effect ");
        }
        return this._stopEffect(streamID, effectID);
    };
    AudioMixModule.prototype.unloadEffect = function (effecId) {
        if (!effecId || typeof effecId !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.UNLOAD_EFFECT + " params error");
            return false;
        }
        delete this.stateCenter.audioEffectBuffer[effecId];
        return true;
    };
    AudioMixModule.prototype.setEffectVolume = function (streamID, volume, effectID) {
        if (!streamID || typeof streamID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_EFFECT_VOLUME + " streamID format error");
            return false;
        }
        if (effectID && typeof effectID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_EFFECT_VOLUME + " effect ");
        }
        var publisher = this.streamCenter.getPublisher(streamID);
        if (!publisher) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_EFFECT_VOLUME + " publisher doesn't exist");
            return false;
        }
        return publisher.setEffectVolume(volume / 100, effectID);
    };
    //开始混音
    AudioMixModule.prototype.startMixingAudio = function (streamID, audio) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.START_MIXING_AUDIO + " call " + streamID);
        if (!streamID || typeof streamID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_MIXING_AUDIO + " stream id type error");
            return false;
        }
        if (!audio) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_MIXING_AUDIO + " no audio");
            return false;
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.START_MIXING_AUDIO + " end " + streamID);
        if (Array.isArray(audio) && audio.length !== 0) {
            return this._startMixingAudio(streamID, audio);
        }
        else {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_MIXING_AUDIO + " audio param type error");
            return false;
        }
    };
    //停止混音
    AudioMixModule.prototype.stopMixingAudio = function (streamID, audio) {
        if (!streamID || typeof streamID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.STOP_MIXING_AUDIO + " param streamID format error");
            return false;
        }
        if ((Array.isArray(audio) && audio.length !== 0) ||
            typeof audio == "undefined") {
            return this._stopMixingAudio(streamID, audio);
        }
        else {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.STOP_MIXING_AUDIO + " audio param type error");
            return false;
        }
    };
    AudioMixModule.prototype.mixingBuffer = function (streamID, sourceID, arrayBuffer, callBack) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MIXING_BUFFER +
            " call streamID: " +
            streamID +
            " sourceID:" +
            sourceID);
        if (!streamID || typeof streamID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.MIXING_BUFFER + " param streamid format error");
            return;
        }
        if (!sourceID || typeof sourceID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.MIXING_BUFFER + " param source id format error");
            return;
        }
        this._mixingBuffer(streamID, sourceID, arrayBuffer, callBack);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MIXING_BUFFER + " end");
    };
    AudioMixModule.prototype.stopMixingBuffer = function (streamID, sourceID) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STOP_MIXING_BUFFER +
            " call streamID: " +
            streamID +
            " sourceID:" +
            sourceID);
        if (!streamID || typeof streamID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.STOP_MIXING_BUFFER + " param streamid format error");
            return false;
        }
        if (!sourceID || typeof sourceID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.STOP_MIXING_BUFFER + " param source id format error");
            return false;
        }
        return this._stopMixingBuffer(streamID, sourceID);
    };
    AudioMixModule.prototype.setMixingAudioVolume = function (streamID, volume, audio) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SET_MIXING_AUDIO_VOLUME + " call");
        if (typeof streamID !== "string" || streamID == "") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_MIXING_AUDIO_VOLUME +
                " stream ID must be string and not empty");
            return false;
        }
        if (typeof volume !== "number" || volume < 0 || volume > 100) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_MIXING_AUDIO_VOLUME +
                " volume must be a number between 0 and 100");
            return false;
        }
        if (!audio || !(audio instanceof HTMLMediaElement)) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_MIXING_AUDIO_VOLUME + " no audio");
            return false;
        }
        return this._setMixingAudioVolume(streamID, volume, audio);
    };
    AudioMixModule.prototype.getSoundLevel = function (localStream, sucCallBack, errCallBack) {
        this.logger.info("zc.gsl call");
        var reportSeq = this.stateCenter.getReportSeq();
        this.dataReport.newReport(reportSeq, logevent_1.ZegoRTCLogEvent.kZegoTaskGetSoundLevel.event);
        try {
            this.ac.resume();
            var mic = this.ac.createMediaStreamSource(localStream);
            var script = this.ac.createScriptProcessor(4096, 1, 1); //创建一个音频分析对象，采样的缓冲区大小为4096，输入和输出都是单声道
            this.stateCenter.audioStreamList[localStream.id] = { mic: mic, script: script };
            mic.connect(script); //将该分析对象与麦克风音频进行连接
            script.connect(this.ac.destination);
            script.onaudioprocess = function (e) {
                //开始处理音频
                var buffer = e.inputBuffer.getChannelData(0); //获得缓冲区的输入音频，转换为包含了PCM通道数据的32位浮点数组
                //创建变量并迭代来获取最大的音量值
                var maxVal = 0;
                for (var i = 0; i < buffer.length; i++) {
                    if (maxVal < buffer[i]) {
                        maxVal = buffer[i];
                    }
                }
                sucCallBack(maxVal);
            };
            this.dataReport.uploadReport(reportSeq);
        }
        catch (err) {
            errCallBack(err);
            this.dataReport.addMsgInfo(reportSeq, logevent_1.ZegoRTCLogEvent.kZegoTaskGetSoundLevel.error.kGetSoundLevelError);
            this.dataReport.uploadReport(reportSeq);
        }
        this.logger.info("zc.gsl call success");
    };
    AudioMixModule.prototype.stopSoundLevel = function (localStream) {
        this.logger.info("zc.ssl call");
        var reportSeq = this.stateCenter.getReportSeq();
        this.dataReport.newReport(reportSeq, logevent_1.ZegoRTCLogEvent.kZegoTaskStopSoundLevel);
        var ctx = this.stateCenter.audioStreamList[localStream.id];
        ctx.mic.disconnect();
        ctx.script.disconnect();
        delete this.stateCenter.audioStreamList[localStream.id];
        this.dataReport.uploadReport(reportSeq);
    };
    AudioMixModule.prototype._preloadEffect = function (ac, id, effectUrl, callBack) {
        var _this = this;
        var xhr = new XMLHttpRequest();
        xhr.open("GET", effectUrl, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = function () {
            if (xhr.status == 200 || xhr.status == 304) {
                var buffer = xhr.response;
                ac.decodeAudioData(buffer, function (ab) {
                    _this.logger.info("zc.pe.0 effect preload success");
                    _this.stateCenter.audioEffectBuffer[id] = ab;
                    callBack && callBack();
                }, function (err) {
                    _this.logger.error("zc.pe.0 effect preload fail " + err);
                    callBack && callBack(err);
                });
            }
            else {
                var err = xhr.statusText;
                _this.logger.error("zc.pe.0 effect preload fail " + err);
                callBack && callBack(err);
            }
        };
        xhr.send();
    };
    AudioMixModule.prototype._playEffect = function (audioMixConfig, start, end) {
        var audioBuffer = this.stateCenter.audioEffectBuffer[audioMixConfig.effectID];
        var publisher = this.streamCenter.getPublisher(audioMixConfig.streamID);
        if (!publisher) {
            this.logger.error("zc.pe.1 publisher doesn't exist");
            return;
        }
        if (audioBuffer) {
            publisher.playEffect(audioMixConfig, audioBuffer, start, end);
        }
        else {
            this.logger.error("zc.pe.1 no audio buffer found");
        }
    };
    AudioMixModule.prototype._pauseEffect = function (streamID, effectID) {
        var publisher = this.streamCenter.getPublisher(streamID);
        if (!publisher) {
            this.logger.error("zc.pe.2 publisher doesn't exist");
            return false;
        }
        return publisher.pauseEffect(effectID);
    };
    AudioMixModule.prototype._resumeEffect = function (streamID, effectID) {
        var publisher = this.streamCenter.getPublisher(streamID);
        if (!publisher) {
            this.logger.error("zc.re.0 publisher doesn't exist");
            return false;
        }
        return publisher.resumeEffect(effectID);
    };
    AudioMixModule.prototype._stopEffect = function (streamID, effectID) {
        var publisher = this.streamCenter.getPublisher(streamID);
        if (!publisher) {
            this.logger.error("zc.re.0 publisher doesn't exist");
            return false;
        }
        return publisher.stopEffect(effectID);
    };
    AudioMixModule.prototype._setMixingAudioVolume = function (streamID, volume, audio) {
        var publisher = this.streamCenter.getPublisher(streamID);
        if (!publisher) {
            this.logger.error("zc.sma.2 publisher doesn't exist");
            return false;
        }
        // return true;
        //todo
        return publisher.setMixingAudioVolume(volume / 100, audio);
    };
    AudioMixModule.prototype._startMixingAudio = function (streamID, mediaList) {
        var publisher = this.streamCenter.getPublisher(streamID);
        if (!publisher) {
            this.logger.error("zc.sma.0 publisher doesn't exist");
            return false;
        }
        return publisher.startMixingAudio(mediaList);
    };
    AudioMixModule.prototype._stopMixingAudio = function (streamID, audio) {
        var publisher = this.streamCenter.getPublisher(streamID);
        if (!publisher) {
            this.logger.error("zc.sma.1 publisher doesn't exist");
            return false;
        }
        return publisher.stopMixingAudio(audio);
    };
    AudioMixModule.prototype._mixingBuffer = function (streamID, sourceID, arrayBuffer, callBack) {
        var publisher = this.streamCenter.getPublisher(streamID);
        if (!publisher) {
            this.logger.error("zc.mb.0 publisher doesn't exist");
            return;
        }
        if (arrayBuffer instanceof ArrayBuffer) {
            publisher.mixingBuffer(sourceID, arrayBuffer, callBack);
        }
        else {
            this.logger.error("zc.mb.0 array buffer not found");
            return;
        }
    };
    AudioMixModule.prototype._stopMixingBuffer = function (streamID, sourceID) {
        var publisher = this.streamCenter.getPublisher(streamID);
        if (!publisher) {
            this.logger.error("zc.sma.1 publisher doesn't exist");
            return false;
        }
        return publisher.stopMixingBuffer(sourceID);
    };
    return AudioMixModule;
}());
exports.AudioMixModule = AudioMixModule;


/***/ }),

/***/ "./sdk/src/modules/audioMix/content.ts":
/*!*********************************************!*\
  !*** ./sdk/src/modules/audioMix/content.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.publisher = void 0;
//@ts-nocheck
var action_1 = __webpack_require__(/*! ./action */ "./sdk/src/modules/audioMix/action.ts");
var audioMix_1 = __webpack_require__(/*! ./audioMix */ "./sdk/src/modules/audioMix/audioMix.ts");
//publisher
exports.publisher = {
    playEffect: function (AudioMixConfig, audioBuffer, start, end) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_PLAY_EFFECT + "" + this.streamId + " call");
        if (this.effectList.find(function (effect) {
            return effect.effectID == AudioMixConfig.effectID &&
                effect.audioBuffer == audioBuffer;
        })) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_PLAY_EFFECT +
                "" +
                this.streamId +
                " effect alreadly exist ");
            return;
        }
        else {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            var audioMix = new audioMix_1.AudioMix(this.logger, this.stateCenter, this.ac, this.mediaEleSources);
            audioMix.localStream = this.localStream;
            audioMix.peerConnection = this.peerConnection;
            audioMix.audioBuffer = audioBuffer;
            this.effectList.push({
                audioMix: audioMix,
                effectID: AudioMixConfig.effectID,
                audioBuffer: audioBuffer
            });
            audioMix.playEffect(AudioMixConfig.playTime, AudioMixConfig.loop, false, start, end);
            this.streamCenter.soundLevelDelegate && this.startSoundLevel();
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_PLAY_EFFECT +
                "" +
                this.streamId +
                " play effect " +
                AudioMixConfig.effectID +
                " success");
        }
    },
    pauseEffect: function (effectID) {
        var effect = this.effectList.find(function (effect) { return effect.effectID == effectID; });
        if (effect) {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            effect.audioMix.pauseEffect();
            this.streamCenter.soundLevelDelegate && this.startSoundLevel();
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_PAUSE_EFFECT +
                " " +
                this.streamId +
                " pause " +
                effectID +
                " success");
        }
        else if (typeof effectID == "undefined") {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            this.effectList.forEach(function (effect) { return effect.audioMix.pauseEffect(); });
            this.streamCenter.soundLevelDelegate && this.startSoundLevel();
        }
        else {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_PAUSE_EFFECT +
                " " +
                this.streamId +
                " no effect ID found");
            return false;
        }
        return true;
    },
    resumeEffect: function (effectID) {
        var effect = this.effectList.find(function (effect) { return effect.effectID == effectID; });
        if (effect) {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            effect.audioMix.resumeEffect();
            this.streamCenter.soundLevelDelegate && this.startSoundLevel();
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_RESUME_EFFECT +
                " " +
                this.streamId +
                " resume" +
                effectID +
                " success");
        }
        else if (typeof effectID == "undefined") {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            this.effectList.forEach(function (effect) { return effect.audioMix.resumeEffect(); });
            this.streamCenter.soundLevelDelegate && this.startSoundLevel();
        }
        else {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_RESUME_EFFECT +
                " " +
                this.streamId +
                " no effect ID found");
            return false;
        }
        return false;
    },
    stopEffect: function (effectID) {
        var effect = this.effectList.find(function (effect) { return effect.effectID == effectID; });
        if (effect) {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            effect.audioMix.stopMixingAudio();
            this.effectList.splice(this.effectList.indexOf(effect), 1);
            this.streamCenter.soundLevelDelegate && this.startSoundLevel();
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_STOP_EFFECT +
                " " +
                this.streamId +
                " pause " +
                effectID +
                " success");
        }
        else if (typeof effectID == "undefined") {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            this.effectList.forEach(function (effect) { return effect.audioMix.stopMixingAudio(); });
            this.effectList = [];
            this.streamCenter.soundLevelDelegate && this.startSoundLevel();
        }
        else {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_STOP_EFFECT +
                " " +
                this.streamId +
                " no effect ID found");
            return false;
        }
        // this.rebackMic();
        return true;
    },
    setEffectVolume: function (volume, effectID) {
        var effect = this.effectList.find(function (effect) { return effect.effectID == effectID; });
        if (effect) {
            effect.audioMix.setMixingAudioVolume(volume);
            this.logger.info("zp.sev.0 " + this.streamId + " set volume " + effectID + " success");
        }
        else if (typeof effectID == "undefined") {
            this.effectList.forEach(function (effect) {
                return effect.audioMix.setMixingAudioVolume(volume);
            });
        }
        else {
            this.logger.error("zp.sev.0 " + this.streamId + " no effect ID found");
            return false;
        }
        return true;
    },
    startMixingAudio: function (mediaList) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_MIXING_AUDIO +
            " " +
            this.streamId +
            " call");
        if (!this.localStream) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_MIXING_AUDIO +
                " localStream not found");
            return false;
        }
        if (!this.micTrack)
            this.micTrack =
                this.localStream.getAudioTracks().length > 0
                    ? this.localStream.getAudioTracks()[0]
                    : null;
        mediaList.forEach(function (media) {
            if (_this.audioMixList.find(function (i) { return i.media == media; })) {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_MIXING_AUDIO +
                    " " +
                    _this.streamId +
                    " mix audio already exist");
            }
            else {
                _this.streamCenter.soundLevelDelegate && _this.stopSoundLevel();
                var audioMix = new audioMix_1.AudioMix(_this.logger, _this.stateCenter, _this.ac, _this.mediaEleSources);
                audioMix.localStream = _this.localStream;
                audioMix.peerConnection = _this.peerConnection;
                _this.audioMixList.push({
                    audioMix: audioMix,
                    media: media
                });
                audioMix.startMixingAudio(media);
                _this.streamCenter.soundLevelDelegate && _this.startSoundLevel();
            }
        });
        return true;
    },
    stopMixingAudio: function (media) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_STOP_MIXING_AUDIO +
            " " +
            this.streamId +
            " call");
        if (media) {
            media.forEach(function (media) {
                for (var i = 0; i < _this.audioMixList.length; i++) {
                    if (_this.audioMixList[i].media == media) {
                        _this.audioMixList[i].audioMix.stopMixingAudio() &&
                            _this.audioMixList.splice(i--, 1);
                        break;
                    }
                }
            });
        }
        else {
            this.audioMixList.forEach(function (i) { return i.audioMix.stopMixingAudio(); });
            this.audioMixList = [];
        }
        // this.rebackMic();
        return true;
    },
    mixingBuffer: function (sourceID, arrayBuffer, callBack) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_MIXING_BUFFER + " " + this.streamId + " call");
        if (!this.micTrack)
            this.micTrack =
                this.localStream.getAudioTracks().length > 0
                    ? this.localStream.getAudioTracks()[0]
                    : null;
        if (this.arrayBufferMap[sourceID]) {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            this.arrayBufferMap[sourceID].mixingBuffer(arrayBuffer, function () {
                _this.streamCenter.soundLevelDelegate && _this.startSoundLevel();
                callBack && callBack();
            });
        }
        else {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            var audioMix = new audioMix_1.AudioMix(this.logger, this.stateCenter, this.ac, this.mediaEleSources);
            audioMix.localStream = this.localStream;
            audioMix.peerConnection = this.peerConnection;
            this.arrayBufferMap[sourceID] = audioMix;
            audioMix.mixingBuffer(arrayBuffer, function () {
                _this.streamCenter.soundLevelDelegate && _this.startSoundLevel();
                callBack && callBack();
            });
        }
    },
    stopMixingBuffer: function (sourceID) {
        if (sourceID && this.arrayBufferMap[sourceID]) {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            this.arrayBufferMap[sourceID].stopMingBuffer();
            delete this.arrayBufferMap[sourceID];
            this.streamCenter.soundLevelDelegate && this.startSoundLevel();
            return true;
        }
        else if (typeof sourceID == "undefined") {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            for (var i in this.arrayBufferMap) {
                this.arrayBufferMap[i].stopMingBuffer();
            }
            this.streamCenter.soundLevelDelegate && this.startSoundLevel();
            return true;
        }
        else {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_MIXING_BUFFER +
                " " +
                this.streamId +
                " arrayBuffer no found");
            return false;
        }
        // this.rebackMic();
    },
    setMixingAudioVolume: function (volume, audio) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SET_MIXING_AUDIO_VOLUME +
            " " +
            this.streamId +
            " call");
        var audioMixItem = this.audioMixList.find(function (item) { return item.media === audio; });
        if (audioMixItem) {
            audioMixItem.audioMix.setMixingAudioVolume(volume);
        }
        else {
            // todo
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SET_MIXING_AUDIO_VOLUME +
                " " +
                this.streamId +
                " audio is not mixing");
            return false;
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SET_MIXING_AUDIO_VOLUME +
            " " +
            this.streamId +
            " call success");
        return true;
    }
};


/***/ }),

/***/ "./sdk/src/modules/audioMix/error.ts":
/*!*******************************************!*\
  !*** ./sdk/src/modules/audioMix/error.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorCodeList = void 0;
exports.errorCodeList = {
    GET_SOUND_LEVEL_FAIL: {
        code: 1000019,
        message: "get sound level error"
    },
    PUBLISHER_DECODE_AUDIO_FAIL: {
        code: 1103057,
        message: "decode audio data fail"
    }
};


/***/ }),

/***/ "./sdk/src/modules/audioMix/index.ts":
/*!*******************************************!*\
  !*** ./sdk/src/modules/audioMix/index.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//@ts-nocheck
var audioModule_1 = __webpack_require__(/*! ./audioModule */ "./sdk/src/modules/audioMix/audioModule.ts");
var content_1 = __webpack_require__(/*! ./content */ "./sdk/src/modules/audioMix/content.ts");
exports["default"] = {
    type: "AudioMix",
    install: function (RTCModules, ZegoPublish) {
        Object.defineProperty(RTCModules.prototype, "initAudioMix", {
            value: function () {
                this.audioMixModule = new audioModule_1.AudioMixModule(this.logger, this.dataReport, this.stateCenter, this.streamCenter, this.ac);
            }
        });
        for (var key in content_1.publisher) {
            Object.defineProperty(ZegoPublish.prototype, key, {
                value: content_1.publisher[key],
                writable: false
            });
        }
    }
};


/***/ }),

/***/ "./sdk/src/modules/audioMix/logevent.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/audioMix/logevent.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoRTCLogEvent = void 0;
var error_1 = __webpack_require__(/*! ./error */ "./sdk/src/modules/audioMix/error.ts");
exports.ZegoRTCLogEvent = {
    kZegoTaskGetSoundLevel: {
        event: "/sdk/get_sound_level",
        error: {
            kGetSoundLevelError: error_1.errorCodeList.GET_SOUND_LEVEL_FAIL
        }
    },
    kZegoTaskStopSoundLevel: "/sdk/stop_sound_level"
};


/***/ }),

/***/ "./sdk/src/modules/datachannel/index.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/datachannel/index.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataChannel = void 0;
var ZegoExpressDataChannel_web_1 = __webpack_require__(/*! ../../../code/zh/ZegoExpressDataChannel.web */ "./sdk/code/zh/ZegoExpressDataChannel.web.ts");
exports.DataChannel = {
    type: "DataChannel",
    install: function (ZegoWebRTC) {
        Object.defineProperty(ZegoWebRTC.prototype, "createRealTimeSequentialDataManager", {
            value: function (roomID) {
                this.enableDataChannel(true);
                var room = this.stateCenter.getRoomByRoomID(roomID);
                if (!room) {
                    this.logger.error("zc.crsdm room no exist");
                    return null;
                }
                if (!room.dataChannelManager) {
                    room.dataChannelManager = new ZegoExpressDataChannel_web_1.ZegoRealTimeSequentialDataManager(this, roomID);
                    return room.dataChannelManager;
                }
                else {
                    return null;
                }
            },
            writable: false
        });
        Object.defineProperty(ZegoWebRTC.prototype, "destroyRealTimeSequentialDataManager", {
            value: function (manager) {
                var room = this.stateCenter.roomList.find(function (room) { return room.dataChannelManager == manager; });
                if (room) {
                    //@ts-ignore
                    manager.dataChannelManager.reset();
                    room.dataChannelManager = null;
                }
            },
            writable: false
        });
    }
};


/***/ }),

/***/ "./sdk/src/modules/datachannel/manager.ts":
/*!************************************************!*\
  !*** ./sdk/src/modules/datachannel/manager.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataChannelListener = void 0;
var CHUNK_MTU = 1151; //1191 - 40 max size of single message slice
var MSG_HEADER_SIZE = 10; //1 + 1 + 2 + 2 + 4
var END_OF_MSG = 0x1;
var TYPE_USER_DATA = 1;
var DataChannelListener = /** @class */ (function () {
    function DataChannelListener(zegoWebRTC, roomID) {
        this.zegoWebRTC = zegoWebRTC;
        this.roomID = roomID;
        this.pubDataChannelList = [];
        this.subDataChannelList = [];
        this.listenerList = {
            receiveRealTimeSequentialData: []
        };
        this.logger = zegoWebRTC.logger;
    }
    // 开始广播
    // 内部调用 startPublishingStream ，进行推流（没有推音视频数据），实际占用一个 main publish channel。
    // 由于强调 发布-订阅 关系，又不想与原有音视频的推流接口混淆，因此命名 Broadcast
    // 表达一个 广播-订阅 的意思
    // 由于复用房间概念，那继续使用流ID，从而在原房间回调中能对得上 streamID 参数。
    DataChannelListener.prototype.startBroadcasting = function (streamID, config) {
        return __awaiter(this, void 0, void 0, function () {
            var publish, can, _a, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.logger.info("dc.sb.0 call");
                        if (this.pubDataChannelList.includes(streamID)) {
                            this.logger.error("dc.sb.0 datachannel already exist");
                            return [2 /*return*/, false];
                        }
                        publish = this.zegoWebRTC.streamCenter.publisherList[streamID];
                        if (publish && publish.publisher.dataChannel) {
                            this.pubDataChannelList.push(streamID);
                            return [2 /*return*/, true];
                        }
                        else if (publish && !publish.publisher.dataChannel) {
                            this.logger.error("dc.sb.0 publish datachannel no exist, try other stream ID");
                            return [2 /*return*/, false];
                        }
                        if (!!this.broadcastStream) return [3 /*break*/, 2];
                        can = document.createElement("canvas");
                        _a = this;
                        return [4 /*yield*/, this.zegoWebRTC.createStream({
                                custom: {
                                    //@ts-ignore
                                    source: can
                                }
                            })];
                    case 1:
                        _a.broadcastStream = _b.sent();
                        _b.label = 2;
                    case 2:
                        result = this.zegoWebRTC.startPublishingStream(streamID, this.broadcastStream, { roomID: this.roomID }, true);
                        if (result)
                            this.pubDataChannelList.push(streamID);
                        this.logger.info("dc.sb.0 end");
                        return [2 /*return*/, result];
                }
            });
        });
    };
    // 对应停止推流的接口，停止后，释放 main publish channel
    DataChannelListener.prototype.stopBroadcasting = function (streamID) {
        this.logger.info("dc.sb.1 call");
        this.pubDataChannelList = this.pubDataChannelList.filter(function (val) { return val !== streamID; });
        //复用则不能影响原来的流
        var publish = this.zegoWebRTC.streamCenter.publisherList[streamID];
        if (!publish) {
            this.logger.error("dc.sb.1 datachannel no found");
            return false;
        }
        if (publish.room.roomID == this.roomID && publish.isDataChannel) {
            this.zegoWebRTC.stopPublishingStream(streamID);
        }
        this.logger.info("dc.sb.1 end");
        return true;
    };
    // 发送实时信令
    // 回调中告知发送结果
    DataChannelListener.prototype.sendRealTimeSequentialData = function (streamID, data) {
        //@ts-ignore
        if (!data instanceof ArrayBuffer) {
            this.logger.error("dc.srsd data type wrong");
            return false;
        }
        var publisher = this.zegoWebRTC.streamCenter.publisherList[streamID];
        if (!publisher || !this.pubDataChannelList.includes(streamID)) {
            this.logger.error("dc.srsd datachannel no found");
            return false;
        }
        return this.sendBCMessage(publisher.publisher, data);
    };
    DataChannelListener.prototype.sendBCMessage = function (publisher, message) {
        var _a;
        if (!publisher.dataChannelState) {
            //this.logger.error("zp.sbcm.0 data channel state wrong");
            return false;
        }
        var uint8_payload = new Uint8Array(message);
        //Message fragment for the limit of mtu
        var off_set = 0;
        var left = message.byteLength;
        var sn0 = publisher.send_seq;
        var flag = 0;
        var ts = new Date().getTime();
        var msg_frag_len = 0;
        while (left > 0) {
            if (left > CHUNK_MTU) {
                msg_frag_len = CHUNK_MTU - MSG_HEADER_SIZE;
            }
            else {
                msg_frag_len = left;
                flag = END_OF_MSG;
            }
            var send_chunk = new Uint8Array(msg_frag_len + MSG_HEADER_SIZE);
            //type
            send_chunk[0] = TYPE_USER_DATA;
            //flag
            send_chunk[1] = flag;
            //sn
            send_chunk[2] = (publisher.send_seq >> 8) & 0xff;
            send_chunk[3] = publisher.send_seq & 0xff;
            //sn0
            send_chunk[4] = (sn0 >> 8) & 0xff;
            send_chunk[5] = sn0 & 0xff;
            //ts
            send_chunk[6] = (ts >> 24) & 0xff;
            send_chunk[7] = (ts >> 16) & 0xff;
            send_chunk[8] = (ts >> 8) & 0xff;
            send_chunk[9] = ts & 0xff;
            //coopy data
            for (var i = 0; i < msg_frag_len; i++) {
                send_chunk[i + MSG_HEADER_SIZE] = uint8_payload[i + off_set];
            }
            left -= msg_frag_len;
            off_set += msg_frag_len;
            publisher.send_seq++;
            if (publisher.send_seq >= 65536) {
                publisher.send_seq = 0;
            }
            (_a = publisher.dataChannel) === null || _a === void 0 ? void 0 : _a.send(send_chunk);
        }
        return true;
    };
    // 订阅 流 ID，内部使用的是 startPlayingStream
    // 用 Subscribe 来精准表达订阅的意思，同时避免与原拉流接口混淆
    DataChannelListener.prototype.startSubscribing = function (streamID, config) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var play, player;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        this.logger.info("dc.ss.0 call");
                        if (this.subDataChannelList.includes(streamID)) {
                            this.logger.error("dc.ss.0 datachannel already exist");
                            return [2 /*return*/, false];
                        }
                        play = this.zegoWebRTC.streamCenter.playerList[streamID];
                        if (!!play) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.zegoWebRTC.startPlayingStream(streamID, undefined, true)];
                    case 1:
                        _c.sent();
                        play = this.zegoWebRTC.streamCenter.playerList[streamID];
                        _c.label = 2;
                    case 2:
                        player = play.player;
                        if (!player.dataChannel) {
                            this.logger.error("dc.ss.0 datachannel no exist, try other stream ID");
                            return [2 /*return*/, false];
                        }
                        !((_a = player.onDataChannelList) === null || _a === void 0 ? void 0 : _a.includes(this.onReceivedDataChannel.bind(this))) && ((_b = player.onDataChannelList) === null || _b === void 0 ? void 0 : _b.push(this.onReceivedDataChannel.bind(this)));
                        this.subDataChannelList.push(streamID);
                        this.logger.info("dc.ss.0 end");
                        return [2 /*return*/, true];
                }
            });
        });
    };
    // 此处暂时不需要重载一个带 config 的函数，后期若有额外配置，按此方式加重载函数即可
    // 停止订阅
    DataChannelListener.prototype.stopSubscribing = function (streamID) {
        this.logger.info("dc.ss.1 call");
        this.subDataChannelList = this.subDataChannelList.filter(function (val) { return val !== streamID; });
        //若复用则不影响原来的通道
        var play = this.zegoWebRTC.streamCenter.playerList[streamID];
        if (!play) {
            this.logger.error("dc.ss.1 datachannel no subscribe");
            return false;
        }
        if (play.room.roomID == this.roomID && play.isDataChannel) {
            this.zegoWebRTC.stopPlayingStream(streamID);
        }
        this.logger.info("dc.ss.1 end");
        return true;
    };
    /**
     * 注册回调事件。
     *
     * Note: 支持版本：2.10.0 及以上
     *
     * Note: 详情描述：用于处理 SDK 主动通知开发者回调的接口，通过注册不同 event 的事件，可以收到不同功能的回调。可监听的事件回调可以通过 ZegoRangeAudioEvent 查看。
     *
     * Note: 业务场景：用于注册范围语音功能相关的业务事件的回调处理。
     *
     * Note: 调用时机：调用接口 createRangeAudioInstance 创建实例之后并且在调用接口 loginRoom 登录房间之前。
     *
     * Note: 注意事项：同样的事件可以注册多个, 相同的注册事件，会根据注册的先后顺序依次触发。
     *
     * Note: 相关接口：调用接口 off 来注销对应回调事件处理。
     *
     * @param event 监听事件名。
     * @param callBack 回调函数。
     *
     * @return 注册是否成功。
     */
    DataChannelListener.prototype.on = function (event, callBack) {
        this.bindListener(event, callBack);
    };
    /**
     * 注销回调事件。
     *
     * Note: 支持版本：2.10.0 及以上
     *
     * Note: 详情描述：用于处理 SDK 主动通知开发者回调的接口，通过注册不同 event 的事件，可以收到不同功能的回调。用于删除注册的同一类回调事件。
     *
     * Note: 业务场景：用于注销范围语音功能相关的业务事件的回调处理。
     *
     * Note: 调用时机：调用接口 createRangeAudioInstance 创建实例之后。
     *
     * Note: 注意事项：如果没有传要注销的回调方法，将会注销所有该事件的回调。
     *
     * @param event 监听事件名。
     * @param callBack 回调函数。
     *
     * @return 注销回调是否成功。
     */
    DataChannelListener.prototype.off = function (event, callBack) {
        this.deleteListener(event, callBack);
    };
    DataChannelListener.prototype.bindListener = function (listener, callBack) {
        if (!this.listenerList[listener]) {
            this.logger.error("dc.o.0 event " + listener + " no found");
            return false;
        }
        if (typeof callBack !== "function") {
            this.logger.error("zc.o.0 listener callBack must be funciton");
            return false;
        }
        this.listenerList[listener].indexOf(callBack) == -1 &&
            this.listenerList[listener].push(callBack);
        return true;
    };
    DataChannelListener.prototype.deleteListener = function (listener, callBack) {
        if (!this.listenerList[listener]) {
            this.logger.error("dc.o.1 listener no found");
            return false;
        }
        var li = this.listenerList[listener];
        if (callBack) {
            li.splice(li.indexOf(callBack), 1);
        }
        else {
            this.listenerList[listener] = [];
        }
        return true;
    };
    DataChannelListener.prototype.actionListener = function (listener) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.listenerList[listener] &&
            this.listenerList[listener].forEach(function (func) {
                try {
                    setTimeout(function () {
                        func.apply(void 0, args);
                    }, 0);
                }
                catch (error) {
                    _this.logger.error("dc.al" + " " + listener + " " + error);
                }
            });
    };
    DataChannelListener.prototype.onReceivedDataChannel = function (copy_buffer, copy_len, streamID) {
        this.actionListener("receiveRealTimeSequentialData", copy_buffer, copy_len, streamID);
    };
    DataChannelListener.prototype.reset = function () {
        var _this = this;
        this.logger.info("dc.rs " + "call");
        //停止所有广播
        this.pubDataChannelList.forEach(function (streamID) {
            var publish = _this.zegoWebRTC.streamCenter.publisherList[streamID];
            if (publish &&
                publish.room.roomID == _this.roomID &&
                publish.isDataChannel) {
                _this.zegoWebRTC.stopPublishingStream(streamID);
            }
        });
        //停止所有订阅
        this.subDataChannelList.forEach(function (streamID) {
            var play = _this.zegoWebRTC.streamCenter.playerList[streamID];
            if (play && play.room.roomID == _this.roomID && play.isDataChannel) {
                _this.zegoWebRTC.stopPlayingStream(streamID);
            }
        });
        for (var key in this.listenerList) {
            this.listenerList[key] = [];
        }
        this.broadcastStream && this.zegoWebRTC.destroyStream(this.broadcastStream);
        this.broadcastStream = undefined;
        this.logger.info("dc.rs " + "end");
    };
    return DataChannelListener;
}());
exports.DataChannelListener = DataChannelListener;


/***/ }),

/***/ "./sdk/src/modules/mixstream/content.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/mixstream/content.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// @ts-nocheck
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.streamHandler = exports.zegoWebRTC = void 0;
var error_1 = __webpack_require__(/*! ./error */ "./sdk/src/modules/mixstream/error.ts");
var logevent_1 = __webpack_require__(/*! ./logevent */ "./sdk/src/modules/mixstream/logevent.ts");
var PROTO_VERSION = "2.13.0";
var MAX_MIX_TASK_ID_LENGTH = 256;
var MIXSTREAM_ERROR_CODE = 10000;
var mixStreamAdvance = {};
var REPORT_ACTION = {
    eventStart: "eventStart",
    eventEndWithMsgInfo: "eventEndWithMsgInfo",
    addEventMsg: "addEventMsg",
    addEvent: "addEvent",
    eventEnd: "eventEnd",
    addMsgInfo: "addMsgInfo"
};
var MIXER_INPUT_PARAMETERS_ERROR = {
    code: 1005027,
    message: "mix stream input parameters are wrong"
};
//ClientUtil
function mixServerError(code) {
    // const mixServerErrorList: any = {
    //   82000001: "kMixStreamFailError",
    //   82000002: "kMixStreamInputError",
    //   82000003: "kMixStreamAuthError",
    //   82000150: "kMixStreamNotExistError",
    //   82000151: "kMixStreamStartMixError",
    //   82000152: "kMixStreamStopMixError",
    //   82000155: "kMixStreamInputFormatError",
    //   82000156: "kMixStreamOutputFormatError",
    //   82000157: "kMixStreamNotOpenError",
    //   82000158: "kMixStreamInputExceedError",
    //   82000159: "kMixStreamDispatchError",
    //   82000160: "kMixStreamStopMixOwnerError",
    //   82000170: "kMixStreamWaterMarkParamError",
    //   82000171: "kMixStreamWaterMarkImageError",
    //   82000190: "kMixStreamQpsOverloadError"
    // };
    var mixServerErrorMap = {
        1: "MIXER_START_REQUEST_ERROR",
        2: "MIXER_START_REQUEST_ERROR",
        3: "MIXER_AUTHENTICATION_FAILED",
        // 4: "MIXER_PARSE_PARAMS_ERROR",
        // 5: "MIXER_START_ACQUIRE_LOCK_ERROR",
        // 6: "MIXER_STOP_ACQUIRE_LOCK_ERROR",
        // 7: "MIXER_START_REQUEST_ERROR",
        // 8: "MIXER_START_CREATE_EOS_FAILED",
        // 9: "MIXER_START_SEND_EOS_FAILED",
        // 10: "MIXER_START_CALLBACK_ERROR",
        // 11: "MIXER_START_BYPASS_ERROR",
        // 12: "MIXER_CLOSE_OWNER_OTHER_STREAM_ERROR",
        // 13: "MIXER_UPDATE_OWNER_ERROR",
        // 14: "MIXER_",
        // 15: "MIXER_",
        // 16: "MIXER_",
        // 17: "MIXER_",
        150: "MIXER_INPUT_STREAM_NOT_EXISTS",
        151: "MIXER_START_REQUEST_ERROR",
        152: "MIXER_STOP_REQUEST_ERROR",
        153: "MIXER_INPUT_PARAMETERS_ERROR",
        154: "MIXER_EXCEED_MAX_OUTPUT_COUNT",
        155: "MIXER_INPUT_PARAMETERS_ERROR",
        156: "MIXER_VIDEO_CONFIG_INVALID",
        157: "MIXER_NO_SERVICES",
        158: "MIXER_EXCEED_MAX_INPUT_COUNT",
        159: "MIXER_START_REQUEST_ERROR",
        160: "MIXER_NOT_OWNER_STOPMIXER",
        170: "MIXER_WATERMARK_PARAMETERS_ERROR",
        171: "MIXER_WATERMARK_NULL",
        175: "MIXER_REPEAT_INPUT",
        190: "MIXER_START_REQUEST_ERROR"
    };
    var res = "MIXER_INNER_ERROR";
    if (code > 1000000000) {
        // const errcode = code - 1000000000 + 82000000;
        // if (mixServerErrorList[errcode]) {
        //   res[0] = mixServerErrorList[errcode];
        // } else {
        //   res[0] = "";
        // }
        if (mixServerErrorMap[code - 1000000000]) {
            res = mixServerErrorMap[code - 1000000000];
        }
    }
    return res;
}
function getMixMapError(stateCenter, err) {
    var reportErr;
    var externalErr = "";
    var codeMap = error_1.errorCodeList;
    if (err.errorCode < 2000000000 && err.errorCode > 1000000000) {
        // @ts-ignore
        // reportErr = errorList[errName];
        externalErr = mixServerError(err.errorCode - MIXSTREAM_ERROR_CODE);
        reportErr = codeMap[externalErr];
    }
    else if (err.errorCode < 1000000) {
        reportErr = stateCenter.decodeServerError(err.errorCode, err.extendedData);
        externalErr = stateCenter.getLiveRoomError(err.errorCode);
    }
    var actualError = codeMap[externalErr];
    return { reportErr: reportErr, actualError: actualError };
}
//ZegoWebRTC
exports.zegoWebRTC = {
    startMixerTask: function (mixStreamConfig) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var reportSeq = _this.stateCenter.getReportSeq();
            _this.dataReport.newReport(reportSeq, logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.event);
            _this.stateCenter.logReportCallback("kZegoTaskMixStart" + mixStreamConfig.taskID, _this.dataReport, reportSeq, _this.stateCenter.reportList);
            // 参数校验
            var paramsError = {
                errorCode: MIXER_INPUT_PARAMETERS_ERROR.code,
                extendedData: MIXER_INPUT_PARAMETERS_ERROR.message
            };
            var hasError = !!(mixStreamConfig === null || mixStreamConfig === void 0 ? void 0 : mixStreamConfig.inputList.find(function (item) {
                if (item.streamID === undefined || item.streamID === null) {
                    paramsError.extendedData =
                        paramsError.extendedData + ". streamID should be of string type";
                    return true;
                }
                return false;
            }));
            if (hasError) {
                _this.dataReport.addMsgInfo(reportSeq, paramsError);
                _this.dataReport.uploadReport(reportSeq);
                _this.stateCenter.unregisterCallback("kZegoTaskMixStart" + mixStreamConfig.taskID, _this.stateCenter.reportList);
                reject(paramsError);
                return;
            }
            if (mixStreamConfig.outputConfig &&
                mixStreamConfig.outputConfig.outputFps) {
                mixStreamConfig.outputConfig.outputFPS =
                    mixStreamConfig.outputConfig.outputFps;
            }
            var interResolve = function (res) {
                _this.dataReport.uploadReport(reportSeq);
                _this.stateCenter.unregisterCallback("kZegoTaskMixStart" + mixStreamConfig.taskID, _this.stateCenter.reportList);
                resolve(res);
            };
            var interReject = function (err) {
                var _a = getMixMapError(_this.stateCenter, err), reportErr = _a.reportErr, actualError = _a.actualError;
                if (reportErr) {
                    _this.dataReport.addMsgInfo(reportSeq, reportErr);
                }
                else {
                    _this.dataReport.addMsgInfo(reportSeq, err);
                }
                _this.dataReport.uploadReport(reportSeq);
                _this.stateCenter.unregisterCallback("kZegoTaskMixStart" + mixStreamConfig.taskID, _this.stateCenter.reportList);
                if (actualError) {
                    err.errorCode = actualError === null || actualError === void 0 ? void 0 : actualError.code;
                    err.extendedData = (actualError === null || actualError === void 0 ? void 0 : actualError.message) || "";
                }
                reject(err);
            };
            var room = _this.stateCenter.roomList[0];
            if (!room) {
                interReject({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kNoLoginError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kNoLoginError.message
                });
                return;
            }
            room.streamHandler.updateMixStream(mixStreamConfig, interResolve, interReject);
        });
    },
    setMixerTaskConfig: function (config) {
        var _this = this;
        return new Promise(function (res, rej) {
            var reportSeq = _this.stateCenter.getReportSeq();
            _this.dataReport.newReport(reportSeq, logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.event);
            _this.stateCenter.logReportCallback("kZegoTaskMixConfig", _this.dataReport, reportSeq, _this.stateCenter.reportList);
            var room = _this.stateCenter.roomList[0];
            if (!room) {
                rej({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error.kNoLoginError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error.kNoLoginError.message
                });
                return;
            }
            room.streamHandler
                .setMixerTaskConfig(config)
                .then(function (result) {
                _this.dataReport.uploadReport(reportSeq);
                _this.stateCenter.unregisterCallback("kZegoTaskMixConfig", _this.stateCenter.reportList);
                res(result);
            })
                .catch(function (err) {
                _this.dataReport.addMsgInfo(reportSeq, err);
                _this.dataReport.uploadReport(reportSeq);
                _this.stateCenter.unregisterCallback("kZegoTaskMixConfig", _this.stateCenter.reportList);
                rej(err);
            });
        });
    },
    stopMixerTask: function (taskId) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var reportSeq = _this.stateCenter.getReportSeq();
            _this.dataReport.newReport(reportSeq, logevent_1.ZegoRTCLogEvent.kZegoTaskMixStop.event);
            if (!taskId ||
                typeof taskId !== "string" ||
                taskId.length > MAX_MIX_TASK_ID_LENGTH ||
                !_this.stateCenter.checkIllegalCharacters(taskId)) {
                _this.logger.error("zb.rh.lg taskID must be string less 256");
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStop.error.kParamError.code,
                    message: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStop.error.kParamError.message +
                        " param taskID error"
                });
                _this.dataReport.uploadReport(reportSeq);
                reject({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStop.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStop.error.kParamError.message +
                        " param taskID error"
                });
                return;
            }
            var interResolve = function (res) {
                _this.dataReport.uploadReport(reportSeq);
                resolve(res);
            };
            var interReject = function (err) {
                var _a = getMixMapError(_this.stateCenter, err), reportErr = _a.reportErr, actualError = _a.actualError;
                if (reportErr) {
                    _this.dataReport.addMsgInfo(reportSeq, reportErr);
                }
                else {
                    _this.dataReport.addMsgInfo(reportSeq, err);
                }
                _this.dataReport.uploadReport(reportSeq);
                if (actualError) {
                    err.errorCode = actualError === null || actualError === void 0 ? void 0 : actualError.code;
                    err.extendedData = (actualError === null || actualError === void 0 ? void 0 : actualError.message) || "";
                }
                reject(err);
            };
            var room = _this.stateCenter.roomList[0];
            if (!room) {
                interReject({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStop.error.kNoLoginError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStop.error.kNoLoginError.message
                });
                return;
            }
            room.streamHandler.stopMixStream(taskId, interResolve, interReject);
        });
    }
};
//streamHandler
exports.streamHandler = {
    setMixerTaskConfig: function (advance) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var _a;
            var _mixStreamAdvance = {};
            var config = {};
            // if (
            //     advance &&
            //     advance.userData &&
            //     typeof advance.userData == 'string' &&
            //     (advance.userData as string).length <= 10000
            // ) {
            //     mixStreamAdvance.userData = advance.userData;
            // }
            if (advance && advance.videoCodec) {
                var videoc = advance.videoCodec.toLowerCase();
                if (["vp8", "h264"].indexOf(videoc) == -1) {
                    _this.logger.error("zb.sh.ums param videoCode error");
                    reject({
                        errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error
                            .kVideoConfigInvalidError.code,
                        extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error
                            .kVideoConfigInvalidError.message
                    });
                    return false;
                }
                //@ts-ignore
                _mixStreamAdvance.videoCodec = videoc;
                config["video_codec"] = videoc;
                // mixStreamAdvance.extraParams = [{ key: 'video_encode', value: advance.videoCodec }];
            }
            if (advance.backgroundColor) {
                // mixOutput["output_bg_color"] = mixStreamConfig.outputBgColor;
                if (!_this.stateCenter.checkInteger(advance.backgroundColor)) {
                    _this.logger.error("zb.sh.ums param backgroundColor must be integer number");
                    reject({
                        errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error.kParamError.code,
                        extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error.kParamError.message
                    });
                    return false;
                }
                _mixStreamAdvance.backgroundColor = advance.backgroundColor;
                config["background_color"] = advance.backgroundColor;
            }
            if (advance.backgroundImage) {
                // mixOutput["output_bg_image"] = mixStreamConfig.outputBgImage;
                if (typeof advance.backgroundImage !== "string") {
                    _this.logger.error("zb.sh.ums param outputBgImage error");
                    reject({
                        errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error.kParamError.code,
                        extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error.kParamError.message
                    });
                    return false;
                }
                if (!(advance.backgroundImage.startsWith("preset-id://") &&
                    (advance.backgroundImage.endsWith(".jpg") ||
                        advance.backgroundImage.endsWith(".png")))) {
                    _this.logger.error("zb.sh.ums illegal input background image URL");
                    reject({
                        errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error
                            .kBackgroundImageUrlInvalidError.code,
                        extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error
                            .kBackgroundImageUrlInvalidError.message
                    });
                    return false;
                }
                _mixStreamAdvance.backgroundImage = advance.backgroundImage;
                config["background_image"] = advance.backgroundImage;
            }
            if (advance.waterMark) {
                _mixStreamAdvance.waterMark = advance.waterMark;
                config["water_mark"] = advance.waterMark;
            }
            if (advance.extraParams) {
                if (!_mixStreamAdvance.extraParams)
                    _mixStreamAdvance.extraParams = [];
                (_a = _mixStreamAdvance.extraParams).push.apply(_a, advance.extraParams);
            }
            _mixStreamAdvance = mixStreamAdvance;
            _this.stateCenter.actionSuccessCallback("kZegoTaskMixConfig", _this.stateCenter.reportList) &&
                _this.stateCenter.actionSuccessCallback("kZegoTaskMixConfig", _this.stateCenter.reportList)(REPORT_ACTION.addMsgInfo, undefined, {
                    config: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.config(config)
                });
            resolve({ errorCode: 0, extendedData: "" });
        });
    },
    stopMixStream: function (taskid, successCallback, errorCallback, outputStreamId, outputUrl) {
        var _this = this;
        this.logger.info("zb.sh.sms call");
        // if (!taskid || typeof taskid !== 'string') {
        //     this.logger.error('zb.sh.sms taskid error');
        //     return false;
        // }
        var req_body = {
            id_name: this.stateCenter.idName,
            live_channel: this.roomID,
            appid: this.stateCenter.appid,
            version: PROTO_VERSION
        };
        if (typeof taskid === "string") {
            req_body["task_id"] = taskid;
        }
        if (outputStreamId != undefined) {
            if (this.stateCenter.testEnvironment) {
                req_body["stream_id"] =
                    "zegotest-" + this.stateCenter.appid + "-" + outputStreamId;
            }
            else {
                req_body["stream_id"] = outputStreamId;
            }
        }
        else if (outputUrl != undefined) {
            req_body["mixurl"] = outputUrl;
        }
        var useNetAgent = this.stateCenter.useNetAgent;
        if (!useNetAgent) {
            var body = {
                channel: "zeus",
                cmd: "stop_mix",
                req_body: JSON.stringify(req_body)
            };
            this.sendBizChannelRequest(body, function () {
                if (successCallback) {
                    successCallback({ errorCode: 0, extendedData: "" });
                }
            }, function (error) {
                if (typeof error == "number") {
                    if (errorCallback) {
                        errorCallback({
                            errorCode: _this.stateCenter.getServerError(MIXSTREAM_ERROR_CODE + error).code,
                            extendedData: ""
                        });
                    }
                }
                else {
                    _this.logger.error("zb.sh.sms stop mix fail " + JSON.stringify(error));
                    var _err = void 0;
                    if (error == error_1.errorCodeList.TIMEOUT) {
                        _err = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStop.error.kRequestError;
                    }
                    else {
                        _err = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStop.error.kInternalError;
                    }
                    if (errorCallback) {
                        errorCallback({
                            errorCode: _err.code,
                            extendedData: _err.message
                        });
                    }
                }
            });
        }
        else {
            this.sendBizChannelRequestV2({
                server: 12,
                location: "/interface/command",
                cmd: "stop_mix"
            }, req_body, function (rspBody) {
                if (successCallback) {
                    successCallback({ errorCode: 0, extendedData: "" });
                }
            }, function (httpCode, bizError, rspBody, errorCode) {
                var message = "";
                // 判断是否为SDK内部错误码
                if (errorCode) {
                    if (errorCode == error_1.errorCodeList.TIMEOUT) {
                        errorCode = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kRequestError;
                    }
                    errorCallback && errorCallback(errorCode, message);
                    return;
                }
                else {
                    errorCode = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kInternalError;
                }
                if (httpCode === 200) {
                    if (typeof bizError == "number") {
                        _this.logger.debug("zb.sh.sms error: " + bizError);
                        bizError = bizError + 1000000000; // 混流服务错误码加前缀
                        if (errorCallback) {
                            errorCallback({
                                errorCode: _this.stateCenter.getServerError(MIXSTREAM_ERROR_CODE + bizError).code,
                                extendedData: message
                            });
                        }
                        return;
                    }
                    else {
                        _this.logger.error("zb.sh.sms stop mix fail " + JSON.stringify(error));
                        var _err = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kInternalError;
                        if (errorCallback) {
                            errorCallback({
                                errorCode: _err.code,
                                extendedData: _err.message
                            });
                        }
                    }
                }
                else {
                    message = "request mix server fail, error: " + httpCode;
                    _this.logger.error("zb.sh.sms " + message);
                    errorCallback && errorCallback(errorCode, message);
                }
            });
        }
        return true;
    },
    updateMixStream: function (mixStreamConfig, successCallback, errorCallback) {
        var _a;
        var _this = this;
        this.logger.info("zb.sh.ums call");
        /***
         * 检查和处理混流传入配置参数
         */
        var allAudio = false;
        {
            if (!mixStreamConfig.noTaskID && !mixStreamConfig.taskID) {
                this.logger.error("zb.sh.ums no taskId found");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kTaskIDNullError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kTaskIDNullError.message
                });
                return false;
            }
            if (!mixStreamConfig.noTaskID &&
                typeof mixStreamConfig.taskID !== "string") {
                this.logger.error("zb.rh.lg taskId must be string");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.message
                });
                return false;
            }
            if (!mixStreamConfig.noTaskID &&
                mixStreamConfig.taskID.length > MAX_MIX_TASK_ID_LENGTH) {
                this.logger.error("zb.sh.ums taskId is too long");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kTaskIDToLongError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kTaskIDToLongError.message
                });
                return false;
            }
            if (!mixStreamConfig.noTaskID &&
                !this.stateCenter.checkIllegalCharacters(mixStreamConfig.taskID)) {
                this.logger.error("zb.sh.ums task ID contains illegal characters");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kTaskIDInvalidCharacterError
                        .code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kTaskIDInvalidCharacterError
                        .message
                });
                return false;
            }
            if (!mixStreamConfig.inputList || mixStreamConfig.inputList.length == 0) {
                this.logger.error("zb.sh.ums input list wrong");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kInputListNullError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kInputListNullError.message
                });
                return false;
            }
            // 纯音频内部指定参数
            mixStreamConfig.inputList.forEach(function (streamInfo) {
                if (streamInfo.contentType === "AUDIO") {
                    !streamInfo.layout &&
                        (streamInfo.layout = { top: 0, left: 0, bottom: 0, right: 0 });
                    streamInfo.layout.top = 0;
                    streamInfo.layout.left = 0;
                    streamInfo.layout.bottom = 1;
                    streamInfo.layout.right = 1;
                }
            });
            for (var i = 0; i < mixStreamConfig.inputList.length; i++) {
                var inputInfo = mixStreamConfig.inputList[i];
                var paramError = {
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.message
                };
                if (typeof inputInfo.layout !== "object") {
                    this.logger.error("zb.sh.ums input layout must be object");
                    errorCallback(paramError);
                    return false;
                }
                if (!this.stateCenter.checkInteger(inputInfo.layout.top, false) ||
                    !this.stateCenter.checkInteger(inputInfo.layout.bottom, false) ||
                    !this.stateCenter.checkInteger(inputInfo.layout.left, false) ||
                    !this.stateCenter.checkInteger(inputInfo.layout.right, false)) {
                    this.logger.error("zb.sh.ums top、left、bottom、right must be integer number");
                    errorCallback(paramError);
                    return false;
                }
                // 画面裁剪缩放设置参数校验
                if (inputInfo.renderMode !== undefined &&
                    ![0, 1].includes(inputInfo.renderMode)) {
                    this.logger.error("zb.sh.ums render_mode is wrong");
                    errorCallback(paramError);
                    return false;
                }
            }
            if (!mixStreamConfig.outputList ||
                mixStreamConfig.outputList.length == 0) {
                this.logger.error("zb.sh.ums no output list found");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kOutputListNullError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kOutputListNullError.message
                });
                return false;
            }
            if (mixStreamConfig.outputList.some(function (output) {
                return (typeof output === "string" &&
                    !_this.stateCenter.isUrl(output) &&
                    !_this.stateCenter.checkIllegalCharacters(output)) ||
                    (typeof output === "object" &&
                        output.target &&
                        !_this.stateCenter.isUrl(output.target) &&
                        !_this.stateCenter.checkIllegalCharacters(output.target));
            })) {
                this.logger.error("zb.sh.ums stream output target is incorrect");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kOutputTargetInvalidError
                        .code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kOutputTargetInvalidError
                        .message
                });
                return false;
            }
            allAudio = mixStreamConfig.inputList.every(function (input) { return input.contentType === "AUDIO"; });
            if (!allAudio &&
                (!mixStreamConfig.outputConfig ||
                    typeof mixStreamConfig.outputConfig !== "object")) {
                this.logger.error("zb.sh.ums no output config found");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kOutputNoTargetError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kOutputNoTargetError.message
                });
                return false;
            }
            if (allAudio) {
                // 纯音频重置output设置
                mixStreamConfig.outputConfig = __assign(__assign({}, (mixStreamConfig.outputConfig || {})), { outputBitrate: 0.001, outputFPS: 1, outputWidth: 1, outputHeight: 1 });
            }
            if (!allAudio &&
                (!mixStreamConfig.outputConfig.outputBitrate ||
                    !this.stateCenter.checkInteger(mixStreamConfig.outputConfig.outputBitrate))) {
                this.logger.error("zb.sh.ums bitrate param is required and must be integer number");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.message
                });
                return false;
            }
            if (!mixStreamConfig.outputConfig.outputFPS ||
                !this.stateCenter.checkInteger(mixStreamConfig.outputConfig.outputFPS)) {
                this.logger.error("zb.sh.ums fps param is required and must be integer number");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.message
                });
                return false;
            }
            if (!mixStreamConfig.outputConfig.outputWidth ||
                !this.stateCenter.checkInteger(mixStreamConfig.outputConfig.outputWidth)) {
                this.logger.error("zb.sh.ums width param is required and must be integer number");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.message
                });
                return false;
            }
            if (!mixStreamConfig.outputConfig.outputHeight ||
                !this.stateCenter.checkInteger(mixStreamConfig.outputConfig.outputHeight)) {
                this.logger.error("zb.sh.ums height param is required and must be integer number");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.message
                });
                return false;
            }
            if (mixStreamConfig.outputConfig.outputAudioCodecID !== undefined &&
                !this.stateCenter.checkInteger(mixStreamConfig.outputConfig.outputAudioCodecID, false)) {
                this.logger.error("zb.sh.ums AudioCodecID param must be integer number");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.message
                });
                return false;
            }
            if (mixStreamConfig.outputConfig.outputAudioBitrate !== undefined &&
                !this.stateCenter.checkInteger(mixStreamConfig.outputConfig.outputAudioBitrate)) {
                this.logger.error("zb.sh.ums AudioBitrate param must be integer number");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.message
                });
                return false;
            }
            if (mixStreamConfig.outputConfig.outputAudioChannels !== undefined &&
                !this.stateCenter.checkInteger(mixStreamConfig.outputConfig.outputAudioChannels, false)) {
                this.logger.error("zb.sh.ums AudioChannels param must be integer number");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.message
                });
                return false;
            }
        }
        /***
         * 处理混流接口请求参数
         */
        var req_body = {};
        {
            var _bypass = 0;
            if (
            // @ts-ignore 单流透传参数不对外
            mixStreamConfig.outputConfig.singleStreamPassThrough &&
                // @ts-ignore
                typeof mixStreamConfig.outputConfig.singleStreamPassThrough ===
                    "boolean") {
                // @ts-ignore
                _bypass = mixStreamConfig.outputConfig.singleStreamPassThrough ? 1 : 0;
            }
            req_body = {
                task_id: mixStreamConfig.taskID,
                id_name: this.stateCenter.idName,
                live_channel: this.roomID,
                appid: this.stateCenter.appid,
                version: PROTO_VERSION,
                bypass: _bypass,
                timestamp: Math.ceil(new Date().getTime() / 1000)
            };
            // 确认作用的字段 signature、timestamp、seq、is_cmd_mix
            // @ts-ignore
            var _advance_1 = mixStreamAdvance;
            if (_advance_1) {
                // if (_advance.userData) {
                //     req_body['UserData'] = _advance.userData;
                // }
                if (_advance_1.videoCodec) {
                    req_body["extra_params"] = [
                        { key: "video_encode", value: _advance_1.videoCodec }
                    ];
                }
                if (_advance_1.backgroundColor) {
                    req_body["output_bg_color"] = _advance_1.backgroundColor;
                }
                if (_advance_1.backgroundImage) {
                    req_body["output_bg_image"] = _advance_1.backgroundImage;
                }
                if (_advance_1.waterMark) {
                    req_body["watermark"] = _advance_1.waterMark;
                }
                if (_advance_1.extraParams) {
                    !req_body["extra_params"] && (req_body["extra_params"] = []);
                    (_a = req_body["extra_params"]).push.apply(_a, _advance_1.extraParams);
                }
            }
            // 处理输入列表参数格式
            req_body["MixInput"] = mixStreamConfig.inputList.map(function (item, index) {
                var totalStreamId = item.streamID;
                if (_this.stateCenter.testEnvironment) {
                    totalStreamId =
                        "zegotest-" + _this.stateCenter.appid + "-" + item.streamID;
                }
                return {
                    stream_id: totalStreamId,
                    content_control: item.contentType === "AUDIO" ? 1 : 0,
                    rect: {
                        layer: index,
                        top: item.layout.top,
                        left: item.layout.left,
                        bottom: item.layout.bottom,
                        right: item.layout.right
                    },
                    render_mode: item.renderMode
                };
            });
            this.stateCenter.actionSuccessCallback("kZegoTaskMixStart" + mixStreamConfig.taskID, this.stateCenter.reportList) &&
                this.stateCenter.actionSuccessCallback("kZegoTaskMixStart" + mixStreamConfig.taskID, this.stateCenter.reportList)(REPORT_ACTION.addMsgInfo, undefined, {
                    mix_stream_id: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.mix_stream_id(mixStreamConfig.taskID),
                    stream_cnt: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.stream_cnt(req_body["MixInput"].length),
                    input_stream_list: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.input_stream_list(req_body["MixInput"])
                });
            // 处理输出列表参数格式
            req_body["MixOutput"] = mixStreamConfig.outputList.map(function (item) {
                var outputStreamInfo = {};
                var _target = "";
                if (typeof item === "string") {
                    _target = item;
                }
                else if (typeof item === "object" && item["target"]) {
                    _target = item.target;
                }
                else {
                    _this.logger.error("zb.sh.ums output target required");
                    errorCallback({
                        errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kOutputTargetInvalidError
                            .code,
                        extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kOutputTargetInvalidError
                            .message
                    });
                    return false;
                }
                if (_target.startsWith("rtmp://") ||
                    (_target.startsWith("https://") && _target.endsWith(".flv")) ||
                    (_target.startsWith("https://") && _target.endsWith(".m3u8"))) {
                    outputStreamInfo["mixurl"] = _target;
                }
                else {
                    if (_this.stateCenter.testEnvironment) {
                        outputStreamInfo["stream_id"] =
                            "zegotest-" + _this.stateCenter.appid + "-" + _target;
                    }
                    else {
                        outputStreamInfo["stream_id"] = _target;
                    }
                }
                outputStreamInfo["bitrate"] =
                    mixStreamConfig.outputConfig.outputBitrate * 1000;
                outputStreamInfo["fps"] = mixStreamConfig.outputConfig.outputFPS;
                outputStreamInfo["width"] = mixStreamConfig.outputConfig.outputWidth;
                outputStreamInfo["height"] = mixStreamConfig.outputConfig.outputHeight;
                if (mixStreamConfig.outputConfig.outputAudioCodecID) {
                    outputStreamInfo["audio_enc_id"] =
                        mixStreamConfig.outputConfig.outputAudioCodecID;
                }
                if (_advance_1.videoCodec === "vp8") {
                    outputStreamInfo["audio_enc_id"] = 3;
                }
                else if (_advance_1.videoCodec === "h264") {
                    outputStreamInfo["audio_enc_id"] = 0;
                }
                if (mixStreamConfig.outputConfig.outputAudioBitrate) {
                    outputStreamInfo["audio_bitrate"] =
                        mixStreamConfig.outputConfig.outputAudioBitrate * 1000;
                }
                if (mixStreamConfig.outputConfig.outputAudioChannels) {
                    outputStreamInfo["audio_channel_cnt"] =
                        mixStreamConfig.outputConfig.outputAudioChannels;
                }
                if (_this.stateCenter.testEnvironment) {
                    outputStreamInfo["testenv"] = 1;
                }
                else {
                    outputStreamInfo["testenv"] = 0;
                }
                return outputStreamInfo;
            });
            this.stateCenter.actionSuccessCallback("kZegoTaskMixStart" + mixStreamConfig.taskID, this.stateCenter.reportList) &&
                this.stateCenter.actionSuccessCallback("kZegoTaskMixStart" + mixStreamConfig.taskID, this.stateCenter.reportList)(REPORT_ACTION.addMsgInfo, undefined, {
                    output_target_list: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.output_target_list(req_body["MixOutput"])
                });
        }
        this.logger.debug("zb.sh.ums send command");
        var useNetAgent = this.stateCenter.useNetAgent;
        var prefix = "zegotest-" + this.stateCenter.appid + "-";
        if (!useNetAgent) {
            var body = {
                channel: "zeus",
                cmd: "start_mix",
                req_body: JSON.stringify(req_body)
            };
            this.sendBizChannelRequest(body, function (seq, cmd, rspBody) {
                _this.logger.debug("zb.sh.ums receive message");
                if (rspBody.length == 0) {
                    if (errorCallback) {
                        errorCallback({
                            errorCode: _this.stateCenter.getServerError(MIXSTREAM_ERROR_CODE + 1).code,
                            extendedData: ""
                        });
                    }
                    return;
                }
                var data = JSON.parse(rspBody);
                var mixPlayInfoList = [];
                for (var i = 0; i < data.play.length; i++) {
                    var mixPlayInfo = {
                        rtmpURL: "",
                        hlsURL: "",
                        flvURL: ""
                    };
                    var streamID = data.play[i].stream_alias || "";
                    if (_this.stateCenter.testEnvironment &&
                        streamID &&
                        streamID.startsWith(prefix)) {
                        streamID = streamID.slice(prefix.length);
                    }
                    mixPlayInfo["streamID"] = streamID;
                    if (data.play[i].rtmp_url && data.play[i].rtmp_url.length > 0) {
                        mixPlayInfo.rtmpURL = data.play[i].rtmp_url;
                    }
                    if (data.play[i].hls_url && data.play[i].hls_url.length > 0) {
                        mixPlayInfo["hlsURL"] = data.play[i].hls_url;
                    }
                    if (data.play[i].hdl_url && data.play[i].hdl_url.length > 0) {
                        mixPlayInfo["flvURL"] = data.play[i].hdl_url;
                    }
                    mixPlayInfoList.push(mixPlayInfo);
                }
                if (successCallback) {
                    var mixs = { mixerOutputList: mixPlayInfoList };
                    successCallback({
                        errorCode: 0,
                        extendedData: JSON.stringify(mixs)
                    });
                    // successCallback({ errorCode: 0 ,extendedData: ''})
                }
            }, function (error, seq, rspBody) {
                if (typeof error == "number") {
                    _this.logger.debug("zb.sh.ums error: " + error);
                    var nonExistsStreamId = [];
                    if (error == 1000000150 && rspBody.length != 0) {
                        //no stream list
                        var data = JSON.parse(rspBody);
                        for (var i = 0; i < data.non_exist_streams.length; i++) {
                            var totalStreamId = data.non_exist_streams[i];
                            if (_this.stateCenter.testEnvironment &&
                                totalStreamId.startsWith(prefix)) {
                                nonExistsStreamId.push(totalStreamId.slice(prefix.length));
                            }
                            else {
                                nonExistsStreamId.push(totalStreamId);
                            }
                        }
                    }
                    if (errorCallback) {
                        errorCallback({
                            errorCode: _this.stateCenter.getServerError(MIXSTREAM_ERROR_CODE + error).code,
                            extendedData: ""
                        });
                    }
                }
                else {
                    _this.logger.debug("zb.sh.ums error code " + error.code);
                    var _err = void 0;
                    if (error == error_1.errorCodeList.TIMEOUT) {
                        _err = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kRequestError;
                    }
                    else {
                        _err = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kInternalError;
                    }
                    if (errorCallback) {
                        errorCallback({
                            errorCode: _err.code,
                            extendedData: _err.message
                        });
                    }
                }
            });
        }
        else {
            this.sendBizChannelRequestV2({
                server: 12,
                location: "/interface/command",
                cmd: "start_mix"
            }, req_body, function (rspBody) {
                var data = rspBody;
                var mixPlayInfoList = data.play.map(function (item) {
                    var mixPlayInfo = {
                        rtmpURL: "",
                        hlsURL: "",
                        flvURL: ""
                    };
                    var streamID = item.stream_alias || "";
                    if (_this.stateCenter.testEnvironment &&
                        streamID &&
                        streamID.startsWith(prefix)) {
                        streamID = streamID.slice(prefix.length);
                    }
                    mixPlayInfo["streamID"] = streamID;
                    if (item.rtmp_url && item.rtmp_url.length > 0) {
                        mixPlayInfo.rtmpURL = item.rtmp_url;
                    }
                    if (item.hls_url && item.hls_url.length > 0) {
                        mixPlayInfo["hlsURL"] = item.hls_url;
                    }
                    if (item.hdl_url && item.hdl_url.length > 0) {
                        mixPlayInfo["flvURL"] = item.hdl_url;
                    }
                    return mixPlayInfo;
                });
                if (successCallback) {
                    var mixs = { mixerOutputList: mixPlayInfoList };
                    successCallback({
                        errorCode: 0,
                        extendedData: JSON.stringify(mixs)
                    });
                }
            }, function (httpCode, bizError, rspBody, errorCode) {
                var message = "";
                // 判断是否为SDK内部错误码
                if (errorCode) {
                    if (errorCode == error_1.errorCodeList.TIMEOUT) {
                        errorCode = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kRequestError;
                    }
                    errorCallback && errorCallback(errorCode, message);
                }
                else {
                    errorCode = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kInternalError;
                }
                if (httpCode === 200) {
                    if (typeof bizError == "number") {
                        _this.logger.debug("zb.sh.ums error: " + bizError);
                        bizError = bizError + 1000000000; // 混流服务错误码加前缀
                        if (bizError == 1000000150 && rspBody) {
                            var data = rspBody;
                            var nonExistsStreamId = (data === null || data === void 0 ? void 0 : data.non_exist_streams.map(function (item) {
                                if (_this.stateCenter.testEnvironment &&
                                    item.startsWith(prefix)) {
                                    return item.slice(prefix.length);
                                }
                                else {
                                    return item;
                                }
                            })) || [];
                            nonExistsStreamId.length > 0 &&
                                (_this.logger.debug("zb.sh.ums not exist streams: " + nonExistsStreamId),
                                    (message = nonExistsStreamId.join(",")));
                        }
                        if (errorCallback) {
                            errorCallback({
                                errorCode: _this.stateCenter.getServerError(MIXSTREAM_ERROR_CODE + bizError).code,
                                extendedData: message
                            });
                        }
                        return;
                    }
                    else {
                        _this.logger.debug("zb.sh.ums error code " + bizError);
                        var _err = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kInternalError;
                        if (errorCallback) {
                            errorCallback({
                                errorCode: _err.code,
                                extendedData: _err.message
                            });
                        }
                    }
                }
                else {
                    message = "request mix server fail, error: " + httpCode;
                    _this.logger.error("zb.sh.ums " + message);
                    errorCallback && errorCallback(errorCode, message);
                }
                // } else {
                //TODO: 接口超时处理，联调时看是否需要
                //   this.logger.debug("zb.sh.ums error code " + error.code);
                //   let _err;
                //   if (error == errorCodeList.TIMEOUT) {
                //     _err = ZegoRTCLogEvent.kZegoTaskMixStart.error.kRequestError;
                //   } else {
                //     _err = ZegoRTCLogEvent.kZegoTaskMixStart.error.kInternalError;
                //   }
                //   if (errorCallback) {
                //     errorCallback({
                //       errorCode: _err.code,
                //       extendedData: _err.message
                //     });
                //   }
                // }
            });
        }
        return true;
    }
};


/***/ }),

/***/ "./sdk/src/modules/mixstream/error.ts":
/*!********************************************!*\
  !*** ./sdk/src/modules/mixstream/error.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorCodeList = void 0;
exports.errorCodeList = {
    NOT_LOGIN: {
        code: 1000002,
        message: "not login room"
    },
    INPUT_PARAM: {
        code: 1100001,
        message: "input param error."
    },
    TIMEOUT: {
        code: 1100002,
        message: "network timeout."
    },
    // mixStreamErr
    MIXER_NO_SERVICES: {
        code: 1005000,
        message: "no mix stream service"
    },
    MIXER_TASK_ID_NULL: {
        code: 1005001,
        message: "mixer task is null"
    },
    MIXER_TASK_ID_TOO_LONG: {
        code: 1005002,
        message: "task ID is too long"
    },
    MIXER_TASK_ID_INVALID_CHARACTER: {
        code: 1005003,
        message: "task ID contains illegal characters"
    },
    MIXER_NO_OUTPUT_TARGET: {
        code: 1005005,
        message: "task configuration does not specify output"
    },
    MIXER_OUTPUT_TARGET_INVALID: {
        code: 1005006,
        message: "stream output target is incorrect"
    },
    MIXER_START_REQUEST_ERROR: {
        code: 1005010,
        message: "start mixer task fail, possibly due to network reasons"
    },
    MIXER_STOP_REQUEST_ERROR: {
        code: 1005011,
        message: "stop mixer task fail, possibly due to network reasons"
    },
    MIXER_NOT_OWNER_STOP_MIXER: {
        code: 1005012,
        message: " maxed task must be stopped by the start user of the task"
    },
    MIXER_INPUTLIST_NULL: {
        code: 1005020,
        message: "Mixed stream task input list is null"
    },
    MIXER_OUTPUTLIST_NULL: {
        code: 1005021,
        message: "Mixed stream task output list is null"
    },
    MIXER_VIDEO_CONFIG_INVALID: {
        code: 1005023,
        message: "invalid mixed stream task video configuration"
    },
    MIXER_EXCEED_MAX_INPUT_COUNT: {
        code: 1005025,
        message: "more than the maximum number of input streams"
    },
    MIXER_INPUT_STREAM_NOT_EXISTS: {
        code: 1005026,
        message: "Input stream does not exist"
    },
    MIXER_EXCEED_MAX_OUTPUT_COUNT: {
        code: 1005030,
        message: "more than the maximum number of output streams"
    },
    MIXER_AUTHENTICATION_FAILED: {
        code: 1005050,
        message: "mixed stream authentication failed"
    },
    MIXER_WATERMARK_NULL: {
        code: 1005061,
        mag: "input watermark is null"
    },
    MIXER_WATERMARK_PARAMETERS_ERROR: {
        code: 1005062,
        message: "input watermark parameter is wrong"
    },
    MIXER_WATERMARK_URL_INVALID: {
        code: 1005063,
        message: "illegal input watermark URL"
    },
    MIXER_BACKGROUND_IMAGE_URL_INVALID: {
        code: 1005067,
        message: "illegal input background image URL"
    },
    MIXER_REPEAT_INPUT: {
        code: 1005099,
        message: "mix stream input repeat"
    },
    MIXER_INNER_ERROR: {
        code: 1005099,
        message: "mixer internal error"
    }
};


/***/ }),

/***/ "./sdk/src/modules/mixstream/index.ts":
/*!********************************************!*\
  !*** ./sdk/src/modules/mixstream/index.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//@ts-nocheck
var content_1 = __webpack_require__(/*! ./content */ "./sdk/src/modules/mixstream/content.ts");
exports["default"] = {
    type: "MixStream",
    install: function (RTC, SH) {
        //ZegoWebRTC
        for (var key in content_1.zegoWebRTC) {
            Object.defineProperty(RTC.prototype, key, {
                value: content_1.zegoWebRTC[key],
                writable: false
            });
        }
        //streamHandler
        for (var key in content_1.streamHandler) {
            Object.defineProperty(SH.prototype, key, {
                value: content_1.streamHandler[key],
                writable: false
            });
        }
    }
};


/***/ }),

/***/ "./sdk/src/modules/mixstream/logevent.ts":
/*!***********************************************!*\
  !*** ./sdk/src/modules/mixstream/logevent.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoRTCLogEvent = void 0;
var error_1 = __webpack_require__(/*! ./error */ "./sdk/src/modules/mixstream/error.ts");
var getItem = function (item) { return item; };
exports.ZegoRTCLogEvent = {
    kZegoTaskMixStart: {
        event: "/mix/start_mix",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM,
            kTaskIDNullError: error_1.errorCodeList.MIXER_TASK_ID_NULL,
            kTaskIDToLongError: error_1.errorCodeList.MIXER_TASK_ID_TOO_LONG,
            kTaskIDInvalidCharacterError: error_1.errorCodeList.MIXER_TASK_ID_INVALID_CHARACTER,
            kInputListNullError: error_1.errorCodeList.MIXER_INPUTLIST_NULL,
            kOutputListNullError: error_1.errorCodeList.MIXER_OUTPUTLIST_NULL,
            kOutputTargetInvalidError: error_1.errorCodeList.MIXER_OUTPUT_TARGET_INVALID,
            kOutputNoTargetError: error_1.errorCodeList.MIXER_NO_OUTPUT_TARGET,
            kRequestError: error_1.errorCodeList.MIXER_START_REQUEST_ERROR,
            kInternalError: error_1.errorCodeList.MIXER_INNER_ERROR,
            kNoLoginError: error_1.errorCodeList.NOT_LOGIN
        },
        mix_stream_id: getItem,
        stream_cnt: getItem,
        input_stream_list: getItem,
        output_target_list: getItem
    },
    kZegoTaskMixStop: {
        event: "/mix/stop_mix",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM,
            kTaskIDNullError: error_1.errorCodeList.MIXER_TASK_ID_NULL,
            kRequestError: error_1.errorCodeList.MIXER_STOP_REQUEST_ERROR,
            kInternalError: error_1.errorCodeList.MIXER_INNER_ERROR,
            kNoLoginError: error_1.errorCodeList.NOT_LOGIN
        }
    },
    kZegoTaskMixConfig: {
        event: "/mix/config_mix",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM,
            kVideoConfigInvalidError: error_1.errorCodeList.MIXER_VIDEO_CONFIG_INVALID,
            kBackgroundImageUrlInvalidError: error_1.errorCodeList.MIXER_BACKGROUND_IMAGE_URL_INVALID,
            kNoLoginError: error_1.errorCodeList.NOT_LOGIN
        },
        config: getItem
    }
};


/***/ }),

/***/ "./sdk/src/modules/rangeaudio/ZegoAudioListener.ts":
/*!*********************************************************!*\
  !*** ./sdk/src/modules/rangeaudio/ZegoAudioListener.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var AudioSource_1 = __importDefault(__webpack_require__(/*! ./modules/AudioSource */ "./sdk/src/modules/rangeaudio/modules/AudioSource.ts"));
var RangeListener_1 = __importDefault(__webpack_require__(/*! ./modules/RangeListener */ "./sdk/src/modules/rangeaudio/modules/RangeListener.ts"));
var PlayStreamHandler_1 = __importDefault(__webpack_require__(/*! ./modules/PlayStreamHandler */ "./sdk/src/modules/rangeaudio/modules/PlayStreamHandler.ts"));
var EventManager_1 = __importDefault(__webpack_require__(/*! ./modules/EventManager */ "./sdk/src/modules/rangeaudio/modules/EventManager.ts"));
var checkParam_1 = __webpack_require__(/*! ./utils/checkParam */ "./sdk/src/modules/rangeaudio/utils/checkParam.ts");
var ZegoExpressEntity_web_1 = __webpack_require__(/*! ../../../code/zh/ZegoExpressEntity.web */ "./sdk/code/zh/ZegoExpressEntity.web.ts");
var ZegoAudioListener = /** @class */ (function () {
    function ZegoAudioListener(zegoRTC) {
        var _this = this;
        // 是否开启立体声
        this.isSpatial = false;
        // 音源列表(无论是否在推流都保存在该列表中)
        this.audioSourceList = [];
        // 音源列表(只有在推流中的音源)
        this.speakingUserIdList = [];
        this._audioCtx = null;
        this.zegoRTC = zegoRTC;
        // 获取房间内正在推流的音源
        this.zegoRTC.on("roomStreamUpdate", function (roomID, updateType, streamList) {
            var changeIdList = streamList.map(function (item) { return item.streamID; });
            if (updateType === "DELETE") {
                // 将停推的流进行停止拉流
                _this.speakingUserIdList = _this.speakingUserIdList.filter(function (item) {
                    var isSpeaking = !changeIdList.includes(item);
                    if (!isSpeaking) {
                        var audioSource = _this.audioSourceMap[item];
                        if (audioSource && audioSource.isPlaying) {
                            audioSource.stopPlayingAudio();
                        }
                    }
                    return isSpeaking;
                });
            }
            else if (updateType === "ADD") {
                _this.speakingUserIdList = _this.speakingUserIdList.concat(changeIdList);
                // 添加音源
                streamList.forEach(function (item) {
                    if (!_this.audioSourceMap[item.streamID]) {
                        var _a = _this.getStreamInfo(item.extraInfo), teamID = _a.teamID, sendMode = _a.sendMode;
                        var audioSource = new AudioSource_1.default({
                            userID: item.streamID,
                            teamID: teamID,
                            sendMode: sendMode
                        }, {
                            audioCtx: _this.audioCtx,
                            zegoRTC: _this.zegoRTC,
                            isSpatial: _this.isSpatial,
                            maxDistance: _this.rangeListener.recvRange
                        });
                        _this.audioSourceList.push(audioSource);
                        _this.playStreamHandler.handlePlayAudioTask();
                    }
                });
            }
            // console.log("获取房间内正在推流的音源", this.speakingUserIdList);
            _this.playStreamHandler.setAudioSourceList(_this.speakingAudioSourceList);
        });
        // 获取房间内正在被拉流的音源
        this.zegoRTC.on("playerStateUpdate", function (result) {
            var audioSource = _this.audioSourceMap[result.streamID];
            if (audioSource) {
                // 标记音源是否在拉流中
                if (result.state === "NO_PLAY") {
                    audioSource.isPlaying = false;
                }
                else {
                    audioSource.isPlaying = true;
                }
            }
        });
        // 获取房间内的流附加信息
        this.zegoRTC.on("streamExtraInfoUpdate", function (roomID, streamList) {
            streamList.forEach(function (item) {
                var audioSource = _this.audioSourceMap[item.streamID];
                if (audioSource) {
                    var _a = _this.getStreamInfo(item.extraInfo), teamID = _a.teamID, sendMode = _a.sendMode;
                    if (teamID !== audioSource.teamID) {
                        audioSource.teamID = teamID;
                        // 更新 3D 音效
                        _this.enableSpatializer(_this.isSpatial);
                    }
                    if (sendMode !== undefined) {
                        audioSource.sendMode = sendMode;
                    }
                    _this.playStreamHandler.handlePlayAudioTask();
                }
            });
        });
        // 获取房间登录状态
        this.zegoRTC.RTM._on("_roomStateUpdate", function (roomID, state) {
            if (state === "CONNECTED") {
                _this.roomID = roomID;
                _this.rangeListener.userID = _this.zegoRTC.RTM.getUserID();
            }
            else if (state === "DISCONNECTED") {
                // 重置房间
                _this.roomID = undefined;
                _this.rangeListener.reset();
                _this.audioSourceList = [];
            }
        });
        var AudioContext = window.AudioContext || window.webkitAudioContext;
        this._audioCtx = (this.zegoRTC && this.zegoRTC.ac) || new AudioContext();
        this.rangeListener = RangeListener_1.default.getInstance(this.audioCtx, this.zegoRTC);
        this.playStreamHandler = PlayStreamHandler_1.default.getInstance(this.rangeListener);
        this.eventManager = EventManager_1.default.getInstance();
    }
    Object.defineProperty(ZegoAudioListener.prototype, "audioSourceMap", {
        get: function () {
            return this.audioSourceList.reduce(function (result, item) {
                if (item.userID) {
                    result[item.userID] = item;
                }
                return result;
            }, {});
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ZegoAudioListener.prototype, "speakingAudioSourceList", {
        get: function () {
            var _this = this;
            return this.audioSourceList.filter(function (item) {
                if (!_this.speakingUserIdList.includes(item.userID)) {
                    return false;
                }
                return true;
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ZegoAudioListener.prototype, "playingAudioSourceList", {
        get: function () {
            return this.audioSourceList.filter(function (item) { return item.isPlaying; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ZegoAudioListener.prototype, "audioCtx", {
        get: function () {
            if (!this._audioCtx) {
                var AudioContext_1 = window.AudioContext || window.webkitAudioContext;
                this._audioCtx = new AudioContext_1();
            }
            return this._audioCtx;
        },
        enumerable: false,
        configurable: true
    });
    ZegoAudioListener.getInstance = function (zegoRTC) {
        if (!ZegoAudioListener.instance) {
            ZegoAudioListener.instance = new ZegoAudioListener(zegoRTC);
        }
        return ZegoAudioListener.instance;
    };
    ZegoAudioListener.prototype.resumeAudioContext = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) {
                        _this.audioCtx.onstatechange = function () {
                            if (_this.audioCtx.state === "running") {
                                resolve(true);
                            }
                        };
                        _this.audioCtx.suspend();
                        _this.audioCtx.resume();
                        setTimeout(function () {
                            resolve(false);
                        }, 3000);
                    })];
            });
        });
    };
    ZegoAudioListener.prototype.getAudioContextState = function () {
        return this.audioCtx.state;
    };
    ZegoAudioListener.prototype.getStreamInfo = function (extraInfoStr) {
        var teamID = undefined, sendMode = undefined;
        try {
            var extraInfo = JSON.parse(extraInfoStr);
            teamID = extraInfo.range_audio_team_id;
            if ([ZegoExpressEntity_web_1.ZegoRangeAudioMode.World, ZegoExpressEntity_web_1.ZegoRangeAudioMode.Team].includes(extraInfo.range_audio_mode)) {
                sendMode = extraInfo.range_audio_mode;
            }
        }
        catch (error) { }
        // console.log("获取流附加信息", extraInfoStr, teamID, sendMode);
        return {
            teamID: teamID,
            sendMode: sendMode
        };
    };
    // loginRoom(roomID: string, token: string, user: ZegoUser): any {
    //   this.rangeListener.userID = user.userID;
    //   // return this.zegoRTC.loginRoom(roomID, token, user);
    // }
    // logoutRoom(): void {
    //   this.zegoRTC.off("roomStreamUpdate");
    //   this.zegoRTC.off("playerStateUpdate");
    //   if (this.rangeListener.audioStream) {
    //     // 关闭麦克风流
    //     this.zegoRTC.destroyStream(this.rangeListener.audioStream);
    //   }
    //   // this.zegoRTC.logoutRoom(this.roomID);
    //   // 重置房间
    //   this.rangeListener.userID = undefined;
    //   this.audioSourceList = [];
    // }
    ZegoAudioListener.prototype.setAudioReceiveRange = function (range) {
        if (!checkParam_1.checkNumber(range)) {
            throw Error("Failed to execute 'setAudioReceiveRange': Argument 'range' requires to be type number.");
        }
        // 参数最小值校验
        range = Number(range);
        if (range < 0) {
            throw Error("Failed to execute 'setAudioReceiveRange': Argument 'range' can not be less than 0.");
        }
        this.rangeListener.recvRange = range;
        this.audioSourceList.forEach(function (item) {
            item.setMaxDistance(range);
        });
    };
    ZegoAudioListener.prototype.updateSelfPosition = function (position, axisForward, axisRight, axisUp) {
        // 参数校验
        var getErrorMsg = function (errorKey) {
            return "Failed to execute 'updateSelfPosition': Argument '" + errorKey + "' requires an array of type number.\"";
        };
        if (!checkParam_1.checkCoordinate(position)) {
            throw new Error(getErrorMsg("position"));
        }
        if (!checkParam_1.checkCoordinate(axisForward)) {
            throw new Error(getErrorMsg("axisForward"));
        }
        if (!checkParam_1.checkCoordinate(axisRight)) {
            throw new Error(getErrorMsg("axisRight"));
        }
        if (!checkParam_1.checkCoordinate(axisUp)) {
            throw new Error(getErrorMsg("axisUp"));
        }
        if (this.rangeListener) {
            this.rangeListener.updateSelfPosition(position, axisForward, axisUp);
        }
        this.playStreamHandler.setListener(this.rangeListener);
    };
    ZegoAudioListener.prototype.updateAudioSource = function (userID, position) {
        // 参数校验
        userID = String(userID);
        if (!checkParam_1.checkCoordinate(position)) {
            throw new Error("Failed to execute 'updateAudioSource': Arguments 'position' must be an array of type number.");
        }
        var audioSource = this.audioSourceMap[userID];
        if (audioSource) {
            audioSource.setPosition(position);
        }
        else {
            audioSource = new AudioSource_1.default({
                userID: userID,
                position: position
            }, {
                audioCtx: this.audioCtx,
                zegoRTC: this.zegoRTC,
                isSpatial: this.isSpatial,
                maxDistance: this.rangeListener.recvRange
            });
            this.enableSpatializer(this.isSpatial);
            this.audioSourceList.push(audioSource);
        }
        this.playStreamHandler.setAudioSourceList(this.speakingAudioSourceList);
    };
    ZegoAudioListener.prototype.enableMicrophone = function (enable) {
        if (enable === void 0) { enable = true; }
        if (!this.rangeListener.userID) {
            throw new Error("Enable mic failed. Please log in room first.");
        }
        if (enable) {
            return this.rangeListener.startPublishingStream();
        }
        else {
            return this.rangeListener.stopPublishingStream();
        }
    };
    ZegoAudioListener.prototype.enableSpeaker = function (enable) {
        if (enable === void 0) { enable = true; }
        if (!this.roomID) {
            throw new Error("Enable speaker failed. Please log in room first.");
        }
        this.playStreamHandler.isEnable = enable;
        if (enable) {
            this.playStreamHandler.startPlayingAudioStream();
            this.playStreamHandler.handlePlayAudioTask();
        }
        else {
            this.playStreamHandler.stopPlayingAudioStream();
        }
    };
    ZegoAudioListener.prototype.enableSpatializer = function (enable) {
        var _this = this;
        if (enable === void 0) { enable = true; }
        this.isSpatial = !!enable;
        this.audioSourceList.forEach(function (item) {
            // 判断是否为同队，如果是同队关闭3D音效
            var isSpatial = ![item.teamID, _this.rangeListener.teamID].includes(undefined) &&
                _this.rangeListener.teamID === item.teamID
                ? false
                : enable;
            item.enableSpatializer(isSpatial);
        });
        if (enable) {
            this.rangeListener.updateListenerEffect();
        }
    };
    ZegoAudioListener.prototype.setRangeAudioTeamID = function (teamID) {
        // console.log("setRangeAudioTeamID", teamID);
        this.rangeListener.setTeamID(teamID);
        // 更新3D音效
        this.enableSpatializer(this.isSpatial);
        this.playStreamHandler.handlePlayAudioTask();
    };
    ZegoAudioListener.prototype.setRangeAudioMode = function (mode) {
        // console.log("setRangeAudioMode", mode);
        this.rangeListener.setSendMode(mode);
        this.rangeListener.setRecvMode(mode);
        this.playStreamHandler.handlePlayAudioTask();
    };
    ZegoAudioListener.prototype.on = function (event, callBack) {
        return this.eventManager.addEventHandler(event, callBack);
    };
    ZegoAudioListener.prototype.off = function (event, callBack) {
        return this.eventManager.removeEventHandler(event, callBack);
    };
    return ZegoAudioListener;
}());
exports["default"] = ZegoAudioListener;


/***/ }),

/***/ "./sdk/src/modules/rangeaudio/index.ts":
/*!*********************************************!*\
  !*** ./sdk/src/modules/rangeaudio/index.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RangeAudio = void 0;
var ZegoExpressRangeAudio_web_1 = __webpack_require__(/*! ../../../code/zh/ZegoExpressRangeAudio.web */ "./sdk/code/zh/ZegoExpressRangeAudio.web.ts");
exports.RangeAudio = {
    type: "RangeAudio",
    install: function (ZegoWebRTC) {
        Object.defineProperty(ZegoWebRTC.prototype, "createRangeAudioInstance", {
            value: function () {
                if (!this.rangeAudio) {
                    this.rangeAudio = ZegoExpressRangeAudio_web_1.ZegoExpressRangeAudio.getInstance(this);
                }
                return this.rangeAudio;
            },
            writable: false
        });
    }
};


/***/ }),

/***/ "./sdk/src/modules/rangeaudio/modules/AudioSource.ts":
/*!***********************************************************!*\
  !*** ./sdk/src/modules/rangeaudio/modules/AudioSource.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ZegoExpressEntity_web_1 = __webpack_require__(/*! ../../../../code/zh/ZegoExpressEntity.web */ "./sdk/code/zh/ZegoExpressEntity.web.ts");
var AudioSource = /** @class */ (function () {
    function AudioSource(userInfo, config) {
        this.panner = null;
        this.isSpatial = false;
        this.autoPlay = true;
        this.position = null;
        this.stream = null;
        this.sourceNode = null;
        this.isPlaying = false;
        this.distance = null;
        this.audioCtx = config.audioCtx;
        this.zegoRTC = config.zegoRTC;
        this.isSpatial = config.isSpatial;
        this.maxDistance = config.maxDistance || 100000;
        this.userID = userInfo.userID;
        this.teamID = userInfo.teamID;
        this.sendMode =
            userInfo.sendMode !== undefined
                ? userInfo.sendMode
                : ZegoExpressEntity_web_1.ZegoRangeAudioMode.World;
        if (userInfo.position) {
            this.position = userInfo.position;
        }
    }
    Object.defineProperty(AudioSource.prototype, "audioWrapper", {
        get: function () {
            var audioWrap = document.getElementById("#zg-audio-source-wrapper");
            if (!audioWrap) {
                audioWrap = document.createElement("div");
                audioWrap.setAttribute("id", "zg-audio-source-wrapper");
                document.body.appendChild(audioWrap);
            }
            return audioWrap;
        },
        enumerable: false,
        configurable: true
    });
    AudioSource.prototype.createPanner = function () {
        // 设置默认定位
        var defaultPosition = this.position || [0, 0, 0];
        // 变化模式
        var pannerModel = "HRTF";
        // 下一个参数是 distanceModel — 这只能设置为 linear, inverse, 或者 exponential。这些是不同的算法，用于在音频源远离收听者时减小音频源的音量。
        var distanceModel = "linear";
        // 设置源和收听者之间的最大距离 (maxDistance)  — 如果源距离此点更远，则音量将不再减小。这可能很有用，因为你可能会发现你想要模拟距离，但是音量会下降，而实际上并不是你想要的。默认情况下，它是10,000（无单位的相对值）
        var maxDistance = this.maxDistance;
        // 参考距离 (refDistance)，由距离模型使用。我们也可以将其保持为默认值 1
        var refDistance = 1;
        // roll-off 因子 (rolloffFactor) — 描述随着panner远离收听者，音量减小的速度有多快。默认值为1；让我们使其大一些以放大我们的动作。
        var rollOff = 1;
        // 外部增益
        var outerGain = 0.4;
        // 使用相关的构造函数来创建我们的panner节点作为3D音效控制器，并传入我们在上面设置的所有参数：
        return new PannerNode(this.audioCtx, {
            panningModel: pannerModel,
            distanceModel: distanceModel,
            refDistance: refDistance,
            maxDistance: maxDistance,
            rolloffFactor: rollOff,
            coneOuterGain: outerGain,
            positionX: defaultPosition[1],
            positionY: defaultPosition[0],
            positionZ: -defaultPosition[0]
        });
    };
    AudioSource.prototype.startPlayingAudio = function () {
        return __awaiter(this, void 0, void 0, function () {
            var audioEl, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        audioEl = document.getElementById("zg-audio-source-" + this.userID);
                        if (!!audioEl) return [3 /*break*/, 2];
                        audioEl = document.createElement("audio");
                        audioEl.setAttribute("autoplay", "autoplay");
                        audioEl.setAttribute("id", "zg-audio-source-" + this.userID);
                        audioEl.setAttribute("crossorigin", "anonymous");
                        _a = this;
                        return [4 /*yield*/, this.zegoRTC.startPlayingStream(this.userID)];
                    case 1:
                        _a.stream = _b.sent();
                        // console.log("开始拉流", this.userID);
                        // 非必要参数
                        // audioEl.setAttribute(
                        //   "src",
                        //   "https://zego-public.oss-cn-shanghai.aliyuncs.com/sdk-doc/assets/bike.mp3"
                        // );
                        // audioEl.setAttribute("controls", "controls");
                        // audioEl.setAttribute("muted", "muted");
                        this.audioWrapper.appendChild(audioEl);
                        // 修改音效
                        if (this.stream) {
                            audioEl.srcObject = this.stream;
                            this.sourceNode = this.audioCtx.createMediaStreamSource(this.stream);
                        }
                        if (!this.panner) {
                            this.panner = this.createPanner();
                        }
                        if (this.sourceNode) {
                            // 判断是否需要开启3D音效,队内语音关闭3D音效
                            this.enableSpatializer(this.isSpatial, true);
                        }
                        if (this.audioCtx.state === "suspended") {
                            this.audioCtx.resume();
                        }
                        _b.label = 2;
                    case 2:
                        // 去掉audio标签
                        if (audioEl && audioEl.parentNode) {
                            audioEl.parentNode.removeChild(audioEl);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    AudioSource.prototype.stopPlayingAudio = function () {
        if (this.isPlaying) {
            this.zegoRTC.stopPlayingStream(this.userID);
        }
        this.stream = null;
        if (this.sourceNode) {
            this.sourceNode.disconnect();
            this.sourceNode = null;
        }
        // console.log("停止拉流", this.userID);
    };
    AudioSource.prototype.setPosition = function (position) {
        this.position = position;
        if (this.panner) {
            this.panner.positionX.value = position[1];
            this.panner.positionY.value = position[2];
            this.panner.positionZ.value = -position[0];
        }
    };
    AudioSource.prototype.setMaxDistance = function (range) {
        this.maxDistance = range;
        if (this.panner) {
            this.panner.maxDistance = this.maxDistance;
        }
    };
    // 计算音源与听者距离
    AudioSource.prototype.getDistanceFromListener = function (listener) {
        var audioPosition = this.position;
        var listenerPosition = listener.position;
        if (!listenerPosition || !audioPosition)
            return null;
        var diff = [
            audioPosition[0] - listenerPosition[0],
            audioPosition[1] - listenerPosition[1],
            audioPosition[2] - listenerPosition[2]
        ];
        this.distance = Math.sqrt(Math.pow(diff[0], 2) + Math.pow(diff[1], 2) + Math.pow(diff[2], 2));
        return this.distance;
    };
    // 控制3D音效开关
    AudioSource.prototype.enableSpatializer = function (enable, hard) {
        if (hard === void 0) { hard = false; }
        if (!hard && this.isSpatial === enable)
            return;
        this.isSpatial = enable;
        if (this.sourceNode) {
            if (enable && this.panner) {
                this.sourceNode.disconnect();
                this.sourceNode.connect(this.panner).connect(this.audioCtx.destination);
            }
            else if (!enable) {
                this.sourceNode.disconnect();
                this.sourceNode.connect(this.audioCtx.destination);
            }
        }
    };
    return AudioSource;
}());
exports["default"] = AudioSource;


/***/ }),

/***/ "./sdk/src/modules/rangeaudio/modules/EventManager.ts":
/*!************************************************************!*\
  !*** ./sdk/src/modules/rangeaudio/modules/EventManager.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var EventManager = /** @class */ (function () {
    function EventManager() {
        this.handlerListMap = {
            microphoneStateUpdate: []
        };
    }
    EventManager.getInstance = function () {
        if (!EventManager.instance) {
            EventManager.instance = new EventManager();
        }
        return EventManager.instance;
    };
    EventManager.prototype.addEventHandler = function (listener, callBack) {
        if (!this.handlerListMap[listener]) {
            return false;
        }
        if (typeof callBack !== "function") {
            throw new Error("Params callBack is not a Function");
        }
        this.handlerListMap[listener].indexOf(callBack) == -1 &&
            this.handlerListMap[listener].push(callBack);
        return true;
    };
    EventManager.prototype.removeEventHandler = function (listener, callBack) {
        if (!this.handlerListMap[listener]) {
            return false;
        }
        if (callBack) {
            this.handlerListMap[listener] = this.handlerListMap[listener].filter(function (item) { return item !== callBack; });
        }
        else {
            this.handlerListMap[listener] = [];
        }
        return true;
    };
    EventManager.prototype.emit = function (listener) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.handlerListMap[listener] &&
            this.handlerListMap[listener].forEach(function (func) {
                try {
                    setTimeout(function () {
                        func.apply(void 0, args);
                    }, 0);
                }
                catch (error) {
                    console.error("dispatch " + listener + " " + error);
                }
            });
    };
    return EventManager;
}());
exports["default"] = EventManager;


/***/ }),

/***/ "./sdk/src/modules/rangeaudio/modules/PlayStreamHandler.ts":
/*!*****************************************************************!*\
  !*** ./sdk/src/modules/rangeaudio/modules/PlayStreamHandler.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var ZegoExpressEntity_web_1 = __webpack_require__(/*! ../../../../code/zh/ZegoExpressEntity.web */ "./sdk/code/zh/ZegoExpressEntity.web.ts");
var PlayStreamHandler = /** @class */ (function () {
    function PlayStreamHandler(rangeListener) {
        this.isEnable = false;
        this.interval = 3000;
        this.timer = null;
        this.audioSourceList = [];
        this.hasChanged = false;
        this.maxPlayingQuantity = 20;
        this.rangeListener = rangeListener;
    }
    PlayStreamHandler.getInstance = function (rangeListener) {
        if (!PlayStreamHandler.instance) {
            PlayStreamHandler.instance = new PlayStreamHandler(rangeListener);
        }
        return PlayStreamHandler.instance;
    };
    // 设置听者
    PlayStreamHandler.prototype.setListener = function (rangeListener) {
        this.rangeListener = rangeListener;
        this.hasChanged = true;
    };
    // 设置音源
    PlayStreamHandler.prototype.setAudioSourceList = function (audioSourceList) {
        this.audioSourceList = audioSourceList;
        this.hasChanged = true;
    };
    PlayStreamHandler.prototype.startPlayingAudioStream = function () {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        this.playAudioTask();
    };
    // 拉流判断任务
    PlayStreamHandler.prototype.playAudioTask = function () {
        var _this = this;
        if (this.hasChanged) {
            this.hasChanged = false;
            this.handlePlayAudioTask();
        }
        this.timer = window.setTimeout(function () {
            _this.playAudioTask();
        }, this.interval);
    };
    PlayStreamHandler.prototype.handlePlayAudioTask = function () {
        var _this = this;
        if (!this.isEnable) {
            this.stopPlayingAudioStream();
            return;
        }
        var _a = this.getTeamAudioSourceGroup(), teamList = _a.teamList, otherList = _a.otherList;
        // console.log("音源分组", teamList, otherList);
        var playingQuantity = 0;
        // 小队语音
        teamList.forEach(function (item) {
            if (playingQuantity < _this.maxPlayingQuantity) {
                if (!item.isPlaying) {
                    item.startPlayingAudio();
                }
                playingQuantity++;
            }
        });
        // 范围语音
        var listenable = this.rangeListener.recvMode === ZegoExpressEntity_web_1.ZegoRangeAudioMode.World;
        if (listenable) {
            otherList.forEach(function (item) {
                item.distance = item.getDistanceFromListener(_this.rangeListener);
            });
            otherList.sort(function (a, b) {
                if (a.distance === null) {
                    return 1;
                }
                if (b.distance === null) {
                    return -1;
                }
                if (a.distance < b.distance) {
                    return -1;
                }
                if (a.distance > b.distance) {
                    return 1;
                }
                return 0;
            });
        }
        otherList.forEach(function (item) {
            // console.log(
            //   "是否拉流",
            //   listenable,
            //   item.sendMode !== ZegoRangeAudioMode.Team,
            //   item.distance !== null &&
            //     (this.rangeListener.recvRange === null ||
            //       item.distance <= this.rangeListener.recvRange)
            // );
            if (listenable &&
                playingQuantity < _this.maxPlayingQuantity &&
                item.sendMode !== ZegoExpressEntity_web_1.ZegoRangeAudioMode.Team &&
                item.distance !== null &&
                (_this.rangeListener.recvRange === null ||
                    item.distance <= _this.rangeListener.recvRange)) {
                if (!item.isPlaying) {
                    item.startPlayingAudio();
                }
                playingQuantity++;
            }
            else {
                item.stopPlayingAudio();
            }
        });
        // console.log("拉流数量", playingQuantity);
    };
    PlayStreamHandler.prototype.getTeamAudioSourceGroup = function () {
        var _this = this;
        var teamList = [];
        var otherList = [];
        this.audioSourceList.forEach(function (item) {
            if (![item.teamID, _this.rangeListener.teamID].includes(undefined) &&
                item.teamID === _this.rangeListener.teamID) {
                teamList.push(item);
            }
            else {
                otherList.push(item);
            }
        });
        return {
            teamList: teamList,
            otherList: otherList
        };
    };
    PlayStreamHandler.prototype.stopPlayingAudioStream = function () {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        this.audioSourceList.forEach(function (item) {
            item.stopPlayingAudio();
        });
    };
    return PlayStreamHandler;
}());
exports["default"] = PlayStreamHandler;


/***/ }),

/***/ "./sdk/src/modules/rangeaudio/modules/RangeListener.ts":
/*!*************************************************************!*\
  !*** ./sdk/src/modules/rangeaudio/modules/RangeListener.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ZegoExpressEntity_web_1 = __webpack_require__(/*! ../../../../code/zh/ZegoExpressEntity.web */ "./sdk/code/zh/ZegoExpressEntity.web.ts");
var EventManager_1 = __importDefault(__webpack_require__(/*! ./EventManager */ "./sdk/src/modules/rangeaudio/modules/EventManager.ts"));
var RangeListener = /** @class */ (function () {
    function RangeListener(audioCtx, zegoRTC) {
        var _this = this;
        this.recvMode = ZegoExpressEntity_web_1.ZegoRangeAudioMode.World;
        this.sendMode = ZegoExpressEntity_web_1.ZegoRangeAudioMode.World;
        // 收听范围
        this.recvRange = null;
        // 空间坐标位置, 分别为前右上
        this.position = null;
        // 自身前轴相对空间坐标系方向向量
        this.forwardAxis = [1, 0, 0];
        // 自身顶轴相对空间坐标系方向向量
        this.upAxis = [0, 0, 1];
        this.audioStream = null;
        // 是否在推流
        this.isPublishing = false;
        this.zegoRTC = zegoRTC;
        this.audioCtx = audioCtx;
        this.audioListener = this.audioCtx.listener;
        this.eventHandler = EventManager_1.default.getInstance();
        // 判断是否在推流
        this.zegoRTC.on("publisherStateUpdate", function (_a) {
            var streamID = _a.streamID, state = _a.state, errorCode = _a.errorCode, extendedData = _a.extendedData;
            if (streamID === _this.userID) {
                if (state === "NO_PUBLISH") {
                    _this.isPublishing = false;
                    _this.stopPublishingStream();
                }
                else {
                    _this.isPublishing = true;
                }
            }
            // "PUBLISHING" | "NO_PUBLISH" | "PUBLISH_REQUESTING";
            var stateMap = {
                NO_PUBLISH: ZegoExpressEntity_web_1.ZegoRangeAudioMicrophoneState.Off,
                PUBLISH_REQUESTING: ZegoExpressEntity_web_1.ZegoRangeAudioMicrophoneState.TurningOn,
                PUBLISHING: ZegoExpressEntity_web_1.ZegoRangeAudioMicrophoneState.On
            };
            _this.eventHandler.emit("microphoneStateUpdate", stateMap[state], errorCode, extendedData);
        });
    }
    RangeListener.getInstance = function (audioCtx, zegoRTC) {
        if (!RangeListener.instance) {
            RangeListener.instance = new RangeListener(audioCtx, zegoRTC);
        }
        return RangeListener.instance;
    };
    // 更新定位
    RangeListener.prototype.updateSelfPosition = function (position, forward, up) {
        this.position = position;
        this.forwardAxis = forward;
        if (Array.isArray(up)) {
            this.upAxis = up;
        }
        this.updateListenerEffect();
    };
    RangeListener.prototype.updateListenerEffect = function () {
        if (!this.position)
            return;
        // 更新audioCtx中听者在坐标系中的位置
        if (this.audioListener.positionX) {
            this.audioListener.positionX.value = this.position[1];
            this.audioListener.positionY.value = this.position[2];
            this.audioListener.positionZ.value = -this.position[0];
        }
        else {
            this.audioListener.setPosition(this.position[1], this.position[2], -this.position[0]);
        }
        // 更新audioCtx中听者在坐标系中的朝向
        if (this.audioListener.forwardX) {
            this.audioListener.forwardX.value = this.forwardAxis[1];
            this.audioListener.forwardY.value = this.forwardAxis[2];
            this.audioListener.forwardZ.value = -this.forwardAxis[0];
            this.audioListener.upX.value = this.upAxis[1];
            this.audioListener.upY.value = this.upAxis[2];
            this.audioListener.upZ.value = -this.upAxis[0];
        }
        else {
            this.audioListener.setOrientation(this.forwardAxis[1], this.forwardAxis[2], -this.forwardAxis[0], this.upAxis[1], this.upAxis[2], -this.upAxis[0]);
        }
    };
    RangeListener.prototype.startPublishingStream = function () {
        var _this = this;
        this.zegoRTC
            .createStream({
            camera: { video: false, audio: true, audioBitrate: 30 }
        })
            .then(function (stream) {
            if (!_this.userID) {
                _this.zegoRTC.destroyStream(stream);
                throw Error("Enable mic failed. Please log in room first.");
            }
            else {
                if (_this.audioStream && _this.audioStream !== stream) {
                    _this.zegoRTC.destroyStream(_this.audioStream);
                }
                _this.audioStream = stream;
                var extraInfo = {
                    range_audio_team_id: _this.teamID,
                    range_audio_mode: _this.sendMode
                };
                _this.zegoRTC.startPublishingStream(_this.userID, stream, {
                    extraInfo: JSON.stringify(extraInfo)
                });
            }
        })
            .catch(function (error) {
            throw error;
        });
    };
    RangeListener.prototype.stopPublishingStream = function () {
        if (this.isPublishing && this.userID) {
            this.zegoRTC.stopPublishingStream(this.userID);
        }
        this.isPublishing = false;
        if (this.audioStream) {
            this.zegoRTC.destroyStream(this.audioStream);
            this.audioStream = null;
        }
    };
    RangeListener.prototype.setRecvMode = function (mode) {
        this.recvMode = mode;
    };
    RangeListener.prototype.setSendMode = function (mode) {
        this.sendMode = mode;
        this.updateSteamExtraInfo();
    };
    RangeListener.prototype.setTeamID = function (teamID) {
        this.teamID = teamID;
        this.updateSteamExtraInfo();
    };
    RangeListener.prototype.updateSteamExtraInfo = function () {
        if (this.userID && this.isPublishing) {
            this.zegoRTC.setStreamExtraInfo(this.userID, JSON.stringify({
                range_audio_team_id: this.teamID || undefined,
                range_audio_mode: this.sendMode
            }));
            // console.log("设置流附加信息", {
            //   range_audio_team_id: this.teamID || undefined,
            //   range_audio_mode: this.sendMode
            // });
        }
    };
    RangeListener.prototype.reset = function () {
        if (this.audioStream) {
            this.stopPublishingStream();
        }
        this.userID = undefined;
    };
    return RangeListener;
}());
exports["default"] = RangeListener;


/***/ }),

/***/ "./sdk/src/modules/rangeaudio/utils/checkParam.ts":
/*!********************************************************!*\
  !*** ./sdk/src/modules/rangeaudio/utils/checkParam.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkCoordinate = exports.checkBoolean = exports.checkNumber = void 0;
function checkNumber(value) {
    if (!isNaN(Number(value)) &&
        Number.MAX_SAFE_INTEGER >= Number(value) &&
        Number(value) >= -Number.MAX_SAFE_INTEGER) {
        return true;
    }
    return false;
}
exports.checkNumber = checkNumber;
function checkBoolean(value) {
    if (typeof value === "boolean")
        return false;
    return false;
}
exports.checkBoolean = checkBoolean;
function checkCoordinate(position) {
    if (Array.isArray(position)) {
        for (var index = 0; index < 3; index++) {
            var isOK = checkNumber(position[index]);
            if (!isOK)
                return false;
        }
        return true;
    }
    return false;
}
exports.checkCoordinate = checkCoordinate;


/***/ }),

/***/ "./sdk/src/modules/videoEffect/content.ts":
/*!************************************************!*\
  !*** ./sdk/src/modules/videoEffect/content.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.preview = void 0;
//@ts-nocheck
var videoEffect_1 = __importDefault(__webpack_require__(/*! ./videoEffect */ "./sdk/src/modules/videoEffect/videoEffect.ts"));
var PUBLISH_SET_BEAUTY_EFFECT = "zc.p.0.sbe.0";
var error_1 = __webpack_require__(/*! ./error */ "./sdk/src/modules/videoEffect/error.ts");
exports.preview = {
    setBeautyEffect: function (enable, options) {
        return __awaiter(this, void 0, void 0, function () {
            var supportWebGL, _a, code, message;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.videoTrack) {
                            this.logger.error(PUBLISH_SET_BEAUTY_EFFECT + " video track no found");
                            return [2 /*return*/];
                        }
                        supportWebGL = "undefined" != typeof WebGLRenderingContext;
                        if (!supportWebGL) {
                            _a = error_1.errorCodeList.VIDEO_EFFECT_NOT_SUPPORT, code = _a.code, message = _a.message;
                            throw Error({ errorCode: code, extendedData: message });
                        }
                        if (!videoEffect_1.default) return [3 /*break*/, 7];
                        if (!this.videoEffect) return [3 /*break*/, 4];
                        if (!(this.videoTrack !== this.videoEffect.input)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.videoEffect.setInput(this.videoTrack)];
                    case 1:
                        _b.sent();
                        _b.label = 2;
                    case 2: return [4 /*yield*/, this.videoEffect.setBeautyEffectOptions(enable, options)];
                    case 3:
                        _b.sent();
                        return [3 /*break*/, 6];
                    case 4:
                        this.videoEffect = new videoEffect_1.default(this.logger, this.videoTrack);
                        (this.videoEffect.onOverload = function (result) {
                            // 触发回调
                            _this.stateCenter.actionListener("beautyEffectOverload", _this.localStream, result);
                        }),
                            (this.videoEffect.onOutputChange = function (outputTrack
                            // enabled: boolean 美颜视轨的状态始终为true
                            ) { return __awaiter(_this, void 0, void 0, function () {
                                var activeTrack, currentTrack, publisher;
                                var _a;
                                return __generator(this, function (_b) {
                                    if (this.videoTrack && this.localStream) {
                                        activeTrack = this.videoTrack;
                                        if (!outputTrack) {
                                        }
                                        else {
                                            activeTrack = outputTrack;
                                        }
                                        currentTrack = this.localStream.getVideoTracks()[0];
                                        if (currentTrack !== activeTrack) {
                                            publisher = (_a = this.streamCenter.checkPublish(this.localStream)) === null || _a === void 0 ? void 0 : _a.publisher;
                                            if (publisher && publisher.previewer) {
                                                publisher.replacePublishedTrack(activeTrack, true);
                                            }
                                            else {
                                                this.replacePreviewTrack(activeTrack, !!outputTrack);
                                            }
                                        }
                                    }
                                    return [2 /*return*/];
                                });
                            }); });
                        return [4 /*yield*/, this.videoEffect.setBeautyEffectOptions(enable, options)];
                    case 5:
                        _b.sent();
                        _b.label = 6;
                    case 6: return [3 /*break*/, 8];
                    case 7:
                        this.logger.error(PUBLISH_SET_BEAUTY_EFFECT + " beauty effect module no found");
                        _b.label = 8;
                    case 8: return [2 /*return*/];
                }
            });
        });
    }
};


/***/ }),

/***/ "./sdk/src/modules/videoEffect/effectManager.ts":
/*!******************************************************!*\
  !*** ./sdk/src/modules/videoEffect/effectManager.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PUBLISH_SET_BEAUTY_EFFECT = void 0;
var blurShader_1 = __importDefault(__webpack_require__(/*! ./shaders/blurShader */ "./sdk/src/modules/videoEffect/shaders/blurShader.ts"));
var LightShader_1 = __importDefault(__webpack_require__(/*! ./shaders/LightShader */ "./sdk/src/modules/videoEffect/shaders/LightShader.ts"));
var sharpnessShader_1 = __importDefault(__webpack_require__(/*! ./shaders/sharpnessShader */ "./sdk/src/modules/videoEffect/shaders/sharpnessShader.ts"));
exports.PUBLISH_SET_BEAUTY_EFFECT = "zc.p.0.sbe.2";
var EffectManager = /** @class */ (function () {
    function EffectManager(logger) {
        this.logger = logger;
        this.gl = null;
        this.effectConfig = {
            sharpenIntensity: 0.5,
            whitenIntensity: 0.5,
            rosyIntensity: 0.5,
            smoothIntensity: 0.5
        };
        this.originResolution = {
            width: 0,
            height: 0
        };
        this.shaderList = [];
        this.frameBufferList = [];
        this.outputTextureList = [];
        this.inputTexture = null;
        this.enableBeauty = false;
    }
    EffectManager.prototype.setEnableBeauty = function (enable) {
        this.enableBeauty = !!enable;
    };
    EffectManager.prototype.init = function (width, height, canvasEl) {
        return __awaiter(this, void 0, void 0, function () {
            var supportWebGL, blurShader, lightShader, sharpnessShader;
            return __generator(this, function (_a) {
                supportWebGL = "undefined" != typeof WebGLRenderingContext;
                if (!supportWebGL) {
                    return [2 /*return*/, this.logger.error(exports.PUBLISH_SET_BEAUTY_EFFECT + " not support webgl!")];
                }
                this.gl = canvasEl.getContext("webgl");
                if (!this.gl)
                    return [2 /*return*/, this.logger.error(exports.PUBLISH_SET_BEAUTY_EFFECT + " not get webgl context")];
                this.initGL(width, height);
                if (!this.inputTexture)
                    return [2 /*return*/, this.logger.error(exports.PUBLISH_SET_BEAUTY_EFFECT + " input texture not found")];
                this.canvasEl = canvasEl;
                blurShader = new blurShader_1.default(this.gl, width, height);
                blurShader.setConstUniforms();
                lightShader = new LightShader_1.default(this.gl, width, height);
                lightShader.setConstUniforms();
                sharpnessShader = new sharpnessShader_1.default(this.gl, width, height);
                sharpnessShader.setConstUniforms();
                this.shaderList = [blurShader, lightShader, sharpnessShader];
                this.setEffectConfig(this.effectConfig);
                return [2 /*return*/];
            });
        });
    };
    EffectManager.prototype.render = function (videoEl) {
        return __awaiter(this, void 0, void 0, function () {
            var gl, isResolutionChange, vertex, vertexIndice, triangleTexCoords;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        gl = this.gl;
                        if (!gl || !this.canvasEl) {
                            this.logger.error(exports.PUBLISH_SET_BEAUTY_EFFECT + " video effect manager is not init!");
                            return [2 /*return*/];
                        }
                        isResolutionChange = (this.originResolution.height !== videoEl.videoHeight ||
                            this.originResolution.width !== videoEl.videoWidth) &&
                            // 2像素以内的分辨率切换时不重置美颜效果，兼容 muteVideo 接口连续动态修改分辨率，导致context丢失
                            (Math.abs(this.originResolution.height - videoEl.videoHeight) > 2 ||
                                Math.abs(this.originResolution.width - videoEl.videoWidth) > 2);
                        if (!isResolutionChange) return [3 /*break*/, 3];
                        if (0 === videoEl.videoHeight || 0 === videoEl.videoWidth)
                            return [2 /*return*/];
                        this.canvasEl.width = videoEl.videoWidth;
                        this.canvasEl.height = videoEl.videoHeight;
                        videoEl.setAttribute("width", videoEl.videoWidth.toString());
                        videoEl.setAttribute("height", videoEl.videoHeight.toString());
                        if (!(this.gl && !this.gl.isContextLost())) return [3 /*break*/, 1];
                        this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " resolution changed, reset resolution");
                        this.resetResolution(videoEl.videoWidth, videoEl.videoHeight);
                        return [3 /*break*/, 3];
                    case 1:
                        this.logger.warn(exports.PUBLISH_SET_BEAUTY_EFFECT +
                            " resolution changed and gl context lost, restart effect");
                        this.release();
                        return [4 /*yield*/, this.init(videoEl.videoWidth, videoEl.videoHeight, this.canvasEl)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        vertex = [-1, -1, 0.0, 1, -1, 0.0, 1, 1, 0.0, -1, 1, 0.0];
                        vertexIndice = [0, 1, 2, 0, 2, 3];
                        triangleTexCoords = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0];
                        // 设置画面
                        gl.viewport(0, 0, videoEl.width, videoEl.height);
                        // 绑定视频纹理
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, this.inputTexture);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, videoEl);
                        this.shaderList.forEach(function (shaderInfo, index) {
                            var program = shaderInfo.program;
                            if (!program) {
                                // TODO: 报错;
                                return;
                            }
                            if (shaderInfo.renderPreTextures) {
                                shaderInfo.renderPreTextures(vertex, vertexIndice, triangleTexCoords);
                            }
                            gl.useProgram(program);
                            shaderInfo.render();
                            var uTexture = gl.getUniformLocation(program, "uTexture");
                            // 绘制顶点
                            // vertex data
                            var vertexBuffer = gl.createBuffer();
                            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertex), gl.STATIC_DRAW);
                            // indice data
                            var vertexIndiceBuffer = gl.createBuffer();
                            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndiceBuffer);
                            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertexIndice), gl.STATIC_DRAW);
                            // set position attribute
                            var aVertexPosition = gl.getAttribLocation(program, "aPosition");
                            gl.enableVertexAttribArray(aVertexPosition);
                            gl.vertexAttribPointer(aVertexPosition, 3, gl.FLOAT, false, 0, 0); // 每次读取三个float 3 * 4 * 2
                            // texture coordinate data
                            var trianglesTexCoordBuffer = gl.createBuffer();
                            gl.bindBuffer(gl.ARRAY_BUFFER, trianglesTexCoordBuffer);
                            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangleTexCoords), gl.STATIC_DRAW);
                            // set texture coordinate attribute
                            var vertexTexCoordAttribute = gl.getAttribLocation(program, "aTexCoordinate");
                            gl.enableVertexAttribArray(vertexTexCoordAttribute);
                            gl.vertexAttribPointer(vertexTexCoordAttribute, 2, gl.FLOAT, false, 0, 0); // 2 * 4
                            // this.programs[index].setUniforms();
                            //  gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBufferList[b + (index % 2)]);
                            var outputTexture = index === _this.shaderList.length - 1
                                ? null
                                : _this.outputTextureList[index];
                            var outputFrameBuffer = index === _this.shaderList.length - 1
                                ? null
                                : _this.frameBufferList[index];
                            gl.bindFramebuffer(gl.FRAMEBUFFER, outputFrameBuffer);
                            gl.clearColor(0, 0, 0, 1);
                            gl.clear(gl.COLOR_BUFFER_BIT);
                            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                            gl.activeTexture(gl.TEXTURE0);
                            outputTexture && gl.bindTexture(gl.TEXTURE_2D, outputTexture);
                            gl.uniform1i(uTexture, 0);
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    EffectManager.prototype.setEffectConfig = function (options) {
        var _this = this;
        if (!isNaN(options.sharpenIntensity))
            this.effectConfig.sharpenIntensity = options.sharpenIntensity;
        if (!isNaN(options.whitenIntensity))
            this.effectConfig.whitenIntensity = options.whitenIntensity;
        if (!isNaN(options.rosyIntensity))
            this.effectConfig.rosyIntensity = options.rosyIntensity;
        if (!isNaN(options.smoothIntensity))
            this.effectConfig.smoothIntensity = options.smoothIntensity;
        this.shaderList.forEach(function (item) {
            item.setEffectConfig(_this.effectConfig);
        });
    };
    // setSize(width: number, height: number): void {
    //   this.shaderList.forEach(item => {
    //     // item instanceof vc &&
    //     item.setSize(width, height);
    //   });
    // }
    EffectManager.prototype.release = function () {
        var _this = this;
        // if (this.gl) {
        //   const extension = this.gl.getExtension("WEBGL_lose_context");
        //   extension && extension.loseContext();
        // }
        this.shaderList.forEach(function (item) {
            var _a;
            if (item.program) {
                (_a = _this.gl) === null || _a === void 0 ? void 0 : _a.deleteProgram(item.program);
            }
        });
        this.outputTextureList.forEach(function (item) {
            var _a;
            if (item) {
                (_a = _this.gl) === null || _a === void 0 ? void 0 : _a.deleteTexture(item);
            }
        });
        this.frameBufferList.forEach(function (item) {
            var _a;
            if (item) {
                (_a = _this.gl) === null || _a === void 0 ? void 0 : _a.deleteFramebuffer(item);
            }
        });
        this.inputTexture = this.gl = null;
        this.shaderList = [];
        this.outputTextureList = [];
        this.frameBufferList = [];
    };
    EffectManager.prototype.initGL = function (width, height) {
        var gl = this.gl;
        if (!gl)
            return this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " webgl context not found");
        this.inputTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.inputTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        for (var index = 0; 3 > index; index++) {
            var texture = gl.createTexture();
            if (!texture)
                return this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " create texture failed");
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            var frameBuffer = gl.createFramebuffer();
            if (!frameBuffer)
                return this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " create frame buffer failed");
            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            this.outputTextureList.push(texture);
            this.frameBufferList.push(frameBuffer);
        }
        gl.viewport(0, 0, width, height);
        this.originResolution.width = width;
        this.originResolution.height = height;
    };
    EffectManager.prototype.resetResolution = function (width, height) {
        var gl = this.gl;
        if (!gl)
            return this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " can not find webgl context");
        this.outputTextureList.forEach(function (item) {
            gl.bindTexture(gl.TEXTURE_2D, item);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        });
        gl.viewport(0, 0, width, height);
        this.originResolution.width = width;
        this.originResolution.height = height;
    };
    return EffectManager;
}());
exports["default"] = EffectManager;


/***/ }),

/***/ "./sdk/src/modules/videoEffect/error.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/videoEffect/error.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorCodeList = void 0;
exports.errorCodeList = {
    VIDEO_EFFECT_NOT_SUPPORT: {
        code: 1103072,
        message: "not support beauty effect"
    }
};


/***/ }),

/***/ "./sdk/src/modules/videoEffect/index.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/videoEffect/index.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeautyEffect = void 0;
//@ts-nocheck
var content_1 = __webpack_require__(/*! ./content */ "./sdk/src/modules/videoEffect/content.ts");
exports.BeautyEffect = {
    type: "BeautyEffect",
    install: function (Preview) {
        for (var key in content_1.preview) {
            Object.defineProperty(Preview.prototype, key, {
                value: content_1.preview[key],
                writable: false
            });
        }
    }
};


/***/ }),

/***/ "./sdk/src/modules/videoEffect/performanceDetector.ts":
/*!************************************************************!*\
  !*** ./sdk/src/modules/videoEffect/performanceDetector.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var PUBLISH_SET_BEAUTY_EFFECT = "zc.p.0.sbe.3";
var PerformanceDetector = /** @class */ (function () {
    function PerformanceDetector(logger) {
        this.logger = logger;
        this.recordedFrameCount = 0;
        this.targetFrameRate = 0;
        this.recordingDuration = 0;
    }
    PerformanceDetector.prototype.startRecordBeautyEffectOutput = function (fps) {
        return __awaiter(this, void 0, void 0, function () {
            var seconds, id, targetFrames, fps_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        seconds = 6;
                        if (this.recordID) {
                            this.logger.warn(PUBLISH_SET_BEAUTY_EFFECT + " detector is already recording");
                            return [2 /*return*/, { result: true }];
                        }
                        id = new Date().getTime();
                        this.recordID = id;
                        this.targetFrameRate = fps;
                        this.recordedFrameCount = 0;
                        this.recordingDuration = seconds;
                        return [4 /*yield*/, new Promise(function (resolve) {
                                window.setTimeout(resolve, 1e3 * _this.recordingDuration);
                            })];
                    case 1:
                        _a.sent();
                        if (this.recordID !== id) {
                            this.recordID = undefined;
                            return [2 /*return*/, { result: true }];
                        }
                        else {
                            this.recordID = undefined;
                            targetFrames = this.targetFrameRate * this.recordingDuration;
                            fps_1 = this.recordedFrameCount / seconds;
                            if (this.recordedFrameCount < targetFrames / 2) {
                                this.logger.warn(PUBLISH_SET_BEAUTY_EFFECT +
                                    " detect effect overload: current fps: " +
                                    fps_1);
                                return [2 /*return*/, {
                                        result: false,
                                        targetFPS: this.targetFrameRate,
                                        currentFPS: fps_1
                                    }];
                            }
                            else {
                                this.logger.info(PUBLISH_SET_BEAUTY_EFFECT + " detect effect current fps: " + fps_1);
                                return [2 /*return*/, {
                                        result: true
                                    }];
                            }
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    PerformanceDetector.prototype.stopRecordBeautyEffectOutput = function () {
        this.recordedFrameCount = this.targetFrameRate = 0;
        this.recordID = undefined;
    };
    PerformanceDetector.prototype.addFrame = function () {
        this.recordID && (this.recordedFrameCount += 1);
    };
    return PerformanceDetector;
}());
exports["default"] = PerformanceDetector;


/***/ }),

/***/ "./sdk/src/modules/videoEffect/shaders/LightShader.ts":
/*!************************************************************!*\
  !*** ./sdk/src/modules/videoEffect/shaders/LightShader.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var baseShader_1 = __importDefault(__webpack_require__(/*! ./baseShader */ "./sdk/src/modules/videoEffect/shaders/baseShader.ts"));
// // eslint-disable-next-line @typescript-eslint/no-var-requires
// const lightVS = require("./glsl/lightVS.glsl").default;
// // eslint-disable-next-line @typescript-eslint/no-var-requires
// const lightFS = require("./glsl/lightFS.glsl").default;
var shadersCodeSourceROT13_1 = __webpack_require__(/*! ./shadersCodeSourceROT13 */ "./sdk/src/modules/videoEffect/shaders/shadersCodeSourceROT13.ts");
var LightShader = /** @class */ (function (_super) {
    __extends(LightShader, _super);
    function LightShader(gl, width, height) {
        var _this = _super.call(this, gl) || this;
        _this.width = width;
        _this.height = height;
        _this.type = "LightShader";
        _this.uLightIntensity = null;
        _this.uRedIntensity = null;
        _this.whitenIntensity = 0.5; // 0-1
        _this.rosyIntensity = 0.5;
        _this.program = _this.makeProgram(shadersCodeSourceROT13_1.lightVS, shadersCodeSourceROT13_1.lightFS);
        return _this;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    LightShader.prototype.setEffectConfig = function (config) {
        if (!isNaN(config.whitenIntensity)) {
            this.whitenIntensity = config.whitenIntensity / 100;
        }
        if (!isNaN(config.rosyIntensity)) {
            this.rosyIntensity = config.rosyIntensity / 100;
        }
    };
    LightShader.prototype.render = function () {
        var gl = this.gl;
        gl.uniform1f(this.uLightIntensity, this.whitenIntensity);
        gl.uniform1f(this.uRedIntensity, this.rosyIntensity);
    };
    LightShader.prototype.setConstUniforms = function () {
        // 标准矩阵
        var identityMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        // y 轴翻转矩阵
        var flipYMatrix = [1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        var program = this.program;
        if (!program)
            return;
        var gl = this.gl;
        gl.useProgram(program);
        this.uLightIntensity = gl.getUniformLocation(program, "intensity");
        gl.uniform1f(this.uLightIntensity, this.whitenIntensity);
        this.uRedIntensity = gl.getUniformLocation(program, "rosyIntensity");
        gl.uniform1f(this.uRedIntensity, this.rosyIntensity);
        // 设置y轴翻转
        var uPMVMatrix = gl.getUniformLocation(program, "uPMVMatrix");
        gl.uniformMatrix4fv(uPMVMatrix, false, flipYMatrix);
    };
    return LightShader;
}(baseShader_1.default));
exports["default"] = LightShader;


/***/ }),

/***/ "./sdk/src/modules/videoEffect/shaders/baseShader.ts":
/*!***********************************************************!*\
  !*** ./sdk/src/modules/videoEffect/shaders/baseShader.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function rot13(str) {
    var key = 13;
    // console.log(key);
    var ctext = str;
    var plain = "";
    // do the encoding
    for (var i = 0; i < ctext.length; i++) {
        var ccode = ctext.charCodeAt(i);
        var pcode = ccode;
        if (ccode >= 65 && ccode <= 90) {
            pcode = ((ccode - 65 - key * 1 + 26) % 26) + 65;
        }
        if (ccode >= 97 && ccode <= 122) {
            pcode = ((ccode - 97 - key * 1 + 26) % 26) + 97;
        }
        // console.log(ccode + "," + pcode);
        plain += String.fromCharCode(pcode);
    }
    // console.log(-3 % 26);
    return plain;
}
var BaseShader = /** @class */ (function () {
    function BaseShader(gl) {
        this.gl = gl;
        this.program = null;
        this.program = null;
    }
    BaseShader.prototype.setEffectConfig = function (config) { };
    BaseShader.prototype.setConstUniforms = function () { };
    BaseShader.prototype.render = function () { };
    BaseShader.prototype.renderPreTextures = function (vertex, vertexIndice, triangleTexCoords) { };
    BaseShader.prototype.makeProgram = function (vs_source, fs_source) {
        var gl = this.gl;
        //get shader source
        // compile shaders
        var vs = rot13(vs_source);
        var fs = rot13(fs_source);
        var vertexShader = this.makeShader(vs, gl.VERTEX_SHADER);
        var fragmentShader = this.makeShader(fs, gl.FRAGMENT_SHADER);
        // create program
        var glProgram = gl.createProgram();
        // attach and link shaders to the program
        gl.attachShader(glProgram, vertexShader);
        gl.attachShader(glProgram, fragmentShader);
        gl.linkProgram(glProgram);
        if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
            // TODO: alert("Unable to initialize the shader program.");
        }
        return glProgram;
    };
    BaseShader.prototype.makeShader = function (src, type) {
        var gl = this.gl;
        //compile the vertex shader
        var shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            // TODO: alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
        }
        return shader;
    };
    return BaseShader;
}());
exports["default"] = BaseShader;


/***/ }),

/***/ "./sdk/src/modules/videoEffect/shaders/blurShader.ts":
/*!***********************************************************!*\
  !*** ./sdk/src/modules/videoEffect/shaders/blurShader.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var baseShader_1 = __importDefault(__webpack_require__(/*! ./baseShader */ "./sdk/src/modules/videoEffect/shaders/baseShader.ts"));
var shadersCodeSourceROT13_1 = __webpack_require__(/*! ./shadersCodeSourceROT13 */ "./sdk/src/modules/videoEffect/shaders/shadersCodeSourceROT13.ts");
var BlurShader = /** @class */ (function (_super) {
    __extends(BlurShader, _super);
    function BlurShader(gl, width, height) {
        var _this = _super.call(this, gl) || this;
        _this.width = width;
        _this.height = height;
        _this.type = "BlurShader";
        _this.blurXProgram = null;
        _this.blurYProgram = null;
        _this.diffProgram = null;
        _this.uIntensity = null;
        _this.smoothIntensity = 0.5; // 0-1
        _this.blurTextureList = [];
        _this.blurBufferList = [];
        _this.blurXProgram = _this.makeProgram(shadersCodeSourceROT13_1.borderBlurVS, shadersCodeSourceROT13_1.borderBlurFS);
        _this.setBorderBlurProgram(_this.blurXProgram, 1 / (width || 1), 0);
        _this.blurYProgram = _this.makeProgram(shadersCodeSourceROT13_1.borderBlurVS, shadersCodeSourceROT13_1.borderBlurFS);
        _this.setBorderBlurProgram(_this.blurYProgram, 0, 1 / (height || 1));
        _this.diffProgram = _this.makeProgram(shadersCodeSourceROT13_1.diffBlurVS, shadersCodeSourceROT13_1.diffBlurFS);
        _this.setDiffBlurProgram(_this.diffProgram);
        _this.program = _this.makeProgram(shadersCodeSourceROT13_1.mixBlurVS, shadersCodeSourceROT13_1.mixBlurFS);
        _this.initBlurBuffer();
        return _this;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    BlurShader.prototype.setEffectConfig = function (config) {
        if (!isNaN(config.smoothIntensity)) {
            this.smoothIntensity = config.smoothIntensity / 100;
        }
    };
    BlurShader.prototype.render = function () {
        var gl = this.gl;
        gl.uniform1f(this.uIntensity, this.smoothIntensity);
    };
    BlurShader.prototype.initBlurBuffer = function () {
        var gl = this.gl;
        this.blurTextureList = [];
        this.blurTextureList = [];
        for (var index = 0; index < 3; index++) {
            // 滤镜纹理
            var texture = gl.createTexture();
            if (!texture)
                return;
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            var frameBuffer = gl.createFramebuffer();
            if (!frameBuffer)
                return;
            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            this.blurTextureList.push(texture);
            this.blurBufferList.push(frameBuffer);
        }
    };
    BlurShader.prototype.renderPreTextures = function (vertex, vertexIndice, triangleTexCoords) {
        var _this = this;
        var gl = this.gl;
        var srcTextureUnits = [0, 1, 0];
        var distTextureUnits = [1, 1, 2];
        [this.blurXProgram, this.blurYProgram, this.diffProgram].forEach(function (program, index) {
            if (!program)
                return;
            gl.useProgram(program);
            var uTexture = gl.getUniformLocation(program, "uTexture");
            gl.uniform1i(uTexture, srcTextureUnits[index]);
            // vertex data
            var vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertex), gl.STATIC_DRAW);
            // indice data
            var vertexIndiceBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndiceBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertexIndice), gl.STATIC_DRAW);
            // set position attribute
            var aVertexPosition = gl.getAttribLocation(program, "aPosition");
            gl.enableVertexAttribArray(aVertexPosition);
            gl.vertexAttribPointer(aVertexPosition, 3, gl.FLOAT, false, 0, 0); // 每次读取三个float 3 * 4 * 2
            // texture coordinate data
            var trianglesTexCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, trianglesTexCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangleTexCoords), gl.STATIC_DRAW);
            // set texture coordinate attribute
            var vertexTexCoordAttribute = gl.getAttribLocation(program, "aTexCoordinate");
            gl.enableVertexAttribArray(vertexTexCoordAttribute);
            gl.vertexAttribPointer(vertexTexCoordAttribute, 2, gl.FLOAT, false, 0, 0);
            gl.bindFramebuffer(gl.FRAMEBUFFER, _this.blurBufferList[index]);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            gl.activeTexture(gl.TEXTURE0 + distTextureUnits[index]);
            gl.bindTexture(gl.TEXTURE_2D, _this.blurTextureList[index]);
        });
    };
    BlurShader.prototype.setConstUniforms = function () {
        var width = this.width;
        var height = this.height;
        var program = this.program;
        if (!program)
            return;
        var gl = this.gl;
        gl.useProgram(program);
        var uTexBlurWidthOffset = gl.getUniformLocation(program, "widthOffset");
        gl.uniform1f(uTexBlurWidthOffset, 1 / width);
        var uTexBlurHeightOffset = gl.getUniformLocation(program, "heightOffset");
        gl.uniform1f(uTexBlurHeightOffset, 1 / height);
        this.uIntensity = gl.getUniformLocation(program, "blurAlpha");
        gl.uniform1f(this.uIntensity, this.smoothIntensity);
        var uBlurTexture = gl.getUniformLocation(program, "blurTexture");
        gl.uniform1i(uBlurTexture, 1);
        var uBlurDiffTexture = gl.getUniformLocation(program, "blurDiffTexture");
        gl.uniform1i(uBlurDiffTexture, 2);
    };
    BlurShader.prototype.setBorderBlurProgram = function (program, width, height) {
        var gl = this.gl;
        gl.useProgram(program);
        var uTexBlurWidthOffset = gl.getUniformLocation(program, "texBlurWidthOffset");
        gl.uniform1f(uTexBlurWidthOffset, width);
        var uTexBlurHeightOffset = gl.getUniformLocation(program, "texBlurHeightOffset");
        gl.uniform1f(uTexBlurHeightOffset, height);
    };
    BlurShader.prototype.setDiffBlurProgram = function (program) {
        var gl = this.gl;
        gl.useProgram(program);
        var uBlurTexture = gl.getUniformLocation(program, "blurTexture");
        gl.uniform1i(uBlurTexture, 1);
    };
    return BlurShader;
}(baseShader_1.default));
exports["default"] = BlurShader;


/***/ }),

/***/ "./sdk/src/modules/videoEffect/shaders/shadersCodeSourceROT13.ts":
/*!***********************************************************************!*\
  !*** ./sdk/src/modules/videoEffect/shaders/shadersCodeSourceROT13.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mixBlurFS = exports.mixBlurVS = exports.diffBlurFS = exports.diffBlurVS = exports.borderBlurFS = exports.borderBlurVS = exports.sharpnessFS = exports.sharpnessVS = exports.lightFS = exports.lightVS = void 0;
exports.lightVS = "cerpvfvba uvtuc sybng;\nnggevohgr irp2 nGrkPbbeqvangr;\nnggevohgr irp4 nCbfvgvba;\nhavsbez zng4 hCZIZngevk;\ninelvat irp2 iGrkPbbeq;\nibvq znva() {\n    ty_Cbfvgvba = hCZIZngevk * nCbfvgvba;\n    iGrkPbbeq = nGrkPbbeqvangr;\n}";
exports.lightFS = "cerpvfvba uvtuc sybng;\ninelvat irp2 iGrkPbbeq;\nhavsbez fnzcyre2Q hGrkgher;\nhavsbez sybng vagrafvgl;\nhavsbez sybng ebflVagrafvgl;\nirp3 oevtugarffNaqPbagenfg(irp3 pbybe){\n  sybng v = vagrafvgl * 1.0;\n  sybng CV = 3.1415926;\n  sybng O = 0.12 * v;\n  sybng p = 0.1 * v;\n  sybng x = gna((45. + 44. * p) / 180.0 * CV);\n  pbybe = ((pbybe*255.0 - 127.5 * (1.0 - O)) * x + 127.5 * (1.0 + O)) / 255.0;\n  erghea pbybe;\n}\nibvq znva() {\n  irp4 grkgherPbybe = grkgher2Q(hGrkgher, iGrkPbbeq);\n  grkgherPbybe = irp4(oevtugarffNaqPbagenfg(grkgherPbybe.eto), grkgherPbybe.j);\n  grkgherPbybe.e = zva(grkgherPbybe.e + 0.06 * ebflVagrafvgl, 1.0);\n  ty_SentPbybe = grkgherPbybe;\n}";
exports.sharpnessVS = "\nnggevohgr irp4 nCbfvgvba;\nnggevohgr irp4 nGrkPbbeqvangr;\nhavsbez sybng vzntrJvqguSnpgbe;\nhavsbez sybng vzntrUrvtugSnpgbe;\nhavsbez sybng funecarff; \ninelvat irp2 iGrkPbbeq;\ninelvat irp2 yrsgGrkgherPbbeqvangr;\ninelvat irp2 evtugGrkgherPbbeqvangr;\ninelvat irp2 gbcGrkgherPbbeqvangr;\ninelvat irp2 obggbzGrkgherPbbeqvangr;\ninelvat sybng pragreZhygvcyvre;\ninelvat sybng rqtrZhygvcyvre;\nibvq znva() {\n  ty_Cbfvgvba = nCbfvgvba;\n  irp2 jvqguFgrc = irp2(vzntrJvqguSnpgbe, 0.0);\n  irp2 urvtugFgrc = irp2(0.0, vzntrUrvtugSnpgbe);\n  iGrkPbbeq = nGrkPbbeqvangr.kl;\n  yrsgGrkgherPbbeqvangr = nGrkPbbeqvangr.kl - jvqguFgrc;\n  evtugGrkgherPbbeqvangr = nGrkPbbeqvangr.kl + jvqguFgrc;\n  gbcGrkgherPbbeqvangr = nGrkPbbeqvangr.kl + urvtugFgrc;\n  obggbzGrkgherPbbeqvangr = nGrkPbbeqvangr.kl - urvtugFgrc;\n  pragreZhygvcyvre = 1.0 + 4.0 * funecarff;\n  rqtrZhygvcyvre = funecarff;\n}\n";
exports.sharpnessFS = "\ncerpvfvba uvtuc sybng;\ninelvat uvtuc irp2 iGrkPbbeq;\ninelvat uvtuc irp2 yrsgGrkgherPbbeqvangr;\ninelvat uvtuc irp2 evtugGrkgherPbbeqvangr;\ninelvat uvtuc irp2 gbcGrkgherPbbeqvangr;\ninelvat uvtuc irp2 obggbzGrkgherPbbeqvangr;\ninelvat uvtuc sybng pragreZhygvcyvre;\ninelvat uvtuc sybng rqtrZhygvcyvre;\nhavsbez fnzcyre2Q hGrkgher;\nibvq znva() {\n  zrqvhzc irp4 nPbybe = grkgher2Q(hGrkgher, iGrkPbbeq);\n  zrqvhzc irp3 grkgherPbybe = nPbybe.eto;\n  zrqvhzc irp3 yrsgGrkgherPbybe = grkgher2Q(hGrkgher, yrsgGrkgherPbbeqvangr).eto;\n  zrqvhzc irp3 evtugGrkgherPbybe = grkgher2Q(hGrkgher, evtugGrkgherPbbeqvangr).eto;\n  zrqvhzc irp3 gbcGrkgherPbybe = grkgher2Q(hGrkgher, gbcGrkgherPbbeqvangr).eto;\n  zrqvhzc irp3 obggbzGrkgherPbybe = grkgher2Q(hGrkgher, obggbzGrkgherPbbeqvangr).eto;\n  ty_SentPbybe = irp4((grkgherPbybe * pragreZhygvcyvre - (yrsgGrkgherPbybe * rqtrZhygvcyvre + evtugGrkgherPbybe * rqtrZhygvcyvre + gbcGrkgherPbybe * rqtrZhygvcyvre + obggbzGrkgherPbybe * rqtrZhygvcyvre)), nPbybe.n);\n}";
exports.borderBlurVS = "nggevohgr irp4 nCbfvgvba;\nnggevohgr irp4 nGrkPbbeqvangr;\nhavsbez uvtuc sybng grkOyheJvqguBssfrg;\nhavsbez uvtuc sybng grkOyheUrvtugBssfrg;\ninelvat irp2 i_grkpbbeq0;\ninelvat irp4 grkgherFuvsg_1;\ninelvat irp4 grkgherFuvsg_2;\ninelvat irp4 grkgherFuvsg_3;\ninelvat irp4 grkgherFuvsg_4;\nibvq znva()\n{\n  ty_Cbfvgvba = nCbfvgvba;\n  i_grkpbbeq0 = nGrkPbbeqvangr.kl;\n\n  irp2 fvatyrFgrcBssfrg = irp2(grkOyheJvqguBssfrg, grkOyheUrvtugBssfrg)*2.5;\n\n  grkgherFuvsg_1 = irp4(nGrkPbbeqvangr.kl - fvatyrFgrcBssfrg, nGrkPbbeqvangr.kl + fvatyrFgrcBssfrg);\n  grkgherFuvsg_2 = irp4(nGrkPbbeqvangr.kl - 2.0 * fvatyrFgrcBssfrg, nGrkPbbeqvangr.kl + 2.0 * fvatyrFgrcBssfrg);\n  grkgherFuvsg_3 = irp4(nGrkPbbeqvangr.kl - 3.0 * fvatyrFgrcBssfrg, nGrkPbbeqvangr.kl + 3.0 * fvatyrFgrcBssfrg);\n  grkgherFuvsg_4 = irp4(nGrkPbbeqvangr.kl - 4.0 * fvatyrFgrcBssfrg, nGrkPbbeqvangr.kl + 4.0 * fvatyrFgrcBssfrg);\n}";
exports.borderBlurFS = "cerpvfvba zrqvhzc sybng;\nhavsbez fnzcyre2Q hGrkgher;\ninelvat irp2 i_grkpbbeq0;\ninelvat uvtuc irp4 grkgherFuvsg_1;\ninelvat uvtuc irp4 grkgherFuvsg_2;\ninelvat uvtuc irp4 grkgherFuvsg_3;\ninelvat uvtuc irp4 grkgherFuvsg_4;\nibvq znva(ibvq) { \n  zrqvhzc irp3 fhz = grkgher2Q(hGrkgher, i_grkpbbeq0).eto;\n  fhz += grkgher2Q(hGrkgher, grkgherFuvsg_1.kl).eto;\n  fhz += grkgher2Q(hGrkgher, grkgherFuvsg_1.mj).eto;\n  fhz += grkgher2Q(hGrkgher, grkgherFuvsg_2.kl).eto;\n  fhz += grkgher2Q(hGrkgher, grkgherFuvsg_2.mj).eto;\n  fhz += grkgher2Q(hGrkgher, grkgherFuvsg_3.kl).eto;\n  fhz += grkgher2Q(hGrkgher, grkgherFuvsg_3.mj).eto;\n  fhz += grkgher2Q(hGrkgher, grkgherFuvsg_4.kl).eto;\n  fhz += grkgher2Q(hGrkgher, grkgherFuvsg_4.mj).eto;\n  ty_SentPbybe = irp4(fhz * 0.1111, 1.0); \n}";
exports.diffBlurVS = "nggevohgr irp4 nCbfvgvba;\nnggevohgr irp4 nGrkPbbeqvangr;\nhavsbez zng4 hCZIZngevk;\ninelvat irp2 i_grkpbbeq0;\nibvq znva()\n{\n  // ty_Cbfvgvba = hCZIZngevk * nCbfvgvba;\n  ty_Cbfvgvba = nCbfvgvba;\n  i_grkpbbeq0 = nGrkPbbeqvangr.kl;\n}";
exports.diffBlurFS = "cerpvfvba zrqvhzc sybng;\nhavsbez fnzcyre2Q hGrkgher;\ninelvat irp2 i_grkpbbeq0;\nhavsbez fnzcyre2Q oyheGrkgher;\nibvq znva(ibvq) {\n  irp4 vPbybe = grkgher2Q(oyheGrkgher, i_grkpbbeq0);\n  irp4 zrnaPbybe = grkgher2Q(hGrkgher, i_grkpbbeq0);\n  irp4 qvssPbybe = vPbybe - zrnaPbybe;\n  qvssPbybe.e = zva(qvssPbybe.e * 50.0 * qvssPbybe.e, 1.0);\n  qvssPbybe.t = zva(qvssPbybe.t * 50.0 * qvssPbybe.t, 1.0);\n  qvssPbybe.o = zva(qvssPbybe.o * 50.0 * qvssPbybe.o, 1.0);\n  ty_SentPbybe = irp4(qvssPbybe.eto, 1.0);\n}";
exports.mixBlurVS = "\nnggevohgr irp4 nCbfvgvba;\nnggevohgr irp4 nGrkPbbeqvangr;\ninelvat irp2 i_grkpbbeq0;\nhavsbez sybng jvqguBssfrg;\nhavsbez sybng urvtugBssfrg;\ninelvat irp2 grkgherFuvsg_1;\ninelvat irp2 grkgherFuvsg_2;\ninelvat irp2 grkgherFuvsg_3;\ninelvat irp2 grkgherFuvsg_4;\nibvq znva()\n{\n  ty_Cbfvgvba = nCbfvgvba;\n  i_grkpbbeq0 = nGrkPbbeqvangr.kl;\n  grkgherFuvsg_1 = irp2(i_grkpbbeq0 + 0.5 * irp2(jvqguBssfrg,urvtugBssfrg));\n  grkgherFuvsg_2 = irp2(i_grkpbbeq0 + 0.5 * irp2(-jvqguBssfrg,-urvtugBssfrg));\n  grkgherFuvsg_3 = irp2(i_grkpbbeq0 + 0.5 * irp2(-jvqguBssfrg,urvtugBssfrg));\n  grkgherFuvsg_4 = irp2(i_grkpbbeq0 + 0.5 * irp2(jvqguBssfrg,-urvtugBssfrg));\n}\n";
exports.mixBlurFS = "\ncerpvfvba zrqvhzc sybng;\nhavsbez fnzcyre2Q hGrkgher;\ninelvat irp2 i_grkpbbeq0;\nhavsbez fnzcyre2Q oyheGrkgher;\nhavsbez fnzcyre2Q oyheQvssGrkgher;\nhavsbez ybjc sybng oyheNycun;\nibvq znva(ibvq) {\n  ybjc irp4 vPbybe = grkgher2Q(hGrkgher, i_grkpbbeq0);\n  ybjc irp4 zrnaPbybe = grkgher2Q(oyheGrkgher, i_grkpbbeq0);\n  ybjc irp4 inePbybe = grkgher2Q(oyheQvssGrkgher, i_grkpbbeq0);\n  ybjc sybng nycun = oyheNycun * 1.0;\n  ybjc sybng gurgn = 0.1;\n  zrqvhzc sybng c = pynzc((zva(vPbybe.e, zrnaPbybe.e - 0.1) - 0.2) * 4.0, 0.0, 1.0);\n  zrqvhzc sybng zrnaIne = znk(znk(inePbybe.e, inePbybe.t), inePbybe.o);\n  zrqvhzc sybng xZva = 0.1;\n  ybjc irp3 erfhygPbybe;\n  xZva = (1.0 - zrnaIne / (zrnaIne + gurgn)) * c * nycun;\n  erfhygPbybe = zvk(vPbybe.eto, zrnaPbybe.eto, xZva);\n  erfhygPbybe = zvk(vPbybe.eto, erfhygPbybe, zva(1.0,nycun));\n  ty_SentPbybe = irp4(erfhygPbybe,1.0);\n}";


/***/ }),

/***/ "./sdk/src/modules/videoEffect/shaders/sharpnessShader.ts":
/*!****************************************************************!*\
  !*** ./sdk/src/modules/videoEffect/shaders/sharpnessShader.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var baseShader_1 = __importDefault(__webpack_require__(/*! ./baseShader */ "./sdk/src/modules/videoEffect/shaders/baseShader.ts"));
var shadersCodeSourceROT13_1 = __webpack_require__(/*! ./shadersCodeSourceROT13 */ "./sdk/src/modules/videoEffect/shaders/shadersCodeSourceROT13.ts");
var SharpnessShader = /** @class */ (function (_super) {
    __extends(SharpnessShader, _super);
    function SharpnessShader(gl, width, height) {
        var _this = _super.call(this, gl) || this;
        _this.width = width;
        _this.height = height;
        _this.type = "SharpnessShader";
        _this.uIntensity = null;
        _this.sharpenIntensity = 0.5; // 0-1
        _this.program = _this.makeProgram(shadersCodeSourceROT13_1.sharpnessVS, shadersCodeSourceROT13_1.sharpnessFS);
        return _this;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    SharpnessShader.prototype.setEffectConfig = function (config) {
        if (!isNaN(config.sharpenIntensity)) {
            this.sharpenIntensity = config.sharpenIntensity / 100;
        }
    };
    SharpnessShader.prototype.render = function () {
        var gl = this.gl;
        gl.uniform1f(this.uIntensity, this.sharpenIntensity * 0.5);
    };
    SharpnessShader.prototype.setConstUniforms = function () {
        var width = this.width;
        var height = this.height;
        var program = this.program;
        if (!program)
            return;
        var gl = this.gl;
        gl.useProgram(program);
        var uWidth = gl.getUniformLocation(program, "imageWidthFactor");
        gl.uniform1f(uWidth, 1 / width);
        var uHeight = gl.getUniformLocation(program, "imageHeightFactor");
        gl.uniform1f(uHeight, 1 / height);
        this.uIntensity = gl.getUniformLocation(program, "sharpness");
        gl.uniform1f(this.uIntensity, this.sharpenIntensity * 0.5);
    };
    return SharpnessShader;
}(baseShader_1.default));
exports["default"] = SharpnessShader;


/***/ }),

/***/ "./sdk/src/modules/videoEffect/videoEffect.ts":
/*!****************************************************!*\
  !*** ./sdk/src/modules/videoEffect/videoEffect.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PUBLISH_SET_BEAUTY_EFFECT = void 0;
var performanceDetector_1 = __importDefault(__webpack_require__(/*! ./performanceDetector */ "./sdk/src/modules/videoEffect/performanceDetector.ts"));
var effectManager_1 = __importDefault(__webpack_require__(/*! ./effectManager */ "./sdk/src/modules/videoEffect/effectManager.ts"));
exports.PUBLISH_SET_BEAUTY_EFFECT = "zc.p.0.sbe.1";
var VideoEffectProcessor = /** @class */ (function () {
    function VideoEffectProcessor(logger, input) {
        this.logger = logger;
        this.kind = "video";
        this._enabled = false;
        this.lastRenderTime = 0;
        this.animationFrameId = 0;
        this.backgroundLoop = null;
        this.setInput(input, true);
        this.fps = 15;
        this.detector = new performanceDetector_1.default(logger);
        this.backgroundLoop && clearTimeout(this.backgroundLoop);
        this.backgroundLoop = null;
        this.lastRenderTime = 0;
        this.manager = new effectManager_1.default(logger);
    }
    Object.defineProperty(VideoEffectProcessor.prototype, "enabled", {
        get: function () {
            return this._enabled;
        },
        set: function (val) {
            this._enabled = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VideoEffectProcessor.prototype, "output", {
        get: function () {
            return this._output;
        },
        enumerable: false,
        configurable: true
    });
    VideoEffectProcessor.prototype.setBeautyEffectOptions = function (enable, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        // 配置参数校验 options并设置
                        enable && this.manager.setEffectConfig(options);
                        if (!(this.enabled !== enable)) return [3 /*break*/, 6];
                        this.manager.setEnableBeauty(enable);
                        this.enabled !== enable &&
                            this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT +
                                " effect enabled " +
                                enable +
                                "; options: " +
                                JSON.stringify(options));
                        this.enabled = enable;
                        if (!enable) return [3 /*break*/, 3];
                        _b = this.input;
                        if (!_b) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.startEffect()];
                    case 1:
                        _b = (_c.sent());
                        _c.label = 2;
                    case 2:
                        _a = _b;
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, this.stopEffect()];
                    case 4:
                        _a = _c.sent();
                        _c.label = 5;
                    case 5:
                        _a;
                        _c.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    VideoEffectProcessor.prototype.startEffect = function () {
        return __awaiter(this, void 0, void 0, function () {
            var effectTrack, render;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " call start effect");
                        // const a = V();
                        if (!this.input) {
                            this.logger.error(exports.PUBLISH_SET_BEAUTY_EFFECT + " start effect failed, input track is null");
                            return [2 /*return*/];
                        }
                        if (this.input && this.output && this.input !== this.output) {
                            this.logger.warn(exports.PUBLISH_SET_BEAUTY_EFFECT + " video effect is already enabled");
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, this.startWebGLProcessor()];
                    case 1:
                        effectTrack = _a.sent();
                        // this.input.enabled = true;
                        return [4 /*yield*/, this.updateOutput(effectTrack)];
                    case 2:
                        // this.input.enabled = true;
                        _a.sent();
                        this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " start effect success");
                        this.detector.startRecordBeautyEffectOutput(this.fps).then(function (result) {
                            if (!result.result && _this.onOverload) {
                                var targetFPS = result.targetFPS, currentFPS = result.currentFPS;
                                _this.onOverload({
                                    targetFPS: targetFPS,
                                    currentFPS: currentFPS
                                });
                            }
                        });
                        render = function () { return __awaiter(_this, void 0, void 0, function () {
                            var currentTime, interFrameTime, realInterFrameTime;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        this.enabled && (this.animationFrameId = requestAnimationFrame(render));
                                        currentTime = Date.now(), interFrameTime = 1e3 / this.fps, realInterFrameTime = this.lastRenderTime
                                            ? currentTime - this.lastRenderTime
                                            : interFrameTime;
                                        if (!(realInterFrameTime >= interFrameTime)) return [3 /*break*/, 2];
                                        this.lastRenderTime =
                                            currentTime - (realInterFrameTime - interFrameTime);
                                        this.videoEl && this.videoEl.paused && this.videoEl.play();
                                        if (!(this.enabled && this.videoEl)) return [3 /*break*/, 2];
                                        return [4 /*yield*/, this.manager.render(this.videoEl)];
                                    case 1:
                                        _a.sent();
                                        // @ts-ignore
                                        this.output && this.output.requestFrame && this.output.requestFrame();
                                        this.detector.addFrame();
                                        _a.label = 2;
                                    case 2: return [2 /*return*/];
                                }
                            });
                        }); };
                        this.animationFrameId = requestAnimationFrame(render);
                        document.addEventListener("visibilitychange", function () {
                            if (document.hidden) {
                                var activeFrame_1 = function () {
                                    _this.enabled && _this.videoEl && _this.manager.render(_this.videoEl);
                                    _this.output &&
                                        //@ts-ignore
                                        _this.output.requestFrame &&
                                        //@ts-ignore
                                        _this.output.requestFrame();
                                    _this.detector.addFrame();
                                    _this.backgroundLoop = window.setTimeout(activeFrame_1, Math.floor(1e3 / _this.fps));
                                };
                                activeFrame_1();
                            }
                            else {
                                if (_this.backgroundLoop) {
                                    clearTimeout(_this.backgroundLoop);
                                    _this.backgroundLoop = null;
                                }
                            }
                        }, false);
                        return [2 /*return*/];
                }
            });
        });
    };
    VideoEffectProcessor.prototype.stopEffect = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " call stop effect");
                        if (this.animationFrameId) {
                            cancelAnimationFrame(this.animationFrameId);
                            this.animationFrameId = 0;
                        }
                        this.detector.stopRecordBeautyEffectOutput();
                        this.manager.release();
                        return [4 /*yield*/, this.updateOutput()];
                    case 1:
                        _a.sent();
                        if (this.removeDomTimer === undefined) {
                            this.removeDomTimer = window.setTimeout(function () {
                                if (_this.enabled === false) {
                                    _this.destroy();
                                }
                            }, 3 * 60 * 1e3);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    VideoEffectProcessor.prototype.destroy = function () {
        this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " destroy hidden elements");
        this.canvasEl && this.canvasEl.remove();
        this.videoEl && this.videoEl.remove();
        this.videoEl = this.canvasEl = undefined;
        if (this.removeDomTimer) {
            clearTimeout(this.removeDomTimer);
            this.removeDomTimer = undefined;
        }
    };
    VideoEffectProcessor.prototype.startWebGLProcessor = function () {
        return __awaiter(this, void 0, void 0, function () {
            var waitVideoPlaying, videoSettings, width, height;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.input) {
                            this.logger.error(exports.PUBLISH_SET_BEAUTY_EFFECT + " input track is null");
                            return [2 /*return*/];
                        }
                        this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " start webgl processor");
                        // 如果已有 dom 元素 不再重新创建
                        if (this.removeDomTimer) {
                            clearTimeout(this.removeDomTimer);
                            this.removeDomTimer = undefined;
                        }
                        if (!(!this.canvasEl || !this.videoEl)) return [3 /*break*/, 2];
                        this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " create elements");
                        this.canvasEl && (this.canvasEl.remove(), (this.canvasEl = undefined));
                        this.videoEl && (this.videoEl.remove(), (this.videoEl = undefined));
                        this.canvasEl = document.createElement("canvas");
                        // const warp = document.getElementsByClassName("container-fluid");
                        // warp[0].appendChild(this.canvasEl);
                        this.videoEl = document.createElement("video");
                        // warp[0].appendChild(this.videoEl);
                        this.videoEl.setAttribute("autoplay", "");
                        this.videoEl.setAttribute("muted", "");
                        this.videoEl.muted = !0;
                        this.videoEl.setAttribute("playsinline", "");
                        this.videoEl.setAttribute("style", "display:none");
                        this.videoEl.srcObject = new MediaStream([this.input]);
                        waitVideoPlaying = new Promise(function (resolve) {
                            var playingHandler = function () {
                                _this.videoEl &&
                                    _this.videoEl.removeEventListener("playing", playingHandler);
                                resolve(void 0);
                            };
                            _this.videoEl &&
                                _this.videoEl.addEventListener("playing", playingHandler);
                        });
                        this.videoEl.play();
                        return [4 /*yield*/, waitVideoPlaying];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        videoSettings = this.input.getSettings();
                        width = videoSettings.width || this.videoEl.videoWidth, height = videoSettings.height || this.videoEl.videoHeight;
                        if (videoSettings.frameRate && this.fps !== videoSettings.frameRate) {
                        }
                        if (videoSettings.frameRate && this.fps !== videoSettings.frameRate) {
                            this.fps = videoSettings.frameRate;
                            this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " set target fps: " + this.fps);
                        }
                        this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT +
                            " beauty video processor: width " +
                            videoSettings.width +
                            " height " +
                            videoSettings.height);
                        if (!width || !height) {
                            this.logger.error(exports.PUBLISH_SET_BEAUTY_EFFECT + " resolution of track is wrong");
                            return [2 /*return*/];
                        }
                        this.canvasEl.width = width;
                        this.canvasEl.height = height;
                        this.videoEl.setAttribute("width", width.toString());
                        this.videoEl.setAttribute("height", height.toString());
                        this.manager.init(width, height, this.canvasEl);
                        // @ts-ignore
                        return [2 /*return*/, this.canvasEl.captureStream().getVideoTracks()[0]];
                }
            });
        });
    };
    VideoEffectProcessor.prototype.setInput = function (videoTrack, isFirst) {
        if (isFirst === void 0) { isFirst = false; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!(videoTrack !== this.input)) return [3 /*break*/, 6];
                        if (videoTrack.kind !== this.kind) {
                            this.logger.error(exports.PUBLISH_SET_BEAUTY_EFFECT + " kind of track is not video");
                            return [2 /*return*/];
                        }
                        if (this.output && this.input === this.output) {
                            this.logger.error(exports.PUBLISH_SET_BEAUTY_EFFECT + " input track is same as effect track");
                        }
                        this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " change input track");
                        if (!isFirst) return [3 /*break*/, 5];
                        _a = this.input;
                        if (!_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.removeInput()];
                    case 1:
                        _a = (_c.sent());
                        _c.label = 2;
                    case 2:
                        _a;
                        this.input = videoTrack;
                        _b = this.enabled && !this.videoEl;
                        if (!_b) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.startEffect()];
                    case 3:
                        _b = (_c.sent());
                        _c.label = 4;
                    case 4:
                        _b;
                        return [3 /*break*/, 6];
                    case 5:
                        this.input = videoTrack;
                        this.videoEl &&
                            (this.videoEl.srcObject = new MediaStream([this.input]));
                        _c.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    VideoEffectProcessor.prototype.removeInput = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.input = undefined;
                        return [4 /*yield*/, this.stopEffect()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    VideoEffectProcessor.prototype.updateOutput = function (track) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(this.output !== track)) return [3 /*break*/, 3];
                        // let enabled = true;
                        // if (track) {
                        //   enabled = track.enabled;
                        // }
                        this._output = track;
                        _a = this.onOutputChange;
                        if (!_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.onOutputChange(this._output)];
                    case 1:
                        _a = (_b.sent());
                        _b.label = 2;
                    case 2:
                        _a;
                        _b.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    VideoEffectProcessor.prototype.onOutputChange = function (track) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2 /*return*/];
        }); });
    };
    VideoEffectProcessor.prototype.onOverload = function (config) { };
    return VideoEffectProcessor;
}());
exports["default"] = VideoEffectProcessor;


/***/ }),

/***/ "./sdk/src/util/client-util.ts":
/*!*************************************!*\
  !*** ./sdk/src/util/client-util.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientUtil = void 0;
var zego_entity_1 = __webpack_require__(/*! ../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var zego_log_event_1 = __webpack_require__(/*! ../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var checkModule_1 = __webpack_require__(/*! ../webrtc/modules/externModules/checkModule */ "./sdk/src/webrtc/modules/externModules/checkModule.ts");
var ClientUtil = /** @class */ (function () {
    function ClientUtil() {
    }
    ClientUtil.checkIllegalCharacters = function (str) {
        // const reg = /^(?=.*[a-zA-Z\d~!@#$%^&amp;*()_+`\-={}:";'&lt;&gt;?,.\/]).{1,256}$/;
        var reg = /^([0-9a-zA-Z#!$%&()`'+-;<=.>@^_~,\\*])+$/;
        var reg2 = /^[^:/]*$/g;
        return reg.test(str) && reg2.test(str);
    };
    ClientUtil.isUrl = function (str) {
        if (str.startsWith("rtmp://") ||
            (str.startsWith("https://") && str.endsWith(".flv")) ||
            (str.startsWith("https://") && str.endsWith(".m3u8"))) {
            return true;
        }
        return false;
    };
    ClientUtil.registerCallback = function (fName, option, callbackList) {
        var sf, ef;
        if (option.success) {
            sf = option.success;
            callbackList[fName + "SuccessCallback"] = sf;
        }
        if (option.error) {
            ef = option.error;
            callbackList[fName + "ErrorCallback"] = ef;
        }
    };
    ClientUtil.actionErrorCallback = function (fName, callbackList) {
        return callbackList[fName + "ErrorCallback"];
    };
    // 执行成功回调函数
    ClientUtil.actionSuccessCallback = function (fName, callbackList) {
        return callbackList[fName + "SuccessCallback"];
    };
    ClientUtil.logReportCallback = function (logEvent, dataReport, reportSeq, callbackList) {
        ClientUtil.registerCallback(logEvent, {
            success: function (reportName, eventName) {
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    args[_i - 2] = arguments[_i];
                }
                ClientUtil.dataReportEvent(dataReport, reportSeq, reportName, eventName, args);
            }
        }, callbackList);
    };
    ClientUtil.actionLogReportCallback = function (logEvent, callbackList, reportAction, eventName, args) {
        ClientUtil.actionSuccessCallback(logEvent, callbackList) &&
            ClientUtil.actionSuccessCallback(logEvent, callbackList)(reportAction, eventName);
    };
    ClientUtil.getServerError = function (code) {
        var serverErrorList = {
            1: "parse json error.",
            1001: "login is processing.",
            1002: "liveroom request error.",
            1003: "zpush connect fail.",
            1004: "zpush handshake fail.",
            1005: "zpush login fail.",
            1006: "user login state is wrong.",
            1007: "got no zpush addr",
            1008: "token error",
            1009: "dispatch error",
            1010: "token expired",
            1011: "token format error",
            2002: "biz channel error",
            1000000000: "liveroom cmd error, code:",
            1000002001: "need relogin",
            1000002002: "third token auth error",
            1000002003: "token nonce type should be int64",
            1000002004: "token appid type  should be uint32",
            1000002005: "token timeout type should be int64",
            1000002006: "token user_id type should be string",
            1000002007: "token room_id type should be string",
            1000002008: "token format error",
            1000002009: "token privilege type should be map",
            1000002010: "token expire_time type should be int64",
            1000002011: "token user_id type should be string",
            1000002012: "token not exist",
            1000002013: "token update error",
            1000002014: "token not need to check"
        };
        if (code === 0) {
            return {
                code: 0,
                message: ""
            };
        }
        var err = {
            code: 0,
            message: "liveroom cmd error"
        };
        err.code = code;
        if (code > 1000000000) {
            var errMsg = serverErrorList[code];
            if (errMsg) {
                err.message =
                    "liveroom cmd error, code: " + code + ", message: " + errMsg;
            }
            else {
                err.message = serverErrorList[1000000000] + code;
            }
        }
        else if (serverErrorList[code]) {
            //@ts-ignore
            err.message = serverErrorList[code] + " code:" + code;
        }
        else {
            err.message = "unknown error code:" + code;
        }
        return err;
    };
    ClientUtil.unregisterCallback = function (fName, callbackList) {
        delete callbackList[fName + "SuccessCallback"];
        delete callbackList[fName + "ErrorCallback"];
    };
    ClientUtil.decodeServerError = function (code, msg) {
        var err = {
            code: -1,
            message: "server error"
        };
        if (code > 1000000000) {
            err.code = code - 1000000000 + 52000000;
        }
        msg && (err.message = msg);
        return err;
    };
    ClientUtil.getLiveRoomError = function (code) {
        var prefix = 1000000000;
        var liveRoomErrMap = {
            1105: "ROOM_MAX_USER_COUNT",
            1012: "PUBLISHER_ERROR_REPETITIVE_PUBLISH_STREAM",
            // 2002: 'ROOM_ERROR_AUTHENTICATION_FAILED',
            2002: "TOKEN_ERROR",
            2003: "ROOM_ERROR_LOGIN_TIMEOUT",
            2010: "TOKEN_ERROR" // token expire_time type should be int64
        };
        var accessSvrErrMap = {
            1: "PARSE_JSON_ERROR",
            1001: "LOGIN_PROCESSING",
            1002: "LIVEROMM_REQUEST_ERROR",
            1003: "ZPUSH_REQUEST_FAIL",
            1004: "ZPUSH_REQUEST_FAIL",
            1005: "ZPUSH_REQUEST_FAIL",
            1006: "LOGIN_STATE_WRONG",
            1007: "ZPUSH_REQUEST_FAIL",
            1008: "TOKEN_ERROR",
            1009: "DIAPATCH_ERROR",
            1010: "TOKEN_EXPIRED",
            1011: "TOKEN_ERROR",
            1012: "SUBCMD_ERROR",
            1101: "ZEGO_AUTH_ERROR",
            2001: "BIZ_CHANNEL_ERROR",
            2002: "BIZ_CHANNEL_ERROR"
        };
        if (code > 1000000000) {
            return liveRoomErrMap[code - prefix] || "";
        }
        else {
            return accessSvrErrMap[code] || "ROOM_INNER_ERROR";
        }
    };
    ClientUtil.getKickoutError = function (code) {
        var err = {};
        switch (code) {
            case 1:
                err.code = 63000001;
                err.message = "zpush multiple login kickout";
                err.name = "MULTIPLE_LOGIN_KICKOUT";
                break;
            case 2:
                err.code = 63000002;
                err.message = "zpush manual kickout";
                err.name = "MANUAL_KICKOUT";
                break;
            case 3:
                err.code = 63000003;
                err.message = "kickout reason = " + code;
                break;
            case 4:
                err.code = 63000004;
                err.message = "zpush multiple login kickout";
                err.name = "MULTIPLE_LOGIN_KICKOUT";
                break;
            case 5:
                err.code = 63000005;
                err.message = "zpush token expired";
                err.name = "TOKEN_EXPIRED";
                break;
            default:
                err.code = code;
                err.message = "kickout reason = " + code;
                break;
        }
        return err;
    };
    ClientUtil.dataReportEvent = function (dataReport, reportSeq, reportName, eventName, args) {
        switch (reportName) {
            case "eventStart":
                dataReport.eventStart(reportSeq, eventName);
                break;
            case "eventEndWithMsgInfo":
                dataReport.eventEndWithMsgInfo(reportSeq, eventName, args[0]);
                break;
            case "addEventMsg":
                dataReport.addEventMsg(reportSeq, eventName, args[0], args[1]);
                break;
            case "addEvent":
                dataReport.addEvent(reportSeq, eventName);
                break;
            case "eventEnd":
                dataReport.eventEnd(reportSeq, eventName);
                break;
            case "addMsgInfo":
                dataReport.addMsgInfo(reportSeq, args[0]);
                break;
            default:
                break;
        }
    };
    ClientUtil.isKeepTryLogin = function (code) {
        switch (code) {
            case 1002: //liveroom connect error
            case 1003: //zpush connect error
                return true;
            default:
                return false;
        }
    };
    ClientUtil.mergeStreamList = function (idName, oldStreamList, newStreamList, callbackResult) {
        var addStreamList = [];
        var delStreamList = [];
        var updateStreamList = [];
        var flag;
        if (!newStreamList) {
            newStreamList = [];
        }
        for (var i = 0; i < newStreamList.length; i++) {
            if (newStreamList[i].anchor_id_name == idName ||
                newStreamList[i].id_name == idName ||
                newStreamList[i].user_id == idName) {
                continue;
            }
            flag = false;
            for (var j = 0; j < oldStreamList.length; j++) {
                if (newStreamList[i].stream_id === oldStreamList[j].stream_id) {
                    if (newStreamList[i].extra_info !== oldStreamList[j].extra_info) {
                        updateStreamList.push(newStreamList[i]);
                    }
                    flag = true;
                    break;
                }
            }
            if (!flag) {
                addStreamList.push(newStreamList[i]);
            }
        }
        for (var k = 0; k < oldStreamList.length; k++) {
            flag = false;
            for (var n = 0; n < newStreamList.length; n++) {
                if (oldStreamList[k].stream_id === newStreamList[n].stream_id) {
                    flag = true;
                    break;
                }
            }
            if (!flag) {
                delStreamList.push(oldStreamList[k]);
            }
        }
        oldStreamList.splice(0);
        for (var i = 0; i < newStreamList.length; i++) {
            oldStreamList.push(newStreamList[i]);
        }
        callbackResult(addStreamList, delStreamList, updateStreamList);
    };
    ClientUtil.checkInteger = function (num, positive) {
        if (positive == false)
            return typeof num === "number" && num % 1 === 0 && num >= 0;
        return typeof num === "number" && num % 1 === 0 && num > 0;
    };
    ClientUtil.checkValidNumber = function (param, min, max) {
        min = min || 1;
        max = max || 1 * 1e4;
        return (typeof param === "number" &&
            param % 1 == 0 &&
            param >= min &&
            param <= max);
    };
    //生成随机数
    ClientUtil.uuid = function (len, radix) {
        var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");
        var uuid = [];
        var i;
        radix = radix || chars.length;
        if (len) {
            // Compact form
            for (i = 0; i < len; i++)
                uuid[i] = chars[0 | (Math.random() * radix)];
        }
        else {
            // rfc4122, version 4 form
            var r = void 0;
            // rfc4122 requires these characters
            uuid[8] = uuid[13] = uuid[18] = uuid[23] = "-";
            uuid[14] = "4";
            // Fill in random data. At i==19 set the high bits of clock sequence as
            // per rfc4122, sec. 4.1.5
            for (i = 0; i < 36; i++) {
                if (!uuid[i]) {
                    r = 0 | (Math.random() * 16);
                    uuid[i] = chars[i == 19 ? (r & 0x3) | 0x8 : r];
                }
            }
        }
        return uuid.join("");
    };
    ClientUtil.supportDetection = function (screenShotReady, success, checkLevel, type) {
        return __awaiter(this, void 0, void 0, function () {
            var result, videoEle, hasGetUserMedia, isOutRule, video, err_1, audio, err_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        result = {
                            webRTC: false,
                            customCapture: false,
                            camera: false,
                            microphone: false,
                            videoCodec: {
                                H264: false,
                                H265: false,
                                VP8: false,
                                VP9: false
                            },
                            screenSharing: screenShotReady,
                            errInfo: {}
                        };
                        if (type && type === "screenSharing") {
                            success({
                                result: screenShotReady,
                                errInfo: result.errInfo
                            });
                            return [2 /*return*/];
                        }
                        if (!type || type === "customCapture") {
                            videoEle = document.createElement("video");
                            // @ts-ignore
                            if (videoEle["captureStream"] || videoEle["mozCaptureStream"]) {
                                result.customCapture = true;
                            }
                            if (type === "customCapture") {
                                success({
                                    result: result.customCapture,
                                    errInfo: result.errInfo
                                });
                                return [2 /*return*/];
                            }
                        }
                        hasGetUserMedia = navigator &&
                            navigator.mediaDevices &&
                            navigator.mediaDevices.getUserMedia;
                        isOutRule = window.location.protocol !== "https:" &&
                            window.location.protocol !== "file:" &&
                            window.location.hostname.indexOf("127.0.0.1") == -1 &&
                            window.location.hostname.indexOf("localhost") == -1;
                        if (!(!type || type === "camera" || type === "microphone")) return [3 /*break*/, 9];
                        if (!!!hasGetUserMedia) return [3 /*break*/, 9];
                        if (!isOutRule) return [3 /*break*/, 1];
                        result.camera = false;
                        console.error("webrtc requires https or localhost");
                        return [3 /*break*/, 9];
                    case 1:
                        if (!(!type || type === "camera")) return [3 /*break*/, 5];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, navigator.mediaDevices.getUserMedia({
                                video: true
                            })];
                    case 3:
                        video = _a.sent();
                        video &&
                            (result.camera = true) &&
                            video.getTracks().forEach(function (track) { return track.stop(); });
                        return [3 /*break*/, 5];
                    case 4:
                        err_1 = _a.sent();
                        result.errInfo.camera = {
                            name: err_1.name,
                            message: err_1.message
                        };
                        console.error("camera devices detect error: ", err_1.name, err_1.message);
                        return [3 /*break*/, 5];
                    case 5:
                        if (!(!type || type === "microphone")) return [3 /*break*/, 9];
                        _a.label = 6;
                    case 6:
                        _a.trys.push([6, 8, , 9]);
                        return [4 /*yield*/, navigator.mediaDevices.getUserMedia({
                                audio: true
                            })];
                    case 7:
                        audio = _a.sent();
                        audio &&
                            (result.microphone = true) &&
                            audio.getTracks().forEach(function (track) { return track.stop(); });
                        return [3 /*break*/, 9];
                    case 8:
                        err_2 = _a.sent();
                        result.errInfo.microphone = {
                            name: err_2.name,
                            message: err_2.message
                        };
                        console.error("microphone devices detect error: ", err_2.name, err_2.message);
                        return [3 /*break*/, 9];
                    case 9:
                        if (type === "camera" || type === "microphone") {
                            success({
                                result: result[type],
                                errInfo: result.errInfo
                            });
                            return [2 /*return*/];
                        }
                        this.supportVideoCodeType(function (rtcCodec, err) {
                            if (!type) {
                                result.videoCodec.H264 = rtcCodec.H264;
                                result.videoCodec.H265 = rtcCodec.H265;
                                result.videoCodec.VP8 = rtcCodec.VP8;
                                result.videoCodec.VP9 = rtcCodec.VP9;
                                result.webRTC = rtcCodec.webRTC;
                            }
                            if (err) {
                                if (typeof err === "string") {
                                    result.errInfo.extendedDate = err;
                                }
                                else {
                                    result.errInfo.webRTC = {
                                        name: err.name,
                                        message: err.message
                                    };
                                }
                                console.error("videoCodec detect error: " + err);
                            }
                            success &&
                                success(!type
                                    ? result
                                    : {
                                        result: rtcCodec[type],
                                        errInfo: result.errInfo
                                    });
                        }, checkLevel, type);
                        return [2 /*return*/];
                }
            });
        });
    };
    ClientUtil.getDevices = function (deviceInfoCallback, error) {
        if (navigator.mediaDevices === undefined ||
            navigator.mediaDevices.enumerateDevices === undefined) {
            if (error) {
                error(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskEnumDevices.error.kBrowserNotSupportError);
            }
            return;
        }
        navigator.mediaDevices
            .enumerateDevices()
            .then(function (deviceInfos) {
            var microphone = [];
            var speaker = [];
            var camera = [];
            for (var i = 0; i < deviceInfos.length; i++) {
                var deviceInfo = deviceInfos[i];
                if (deviceInfo.kind === "audioinput") {
                    microphone.push({
                        deviceName: deviceInfo.label,
                        deviceID: deviceInfo.deviceId
                    });
                }
                if (deviceInfo.kind === "audiooutput") {
                    speaker.push({
                        deviceName: deviceInfo.label,
                        deviceID: deviceInfo.deviceId
                    });
                }
                if (deviceInfo.kind === "videoinput") {
                    camera.push({
                        deviceName: deviceInfo.label,
                        deviceID: deviceInfo.deviceId
                    });
                }
            }
            if (deviceInfoCallback) {
                deviceInfoCallback({
                    microphones: microphone,
                    speakers: speaker,
                    cameras: camera
                });
            }
        })
            .catch(function (err) {
            console.error("enumerate devices wrong " + err);
            error &&
                error(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskEnumDevices.error.kEnumDevicesError);
        });
    };
    ClientUtil.compareVersion = function (v1, v2) {
        v1 = v1.split(".");
        v2 = v2.split(".");
        var len = Math.max(v1.length, v2.length);
        while (v1.length < len) {
            v1.push("0");
        }
        while (v2.length < len) {
            v2.push("0");
        }
        for (var i = 0; i < len; i++) {
            var num1 = parseInt(v1[i]);
            var num2 = parseInt(v2[i]);
            if (num1 > num2) {
                return 1;
            }
            else if (num1 < num2) {
                return -1;
            }
        }
        return 0;
    };
    ClientUtil.isSupportLive = function (sucCall, errCall) {
        var resultList = {
            10001: "当前微信版本过低，无法使用相关组件",
            10002: "需要摄像头和录音功能的授权"
        };
        var version = wx.getSystemInfoSync().SDKVersion;
        var res = {
            code: 0,
            msg: ""
        };
        if (this.compareVersion(version, "1.7.0") < 0) {
            res = {
                code: 10001,
                msg: resultList[10001]
            };
            sucCall && sucCall(res);
        }
        wx.getSetting({
            success: function (_a) {
                var authSetting = _a.authSetting;
                if (!authSetting["scope.camera"] || !authSetting["scope.record"]) {
                    res = {
                        code: 10002,
                        msg: resultList[10002]
                    };
                }
                sucCall && sucCall(res);
            },
            fail: function (err) {
                console.error("get setting error", err);
                errCall && errCall(err);
            }
        });
    };
    ClientUtil.supportVideoCodeType = function (sucCall, checkLevel, type) {
        return __awaiter(this, void 0, void 0, function () {
            var rtcCodec, checkModule, res, e_1, errorInfo_1, allType_2, promiseList, _i, allType_1, allTypeItem, checkModule;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        rtcCodec = {
                            webRTC: false,
                            H264: false,
                            VP8: false,
                            VP9: false,
                            H265: false
                        };
                        if (!type) return [3 /*break*/, 2];
                        if (!(checkLevel === 1 && (type === "VP8" || type === "H264"))) return [3 /*break*/, 2];
                        checkModule = new checkModule_1.CheckModule();
                        return [4 /*yield*/, checkModule.checkSupportByType(type)];
                    case 1:
                        res = _a.sent();
                        if (typeof res === "boolean") {
                            rtcCodec[type] = res;
                            return [2 /*return*/, sucCall(rtcCodec)];
                        }
                        else {
                            rtcCodec[type] = false;
                            return [2 /*return*/, sucCall(rtcCodec, res)];
                        }
                        _a.label = 2;
                    case 2:
                        if (!(type === "webRTC" || checkLevel === 1)) return [3 /*break*/, 7];
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, new RTCPeerConnection().createOffer({
                                offerToReceiveAudio: true,
                                offerToReceiveVideo: true
                            })];
                    case 4:
                        _a.sent();
                        rtcCodec.webRTC = true;
                        return [3 /*break*/, 6];
                    case 5:
                        e_1 = _a.sent();
                        sucCall && sucCall(rtcCodec, e_1);
                        return [3 /*break*/, 6];
                    case 6:
                        if (type === "webRTC") {
                            return [2 /*return*/, sucCall(rtcCodec)];
                        }
                        _a.label = 7;
                    case 7:
                        if (checkLevel === 1) {
                            errorInfo_1 = "";
                            allType_2 = ["VP8", "H264"];
                            promiseList = [];
                            for (_i = 0, allType_1 = allType_2; _i < allType_1.length; _i++) {
                                allTypeItem = allType_1[_i];
                                checkModule = new checkModule_1.CheckModule();
                                promiseList.push(checkModule.checkSupportByType(allTypeItem));
                            }
                            Promise.all(promiseList).then(function (resList) {
                                resList.forEach(function (item, index) {
                                    if (typeof item === "boolean") {
                                        rtcCodec[allType_2[index]] = true;
                                    }
                                    else {
                                        rtcCodec[allType_2[index]] = false;
                                        errorInfo_1 = item;
                                    }
                                });
                                !!errorInfo_1 ? sucCall(rtcCodec, errorInfo_1) : sucCall(rtcCodec);
                            });
                            return [2 /*return*/];
                        }
                        try {
                            new RTCPeerConnection()
                                .createOffer({
                                offerToReceiveAudio: true,
                                offerToReceiveVideo: true
                            })
                                .then(function (desc) {
                                rtcCodec.webRTC = true;
                                if (desc && desc.sdp) {
                                    var sdplist = desc.sdp.split("\r\n");
                                    rtcCodec.H264 = sdplist.some(function (item) {
                                        return item.startsWith("a=rtpmap:") && item.indexOf("H264/") > -1;
                                    });
                                    if (type === "H264") {
                                        return sucCall(rtcCodec);
                                    }
                                    rtcCodec.VP8 = sdplist.some(function (item) {
                                        return item.startsWith("a=rtpmap:") && item.indexOf("VP8/") > -1;
                                    });
                                    if (type === "VP8") {
                                        return sucCall(rtcCodec);
                                    }
                                    rtcCodec.VP9 = sdplist.some(function (item) {
                                        return item.startsWith("a=rtpmap:") && item.indexOf("VP9/") > -1;
                                    });
                                    rtcCodec.H265 = sdplist.some(function (item) {
                                        return item.startsWith("a=rtpmap:") && item.indexOf("H265/") > -1;
                                    });
                                    sucCall && sucCall(rtcCodec);
                                }
                            });
                        }
                        catch (error) {
                            sucCall && sucCall(rtcCodec, error);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    ClientUtil.getPublisherStateType = function (type) {
        return type == 0 || type == 1
            ? type == 0
                ? "PUBLISHING"
                : "NO_PUBLISH"
            : "PUBLISH_REQUESTING";
    };
    ClientUtil.getPlayerStateType = function (type) {
        return type == 0 || type == 1
            ? type == 0
                ? "PLAYING"
                : "NO_PLAY"
            : "PLAY_REQUESTING";
    };
    ClientUtil.getSteamUpdateType = function (type) {
        return type == 0 ? "DELETE" : "ADD";
    };
    ClientUtil.checkScreenParams = function (screen, errorCallback) {
        if (typeof screen === "object" && screen.videoQuality !== undefined) {
            if (!ClientUtil.checkInteger(screen.videoQuality)) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " videoQuality must be integer number");
                return false;
            }
        }
        if (typeof screen === "object" && screen.sourceID !== undefined) {
            if (typeof screen.sourceID !== "string") {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " sourceID must be string");
                return false;
            }
        }
        if (typeof screen === "object" && screen.videoQuality === 4) {
            if (screen.bitRate === undefined) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " bitrate is required when videoQuality is 4");
                return false;
            }
            else if (!ClientUtil.checkInteger(screen.bitRate)) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " bitrate must be integer number");
                return false;
            }
            else if (screen.bitRate > 10240) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " bitrate cannot greater than 10 Mbps");
                return false;
            }
            if (screen.frameRate === undefined) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " frameRate is required when videoQuality is 4");
                return false;
            }
            else if (!ClientUtil.checkInteger(screen.frameRate)) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " frameRate must be integer number");
                return false;
            }
            if (screen.width === undefined) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " width is required when videoQuality is 4");
                return false;
            }
            else if (!ClientUtil.checkInteger(screen.width)) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " width must be integer number");
                return false;
            }
            if (screen.height === undefined) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " height is required when videoQuality is 4");
                return false;
            }
            else if (!ClientUtil.checkInteger(screen.height)) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " height must be integer number");
                return false;
            }
        }
        return true;
    };
    ClientUtil.checkCameraParams = function (cameras, errorCallback) {
        if (!cameras.width || !ClientUtil.checkValidNumber(cameras.width)) {
            errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " width must be integer number");
            return false;
        }
        if (!cameras.height || !ClientUtil.checkValidNumber(cameras.height)) {
            errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " height must be integer number");
            return false;
        }
        if (!cameras.frameRate || !ClientUtil.checkValidNumber(cameras.frameRate)) {
            errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " frameRate must be integer number");
            return false;
        }
        if (!cameras.bitRate || !ClientUtil.checkValidNumber(cameras.bitRate)) {
            errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " bitrate must be integer number");
            return false;
        }
        return true;
    };
    ClientUtil.isParamEmpty = function (param) {
        if (param === undefined || param === null || param === "") {
            return false;
        }
        else {
            return true;
        }
    };
    ClientUtil.isTypeString = function (param) {
        if (typeof param !== "string") {
            return false;
        }
        else {
            return true;
        }
    };
    ClientUtil.isTooLong = function (param, len) {
        if (param.length >= len) {
            return false;
        }
        else {
            return true;
        }
    };
    ClientUtil.isReDispatch = function (error) {
        var result = error.message.match(/action:(\d+)/);
        var action = result ? Number(result[1]) : NaN;
        return ([
            zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kTTLOverTimeError,
            zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kClientIPChangedError,
            zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kTTLOverTimeError,
            zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kClientIPChangedError
        ].includes(error) || [6].includes(action));
    };
    ClientUtil.arrAvg = function (arr, val, shiftLen) {
        arr.push(val);
        if (arr.length > shiftLen) {
            arr.shift();
        }
        var sum = arr.reduce(function (prev, current) {
            return prev + current;
        });
        return sum / arr.length;
    };
    ClientUtil.getNetQuality = function (rtt, lostRate, jitter) {
        if (typeof jitter !== "undefined") {
            var jitterWeight = 0.15;
            var lostRTTWeight = 0.85;
            var jitterQuality = this.calcQualityOfJitter(jitter);
            var lostRTTQuality = Math.min(this.calcQualityOfRtt(rtt), this.calcQualityOfLostRate(lostRate, false));
            var quality = jitterWeight * jitterQuality + lostRTTWeight * lostRTTQuality;
            return quality;
        }
        else {
            return Math.min(this.calcQualityOfRtt(rtt), this.calcQualityOfLostRate(lostRate, true));
        }
    };
    ClientUtil.calcQualityOfRtt = function (rtt) {
        if (rtt < 600) {
            return 97 - Math.pow(9.0e-2 * rtt, 1.1);
        }
        else {
            return 18 * Math.exp(2.0e-3 * (600 - rtt));
        }
    };
    ClientUtil.calcQualityOfJitter = function (jitter) {
        if (jitter <= 50) {
            return 98 - Math.pow(jitter, 1.15);
        }
        else {
            return zego_entity_1.QUALITY_CONSTANT.PoorMinQuality;
        }
    };
    ClientUtil.calcQualityOfLostRate = function (lostRate, isProbe) {
        if (isProbe) {
            var _lossRate = lostRate;
            if (_lossRate <= 55) {
                return 99 - Math.pow(0.8 * _lossRate, 1.18);
            }
            else {
                return zego_entity_1.QUALITY_CONSTANT.PoorMinQuality;
            }
        }
        else {
            var _lostRate = lostRate * 100;
            if (_lostRate <= 40) {
                return 96 - Math.pow(_lostRate, 1.22);
            }
            else {
                return zego_entity_1.QUALITY_CONSTANT.PoorMinQuality;
            }
        }
    };
    ClientUtil.quality2QualityGrade = function (quality) {
        var grade = zego_entity_1.QualityGrade.Unknown;
        if (quality >= zego_entity_1.QUALITY_CONSTANT.ExcellentMinQuality) {
            grade = zego_entity_1.QualityGrade.Excellent;
        }
        else if (quality >= zego_entity_1.QUALITY_CONSTANT.GoodMinQuality) {
            grade = zego_entity_1.QualityGrade.Good;
        }
        else if (quality >= zego_entity_1.QUALITY_CONSTANT.MiddleMinQuality) {
            grade = zego_entity_1.QualityGrade.Middle;
        }
        else if (quality >= zego_entity_1.QUALITY_CONSTANT.PoorMinQuality) {
            grade = zego_entity_1.QualityGrade.Poor;
        }
        else {
            grade = zego_entity_1.QualityGrade.Die;
        }
        return grade;
    };
    return ClientUtil;
}());
exports.ClientUtil = ClientUtil;


/***/ }),

/***/ "./sdk/src/util/retryHandler.ts":
/*!**************************************!*\
  !*** ./sdk/src/util/retryHandler.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RetryHandler = void 0;
var RetryHandler = /** @class */ (function () {
    function RetryHandler() {
        this.RETRY_MAX_TIME = 300;
        this.RETRY_START_TIME_INTERVAL = 4;
        this.RETRY_CONTINUE_COUNT = 2;
        this.RETRY_MAX_TIME_INTERVAL = 32;
        this.retryStartTime = 0;
        this.retryActiveCount = 1;
        this.isOverTime = false;
    }
    //初始化重试
    RetryHandler.prototype.init = function (retryMaxTime, startTimeInterval, retryContinueCount, maxTimeInterval) {
        this.invalid();
        this.stopMaxTime();
        this.isOverTime = false;
        if (typeof retryMaxTime == "number" && retryMaxTime < 3600) {
            this.RETRY_MAX_TIME = retryMaxTime;
        }
        if (typeof startTimeInterval == "number") {
            this.RETRY_START_TIME_INTERVAL = startTimeInterval;
        }
        if (typeof retryContinueCount == "number") {
            this.RETRY_CONTINUE_COUNT = retryContinueCount;
        }
        if (typeof maxTimeInterval == "number") {
            this.RETRY_MAX_TIME_INTERVAL = maxTimeInterval;
        }
    };
    //暂停重试
    RetryHandler.prototype.invalid = function () {
        this.retryTimer && clearTimeout(this.retryTimer);
        this.retryTimer = null;
        this.retryStartTime = 0;
        this.retryActiveCount = 1;
    };
    return RetryHandler;
}());
exports.RetryHandler = RetryHandler;


/***/ }),

/***/ "./sdk/src/util/sdpUtil.ts":
/*!*********************************!*\
  !*** ./sdk/src/util/sdpUtil.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SdpUtil = void 0;
var SdpUtil = /** @class */ (function () {
    function SdpUtil() {
    }
    SdpUtil.zegoSdp = function (sdp) {
        var sdpLines = sdp.split("\r\n");
        var h264_id = [], opus_id = [];
        sdpLines.forEach(function (item) {
            var _id = item.match(/a=rtpmap:(\d+)\s+((H264\/90000)|(opus\/48000\/2))/);
            if (_id && _id[1] && _id[2]) {
                //@ts-ignore
                _id[2] === "H264/90000" && h264_id.push(_id[1]);
                //@ts-ignore
                _id[2] === "opus/48000/2" && opus_id.push(_id[1]);
            }
        });
        var newSdpLines = [];
        sdpLines.map(function (item) {
            //去掉非h64和opus编解码
            var isH264_opus = true;
            var other_needed = true;
            var _matched = item.match(/((a=rtcp-fb:)|(a=rtpmap:)|(a=fmtp:))(\d+)/);
            if (_matched && _matched[5]) {
                if (!__spreadArrays(h264_id, opus_id).some(function (item) { return item == _matched[5]; })) {
                    isH264_opus = false;
                }
            }
            //去掉非h64和opus编解码 m=video
            if (item.indexOf("m=video") > -1) {
                var _videoDesc = item.split(" ");
                item = __spreadArrays([_videoDesc[0], _videoDesc[1], _videoDesc[2]], h264_id).join(" ");
            }
            else if (item.indexOf("m=audio") > -1) {
                var _videoDesc = item.split(" ");
                item = __spreadArrays([_videoDesc[0], _videoDesc[1], _videoDesc[2]], opus_id).join(" ");
            }
            //a=ssrc 非cname
            // if (item.indexOf ('a=ssrc') > -1 && item.indexOf ('cname') < 0) {
            //         other_needed = false
            // }
            //@ts-ignore
            isH264_opus && other_needed && newSdpLines.push(item);
        });
        return newSdpLines.join("\r\n");
    };
    SdpUtil.getSDPByVideDecodeType = function (sdp, type, isSoft) {
        var videoDecodeTypes = {
            str: "",
            arr: [],
            obj: {
                H264: [],
                H265: [],
                VP8: [],
                VP9: [],
                OTHER: []
            }
        };
        if (!sdp.includes("m=video")) {
            return sdp;
        }
        var videoHead = /m=video.+/.exec(sdp)[0];
        videoHead = videoHead.match(/[\s|\d]+/g)[1].replace(" ", "");
        videoDecodeTypes.str = videoHead;
        videoDecodeTypes.arr = videoDecodeTypes.str.split(" ");
        videoDecodeTypes.arr.forEach(function (decodeType) {
            var reg = new RegExp("a=rtpmap:" + decodeType + ".+");
            var matched = reg.exec(sdp)[0];
            if (matched.includes("H264")) {
                videoDecodeTypes.obj.H264.push(decodeType);
            }
            else if (matched.includes("H265")) {
                videoDecodeTypes.obj.H265.push(decodeType);
            }
            else if (matched.includes("VP8")) {
                videoDecodeTypes.obj.VP8.push(decodeType);
            }
            else if (matched.includes("VP9")) {
                videoDecodeTypes.obj.VP9.push(decodeType);
            }
            else {
                videoDecodeTypes.obj.OTHER.push(decodeType);
            }
        });
        videoDecodeTypes.obj.OTHER.forEach(function (otherType) {
            var reg = new RegExp("a=fmtp:" + otherType + ".+apt=(\\d+)");
            var matchedArr = reg.exec(sdp);
            var matched = matchedArr && matchedArr[1];
            if (matched) {
                if (videoDecodeTypes.obj.H264.includes(matched)) {
                    videoDecodeTypes.obj.H264.push(otherType);
                }
                else if (videoDecodeTypes.obj.H265.includes(matched)) {
                    videoDecodeTypes.obj.H265.push(otherType);
                }
                else if (videoDecodeTypes.obj.VP8.includes(matched)) {
                    videoDecodeTypes.obj.VP8.push(otherType);
                }
                else if (videoDecodeTypes.obj.VP9.includes(matched)) {
                    videoDecodeTypes.obj.VP9.push(otherType);
                }
            }
        });
        var targetArr = [];
        if (type === "VP9") {
            targetArr = __spreadArrays(videoDecodeTypes.obj.H265, videoDecodeTypes.obj.H264, videoDecodeTypes.obj.VP8);
        }
        else if (type === "VP8") {
            targetArr = __spreadArrays(videoDecodeTypes.obj.H265, videoDecodeTypes.obj.H264, videoDecodeTypes.obj.VP9);
        }
        else if (type === "H264") {
            targetArr = __spreadArrays(videoDecodeTypes.obj.H265, videoDecodeTypes.obj.VP8, videoDecodeTypes.obj.VP9);
        }
        else if (type === "H265") {
            targetArr = __spreadArrays(videoDecodeTypes.obj.VP8, videoDecodeTypes.obj.H264, videoDecodeTypes.obj.VP9);
        }
        // targetArr.forEach(itype => {
        //         let currentIndex = videoDecodeTypes.arr.indexOf(itype);
        //         let reg;
        //         if( currentIndex!==(videoDecodeTypes.arr.length - 1)){
        //                 reg = new RegExp('a=rtpmap:' + itype + '[\\s\\S]+a=rtpmap:' + videoDecodeTypes.arr[currentIndex+1])
        //                 sdp = sdp.replace(reg, 'a=rtpmap:' + videoDecodeTypes.arr[currentIndex+1]);
        //         }else{
        //                 reg = new RegExp ('a=rtpmap:' + itype + '[\\s\\S]+a=fmtp:' + itype + '.+\\s\\n')
        //                 sdp = sdp.replace(reg, '');
        //         }
        //         videoDecodeTypes.arr.splice(currentIndex,1)
        //         //console.log('targetArr',reg)
        // });
        if (isSoft && type == "H264") {
            //H264 开启软编
            var h264Arr_1 = [];
            videoDecodeTypes.obj.H264.forEach(function (itype) {
                var regFmtp = new RegExp("a=fmtp:" + itype + ".+\\s\\n", "g");
                var fmtpRes = regFmtp.exec(sdp);
                if (!!!(fmtpRes === null || fmtpRes === void 0 ? void 0 : fmtpRes.find(function (str) { return str.includes("profile-level-id=42e01f"); }))) {
                    h264Arr_1.push(itype);
                }
            });
            if (h264Arr_1.length == videoDecodeTypes.obj.H264.length) {
                h264Arr_1 = [];
            }
            targetArr = targetArr.concat(h264Arr_1);
        }
        targetArr.forEach(function (itype) {
            var currentIndex = videoDecodeTypes.arr.indexOf(itype);
            videoDecodeTypes.arr.splice(currentIndex, 1);
            var regRtpmap = new RegExp("a=rtpmap:" + itype + ".+\\s\\n", "g");
            var regRtcpfb = new RegExp("a=rtcp-fb:" + itype + ".+\\s\\n", "g");
            var regFmtp = new RegExp("a=fmtp:" + itype + ".+\\s\\n", "g");
            sdp = sdp.replace(regRtpmap, "");
            sdp = sdp.replace(regRtcpfb, "");
            sdp = sdp.replace(regFmtp, "");
        });
        sdp = sdp.replace(videoHead, videoDecodeTypes.arr.join(" "));
        return sdp;
    };
    return SdpUtil;
}());
exports.SdpUtil = SdpUtil;


/***/ }),

/***/ "./sdk/src/webrtc/index.ts":
/*!*********************************!*\
  !*** ./sdk/src/webrtc/index.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoWebRTC = void 0;
var zego_entity_1 = __webpack_require__(/*! ../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var client_util_1 = __webpack_require__(/*! ../util/client-util */ "./sdk/src/util/client-util.ts");
var stateCenter_1 = __webpack_require__(/*! ../common/stateCenter */ "./sdk/src/common/stateCenter.ts");
var action_1 = __webpack_require__(/*! ../common/action */ "./sdk/src/common/action.ts");
var zego_log_event_1 = __webpack_require__(/*! ../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var modules_1 = __webpack_require__(/*! ./modules */ "./sdk/src/webrtc/modules/index.ts");
var zego_streamCenter_web_1 = __webpack_require__(/*! ./modules/zego.streamCenter.web */ "./sdk/src/webrtc/modules/zego.streamCenter.web.ts");
var streamHandler_1 = __webpack_require__(/*! ../common/streamHandler */ "./sdk/src/common/streamHandler.ts");
var zego_publish_1 = __webpack_require__(/*! ./modules/publishModules/zego.publish */ "./sdk/src/webrtc/modules/publishModules/zego.publish.ts");
// @ts-ignore
var adapter = __importStar(__webpack_require__(/*! ./adapter */ "./sdk/src/webrtc/adapter.js"));
var zego_preview_1 = __webpack_require__(/*! ./modules/publishModules/zego.preview */ "./sdk/src/webrtc/modules/publishModules/zego.preview.ts");
var playModules_1 = __webpack_require__(/*! ./modules/playModules */ "./sdk/src/webrtc/modules/playModules/index.ts");
var publishModules_1 = __webpack_require__(/*! ./modules/publishModules */ "./sdk/src/webrtc/modules/publishModules/index.ts");
var streamSignal_1 = __webpack_require__(/*! ./modules/streamSignal */ "./sdk/src/webrtc/modules/streamSignal.ts");
var setting_config_1 = __webpack_require__(/*! ../common/setting.config */ "./sdk/src/common/setting.config.ts");
var setting_config_2 = __webpack_require__(/*! ../common/setting.config */ "./sdk/src/common/setting.config.ts");
var ZegoWebRTC = /** @class */ (function () {
    function ZegoWebRTC(logger, dataReport, rtm, ENV) {
        var _this = this;
        if (ENV === void 0) { ENV = 0; }
        this.mediaEleSources = [];
        this.logger = logger;
        this.dataReport = dataReport;
        this.ac = new (typeof webkitAudioContext !== "undefined"
            ? webkitAudioContext
            : AudioContext)();
        this.checkAudioContext();
        this.stateCenter = new stateCenter_1.StateCenter(this.logger, this.dataReport);
        this.stateCenter.clientType = "webrtc";
        this.stateCenter.type = ENV === 2 ? "PRIVATE" : "PUBLIC";
        this.RTM = rtm;
        this.streamCenter = new zego_streamCenter_web_1.ZegoStreamCenterWeb(this.logger, this.stateCenter, this.dataReport, this.RTM, this.ac, this.mediaEleSources);
        this.rtcModules = new modules_1.RTCModules(this.logger, this.dataReport, this.stateCenter, this.streamCenter, this.RTM, this.ac);
        this.stateCenter.getSeq = zego_entity_1.getSeq;
        this.stateCenter.getReportSeq = zego_entity_1.getReportSeq;
        this.stateCenter.networkState = navigator
            ? navigator.onLine
                ? zego_entity_1.ENUM_NETWORK_STATE.online
                : zego_entity_1.ENUM_NETWORK_STATE.offline
            : zego_entity_1.ENUM_NETWORK_STATE.online;
        this.stateCenter.browser = adapter.browserDetails.browser;
        this.stateCenter.settingConfig = new setting_config_2.ZegoSettingConfig();
        this.RTM.cloudSetting.setEnvVariable("sdk_version", zego_entity_1.PROTO_VERSION);
        // 获取云控本地配置
        this.RTM.cloudSetting
            .getSettingCache(setting_config_1.RTC)
            .then(function (streamConfig) {
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.CONSTRUCTOR +
                " streamConfig " +
                JSON.stringify(streamConfig));
            // if (streamConfig) {
            var reportSeq = zego_entity_1.getReportSeq();
            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCloudSettingCache.event);
            _this.dataReport.addMsgInfo(reportSeq, {
                files: [
                    {
                        name: setting_config_1.RTC,
                        content: streamConfig === null || streamConfig === void 0 ? void 0 : streamConfig.setting,
                        versions: streamConfig === null || streamConfig === void 0 ? void 0 : streamConfig.versions
                    }
                ]
            });
            _this.dataReport.uploadReport(reportSeq);
            _this.stateCenter.settingConfig.setSetting(streamConfig === null || streamConfig === void 0 ? void 0 : streamConfig.setting);
            // }
        })
            .catch(function (error) {
            _this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.CONSTRUCTOR +
                " streamConfig " +
                JSON.stringify(error));
        });
    }
    ZegoWebRTC.prototype.checkAudioContext = function () {
        var _this = this;
        if (this.ac && this.ac.state === "suspended") {
            var resumeAudioContext_1 = function () {
                _this.ac.resume();
                window.removeEventListener("click", resumeAudioContext_1);
                window.removeEventListener("touchstart", resumeAudioContext_1);
            };
            window.addEventListener("click", resumeAudioContext_1);
            window.addEventListener("touchstart", resumeAudioContext_1);
        }
    };
    ZegoWebRTC.prototype.mutePublishStreamVideo = function (localStream, mute, retain) {
        return false;
    };
    ZegoWebRTC.prototype.mutePublishStreamAudio = function (localStream, mute) {
        return false;
    };
    ZegoWebRTC.prototype.mutePlayStreamVideo = function (streamID, mute) {
        return new Promise(function (resolve, reject) {
            console.error("should install advanced module");
            resolve(false);
        });
    };
    ZegoWebRTC.prototype.mutePlayStreamAudio = function (streamID, mute) {
        return new Promise(function (resolve, reject) {
            console.error("should install advanced module");
            resolve(false);
        });
    };
    ZegoWebRTC.prototype.muteMicrophone = function (mute) {
        return false;
    };
    ZegoWebRTC.prototype.isMicrophoneMuted = function () {
        return !this.streamCenter.isMicEnabled;
    };
    ZegoWebRTC.prototype.setAudioOutput = function (localVideo, audioOutput) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SET_AUDIO_OUTPUT + " call");
        if (typeof audioOutput !== "string") {
            this.logger.error("audiooutput is not string");
            return false;
        }
        return this.rtcModules.playModule.setStreamAudioOutput(localVideo, audioOutput);
    };
    ZegoWebRTC.prototype.setCustomSignalUrl = function (signalUrl) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SET_CUSTOM_SIGNAL_URL + " call: " + signalUrl);
        if (!signalUrl || signalUrl.length == 0) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_CUSTOM_SIGNAL_URL + " param error");
            return;
        }
        var isUrl = true;
        signalUrl.forEach(function (url) { return url.indexOf("wss://") != 0 && (isUrl = false); });
        if (!isUrl) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_CUSTOM_SIGNAL_URL + " url is not correct");
            return;
        }
        this.stateCenter.customUrl = signalUrl;
    };
    ZegoWebRTC.prototype.setGWNode = function (gwNode) {
        if (typeof gwNode == "string" && gwNode.length > 0) {
            this.streamCenter.gwNode = gwNode;
        }
    };
    ZegoWebRTC.prototype.setQualityMonitorCycle = function (timeInMs) {
        if (typeof timeInMs === "number" && timeInMs >= 1000) {
            this.streamCenter.setQualityMonitorCycle(timeInMs);
            return true;
        }
        else {
            this.logger.error("zc.sqmc.0 time must be number and bigger than 1000");
            return false;
        }
    };
    ZegoWebRTC.prototype.startPlayingStream = function (streamID, playOption, isDataChannel) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.START_PLAYING_STREAM + " call by user");
        return this.rtcModules.playModule.startPlayingStream(streamID, playOption, isDataChannel);
    };
    ZegoWebRTC.prototype.stopPlayingStream = function (streamID) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STOP_PLAYING_STREAM + " call by user");
        this.rtcModules.playModule.stopPlayingStream(streamID);
    };
    ZegoWebRTC.prototype.setPlayAccelerate = function (accelerate) {
        this.stateCenter.playAccelerate = accelerate;
    };
    //是否走tcp
    ZegoWebRTC.prototype.setTurnOverTcpOnly = function (bool) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SET_TURN_OVER_TCP_ONLY + " call " + bool);
        if (typeof bool == "boolean") {
            this.stateCenter.turnOverTcpOnly = bool;
        }
        else {
            this.logger.error("zc.p.stoto.0 param must be param");
        }
    };
    ZegoWebRTC.prototype.createStream = function (option) {
        return this.rtcModules.publishModule.createStream(option);
    };
    ZegoWebRTC.prototype.destroyStream = function (localStream) {
        this.rtcModules.publishModule.destroyStream(localStream);
    };
    ZegoWebRTC.prototype.startPublishingStream = function (streamID, localStream, publishOption, isDataChannel) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM + " call by user");
        return this.rtcModules.publishModule.startPublishingStream(streamID, localStream, publishOption, isDataChannel);
    };
    ZegoWebRTC.prototype.activateSEIInsert = function (config) {
        console.error("should install advanced module");
        return false;
    };
    //结束推流
    ZegoWebRTC.prototype.stopPublishingStream = function (streamID) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STOP_PUBLISHING_STREAM + " call by user");
        return this.rtcModules.publishModule.stopPublishingStream(streamID);
    };
    //修改推流参数
    ZegoWebRTC.prototype.setVideoConfig = function (localStream, constraints) {
        if (this.rtcModules.advancedModule) {
            return this.rtcModules.advancedModule.setVideoConfig(localStream, constraints);
        }
        else {
            return new Promise(function (resolve, reject) {
                console.error("should install advanced module");
                resolve({
                    errorCode: -1,
                    extendedData: "should install advanced module"
                });
            });
        }
    };
    ZegoWebRTC.prototype.setAudioConfig = function (localStream, constraints) {
        if (this.rtcModules.advancedModule) {
            return this.rtcModules.advancedModule.setAudioConfig(localStream, constraints);
        }
        else {
            return new Promise(function (resolve, reject) {
                console.error("should install advanced module");
                resolve({
                    errorCode: -1,
                    extendedData: "should install advanced module"
                });
            });
        }
    };
    ZegoWebRTC.prototype.replaceTrack = function (localStream, mediaStreamTrack) {
        if (this.rtcModules.advancedModule) {
            return this.rtcModules.advancedModule.replaceTrack(localStream, mediaStreamTrack);
        }
        else {
            return new Promise(function (resolve, reject) {
                console.error("should install advanced module");
                resolve({
                    errorCode: -1,
                    extendedData: "should install advanced module"
                });
            });
        }
    };
    //预加载音效
    ZegoWebRTC.prototype.preloadEffect = function (id, effectUrl, callBack) {
        if (this.rtcModules.audioMixModule !== undefined) {
            this.rtcModules.audioMixModule.preloadEffect(id, effectUrl, callBack);
        }
        else {
            console.error("未引入混音模块");
        }
    };
    ZegoWebRTC.prototype.playEffect = function (audioMixConfig, start, end) {
        if (this.rtcModules.audioMixModule !== undefined) {
            this.rtcModules.audioMixModule.playEffect(audioMixConfig, start, end);
        }
        else {
            console.error("未引入混音模块");
        }
    };
    ZegoWebRTC.prototype.pauseEffect = function (streamID, effectID) {
        if (this.rtcModules.audioMixModule !== undefined) {
            return this.rtcModules.audioMixModule.pauseEffect(streamID, effectID);
        }
        else {
            console.error("未引入混音模块");
            return false;
        }
    };
    ZegoWebRTC.prototype.resumeEffect = function (streamID, effectID) {
        if (this.rtcModules.audioMixModule !== undefined) {
            return this.rtcModules.audioMixModule.resumeEffect(streamID, effectID);
        }
        else {
            console.error("未引入混音模块");
            return false;
        }
    };
    ZegoWebRTC.prototype.stopEffect = function (streamID, effectID) {
        if (this.rtcModules.audioMixModule !== undefined) {
            return this.rtcModules.audioMixModule.stopEffect(streamID, effectID);
        }
        else {
            console.error("未引入混音模块");
            return false;
        }
    };
    ZegoWebRTC.prototype.unloadEffect = function (effecId) {
        if (this.rtcModules.audioMixModule !== undefined) {
            return this.rtcModules.audioMixModule.unloadEffect(effecId);
        }
        else {
            console.error("未引入混音模块");
            return false;
        }
    };
    ZegoWebRTC.prototype.setEffectVolume = function (streamID, volume, effectID) {
        if (this.rtcModules.audioMixModule !== undefined) {
            return this.rtcModules.audioMixModule.setEffectVolume(streamID, volume, effectID);
        }
        else {
            console.error("未引入混音模块");
            return false;
        }
    };
    //开始混音
    ZegoWebRTC.prototype.startMixingAudio = function (streamID, audio) {
        if (this.rtcModules.audioMixModule !== undefined) {
            return this.rtcModules.audioMixModule.startMixingAudio(streamID, audio);
        }
        else {
            console.error("未引入混音模块");
            return false;
        }
    };
    //停止混音
    ZegoWebRTC.prototype.stopMixingAudio = function (streamID, audio) {
        if (this.rtcModules.audioMixModule !== undefined) {
            return this.rtcModules.audioMixModule.stopMixingAudio(streamID, audio);
        }
        else {
            console.error("未引入混音模块");
            return false;
        }
    };
    ZegoWebRTC.prototype.mixingBuffer = function (streamID, sourceID, arrayBuffer, callBack) {
        if (this.rtcModules.audioMixModule !== undefined) {
            this.rtcModules.audioMixModule.mixingBuffer(streamID, sourceID, arrayBuffer, callBack);
        }
        else {
            console.error("未引入混音模块");
        }
    };
    ZegoWebRTC.prototype.stopMixingBuffer = function (streamID, sourceID) {
        if (this.rtcModules.audioMixModule !== undefined) {
            return this.rtcModules.audioMixModule.stopMixingBuffer(streamID, sourceID);
        }
        else {
            console.error("未引入混音模块");
            return false;
        }
    };
    ZegoWebRTC.prototype.setMixingAudioVolume = function (streamID, volume, audio) {
        if (this.rtcModules.audioMixModule !== undefined) {
            return this.rtcModules.audioMixModule.setMixingAudioVolume(streamID, volume, audio);
        }
        else {
            console.error("未引入混音模块");
            return false;
        }
    };
    // private voiceChange(mult: number, streamID: string): any {
    //     if (!mult || typeof mult !== 'number') {
    //         this.logger.error('zc.vc.0 mult error');
    //         return false;
    //     }
    //     if (!streamID || typeof streamID !== 'string') {
    //         this.logger.error('zc.vc.0 stream id error');
    //         return false;
    //     }
    //     return this.rtcModules.streamCenter.voiceChange(mult, streamID);
    // }
    // private voiceBack(streamID: string): void {
    //     this.rtcModules.streamCenter.voiceBack(streamID);
    // }
    ZegoWebRTC.prototype.checkSystemRequirements = function (checkLevel, type) {
        var _this = this;
        var flag = navigator &&
            navigator.mediaDevices &&
            (ZegoWebRTC.screenShotReady ||
                "getDisplayMedia" in navigator.mediaDevices);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.CHECK_SUPPORT + " call" + navigator.userAgent);
        return new Promise(function (resolve) {
            var reportSeq = zego_entity_1.getReportSeq();
            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCheckSystemRequirements.event);
            var checkType = !type ? "all" : type;
            var interResolve = function (capability) {
                _this.dataReport.addMsgInfo(reportSeq, {
                    capability: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCheckSystemRequirements.capability(capability)
                });
                _this.dataReport.uploadReport(reportSeq);
                var index = _this.stateCenter.checkList.indexOf(checkType);
                _this.stateCenter.checkList.splice(index, 1);
                resolve(capability);
            };
            if (![
                "webRTC",
                "customCapture",
                "camera",
                "microphone",
                "screenSharing",
                "H264",
                "VP8",
                "all"
            ].includes(checkType) ||
                ![0, 1].includes(checkLevel)) {
                return interResolve({
                    result: false,
                    errInfo: {
                        extendedDate: "param error"
                    }
                });
            }
            if (_this.stateCenter.checkList.includes(checkType) ||
                _this.stateCenter.checkList.includes("all")) {
                return interResolve({
                    result: false,
                    errInfo: {
                        extendedDate: "The last test of the same type has not returned a result "
                    }
                });
            }
            _this.stateCenter.checkList.push(checkType);
            client_util_1.ClientUtil.supportDetection(flag, interResolve, checkLevel, type);
        });
    };
    ZegoWebRTC.prototype.enumDevices = function () {
        var _this = this;
        this.logger.info("zc.ed.0 call");
        return new Promise(function (resolve, reject) {
            var reportSeq = zego_entity_1.getReportSeq();
            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskEnumDevices.event);
            var interResolve = function (res) {
                var dev_list = [];
                res.cameras.forEach(function (info) {
                    return dev_list.push({
                        device: info.deviceName,
                        type: 0
                    });
                });
                res.microphones.forEach(function (info) {
                    return dev_list.push({
                        device: info.deviceName,
                        type: 1
                    });
                });
                res.speakers.forEach(function (info) {
                    return dev_list.push({
                        device: info.deviceName,
                        type: 2
                    });
                });
                _this.dataReport.addMsgInfo(reportSeq, {
                    dev_list: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskEnumDevices.dev_list(dev_list)
                });
                _this.dataReport.uploadReport(reportSeq);
                resolve(res);
            };
            var interReject = function (err) {
                _this.dataReport.addMsgInfo(reportSeq, err);
                _this.dataReport.uploadReport(reportSeq);
                reject(err);
            };
            _this.rtcModules.publishModule.recordDevices(interResolve, interReject);
        });
    };
    ZegoWebRTC.prototype.getAudioInfo = function (localStream, errCallBack, option) { };
    ZegoWebRTC.prototype.getSoundLevel = function (localStream, sucCallBack, errCallBack) {
        if (this.rtcModules.audioMixModule) {
            this.rtcModules.audioMixModule.getSoundLevel(localStream, sucCallBack, errCallBack);
        }
        else {
            console.error("未引入混音模块");
        }
    };
    ZegoWebRTC.prototype.stopSoundLevel = function (localStream) {
        if (this.rtcModules.audioMixModule) {
            this.rtcModules.audioMixModule.stopSoundLevel(localStream);
        }
        else {
            console.error("未引入混音模块");
        }
    };
    ZegoWebRTC.handleDataAvailable = function (event) {
        if (event.data && event.data.size > 0) {
            ZegoWebRTC.recordedBlobs.push(event.data);
        }
    };
    ZegoWebRTC.prototype.startRecord = function (stream) { };
    ZegoWebRTC.prototype.stopRecord = function () { };
    ZegoWebRTC.prototype.resumeRecord = function () { };
    ZegoWebRTC.prototype.pauseRecord = function () { };
    ZegoWebRTC.prototype.saveRecord = function (name) { };
    ZegoWebRTC.prototype.takeSnapShot = function (el, img) { };
    ZegoWebRTC.prototype.saveSnapShot = function (el, name) { };
    ZegoWebRTC.prototype.useVideoDevice = function (localStream, deviceID) {
        if (this.rtcModules.advancedModule) {
            return this.rtcModules.advancedModule.useVideoDevice(localStream, deviceID);
        }
        else {
            return new Promise(function (resolve, reject) {
                resolve({
                    errorCode: -1,
                    extendedData: "should install advanced module"
                });
            });
        }
    };
    ZegoWebRTC.prototype.useAudioDevice = function (localStream, deviceID) {
        if (this.rtcModules.advancedModule) {
            return this.rtcModules.advancedModule.useAudioDevice(localStream, deviceID);
        }
        else {
            console.error("should use advanced module first");
            return new Promise(function (resolve, reject) {
                resolve({
                    errorCode: -1,
                    extendedData: "should install advanced module"
                });
            });
        }
    };
    ZegoWebRTC.prototype.getElectronScreenSources = function () {
        return this.rtcModules.publishModule.getElectronScreenSources();
    };
    ZegoWebRTC.prototype.setSoundLevelDelegate = function (bool, timeInMs) {
        this.logger.info("zc.ssd.0 call");
        if (typeof bool !== "boolean") {
            this.logger.error("zc.ssd.0 param 1 must be boolean");
            return;
        }
        if (timeInMs &&
            (!this.stateCenter.checkInteger(timeInMs) ||
                timeInMs < 100 ||
                timeInMs > 3000)) {
            this.logger.error("zc.ssd.0 soundLevel interval must be integer number which is between 100 and 3000");
            return;
        }
        this.streamCenter.setSoundLevelDelegate(bool, timeInMs);
    };
    ZegoWebRTC.prototype.on = function (event, callBack) {
        return this.rtcModules.bindListener(event, callBack);
    };
    ZegoWebRTC.prototype.off = function (event, callBack) {
        return this.rtcModules.deleteListener(event, callBack);
    };
    ZegoWebRTC.prototype.getVersion = function () {
        return zego_entity_1.PROTO_VERSION;
    };
    ZegoWebRTC.prototype.setStreamExtraInfo = function (streamID, extraInfo) {
        return new Promise(function (resolve, reject) {
            console.error("should use advanced module first");
            reject();
        });
    };
    ZegoWebRTC.prototype.addPublishCdnUrl = function (streamID, targetURL) {
        this.logger.info("zg.cm.apu call ", streamID, targetURL);
        if (this.rtcModules.advancedModule) {
            return this.rtcModules.advancedModule.publishTarget({
                type: "addpush",
                streamID: streamID,
                pushUrl: targetURL
                // signature: signature,
            });
        }
        else {
            return new Promise(function (resolve, reject) {
                console.error("should install advanced module");
                resolve({
                    errorCode: -1,
                    extendedData: "should install advanced module"
                });
            });
        }
    };
    ZegoWebRTC.prototype.removePublishCdnUrl = function (streamID, targetURL) {
        this.logger.info("zg.cm.apu call ", streamID, targetURL);
        if (this.rtcModules.advancedModule) {
            return this.rtcModules.advancedModule.publishTarget({
                type: "delpush",
                streamID: streamID,
                pushUrl: targetURL
                // signature: signature,
            });
        }
        else {
            return new Promise(function (resolve, reject) {
                console.error("should install advanced module");
                resolve({
                    errorCode: -1,
                    extendedData: "should install advanced module"
                });
            });
        }
    };
    ZegoWebRTC.prototype.startMixerTask = function (mixStreamConfig) {
        return new Promise(function (resolve, reject) {
            console.error("未引入混流模块");
            reject();
        });
    };
    ZegoWebRTC.prototype.setMixerTaskConfig = function (config) {
        return new Promise(function (resolve, reject) {
            console.error("未引入混流模块");
            reject();
        });
    };
    ZegoWebRTC.prototype.stopMixerTask = function (taskId) {
        return new Promise(function (resolve, reject) {
            console.error("未引入混流模块");
            reject();
        });
    };
    ZegoWebRTC.prototype.setCaptureVolume = function (localStream, volume) {
        return this.rtcModules.publishModule.setCaptureVolume(localStream, volume);
    };
    // getRoomInfo(): Promise<{ streamList: StreamInfo[] }> {
    //   const room = this.stateCenter.roomList[0];
    //   return room?.streamHandler.getRoomInfo();
    // }
    ZegoWebRTC.use = function (module) {
        switch (module.type) {
            case "AudioMix":
                module.install(modules_1.RTCModules, zego_publish_1.ZegoPublish);
                break;
            case "MixStream":
                module.install(ZegoWebRTC, streamHandler_1.StreamHandler, modules_1.RTCModules);
                break;
            case "Advance":
                module.install(ZegoWebRTC, modules_1.RTCModules, streamHandler_1.StreamHandler, zego_preview_1.ZegoPreview, playModules_1.PlayModule, publishModules_1.PublishModule, zego_publish_1.ZegoPublish, streamSignal_1.ZegoSignal);
                break;
            case "BeautyEffect":
                module.install(zego_preview_1.ZegoPreview);
                break;
            case "RangeAudio":
                module.install(ZegoWebRTC);
                break;
            case "DataChannel":
                module.install(ZegoWebRTC);
                break;
        }
    };
    ZegoWebRTC.prototype.createRangeAudioInstance = function () {
        throw new Error("should use range audio module");
    };
    ZegoWebRTC.prototype.createRealTimeSequentialDataManager = function (roomID) {
        throw new Error("should use datachannel module");
    };
    ZegoWebRTC.prototype.destroyRealTimeSequentialDataManager = function (manager) {
        throw new Error("should use datachannel module");
    };
    ZegoWebRTC.prototype.enableDataChannel = function (bool) {
        if (typeof bool !== "boolean") {
            return;
        }
        this.streamCenter.isDataChannelEnabled = bool;
    };
    ZegoWebRTC.prototype.addTrack = function (stream, track) {
        return new Promise(function (resolve, reject) {
            throw new Error("use advanced module first");
        });
    };
    ZegoWebRTC.prototype.removeTrack = function (stream, track) {
        return new Promise(function (resolve, reject) {
            throw new Error("use advanced module first");
        });
    };
    ZegoWebRTC.prototype.setBeautyEffect = function (localStream, enable, options) {
        if (this.rtcModules.advancedModule) {
            return this.rtcModules.advancedModule.setBeautyEffect(localStream, enable, options);
        }
        else {
            return new Promise(function (resolve, reject) {
                console.error("should install advanced module");
                resolve({
                    errorCode: -1,
                    extendedData: "should install advanced module"
                });
            });
        }
    };
    ZegoWebRTC.screenShotReady = false;
    return ZegoWebRTC;
}());
exports.ZegoWebRTC = ZegoWebRTC;
// listen for messages from the content-script
window.addEventListener("message", function (event) {
    var type = event.data.type, origin = event.origin;
    // NOTE: you should discard foreign events
    if (origin !== window.location.origin) {
        console.warn("ScreenStream: you should discard foreign event from origin:", origin);
        // return;
    }
    // content-script will send a 'SS_PING' msg if extension is installed
    if (type === "SS_PING") {
        ZegoWebRTC.screenShotReady = true;
    }
});


/***/ }),

/***/ "./sdk/src/webrtc/modules/analogSocket.ts":
/*!************************************************!*\
  !*** ./sdk/src/webrtc/modules/analogSocket.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnalogSocket = void 0;
var zego_express_engine_webrtm_1 = __webpack_require__(/*! zego-express-engine-webrtm */ "../zego_express_web_rtm/dist/ZegoExpressWebRTM.js");
var ServerState;
(function (ServerState) {
    ServerState[ServerState["Connected"] = 0] = "Connected";
    ServerState[ServerState["Disconnected"] = 1] = "Disconnected";
    ServerState[ServerState["Broken"] = 2] = "Broken";
})(ServerState || (ServerState = {}));
/**
 * 模拟统一接入连接媒体服务的ws连接
 */
var AnalogSocket = /** @class */ (function () {
    function AnalogSocket(server, netAgent, signalConfig) {
        var _this = this;
        this.server = server;
        this.netAgent = netAgent;
        this.signalConfig = signalConfig;
        this.readyState = WebSocket.CLOSED;
        this.isActive = false;
        this.accessServerState = ServerState.Disconnected;
        this.originAccessServerState = ServerState.Disconnected;
        this.mediaServerState = ServerState.Disconnected;
        this.originMediaServerState = ServerState.Disconnected;
        this.eventHandler = {
            accessDisconnect: function () {
                _this.setAccessServerState(ServerState.Disconnected);
            },
            accessConnect: function () {
                _this.setAccessServerState(ServerState.Connected);
            },
            accessBroken: function () {
                console.error("accessBroken");
                _this.setAccessServerState(ServerState.Broken);
            },
            mediaDisconnect: function () {
                _this.setMediaServerState(ServerState.Disconnected);
            },
            mediaConnect: function () {
                _this.setMediaServerState(ServerState.Connected);
            },
            mediaBroken: function () {
                console.error("mediaBroken");
                _this.setMediaServerState(ServerState.Broken);
            }
        };
        this.wsHandler = netAgent.getPCRequest(server === "unified_rtc"
            ? zego_express_engine_webrtm_1.BusinessService.SERVICE_WEBRTC_SIGNAL
            : zego_express_engine_webrtm_1.BusinessService.SERVICE_L3_WEBRTC_SIGNAL, signalConfig.path, signalConfig.query);
        // 获取
        this.setAccessServerState(netAgent.isConnect() ? ServerState.Connected : ServerState.Disconnected);
        this.setMediaServerState(this.wsHandler.connectState === 0
            ? ServerState.Connected
            : ServerState.Disconnected);
    }
    AnalogSocket.prototype.updateAccessReadyState = function () {
        if (this.isActive &&
            this.accessServerState === ServerState.Connected &&
            this.mediaServerState !== ServerState.Connected) {
            this.onreconnnecting && this.onreconnnecting();
            return;
        }
    };
    AnalogSocket.prototype.updateMediaReadyState = function () {
        if (this.mediaServerState === ServerState.Connected) {
            if (this.originMediaServerState === ServerState.Broken) {
                this.onreconnnecting && this.onreconnnecting();
            }
            if (this.readyState !== WebSocket.OPEN) {
                this.readyState = WebSocket.OPEN;
                this.onopen && this.onopen();
            }
            return;
        }
        else if (this.mediaServerState === ServerState.Disconnected) {
            // 注册媒体连接事件
            this.wsHandler.off("connected", this.eventHandler.mediaConnect);
            this.wsHandler.off("disconnected", this.eventHandler.mediaDisconnect);
            this.wsHandler.off("broken", this.eventHandler.mediaBroken);
            // 注册 统一接入 断开事件
            this.netAgent.off("connected", this.eventHandler.accessConnect);
            this.netAgent.off("disconnected", this.eventHandler.accessDisconnect);
            this.netAgent.off("broken", this.eventHandler.accessBroken);
            if (this.readyState !== WebSocket.CLOSED) {
                this.onclose && this.onclose();
                this.readyState = WebSocket.CLOSED;
            }
            return;
        }
        else if (this.mediaServerState === ServerState.Broken) {
            this.onerror && this.onerror(new Event("signal connecting"));
            this.readyState = WebSocket.CONNECTING;
        }
    };
    AnalogSocket.prototype.setMediaServerState = function (val) {
        console.error("1111媒体连接状态", val);
        if (this.mediaServerState === val)
            return;
        this.originMediaServerState = this.mediaServerState;
        this.mediaServerState = val;
        this.updateMediaReadyState();
    };
    AnalogSocket.prototype.setAccessServerState = function (val) {
        console.error("1111连接统一接入连接状态", val);
        if (this.accessServerState === val)
            return;
        this.originAccessServerState = this.accessServerState;
        this.accessServerState = val;
        this.updateAccessReadyState();
    };
    // 主动操作
    AnalogSocket.prototype.open = function () {
        var _this = this;
        this.isActive = true;
        // 注册媒体连接事件
        this.wsHandler.on("connected", this.eventHandler.mediaConnect);
        this.wsHandler.on("disconnected", this.eventHandler.mediaDisconnect);
        this.wsHandler.on("broken", this.eventHandler.mediaBroken);
        // 注册 统一接入 断开事件
        this.netAgent.on("connected", this.eventHandler.accessConnect);
        this.netAgent.on("disconnected", this.eventHandler.accessDisconnect);
        this.netAgent.on("broken", this.eventHandler.accessBroken);
        this.wsHandler.on("downLoadMessage", function (msg) {
            console.warn("连接11111 downLoadMessage", JSON.parse(msg), new Date());
            _this.onmessage({ data: msg });
        });
    };
    AnalogSocket.prototype.close = function () {
        this.isActive = false;
        // // 注册媒体连接事件
        // this.wsHandler.off("connected", this.eventHandler.mediaConnect);
        // this.wsHandler.off("disconnected", this.eventHandler.mediaDisconnect);
        // this.wsHandler.off("broken", this.eventHandler.mediaBroken);
        // // 注册 统一接入 断开事件
        // this.netAgent.off("connected", this.eventHandler.accessConnect);
        // this.netAgent.off("disconnected", this.eventHandler.accessDisconnect);
        // this.netAgent.off("broken", this.eventHandler.accessBroken);
        // if (this.readyState !== WebSocket.CLOSED) {
        //   this.onclose && this.onclose();
        //   this.readyState = WebSocket.CLOSED;
        // }
        // 断开连接
        this.wsHandler.closeRequest();
    };
    AnalogSocket.prototype.send = function (data, ack) {
        console.warn("连接11111 sendRequest", data, new Date());
        // 通过统一接入发送信息
        this.wsHandler.sendRequest({ payload: data, ack: ack }, function (res) {
            console.warn("netAgent res", res);
        }, function (ack) {
            console.warn("netAgent ack", ack);
        });
    };
    // socket 回调
    AnalogSocket.prototype.onopen = function () { };
    AnalogSocket.prototype.onclose = function (reason) { };
    AnalogSocket.prototype.onerror = function (err) { };
    AnalogSocket.prototype.onmessage = function (e) { };
    /**
     *  提示发起login请求
     */
    AnalogSocket.prototype.onreconnnecting = function () { };
    return AnalogSocket;
}());
exports.AnalogSocket = AnalogSocket;


/***/ }),

/***/ "./sdk/src/webrtc/modules/externModules/checkModule.ts":
/*!*************************************************************!*\
  !*** ./sdk/src/webrtc/modules/externModules/checkModule.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckModule = void 0;
var sdpUtil_1 = __webpack_require__(/*! ../../../util/sdpUtil */ "./sdk/src/util/sdpUtil.ts");
var CheckModule = /** @class */ (function () {
    function CheckModule() {
        var _this = this;
        this.iceconnectionstatechangeTimes = 0;
        this.isCheckAll = false;
        var canvas = document.createElement("canvas");
        var context = canvas.getContext("2d");
        context.fillStyle = "rgba(255, 255, 255, 0)";
        try {
            this.localStream = canvas.captureStream();
        }
        catch (e) {
            console.error("canvas captureStream error", e);
        }
        this.timer = setTimeout(function () {
            _this.resolve("Detection timeout");
            _this.hangup();
        }, 5000);
    }
    CheckModule.prototype.checkSupportByType = function (type) {
        return __awaiter(this, void 0, void 0, function () {
            var configuration, promise, res;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.checkType = type;
                        configuration = {};
                        this.localPc = new RTCPeerConnection(configuration);
                        this.remotePc = new RTCPeerConnection(configuration);
                        promise = new Promise(function (resolve) { return (_this.resolve = resolve); });
                        this.localPc.addEventListener("icecandidate", function (e) {
                            return _this.onIceCandidate(_this.localPc, e);
                        });
                        this.remotePc.addEventListener("icecandidate", function (e) {
                            return _this.onIceCandidate(_this.remotePc, e);
                        });
                        this.remotePc.addEventListener("iceconnectionstatechange", function (e) {
                            if (_this.remotePc.iceConnectionState === "connected") {
                                _this.iceconnectionstatechangeResult = true;
                            }
                            if (++_this.iceconnectionstatechangeTimes === 2 && _this.iceCandidate) {
                                clearTimeout(_this.timer);
                                if (_this.remotePc.iceConnectionState === "connected") {
                                    _this.resolve(true);
                                }
                                else {
                                    _this.resolve("The browser does not support " + type + " format");
                                }
                                _this.hangup();
                            }
                        });
                        this.localStream
                            .getTracks()
                            .forEach(function (track) { return _this.localPc.addTrack(track, _this.localStream); });
                        return [4 /*yield*/, this.check(type)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, promise];
                    case 2:
                        res = _a.sent();
                        return [2 /*return*/, res];
                }
            });
        });
    };
    CheckModule.prototype.check = function (type) {
        return __awaiter(this, void 0, void 0, function () {
            var offer, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.localPc.createOffer({
                                offerToReceiveAudio: true,
                                offerToReceiveVideo: true
                            })];
                    case 1:
                        offer = _a.sent();
                        offer.sdp = sdpUtil_1.SdpUtil.getSDPByVideDecodeType(offer.sdp, type);
                        this.onCreateOfferSuccess(offer);
                        return [3 /*break*/, 3];
                    case 2:
                        e_1 = _a.sent();
                        this.onCreateSessionDescriptionError(e_1);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    CheckModule.prototype.onCreateOfferSuccess = function (desc) {
        return __awaiter(this, void 0, void 0, function () {
            var e_2, e_3, answer, e_4;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.localPc.setLocalDescription(desc)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        e_2 = _a.sent();
                        this.onSetSessionDescriptionError(e_2);
                        return [2 /*return*/];
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, this.remotePc.setRemoteDescription(desc)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        e_3 = _a.sent();
                        this.onSetSessionDescriptionError(e_3);
                        return [2 /*return*/];
                    case 6:
                        _a.trys.push([6, 9, , 10]);
                        return [4 /*yield*/, this.remotePc.createAnswer()];
                    case 7:
                        answer = _a.sent();
                        return [4 /*yield*/, this.onCreateAnswerSuccess(answer)];
                    case 8:
                        _a.sent();
                        return [3 /*break*/, 10];
                    case 9:
                        e_4 = _a.sent();
                        this.onCreateSessionDescriptionError(e_4);
                        return [2 /*return*/];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    CheckModule.prototype.onCreateAnswerSuccess = function (desc) {
        return __awaiter(this, void 0, void 0, function () {
            var e_5, e_6;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.remotePc.setLocalDescription(desc)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        e_5 = _a.sent();
                        this.onSetSessionDescriptionError(e_5);
                        return [2 /*return*/];
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, this.localPc.setRemoteDescription(desc)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        e_6 = _a.sent();
                        this.onSetSessionDescriptionError(e_6);
                        return [2 /*return*/];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    CheckModule.prototype.onIceCandidate = function (pc, event) {
        return __awaiter(this, void 0, void 0, function () {
            var error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.getOtherPc(pc).addIceCandidate(event.candidate)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        error_1 = _a.sent();
                        console.error(this.checkType, this.getPcName(pc) + " addIceCandidate error", error_1);
                        clearTimeout(this.timer);
                        this.hangup();
                        this.resolve(error_1);
                        return [3 /*break*/, 3];
                    case 3:
                        if (this.getPcName(pc) === "remotePc") {
                            if (event.candidate) {
                                this.iceCandidate = true;
                            }
                        }
                        if (this.iceconnectionstatechangeResult &&
                            this.getPcName(pc) === "localPc") {
                            clearTimeout(this.timer);
                            this.hangup();
                            this.resolve(true);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    CheckModule.prototype.getOtherPc = function (pc) {
        return pc === this.localPc ? this.remotePc : this.localPc;
    };
    CheckModule.prototype.getPcName = function (pc) {
        return pc === this.localPc ? "localPc" : "remotePc";
    };
    CheckModule.prototype.onCreateSessionDescriptionError = function (error) {
        console.error("Failed to create session description: " + error.toString());
        clearTimeout(this.timer);
        this.hangup();
        this.resolve(error);
    };
    CheckModule.prototype.onSetSessionDescriptionError = function (error) {
        console.error("Failed to set session description: " + error.toString());
        clearTimeout(this.timer);
        this.hangup();
        this.resolve(error);
    };
    CheckModule.prototype.hangup = function () {
        this.localPc.close();
        this.remotePc.close();
        this.iceconnectionstatechangeTimes = 0;
        this.localStream.getTracks().forEach(function (track) { return track.stop(); });
    };
    return CheckModule;
}());
exports.CheckModule = CheckModule;


/***/ }),

/***/ "./sdk/src/webrtc/modules/externModules/retryDispatchHandler.ts":
/*!**********************************************************************!*\
  !*** ./sdk/src/webrtc/modules/externModules/retryDispatchHandler.ts ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RetryDispatchHandler = void 0;
var retryHandler_1 = __webpack_require__(/*! ../../../util/retryHandler */ "./sdk/src/util/retryHandler.ts");
var zego_entity_1 = __webpack_require__(/*! ../../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var action_1 = __webpack_require__(/*! ../../../common/action */ "./sdk/src/common/action.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var zego_error_1 = __webpack_require__(/*! ../../../common/zego.error */ "./sdk/src/common/zego.error.ts");
var RetryDispatchHandler = /** @class */ (function (_super) {
    __extends(RetryDispatchHandler, _super);
    function RetryDispatchHandler(logger, stateCenter, rtm, streamCenter) {
        var _this = _super.call(this) || this;
        _this.retryActiveCount = 1;
        _this.RETRY_MAX_TIME = 90;
        _this.logger = logger;
        _this.stateCenter = stateCenter;
        _this.rtm = rtm;
        _this.streamCenter = streamCenter;
        return _this;
    }
    RetryDispatchHandler.prototype.initStream = function (streamID, playOption, isPublish) {
        this.streamID = streamID;
        this.playOption = playOption;
        this.isPublish = isPublish;
    };
    //激活重试
    RetryDispatchHandler.prototype.active = function (firstInterval) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.RDH_ACTIVE + " retry call " + this.streamID);
        //网络中断不进行重试
        if (this.stateCenter.networkState == zego_entity_1.ENUM_NETWORK_STATE.offline) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.RDH_ACTIVE + " network is broken, stop retry");
            return false;
        }
        //已触发了重试,忽略
        if (this.retryTimer) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.RDH_ACTIVE + " has active, ignore");
            return false;
        }
        //若已经过了最大重试时间，则不进行重试
        if (this.isOverTime) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.RDH_ACTIVE + " retry over time, stop retry");
            return false;
        }
        //未登录，终止重试
        if (!this.rtm.isLogin()) {
            this.stopMaxTime();
            this.invalid();
            var streamer = this.isPublish
                ? this.streamCenter.publisherList[this.streamID]
                : this.streamCenter.playerList[this.streamID];
            streamer && (streamer.isReDispatch = true);
        }
        var retryCount = this.retryActiveCount - 1;
        var dispatchType = this.playOption && this.playOption.resourceMode == 2
            ? 1
            : 0;
        var body = {
            stream_id: this.streamID,
            ptype: this.isPublish ? "push" : "pull",
            signals: this.streamCenter.getAllInUseUrl(),
            header_kvs: [
                {
                    key: "grpc-metadata-push",
                    value: (this.playOption && this.playOption.cdnUrl) || ""
                }
            ],
            retry: retryCount,
            center_ability: true,
            //判断是否走l3
            dispatch_type: dispatchType
        };
        this.retryTimer && clearTimeout(this.retryTimer);
        this.retryTimer = setTimeout(function () {
            _this.retryTimer = null;
            _this.retryActiveCount++;
            var room = _this.streamCenter.getRoomByStreamID(_this.streamID);
            var seq = _this.rtm.service.sendMessage("webrtc_url", body, function (msg, seq) {
                _this.handleFetchWebRtcUrlRsp(msg);
            }, function (result, seq) {
                _this.handleFetchWebRtcUrlRsp(result);
            }, undefined, {
                sessionID: room === null || room === void 0 ? void 0 : room.sessionID,
                roomID: room === null || room === void 0 ? void 0 : room.roomID,
                roomSessionID: room === null || room === void 0 ? void 0 : room.roomSessionID
            });
            if (_this.isPublish && seq) {
                if (_this.streamCenter.publisherList[_this.streamID])
                    _this.streamCenter.publisherList[_this.streamID].seq = seq;
            }
            else if (seq) {
                if (_this.streamCenter.playerList[_this.streamID])
                    _this.streamCenter.playerList[_this.streamID].seq = seq;
            }
        }, typeof firstInterval == "number"
            ? firstInterval
            : this.retryActiveInterval * 1000);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.RDH_ACTIVE + " call success");
        return true;
    };
    //开启最大重试时间计时
    RetryDispatchHandler.prototype.startMaxTime = function () {
        var _this = this;
        if (this.maxTimer) {
            return;
        }
        this.maxTimer = setTimeout(function () {
            _this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.RDH_MAX_TIME + " " + _this.streamID + " dispatch over max time " + _this.RETRY_MAX_TIME + "s stop retry");
            _this.isOverTime = true;
            _this.invalid();
            var errorData = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayDispatchError;
            errorData.message = errorData.message + " try max limit";
            _this.isPublish
                ? _this.streamCenter.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.error, _this.streamID, errorData)
                : _this.streamCenter.onPlayStateUpdate(zego_entity_1.ENUM_PLAY_STATE_UPDATE.error, _this.streamID, errorData);
        }, this.RETRY_MAX_TIME * 1e3);
    };
    //停止最大重试时间计时
    RetryDispatchHandler.prototype.stopMaxTime = function () {
        this.maxTimer && clearTimeout(this.maxTimer);
        this.maxTimer = null;
    };
    RetryDispatchHandler.prototype.onactive = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
    };
    RetryDispatchHandler.prototype.handleFetchWebRtcUrlRsp = function (result) {
        if (result.code && [zego_error_1.errorCodeList.TIMEOUT.code].includes(result.code)) {
            this.active();
            return;
        }
        else if (result.code &&
            [zego_error_1.errorCodeList.SOCKET_CLOSE.code].includes(result.code)) {
            this.stopMaxTime();
            this.invalid();
            if (this.isPublish) {
                this.streamCenter.publisherList[this.streamID].isReDispatch = true;
            }
            else {
                this.streamCenter.playerList[this.streamID].isReDispatch = true;
            }
            return;
        }
        var msg = result;
        var streamID = msg.body.stream_id;
        var foundSignal = false;
        //服务端返回非最新seq则忽略，也无需重试
        if (this.isPublish &&
            (!this.streamCenter.publisherList[streamID] ||
                msg.header.seq !== this.streamCenter.publisherList[this.streamID].seq)) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.RDH_WEBRTC_URL_RSP +
                " seq is not match, ignore " +
                this.streamID);
            this.stopMaxTime();
            this.invalid();
            return;
        }
        else if (!this.isPublish &&
            (!this.streamCenter.playerList[this.streamID] ||
                msg.header.seq !== this.streamCenter.playerList[this.streamID].seq)) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.RDH_WEBRTC_URL_RSP +
                " seq is not match, ignore " +
                this.streamID);
            this.stopMaxTime();
            this.invalid();
            return;
        }
        if (this.stateCenter.type === "PUBLIC") {
            this.stateCenter.clientIP = msg.body.clientip || "";
            //根据错误码及need_action字段判断是否重试
            if (msg.body.err_code !== 0 && msg.body.need_action == 2) {
                this.retryActiveInterval =
                    msg.body.action_delay / 1000 || Math.floor(Math.random() * 3) + 3;
                if (this.retryActiveCount == 2) {
                    var errorData = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayDispatchError;
                    errorData.message =
                        errorData.message +
                            (msg.body.err_code ? " server error:" + msg.body.err_code : "");
                    msg.body.ptype === "push"
                        ? this.streamCenter.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.retry, streamID, errorData)
                        : this.streamCenter.onPlayStateUpdate(zego_entity_1.ENUM_PLAY_STATE_UPDATE.retry, streamID, errorData);
                }
                this.active();
                return;
            }
            else if (msg.body.err_code !== 0 && msg.body.need_action !== 1) {
                var isRetry = ![3102].includes(msg.body.err_code);
                if (isRetry) {
                    this.retryActiveInterval = Math.floor(Math.random() * 3) + 3;
                    if (this.retryActiveCount == 2) {
                        var errorData = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayDispatchError;
                        errorData.message =
                            errorData.message +
                                (msg.body.err_code ? " server error:" + msg.body.err_code : "");
                        msg.body.ptype === "push"
                            ? this.streamCenter.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.retry, streamID, errorData)
                            : this.streamCenter.onPlayStateUpdate(zego_entity_1.ENUM_PLAY_STATE_UPDATE.retry, streamID, errorData);
                    }
                    this.active();
                    return;
                }
            }
            // 成功获取到媒体服务地址，停止重试。
            this.stopMaxTime();
            this.invalid();
            if (msg.body.urls &&
                Array.isArray(msg.body.urls) &&
                msg.body.urls.length > 0) {
                foundSignal = true;
            }
            else {
                this.logger.error(action_1.ZEGO_WEBRTC_ACTION.RDH_WEBRTC_URL_RSP + " signal url is empty");
            }
            if (msg.body.ptype === "push" &&
                this.streamCenter.publisherList[streamID]) {
                if (!foundSignal) {
                    this.streamCenter.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.error, streamID, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishDispatchError);
                    return;
                }
                var publish = this.streamCenter.publisherList[streamID];
                if (this.stateCenter.publishStreamList[streamID]) {
                    //节点过期时间，单位ms
                    publish.ttl = msg.body.hosts_ttl
                        ? new Date().getTime() + msg.body.hosts_ttl * 1000
                        : 0;
                    //返回节点是否为单中心
                    publish.isCenterNode =
                        typeof msg.body.is_center_node == "boolean"
                            ? msg.body.is_center_node
                            : false;
                    publish.serverUrls = msg.body.urls;
                    this.streamCenter.startPublishingStream(streamID);
                }
                else {
                    this.logger.error(action_1.ZEGO_WEBRTC_ACTION.RDH_WEBRTC_URL_RSP + " no streamid to publish");
                }
            }
            else if (msg.body.ptype == "pull" &&
                this.streamCenter.playerList[streamID]) {
                if (!foundSignal) {
                    var errorData = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayDispatchError;
                    errorData.message =
                        errorData.message +
                            (msg.body.err_code ? " server error:" + msg.body.err_code : "");
                    if (msg.body.err_code === 3102) {
                        errorData =
                            zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error
                                .kPlayUnsupportedResourceMode;
                    }
                    this.streamCenter.onPlayStateUpdate(zego_entity_1.ENUM_PLAY_STATE_UPDATE.error, streamID, errorData);
                    return;
                }
                var play = this.streamCenter.playerList[streamID];
                //节点过期时间，单位ms
                play.ttl = msg.body.hosts_ttl
                    ? new Date().getTime() + msg.body.hosts_ttl * 1000
                    : 0;
                //返回是否为单中心
                play.isCenterNode =
                    typeof msg.body.is_center_node == "boolean"
                        ? msg.body.is_center_node
                        : false;
                play.serverUrls = msg.body.urls;
                this.streamCenter.startPlayingStream(streamID, this.stateCenter.useNetAgent, this.streamCenter.playSuccessCallBackList[streamID]);
            }
        }
    };
    return RetryDispatchHandler;
}(retryHandler_1.RetryHandler));
exports.RetryDispatchHandler = RetryDispatchHandler;


/***/ }),

/***/ "./sdk/src/webrtc/modules/externModules/retryStreamHandler.ts":
/*!********************************************************************!*\
  !*** ./sdk/src/webrtc/modules/externModules/retryStreamHandler.ts ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RetryStreamHandler = void 0;
var zego_entity_1 = __webpack_require__(/*! ../../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var retryHandler_1 = __webpack_require__(/*! ../../../util/retryHandler */ "./sdk/src/util/retryHandler.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var action_1 = __webpack_require__(/*! ../../../common/action */ "./sdk/src/common/action.ts");
var client_util_1 = __webpack_require__(/*! ../../../util/client-util */ "./sdk/src/util/client-util.ts");
var RetryStreamHandler = /** @class */ (function (_super) {
    __extends(RetryStreamHandler, _super);
    function RetryStreamHandler(logger, stateCenter, streamCenter, isPublish) {
        var _this = _super.call(this) || this;
        _this.logger = logger;
        _this.stateCenter = stateCenter;
        _this.streamCenter = streamCenter;
        _this.isPublish = isPublish;
        _this.serverUrls = [];
        return _this;
    }
    RetryStreamHandler.prototype.initStream = function (streamID, serverUrls) {
        this.streamID = streamID;
        this.serverUrls = serverUrls;
    };
    //激活推拉流重试
    RetryStreamHandler.prototype.activePublish = function (firstInterval) {
        var _this = this;
        this.logger.info("zc.tsh.a retry call " + this.streamID);
        //网络中断不进行重试
        if (this.stateCenter.networkState == zego_entity_1.ENUM_NETWORK_STATE.offline) {
            this.logger.info("zc.tsh.a network is broken, stop retry");
            return false;
        }
        //已触发了重试,忽略
        if (this.retryTimer) {
            this.logger.info("zc.tsh.a has active, ignore");
            return false;
        }
        //若已经过了最大重试时间，则不进行重试
        if (this.isOverTime) {
            this.logger.warn("zc.tsh.a retry over time, stop retry");
            return false;
        }
        //根据重试次数来决定下次重试时间
        if (this.retryActiveCount == 1) {
            this.retryActiveInterval = Math.floor(Math.random() * (1 - this.RETRY_START_TIME_INTERVAL) +
                this.RETRY_START_TIME_INTERVAL);
        }
        else {
            var retryActiveInterval = Math.pow(2, Math.round(this.retryActiveCount / this.RETRY_CONTINUE_COUNT + 1));
            this.retryActiveInterval =
                retryActiveInterval > this.RETRY_MAX_TIME_INTERVAL
                    ? this.RETRY_MAX_TIME_INTERVAL
                    : retryActiveInterval;
        }
        var publish = this.streamCenter.publisherList[this.streamID];
        var publisher = publish.publisher;
        //ttl 过期重新调度
        // if (firstInterval == undefined && publish.ttl < new Date().getTime()) {
        //   this.publishStateHandle(
        //     ENUM_PUBLISH_STATE_UPDATE.error,
        //     this.streamID,
        //     ZegoRTCLogEvent.kZegoTaskPublishStart.error.kTTLOverTimeError
        //   );
        //   return true;
        // }
        var useNetAgent = this.stateCenter.useNetAgent;
        var serverUrl = "";
        if (useNetAgent) {
            serverUrl = this.serverUrls[0];
        }
        else {
            //决定当前重试的节点
            var serverUrls_1 = this.serverUrls;
            var server_1 = publisher.signal ? publisher.signal.server : "";
            serverUrls_1.forEach(function (val, ind) {
                return ind <= serverUrls_1.indexOf(server_1) && _this.serverUrls.push(val);
            });
            serverUrls_1.splice(0, serverUrls_1.indexOf(server_1) + 1);
            serverUrl = this.serverUrls[this.retryActiveCount % this.serverUrls.length == 0
                ? this.serverUrls.length - 1
                : (this.retryActiveCount % this.serverUrls.length) - 1];
        }
        this.retryTimer = setTimeout(function () {
            _this.logger.info("zc.tsh.a stream " + _this.streamID + " : connect to " + (useNetAgent ? "unified signal server" : "signal server " + serverUrl));
            _this.retryTimer && clearTimeout(_this.retryTimer);
            _this.retryTimer = null;
            _this.retryActiveCount++;
            _this.streamCenter.connectPublishServer(_this.streamID, serverUrl);
        }, typeof firstInterval == "number"
            ? firstInterval
            : this.retryActiveInterval * 1000);
        this.logger.info("zc.tsh.a call success");
        return true;
    };
    RetryStreamHandler.prototype.activePull = function (firstInterval, success) {
        var _this = this;
        this.logger.info("zc.tsh.a retry call " + this.streamID);
        if (success) {
            this.playStreamSuccess = success;
        }
        //网络中断不进行重试
        if (this.stateCenter.networkState == zego_entity_1.ENUM_NETWORK_STATE.offline) {
            this.logger.info("zc.tsh.a network is broken, stop retry");
            return false;
        }
        //已触发了重试,忽略
        if (this.retryTimer) {
            this.logger.info("zc.tsh.a has active, ignore");
            return false;
        }
        //若已经过了最大重试时间，则不进行重试
        if (this.isOverTime) {
            this.logger.warn("zc.tsh.a retry over time, stop retry");
            return false;
        }
        //根据重试次数来决定下次重试时间
        if (this.retryActiveCount == 1) {
            this.retryActiveInterval = Math.floor(Math.random() * (1 - this.RETRY_START_TIME_INTERVAL) +
                this.RETRY_START_TIME_INTERVAL);
        }
        else {
            var retryActiveInterval = Math.pow(2, Math.round(this.retryActiveCount / this.RETRY_CONTINUE_COUNT + 1));
            this.retryActiveInterval =
                retryActiveInterval > this.RETRY_MAX_TIME_INTERVAL
                    ? this.RETRY_MAX_TIME_INTERVAL
                    : retryActiveInterval;
        }
        var play = this.streamCenter.playerList[this.streamID];
        var player = play.player;
        //ttl 过期重新调度
        // if (firstInterval == undefined && play.ttl < new Date().getTime()) {
        //   this.playStateHandle(
        //     ENUM_PLAY_STATE_UPDATE.error,
        //     this.streamID,
        //     ZegoRTCLogEvent.kZegoTaskPlayStart.error.kTTLOverTimeError
        //   );
        //   return true;
        // }
        //决定当前重试的节点
        var serverUrls = this.serverUrls;
        var server = player.signal ? player.signal.server : "";
        var useNetAgent = this.stateCenter.useNetAgent;
        var serverUrl = "";
        if (useNetAgent) {
            // serverUrl = player.resourceMode !== 2 ? "unified_rtc" : "unified_l3";
            serverUrl = this.serverUrls[0];
        }
        else {
            // TODO: 内部将重试过的url往后排，这一段排序处理可能是多余的，根据索引来取就可以拿到 serverUrl
            //  const serverUrl = this.serverUrls[this.retryActiveCount % this.serverUrls.length];
            serverUrls.forEach(function (val, ind) {
                return ind <= serverUrls.indexOf(server) && _this.serverUrls.push(val);
            });
            serverUrls.splice(0, serverUrls.indexOf(server) + 1);
            serverUrl = this.serverUrls[this.retryActiveCount % this.serverUrls.length == 0
                ? this.serverUrls.length - 1
                : (this.retryActiveCount % this.serverUrls.length) - 1];
            // end
        }
        this.retryTimer = setTimeout(function () {
            _this.logger.warn("zc.tsh.a stream " + _this.streamID + " : connect to " + (useNetAgent ? "unified signal server" : "signal server " + serverUrl));
            _this.retryTimer && clearTimeout(_this.retryTimer);
            _this.retryTimer = null;
            _this.retryActiveCount++;
            _this.streamCenter.connectPlayServer(_this.streamID, _this.playStreamSuccess, serverUrl);
        }, typeof firstInterval == "number"
            ? firstInterval
            : this.retryActiveInterval * 1000);
        this.logger.info("zc.tsh.a call success");
        return true;
    };
    //开启最大重试时间计时
    RetryStreamHandler.prototype.startMaxTime = function () {
        var _this = this;
        if (this.maxTimer) {
            return;
        }
        this.maxTimer = setTimeout(function () {
            _this.logger.warn(_this.streamID + " over max time " + _this.RETRY_MAX_TIME + "s, stop retry");
            _this.isOverTime = true;
            _this.invalid();
            //推拉流重试超时处理
            if (_this.isPublish) {
                var publish = _this.streamCenter.publisherList[_this.streamID];
                if (!publish) {
                    _this.logger.info("zc.tsh.smt streamID " + _this.streamID + " publish no found");
                    return;
                }
                _this.publishStateHandle(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.error, _this.streamID, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishRetryTimeoutError, true);
            }
            else {
                var play = _this.streamCenter.playerList[_this.streamID];
                if (!play) {
                    _this.logger.info("zc.tsh.smt streamID " + _this.streamID + " play no found");
                    return;
                }
                _this.playStateHandle(zego_entity_1.ENUM_PLAY_STATE_UPDATE.error, _this.streamID, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayRetryTimeoutError, true);
            }
            //this.onactive();
        }, this.RETRY_MAX_TIME * 1e3);
    };
    //停止最大重试时间计时
    RetryStreamHandler.prototype.stopMaxTime = function () {
        this.maxTimer && clearTimeout(this.maxTimer);
        this.maxTimer = null;
    };
    RetryStreamHandler.prototype.onactive = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
    };
    //处理推拉流失败错误码
    RetryStreamHandler.prototype.retryNextSignal = function (error) {
        var _a, _b;
        if (this.stateCenter.networkState == zego_entity_1.ENUM_NETWORK_STATE.offline) {
            return true;
        }
        if (this.isPublish) {
            var publish = this.streamCenter.publisherList[this.streamID];
            if (publish.publisher.state == zego_entity_1.ENUM_PUBLISH_STATE.stop &&
                [
                    zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kSessionTimeoutError.code,
                    zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishNegoTimeoutError
                        .code
                ].includes(error.code)) {
                return true;
            }
            if (publish.isCenterNode &&
                ((_a = publish.publisher.signal) === null || _a === void 0 ? void 0 : _a.wsReadyState) == WebSocket.OPEN) {
                return false;
            }
            else if (!publish.isCenterNode &&
                [
                    zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishSessionClosedError
                        .code
                ].includes(error.code)) {
                var result = error.message.match(/reason:(\d+)/);
                var reason = result ? result[1] : "";
                return !["26"].includes(reason);
            }
            else {
                return true;
            }
        }
        else {
            var play = this.streamCenter.playerList[this.streamID];
            if (play.player.state == zego_entity_1.ENUM_PLAY_STATE.stop &&
                [
                    zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kSessionTimeoutError.code,
                    zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayNegoTimeoutError.code
                ].includes(error.code)) {
                return true;
            }
            if (play.isCenterNode &&
                ((_b = play.player.signal) === null || _b === void 0 ? void 0 : _b.wsReadyState) == WebSocket.OPEN) {
                return false;
            }
            else if (!play.isCenterNode &&
                [
                    zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlaySessionClosedError.code
                ].includes(error.code)) {
                var result = error.message.match(/reason:(\d+)/);
                var reason = result ? result[1] : "";
                return !["24", "26", "28"].includes(reason);
            }
            else {
                return true;
            }
        }
    };
    RetryStreamHandler.prototype.publishStateHandle = function (type, streamID, error, stopRetry) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISH_STATE_HANDLE +
            " call " +
            streamID +
            " " +
            (error ? error.code + "" : ""));
        //最大重试时间小于3s则认为不重试
        var isStopRetry = stopRetry || this.RETRY_MAX_TIME < 3;
        // 需重新调度
        if (!isStopRetry &&
            error &&
            (client_util_1.ClientUtil.isReDispatch(error) || this.serverUrls.length == 0)) {
            this.stopMaxTime();
            this.retryTimer && clearTimeout(this.retryTimer);
            this.retryTimer = null;
            this.streamCenter.onPublishStateUpdate(type, streamID, error);
            return;
        }
        var publish = this.streamCenter.publisherList[streamID];
        var publisher = publish.publisher;
        if (!isStopRetry && error && error.code !== 0) {
            !this.maxTimer && !isStopRetry && this.startMaxTime();
            //非第一次重试则将状态置为retryPublish
            this.stateCenter.publishStreamList[streamID].state =
                zego_entity_1.ENUM_PUBLISH_STREAM_STATE.retryPublish;
            var localStream_1 = publisher.localStream;
            var videoInfo_1 = publisher.videoInfo;
            var mediaStreamConfig_1 = publisher.mediaStreamConfig;
            var publishOption_1 = publisher.publishOption;
            if (publisher.sessionId != 0 &&
                publisher.signal &&
                publisher.shouldSendCloseSession()) {
                //send close session request
                publisher.signal.sendCloseSession(zego_entity_1.getSeq(), publisher.sessionId, 1);
                publisher.signal.removeSession(publisher.sessionId);
                publisher.closeSessionSignal = true;
            }
            publisher.resetPublish();
            //仅需要重试当前节点
            if (!isStopRetry && !this.retryNextSignal(error)) {
                //单中心
                if (publish.isCenterNode &&
                    publisher.gwNodeTTL < new Date().getTime() &&
                    publisher.gwNodeList.length !== 0) {
                    publisher.gwNode = "";
                    publisher.gwNodeList = [];
                    publisher.gwNodeTTL = 0;
                }
                else if (publish.isCenterNode) {
                    var index = publisher.gwNodeList.findIndex(function (gwNode) { return gwNode == publisher.gwNode; });
                    publisher.gwNode =
                        publisher.gwNodeList[++index % publisher.gwNodeList.length];
                }
                setTimeout(function () {
                    publisher.startPublish(streamID, localStream_1, videoInfo_1, mediaStreamConfig_1, publishOption_1);
                }, 3000);
                return;
            }
            this.streamCenter.removeStreamFromSignal(true, streamID);
        }
        if (isStopRetry) {
            //需终止重试或推流成功
            this.stopMaxTime();
            this.invalid();
            if (type === 1) {
                publisher.resetPublish();
            }
            this.streamCenter.onPublishStateUpdate(type, streamID, error);
            return;
        }
        if (error && error.code !== 0) {
            //抛出重试状态
            if (this.activePublish(undefined)) {
                var seq = zego_entity_1.getReportSeq();
                this.streamCenter.dataReport.newReport(seq);
                this.streamCenter.dataReport.addMsgInfo(seq, {
                    stream: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRePublish.stream(this.streamID)
                });
                this.streamCenter.dataReport.uploadReport(seq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRePublish.event);
                this.streamCenter.onPublishStateUpdate(2, streamID, error);
            }
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISH_STATE_HANDLE + " end " + streamID);
    };
    RetryStreamHandler.prototype.playStateHandle = function (type, streamID, error, stopRetry) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAY_STATE_HANDLE +
            " call " +
            streamID +
            " " +
            (error ? error.code + "" : ""));
        //最大重试时间小于3s则认为不重试
        var isStopRetry = stopRetry || this.RETRY_MAX_TIME < 3;
        if (!isStopRetry &&
            error &&
            (client_util_1.ClientUtil.isReDispatch(error) || this.serverUrls.length == 0)) {
            this.stopMaxTime();
            this.retryTimer && clearTimeout(this.retryTimer);
            this.retryTimer = null;
            this.streamCenter.onPlayStateUpdate(type, streamID, error);
            return;
        }
        if (error && error.code !== 0) {
            !this.maxTimer && !isStopRetry && this.startMaxTime();
            var play = this.streamCenter.playerList[streamID];
            var player_1 = play.player;
            var playOption_1 = player_1.playOption;
            if (player_1.sessionId != 0 &&
                player_1.signal &&
                player_1.shouldSendCloseSession()) {
                //send close session request
                player_1.signal.sendCloseSession(zego_entity_1.getSeq(), player_1.sessionId, 1);
                player_1.signal.removeSession(player_1.sessionId);
                player_1.closeSessionSignal = true;
            }
            player_1.resetPlay();
            //仅需要重试当前节点
            if (!isStopRetry && !this.retryNextSignal(error)) {
                if (play.isCenterNode &&
                    player_1.gwNodeTTL < new Date().getTime() &&
                    player_1.gwNodeList.length !== 0) {
                    player_1.gwNode = "";
                    player_1.gwNodeList = [];
                    player_1.gwNodeTTL = 0;
                }
                else if (play.isCenterNode) {
                    var index = player_1.gwNodeList.findIndex(function (gwNode) { return gwNode == player_1.gwNode; });
                    player_1.gwNode = player_1.gwNodeList[++index % player_1.gwNodeList.length];
                }
                setTimeout(function () {
                    player_1.startPlay(streamID, player_1.getRemoteStreamSuc, playOption_1);
                }, 3000);
                return;
            }
            this.streamCenter.removeStreamFromSignal(false, streamID);
        }
        if (isStopRetry) {
            //需终止重试或拉流成功
            this.stopMaxTime();
            this.invalid();
            this.streamCenter.onPlayStateUpdate(type, streamID, error);
            return;
        }
        if (error && error.code !== 0) {
            //抛出重试状态
            if (this.activePull(undefined)) {
                var seq = zego_entity_1.getReportSeq();
                this.streamCenter.dataReport.newReport(seq);
                this.streamCenter.dataReport.addMsgInfo(seq, {
                    stream: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRePlay.stream(this.streamID)
                });
                this.streamCenter.dataReport.uploadReport(seq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRePlay.event);
                this.streamCenter.onPlayStateUpdate(2, streamID, error);
            }
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAY_STATE_HANDLE + " end " + streamID);
    };
    return RetryStreamHandler;
}(retryHandler_1.RetryHandler));
exports.RetryStreamHandler = RetryStreamHandler;


/***/ }),

/***/ "./sdk/src/webrtc/modules/index.ts":
/*!*****************************************!*\
  !*** ./sdk/src/webrtc/modules/index.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RTCModules = void 0;
var zego_entity_1 = __webpack_require__(/*! ../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var zego_entity_2 = __webpack_require__(/*! ../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var client_util_1 = __webpack_require__(/*! ../../util/client-util */ "./sdk/src/util/client-util.ts");
var streamHandler_1 = __webpack_require__(/*! ../../common/streamHandler */ "./sdk/src/common/streamHandler.ts");
var index_1 = __webpack_require__(/*! ./publishModules/index */ "./sdk/src/webrtc/modules/publishModules/index.ts");
var index_2 = __webpack_require__(/*! ./playModules/index */ "./sdk/src/webrtc/modules/playModules/index.ts");
var action_1 = __webpack_require__(/*! ../../common/action */ "./sdk/src/common/action.ts");
var zego_error_1 = __webpack_require__(/*! ../../common/zego.error */ "./sdk/src/common/zego.error.ts");
var setting_config_1 = __webpack_require__(/*! ../../common/setting.config */ "./sdk/src/common/setting.config.ts");
var RTCModules = /** @class */ (function () {
    function RTCModules(logger, dataReport, stateCenter, streamCenter, rtm, ac) {
        this.logger = logger;
        this.dataReport = dataReport;
        this.stateCenter = stateCenter;
        this.streamCenter = streamCenter;
        this.rtm = rtm;
        this.ac = ac;
        this.mediaEleSources = [];
        //推流基础模块
        this.publishModule = new index_1.PublishModule(this.logger, this.dataReport, this.stateCenter, this.streamCenter, this.rtm);
        //拉流基础模块
        this.playModule = new index_2.PlayModule(this.logger, this.dataReport, this.stateCenter, this.streamCenter, this.rtm);
        //流进阶模块
        this.initAdvance();
        //混音模块
        this.initAudioMix();
        this.init();
    }
    RTCModules.prototype.init = function () {
        this.bindWindowListener();
        //监听房间信息
        this.bindRTMListener();
        this.bindStreamCenterHandler();
    };
    RTCModules.prototype.initAudioMix = function () { };
    RTCModules.prototype.initAdvance = function () { };
    RTCModules.prototype.bindWindowListener = function () {
        var _this = this;
        //防止，暴力退出（关闭或刷新页面）
        var isOnIOS = navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPhone/i);
        var browser = this.stateCenter.browser;
        var eventName = isOnIOS
            ? "pagehide"
            : browser === "firefox"
                ? "beforeunload"
                : "unload";
        window.addEventListener(eventName, function () {
            if (window.event)
                window.event.cancelBubble = true; // Don't know if this works on iOS but it might!
            for (var key in _this.streamCenter.publisherList) {
                _this.publishModule.stopPublishingStream(key);
            }
            for (var key in _this.streamCenter.playerList) {
                _this.playModule.stopPlayingStream(key);
            }
        });
        window.addEventListener("message", function (event) {
            var _a = event.data, type = _a.type, streamId = _a.streamId, canRequestAudioTrack = _a.canRequestAudioTrack;
            if (type === "SS_DIALOG_SUCCESS") {
                //user chose a stream
                _this.screenStreamFrom(streamId, canRequestAudioTrack, client_util_1.ClientUtil.actionSuccessCallback("screenShare", _this.stateCenter.callbackList));
            }
            if (type === "SS_DIALOG_CANCEL") {
                client_util_1.ClientUtil.actionSuccessCallback("screenShare", _this.stateCenter.callbackList)(false, null, type);
            }
        });
        //监听到网络断开
        window.addEventListener("offline", function () {
            _this.logger.info("zc.off.0 network is broken");
            _this.stateCenter.networkState = zego_entity_2.ENUM_NETWORK_STATE.offline;
            if (_this.stateCenter.useNetAgent) {
                _this.logger.info("zc.off.0 use netAgent");
            }
            else {
                //流处理
                for (var streamid in _this.streamCenter.publisherList) {
                    var tryStreamHandler = _this.streamCenter.publisherList[streamid]
                        .retryStreamHandler;
                    tryStreamHandler.stopMaxTime();
                    tryStreamHandler.invalid();
                }
                for (var streamid in _this.streamCenter.playerList) {
                    var tryStreamHandler = _this.streamCenter.playerList[streamid]
                        .retryStreamHandler;
                    tryStreamHandler.stopMaxTime();
                    tryStreamHandler.invalid();
                }
            }
        });
        //监听到网络连接
        window.addEventListener("online", function (event) {
            _this.logger.info("zc.on.0 network is online");
            _this.stateCenter.networkState = zego_entity_2.ENUM_NETWORK_STATE.online;
            // if (this.stateCenter.useNetAgent) {
            //   this.logger.info("zc.on.0 use netAgent");
            // } else {
            //流处理
            for (var streamid in _this.streamCenter.publisherList) {
                var publisher = _this.streamCenter.publisherList[streamid].publisher;
                var retryStreamHandler = _this.streamCenter.publisherList[streamid]
                    .retryStreamHandler;
                if (publisher.state == zego_entity_2.ENUM_PUBLISH_STATE.stop ||
                    publisher.stateNego !== zego_entity_2.ENUM_PUBLISH_STATE_NEGO.iceConnected) {
                    !retryStreamHandler.isOverTime &&
                        retryStreamHandler.publishStateHandle(zego_entity_2.ENUM_PUBLISH_STATE_UPDATE.error, streamid, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error
                            .kPublishNetworkBrokenError);
                }
                else if (publisher.state == zego_entity_2.ENUM_PUBLISH_STATE.publishing) {
                    retryStreamHandler.stopMaxTime();
                }
            }
            for (var streamid in _this.streamCenter.playerList) {
                var player = _this.streamCenter.playerList[streamid].player;
                var retryStreamHandler = _this.streamCenter.playerList[streamid]
                    .retryStreamHandler;
                if (player.state == zego_entity_2.ENUM_PLAY_STATE.stop ||
                    player.stateNego !== zego_entity_2.ENUM_PLAY_STATE_NEGO.iceConnected) {
                    !retryStreamHandler.isOverTime &&
                        retryStreamHandler.playStateHandle(zego_entity_2.ENUM_PLAY_STATE_UPDATE.error, streamid, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayNetworkBrokenError);
                }
                else if (player.state == zego_entity_2.ENUM_PLAY_STATE.playing) {
                    retryStreamHandler.stopMaxTime();
                }
            }
            // }
        });
        //监听退后台事件
        window.addEventListener("visibilitychange", function (event) {
            //有推拉流才上报
            if (Object.keys(_this.streamCenter.publisherList).length > 0 ||
                Object.keys(_this.streamCenter.playerList).length > 0) {
                var seq = zego_entity_2.getReportSeq();
                _this.dataReport.newReport(seq, zego_log_event_1.ZegoRTCLogEvent.kZegoVisibilityChange.event);
                _this.dataReport.uploadReport(seq);
            }
        });
    };
    RTCModules.prototype.bindRTMListener = function () {
        var _this = this;
        var _a, _b;
        this.rtm._on("_settingCanFetch", function (msg) { return __awaiter(_this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                this.rtm.cloudSetting.fetchSetting(setting_config_1.RTC).then(function (settingConfig) {
                    _this.logger.info("zc.scf stream config " + JSON.stringify(settingConfig));
                    // this.stateCenter.cloudSettings[RTC] = settingConfig?.setting;
                    // this.stateCenter.setSetting(RTC, settingConfig?.setting);
                    _this.rtm._on("_cloudSettingNotify", function (file, settingFile) {
                        var reportSeq = zego_entity_2.getReportSeq();
                        _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCloudSettingRefresh.event);
                        var params = _this.rtm.cloudSetting.getEnvVariables();
                        _this.dataReport.addMsgInfo(reportSeq, {
                            params: params,
                            files: [
                                {
                                    name: file,
                                    content: settingFile.setting,
                                    versions: settingFile.versions
                                }
                            ]
                        });
                        _this.dataReport.uploadReport(reportSeq);
                        if (file === setting_config_1.RTC) {
                            // this.stateCenter.cloudSettings[RTC] =
                            //   settingFile?.setting;
                            // this.stateCenter.setSetting(file, settingFile?.setting);
                        }
                    });
                });
                return [2 /*return*/];
            });
        }); });
        this.rtm._on("_appConfigRsp", function () {
            _this.stateCenter.appConfig = _this.rtm.getAppConfig();
            _this.publishModule.startWaitPublish();
            _this.playModule.startWaitPlay();
        });
        this.rtm._on("_roomLogin", function (roomID, token) {
            // debugger;
            _this.stateCenter.appid = _this.rtm.getAppID();
            _this.stateCenter.idName = _this.rtm.getUserID();
            _this.stateCenter.testEnvironment = _this.rtm.isTestEnvironment();
            _this.stateCenter.isMultiRoom = _this.rtm.getMultiRoom();
            _this.stateCenter.useNetAgent = _this.rtm.getUseNetAgent();
            _this.streamCenter.setSessionInfo(_this.stateCenter.appid, _this.stateCenter.idName, _this.stateCenter.testEnvironment);
            var room = _this.stateCenter.getRoomByRoomID(roomID);
            if (!room) {
                var streamHandler = new streamHandler_1.StreamHandler(_this.logger, _this.stateCenter, _this.rtm, _this.streamCenter, roomID);
                _this.bindStreamHandler(streamHandler);
                room = {
                    roomID: roomID,
                    streamHandler: streamHandler,
                    sessionID: "",
                    roomSessionID: "",
                    token: token,
                    isResetRoom: false,
                    streamList: [],
                    streamInfoList: []
                };
                _this.stateCenter.roomList.push(room);
            }
        });
        //todo
        this.rtm._on("roomLoginResponse", function (msg) {
            _this.logger.info("zc.rlr call " + JSON.stringify(msg));
            var roomID = msg.header.room_id || msg.body.room_id;
            _this.stateCenter.appConfig = _this.rtm.getAppConfig();
            //todo anchor_info
            var token = _this.rtm.getToken(roomID);
            var sessionID = _this.rtm.getSessionId(roomID);
            var roomSessionID = _this.rtm.getRoomSessionID(roomID);
            var room = _this.stateCenter.getRoomByRoomID(roomID);
            if (!room) {
                var streamHandler = new streamHandler_1.StreamHandler(_this.logger, _this.stateCenter, _this.rtm, _this.streamCenter, roomID);
                _this.bindStreamHandler(streamHandler);
                room = {
                    roomID: roomID,
                    streamHandler: streamHandler,
                    sessionID: sessionID,
                    roomSessionID: roomSessionID,
                    token: token,
                    isResetRoom: false,
                    streamList: [],
                    streamInfoList: []
                };
                _this.stateCenter.roomList.push(room);
            }
            room.sessionID = sessionID;
            room.roomSessionID = roomSessionID;
            if (msg.body.stream_fetch_flag === 1) {
                // TODO 拉取流列表
                room.streamHandler.fetchStreamList();
            }
            // 登录成功后跟房间信令同步流列表
            room.streamHandler.handleStreamStart(msg, room);
            _this.logger.info("zc.rlr end " + roomID);
        });
        this.rtm._on("HBResponse", function (msg) {
            var _a;
            var roomID = (_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id;
            var room = _this.stateCenter.getRoomByRoomID(roomID);
            _this.stateCenter.type === "PUBLIC" && (room === null || room === void 0 ? void 0 : room.streamHandler.patchStreamList(msg));
        });
        this.rtm._on("_roomStateUpdate", function (roomID, state, errorCode, extendedData) {
            if (state == "DISCONNECTED") {
                _this.logger.info("zc.rsu " +
                    roomID +
                    " disconnected " +
                    (errorCode ? errorCode + " " : "") +
                    (extendedData ? extendedData : ""));
                //todo 根据roomid 清除相应的流
                var room = _this.stateCenter.getRoomByRoomID(roomID);
                if (room) {
                    var index = _this.stateCenter.roomList.findIndex(function (room) { return room.roomID == roomID; });
                    room.isResetRoom = true;
                    room.streamHandler.reset();
                    _this.streamCenter.reset(roomID);
                    _this.stateCenter.roomList.splice(index, 1);
                }
            }
            else {
                _this.logger.info("zc.rsu " + roomID + " state: " + state);
            }
        });
        this.rtm._on("_tokenRenewed", function (token, roomID) {
            _this.logger.info("zc.tr roomID:" + roomID + " " + token);
            var room = _this.stateCenter.getRoomByRoomID(roomID);
            room && (room.token = token);
        });
        this.rtm._on("_tokenExpired", function (msg) {
            var _a, _b;
            var stopStreamList = ((_b = (_a = msg === null || msg === void 0 ? void 0 : msg.body) === null || _a === void 0 ? void 0 : _a.stop_stream) === null || _b === void 0 ? void 0 : _b.stream_id_list) || [];
            stopStreamList.forEach(function (streamId) {
                // 处理房间的停止推流
                _this.publishModule.stopPublishingStream(streamId, zego_error_1.errorCodeList.TOKEN_EXPIRED);
            });
        });
        this.rtm.service.on("stream", function (msg) {
            var _a;
            var roomID = ((_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id) || "";
            var room = _this.stateCenter.getRoomByRoomID(roomID);
            if (!room) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.ON_STREAM + " room no found");
                return;
            }
            room.streamHandler.handleStreamUpdateRsp(msg);
        });
        this.rtm.liveRoomHandler.handlePushStreamMsg = function (msg) {
            console.warn("handlePushStreamMsg", msg);
            // @ts-ignore
            var streamCmd = zego_entity_1.streamMap[msg.header.sub_cmd];
            msg.body.stream_cmd = streamCmd;
            _this.handlePushStreamMsg(msg);
        };
        (_a = this.rtm.service) === null || _a === void 0 ? void 0 : _a.on("push_stream_update", function (msg) {
            _this.handlePushStreamMsg(msg);
        });
        //私有化流更新处理
        (_b = this.rtm.service) === null || _b === void 0 ? void 0 : _b.on("zegochat_js.push_room_stream_update_req", function (msg) {
            var _a;
            var roomID = ((_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id) || "";
            var room = _this.stateCenter.getRoomByRoomID(roomID);
            if (!room) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.ON_STREAM + " room no found");
                return;
            }
            room.streamHandler.handlePriPushStreamUpdateMsg(msg);
        });
    };
    RTCModules.prototype.handlePushStreamMsg = function (msg) {
        var _a;
        var roomID = ((_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id) || "";
        var room = this.stateCenter.getRoomByRoomID(roomID);
        if (!room) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.ON_PUSH_STREAM_UPDATE + " room no found");
            return;
        }
        room.streamHandler.handlePushStreamUpdateMsg(msg);
    };
    RTCModules.prototype.bindStreamCenterHandler = function () {
        var _this = this;
        this.streamCenter.onPlayStateUpdate = function (type, streamID, error) {
            var reportSeq = _this.stateCenter.reportSeqList.startPlay[streamID];
            var play = _this.streamCenter.playerList[streamID];
            // 需要重新调度
            if (type == 1 && play && client_util_1.ClientUtil.isReDispatch(error)) {
                var player = play.player;
                var retryDispatchHandler = play.retryDispatchHandler;
                var playOption = play.playOption;
                if (player.sessionId != 0 &&
                    player.signal &&
                    player.shouldSendCloseSession()) {
                    //send close session request
                    player.signal.sendCloseSession(_this.stateCenter.getSeq(), player.sessionId, 1);
                    player.signal.removeSession(player.sessionId);
                    player.closeSessionSignal = true;
                }
                player.resetPlay();
                retryDispatchHandler.stopMaxTime();
                retryDispatchHandler.invalid();
                retryDispatchHandler.initStream(streamID, playOption, false);
                if (!_this.rtm.isLogin()) {
                    _this.streamCenter.playerList[streamID].isReDispatch = true;
                }
                else {
                    retryDispatchHandler.startMaxTime();
                    retryDispatchHandler.active(0);
                }
                return;
            }
            if (play && play.player && (type == 0 || type == 1) && reportSeq) {
                _this.dataReport.eventEndWithMsgInfo(reportSeq, "PlayState", {
                    type: type
                });
                type == 1 && error && _this.dataReport.addMsgInfo(reportSeq, error);
                _this.dataReport.uploadReport(reportSeq);
                delete _this.stateCenter.reportSeqList.startPlay[streamID];
            }
            if (type === 1 && _this.streamCenter.playErrorCallBackList[streamID]) {
                _this.streamCenter.playErrorCallBackList[streamID]({
                    errorCode: error && error.code,
                    extendedData: error && error.message
                });
                delete _this.streamCenter.playErrorCallBackList[streamID];
                _this.logger.info("zc.opsu.1 " + "stop play called by sdk");
                _this.playModule.stopPlayingStream(streamID, error);
            }
            else {
                _this.stateCenter.actionListener("playerStateUpdate", {
                    state: client_util_1.ClientUtil.getPlayerStateType(type),
                    streamID: streamID,
                    errorCode: error && error.code,
                    extendedData: error && error.message
                });
            }
        };
        this.streamCenter.onPublishStateUpdate = function (type, streamID, error) {
            _this.onPublishStateUpdateHandle(type, streamID, error);
        };
        this.streamCenter.onPublishQualityUpdate = function (streamID, stats) {
            _this.stateCenter.actionListener("publishQualityUpdate", streamID, stats);
        };
        this.streamCenter.onPlayQualityUpdate = function (streamID, stats) {
            _this.stateCenter.actionListener("playQualityUpdate", streamID, stats);
        };
        this.streamCenter.onRemoteCameraStatusUpdate = function (streamID, status, originalStatus) {
            var reportSeq = zego_entity_2.getReportSeq();
            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRemoteCameraUpdate.event);
            _this.dataReport.addMsgInfo(reportSeq, {
                stream: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRemoteCameraUpdate.stream(streamID),
                status: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRemoteCameraUpdate.status(status)
            });
            _this.dataReport.uploadReport(reportSeq);
            _this.stateCenter.actionListener("remoteCameraStatusUpdate", streamID, status);
            _this.stateCenter.actionListener("_remoteCameraStatusUpdate", streamID, originalStatus);
        };
        this.streamCenter.onRemoteMicStatusUpdate = function (streamID, status, originalStatus) {
            var reportSeq = zego_entity_2.getReportSeq();
            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRemoteMicUpdate.event);
            _this.dataReport.addMsgInfo(reportSeq, {
                stream: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRemoteMicUpdate.stream(streamID),
                status: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRemoteMicUpdate.status(status)
            });
            _this.dataReport.uploadReport(reportSeq);
            _this.stateCenter.actionListener("remoteMicStatusUpdate", streamID, status);
            _this.stateCenter.actionListener("_remoteMicStatusUpdate", streamID, originalStatus);
        };
        this.streamCenter.onSoundLevelUpdate = function (soundLevelList) {
            _this.stateCenter.actionListener("soundLevelUpdate", soundLevelList);
        };
        this.streamCenter.onMicSoundLevelUpdate = function (soundLevel) {
            _this.stateCenter.actionListener("capturedSoundLevelUpdate", soundLevel);
        };
    };
    RTCModules.prototype.bindStreamHandler = function (streamHandler) {
        var _this = this;
        streamHandler.onStreamUpdated = function (roomID, type, streamList) {
            var _streamList;
            if (_this.stateCenter.type === "PRIVATE") {
                _streamList = streamList.map(function (stream) {
                    return {
                        streamID: stream.stream_id,
                        user: {
                            userID: stream.user_id,
                            userName: stream.user_name
                        },
                        extraInfo: stream.extra_info,
                        title: stream.title,
                        streamVer: stream.stream_ver
                    };
                });
            }
            else {
                _streamList = streamList.map(function (stream) {
                    return {
                        streamID: stream.streamID,
                        user: stream.user,
                        extraInfo: stream.extraInfo,
                        urlsFLV: stream.urlFlv,
                        urlsRTMP: stream.urlRtmp,
                        urlsHLS: stream.urlHls,
                        urlsHttpsFLV: stream.urlHttpsFlv,
                        urlsHttpsHLS: stream.urlHttpsHls
                    };
                });
            }
            var extendObject = {};
            if (type === 0) {
                var streamDeleteReason = streamList.map(function (stream) {
                    return {
                        stream_id: stream.streamID,
                        code: (zego_entity_2.STREAM_DELETE_REASON[stream.closeType] &&
                            zego_entity_2.STREAM_DELETE_REASON[stream.closeType].code) ||
                            0,
                        description: (zego_entity_2.STREAM_DELETE_REASON[stream.closeType] &&
                            zego_entity_2.STREAM_DELETE_REASON[stream.closeType].description) ||
                            "unknown"
                    };
                });
                extendObject["stream_delete_reason"] = streamDeleteReason;
            }
            var reportSeq = zego_entity_2.getReportSeq();
            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomGetStreamUpdateInfo.event);
            _this.dataReport.addMsgInfo(reportSeq, {
                stream_update_type: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomGetStreamUpdateInfo.stream_update_type(type === 1 ? "added" : "deleted"),
                update_stream: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomGetStreamUpdateInfo.update_stream(_streamList)
            });
            _this.dataReport.uploadReport(reportSeq);
            _this.stateCenter.actionListener("roomStreamUpdate", roomID, client_util_1.ClientUtil.getSteamUpdateType(type), _streamList, Object.keys(extendObject).length > 0 ? JSON.stringify(extendObject) : "");
            _this.stateCenter.actionListener("_streamUpdated", type, streamList);
            if (type === 1) {
                var filterStreamList_1 = [];
                _streamList.forEach(function (stream) {
                    if (stream.extraInfo) {
                        filterStreamList_1.push({
                            streamID: stream.streamID,
                            user: stream.user,
                            extraInfo: stream.extraInfo
                        });
                    }
                });
                filterStreamList_1.length > 0 &&
                    _this.stateCenter.actionListener("streamExtraInfoUpdate", roomID, filterStreamList_1);
            }
        };
        streamHandler.onPublishStateUpdate = function (type, streamID, error) {
            _this.logger.info("zb.opsu ", streamID);
            var reportSeq = _this.stateCenter.reportSeqList.startPublish[streamID];
            var publish = _this.streamCenter.publisherList[streamID];
            if (publish &&
                publish.publisher &&
                (type == 0 || type == 1) &&
                reportSeq) {
                _this.dataReport.eventEndWithMsgInfo(reportSeq, "PublishState", {
                    type: type
                });
                type == 1 && _this.dataReport.addMsgInfo(reportSeq, error);
                _this.dataReport.uploadReport(reportSeq);
                delete _this.stateCenter.reportSeqList.startPublish[streamID];
            }
            _this.stateCenter.actionListener("publisherStateUpdate", {
                state: client_util_1.ClientUtil.getPublisherStateType(type),
                streamID: streamID,
                errorCode: error.code,
                extendedData: error.message
            });
        };
        streamHandler.onStreamExtraInfoUpdated = function (roomID, streamList) {
            var _streamList;
            if (_this.stateCenter.type === "PUBLIC") {
                _streamList = streamList.map(function (stream) {
                    return {
                        streamID: stream.streamID,
                        user: stream.user,
                        extraInfo: stream.extraInfo
                    };
                });
            }
            else {
                _streamList = streamList.map(function (stream) {
                    return {
                        streamID: stream.stream_id,
                        user: {
                            userID: stream.user_id,
                            userName: stream.user_name
                        },
                        extraInfo: stream.extra_info,
                        title: stream.title,
                        streamVer: stream.stream_ver
                    };
                });
            }
            var reportSeq = zego_entity_2.getReportSeq();
            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomGetStreamExtraInfo.event);
            _this.dataReport.addMsgInfo(reportSeq, {
                update_stream: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomGetStreamExtraInfo.update_stream(_streamList)
            });
            _this.dataReport.uploadReport(reportSeq);
            _this.stateCenter.actionListener("streamExtraInfoUpdate", roomID, _streamList);
        };
    };
    RTCModules.prototype.screenStreamFrom = function (streamID, canRequestAudioTrack, callBack) {
        var config = {};
        config["audio"] = {
            mandatory: {
                chromeMediaSource: "desktop",
                chromeMediaSourceId: streamID
            }
        };
        config["video"] = {
            mandatory: {
                chromeMediaSource: "desktop",
                chromeMediaSourceId: streamID,
                maxWidth: window.screen.width,
                maxHeight: window.screen.height
            }
        };
        !canRequestAudioTrack && (config["audio"] = false);
        navigator.mediaDevices
            .getUserMedia(config)
            .then(function (stream) {
            // this.stateCenter.screenShotStream = stream;
            callBack(true, stream);
        })
            .catch(function (err) {
            //this.logger.error('ze.ssf.0 ' + err);
            callBack(false, null, err);
        });
    };
    RTCModules.prototype.onPublishStateUpdateHandle = function (type, streamID, error) {
        var _this = this;
        this.logger.info("zc.opsuh.0 call");
        var publish = this.streamCenter.publisherList[streamID];
        var room = publish.room;
        if (!room) {
            this.logger.error("zc.opsuh.0 room not exist");
            return;
        }
        if (type == 0) {
            //start publish
            if (this.stateCenter.publishStreamList[streamID]) {
                if ([
                    zego_entity_2.ENUM_PUBLISH_STREAM_STATE.tryPublish,
                    zego_entity_2.ENUM_PUBLISH_STREAM_STATE.retryPublish
                ].includes(this.stateCenter.publishStreamList[streamID].state) &&
                    !room.streamList.find(function (streamInfo) { return streamInfo.stream_id == streamID; })) {
                    this.stateCenter.publishStreamList[streamID].state =
                        zego_entity_2.ENUM_PUBLISH_STREAM_STATE.update_info;
                    var cmd = void 0;
                    this.stateCenter.type === "PUBLIC"
                        ? (cmd = zego_entity_2.ENUM_STREAM_SUB_CMD.liveBegin)
                        : (cmd = zego_entity_2.ENUM_STREAM_CMD_PRI.liveBegin);
                    room.streamHandler.updateStreamInfo(streamID, cmd, this.stateCenter.publishStreamList[streamID].extra_info, function (err) {
                        if (_this.stateCenter.type === "PRIVATE") {
                            if (_this.stateCenter.publishStreamList[streamID] &&
                                _this.stateCenter.publishStreamList[streamID].state ==
                                    zego_entity_2.ENUM_PUBLISH_STREAM_STATE.update_info) {
                                _this.stateCenter.publishStreamList[streamID].state =
                                    zego_entity_2.ENUM_PUBLISH_STREAM_STATE.stop;
                                room.streamHandler.onPublishStateUpdate(1, streamID, err);
                                _this.publishModule.stopPublishingStream(streamID);
                            }
                        }
                    });
                }
                else {
                    this.stateCenter.publishStreamList[streamID].state =
                        zego_entity_2.ENUM_PUBLISH_STREAM_STATE.publishing;
                    this.WebrtcOnPublishStateUpdateHandle(type, streamID, error);
                }
            }
        }
        else {
            //重新调度
            if (type == 1 && publish && client_util_1.ClientUtil.isReDispatch(error)) {
                var publisher = publish.publisher;
                var retryDispatchHandler = publish.retryDispatchHandler;
                var publishOption = publish.publishOption;
                if (publisher.sessionId != 0 &&
                    publisher.signal &&
                    publisher.shouldSendCloseSession()) {
                    //send close session request
                    publisher.signal.sendCloseSession(this.stateCenter.getSeq(), publisher.sessionId, 1);
                    publisher.signal.removeSession(publisher.sessionId);
                    publisher.closeSessionSignal = true;
                }
                publisher.resetPublish();
                retryDispatchHandler.stopMaxTime();
                retryDispatchHandler.invalid();
                retryDispatchHandler.initStream(streamID, publishOption, true);
                if (!this.rtm.isLogin()) {
                    this.streamCenter.publisherList[streamID].isReDispatch = true;
                }
                else {
                    retryDispatchHandler.startMaxTime();
                    retryDispatchHandler.active(0);
                }
                return;
            }
            room.streamHandler.onPublishStateUpdate(type, streamID, error);
            if (type == 1) {
                this.logger.info("zc.opsuh.0 " + "stop publish called by sdk");
                this.publishModule.stopPublishingStream(streamID, error);
            }
        }
    };
    // web独有
    RTCModules.prototype.WebrtcOnPublishStateUpdateHandle = function (type, streamID, error) {
        if (this.stateCenter.publishStreamList[streamID].state ==
            zego_entity_2.ENUM_PUBLISH_STREAM_STATE.publishing) {
            var room = this.streamCenter.getRoomByStreamID(streamID);
            room && room.streamHandler.onPublishStateUpdate(type, streamID, error);
        }
    };
    RTCModules.prototype.bindListener = function (listener, callBack) {
        if (!this.stateCenter.listenerList[listener]) {
            this.logger.error("zc.o.0 event " + listener + " no found");
            return false;
        }
        if (typeof callBack !== "function") {
            this.logger.error("zc.o.0 listener callBack must be funciton");
            return false;
        }
        this.stateCenter.listenerList[listener].indexOf(callBack) == -1 &&
            this.stateCenter.listenerList[listener].push(callBack);
        return true;
    };
    RTCModules.prototype.deleteListener = function (listener, callBack) {
        if (!this.stateCenter.listenerList[listener]) {
            this.logger.error("zc.o.1 listener no found");
            return false;
        }
        var li = this.stateCenter.listenerList[listener];
        if (callBack) {
            li.splice(li.indexOf(callBack), 1);
        }
        else {
            this.stateCenter.listenerList[listener] = [];
        }
        return true;
    };
    return RTCModules;
}());
exports.RTCModules = RTCModules;


/***/ }),

/***/ "./sdk/src/webrtc/modules/playModules/index.ts":
/*!*****************************************************!*\
  !*** ./sdk/src/webrtc/modules/playModules/index.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlayModule = void 0;
var action_1 = __webpack_require__(/*! ../../../common/action */ "./sdk/src/common/action.ts");
var zego_entity_1 = __webpack_require__(/*! ../../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var client_util_1 = __webpack_require__(/*! ../../../util/client-util */ "./sdk/src/util/client-util.ts");
var PlayModule = /** @class */ (function () {
    function PlayModule(logger, dataReport, stateCenter, streamCenter, rtm) {
        this.logger = logger;
        this.dataReport = dataReport;
        this.stateCenter = stateCenter;
        this.streamCenter = streamCenter;
        this.rtm = rtm;
    }
    PlayModule.prototype.startPlayingStream = function (streamID, playOption, isDataChannel) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.START_PLAYING_STREAM + " call ", streamID);
        return new Promise(function (resolve, reject) {
            return _this._handlePlayStream(streamID, playOption, resolve, reject, isDataChannel);
        });
    };
    PlayModule.prototype._handlePlayStream = function (streamID, playOption, successCallback, errorCallback, isDataChannel) {
        var _this = this;
        var reportSeq = zego_entity_1.getReportSeq();
        this.stateCenter.reportSeqList.startPlay[streamID] = reportSeq;
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.event);
        var innerReject = function (err, externMsg) {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PLAYING_STREAM +
                " " +
                (externMsg || err.message));
            _this.dataReport.uploadReport(reportSeq, undefined, err, externMsg);
            delete _this.stateCenter.reportSeqList.startPlay[streamID];
            errorCallback &&
                errorCallback(__assign(__assign({}, err), { errorCode: err.code, extendedData: err.message + (externMsg ? " " + externMsg : "") }));
            return;
        };
        if (streamID === undefined ||
            typeof streamID !== "string" ||
            streamID === "") {
            innerReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayParamError, "stream id type error");
            return false;
        }
        if (streamID.length > zego_entity_1.MAX_STREAM_ID_LENGTH) {
            innerReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayStreamIDToLongError, "stream id length limit " + zego_entity_1.MAX_STREAM_ID_LENGTH);
            return false;
        }
        if (!client_util_1.ClientUtil.checkIllegalCharacters(streamID)) {
            innerReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error
                .kPlayStreamIDInvalidCharacterError);
            return false;
        }
        if (typeof playOption !== "undefined" && typeof playOption !== "object") {
            innerReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayParamError, "playOption must be object");
            return false;
        }
        var signals;
        if (this.stateCenter.customUrl && this.stateCenter.customUrl.length != 0) {
            this.logger.info("zc.p.sps.1 customUrl " + JSON.stringify(this.stateCenter.customUrl));
            signals = this.stateCenter.customUrl;
        }
        else {
            var signalNodes = this.stateCenter.settingConfig.getSetting("signal_nodes", true);
            if (signalNodes &&
                signalNodes instanceof Array &&
                signalNodes.length > 0) {
                signals = signalNodes;
                this.logger.info("zc.p.sps.1 setting config signal_nodes " +
                    JSON.stringify(signalNodes));
            }
        }
        if (signals) {
            if (!this.streamCenter.setPlayStateStart(streamID, playOption, isDataChannel)) {
                innerReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayRepeatedPullError, "cannot start play");
                return false;
            }
            this.streamCenter.onPlayStateUpdate(zego_entity_1.ENUM_PLAY_STATE_UPDATE.retry, streamID, { code: 0, message: "" });
            this.streamCenter.playerList[streamID].serverUrls = signals;
            return this.streamCenter.startPlayingStream(streamID, this.stateCenter.useNetAgent, function (stream) {
                successCallback && successCallback(stream);
            });
        }
        this.dataReport.addMsgInfo(reportSeq, {
            stream: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.stream(streamID),
            playOption: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.playOption(playOption)
        });
        // TODO
        if (this.stateCenter.useNetAgent &&
            this.stateCenter.playAccelerate &&
            this.stateCenter.roomList.length > 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.START_PLAYING_STREAM + " play accelerate");
        }
        else if (this.rtm.isDisConnect()) {
            innerReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayNoLoginError);
            return false;
        }
        //打开不能同时多次拉同一条流限制
        if (!this.stateCenter.pullLimited) {
            streamID = +"_" + streamID;
        }
        // playOption videoCodec 大小写兼容
        if (playOption && playOption.videoCodec) {
            playOption.videoCodec = playOption.videoCodec.toUpperCase();
        }
        var _resourceMode = this.stateCenter.settingConfig.getSetting("resource_mode", true);
        if (_resourceMode) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.START_PLAYING_STREAM, " setting resource_mode " + _resourceMode);
            !playOption && (playOption = {});
            playOption.resourceMode = _resourceMode;
        }
        if (!this.streamCenter.setPlayStateStart(streamID, playOption, isDataChannel)) {
            innerReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayRepeatedPullError, "cannot start play");
            return false;
        }
        this.streamCenter.onPlayStateUpdate(zego_entity_1.ENUM_PLAY_STATE_UPDATE.retry, streamID, { code: 0, message: "" });
        this.streamCenter.playSuccessCallBackList[streamID] = function (stream) {
            successCallback && successCallback(stream);
        };
        errorCallback &&
            (this.streamCenter.playErrorCallBackList[streamID] = errorCallback);
        var useNetAgent = this.stateCenter.useNetAgent;
        if (useNetAgent) {
            if (!this.stateCenter.appConfig) {
                this.streamCenter.waitPlayList.push(streamID);
                return true;
            }
            // 统一接入不用走调度,直接调用推拉流
            this.streamCenter.playerList[streamID].serverUrls =
                (playOption === null || playOption === void 0 ? void 0 : playOption.resourceMode) === 2 ? ["unified_l3"] : ["unified_rtc"];
            this.streamCenter.startPlayingStream(streamID, useNetAgent, this.streamCenter.playSuccessCallBackList[streamID]);
            return true;
        }
        else {
            var tryDispatchHandler = this.streamCenter.playerList[streamID]
                .retryDispatchHandler;
            tryDispatchHandler.stopMaxTime();
            tryDispatchHandler.invalid();
            tryDispatchHandler.initStream(streamID, playOption, false);
            tryDispatchHandler.startMaxTime();
            return tryDispatchHandler.active(0);
        }
    };
    PlayModule.prototype.stopPlayingStream = function (streamID, error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STOP_PLAYING_STREAM + " call", streamID);
        //stop play event start
        var reportSeq = zego_entity_1.getReportSeq();
        this.stateCenter.reportSeqList.stopPlay[streamID] = reportSeq;
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStop.event);
        this.dataReport.addMsgInfo(reportSeq, {
            stream: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStop.stream(streamID)
        });
        if (typeof streamID !== "string" || streamID === "") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.STOP_PLAYING_STREAM +
                " streamid must be string and not empty");
            this.dataReport.uploadReport(reportSeq, undefined, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStop.error.kParamError, "stream id type error");
            delete this.stateCenter.reportSeqList.stopPlay[streamID];
            return;
        }
        var play = this.streamCenter.playerList[streamID];
        // if (!play || play.serverUrls.length == 0) {
        //     play && this.logger.error('zc.p.sps.1.0 stream can not be destroyed');
        //     this.dataReport.uploadReport(reportSeq, undefined, errorList.kIsPlaying, 'can not be destroyed');
        //     delete this.stateCenter.reportSeqList.stopPlay[totalStreamId];
        //     return;
        // }
        var shouldPlayUpdate = play && play.player && play.player.state !== zego_entity_1.ENUM_PLAY_STATE.stop;
        this.streamCenter.stopPlayingStream(streamID);
        for (var seq in this.stateCenter.streamUrlMap) {
            if (this.stateCenter.streamUrlMap[seq] === streamID) {
                delete this.stateCenter.streamUrlMap[seq];
                break;
            }
        }
        this.dataReport.uploadReport(reportSeq);
        shouldPlayUpdate &&
            this.streamCenter.onPlayStateUpdate(zego_entity_1.ENUM_PLAY_STATE_UPDATE.error, streamID, error ? error : { code: 0, message: "" });
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.STOP_PLAYING_STREAM + " call success");
        return;
    };
    PlayModule.prototype.mutePlayStream = function (streamID, type, mute) {
        return new Promise(function (resolve, reject) {
            resolve(false);
        });
    };
    PlayModule.prototype.setStreamAudioOutput = function (localVideo, audioOutput) {
        return false;
    };
    PlayModule.prototype.startWaitPlay = function () {
        var _this = this;
        this.streamCenter.waitPlayList.forEach(function (streamID) {
            _this.streamCenter.startPlayingStream(streamID, _this.stateCenter.useNetAgent, _this.streamCenter.playSuccessCallBackList[streamID]);
        });
        this.streamCenter.waitPlayList = [];
    };
    return PlayModule;
}());
exports.PlayModule = PlayModule;


/***/ }),

/***/ "./sdk/src/webrtc/modules/playModules/playStreamQuality.ts":
/*!*****************************************************************!*\
  !*** ./sdk/src/webrtc/modules/playModules/playStreamQuality.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlayStreamQuality = void 0;
var zego_entity_1 = __webpack_require__(/*! ../../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var action_1 = __webpack_require__(/*! ../../../common/action */ "./sdk/src/common/action.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var client_util_1 = __webpack_require__(/*! ../../../util/client-util */ "./sdk/src/util/client-util.ts");
var PlayStreamQuality = /** @class */ (function () {
    function PlayStreamQuality(qualityTimeInterval, player, logger, dataReport) {
        this.player = player;
        this.logger = logger;
        this.dataReport = dataReport;
        this.playQualityList = [];
        this.maxQualityListCount = 10;
        this.qualityTimer = null;
        this.lastPlayStats = {
            audioPacketsLost: 0,
            videoPacketsLost: 0,
            time: 0,
            audioTime: 0,
            videoTime: 0,
            audioBytesReceived: 0,
            videoBytesReceived: 0,
            audioPacketsReceived: 0,
            videoPacketsReceived: 0,
            framesDecoded: 0,
            framesReceived: 0,
            framesDropped: 0,
            audioBitrate: 0
        };
        this.decodeStartTime = 0;
        // // 探测流相关参数
        this.netQuality = 0;
        this.probeTime = 0;
        this.probeInterval = 60000;
        this.probeState = zego_entity_1.ENUM_PROBE_STATE.probed;
        this.probeTimer = null;
        this.probeTimeoutInterval = 30000;
        // 质量上报相关参数
        this.qualityUpload = false;
        this.qualityUploadInterval = 30 * 1000;
        this.qualityUploadLastTime = 0;
        this.cumulativeQuality = {};
        // 卡顿阈值
        this.audioBreakThreshold = 200;
        this.videoBreakThreshold = 500;
        this.videoBreak = {
            breakStartTime: undefined,
            cumulativeBreakDuration: 0,
            cumulativeDecodeDuration: 0,
            decodeStartTime: undefined,
            decodeEndTime: undefined,
            totalDuration: 0,
            noBreakNoDecodeDuration: 0,
            resumeRecv: true
        };
        this.audioBreak = {
            breakStartTime: undefined,
            cumulativeBreakDuration: 0,
            cumulativeDecodeDuration: 0,
            decodeStartTime: undefined,
            decodeEndTime: undefined,
            totalDuration: 0,
            noBreakNoDecodeDuration: 0,
            resumeRecv: true
        };
        this.lastSampleTime = 0;
        // 流质量事件上报字段
        this.videoBreakReport = {
            breakDuration: 0,
            breakCancelDuration: 0,
            decodeTime: 0
        };
        this.audioBreakReport = {
            breakDuration: 0,
            breakCancelDuration: 0,
            decodeTime: 0
        };
        // 累计指标
        this.totalQuality = {
            totalSquaredInterFrameDelay: 0,
            totalInterFrameDelay: 0,
            framesDecode: 0,
            totalSamplesReceived: 0,
            concealedSamples: 0,
            audioBytesReceived: 0
        };
        this.currentSecondQuality = {
            totalSquaredInterFrameDelay: 0,
            totalInterFrameDelay: 0,
            framesDecode: 0,
            totalSamplesReceived: 0,
            concealedSamples: 0
        };
        // 是否开始记录卡顿
        this.onBreakEnd = function (breakEndTime, breakInfo, breakThreshold, isVideo) {
            if (isVideo === void 0) { isVideo = "video"; }
            if (breakInfo.breakStartTime) {
                var breakDuration = breakEndTime - breakInfo.breakStartTime;
                if (breakDuration >= breakThreshold) {
                    breakInfo.cumulativeBreakDuration += breakDuration;
                }
                breakInfo.breakStartTime = undefined;
                // console.log(
                //   isVideo + "BreakEnd_test 卡顿结束1",
                //   breakEndTime,
                //   breakDuration
                // );
            }
        };
        this.p2pNetStats = {
            p2pLostRate: 0,
            p2pRTT: 0
        };
        // 开启获取拉流质量上报
        this.sampleTimes = 0;
        this.qualitySampleInterval = 1000;
        this.qualityTimeInterval = qualityTimeInterval;
    }
    Object.defineProperty(PlayStreamQuality.prototype, "streamId", {
        get: function () {
            return this.player.streamId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PlayStreamQuality.prototype, "sessionId", {
        get: function () {
            return this.player.sessionId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PlayStreamQuality.prototype, "peerID", {
        get: function () {
            return this.player.peerID;
        },
        enumerable: false,
        configurable: true
    });
    PlayStreamQuality.prototype.getPlayStats = function (rtcStats, callbackResults) {
        var _this = this;
        if (rtcStats == undefined) {
            return;
        }
        var isToReport = this.sampleTimes %
            parseInt((this.qualityTimeInterval / this.qualitySampleInterval).toString()) ===
            0;
        var isToCallback = this.sampleTimes %
            parseInt((this.qualityTimeInterval / this.qualitySampleInterval).toString()) ===
            0;
        if (isToReport) {
            // 获取端到端延迟
            this.getP2PNetStats();
        }
        var medias = document.querySelectorAll("video, audio");
        // TODO: 此处报错没有抛出
        // throw new Error("error")
        var streamMedia;
        for (var i = 0; i < medias.length; i++) {
            if (medias[i].srcObject === this.player.playStream) {
                streamMedia = medias[i];
            }
        }
        var playData = {
            sampleTimeWindow: this.qualityTimeInterval,
            audioFractionLost: 0,
            audioPacketsLost: 0,
            audioPacketsLostRate: 0,
            audioBitrate: 0,
            audioLevel: 0,
            audioSendLevel: 0,
            audioSamplingRate: 0,
            audioCodec: "opus",
            audioQuality: 0,
            audioFPS: 0,
            videoQuality: 0,
            videoPacketsLost: 0,
            videoPacketsLostRate: 0,
            videoBitrate: 0,
            videoFPS: 0,
            playData: 0,
            nackCount: 0,
            pliCount: 0,
            //sliCount: 0,
            audioJitter: 0,
            videoFractionLost: 0,
            videoFramesDecoded: 0,
            frameHeight: 0,
            frameWidth: 0,
            videoTransferFPS: 0,
            videoFramesDropped: 0,
            totalRoundTripTime: 0,
            currentRoundTripTime: 0,
            googBandwidthLimitedResolution: undefined,
            videoCodecName: "",
            audioCodecName: "",
            googCpuLimitedResolution: undefined,
            googAvailableSendBandwidth: 0,
            audioMuteState: this.player.audioMuteState,
            videoMuteState: this.player.videoMuteState,
            muted: streamMedia ? streamMedia.muted : undefined,
            paused: streamMedia ? streamMedia.paused : undefined,
            volume: streamMedia ? streamMedia.volume : undefined,
            sinkId: streamMedia ? streamMedia.sinkId : undefined
        };
        var time = this.lastPlayStats.time;
        var rtt = 0;
        var audioLostRate = 0;
        var videoLostRate = 0;
        var audioJitter = 0;
        var videoJitter = 0;
        var audioCurrentDelayMs = 0;
        var videoCurrentDelayMs = 0;
        var videoStats = null;
        var audioStats = null;
        rtcStats.forEach(function (item) {
            if (["ssrc", "inbound-rtp"].includes(item.type) &&
                (item.mediaType == "video" || item.id.indexOf("VideoStream") >= 0)) {
                videoStats = item;
            }
            if ((item.type == "inbound-rtp" ||
                (item.type == "ssrc" && item.bytesReceived != undefined)) &&
                (item.mediaType == "audio" || item.id.indexOf("AudioStream") >= 0)) {
                audioStats = item;
            }
        });
        var recordBreakDuration = function (now, framesCurrentSecond, isMediaEnabled, breakInfo, breakThreshold, breakReport, averageBreakDelay, maxBreakValue, isVideo) {
            if (maxBreakValue === void 0) { maxBreakValue = averageBreakDelay; }
            if (isVideo === void 0) { isVideo = "video"; }
            if (breakThreshold > 1000) {
                breakThreshold = 1000;
            }
            if (breakInfo.breakStartTime) {
                if (!isMediaEnabled) {
                    breakInfo.resumeRecv = false;
                    var breakCancelTime = now - 1000;
                    var breakCancelDuration = breakCancelTime - breakInfo.breakStartTime;
                    if (breakCancelDuration <= 0) {
                        // 这里判断 取消卡顿时间小于开始卡顿时间的情况。不应该出现的场景
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SET_PLAYER_QUALITY_TIMER +
                            " breakCancelDuration less than 0. " +
                            (" (" + breakInfo.breakStartTime + ", " + breakCancelTime + ")"));
                        breakCancelDuration = 0;
                    }
                    // console.log(
                    //   isVideo + "BreakCancel_test 卡顿取消",
                    //   breakCancelTime,
                    //   breakCancelDuration
                    // );
                    breakInfo.breakStartTime = undefined;
                    breakInfo.noBreakNoDecodeDuration += breakCancelDuration;
                    // if (framesCurrentSecond === 0 && !breakInfo.decodeEndTime) {
                    //   breakInfo.decodeEndTime = now - 1000;
                    // }
                    // 单段卡顿累计
                    breakReport.breakCancelDuration += breakCancelDuration;
                }
                else {
                    // breakInfo.decodeEndTime = undefined;
                    if (framesCurrentSecond === 0) {
                        if (now - breakInfo.breakStartTime >= 22 * 1000) {
                            // 卡顿超时记录卡顿结束
                            _this.onBreakEnd(now, breakInfo, breakThreshold, isVideo);
                        }
                        // 单段卡顿累计
                        breakReport.breakDuration += 1000;
                    }
                    else {
                        if (averageBreakDelay >= breakThreshold) {
                            if (averageBreakDelay < 500) {
                                if (averageBreakDelay + maxBreakValue < 1000) {
                                    var breakEndTime = now - (1000 - maxBreakValue);
                                    _this.onBreakEnd(breakEndTime, breakInfo, breakThreshold, isVideo);
                                    breakInfo.breakStartTime = now - averageBreakDelay;
                                    // console.log(
                                    //   isVideo + "BreakStart_test 卡顿开始1",
                                    //   breakInfo.breakStartTime
                                    // );
                                    // 单段卡顿累计
                                    breakReport.breakDuration +=
                                        maxBreakValue + averageBreakDelay;
                                    breakReport.decodeTime +=
                                        1000 - (maxBreakValue + averageBreakDelay);
                                }
                                else {
                                    //  averageBreakDelay+maxBreakValue >1000
                                    _this.onBreakEnd(now - 1000 + maxBreakValue, breakInfo, breakThreshold, isVideo);
                                    breakInfo.breakStartTime = now - 1000 + maxBreakValue;
                                    // console.log(
                                    //   isVideo + "BreakStart_test 卡顿开始2",
                                    //   breakInfo.breakStartTime
                                    // );
                                    // 单段卡顿累计
                                    breakReport.breakDuration += 1000;
                                }
                            }
                            else if (averageBreakDelay >= 500) {
                                _this.onBreakEnd(now - averageBreakDelay, breakInfo, breakThreshold, isVideo);
                                breakInfo.breakStartTime = now - averageBreakDelay;
                                // console.log(
                                //   isVideo + "BreakStart_test 卡顿开始3",
                                //   breakInfo.breakStartTime
                                // );
                                // 单段卡顿累计
                                breakReport.breakDuration += 1000;
                            }
                        }
                        else {
                            if (maxBreakValue <= breakThreshold) {
                                _this.onBreakEnd(now - 1000 + maxBreakValue, breakInfo, breakThreshold, isVideo);
                                breakInfo.breakStartTime = undefined;
                                // 单段卡顿累计
                                breakReport.breakDuration += maxBreakValue;
                                // console.log("audiobreakReport 补充卡顿结束时长", maxBreakValue);
                                breakReport.decodeTime += 1000 - maxBreakValue;
                            }
                            else {
                                breakReport.breakDuration += 1000;
                            }
                        }
                    }
                }
            }
            else {
                // 判断是否卡顿记录卡顿开始时间点
                if (!isMediaEnabled) {
                    if (!breakInfo.decodeStartTime) {
                        // 没有开始解码不计解码时间
                    }
                    else if (framesCurrentSecond === 0) {
                        breakInfo.resumeRecv = false;
                        breakInfo.noBreakNoDecodeDuration += 1000;
                        // console.log(isVideo + "BreakCancel_test 非卡顿非解码", 1000);
                        // if (!breakInfo.decodeEndTime) {
                        //   breakInfo.decodeEndTime = now - 1000;
                        // }
                    }
                    else {
                        breakReport.decodeTime += 1000;
                    }
                }
                else {
                    if (framesCurrentSecond === 0) {
                        if (!breakInfo.resumeRecv) {
                            // 关闭画面或音频的信令提前收到，这一秒依然记为非解码非卡顿
                            breakInfo.noBreakNoDecodeDuration += 1000;
                        }
                        else {
                            breakInfo.breakStartTime = now - 1000;
                            // console.log(
                            //   isVideo + "BreakStart_test 卡顿开始4",
                            //   breakInfo.breakStartTime
                            // );
                            // 单段卡顿累计
                            breakReport.breakDuration += 1000;
                        }
                    }
                    else {
                        if (maxBreakValue > breakThreshold) {
                            if (!breakInfo.resumeRecv) {
                                // 关闭画面或音频的信令提前收到，这一秒依然记为非解码非卡顿
                                breakInfo.noBreakNoDecodeDuration += 1000;
                            }
                            else {
                                breakInfo.breakStartTime = now - maxBreakValue;
                                // console.log(
                                //   isVideo + "BreakStart_test 卡顿开始5",
                                //   breakInfo.breakStartTime
                                // );
                                // 单段卡顿累计
                                breakReport.breakDuration += maxBreakValue;
                                breakReport.decodeTime += 1000 - maxBreakValue;
                            }
                        }
                        else {
                            breakReport.decodeTime += 1000;
                        }
                    }
                }
            }
            if (isMediaEnabled && framesCurrentSecond) {
                breakInfo.resumeRecv = true;
            }
        };
        var now = new Date().getTime();
        var getIncrement = function (current, origin) {
            return current > origin ? current - origin : 0;
        };
        if (!this.lastSampleTime) {
            this.lastSampleTime = now - 1000;
        }
        // 获取视频卡顿
        if (videoStats) {
            // start: 计算卡顿指标 maxInterFrameDelay
            var totalInterFrameDelay = videoStats.totalInterFrameDelay, framesDecoded = videoStats.framesDecoded, totalSquaredInterFrameDelay = videoStats.totalSquaredInterFrameDelay;
            // 获取解码帧数
            var framesCurrentSecond = getIncrement(framesDecoded, this.totalQuality.framesDecode);
            this.totalQuality.framesDecode = framesDecoded;
            var interFrameDelayCS = getIncrement(totalInterFrameDelay, this.totalQuality.totalInterFrameDelay);
            this.totalQuality.totalInterFrameDelay = totalInterFrameDelay;
            var squaredInterFrameDelayCS = getIncrement(totalSquaredInterFrameDelay, this.totalQuality.totalSquaredInterFrameDelay);
            this.totalQuality.totalSquaredInterFrameDelay = totalSquaredInterFrameDelay;
            // 每秒帧间间隔标准差
            var interFrameDelayVarianceCS = (squaredInterFrameDelayCS -
                Math.pow(interFrameDelayCS, 2) / (framesCurrentSecond || 1)) /
                (framesCurrentSecond || 1);
            interFrameDelayVarianceCS =
                interFrameDelayVarianceCS > 0
                    ? interFrameDelayVarianceCS
                    : -interFrameDelayVarianceCS;
            // 每秒平均帧间间隔 (兼容老浏览器没有提供 totalInterFrameDelay, totalSquaredInterFrameDelay)
            var averageDelay = parseInt((1000 / (framesCurrentSecond + 1)).toString());
            // 每秒帧间间隔标准差
            var interFrameDelayStDevCS = Math.sqrt(interFrameDelayVarianceCS) * 1000;
            var averageInterFrameDelay = (interFrameDelayCS / (framesCurrentSecond || 1)) * 1000 || averageDelay;
            averageInterFrameDelay = parseInt((averageInterFrameDelay > 1000
                ? 1000
                : averageInterFrameDelay).toString());
            var maxInterFrameDelay = averageInterFrameDelay + interFrameDelayStDevCS;
            maxInterFrameDelay = parseInt((maxInterFrameDelay > 1000 ? 1000 : maxInterFrameDelay).toString());
            // end: 计算卡顿指标 maxInterFrameDelay
            // console.log("videobreak111", averageDelay, maxInterFrameDelay);
            // 记录首帧开始时间
            if (framesCurrentSecond > 0 &&
                this.player.cameraStatus === 0 &&
                !this.videoBreak.decodeStartTime) {
                this.videoBreak.decodeStartTime = now - 1000;
                // console.log( "videoBreakDecodeStart_test 解码开始1", this.videoBreak.breakStartTime );
            }
            if (this.videoBreak.decodeStartTime) {
                var isMediaEnabled = this.player.cameraStatus === 0 && this.player.playMediaStatus.video;
                // console.log("videoBreakDelay_test", maxInterFrameDelay, isMediaEnabled);
                recordBreakDuration(now, framesCurrentSecond, isMediaEnabled, this.videoBreak, this.videoBreakThreshold, this.videoBreakReport, averageInterFrameDelay, maxInterFrameDelay);
                // console.log("videobreakReport", this.videoBreakReport);
            }
        }
        // 音频卡顿
        if (audioStats) {
            // start: 音频卡顿
            var totalSamplesReceived = audioStats.totalSamplesReceived, concealedSamples = audioStats.concealedSamples, bytesReceived = audioStats.bytesReceived;
            var samplesCurrentSecond = getIncrement(totalSamplesReceived, this.totalQuality.totalSamplesReceived);
            this.totalQuality.totalSamplesReceived = totalSamplesReceived;
            var concealSamplesCurrentSecond = getIncrement(concealedSamples, this.totalQuality.concealedSamples);
            this.totalQuality.concealedSamples = concealedSamples;
            var bytesReceivedCS = getIncrement(bytesReceived, this.totalQuality.audioBytesReceived);
            this.totalQuality.audioBytesReceived = bytesReceived;
            var concealRatio = concealSamplesCurrentSecond / (samplesCurrentSecond || 1);
            var audioInterrupt = parseInt((concealRatio * 1000).toString());
            // end: 音频卡顿
            // 记录首帧开始时间
            if (bytesReceivedCS > 0 &&
                this.player.micStatus === 0 &&
                !this.audioBreak.decodeStartTime) {
                this.audioBreak.decodeStartTime = now - 1000;
                // console.log(  "audioBreakDecodeStart_test 解码开始2", this.audioBreak.breakStartTime  );
            }
            if (this.audioBreak.decodeStartTime) {
                var isMediaEnabled = this.player.micStatus === 0 && this.player.playMediaStatus.audio;
                // console.log("audioBreakDelay_test", audioInterrupt, isMediaEnabled);
                recordBreakDuration(now, bytesReceivedCS, isMediaEnabled, this.audioBreak, this.audioBreakThreshold, this.audioBreakReport, audioInterrupt, audioInterrupt, "audio");
                // console.log("audioBreakReport", this.audioBreakReport);
            }
            if (isToReport) {
                // playData.audioBreakDuration = this.audioBreakDuration;
                // playData.audioBreakRate = parseInt(
                //   (
                //     (this.audioBreakTimes / this.qualitySampleInterval) *
                //     10 *
                //     1000
                //   ).toString()
                // );
                // this.audioBreakDuration = 0;
                // this.audioBreakTimes = 0;
            }
        }
        callbackResults &&
            callbackResults.result().forEach(function (result) {
                // 隔三秒获取一次stats
                if (isToReport) {
                    // 获取其他流质量
                    if (result.type == "ssrc") {
                        if (result.names().indexOf("googBandwidthLimitedResolution") >= 0) {
                            playData.googBandwidthLimitedResolution = result.stat("googBandwidthLimitedResolution");
                        }
                        if (result.names().indexOf("codecImplementationName") >= 0) {
                            playData.codecImplementationName = result.stat("codecImplementationName");
                        }
                        if (result.stat("mediaType") == "video") {
                            if (result.names().indexOf("googCodecName") >= 0) {
                                playData.videoCodecName = result.stat("googCodecName");
                            }
                            // 获取视频流抖动延迟
                            if (result.names().indexOf("googCurrentDelayMs") >= 0) {
                                videoCurrentDelayMs = result.stat("googCurrentDelayMs");
                            }
                        }
                        if (result.stat("mediaType") == "audio") {
                            if (result.names().indexOf("googCodecName") >= 0) {
                                playData.audioCodecName = result.stat("googCodecName");
                            }
                            // 获取音频流抖动延迟
                            if (result.names().indexOf("googCurrentDelayMs") >= 0) {
                                audioCurrentDelayMs = result.stat("googCurrentDelayMs");
                            }
                        }
                        if (result.names().indexOf("googCpuLimitedResolution") >= 0) {
                            playData.googCpuLimitedResolution = result.stat("googCpuLimitedResolution");
                        }
                    }
                    if (result.type == "VideoBwe" &&
                        result.names().indexOf("googAvailableSendBandwidth") >= 0) {
                        playData.googAvailableSendBandwidth = result.stat("googAvailableSendBandwidth");
                    }
                }
            });
        if (isToReport) {
            rtcStats.forEach(function (result) {
                if ((result.type == "inbound-rtp" ||
                    (result.type == "ssrc" && result.bytesReceived != undefined)) &&
                    (result.mediaType == "audio" || result.id.indexOf("AudioStream") >= 0)) {
                    //audio
                    if (time != 0) {
                        // 计算音频码率
                        playData["audioBitrate"] =
                            (8 *
                                (result.bytesReceived -
                                    _this.lastPlayStats["audioBytesReceived"])) /
                                (result.timestamp - time);
                        // 计算音频丢包率
                        var deltaPacketsLost = result.packetsLost - _this.lastPlayStats.audioPacketsLost;
                        deltaPacketsLost > 0 &&
                            (audioLostRate =
                                deltaPacketsLost /
                                    (deltaPacketsLost +
                                        result.packetsReceived -
                                        _this.lastPlayStats.audioPacketsReceived));
                    }
                    if (playData["audioBitrate"] < 0) {
                        playData["audioBitrate"] = 0;
                    }
                    playData.audioJitter = result.jitter;
                    result.packetsLost > 0 &&
                        (playData.audioPacketsLost = result.packetsLost);
                    playData.audioFractionLost = result.fractionLost;
                    var timePacketsLost = result.packetsLost - _this.lastPlayStats.audioPacketsLost;
                    playData.audioFPS =
                        ((result.packetsReceived -
                            _this.lastPlayStats.audioPacketsReceived) /
                            (result.timestamp - time)) *
                            1000;
                    if (timePacketsLost > 0) {
                        playData.audioPacketsLostRate =
                            timePacketsLost /
                                (result.packetsReceived -
                                    _this.lastPlayStats.audioPacketsReceived +
                                    timePacketsLost);
                    }
                    else {
                        playData.audioPacketsLostRate = 0;
                    }
                    _this.lastPlayStats.audioBytesReceived = result.bytesReceived;
                    result.packetsLost > 0 &&
                        (_this.lastPlayStats.audioPacketsLost = result.packetsLost);
                    _this.lastPlayStats.audioPacketsReceived = result.packetsReceived;
                    _this.lastPlayStats.audioTime = result.timestamp;
                    _this.lastPlayStats.time = result.timestamp;
                    _this.lastPlayStats.audioBitrate = playData["audioBitrate"];
                    audioJitter = result.jitter;
                }
                else if ((result.type == "inbound-rtp" ||
                    (result.type == "ssrc" && result.bytesReceived != undefined)) &&
                    (result.mediaType == "video" || result.id.indexOf("VideoStream") >= 0)) {
                    //video
                    if (time != 0) {
                        playData.videoBitrate =
                            (8 *
                                (result.bytesReceived -
                                    _this.lastPlayStats.videoBytesReceived)) /
                                (result.timestamp - time);
                        playData.videoFPS =
                            (1000 *
                                (result.framesDecoded - _this.lastPlayStats.framesDecoded)) /
                                (result.timestamp - time);
                        var deltaPacketsLost = result.packetsLost - _this.lastPlayStats.videoPacketsLost;
                        deltaPacketsLost > 0 &&
                            (videoLostRate =
                                deltaPacketsLost /
                                    (deltaPacketsLost +
                                        result.packetsReceived -
                                        _this.lastPlayStats.videoPacketsReceived));
                    }
                    if (playData.videoBitrate < 0) {
                        playData.videoBitrate = 0;
                    }
                    if (playData.videoFPS < 0) {
                        playData.videoFPS = 0;
                    }
                    //playData.jitter = result.jitter;
                    playData.nackCount = result.nackCount;
                    playData.pliCount = result.pliCount;
                    //playData.sliCount = result.sliCount;
                    playData.videoFractionLost = result.fractionLost;
                    playData.videoFramesDecoded = result.framesDecoded;
                    result.packetsLost > 0 &&
                        (playData.videoPacketsLost = result.packetsLost);
                    var timePacketsLost = result.packetsLost - _this.lastPlayStats.videoPacketsLost;
                    if (timePacketsLost > 0) {
                        playData.videoPacketsLostRate =
                            timePacketsLost /
                                (result.packetsReceived -
                                    _this.lastPlayStats.videoPacketsReceived +
                                    timePacketsLost);
                    }
                    else {
                        playData.videoPacketsLostRate = 0;
                    }
                    _this.lastPlayStats.videoBytesReceived = result.bytesReceived;
                    _this.lastPlayStats.framesDecoded = result.framesDecoded;
                    result.packetsLost > 0 &&
                        (_this.lastPlayStats.videoPacketsLost = result.packetsLost);
                    _this.lastPlayStats.videoPacketsReceived = result.packetsReceived;
                    _this.lastPlayStats.videoTime = result.timestamp;
                    _this.lastPlayStats.time = result.timestamp;
                    videoJitter = result.jitter;
                }
                else if ((result.type == "track" &&
                    (result.kind == "video" || result.id.indexOf("video") >= 0)) ||
                    result.frameWidth) {
                    playData.frameHeight = result.frameHeight;
                    playData.frameWidth = result.frameWidth;
                    // 上报分辨率变化
                    if (time !== 0 &&
                        (_this.lastPlayStats.frameHeight !== result.frameHeight ||
                            _this.lastPlayStats.frameWidth !== result.frameWidth)) {
                        var reportSizeSeq = zego_entity_1.getReportSeq();
                        _this.dataReport.newReport(reportSizeSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskVideoPlaySize.event);
                        _this.dataReport.addMsgInfo(reportSizeSeq, {
                            session_id: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskVideoPlaySize.session_id(_this.sessionId),
                            w: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskVideoPlaySize.w(result.frameWidth),
                            h: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskVideoPlaySize.h(result.frameHeight)
                        });
                        !_this.player.isProbe && _this.dataReport.uploadReport(reportSizeSeq);
                        _this.lastPlayStats.frameHeight = result.frameHeight;
                        _this.lastPlayStats.frameWidth = result.frameWidth;
                    }
                    else if (time === 0) {
                        _this.lastPlayStats.frameHeight = result.frameHeight;
                        _this.lastPlayStats.frameWidth = result.frameWidth;
                    }
                    if (time != 0) {
                        playData.videoTransferFPS =
                            (1000 *
                                (result.framesReceived - _this.lastPlayStats.framesReceived)) /
                                (result.timestamp - time);
                        playData.videoFramesDropped =
                            result.framesDropped - _this.lastPlayStats.framesDropped;
                    }
                    if (playData.videoTransferFPS < 0) {
                        playData.videoTransferFPS = 0;
                    }
                    if (playData.videoFramesDropped < 0) {
                        playData.videoFramesDropped = 0;
                    }
                    _this.lastPlayStats.framesReceived = result.framesReceived;
                    _this.lastPlayStats.framesDropped = result.framesDropped;
                }
                else if (result.type == "track" &&
                    (result.kind == "audio" || result.id.indexOf("audio") >= 0)) {
                    playData.audioLevel = result.audioLevel;
                    playData.audioSendLevel = result.totalAudioEnergy;
                    playData.audioSamplingRate = result.totalSamplesDuration;
                }
                else if (result.type == "candidate-pair") {
                    if (result.totalRoundTripTime != undefined) {
                        playData.totalRoundTripTime = result.totalRoundTripTime;
                    }
                    if (result.currentRoundTripTime != undefined) {
                        playData.currentRoundTripTime = result.currentRoundTripTime;
                        rtt = playData.currentRoundTripTime * 1000;
                    }
                }
            });
            // 本地播放延迟值优先取音频的延迟
            this.lastPlayStats.googCurrentDelayMs =
                Number(audioCurrentDelayMs) || Number(videoCurrentDelayMs) || 0;
            videoLostRate =
                isNaN(videoLostRate) || videoLostRate < 0 ? 0 : videoLostRate;
            videoJitter = isNaN(videoJitter) || videoJitter < 0 ? 0 : videoJitter;
            audioLostRate =
                isNaN(audioLostRate) || audioLostRate < 0 ? 0 : audioLostRate;
            audioJitter = isNaN(audioJitter) || audioJitter < 0 ? 0 : audioJitter;
            var videoQuality = client_util_1.ClientUtil.getNetQuality(rtt, videoLostRate, videoJitter);
            var audioQuality = client_util_1.ClientUtil.getNetQuality(rtt, audioLostRate, audioJitter);
            playData.audioQuality =
                time > 0 ? client_util_1.ClientUtil.quality2QualityGrade(videoQuality) : 0;
            playData.videoQuality =
                time > 0 ? client_util_1.ClientUtil.quality2QualityGrade(audioQuality) : 0;
            var netQuality = Math.min(videoQuality, audioQuality);
            this.netQuality = netQuality;
            playData.peerToPeerDelay = !isNaN(this.p2pNetStats.p2pRTT)
                ? parseInt((this.p2pNetStats.p2pRTT / 2 +
                    this.lastPlayStats.googCurrentDelayMs).toString())
                : 0;
            playData.peerToPeerPacketLostRate =
                (this.p2pNetStats.p2pLostRate * 100) / 256;
            if (time > 0 &&
                netQuality <= zego_entity_1.QUALITY_CONSTANT.MiddleMinQuality &&
                now > this.probeTime + this.probeInterval) {
                this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SET_PLAYER_QUALITY_TIMER +
                    " netQuality " +
                    netQuality +
                    " start net probe");
                this.probeState = zego_entity_1.ENUM_PROBE_STATE.tryProbe;
                this.player.streamCenter.startNetProbe(false, this.player, this.player.gwNodeList);
                this.probeTime = now;
            }
            this.uploadPlayQuality(playData, now);
            var streamQuality = {
                video: {
                    videoBitrate: playData.videoBitrate,
                    videoFPS: playData.videoFPS,
                    videoTransferFPS: playData.videoTransferFPS,
                    videoFramesDecoded: playData.videoFramesDecoded,
                    videoFramesDropped: playData.videoFramesDropped,
                    videoPacketsLost: playData.videoPacketsLost,
                    videoPacketsLostRate: playData.videoPacketsLostRate,
                    videoQuality: playData.videoQuality,
                    frameHeight: playData.frameHeight,
                    frameWidth: playData.frameWidth,
                    muteState: playData.videoMuteState
                    // // 拉流视频卡顿
                    // videoBreakRate: playData.videoBreakRate,
                    // videoBreakDuration: playData.videoBreakDuration
                },
                audio: {
                    audioBitrate: playData.audioBitrate,
                    audioCodec: playData.audioCodec,
                    audioJitter: playData.audioJitter,
                    audioLevel: playData.audioLevel,
                    audioPacketsLost: playData.audioPacketsLost,
                    audioPacketsLostRate: playData.audioPacketsLostRate,
                    audioQuality: playData.audioQuality,
                    audioSamplingRate: playData.audioSamplingRate,
                    audioSendLevel: playData.audioSendLevel,
                    muteState: playData.audioMuteState,
                    audioFPS: playData.audioFPS
                    // // 拉流音频卡顿
                    // audioBreakRate: playData.audioBreakRate,
                    // audioBreakDuration: playData.audioBreakDuration
                },
                //roomId: '',
                nackCount: playData.nackCount,
                pliCount: playData.pliCount,
                totalRoundTripTime: playData.totalRoundTripTime,
                playData: playData.playData,
                currentRoundTripTime: playData.currentRoundTripTime,
                // 端到端报文
                peerToPeerDelay: playData.peerToPeerDelay,
                peerToPeerPacketLostRate: playData.peerToPeerPacketLostRate,
                sampleTimeWindow: playData.sampleTimeWindow
            };
            if (playData.muted !== undefined) {
                streamQuality.muted = playData.muted;
                streamQuality.paused = playData.paused;
                streamQuality.volume = playData.volume;
                streamQuality.sinkId = playData.sinkId;
            }
            if (playData.videoCodecName !== undefined) {
                // streamQuality.googBandwidthLimitedResolution = playData.googBandwidthLimitedResolution;
                streamQuality.video.googCodecName = playData.videoCodecName;
                streamQuality.audio.googCodecName = playData.audioCodecName;
                // streamQuality.googCpuLimitedResolution = playData.googCpuLimitedResolution;
                streamQuality.codecImplementationName =
                    playData.codecImplementationName;
                streamQuality.googAvailableSendBandwidth =
                    playData.googAvailableSendBandwidth;
            }
            if (time != 0) {
                this.player.onPlayQualityUpdate(this.streamId, streamQuality);
            }
        }
    };
    PlayStreamQuality.prototype.uploadPlayQuality = function (playData, now) {
        var _this = this;
        if (!this.qualityUpload) {
            return;
        }
        var timeStamp = now;
        if (this.qualityUploadLastTime == 0 ||
            timeStamp - this.qualityUploadLastTime >= this.qualityUploadInterval) {
            playData["stream_type"] = "play";
            playData["stream_id"] = this.streamId;
            playData["timeStamp"] = parseInt((timeStamp / 1000).toString());
            // 设置上报卡顿指标
            playData.video_break_duration = this.videoBreakReport.breakDuration;
            playData.video_break_cancel_duration = this.videoBreakReport.breakCancelDuration;
            playData.video_decode_time = this.videoBreakReport.decodeTime;
            this.videoBreakReport.breakCancelDuration = 0;
            this.videoBreakReport.breakDuration = 0;
            this.videoBreakReport.decodeTime = 0;
            playData.audio_break_duration = this.audioBreakReport.breakDuration;
            playData.audio_break_cancel_duration = this.audioBreakReport.breakCancelDuration;
            playData.audio_decode_time = this.audioBreakReport.decodeTime;
            this.audioBreakReport.breakCancelDuration = 0;
            this.audioBreakReport.breakDuration = 0;
            this.audioBreakReport.decodeTime = 0;
            playData.real_sampling_interval = timeStamp - this.lastSampleTime;
            // if (
            //   playData.real_sampling_interval -
            //     playData.video_decode_time -
            //     playData.video_break_duration +
            //     100 <
            //     0 ||
            //   playData.real_sampling_interval < 3000
            // ) {
            //   debugger;
            // }
            this.lastSampleTime = timeStamp;
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_UPLOAD_PLAYER_QUALITY +
                " " +
                this.streamId +
                " upload" +
                JSON.stringify(playData));
            this.player.streamCenter.updateQuality(1, playData);
            this.player.signal.QualityReport(zego_entity_1.getSeq(), this.sessionId, playData, function (seq, sessionId, data) {
                if (data.report !== undefined) {
                    _this.qualityUpload = data.report;
                    _this.qualityUploadInterval = data.report_interval_ms;
                }
            }, function (err) {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_UPLOAD_PLAYER_QUALITY +
                    " " +
                    _this.streamId +
                    " upload failed " +
                    err);
            });
            this.qualityUploadLastTime = timeStamp;
        }
    };
    PlayStreamQuality.prototype.getP2PNetStats = function () {
        var _this = this;
        this.player.signal.getP2PNetStats(zego_entity_1.getSeq(), this.sessionId, this.peerID, function (seq, sessionID, body) {
            var p2p_lost_rate = body.p2p_lost_rate, p2p_rtt = body.p2p_rtt;
            _this.p2pNetStats.p2pLostRate = p2p_lost_rate || 0;
            _this.p2pNetStats.p2pRTT = p2p_rtt || 0;
        }, function (errcode) {
            // TODO: 错误日志处理
            // if (SEND_MSG_TIMEOUT === errcode) {
            // }
        });
    };
    PlayStreamQuality.prototype.setPlayQualityTimer = function () {
        var _this = this;
        if (this.qualityTimer != null) {
            return;
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SET_PLAYER_QUALITY_TIMER +
            " " +
            this.streamId +
            " startTimer");
        this.clearPlayQualityTimer();
        this.getP2PNetStats();
        this.qualityTimer = setInterval(function () {
            _this.sampleTimes++;
            var peerConnection = _this.player.peerConnection;
            if (peerConnection) {
                var promiseList = [peerConnection.getStats(null)];
                if (_this.player.stateCenter.browser == "chrome") {
                    promiseList.push(new Promise(function (resolve, reject) {
                        peerConnection.getStats(function (results) { return resolve(results); }, function (err) { return reject(err); });
                    }));
                }
                Promise.all(promiseList)
                    .then(function (values) {
                    var stats = _this.getPlayStats(values[0], values[1]);
                })
                    .catch(function (error) {
                    _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SET_PLAYER_QUALITY_TIMER +
                        " " +
                        _this.streamId +
                        " getStats error " +
                        error.toString());
                });
            }
        }, 1000);
        this.lastPlayStats = {
            audioPacketsLost: 0,
            videoPacketsLost: 0,
            time: 0,
            audioTime: 0,
            videoTime: 0,
            audioBytesReceived: 0,
            videoBytesReceived: 0,
            videoPacketsReceived: 0,
            audioPacketsReceived: 0,
            framesDecoded: 0,
            framesReceived: 0,
            framesDropped: 0,
            audioBitrate: 0
        };
    };
    // 停止拉流质量上报
    PlayStreamQuality.prototype.clearPlayQualityTimer = function () {
        if (this.qualityTimer != null) {
            clearInterval(this.qualityTimer);
            this.qualityTimer = null;
            // 停止拉流记录卡顿结束
            var now_1 = new Date().getTime();
            this.lastSampleTime = 0;
            this.sampleTimes = 0;
            // console.log("videobreak 重置获取拉质量");
            // 重置卡顿相关指标累计参数
            this.totalQuality = {
                totalSquaredInterFrameDelay: 0,
                totalInterFrameDelay: 0,
                framesDecode: 0,
                totalSamplesReceived: 0,
                concealedSamples: 0,
                audioBytesReceived: 0
            };
            var calculateCumulativeDuration = function (breakInfo, breakReport, breakThreshold, isMediaEnabled, isVideo) {
                if (isVideo === void 0) { isVideo = "video"; }
                breakThreshold = breakThreshold > 1000 ? 1000 : breakThreshold;
                // 重置上一小段拉流质量统计
                breakReport.breakDuration = 0;
                breakReport.breakCancelDuration = 0;
                breakReport.decodeTime = 0;
                // isVideo === "video" &&
                //   console.log("videobreak 重置breakReport ", this.videoBreakReport);
                // 停止拉流时记录非解码非卡顿时长;
                if (breakInfo.decodeStartTime) {
                    var playEndTime = now_1;
                    // 获取上一段拉流时长,并计入总拉流时长
                    var playDuration = playEndTime - breakInfo.decodeStartTime;
                    breakInfo.decodeStartTime = undefined;
                    // console.log(
                    //   isVideo + "BreakDecodeEnd_test 解码结束1",
                    //   playEndTime,
                    //   playDuration
                    // );
                    breakInfo.totalDuration += playDuration;
                    // 将断网这段时间的拉流黑屏记为卡顿时间
                    if (breakInfo.breakStartTime) {
                        var breakEndTime = playEndTime;
                        var breakDuration = breakEndTime - breakInfo.breakStartTime;
                        breakInfo.breakStartTime = undefined;
                        if (!isMediaEnabled) {
                            breakInfo.noBreakNoDecodeDuration += breakDuration;
                            // console.log(
                            //   isVideo + "BreakEnd_test 卡顿取消2",
                            //   breakEndTime,
                            //   breakDuration
                            // );
                        }
                        else if (breakDuration > breakThreshold) {
                            breakInfo.cumulativeBreakDuration += breakDuration;
                            // console.log(
                            //   isVideo + "BreakEnd_test 卡顿结束2",
                            //   breakEndTime,
                            //   breakDuration
                            // );
                        }
                    }
                    // 获取总的累计值
                    //  总卡顿时长
                    var cumulativeBreakTime = breakInfo.cumulativeBreakDuration;
                    // 总解码时长
                    var totalDuration = breakInfo.totalDuration, cumulativeBreakDuration = breakInfo.cumulativeBreakDuration, noBreakNoDecodeDuration = breakInfo.noBreakNoDecodeDuration;
                    var cumulativeDecodeTime = totalDuration - cumulativeBreakDuration - noBreakNoDecodeDuration;
                    breakInfo.cumulativeDecodeDuration = cumulativeDecodeTime;
                    return {
                        cumulativeBreakDuration: cumulativeBreakTime,
                        cumulativeDecodeDuration: cumulativeDecodeTime
                    };
                }
                return {
                    cumulativeBreakDuration: 0,
                    cumulativeDecodeDuration: 0
                };
            };
            var enableVideo = this.player.cameraStatus === 0 && this.player.playMediaStatus.video;
            calculateCumulativeDuration(this.videoBreak, this.videoBreakReport, this.videoBreakThreshold, enableVideo);
            var enableAudio = this.player.micStatus === 0 && this.player.playMediaStatus.audio;
            calculateCumulativeDuration(this.audioBreak, this.audioBreakReport, this.audioBreakThreshold, enableAudio, "audio");
        }
        this.lastPlayStats = {
            audioPacketsLost: 0,
            videoPacketsLost: 0,
            time: 0,
            audioTime: 0,
            videoTime: 0,
            audioBytesReceived: 0,
            videoBytesReceived: 0,
            videoPacketsReceived: 0,
            audioPacketsReceived: 0,
            framesDecoded: 0,
            framesDropped: 0,
            framesReceived: 0,
            audioBitrate: 0
        };
    };
    PlayStreamQuality.prototype.startProbeTimeout = function () {
        var _this = this;
        this.probeTimer = setTimeout(function () {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY + " probe timeout");
            _this.player.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kProbeTimeOutError);
        }, this.probeTimeoutInterval);
    };
    PlayStreamQuality.prototype.stopProbeTimeout = function () {
        if (this.probeTimer) {
            clearTimeout(this.probeTimer);
            this.probeTimer = null;
        }
    };
    return PlayStreamQuality;
}());
exports.PlayStreamQuality = PlayStreamQuality;


/***/ }),

/***/ "./sdk/src/webrtc/modules/playModules/zego.play.web.ts":
/*!*************************************************************!*\
  !*** ./sdk/src/webrtc/modules/playModules/zego.play.web.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoPlayWeb = void 0;
var zego_entity_1 = __webpack_require__(/*! ../../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var sdpUtil_1 = __webpack_require__(/*! ../../../util/sdpUtil */ "./sdk/src/util/sdpUtil.ts");
var client_util_1 = __webpack_require__(/*! ../../../util/client-util */ "./sdk/src/util/client-util.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var action_1 = __webpack_require__(/*! ../../../common/action */ "./sdk/src/common/action.ts");
var playStreamQuality_1 = __webpack_require__(/*! ./playStreamQuality */ "./sdk/src/webrtc/modules/playModules/playStreamQuality.ts");
var MAX_MESSAGE_SIZE = 65536;
var MSG_TIMEOUT = 4000;
var MSG_HEADER_SIZE = 10; //1 + 1 + 2 + 2 + 4
var END_OF_MSG = 0x1;
var TYPE_USER_DATA = 1;
var ZegoPlayWeb = /** @class */ (function () {
    function ZegoPlayWeb(log, signal, dataReport, qualityTimeInterval, streamCenter, ac, stateCenter) {
        this.state = zego_entity_1.ENUM_PLAY_STATE.stop;
        this.candidateInfo = [];
        // waitingAnswerTimer: number;
        // waitingAnswerTimeInterval = 0;
        // qualityTimer: any = null;
        // qualityTimeInterval: number;
        //连麦状态
        this.broadcasterStatus = zego_entity_1.ENUM_BROADCASTER_STATUS.stop;
        this.playQualityList = [];
        this.maxQualityListCount = 10;
        //事件上报seq /sdk/api/play_request
        this.reportSeq = NaN;
        //RTCplayStream
        this.streamReportSeq = zego_entity_1.getSeq();
        this.videoSizeCallback = false;
        this.remoteStream = null;
        this.playStream = null;
        this.playOption = {};
        this.playMediaStatus = {
            video: true,
            audio: true
        };
        this.closeSessionSignal = false;
        this.stateNego = zego_entity_1.ENUM_PLAY_STATE_NEGO.stop;
        this.negoTimer = null;
        this.negoInterval = 25000;
        //对端流的摄像头与麦克风状态, 0 为 开启 非0 为 关闭，其中 2 为正常关闭
        this.cameraStatus = 0;
        this.micStatus = 0;
        this.hasSentStreamStatus = false;
        this.playEvent = false;
        this.gotStreamStatus = false;
        this.soundLevel = 0;
        this.mic = null;
        this.script = null;
        //开始调用拉流接口时间
        this.beginTime = 0;
        this.firstFrameTime = 0;
        //是否走l3
        this.resourceMode = 0;
        //单中心
        this.gwNode = "";
        this.gwNodeList = [];
        this.gwNodeTTL = 0;
        //是否开启peer模式
        this.isPeer = false;
        this.peerFailCount = 0;
        //是否为探测模式
        this.isProbe = false;
        this.peerID = 0;
        // netQuality = 0;
        // probeTime = 0;
        // probeInterval = 60000;
        // probeState = ENUM_PROBE_STATE.probed;
        this.isRecvClientInfo = false;
        /**音轨是否禁止 */
        this.audioMuteState = "0";
        /**视轨是否禁止 */
        this.videoMuteState = "0";
        this.first_pkt = true;
        this.next_sn = [];
        this.pkt_list = [];
        this.onDataChannelList = [];
        this.iceDisconnectedMaxTime = 15000;
        this.logger = log;
        this.signal = signal;
        this.dataReport = dataReport;
        this.streamCenter = streamCenter;
        this.ac = ac;
        this.stateCenter = stateCenter;
        this.dataReport.newReport(this.streamReportSeq);
        this.dataReport.addMsgInfo(this.streamReportSeq, {
            abs_time: Date.now()
        });
        this.qualityHandler = new playStreamQuality_1.PlayStreamQuality(qualityTimeInterval, this, this.logger, this.dataReport);
        this.resourceMode = this.stateCenter.settingConfig.getSetting("resource_mode");
    }
    Object.defineProperty(ZegoPlayWeb.prototype, "probeState", {
        get: function () {
            return this.qualityHandler.probeState;
        },
        set: function (state) {
            this.qualityHandler.probeState = state;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ZegoPlayWeb.prototype, "netQuality", {
        get: function () {
            return this.qualityHandler.netQuality;
        },
        set: function (val) {
            this.qualityHandler.netQuality = val;
        },
        enumerable: false,
        configurable: true
    });
    ZegoPlayWeb.prototype.startPlay = function (streamId, success, playOption) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY + " called ", streamId);
        this.playEvent = false;
        this.signal &&
            this.signal.negoInterval &&
            (this.negoInterval = this.signal.negoInterval);
        if (!streamId) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY + " streamId is null");
            return;
        }
        this.streamId = streamId;
        this.getRemoteStreamSuc = success;
        this.playOption = playOption || {};
        this.playMediaStatus = {
            video: this.playOption.video === undefined ? true : !!this.playOption.video,
            audio: this.playOption.audio === undefined ? true : !!this.playOption.audio
        };
        if (playOption && playOption.videoCodec) {
            this.playOption.videoCodec = playOption.videoCodec;
        }
        var _videoCodec = this.stateCenter.settingConfig.getSetting("play_video_codec", true);
        if (_videoCodec) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY +
                " setting play_video_codec " +
                _videoCodec);
            this.playOption.videoCodec = _videoCodec;
        }
        this.dataReport.addMsgInfo(this.reportSeq, {
            audio_activate: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.audio_activate(this.playOption.audio == true
                ? 1
                : this.playOption.audio == false
                    ? 0
                    : 1),
            video_activate: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.video_activate(this.playOption.video == true
                ? 1
                : this.playOption.video == false
                    ? 0
                    : 1)
        });
        this.isPeer ? this.createOffer() : this.createSession();
        // 下面的代码，在服务器没有返回任何错误码，且协商不成功时才会回调
        this.negoTimer = setTimeout(function () {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY + " waiting timeout");
            _this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayNegoTimeoutError);
        }, this.negoInterval);
        // 下面代码，在探测一段时间内无结果后触发
        this.isProbe && this.qualityHandler.startProbeTimeout();
        //
        //   (this.qualityHandler.probeTimer = setTimeout(() => {
        //     this.logger.error(
        //       ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY + " probe timeout"
        //     );
        //     this.playStateUpdateError(
        //       ZegoRTCLogEvent.kZegoTaskPlayStart.error.kProbeTimeOutError
        //     );
        //   }, this.qualityHandler.probeTimeoutInterval));
    };
    ZegoPlayWeb.prototype.onCreatePlaySessionSuccess = function (data) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
            " " +
            this.streamId +
            " success");
        var urls = [];
        if (data.turn_server) {
            var turnServer = data.turn_server;
            var _turnToTcp = this.stateCenter.turnOverTcpOnly;
            var udpOrTcp = this.stateCenter.settingConfig.getSetting("udp_or_tcp", true);
            if (udpOrTcp) {
                this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
                    " setting udp_or_tcp " +
                    udpOrTcp);
                _turnToTcp = udpOrTcp === "tcp";
            }
            _turnToTcp && (turnServer = turnServer.replace("udp", "tcp"));
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
                " turn over tcp " +
                turnServer);
            urls.push(turnServer);
        }
        if (data.stun_server)
            urls.push(data.stun_server);
        var configuration = {
            iceTransportPolicy: "relay",
            iceServers: [
                {
                    urls: urls,
                    username: data.turn_username,
                    credential: data.turn_auth_key
                }
            ]
        };
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
            " " +
            this.streamId +
            " username: " +
            data.turn_username);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
            " " +
            this.streamId +
            " credential: " +
            data.turn_auth_key);
        this.createOffer(configuration);
        //register callback
        this.signal.registerPushCallback("MediaDescPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvMediaDesc(seq, sessionId, data);
        });
        this.signal.registerPushCallback("CandidateInfoPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvCandidateInfo(seq, sessionId, data);
        });
        this.signal.registerPushCallback("CloseSessionPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvCloseSession(seq, sessionId, data);
        });
        // this.signal.registerPushCallback("WebSocketDisconnect", this.sessionId, onDisconnect, this);
        this.signal.registerPushCallback("SessionResetPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvResetSession(seq, sessionId, data);
        });
        this.signal.registerPushCallback("StreamStatusNotifyPush", this.sessionId, function (seq, sessionId, data) {
            _this.gotStreamStatus = true;
            _this.streamStatus = data;
            _this.playStream && _this.onRecvStreamStatus(data);
        });
        this.signal.registerPushCallback("PlayEventPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvPlayEvent(seq, sessionId, data);
        });
        this.signal.registerPushCallback("ClientInfoPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvClientInfo(seq, sessionId, data);
        });
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
            " " +
            this.streamId +
            " call success");
    };
    ZegoPlayWeb.prototype.createOffer = function (configuration) {
        var _this = this;
        this.peerConnection = new RTCPeerConnection(configuration);
        this.peerConnection.onicecandidate = function (e) {
            _this.onIceCandidate(e);
        };
        this.peerConnection.onsignalingstatechange = function (e) {
            _this.onConnectionStateChange(e);
        };
        this.peerConnection.oniceconnectionstatechange = function (e) {
            _this.onIceConnectionStateChange(e);
        };
        this.peerConnection.ontrack = function (e) {
            _this.onGotRemoteStream(e.streams[0]);
        };
        if (this.streamCenter.isDataChannelEnabled) {
            this.dataChannel = this.peerConnection.createDataChannel(this.streamId);
            this.dataChannel.binaryType = "arraybuffer";
            this.dataChannel.onopen = function (event) {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
                    " " +
                    _this.streamId +
                    " data channel open");
            };
            this.dataChannel.onmessage = function (event) {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
                    " " +
                    _this.streamId +
                    " data channel onmessage");
                if (event.data instanceof Blob) {
                    var reader_1 = new FileReader();
                    var _event_1 = {};
                    reader_1.readAsArrayBuffer(event.data);
                    reader_1.onload = function () {
                        _event_1.data = reader_1.result;
                        _this.onReceivedDataChannel(_event_1);
                    };
                    // (event.data as Blob).arrayBuffer().then(data => {
                    //   _event.data = data;
                    //   this.onReceivedDataChannel(_event);
                    // });
                }
                else {
                    _this.onReceivedDataChannel(event);
                }
            };
        }
        var offerOptions = {
            offerToReceiveAudio: 1,
            offerToReceiveVideo: 1
        };
        if (this.playOption && this.playOption.video === false) {
            offerOptions.offerToReceiveVideo = 0;
        }
        if (this.playOption && this.playOption.audio === false) {
            offerOptions.offerToReceiveAudio = 0;
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
            " " +
            this.streamId +
            " createOffer: " +
            JSON.stringify(offerOptions));
        //create offer
        this.dataReport.eventStart(this.reportSeq, "CreateOffer");
        this.dataReport.eventStart(this.streamReportSeq, "CreateOffer");
        this.peerConnection.createOffer(offerOptions).then(function (desc) {
            _this.dataReport.eventEnd(_this.reportSeq, "CreateOffer");
            _this.dataReport.eventEnd(_this.streamReportSeq, "CreateOffer");
            _this.onCreateOfferSuccess(desc);
        }, function (error) {
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "CreateOffer", {
                error: error.toString()
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "CreateOffer", {
                error: error.toString()
            });
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
                " " +
                _this.streamId +
                " create offer error " +
                error.toString());
            _this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kCreateOfferError, true);
        });
    };
    ZegoPlayWeb.prototype.createSession = function (desc) {
        var _this = this;
        //create session
        this.sessionSeq = zego_entity_1.getSeq();
        var totalStreamId = this.streamId;
        if (this.streamCenter.testEnvironment == true) {
            totalStreamId =
                "zegotest-" + this.streamCenter.appid + "-" + this.streamId;
        }
        // 云控
        var gwNodes = this.stateCenter.settingConfig.getSetting("gw_nodes");
        if (gwNodes && gwNodes instanceof Array && gwNodes.length > 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY +
                " setting " +
                JSON.stringify(gwNodes));
            this.gwNodeList = gwNodes;
            this.gwNode = this.gwNodeList[0] || this.gwNode;
        }
        if (this.isPeer) {
            this.dataReport.eventStart(this.reportSeq, "CreateSessionWithSdp");
            this.dataReport.eventStart(this.streamReportSeq, "CreateSessionWithSdp");
            var _bufLevel = this.stateCenter.settingConfig.getSetting("l3_play_buffer_ms");
            this.signal.createSessionWithSdp({
                seq: this.sessionSeq,
                type: this.isProbe ? 2 : 1,
                mode: 0,
                streamId: totalStreamId,
                strAuthParam: this.playOption
                    ? this.playOption.streamParams || ""
                    : "",
                sdp: desc.sdp,
                serverHost: this.gwNode,
                playBufLevel: this.resourceMode == 2 ? _bufLevel : undefined
            }, function (seq, sessionID, msg) {
                _this.handleCreateSessionWithSdpResp(seq, sessionID, msg);
            }, function (err, seq) {
                _this.dataReport.eventEndWithMsg(_this.reportSeq, "CreateSession", {
                    error: err
                });
                _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "CreateSession", {
                    error: err
                });
                //后台网关若不支持peer模式则改用老模式,探测模式只支持peer，探测模式超时直接失败
                if (!_this.isProbe &&
                    err == zego_entity_1.SEND_MSG_TIMEOUT &&
                    _this.peerFailCount < 2) {
                    _this.peerFailCount++;
                    _this.createSession(desc);
                }
                else if (!_this.isProbe &&
                    err == zego_entity_1.SEND_MSG_TIMEOUT &&
                    _this.peerFailCount >= 2) {
                    _this.isPeer = false;
                    _this.streamCenter.isPeer = false;
                    _this.createSession();
                }
                else {
                    _this.playStateUpdateError(err == zego_entity_1.SEND_MSG_TIMEOUT
                        ? zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kSessionTimeoutError
                        : zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kSessionRequestError);
                }
            });
        }
        else {
            this.dataReport.eventStart(this.reportSeq, "CreateSession");
            this.dataReport.eventStart(this.streamReportSeq, "CreateSession");
            this.signal.createSession(this.sessionSeq, 1, 0, totalStreamId, this.playOption && this.playOption.streamParams, this.gwNode, function (seq, sessionID, msg) {
                _this.handleCreateSessionResp(seq, sessionID, msg);
            }, function (err, seq) {
                _this.dataReport.eventEndWithMsg(_this.reportSeq, "CreateSession", {
                    error: err
                });
                _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "CreateSession", {
                    error: err
                });
                _this.playStateUpdateError(err == zego_entity_1.SEND_MSG_TIMEOUT
                    ? zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kSessionTimeoutError
                    : zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kSessionRequestError);
            });
        }
        this.state = zego_entity_1.ENUM_PLAY_STATE.waitingSessionRsp;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY +
            " " +
            this.streamId +
            " called success");
        this.stateNego = zego_entity_1.ENUM_PLAY_STATE_NEGO.start;
    };
    ZegoPlayWeb.prototype.handleCreateSessionResp = function (seq, sessionID, msg) {
        var turnServer = msg.turn_server;
        var ip = turnServer.split("?")[0] && turnServer.split("?")[0].slice(5);
        var serverArr = this.streamCenter.server.split("?");
        var app = serverArr[1] && serverArr[1].slice(2);
        this.dataReport.eventEndWithMsg(this.streamReportSeq, "CreateSession", {
            sessionId: msg.session_id,
            url: "webrtc://" + ip + "/" + app + "/" + this.streamId
        });
        this.dataReport.eventEndWithMsg(this.reportSeq, "CreateSession", {
            sessionId: msg.session_id,
            url: "webrtc://" + ip + "/" + app + "/" + this.streamId
        });
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY +
            " " +
            this.streamId +
            " sessionId:" +
            msg.session_id);
        if (this.sessionSeq != seq) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY + " seq is not match.");
            return;
        }
        this.gwNodeList =
            msg.gw_nodes && msg.gw_nodes.length > 0 ? msg.gw_nodes : this.gwNodeList;
        this.gwNode =
            msg.gw_nodes && msg.gw_nodes.length > 0
                ? this.gwNodeList[0]
                : this.gwNode;
        this.gwNodeTTL = msg.gw_nodes_ttl
            ? new Date().getTime() + msg.gw_nodes_ttl * 1000
            : this.gwNodeTTL;
        this.stateCenter.clientIP = msg.clientip
            ? msg.clientip
            : this.stateCenter.clientIP;
        if (msg.result !== 0) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY +
                " " +
                this.streamId +
                " create error");
            this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kSessionRequestError);
        }
        else {
            this.sessionId = msg.session_id;
            this.sessionToken = msg.session_token;
            this.dataReport.addMsgInfo(this.reportSeq, {
                session_id: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.session_id(this.sessionId)
            });
            this.onCreatePlaySessionSuccess(msg);
        }
    };
    ZegoPlayWeb.prototype.handleCreateSessionWithSdpResp = function (seq, sessionID, msg) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_HANDLE_CREATE_SESSION_WITH_SDP +
            " sessionId:" +
            sessionID);
        if (this.sessionSeq != seq) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_HANDLE_CREATE_SESSION_WITH_SDP +
                " seq is not match.");
            return;
        }
        this.gwNodeList =
            msg.gw_nodes && msg.gw_nodes.length > 0 ? msg.gw_nodes : this.gwNodeList;
        this.gwNode =
            msg.gw_nodes && msg.gw_nodes.length > 0
                ? this.gwNodeList[0]
                : this.gwNode;
        this.gwNodeTTL = msg.gw_nodes_ttl
            ? new Date().getTime() + msg.gw_nodes_ttl * 1000
            : this.gwNodeTTL;
        this.stateCenter.clientIP = msg.clientip
            ? msg.clientip
            : this.stateCenter.clientIP;
        this.dataReport.eventEndWithMsg(this.streamReportSeq, "CreateSessionWithSdp", {
            sessionId: sessionID
        });
        this.dataReport.eventEndWithMsg(this.reportSeq, "CreateSessionWithSdp", {
            sessionId: sessionID
        });
        if (msg.result !== 0) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_HANDLE_CREATE_SESSION_WITH_SDP +
                " create session failed " +
                msg.result);
            this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kSessionRequestError);
        }
        else {
            this.sessionId = sessionID;
            this.sessionToken = msg.session_token;
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_HANDLE_CREATE_SESSION_WITH_SDP +
                " create session success ", this.streamId);
            this.signal.registerPushCallback("CloseSessionPush", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvCloseSession(seq, sessionId, data);
            });
            // this.signal.registerPushCallback("WebSocketDisconnect", this.sessionId, onDisconnect, this);
            this.signal.registerPushCallback("SessionResetPush", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvResetSession(seq, sessionId, data);
            });
            this.signal.registerPushCallback("StreamStatusNotifyPush", this.sessionId, function (seq, sessionId, data) {
                _this.gotStreamStatus = true;
                _this.streamStatus = data;
                _this.playStream && _this.onRecvStreamStatus(data);
            });
            this.signal.registerPushCallback("PlayEventPush", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvPlayEvent(seq, sessionId, data);
            });
            this.signal.registerPushCallback("ClientInfoPush", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvClientInfo(seq, sessionId, data);
            });
            //
            this.signal.registerPushCallback("NetQualityProbeRsp", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvPlayEvent(seq, sessionId, data);
            });
            this.signal.registerPushCallback("NetQualityInfoPush", this.sessionId, function (seq, sessionID, data) {
                _this.onRecvNetQualityInfo(seq, sessionID, data);
            });
            this.onGetRemoteOfferSuccess(msg.sdp);
        }
    };
    ZegoPlayWeb.prototype.onCreateOfferSuccess = function (desc) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_OFFER_SUCCESS +
            " " +
            this.streamId +
            " localSdp1 " +
            desc.sdp.substr(0, desc.sdp.length / 2));
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_OFFER_SUCCESS +
            " " +
            this.streamId +
            " localSdp2 " +
            desc.sdp.substr(desc.sdp.length / 2));
        desc.sdp = desc.sdp.replace(/sendrecv/g, "recvonly");
        desc.sdp = desc.sdp.replace(/useinbandfec=/, "stereo=1;useinbandfec=");
        var dataChannelSdp = desc.sdp.match(/m=application[\s\S]+datachannel[\s\S]+/)
            ? desc.sdp.match(/m=application[\s\S]+datachannel[\s\S]+/)[0]
            : null;
        if (dataChannelSdp) {
            var newDataChannelSdp = dataChannelSdp.replace(/recvonly/, "sendrecv");
            desc.sdp = desc.sdp.replace(dataChannelSdp, newDataChannelSdp);
        }
        // 避免拉流丢包时画面出现马赛克
        var video_fmtp = desc.sdp.match(/m=video(.|\r|\n)*a=rtpmap(.|\r|\n)*(a=fmtp:(102).*)/);
        if (video_fmtp !== null) {
            var fmtp = video_fmtp[3];
            desc.sdp = desc.sdp.replace(fmtp, fmtp + ";sps-pps-idr-in-keyframe=1");
        }
        if (this.playOption.videoCodec) {
            desc.sdp = sdpUtil_1.SdpUtil.getSDPByVideDecodeType(desc.sdp, this.playOption.videoCodec);
        }
        this.dataReport.eventStart(this.reportSeq, "SetLocalDescription");
        this.dataReport.eventStart(this.streamReportSeq, "SetLocalDescription");
        this.peerConnection.setLocalDescription(desc).then(function () {
            _this.dataReport.eventEnd(_this.reportSeq, "SetLocalDescription");
            _this.dataReport.eventEnd(_this.streamReportSeq, "SetLocalDescription");
            _this.onSetLocalDescriptionSuccess(desc);
        }, function (error) {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_OFFER_SUCCESS +
                " " +
                _this.streamId +
                " set error " +
                error.toString());
            _this.dataReport.eventEnd(_this.reportSeq, "SetLocalDescription", {
                error: error.toString()
            });
            _this.dataReport.eventEnd(_this.streamReportSeq, "SetLocalDescription", {
                error: error.toString()
            });
            _this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kSetLocalDescError, true);
        });
    };
    ZegoPlayWeb.prototype.onSetLocalDescriptionSuccess = function (desc) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
            " " +
            this.streamId +
            " success");
        if (this.isPeer) {
            this.createSession(desc);
            return;
        }
        var mediaDescription = {
            sdp: desc.sdp
        };
        if (this.resourceMode == 2) {
            mediaDescription["min_play_buf_level_ms"] = 500;
        }
        this.answerSeq = zego_entity_1.getSeq();
        this.dataReport.eventStart(this.reportSeq, "SendMediaDesc");
        this.dataReport.eventStart(this.streamReportSeq, "SendMediaDesc");
        this.signal.sendMediaDesc(this.answerSeq, this.sessionId, 0, mediaDescription, function (seq, sessionId, data) {
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
                " " +
                _this.streamId +
                " sendMediaDesc resp");
            if (_this.answerSeq != seq || _this.sessionId != sessionId) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
                    " " +
                    _this.streamId +
                    " seq or sessionId is not equal " +
                    _this.answerSeq +
                    " " +
                    seq, +" " + _this.sessionId + " " + sessionId);
                return;
            }
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
                " " +
                _this.streamId +
                " send success stateNego:waiterAnswer");
            _this.stateNego = zego_entity_1.ENUM_PLAY_STATE_NEGO.waiterAnswer;
            _this.dataReport.eventEnd(_this.reportSeq, "SendMediaDesc");
            _this.dataReport.eventEnd(_this.streamReportSeq, "SendMediaDesc");
            _this.state = zego_entity_1.ENUM_PLAY_STATE.waitingServerAnswer;
        }, function (err, seq) {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
                " " +
                _this.streamId +
                " failed to send " +
                err);
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "SendMediaDesc", {
                error: err
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "SendMediaDesc", {
                error: err
            });
            _this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kMediaDescError);
        });
        this.state = zego_entity_1.ENUM_PLAY_STATE.waitingOfferRsp;
    };
    ZegoPlayWeb.prototype.onRecvMediaDesc = function (seq, sessionId, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_MEDIA_DESC +
            " " +
            this.streamId +
            " received ", data);
        this.stateNego = zego_entity_1.ENUM_PLAY_STATE_NEGO.waitingCandidate;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_MEDIA_DESC +
            " " +
            this.streamId +
            " received stateNego:waitingCandidate");
        if (this.state !== zego_entity_1.ENUM_PLAY_STATE.waitingServerAnswer) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_MEDIA_DESC +
                " " +
                this.streamId +
                " current state " +
                this.state +
                " not allowed");
            return;
        }
        this.dataReport.addEvent(this.reportSeq, "RecvMediaDesc");
        this.dataReport.addEvent(this.streamReportSeq, "RecvMediaDesc");
        this.signal.sendMediaDescAck(seq, this.sessionId, 0);
        this.onGetRemoteOfferSuccess(data.sdp);
    };
    ZegoPlayWeb.prototype.onGetRemoteOfferSuccess = function (sdp) {
        var _this = this;
        var _a;
        var offerDescription = {
            type: "answer",
            sdp: sdp,
            toJSON: function () { }
        };
        //setRemoteDescritpion
        this.dataReport.eventStart(this.reportSeq, "SetRemoteDescription");
        this.dataReport.eventStart(this.streamReportSeq, "SetRemoteDescription");
        var _turnToTcp = this.stateCenter.turnOverTcpOnly;
        var udpOrTcp = this.stateCenter.settingConfig.getSetting("udp_or_tcp", true);
        if (udpOrTcp) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_MEDIA_DESC +
                " setting udp_or_tcp " +
                udpOrTcp);
            _turnToTcp = udpOrTcp === "tcp";
        }
        if (_turnToTcp) {
            (_a = offerDescription.sdp.match(/candidate.*/g)) === null || _a === void 0 ? void 0 : _a.forEach(function (candStr) {
                var repCandStr = candStr.replace(/udp/, "tcp");
                //@ts-ignore
                offerDescription.sdp = offerDescription.sdp.replace(candStr, repCandStr);
            });
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_MEDIA_DESC +
            " " +
            this.streamId +
            " remoteSdp ", offerDescription.sdp);
        this.peerConnection
            .setRemoteDescription(new RTCSessionDescription(offerDescription))
            .then(function () {
            _this.dataReport.eventEnd(_this.reportSeq, "SetRemoteDescription");
            _this.dataReport.eventEnd(_this.streamReportSeq, "SetRemoteDescription");
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_MEDIA_DESC +
                " " +
                _this.streamId +
                " set success");
        }, function (error) {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_MEDIA_DESC +
                " " +
                _this.streamId +
                " set remote error " +
                error.toString());
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "SetRemoteDescription", {
                error: error.toString()
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "SetRemoteDescription", {
                error: error.toString()
            });
            _this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kSetRemoteDescError, true);
        });
        this.state = zego_entity_1.ENUM_PLAY_STATE.waitingServerICE;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_MEDIA_DESC +
            " " +
            this.streamId +
            " call success");
    };
    ZegoPlayWeb.prototype.onRecvCandidateInfo = function (seq, sessionId, data) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_CANDIDATE_INFO +
            " " +
            this.streamId +
            " received ");
        if (this.state != zego_entity_1.ENUM_PLAY_STATE.waitingServerICE) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_CANDIDATE_INFO +
                " " +
                this.streamId +
                " current state " +
                this.state +
                " not allowed");
            return;
        }
        this.dataReport.addEvent(this.reportSeq, "RecvIceCandidate");
        this.dataReport.addEvent(this.streamReportSeq, "RecvIceCandidate");
        this.signal.sendCandidateInfoAck(seq, this.sessionId, 0);
        //send candidate
        this.sendCandidateInfo(this.candidateInfo);
        this.candidateInfo = [];
        for (var i = 0; i < data.infos.length; i++) {
            var ice = {
                sdpMid: data.infos[i].sdpMid,
                sdpMLineIndex: data.infos[i].sdpMLineIndex,
                candidate: data.infos[i].candidate
            };
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_CANDIDATE_INFO +
                " " +
                this.streamId +
                " candidate " +
                ice.candidate);
            this.peerConnection.addIceCandidate(new RTCIceCandidate(ice)).then(function () {
                _this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_CANDIDATE_INFO +
                    " " +
                    _this.streamId +
                    " add success");
            }, function (error) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_CANDIDATE_INFO +
                    " " +
                    _this.streamId +
                    " add error " +
                    error.toString());
                _this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kCandidateError, true);
            });
        }
        this.state = zego_entity_1.ENUM_PLAY_STATE.connecting;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_CANDIDATE_INFO +
            " " +
            this.streamId +
            " call success");
    };
    ZegoPlayWeb.prototype.onRecvPlayEvent = function (seq, sessionId, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_PLAY_EVENT +
            " " +
            this.streamId +
            " received");
        if (this.playEvent === true && data.event == 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_PLAY_EVENT +
                " " +
                this.streamId +
                " retry: " +
                this.streamId);
            var streamId = this.streamId;
            var playOption = this.playOption;
            this.signal.sendCloseSession(zego_entity_1.getSeq(), this.sessionId, 1);
            this.resetPlay();
            this.startPlay(streamId, this.getRemoteStreamSuc, playOption);
        }
        else {
            this.playEvent = true;
        }
    };
    ZegoPlayWeb.prototype.onRecvClientInfo = function (seq, sessionId, data) {
        //客户端ip发生变化
        if (this.stateCenter.clientIP !== data.clientip) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_CLIENT_INFO +
                " " +
                "client ip changed " +
                this.stateCenter.clientIP +
                " " +
                data.clientip);
            // const error = ZegoRTCLogEvent.kZegoTaskPlayStart.error.kClientIPChangedError;
            // this.gwNode = "";
            // this.gwNodeList = [];
            // this.gwNodeTTL = 0;
            // this.playStateUpdateError (error);
        }
        this.stateCenter.clientIP = data.clientip;
        this.peerID = data.peer_id;
        if (this.isProbe && this.stateNego == zego_entity_1.ENUM_PLAY_STATE_NEGO.iceConnected) {
            this.signal.sendNetProbe(zego_entity_1.getSeq(), this.sessionId, this.peerID, function () { }, function () { });
        }
        this.isRecvClientInfo = true;
    };
    ZegoPlayWeb.prototype.onRecvNetQualityInfo = function (seq, sessionID, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_NET_QUALITY_INFO + " call");
        this.qualityHandler.stopProbeTimeout();
        var result = 0;
        var lossrate = data.lossrate;
        var rtt = data.rtt;
        if (this.peerID !== data.peer_id ||
            typeof lossrate == undefined ||
            typeof rtt == undefined) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_NET_QUALITY_INFO +
                " local peerID:" +
                this.peerID +
                " remote peerID:" +
                data.peer_id +
                " lossrate:" +
                lossrate +
                " rtt:" +
                rtt);
            result = 1;
        }
        this.signal.sendNetQualityInfoPushAck(zego_entity_1.getSeq(), this.sessionId, this.peerID, result);
        if (result == 0 && typeof lossrate == "number" && typeof rtt == "number") {
            //todo calculate net quality
            this.onCalNetQualityResult(0, client_util_1.ClientUtil.getNetQuality(rtt, lossrate));
        }
        else {
            this.onCalNetQualityResult(1);
        }
    };
    ZegoPlayWeb.prototype.onIceCandidate = function (event) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_ICE_CANDIDATE +
            " " +
            this.streamId +
            " called");
        //send candidate to other peer
        if (event.candidate == undefined) {
            return;
        }
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_ICE_CANDIDATE +
            " " +
            this.streamId +
            " candidate " +
            event.candidate.candidate);
        if (this.state < zego_entity_1.ENUM_PLAY_STATE.connecting ||
            this.state == zego_entity_1.ENUM_PLAY_STATE.stop) {
            //save candidate Info
            this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_ICE_CANDIDATE +
                " " +
                this.streamId +
                " cached");
            this.candidateInfo.push({
                candidate: event.candidate.candidate,
                sdpMid: event.candidate.sdpMid,
                sdpMLineIndex: event.candidate.sdpMLineIndex
            });
        }
        else {
            this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_ICE_CANDIDATE +
                " " +
                this.streamId +
                " send");
            var candidate = {
                candidate: event.candidate.candidate,
                sdpMid: event.candidate.sdpMid,
                sdpMLineIndex: event.candidate.sdpMLineIndex
            };
            this.sendCandidateInfo([candidate]);
        }
    };
    ZegoPlayWeb.prototype.onConnectionStateChange = function (event) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CONNECTION_STATE_CHANGE +
            " " +
            this.streamId +
            " called " +
            event.target.signalingState);
    };
    ZegoPlayWeb.prototype.onIceConnectionStateChange = function (event) {
        var _this = this;
        if (this.state == zego_entity_1.ENUM_PLAY_STATE.stop || this.peerConnection == null) {
            return;
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_ICE_CONNECTION_STATE_CHANGE +
            " " +
            this.streamId +
            " stateChanged " +
            this.peerConnection.iceConnectionState);
        if (this.peerConnection.iceConnectionState === "connected") {
            this.stateNego = zego_entity_1.ENUM_PLAY_STATE_NEGO.iceConnected;
            if (this.isProbe && this.isPeer && this.isRecvClientInfo) {
                this.signal.sendNetProbe(zego_entity_1.getSeq(), this.sessionId, this.peerID, function () { }, function () { });
                if (this.negoTimer != null) {
                    clearTimeout(this.negoTimer);
                    this.negoTimer = null;
                }
                return;
            }
            if (this.negoTimer != null) {
                clearTimeout(this.negoTimer);
                this.negoTimer = null;
            }
            if (this.iceDisconnectedTimer != null) {
                clearTimeout(this.iceDisconnectedTimer);
                this.iceDisconnectedTimer = null;
            }
            this.dataReport.addEvent(this.reportSeq, "IceConnected");
            this.dataReport.addEvent(this.streamReportSeq, "IceConnected");
            if (this.state != zego_entity_1.ENUM_PLAY_STATE.playing) {
                this.onPlayStateUpdate(zego_entity_1.ENUM_PLAY_STATE_UPDATE.start, this.streamId, { code: 0, message: "" }, true);
                this.getRemoteStreamSuc && this.getRemoteStreamSuc(this.playStream);
            }
            this.state = zego_entity_1.ENUM_PLAY_STATE.playing;
            //play started
            this.dataReport.eventStart(this.reportSeq, "PlayState");
            this.dataReport.eventStart(this.streamReportSeq, "PlayState");
            //BroadcasterStatusNotify
            for (var i in this.streamCenter.publisherList) {
                var publisher = this.streamCenter.publisherList[i]
                    .publisher;
                if (publisher.state == zego_entity_1.ENUM_PUBLISH_STATE.publishing &&
                    this.broadcasterStatus == zego_entity_1.ENUM_BROADCASTER_STATUS.stop) {
                    this.signal &&
                        this.signal.sendBroadcasterStatus(zego_entity_1.getSeq(), this.sessionId, 1);
                    this.broadcasterStatus = zego_entity_1.ENUM_BROADCASTER_STATUS.start;
                    break;
                }
            }
            //start quality timeInterval
            !this.isProbe && this.qualityHandler.setPlayQualityTimer();
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_ICE_CONNECTION_STATE_CHANGE +
                " " +
                this.streamId +
                " stateNego:iceConnected");
            if (this.isPeer) {
                this.peerFailCount = 0;
            }
            //上报拉流首帧耗时，不区分video或audi，统一用video
            if (this.firstFrameTime == 0) {
                this.firstFrameTime = new Date().getTime() - this.beginTime;
                var reportSeq = zego_entity_1.getReportSeq();
                this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayDecodeFirstVideoFrame.event);
                this.dataReport.addMsgInfo(reportSeq, {
                    session_id: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayDecodeFirstVideoFrame.session_id(this.sessionId),
                    fft_consumed: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayDecodeFirstVideoFrame.fft_consumed(this.firstFrameTime)
                });
                !this.isProbe && this.dataReport.uploadReport(reportSeq);
            }
        }
        else if (this.peerConnection.iceConnectionState === "closed") {
            this.dataReport.addEvent(this.reportSeq, "IceClosed");
            this.stateNego = zego_entity_1.ENUM_PLAY_STATE_NEGO.iceClosed;
            this.checkPlayConnectionFailedState(this.peerConnection.iceConnectionState);
        }
        else if (this.peerConnection.iceConnectionState === "failed") {
            this.dataReport.addEvent(this.reportSeq, "IceFailed");
            this.stateNego = zego_entity_1.ENUM_PLAY_STATE_NEGO.iceFailed;
            this.checkPlayConnectionFailedState(this.peerConnection.iceConnectionState);
        }
        else if (this.peerConnection.iceConnectionState === "disconnected") {
            this.dataReport.addEvent(this.reportSeq, "IceDisconnected");
            this.stateNego = zego_entity_1.ENUM_PLAY_STATE_NEGO.iceDisconnected;
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_ICE_CONNECTION_STATE_CHANGE +
                " ice disconnected");
            if (!this.iceDisconnectedTimer) {
                this.iceDisconnectedTimer = setTimeout(function () {
                    _this.checkPlayConnectionFailedState("disconnected");
                }, this.iceDisconnectedMaxTime);
            }
        }
    };
    ZegoPlayWeb.prototype.checkPlayConnectionFailedState = function (connectionState) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_ICE_CONNECTION_STATE_CHANGE +
            "  state " +
            this.state +
            " connectionState " +
            connectionState);
        this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kMediaConnectionError);
    };
    // private clearPlayQualityTimer(): void {
    //   if (this.qualityTimer != null) {
    //     clearInterval(this.qualityTimer);
    //     this.qualityTimer = null;
    //   }
    //   this.lastPlayStats = {
    //     audioPacketsLost: 0,
    //     videoPacketsLost: 0,
    //     time: 0,
    //     audioTime: 0,
    //     videoTime: 0,
    //     audioBytesReceived: 0,
    //     videoBytesReceived: 0,
    //     videoPacketsReceived: 0,
    //     audioPacketsReceived: 0,
    //     framesDecoded: 0,
    //     framesDropped: 0,
    //     framesReceived: 0,
    //     audioBitrate: 0
    //   };
    // }
    // p2pNetStats: {
    //   p2pLostRate: number;
    //   p2pRTT: number;
    // } = {
    //   p2pLostRate: 0,
    //   p2pRTT: 0
    // };
    // private getP2PNetStats(): void {
    //   this.signal.getP2PNetStats(
    //     getSeq(),
    //     this.sessionId,
    //     this.peerID,
    //     (seq: number, sessionID: string, body: any) => {
    //       console.log("getP2PNetStats", body);
    //       const { p2p_lost_rate, p2p_rtt } = body;
    //       this.p2pNetStats.p2pLostRate = p2p_lost_rate;
    //       this.p2pNetStats.p2pRTT = p2p_rtt;
    //     },
    //     (errcode: number) => {
    //       // TODO: 错误日志处理
    //       // if (SEND_MSG_TIMEOUT === errcode) {
    //       // }
    //     }
    //   );
    // }
    ZegoPlayWeb.prototype.resetPlay = function () {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_RESET_PLAY + " " + this.streamId + " call");
        this.state = zego_entity_1.ENUM_PLAY_STATE.stop;
        this.playEvent = false;
        this.isRecvClientInfo = false;
        if (this.peerConnection != undefined) {
            this.peerConnection.close();
            this.peerConnection = null;
        }
        if (this.negoTimer != null) {
            clearTimeout(this.negoTimer);
            this.negoTimer = null;
        }
        if (this.iceDisconnectedTimer != null) {
            clearTimeout(this.iceDisconnectedTimer);
            this.iceDisconnectedTimer = null;
        }
        this.qualityHandler.stopProbeTimeout();
        this.qualityHandler.clearPlayQualityTimer();
        if (this.signal) {
            this.signal.unregisterPushCallback("MediaDescPush", this.sessionId);
            this.signal.unregisterPushCallback("CandidateInfoPush", this.sessionId);
            this.signal.unregisterPushCallback("CloseSessionPush", this.sessionId);
            this.signal.unregisterPushCallback("SessionResetPush", this.sessionId);
            this.signal.unregisterPushCallback("PublishEventPush", this.sessionId);
            this.signal.unregisterPushCallback("ClientInfoPush", this.sessionId);
            this.signal.unregisterPushCallback("NetQualityProbeRsp", this.sessionId);
            this.signal.unregisterPushCallback("NetQualityInfoPush", this.sessionId);
        }
        // this.sessionId = 0;
        this.sessionSeq = 0;
        this.answerSeq = 0;
        this.videoSizeCallback = false;
        this.stopSoundLevel();
    };
    // private setPlayQualityTimer(): void {
    //   if (this.qualityTimer != null) {
    //     return;
    //   }
    //   this.logger.info(
    //     ZEGO_WEBRTC_ACTION.PLAYER_SET_PLAYER_QUALITY_TIMER +
    //       " " +
    //       this.streamId +
    //       " startTimer"
    //   );
    //   this.clearPlayQualityTimer();
    //   this.getP2PNetStats();
    //   this.qualityTimer = setInterval(() => {
    //     if (this.peerConnection) {
    //       const promiseList = [this.peerConnection.getStats(null)];
    //       if (this.stateCenter.browser == "chrome") {
    //         promiseList.push(
    //           new Promise((resolve, reject) => {
    //             this.peerConnection.getStats(
    //               (results: any) => resolve(results),
    //               (err: any) => reject(err)
    //             );
    //           })
    //         );
    //       }
    //       Promise.all(promiseList)
    //         .then((values: any) => {
    //           const stats = this.getPlayStats(values[0], values[1]);
    //         })
    //         .catch((error: any) => {
    //           this.logger.info(
    //             ZEGO_WEBRTC_ACTION.PLAYER_SET_PLAYER_QUALITY_TIMER +
    //               " " +
    //               this.streamId +
    //               " getStats error " +
    //               error.toString()
    //           );
    //         });
    //       // 获取端到端延迟
    //       this.getP2PNetStats();
    //     }
    //   }, this.qualityTimeInterval);
    //   this.lastPlayStats = {
    //     audioPacketsLost: 0,
    //     videoPacketsLost: 0,
    //     time: 0,
    //     audioTime: 0,
    //     videoTime: 0,
    //     audioBytesReceived: 0,
    //     videoBytesReceived: 0,
    //     videoPacketsReceived: 0,
    //     audioPacketsReceived: 0,
    //     framesDecoded: 0,
    //     framesReceived: 0,
    //     framesDropped: 0,
    //     audioBitrate: 0
    //   };
    // }
    // private getPlayStats(
    //   results: { forEach: (arg0: (result: any) => void) => void } | undefined,
    //   callbackResults: any
    // ): void {
    //   if (results == undefined) {
    //     return;
    //   }
    //   const medias: any = document.querySelectorAll("video, audio");
    //   let streamMedia;
    //   for (let i = 0; i < medias.length; i++) {
    //     if (medias[i].srcObject === this.playStream) {
    //       streamMedia = medias[i];
    //     }
    //   }
    //   const playData: any = {
    //     audioFractionLost: 0,
    //     audioPacketsLost: 0,
    //     audioPacketsLostRate: 0,
    //     audioBitrate: 0,
    //     audioLevel: 0,
    //     audioSendLevel: 0,
    //     audioSamplingRate: 0,
    //     audioCodec: "opus",
    //     audioQuality: 0,
    //     audioFPS: 0,
    //     videoQuality: 0,
    //     videoPacketsLost: 0,
    //     videoPacketsLostRate: 0,
    //     videoBitrate: 0,
    //     videoFPS: 0,
    //     playData: 0,
    //     nackCount: 0,
    //     pliCount: 0,
    //     //sliCount: 0,
    //     audioJitter: 0,
    //     videoFractionLost: 0,
    //     videoFramesDecoded: 0,
    //     frameHeight: 0,
    //     frameWidth: 0,
    //     videoTransferFPS: 0,
    //     videoFramesDropped: 0,
    //     totalRoundTripTime: 0,
    //     currentRoundTripTime: 0,
    //     googBandwidthLimitedResolution: undefined,
    //     videoCodecName: "",
    //     audioCodecName: "",
    //     googCpuLimitedResolution: undefined,
    //     googAvailableSendBandwidth: 0,
    //     audioMuteState: this.audioMuteState,
    //     videoMuteState: this.videoMuteState,
    //     muted: streamMedia ? streamMedia.muted : undefined,
    //     paused: streamMedia ? streamMedia.paused : undefined,
    //     volume: streamMedia ? streamMedia.volume : undefined,
    //     sinkId: streamMedia ? streamMedia.sinkId : undefined,
    //     p2p_rtt: this.lastPlayStats.p2p_rtt || undefined,
    //     p2p_lost: this.lastPlayStats.p2p_lost || undefined
    //   };
    //   const time = this.lastPlayStats.time;
    //   let rtt = 0;
    //   let audioLostRate = 0;
    //   let videoLostRate = 0;
    //   let audioJitter = 0;
    //   let videoJitter = 0;
    //   let audioCurrentDelayMs = 0;
    //   let videoCurrentDelayMs = 0;
    //   results.forEach(result => {
    //     if (
    //       (result.type == "inbound-rtp" ||
    //         (result.type == "ssrc" && result.bytesReceived != undefined)) &&
    //       (result.mediaType == "audio" || result.id.indexOf("AudioStream") >= 0)
    //     ) {
    //       //audio
    //       if (time != 0) {
    //         // 计算音频码率
    //         playData["audioBitrate"] =
    //           (8 *
    //             (result.bytesReceived -
    //               this.lastPlayStats["audioBytesReceived"])) /
    //           (result.timestamp - time);
    //         // 计算音频丢包率
    //         const deltaPacketsLost =
    //           result.packetsLost - this.lastPlayStats.audioPacketsLost;
    //         deltaPacketsLost > 0 &&
    //           (audioLostRate =
    //             deltaPacketsLost /
    //             (deltaPacketsLost +
    //               result.packetsReceived -
    //               this.lastPlayStats.audioPacketsReceived));
    //       }
    //       if (playData["audioBitrate"] < 0) {
    //         playData["audioBitrate"] = 0;
    //       }
    //       playData.audioJitter = result.jitter;
    //       result.packetsLost > 0 &&
    //         (playData.audioPacketsLost = result.packetsLost);
    //       playData.audioFractionLost = result.fractionLost;
    //       const timePacketsLost =
    //         result.packetsLost - this.lastPlayStats.audioPacketsLost;
    //       playData.audioFPS =
    //         ((result.packetsReceived - this.lastPlayStats.audioPacketsReceived) /
    //           (result.timestamp - time)) *
    //         1000;
    //       if (timePacketsLost > 0) {
    //         playData.audioPacketsLostRate =
    //           timePacketsLost /
    //           (result.packetsReceived -
    //             this.lastPlayStats.audioPacketsReceived +
    //             timePacketsLost);
    //       } else {
    //         playData.audioPacketsLostRate = 0;
    //       }
    //       this.lastPlayStats.audioBytesReceived = result.bytesReceived;
    //       result.packetsLost > 0 &&
    //         (this.lastPlayStats.audioPacketsLost = result.packetsLost);
    //       this.lastPlayStats.audioPacketsReceived = result.packetsReceived;
    //       this.lastPlayStats.audioTime = result.timestamp;
    //       this.lastPlayStats.time = result.timestamp;
    //       this.lastPlayStats.audioBitrate = playData["audioBitrate"];
    //       audioJitter = result.jitter;
    //     } else if (
    //       (result.type == "inbound-rtp" ||
    //         (result.type == "ssrc" && result.bytesReceived != undefined)) &&
    //       (result.mediaType == "video" || result.id.indexOf("VideoStream") >= 0)
    //     ) {
    //       //video
    //       if (time != 0) {
    //         playData.videoBitrate =
    //           (8 *
    //             (result.bytesReceived - this.lastPlayStats.videoBytesReceived)) /
    //           (result.timestamp - time);
    //         playData.videoFPS =
    //           (1000 * (result.framesDecoded - this.lastPlayStats.framesDecoded)) /
    //           (result.timestamp - time);
    //         const deltaPacketsLost =
    //           result.packetsLost - this.lastPlayStats.videoPacketsLost;
    //         deltaPacketsLost > 0 &&
    //           (videoLostRate =
    //             deltaPacketsLost /
    //             (deltaPacketsLost +
    //               result.packetsReceived -
    //               this.lastPlayStats.videoPacketsReceived));
    //       }
    //       if (playData.videoBitrate < 0) {
    //         playData.videoBitrate = 0;
    //       }
    //       if (playData.videoFPS < 0) {
    //         playData.videoFPS = 0;
    //       }
    //       //playData.jitter = result.jitter;
    //       playData.nackCount = result.nackCount;
    //       playData.pliCount = result.pliCount;
    //       //playData.sliCount = result.sliCount;
    //       playData.videoFractionLost = result.fractionLost;
    //       playData.videoFramesDecoded = result.framesDecoded;
    //       result.packetsLost > 0 &&
    //         (playData.videoPacketsLost = result.packetsLost);
    //       const timePacketsLost =
    //         result.packetsLost - this.lastPlayStats.videoPacketsLost;
    //       if (timePacketsLost > 0) {
    //         playData.videoPacketsLostRate =
    //           timePacketsLost /
    //           (result.packetsReceived -
    //             this.lastPlayStats.videoPacketsReceived +
    //             timePacketsLost);
    //       } else {
    //         playData.videoPacketsLostRate = 0;
    //       }
    //       this.lastPlayStats.videoBytesReceived = result.bytesReceived;
    //       this.lastPlayStats.framesDecoded = result.framesDecoded;
    //       result.packetsLost > 0 &&
    //         (this.lastPlayStats.videoPacketsLost = result.packetsLost);
    //       this.lastPlayStats.videoPacketsReceived = result.packetsReceived;
    //       this.lastPlayStats.videoTime = result.timestamp;
    //       this.lastPlayStats.time = result.timestamp;
    //       videoJitter = result.jitter;
    //     } else if (
    //       (result.type == "track" &&
    //         (result.kind == "video" || result.id.indexOf("video") >= 0)) ||
    //       result.frameWidth
    //     ) {
    //       playData.frameHeight = result.frameHeight;
    //       playData.frameWidth = result.frameWidth;
    //       // 上报分辨率变化
    //       if (
    //         time !== 0 &&
    //         (this.lastPlayStats.frameHeight !== result.frameHeight ||
    //           this.lastPlayStats.frameWidth !== result.frameWidth)
    //       ) {
    //         const reportSizeSeq = getReportSeq();
    //         this.dataReport.newReport(
    //           reportSizeSeq,
    //           ZegoRTCLogEvent.kZegoTaskVideoPlaySize.event
    //         );
    //         this.dataReport.addMsgInfo(reportSizeSeq, {
    //           session_id: ZegoRTCLogEvent.kZegoTaskVideoPlaySize.session_id(
    //             this.sessionId
    //           ),
    //           w: ZegoRTCLogEvent.kZegoTaskVideoPlaySize.w(result.frameWidth),
    //           h: ZegoRTCLogEvent.kZegoTaskVideoPlaySize.h(result.frameHeight)
    //         });
    //         !this.isProbe && this.dataReport.uploadReport(reportSizeSeq);
    //         this.lastPlayStats.frameHeight = result.frameHeight;
    //         this.lastPlayStats.frameWidth = result.frameWidth;
    //       } else if (time === 0) {
    //         this.lastPlayStats.frameHeight = result.frameHeight;
    //         this.lastPlayStats.frameWidth = result.frameWidth;
    //       }
    //       if (time != 0) {
    //         playData.videoTransferFPS =
    //           (1000 *
    //             (result.framesReceived - this.lastPlayStats.framesReceived)) /
    //           (result.timestamp - time);
    //         playData.videoFramesDropped =
    //           result.framesDropped - this.lastPlayStats.framesDropped;
    //       }
    //       if (playData.videoTransferFPS < 0) {
    //         playData.videoTransferFPS = 0;
    //       }
    //       if (playData.videoFramesDropped < 0) {
    //         playData.videoFramesDropped = 0;
    //       }
    //       this.lastPlayStats.framesReceived = result.framesReceived;
    //       this.lastPlayStats.framesDropped = result.framesDropped;
    //     } else if (
    //       result.type == "track" &&
    //       (result.kind == "audio" || result.id.indexOf("audio") >= 0)
    //     ) {
    //       playData.audioLevel = result.audioLevel;
    //       playData.audioSendLevel = result.totalAudioEnergy;
    //       playData.audioSamplingRate = result.totalSamplesDuration;
    //     } else if (result.type == "candidate-pair") {
    //       if (result.totalRoundTripTime != undefined) {
    //         playData.totalRoundTripTime = result.totalRoundTripTime;
    //       }
    //       if (result.currentRoundTripTime != undefined) {
    //         playData.currentRoundTripTime = result.currentRoundTripTime;
    //         rtt = playData.currentRoundTripTime * 1000;
    //       }
    //     }
    //   });
    //   callbackResults &&
    //     callbackResults.result().forEach((result: any) => {
    //       if (result.type == "ssrc") {
    //         if (result.names().indexOf("googBandwidthLimitedResolution") >= 0) {
    //           playData.googBandwidthLimitedResolution = result.stat(
    //             "googBandwidthLimitedResolution"
    //           );
    //         }
    //         if (result.names().indexOf("codecImplementationName") >= 0) {
    //           playData.codecImplementationName = result.stat(
    //             "codecImplementationName"
    //           );
    //         }
    //         if (result.stat("mediaType") == "video") {
    //           if (result.names().indexOf("googCodecName") >= 0) {
    //             playData.videoCodecName = result.stat("googCodecName");
    //           }
    //           // 获取视频流抖动延迟
    //           if (result.names().indexOf("googCurrentDelayMs") >= 0) {
    //             videoCurrentDelayMs = result.stat("googCurrentDelayMs");
    //           }
    //         }
    //         if (result.stat("mediaType") == "audio") {
    //           if (result.names().indexOf("googCodecName") >= 0) {
    //             playData.audioCodecName = result.stat("googCodecName");
    //           }
    //           // 获取音频流抖动延迟
    //           if (result.names().indexOf("googCurrentDelayMs") >= 0) {
    //             audioCurrentDelayMs = result.stat("googCurrentDelayMs");
    //           }
    //         }
    //         if (result.names().indexOf("googCpuLimitedResolution") >= 0) {
    //           playData.googCpuLimitedResolution = result.stat(
    //             "googCpuLimitedResolution"
    //           );
    //         }
    //       }
    //       if (
    //         result.type == "VideoBwe" &&
    //         result.names().indexOf("googAvailableSendBandwidth") >= 0
    //       ) {
    //         playData.googAvailableSendBandwidth = result.stat(
    //           "googAvailableSendBandwidth"
    //         );
    //       }
    //     });
    //   // 本地播放延迟值优先取音频的延迟
    //   this.lastPlayStats.googCurrentDelayMs =
    //     Number(audioCurrentDelayMs) || Number(videoCurrentDelayMs) || 0;
    //   videoLostRate =
    //     isNaN(videoLostRate) || videoLostRate < 0 ? 0 : videoLostRate;
    //   videoJitter = isNaN(videoJitter) || videoJitter < 0 ? 0 : videoJitter;
    //   audioLostRate =
    //     isNaN(audioLostRate) || audioLostRate < 0 ? 0 : audioLostRate;
    //   audioJitter = isNaN(audioJitter) || audioJitter < 0 ? 0 : audioJitter;
    //   const videoQuality = ClientUtil.getNetQuality(
    //     rtt,
    //     videoLostRate,
    //     videoJitter
    //   );
    //   const audioQuality = ClientUtil.getNetQuality(
    //     rtt,
    //     audioLostRate,
    //     audioJitter
    //   );
    //   playData.audioQuality =
    //     time > 0 ? ClientUtil.quality2QualityGrade(videoQuality) : 0;
    //   playData.videoQuality =
    //     time > 0 ? ClientUtil.quality2QualityGrade(audioQuality) : 0;
    //   const netQuality = Math.min(videoQuality, audioQuality);
    //   this.netQuality = netQuality;
    //   playData.peerToPeerDelay = this.p2pNetStats.p2pRTT
    //     ? this.p2pNetStats.p2pRTT / 2 + this.lastPlayStats.googCurrentDelayMs
    //     : 0;
    //   playData.peerToPeerPacketsLostRate = this.p2pNetStats.p2pLostRate;
    //   if (
    //     time > 0 &&
    //     netQuality <= QUALITY_CONSTANT.MiddleMinQuality &&
    //     new Date().getTime() > this.probeTime + this.probeInterval
    //   ) {
    //     this.logger.info(
    //       ZEGO_WEBRTC_ACTION.PLAYER_SET_PLAYER_QUALITY_TIMER +
    //         " netQuality " +
    //         netQuality +
    //         " start net probe"
    //     );
    //     this.probeState = ENUM_PROBE_STATE.tryProbe;
    //     this.streamCenter.startNetProbe(false, this, this.gwNodeList);
    //     this.probeTime = new Date().getTime();
    //   }
    //   this.uploadPlayQuality(playData);
    //   const streamQuality: any = {
    //     video: {
    //       videoBitrate: playData.videoBitrate,
    //       videoFPS: playData.videoFPS,
    //       videoTransferFPS: playData.videoTransferFPS,
    //       videoFramesDecoded: playData.videoFramesDecoded,
    //       videoFramesDropped: playData.videoFramesDropped,
    //       videoPacketsLost: playData.videoPacketsLost,
    //       videoPacketsLostRate: playData.videoPacketsLostRate,
    //       videoQuality: playData.videoQuality,
    //       frameHeight: playData.frameHeight,
    //       frameWidth: playData.frameWidth,
    //       muteState: playData.videoMuteState
    //     },
    //     audio: {
    //       audioBitrate: playData.audioBitrate,
    //       audioCodec: playData.audioCodec,
    //       audioJitter: playData.audioJitter,
    //       audioLevel: playData.audioLevel,
    //       audioPacketsLost: playData.audioPacketsLost,
    //       audioPacketsLostRate: playData.audioPacketsLostRate,
    //       audioQuality: playData.audioQuality,
    //       audioSamplingRate: playData.audioSamplingRate,
    //       audioSendLevel: playData.audioSendLevel,
    //       muteState: playData.audioMuteState,
    //       audioFPS: playData.audioFPS
    //     },
    //     //roomId: '',
    //     nackCount: playData.nackCount,
    //     pliCount: playData.pliCount,
    //     totalRoundTripTime: playData.totalRoundTripTime,
    //     playData: playData.playData,
    //     currentRoundTripTime: playData.currentRoundTripTime
    //   };
    //   if (playData.muted !== undefined) {
    //     streamQuality.muted = playData.muted;
    //     streamQuality.paused = playData.paused;
    //     streamQuality.volume = playData.volume;
    //     streamQuality.sinkId = playData.sinkId;
    //   }
    //   if (playData.videoCodecName !== undefined) {
    //     // streamQuality.googBandwidthLimitedResolution = playData.googBandwidthLimitedResolution;
    //     streamQuality.video.googCodecName = playData.videoCodecName;
    //     streamQuality.audio.googCodecName = playData.audioCodecName;
    //     // streamQuality.googCpuLimitedResolution = playData.googCpuLimitedResolution;
    //     streamQuality.codecImplementationName = playData.codecImplementationName;
    //     streamQuality.googAvailableSendBandwidth =
    //       playData.googAvailableSendBandwidth;
    //   }
    //   if (time != 0) {
    //     this.onPlayQualityUpdate(this.streamId as string, streamQuality);
    //   }
    // }
    // private uploadPlayQuality(playData: any): void {
    //   if (!this.qualityUpload) {
    //     return;
    //   }
    //   const timeStamp = new Date().getTime();
    //   if (
    //     this.qualityUploadLastTime == 0 ||
    //     timeStamp - this.qualityUploadLastTime >= this.qualityUploadInterval
    //   ) {
    //     playData["stream_type"] = "play";
    //     playData["stream_id"] = this.streamId;
    //     playData["timeStamp"] = timeStamp / 1000;
    //     this.logger.info(
    //       ZEGO_WEBRTC_ACTION.PLAYER_UPLOAD_PLAYER_QUALITY +
    //         " " +
    //         this.streamId +
    //         " upload" +
    //         JSON.stringify(playData)
    //     );
    //     this.signal.QualityReport(
    //       getSeq(),
    //       this.sessionId,
    //       playData,
    //       (
    //         seq: number,
    //         sessionId: string,
    //         data: { report: boolean | undefined; report_interval_ms: number }
    //       ) => {
    //         if (data.report !== undefined) {
    //           this.qualityUpload = data.report;
    //           this.qualityUploadInterval = data.report_interval_ms;
    //         }
    //       },
    //       (err: string) => {
    //         this.logger.info(
    //           ZEGO_WEBRTC_ACTION.PLAYER_UPLOAD_PLAYER_QUALITY +
    //             " " +
    //             this.streamId +
    //             " upload failed " +
    //             err
    //         );
    //       }
    //     );
    //     this.qualityUploadLastTime = timeStamp;
    //   }
    // }
    ZegoPlayWeb.prototype.onRecvResetSession = function (seq, sessionId, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_RESET_SESSION +
            " " +
            this.streamId +
            " received ");
        if (sessionId != this.sessionId) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_RESET_SESSION +
                " " +
                this.streamId +
                " cannot find session");
            return;
        }
        this.signal.sendCloseSessionAck(seq, this.sessionId, 0);
        var error = JSON.parse(JSON.stringify(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlaySessionClosedError));
        // error.msg += data.reason;
        this.negoTimer && clearTimeout(this.negoTimer);
        this.playStateUpdateError(error);
    };
    ZegoPlayWeb.prototype.onRecvCloseSession = function (seq, sessionId, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_CLOSE_SESSION +
            " " +
            this.streamId +
            " " +
            JSON.stringify(data));
        this.signal.sendCloseSessionAck(seq, this.sessionId, 0);
        var err_info = data.err_info
            ? JSON.parse(data.err_info.toLowerCase())
            : {};
        var action = err_info.action ? err_info.action : null;
        var reason = data.reason * 1;
        var error = JSON.parse(JSON.stringify(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlaySessionClosedError));
        error.message += " reason:" + reason + " " + (action ? " action:" + action : "");
        this.negoTimer && clearTimeout(this.negoTimer);
        var stopRetry = [4, 8, 10, 11, 12, 14, 24, 26, 27, 28].includes(reason) ||
            [2, 5, 6].includes(action)
            ? false
            : true;
        this.playStateUpdateError(error, stopRetry);
    };
    ZegoPlayWeb.prototype.onRecvStreamStatus = function (data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_STREAM_STATUS +
            " " +
            this.streamId +
            " call");
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_STREAM_STATUS + " " + this.streamId + " status camera_status: " + data.camera_status + " mic_status: " + data.mic_status);
        (!this.hasSentStreamStatus || this.cameraStatus !== data.camera_status) &&
            this.onRemoteCameraStatusUpdate(this.streamId, this.getCameraMicStatus(data.camera_status), data.camera_status);
        (!this.hasSentStreamStatus || this.micStatus !== data.mic_status) &&
            this.onRemoteMicStatusUpdate(this.streamId, this.getCameraMicStatus(data.mic_status), data.mic_status);
        this.hasSentStreamStatus = true;
        this.cameraStatus = data.camera_status;
        this.micStatus = data.mic_status;
        // 1为关闭、0为开启
        this.videoMuteState = data.camera_status === 0 ? "0" : "1";
        this.audioMuteState = data.mic_status === 0 ? "0" : "1";
        if (typeof this.playOption.video === "boolean") {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_STREAM_STATUS +
                " " +
                this.streamId +
                " has set video option, ignore stream status");
        }
        else {
            var stream_1 = this.playStream;
            if (data.camera_status !== 0 && data.camera_status !== 20) {
                // 拉流第一次接收到没有画面的流需要先停止视轨再移除，否则video会进入loading状态，等待视轨有数据才能播放
                // 音轨没数据的情况：一、native端推音视频流并关闭摄像头  二、推纯音频的流。web端推流 enable 来关闭画面不影响视轨原有数据，video 能正常播放。
                stream_1.getVideoTracks().forEach(function (track) {
                    track.enabled = false;
                    track.stop();
                    stream_1.removeTrack(track);
                });
            }
            else if (stream_1.getVideoTracks().length === 0) {
                stream_1.addTrack(this.remoteStream.clone().getVideoTracks()[0]);
            }
            // Safari修改音视轨后无法自动恢复播放
            if (this.stateCenter.browser === "safari") {
                var medias = document.querySelectorAll("video, audio");
                for (var i = 0; i < medias.length; i++) {
                    if (medias[i].srcObject === this.playStream) {
                        medias[i].srcObject = this.playStream;
                    }
                }
            }
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_STREAM_STATUS +
            " " +
            this.streamId +
            " call success");
    };
    ZegoPlayWeb.prototype.onGotRemoteStream = function (stream) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_GOT_REMOTE_STREAM +
            " " +
            this.streamId +
            " called " +
            stream);
        if (!stream) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_GOT_REMOTE_STREAM +
                " " +
                this.streamId +
                " remote stream is empty");
            return;
        }
        if (!this.playStream) {
            this.playStream = stream.clone();
        }
        else {
            this.playStream
                .getTracks()
                .forEach(function (track) { return _this.playStream.removeTrack(track); });
            stream
                .clone()
                .getTracks()
                .forEach(function (track) { return _this.playStream.addTrack(track); });
        }
        this.audioMuteState =
            this.playStream.getAudioTracks().length > 0 ? "0" : "1";
        this.videoMuteState =
            this.playStream.getVideoTracks().length > 0 ? "0" : "1";
        this.remoteStream = stream;
        this.gotStreamStatus && this.onRecvStreamStatus(this.streamStatus);
        this.dataReport.addEvent(this.reportSeq, "GetRemoteStream");
        this.streamCenter.soundLevelDelegate &&
            !this.isProbe &&
            this.startSoundLevel();
    };
    ZegoPlayWeb.prototype.sendCandidateInfo = function (candidateInfo) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SEND_CANDIDATE_INFO +
            " " +
            this.streamId +
            " called");
        candidateInfo = candidateInfo.filter(function (item) {
            if (item.candidate.indexOf("tcp") > 0) {
                return false;
            }
            else if (item.candidate) {
                return true;
            }
        });
        if (!candidateInfo || candidateInfo.length < 1) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SEND_CANDIDATE_INFO +
                " " +
                this.streamId +
                " cancelled");
            return;
        }
        this.dataReport.eventStart(this.reportSeq, "SendIceCandidate");
        this.dataReport.eventStart(this.streamReportSeq, "SendIceCandidate");
        if (this.stateNego !== zego_entity_1.ENUM_PLAY_STATE_NEGO.iceConnected)
            this.stateNego = zego_entity_1.ENUM_PLAY_STATE_NEGO.sendCandidate;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SEND_CANDIDATE_INFO +
            " " +
            this.streamId +
            " stateNego:sendCandidate");
        this.signal.sendCandidateInfo(zego_entity_1.getSeq(), this.sessionId, candidateInfo, function (seq, sessionId, data) {
            _this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SEND_CANDIDATE_INFO +
                " " +
                _this.streamId +
                " send success");
            _this.dataReport.eventEnd(_this.reportSeq, "SendIceCandidate");
            _this.dataReport.eventEnd(_this.streamReportSeq, "SendIceCandidate");
        }, function (err, seq) {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SEND_CANDIDATE_INFO +
                " " +
                _this.streamId +
                " failed to send: " +
                err.toString());
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "SendIceCandidate", {
                error: err
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "SendIceCandidate", {
                error: err
            });
            _this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kCandidateError);
        });
    };
    ZegoPlayWeb.prototype.shouldSendCloseSession = function () {
        if (this.state != zego_entity_1.ENUM_PLAY_STATE_UPDATE.stop &&
            this.state != zego_entity_1.ENUM_PLAY_STATE.waitingSessionRsp) {
            return true;
        }
        return false;
    };
    ZegoPlayWeb.prototype.playStateUpdateError = function (error, stopRetry) {
        this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_STATE_ERROR + " call ", this.streamId, JSON.stringify(error));
        if (this.isProbe) {
            this.onCalNetQualityResult(1);
        }
        else {
            this.streamId &&
                this.onPlayStateUpdate(zego_entity_1.ENUM_PLAY_STATE_UPDATE.error, this.streamId, error, stopRetry);
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_STATE_ERROR + " " + this.streamId + " ended");
    };
    ZegoPlayWeb.prototype.getCameraMicStatus = function (status) {
        return status == 0 ? "OPEN" : "MUTE";
    };
    ZegoPlayWeb.prototype.onPlayStateUpdate = function (type, streamId, error, stopRetry) { };
    ZegoPlayWeb.prototype.onPlayQualityUpdate = function (streamID, quality) { };
    ZegoPlayWeb.prototype.onRemoteCameraStatusUpdate = function (streamID, status, initialStatus) { };
    ZegoPlayWeb.prototype.onRemoteMicStatusUpdate = function (streamID, status, initialStatus) { };
    ZegoPlayWeb.prototype.stopPlay = function () {
        var _a;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_STOP_PLAY + " " + this.streamId + " called");
        //sendBroadcasterStatusNotify
        for (var i in this.streamCenter.publisherList) {
            var publisher = this.streamCenter.publisherList[i]
                .publisher;
            if (publisher.state == zego_entity_1.ENUM_PUBLISH_STATE.publishing &&
                this.broadcasterStatus == zego_entity_1.ENUM_BROADCASTER_STATUS.start) {
                this.signal &&
                    this.signal.sendBroadcasterStatus(zego_entity_1.getSeq(), this.sessionId, 0);
                this.broadcasterStatus = zego_entity_1.ENUM_BROADCASTER_STATUS.stop;
                break;
            }
        }
        //send to server
        if (this.sessionId && !this.closeSessionSignal) {
            this.signal.sendCloseSession(zego_entity_1.getSeq(), this.sessionId, 0);
        }
        this.dataReport.eventEndWithMsg(this.streamReportSeq, "PlayState", {
            state: this.state + ""
        });
        this.dataReport.addEvent(this.streamReportSeq, "StopPlay");
        this.dataReport.addMsgExt(this.streamReportSeq, {
            stream: this.streamId,
            sessionId: this.sessionId
        });
        this.resetPlay();
        var _b = this.qualityHandler, videoBreak = _b.videoBreak, audioBreak = _b.audioBreak;
        var key = this.resourceMode === 2 ? "l3" : "rtc";
        var reportBreak = (_a = {},
            _a[key + "_a_break_time"] = audioBreak.cumulativeBreakDuration,
            _a[key + "_a_decode_time"] = audioBreak.cumulativeDecodeDuration,
            _a[key + "_v_break_time"] = videoBreak.cumulativeBreakDuration,
            _a[key + "_v_decode_time"] = videoBreak.cumulativeDecodeDuration,
            _a);
        this.dataReport.addMsgInfo(this.streamReportSeq, __assign({ itemtype: "RTCPlayStream", cdn_a_break_time: 0, cdn_a_decode_time: 0, cdn_v_break_time: 0, cdn_v_decode_time: 0, l3_a_break_time: 0, l3_a_decode_time: 0, l3_v_break_time: 0, l3_v_decode_time: 0, rtc_a_break_time: 0, rtc_a_decode_time: 0, rtc_v_break_time: 0, rtc_v_decode_time: 0 }, reportBreak));
        // console.log("videobreak", reportBreak);
        !this.isProbe &&
            this.dataReport.uploadReport(this.streamReportSeq, "RTCPlayStream");
    };
    ZegoPlayWeb.prototype.onDisconnect = function (error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_DISCONNECT + " " + this.streamId + " call");
        this.dataReport.addEvent(this.reportSeq, "OnDisconnect");
        // 异常断开时停止重试
        this.playStateUpdateError(error ||
            zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kWebsocketDisconnectedError, !!error);
    };
    ZegoPlayWeb.prototype.startSoundLevel = function () {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_SOUND_LEVEL +
            " call streamID: " +
            this.streamId);
        //探测模式下不开启音浪回调
        if (this.isProbe) {
            return;
        }
        if (!this.remoteStream || this.remoteStream.getAudioTracks().length == 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_SOUND_LEVEL +
                " " +
                this.streamId +
                " remote stream no found");
            return;
        }
        this.script && this.script.disconnect() && (this.script = null);
        this.mic && this.mic.disconnect() && (this.mic = null);
        try {
            this.mic = this.ac.createMediaStreamSource(this.remoteStream);
            this.script = this.ac.createScriptProcessor(4096, 1, 1); //创建一个音频分析对象，采样的缓冲区大小为4096，输入和输出都是单声道
            this.mic.connect(this.script); //将该分析对象与麦克风音频进行连接
            this.script.connect(this.ac.destination);
            this.script.onaudioprocess = function (e) {
                //开始处理音频
                var buffer = e.inputBuffer.getChannelData(0); //获得缓冲区的输入音频，转换为包含了PCM通道数据的32位浮点数组
                //创建变量并迭代来获取最大的音量值
                var maxVal = 0;
                for (var i = 0; i < buffer.length; i++) {
                    if (maxVal < buffer[i]) {
                        maxVal = buffer[i];
                    }
                }
                _this.soundLevel = maxVal * 100;
            };
            this.ac.resume();
        }
        catch (err) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_SOUND_LEVEL +
                " get sound level failed " +
                err);
        }
    };
    ZegoPlayWeb.prototype.stopSoundLevel = function () {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_STOP_SOUND_LEVEL +
            " call streamID: " +
            this.streamId);
        this.script && this.script.disconnect();
        this.mic && this.mic.disconnect();
        this.script = null;
        this.mic = null;
    };
    ZegoPlayWeb.prototype.onCalNetQualityResult = function (result, netQuality) { };
    ZegoPlayWeb.prototype.onReceivedDataChannel = function (event) {
        var _this = this;
        var _a, _b;
        var byteArray = new Uint8Array(event.data, 0, MSG_HEADER_SIZE);
        var payload_len = event.data.byteLength - MSG_HEADER_SIZE;
        var payloadArray = new Uint8Array(event.data, MSG_HEADER_SIZE, payload_len);
        var type = byteArray[0];
        if (type == TYPE_USER_DATA) {
            var flags = byteArray[1];
            var sn = (byteArray[2] << 8) | byteArray[3];
            var sn0_1 = (byteArray[4] << 8) | byteArray[5];
            var recv_ts = new Date().getTime();
            if (this.first_pkt) {
                if (sn == sn0_1) {
                    this.next_sn[0] = sn;
                }
                else {
                    this.next_sn[0] = sn0_1;
                }
                this.first_pkt = false;
            }
            this.pkt_list.push({
                sn: sn,
                sn0: sn0_1,
                recv_ts: recv_ts,
                flags: flags,
                payload_len: payload_len,
                payloadArray: payloadArray
            });
            this.pkt_list.sort(this.compareShort);
            if (sn == this.next_sn[0]) {
                var pkts = this.pkt_list.filter(function (a) { return a.sn0 == sn0_1; });
                pkts.sort(this.compareShort);
                var f = pkts.find(function (a) { return a.flags & END_OF_MSG; });
                if (f != undefined && pkts.length == this.compareShort(sn, sn0_1) + 1) {
                    var copy_len_1 = 0;
                    var copy_buffer_1 = new ArrayBuffer(MAX_MESSAGE_SIZE);
                    for (var i = 0; i < pkts.length; i++) {
                        var chunk = new Uint8Array(copy_buffer_1);
                        chunk.set(pkts[i].payloadArray, copy_len_1);
                        copy_len_1 += pkts[i].payload_len;
                    }
                    (_a = this.onDataChannelList) === null || _a === void 0 ? void 0 : _a.forEach(function (fun) {
                        fun(copy_buffer_1, copy_len_1, _this.streamId);
                    });
                    this.pkt_list = [];
                    this.first_pkt = true;
                }
                this.next_sn[0]++;
            }
            else {
                var _loop_1 = function () {
                    var pkts = this_1.pkt_list.filter(function (a) { return a.sn0 == _this.pkt_list[0].sn0; });
                    pkts.sort(this_1.compareShort);
                    var f = pkts.find(function (a) { return a.flags & END_OF_MSG; });
                    if (f != undefined &&
                        pkts.length ==
                            this_1.compareShort(pkts[pkts.length - 1].sn, pkts[0].sn0) + 1) {
                        var copy_len_2 = 0;
                        var copy_buffer_2 = new ArrayBuffer(MAX_MESSAGE_SIZE);
                        for (var i = 0; i < pkts.length; i++) {
                            var chunk = new Uint8Array(copy_buffer_2);
                            chunk.set(pkts[i].payloadArray, copy_len_2);
                            copy_len_2 += pkts[i].payload_len;
                        }
                        this_1.next_sn[0] = pkts[0].sn0 + pkts.length;
                        (_b = this_1.onDataChannelList) === null || _b === void 0 ? void 0 : _b.forEach(function (fun) {
                            fun(copy_buffer_2, copy_len_2, _this.streamId);
                        });
                        this_1.pkt_list = [];
                        this_1.first_pkt = true;
                    }
                    else {
                        if (recv_ts - pkts[0].ts < MSG_TIMEOUT) {
                            var next_sn = pkts[0].sn0;
                            for (var i = 0; i < pkts.length; i++) {
                                if (next_sn != pkts[i].sn) {
                                    break;
                                }
                                next_sn++;
                            }
                            this_1.next_sn[0] = next_sn;
                            return "break";
                        }
                    }
                    for (var i = 0; i < pkts.length; i++) {
                        this_1.pkt_list.shift();
                    }
                };
                var this_1 = this;
                while (this.pkt_list.length > 0) {
                    var state_1 = _loop_1();
                    if (state_1 === "break")
                        break;
                }
            }
        }
    };
    ZegoPlayWeb.prototype.compareShort = function (a, b) {
        var uint16 = new Uint16Array(1);
        uint16[0] = a - b;
        var int16 = new Int16Array(1);
        int16[0] = uint16[0];
        return int16[0];
    };
    return ZegoPlayWeb;
}());
exports.ZegoPlayWeb = ZegoPlayWeb;


/***/ }),

/***/ "./sdk/src/webrtc/modules/publishModules/index.ts":
/*!********************************************************!*\
  !*** ./sdk/src/webrtc/modules/publishModules/index.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PublishModule = void 0;
var action_1 = __webpack_require__(/*! ../../../common/action */ "./sdk/src/common/action.ts");
var zego_entity_1 = __webpack_require__(/*! ../../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var client_util_1 = __webpack_require__(/*! ../../../util/client-util */ "./sdk/src/util/client-util.ts");
var zego_error_1 = __webpack_require__(/*! ../../../common/zego.error */ "./sdk/src/common/zego.error.ts");
var zego_preview_1 = __webpack_require__(/*! ./zego.preview */ "./sdk/src/webrtc/modules/publishModules/zego.preview.ts");
var index_1 = __webpack_require__(/*! ../../index */ "./sdk/src/webrtc/index.ts");
var PublishModule = /** @class */ (function () {
    function PublishModule(logger, dataReport, stateCenter, streamCenter, rtm) {
        this.logger = logger;
        this.dataReport = dataReport;
        this.stateCenter = stateCenter;
        this.streamCenter = streamCenter;
        this.rtm = rtm;
        //检测已有设备
        this.recordDevices();
    }
    PublishModule.prototype.createStream = function (option) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM + " call");
        // @ts-ignore
        if (option && option.camera && option.camera.audioBitRate) {
            // @ts-ignore
            option.camera.audioBitrate = option.camera.audioBitRate;
        }
        if (option && option.camera && option.camera.bitrate) {
            option.camera.bitRate = option.camera.bitrate;
        }
        if (option &&
            option.screen &&
            typeof option.screen == "object" &&
            option.screen.bitrate) {
            option.screen.bitRate = option.screen.bitrate;
        }
        if (option && option.custom && option.custom.bitrate) {
            option.custom.bitRate = option.custom.bitrate;
        }
        return new Promise(function (resolve, reject) {
            //const code = sdkErrorList.CLIENT + sdkErrorList.PARAM.code;
            var previewType = "camera";
            var reportSeq = zego_entity_1.getReportSeq();
            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.event);
            // 创建成功处理
            var interResolve = function (stream) {
                var preview = _this.streamCenter.checkPreview(stream);
                var _stream = stream;
                //兼容ios 15.1 h264推流失败问题
                if (preview && navigator.userAgent) {
                    var ver = navigator.userAgent
                        .toLowerCase()
                        .match(/cpu iphone os (.*?) like mac os/);
                    if (ver && ver[1] && ver[1].includes("15_1")) {
                        _stream = _this.getStreamThroughCanvas(stream);
                        preview.localStream = _stream;
                    }
                }
                // 补充无数据音轨
                if (_stream.getAudioTracks().length == 0) {
                    var destination = _this.streamCenter.ac.createMediaStreamDestination();
                    var aStream = destination ? destination.stream : null;
                    var audioTrack = aStream ? aStream.getAudioTracks()[0] : null;
                    if (audioTrack) {
                        // 把无数据音轨保存下来，录制时要删掉，避免录制异常
                        audioTrack.enabled = false;
                        _stream.addTrack(audioTrack);
                        preview && (preview.hasEmptyAudioTrack = true);
                    }
                }
                _this.dataReport.uploadReport(reportSeq);
                !_this.stateCenter.deviceInfos && _this.recordDevices();
                resolve(_stream);
                _this.streamCenter.activeSoundLevel();
            };
            // 创建失败处理
            var interReject = function (err, externMsg) {
                if (externMsg === void 0) { externMsg = ""; }
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: err.code,
                    message: err.message + externMsg
                });
                _this.dataReport.uploadReport(reportSeq);
                reject({
                    code: err.code,
                    msg: err.message + externMsg
                });
            };
            // 检测域名是否支持webrtc
            if (window.location.protocol !== "https:" &&
                window.location.protocol !== "file:" &&
                window.location.hostname.indexOf("127.0.0.1") == -1 &&
                window.location.hostname.indexOf("localhost") == -1) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM + " https or localhost required ");
                interReject({
                    code: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kBrowserNotSupportError
                        .code,
                    message: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kBrowserNotSupportError
                        .message + " https or localhost required"
                });
                return;
            }
            // 屏幕共享设置
            if (option && option.screen) {
                previewType = "screen";
                if (!client_util_1.ClientUtil.checkScreenParams(option.screen, interReject))
                    return;
                var bro = _this.stateCenter.browser;
                var screenConfig_1 = _this.streamCenter.getScreenConstrains(option.screen);
                _this.dataReport.addMsgInfo(reportSeq, {
                    stream_type: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.stream_type("screen"),
                    screen: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.screen(screenConfig_1)
                });
                var handleScreenSuccess_1 = function (stream) {
                    _this.streamCenter.createScreenPreviewer(stream, screenConfig_1) &&
                        interResolve(stream);
                    // 监听屏幕共享被手动关闭，并自动销毁流
                    stream.getVideoTracks()[0].onended = function () {
                        var innerReportSeq = zego_entity_1.getReportSeq();
                        _this.dataReport.newReport(innerReportSeq);
                        _this.dataReport.uploadReport(innerReportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskScreenSharingEnded);
                        stream && _this.stopPreview(stream);
                        _this.stateCenter.actionListener("screenSharingEnded", stream);
                    };
                };
                if (bro == "firefox" ||
                    // @ts-ignore
                    (typeof option.screen == "object" && option.screen.type == "firefox")) {
                    _this.startScreenShotFirFox("screen", screenConfig_1, function (suc, stream, err) {
                        if (suc) {
                            stream && handleScreenSuccess_1(stream);
                        }
                        else {
                            err && interReject(err);
                        }
                    });
                }
                else if ((bro == "chrome" && index_1.ZegoWebRTC.screenShotReady) ||
                    // @ts-ignore
                    (typeof option.screen == "object" && option.screen.type == "shot")) {
                    _this.startScreenShotChrome(function (suc, stream, err) {
                        if (suc) {
                            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM + " using extension");
                            stream && handleScreenSuccess_1(stream);
                        }
                        else {
                            err &&
                                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM + " extension " + err);
                            if (err !== "SS_DIALOG_CANCEL" &&
                                !(typeof option.screen == "object" &&
                                    // @ts-ignore
                                    option.screen.type == "shot")) {
                                _this.startScreenSharing(screenConfig_1, function (suc, stream, err) {
                                    if (suc) {
                                        stream && handleScreenSuccess_1(stream);
                                    }
                                    else {
                                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM + " " + err);
                                        err && interReject(err);
                                    }
                                });
                            }
                            else {
                                err &&
                                    interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error
                                        .kScreenCancelError);
                            }
                        }
                    });
                }
                else if (bro == "Electron" ||
                    // @ts-ignore
                    (typeof option.screen == "object" && option.screen.type == "Electron")) {
                    _this.startScreenShotElectron(screenConfig_1, function (suc, stream, err) {
                        if (suc) {
                            stream && handleScreenSuccess_1(stream);
                        }
                        else {
                            err && interReject(err);
                        }
                    });
                }
                else {
                    _this.startScreenSharing(screenConfig_1, function (suc, stream, err) {
                        if (suc) {
                            stream && handleScreenSuccess_1(stream);
                        }
                        else {
                            err && interReject(err);
                        }
                    });
                }
            }
            else {
                // 摄像头麦克风
                if (option &&
                    typeof option.camera === "object" &&
                    option.camera.videoQuality !== undefined) {
                    if (!client_util_1.ClientUtil.checkInteger(option.camera.videoQuality)) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM +
                            " videoQuality must be integer number");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " videoQuality must be integer number");
                        return;
                    }
                }
                // 麦克风音频码率参数校验
                if (option && option.camera && option.camera.audioBitrate) {
                    if (!client_util_1.ClientUtil.checkInteger(option.camera.audioBitrate)) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM +
                            " audioBitrate must be integer number");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " audioBitrate must be integer number");
                        return;
                    }
                    else if (option.camera.audioBitrate < 6) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM +
                            " audioBitrate cannot less 6 kbps");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " audioBitrate cannot less 6 kbps");
                        return;
                    }
                    else if (option.camera.audioBitrate > 510) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM +
                            " audioBitrate cannot greater than 510 kbps");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " audioBitrate cannot greater than 510 kbps");
                        return;
                    }
                    _this.stateCenter.audioBitRate = option.camera.audioBitrate * 1e3;
                }
                // 摄像头码率参数校验
                if (option && option.camera && option.camera.bitRate) {
                    if (typeof option.camera.bitRate !== "number") {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM +
                            " bitrate must be integer number");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " bitrate must be integer number");
                        return;
                    }
                    else if (option.camera.bitRate > 10240) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM +
                            " bitrate cannot greater than 10 Mbps");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " bitrate cannot greater than 10 Mbps");
                        return;
                    }
                }
                // 麦克风声道数参数校验
                if (option &&
                    option.camera &&
                    option.camera.channelCount !== undefined) {
                    if (!client_util_1.ClientUtil.checkInteger(option.camera.channelCount)) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM +
                            " channelCount must be integer number");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " channelCount must be integer number");
                        return;
                    }
                }
                // 自定义视频质量参数校验
                if (option &&
                    option.camera &&
                    option.camera.videoQuality === 4 &&
                    !client_util_1.ClientUtil.checkCameraParams(option.camera, interReject)) {
                    return;
                }
                if (option && option.custom && option.custom.bitRate) {
                    if (!client_util_1.ClientUtil.checkInteger(option.custom.bitRate)) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM +
                            " bitrate must be integer number");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " bitrate must be integer number");
                        return;
                    }
                    else if (option.custom.bitRate > 10240) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM +
                            " bitrate cannot greater than 10 Mbps");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " bitrate cannot greater than 10 Mbps");
                        return;
                    }
                }
                if (option && option.custom && option.custom.audioBitrate) {
                    if (!client_util_1.ClientUtil.checkInteger(option.custom.audioBitrate)) {
                        _this.logger.error("ze.cs.0 audioBitrate must be integer number");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " audioBitrate must be integer number");
                        return;
                    }
                    else if (option.custom.audioBitrate < 6) {
                        _this.logger.error("ze.cs.0 audioBitrate cannot less 6 kbps");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " audioBitrate cannot less 6 kbps");
                        return;
                    }
                    else if (option.custom.audioBitrate > 510) {
                        _this.logger.error("ze.cs.0 audioBitrate cannot greater than 510 kbps");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " audioBitrate cannot greater than 510 kbps");
                        return;
                    }
                }
                if (option &&
                    option.custom &&
                    option.custom.channelCount !== undefined) {
                    if (option.custom.channelCount !== 1 &&
                        option.custom.channelCount !== 2) {
                        _this.logger.error("ze.cs.0 channelCount must number 1 or 2");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " channelCount must number 1 or 2");
                        return;
                    }
                }
                var constraints = {};
                if (option && option.camera) {
                    previewType = "camera";
                    constraints = option.camera;
                    _this.dataReport.addMsgInfo(reportSeq, {
                        stream_type: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.stream_type("camera"),
                        camera: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.camera(option.camera)
                    });
                    if (typeof constraints.video !== "boolean")
                        constraints.video = true;
                    if (typeof constraints.audio !== "boolean")
                        constraints.audio = true;
                }
                else if (option && option.custom) {
                    previewType = "custom";
                    constraints = option.custom;
                    var sourceType = option.custom.source instanceof MediaStream
                        ? "MediaStream"
                        : "HTMLElement";
                    _this.dataReport.addMsgInfo(reportSeq, {
                        stream_type: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.stream_type("custom"),
                        custom: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.custom(__assign(__assign({}, option.custom), { source: sourceType }))
                    });
                }
                _this.startPreview(constraints, previewType, interResolve, interReject);
            }
        });
    };
    PublishModule.prototype.destroyStream = function (localStream) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.DESTROY_STREAM + " call");
        var reportSeq = zego_entity_1.getReportSeq();
        this.dataReport.newReport(reportSeq);
        if (!(localStream instanceof MediaStream)) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.DESTROY_STREAM +
                " localStream is not mediaStream or tracks is null");
            this.dataReport.addMsgInfo(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskDestroyStream.error.kLocalStreamError);
            this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskDestroyStream.event);
            return;
        }
        if (localStream instanceof MediaStream &&
            localStream.getTracks().length == 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.DESTROY_STREAM + " tracks is null");
        }
        this.stopPreview(localStream);
        this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskDestroyStream.event);
    };
    PublishModule.prototype.startPublishingStream = function (streamID, localStream, publishOption, isDataChannel) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM + " call ", streamID);
        //publish Event start
        var result = true;
        var error;
        var externMsg = "";
        var reportSeq = zego_entity_1.getReportSeq();
        this.stateCenter.reportSeqList.startPublish[streamID] = reportSeq;
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.event);
        if (result && streamID === undefined) {
            externMsg = "stream id required";
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM + externMsg);
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
        }
        if (result && (!streamID || typeof streamID !== "string")) {
            externMsg = "stream id type wrong";
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM + " " + externMsg);
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
        }
        if (result && streamID.length > zego_entity_1.MAX_STREAM_ID_LENGTH) {
            externMsg = "stream id length limit";
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM + " " + externMsg);
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
        }
        if (result && !client_util_1.ClientUtil.checkIllegalCharacters(streamID)) {
            externMsg = "stream ID contains illegal characters";
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM + " " + externMsg);
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
        }
        if (result &&
            (!localStream ||
                (localStream instanceof MediaStream &&
                    localStream.getTracks().length == 0))) {
            externMsg = "localStream wrong";
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM + " " + externMsg);
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
        }
        if (result && !this.streamCenter.checkPreview(localStream)) {
            externMsg = "stream is not from zego";
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM + " " + externMsg);
            result = false;
            error =
                zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishNoPreviewError;
        }
        if (result &&
            typeof publishOption !== "undefined" &&
            typeof publishOption !== "object") {
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
            externMsg = "publishOption must be object";
        }
        if (result &&
            publishOption !== undefined &&
            publishOption.streamParams !== undefined &&
            typeof publishOption.streamParams !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM +
                " publishOption streamParams must be string");
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
            externMsg = " publishOption streamParams must be string";
        }
        if (result &&
            publishOption !== undefined &&
            publishOption.extraInfo !== undefined &&
            typeof publishOption.extraInfo !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM +
                " publishOption extraInfo must be string");
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
            externMsg = " publishOption extraInfo must be string";
        }
        if (result &&
            publishOption !== undefined &&
            publishOption.videoCodec !== undefined &&
            typeof publishOption.videoCodec !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM +
                " publishOption videoCodec must be string");
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
            externMsg = " publishOption videoCodec must be string";
        }
        if (result &&
            this.stateCenter.isMultiRoom &&
            (!publishOption ||
                typeof publishOption.roomID !== "string" ||
                publishOption.roomID == "")) {
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
            externMsg = " roomID is need if set multi room";
        }
        // publishOption videoCodec 大小写兼容
        if (publishOption && publishOption.videoCodec) {
            publishOption.videoCodec = publishOption.videoCodec.toUpperCase();
        }
        if (result && this.rtm.isDisConnect()) {
            this.logger.error("zc.p.sps.1 not login");
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishNoLoginError;
        }
        if (!result) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM + " " + externMsg);
            this.dataReport.uploadReport(reportSeq, undefined, error, externMsg);
            delete this.stateCenter.reportSeqList.startPublish[streamID];
            return false;
        }
        if (!publishOption) {
            publishOption = {};
        }
        this.dataReport.addMsgInfo(reportSeq, {
            stream: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.stream(streamID),
            publishOption: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.publishOption(publishOption)
        });
        publishOption.audioBitRate = this.stateCenter.audioBitRate;
        var roomID = publishOption.roomID
            ? publishOption.roomID
            : this.stateCenter.roomList[0]
                ? this.stateCenter.roomList[0].roomID
                : "";
        var room = this.stateCenter.getRoomByRoomID(roomID);
        if (!room) {
            this.logger.error("zc.p.sps.1 room no found");
            return false;
        }
        this.dataReport.addMsgInfo(reportSeq, {
            publish_room_id: roomID,
            isMulti: this.stateCenter.isMultiRoom
        });
        var signals;
        if (this.stateCenter.customUrl && this.stateCenter.customUrl.length != 0) {
            this.logger.info("zc.p.sps.1 customUrl " + JSON.stringify(this.stateCenter.customUrl));
            signals = this.stateCenter.customUrl;
        }
        else {
            var signalNodes = this.stateCenter.settingConfig.getSetting("signal_nodes", true);
            if (signalNodes &&
                signalNodes instanceof Array &&
                signalNodes.length > 0) {
                signals = signalNodes;
                this.logger.info("zc.p.sps.1 setting config signal_nodes " +
                    JSON.stringify(signalNodes));
            }
        }
        if (signals) {
            this.stateCenter.publishStreamList[streamID] = {
                state: zego_entity_1.ENUM_PUBLISH_STREAM_STATE.tryPublish,
                extra_info: publishOption.extraInfo ? publishOption.extraInfo : null
            };
            if (!this.streamCenter.setPublishStateStart(room, streamID, localStream, publishOption, isDataChannel)) {
                this.logger.info("zc.p.sps.1 cannot start publish");
                return false;
            }
            room.streamHandler.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.retry, streamID, { code: 0, message: "" });
            this.streamCenter.publisherList[streamID].serverUrls = signals;
            return this.streamCenter.startPublishingStream(streamID);
        }
        if (!this.streamCenter.setPublishStateStart(room, streamID, localStream, publishOption, isDataChannel)) {
            this.logger.error("zc.p.sps.1 cannot start publish");
            return false;
        }
        this.stateCenter.publishStreamList[streamID] = {
            state: zego_entity_1.ENUM_PUBLISH_STREAM_STATE.tryPublish,
            extra_info: publishOption.extraInfo ? publishOption.extraInfo : null
        };
        this.logger.info("zc.p.sps.1 start publish");
        room.streamHandler.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.retry, streamID, { code: 0, message: "" });
        // // TODO: test
        // if (this.stateCenter.useNetAgent) {
        //   this.streamCenter.onPublishStateUpdate(0, streamID);
        //   return true;
        // }
        // // TOTO
        var useNetAgent = this.stateCenter.useNetAgent;
        var publisherInfo = this.streamCenter.publisherList[streamID];
        if (useNetAgent) {
            if (!this.stateCenter.appConfig) {
                this.streamCenter.waitPublishList.push(streamID);
                return true;
            }
            // 统一接入不用走调度,直接调用推流
            this.streamCenter.publisherList[streamID].serverUrls = ["unified_rtc"];
            this.streamCenter.startPublishingStream(streamID, useNetAgent);
            return true;
        }
        else {
            var retryDispatchHandler = publisherInfo.retryDispatchHandler;
            retryDispatchHandler.stopMaxTime();
            retryDispatchHandler.invalid();
            retryDispatchHandler.initStream(streamID, publishOption, true);
            retryDispatchHandler.startMaxTime();
            return retryDispatchHandler.active(0);
        }
    };
    PublishModule.prototype.activateSEIInsert = function (stream, action, infoType) {
        if (infoType === void 0) { infoType = 0; }
        return false;
    };
    PublishModule.prototype.stopPublishingStream = function (streamID, serverError) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STOP_PUBLISHING_STREAM + " call ", streamID + (serverError ? serverError.toString() : ""));
        //stop publish Event start
        var reportSeq = zego_entity_1.getReportSeq();
        this.stateCenter.reportSeqList.stopPublish[streamID] = reportSeq;
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStop.event);
        this.dataReport.addMsgInfo(reportSeq, {
            streamID: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStop.stream(streamID)
        });
        if (typeof streamID !== "string" || streamID == "") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.STOP_PUBLISHING_STREAM +
                " streamID must be string and not empty");
            this.dataReport.uploadReport(reportSeq, undefined, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStop.error.kParamError, "stream id type error");
            delete this.stateCenter.reportSeqList.stopPublish[streamID];
            return false;
        }
        var publish = this.streamCenter.publisherList[streamID];
        // if (!publish || publish.serverUrls.length == 0 || !publish.publisher.signal) {
        //     publish && this.logger.error('zc.p.sps.1.1 stream can not be destroyed');
        //     this.dataReport.uploadReport(reportSeq, undefined, errorList.kIsPublishing, 'can not be destroyed');
        //     delete this.stateCenter.reportSeqList.stopPublish[totalStreamId];
        //     return false;
        // }
        var room = this.streamCenter.getRoomByStreamID(streamID);
        var shouldPublishUpdate = publish &&
            publish.publisher &&
            publish.publisher.state !== zego_entity_1.ENUM_PUBLISH_STATE.stop;
        this.streamCenter.stopPublishingStream(streamID);
        if (this.stateCenter.publishStreamList[streamID]) {
            if (this.stateCenter.publishStreamList[streamID].state >=
                zego_entity_1.ENUM_PUBLISH_STREAM_STATE.update_info &&
                room) {
                // 服务端下发token过期而停止推流不需要在向服务端发送流删除信令。
                if (!serverError || serverError.code !== 1102018) {
                    var cmd = void 0;
                    this.stateCenter.type === "PUBLIC"
                        ? (cmd = zego_entity_1.ENUM_STREAM_SUB_CMD.liveEnd)
                        : (cmd = zego_entity_1.ENUM_STREAM_CMD_PRI.liveEnd);
                    room.streamHandler.updateStreamInfo(streamID, cmd);
                }
                //上报流删除时需将statecenter.streamList中对应的流删除
                for (var i = 0; i < room.streamList.length; i++) {
                    if (room.streamList[i].stream_id == streamID) {
                        room.streamList.splice(i--, 1);
                        break;
                    }
                }
            }
            delete this.stateCenter.publishStreamList[streamID];
        }
        this.dataReport.uploadReport(reportSeq);
        // TODO 抛出回调
        room &&
            shouldPublishUpdate &&
            room.streamHandler.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.error, streamID, serverError || {
                code: 0,
                message: ""
            });
        return true;
    };
    PublishModule.prototype.setCaptureVolume = function (localStream, volume) {
        var _this = this;
        return new Promise(function (resolve) {
            var _a;
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISH_SET_CAPTURE_VOLUME + " call");
            var handleFail = function (msg) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISH_SET_CAPTURE_VOLUME + " " + msg);
                resolve({
                    errorCode: zego_log_event_1.ZegoRTCLogEvent.kZegoSetCaptureVolume.error.kParamError.code,
                    extendedData: JSON.stringify({
                        fail_reason: zego_log_event_1.ZegoRTCLogEvent.kZegoSetCaptureVolume.error.kParamError.message +
                            " " +
                            msg
                    })
                });
            };
            var ac = _this.streamCenter.ac;
            var preview = _this.streamCenter.checkPreview(localStream);
            if (!(localStream instanceof MediaStream) || !preview) {
                handleFail(" stream must be created by zego");
                return;
            }
            if (localStream.getAudioTracks().length == 0) {
                handleFail(" stream audioTrack no found");
                return;
            }
            if (typeof volume !== "number" || volume < 0 || volume > 100) {
                handleFail(" volume must be number between 0 to 100");
                return;
            }
            if (preview.gainNode) {
                preview.gainNode.gain.value = volume / 100;
            }
            else {
                var source = ac.createMediaStreamSource(localStream);
                var gainNode = ac.createGain();
                var destination = ac.createMediaStreamDestination();
                source.connect(gainNode);
                gainNode.connect(destination);
                var audioTrack = destination.stream.getAudioTracks()[0];
                for (var streamID in _this.streamCenter.publisherList) {
                    var publish = _this.streamCenter.publisherList[streamID];
                    if (publish.localStream == localStream) {
                        var sender = (_a = publish.publisher.peerConnection) === null || _a === void 0 ? void 0 : _a.getSenders().find(function (s) { return s.track && s.track.kind === "audio"; });
                        if (sender) {
                            sender.replaceTrack(audioTrack);
                            publish.localStream.removeTrack(publish.publisher.localStream.getAudioTracks()[0]);
                            publish.localStream.addTrack(audioTrack);
                        }
                        break;
                    }
                }
                localStream.removeTrack(localStream.getAudioTracks()[0]);
                localStream.addTrack(audioTrack);
                preview.gainNode = gainNode;
                preview.gainNode.gain.value = volume / 100;
            }
            ac.resume();
            resolve({ errorCode: 0, extendedData: "" });
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISH_SET_CAPTURE_VOLUME + " call success");
        });
    };
    PublishModule.prototype.getElectronScreenSources = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var electron = window.require("electron");
            if (!electron) {
                _this.logger.error("zc.gess.0 Electron is not exist");
                reject({
                    message: "Electron is not exist"
                });
            }
            electron.desktopCapturer
                .getSources({
                types: ["window", "screen"]
            })
                .then(function (sources) {
                var sourceList = sources.map(function (item) {
                    return {
                        id: item.id,
                        name: item.name,
                        thumbnail: item.thumbnail
                    };
                });
                resolve(sourceList);
            })
                .catch(function (err) {
                _this.logger.error("zc.gess.0 " + err);
                reject(err);
            });
        });
    };
    PublishModule.prototype.startScreenShotChrome = function (callBack) {
        if (!index_1.ZegoWebRTC.screenShotReady) {
            var msg = "zc.b.ss Please install the extension:1. Go to chrome://extensions  2. Check: \"Enable Developer mode   3. Click: \"Load the unpacked extension... 4. Choose \"extension\" folder from the repository 5. Reload this page";
            this.logger.error(msg);
            callBack(false, null, {
                code: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError.code,
                message: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError
                    .message +
                    " " +
                    msg
            });
        }
        else {
            window.postMessage({ type: "SS_UI_REQUEST", text: "start" }, "*");
            // listen for messages from the content-script
            client_util_1.ClientUtil.registerCallback("screenShare", { success: callBack }, this.stateCenter.callbackList);
        }
    };
    PublishModule.prototype.startScreenSharing = function (screenConfig, callBack) {
        var _this = this;
        if ("getDisplayMedia" in navigator.mediaDevices) {
            var zegoMediaDevices = navigator.mediaDevices;
            zegoMediaDevices
                .getDisplayMedia({
                audio: screenConfig.audio,
                video: {
                    frameRate: screenConfig.frameRate,
                    width: screenConfig.width,
                    height: screenConfig.height
                }
            })
                .then(function (stream) {
                callBack(true, stream);
            })
                .catch(function (err) {
                _this.logger.error("zc.b.sss " + err);
                if (err.message && err.message.toLowerCase() == "permission denied") {
                    callBack(false, null, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenCancelError);
                }
                else {
                    callBack(false, null, {
                        code: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError
                            .code,
                        message: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError
                            .message +
                            " " +
                            err
                    });
                }
            });
        }
        else {
            this.logger.error("zc.b.sss brower does not support getDisplayMedia");
            callBack(false, null, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kBrowserNotSupportError);
        }
    };
    PublishModule.prototype.startScreenShotFirFox = function (mediaSource, screenConfig, callBack) {
        var _this = this;
        var config = {
            video: {
                frameRate: screenConfig.frameRate,
                bitRate: screenConfig.bitRate,
                width: screenConfig.width,
                height: screenConfig.height,
                mediaSource: mediaSource
            },
            audio: screenConfig.audio
        };
        navigator.mediaDevices
            .getUserMedia(config)
            .then(function (stream) {
            // this.stateCenter.screenShotStream = stream;
            callBack(true, stream);
        })
            .catch(function (err) {
            _this.logger.error("ze.ssf.1 " + err);
            callBack(false, null, {
                code: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError.code,
                message: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError
                    .message +
                    " " +
                    err
            });
        });
    };
    PublishModule.prototype.startScreenShotElectron = function (screenConfig, callBack) {
        var _this = this;
        var electron = window.require("electron");
        if (!electron) {
            this.logger.error("ze.sse.1 Electron is not exist");
            callBack(false, null, {
                code: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError.code,
                message: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError
                    .message + " Electron is not exist"
            });
            return;
        }
        var config = {
            video: {
                mandatory: {
                    chromeMediaSource: "desktop",
                    chromeMediaSourceId: screenConfig.sourceID,
                    maxWidth: window.screen.width,
                    maxHeight: window.screen.height
                }
            },
            audio: false
        };
        navigator.mediaDevices
            .getUserMedia(config)
            .then(function (stream) {
            // this.stateCenter.screenShotStream = stream;
            callBack(true, stream);
        })
            .catch(function (err) {
            _this.logger.error("ze.sse.1 " + err);
            callBack(false, null, {
                code: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError.code,
                message: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError
                    .message +
                    " " +
                    err
            });
        });
    };
    PublishModule.prototype.startPreview = function (mediaStreamConstraints, previewType, success, error) {
        var _this = this;
        var preview = null;
        preview = new zego_preview_1.ZegoPreview(this.logger, this.streamCenter.ac, this.stateCenter, this.streamCenter, previewType);
        this.streamCenter.previewStreamList.push(preview);
        preview.startPreview(mediaStreamConstraints, function (stream) {
            _this.streamCenter.soundLevelDelegate && (preview === null || preview === void 0 ? void 0 : preview.startSoundLevel());
            if (previewType === "camera") {
                // 根据麦克风静音状态来设置新建的预览流麦克风音频
                (preview === null || preview === void 0 ? void 0 : preview.micTrack) &&
                    (preview.micTrack.enabled = _this.streamCenter.isMicEnabled);
            }
            // 修改contentHint
            if (mediaStreamConstraints === null || mediaStreamConstraints === void 0 ? void 0 : mediaStreamConstraints.videoOptimizationMode) {
                _this.streamCenter.setVideoTrackContentHint(stream, mediaStreamConstraints === null || mediaStreamConstraints === void 0 ? void 0 : mediaStreamConstraints.videoOptimizationMode);
            }
            _this.logger.debug("zsc.sp.0 call success");
            !_this.stateCenter.deviceInfos && _this.recordDevices();
            success && success(stream);
        }, function (err) {
            _this.streamCenter.previewStreamList = _this.streamCenter.previewStreamList.filter(function (view) { return view !== preview; });
            error && error(err);
        });
        return true;
    };
    PublishModule.prototype.stopPreview = function (localStream) {
        if (!localStream) {
            this.logger.warn("zsc.sp.0 localStream null");
            return false;
        }
        for (var streamid in this.streamCenter.publisherList) {
            if (this.streamCenter.publisherList[streamid].localStream === localStream) {
                this.streamCenter.publisherList[streamid].localStream = null;
            }
        }
        var preview = this.streamCenter.checkPreview(localStream);
        if (!preview) {
            this.logger.warn("zsc.sp.0 no preview");
            return false;
        }
        if (preview.previewSuc) {
            preview.stopPreview();
            this.streamCenter.removePreview(preview);
        }
        return true;
    };
    PublishModule.prototype.recordDevices = function (suc, fail) {
        var _this = this;
        var _a;
        this.logger.info("zsc.rd.0 call");
        // 枚举设备并存储，同时设置设备列表更改监听
        client_util_1.ClientUtil.getDevices(function (res) {
            _this.stateCenter.deviceInfos = {
                microphones: res.microphones,
                speakers: res.speakers,
                cameras: res.cameras
            };
            suc && suc(res);
        }, function (err) {
            _this.logger.warn("zsc.rd.0 getDevices err:", err);
            fail && fail(err);
        });
        if (((_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.ondevicechange) !== undefined) {
            navigator.mediaDevices.ondevicechange = null;
            navigator.mediaDevices.ondevicechange = function (event) {
                _this.logger.info("zsc.rd.0 devicechange");
                if (_this.stateCenter.deviceChangeTimer) {
                    clearTimeout(_this.stateCenter.deviceChangeTimer);
                    _this.stateCenter.deviceChangeTimer = null;
                }
                _this.stateCenter.deviceChangeTimer = setTimeout(function () {
                    client_util_1.ClientUtil.getDevices(function (res) {
                        var reducedCameras = [];
                        var _loop_1 = function (i) {
                            var camera = _this.stateCenter.deviceInfos.cameras[i];
                            if (!res.cameras.find(function (item) { return item.deviceID === camera.deviceID; })) {
                                reducedCameras.push(camera);
                            }
                        };
                        for (var i = 0; i < _this.stateCenter.deviceInfos.cameras.length; i++) {
                            _loop_1(i);
                        }
                        _this.stateCenter.deviceStateOut = false;
                        var deviceOut = false;
                        reducedCameras.length > 0 && (deviceOut = true);
                        reducedCameras.forEach(function (reducedCamera) {
                            for (var key in _this.streamCenter.publisherList) {
                                var publish = _this.streamCenter.publisherList[key];
                                var publisher = publish.publisher;
                                if (publish.localStream &&
                                    publish.cameraLabel === reducedCamera.deviceName) {
                                    deviceOut = false;
                                    publisher.sendStreamStatus(-6, publisher.mic_status);
                                    _this.stateCenter.actionListener("_deviceError", zego_error_1.errorCodeList.DEVICE_ERROR_TYPE_UNPLUGGED.code, reducedCamera.deviceName, "camera");
                                    _this.stateCenter.actionListener("deviceError", zego_error_1.errorCodeList.DEVICE_ERROR_TYPE_UNPLUGGED.code, reducedCamera.deviceName);
                                }
                                publish.localStream &&
                                    publish.localStream.getAudioTracks().length === 0 &&
                                    (deviceOut = false);
                            }
                            var reportSeq = zego_entity_1.getReportSeq();
                            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskDeviceInterrupt.event);
                            _this.dataReport.addMsgInfo(reportSeq, {
                                interrupt: 0
                            });
                            _this.dataReport.uploadReport(reportSeq);
                            _this.stateCenter.actionListener("videoDeviceStateChanged", "DELETE", reducedCamera);
                        });
                        if (deviceOut) {
                            _this.stateCenter.deviceStateOut = true;
                        }
                        var reduceMicros = _this.stateCenter.deviceInfos.microphones.filter(function (item) {
                            return !res.microphones.find(function (micro) { return micro.deviceID === item.deviceID; });
                        });
                        reduceMicros.forEach(function (reducedCamera) {
                            for (var key in _this.streamCenter.publisherList) {
                                var publish = _this.streamCenter.publisherList[key];
                                var publisher = publish.publisher;
                                if (publish.localStream &&
                                    (publish.microLabel === reducedCamera.deviceName ||
                                        publish.microLabel.includes(reducedCamera.deviceName))) {
                                    publisher.sendStreamStatus(publisher.camera_status, -6);
                                    _this.stateCenter.actionListener("_deviceError", zego_error_1.errorCodeList.DEVICE_ERROR_TYPE_UNPLUGGED.code, _this.streamCenter.publisherList[key].microLabel, "micro");
                                    _this.stateCenter.actionListener("deviceError", zego_error_1.errorCodeList.DEVICE_ERROR_TYPE_UNPLUGGED.code, _this.streamCenter.publisherList[key].microLabel);
                                }
                            }
                            var reportSeq = zego_entity_1.getReportSeq();
                            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskDeviceInterrupt.event);
                            _this.dataReport.addMsgInfo(reportSeq, {
                                interrupt: 0
                            });
                            _this.dataReport.uploadReport(reportSeq);
                            _this.stateCenter.actionListener("audioDeviceStateChanged", "DELETE", "Input", reducedCamera);
                        });
                        var reduceSpeakers = _this.stateCenter.deviceInfos.speakers.filter(function (item) {
                            return !res.speakers.find(function (micro) { return micro.deviceID === item.deviceID; });
                        });
                        var increaseCameras = res.cameras.filter(function (item) {
                            return !_this.stateCenter.deviceInfos.cameras.find(function (camera) { return camera.deviceID === item.deviceID; });
                        });
                        var increaseMicros = res.microphones.filter(function (item) {
                            return !_this.stateCenter.deviceInfos.microphones.find(function (camera) { return camera.deviceID === item.deviceID; });
                        });
                        var increaseSpeakers = res.speakers.filter(function (item) {
                            return !_this.stateCenter.deviceInfos.speakers.find(function (camera) { return camera.deviceID === item.deviceID; });
                        });
                        reduceSpeakers.forEach(function (device) {
                            var reportSeq = zego_entity_1.getReportSeq();
                            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskAudioOutputChanged.event);
                            _this.dataReport.addMsgInfo(reportSeq, {
                                reason: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskAudioOutputChanged.reason("delete"),
                                device: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskAudioOutputChanged.device(device)
                            });
                            _this.dataReport.uploadReport(reportSeq);
                            _this.stateCenter.actionListener("audioDeviceStateChanged", "DELETE", "Output", device);
                        });
                        increaseCameras.forEach(function (device) {
                            var reportSeq = zego_entity_1.getReportSeq();
                            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskDeviceInterrupt.event);
                            _this.dataReport.addMsgInfo(reportSeq, {
                                interrupt: 1
                            });
                            _this.dataReport.uploadReport(reportSeq);
                            _this.stateCenter.actionListener("videoDeviceStateChanged", "ADD", device);
                        });
                        increaseMicros.forEach(function (device) {
                            var reportSeq = zego_entity_1.getReportSeq();
                            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskDeviceInterrupt.event);
                            _this.dataReport.addMsgInfo(reportSeq, {
                                interrupt: 1
                            });
                            _this.dataReport.uploadReport(reportSeq);
                            _this.stateCenter.actionListener("audioDeviceStateChanged", "ADD", "Input", device);
                        });
                        increaseSpeakers.forEach(function (device) {
                            var reportSeq = zego_entity_1.getReportSeq();
                            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskAudioOutputChanged.event);
                            _this.dataReport.addMsgInfo(reportSeq, {
                                reason: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskAudioOutputChanged.reason("add"),
                                device: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskAudioOutputChanged.device(device)
                            });
                            _this.dataReport.uploadReport(reportSeq);
                            _this.stateCenter.actionListener("audioDeviceStateChanged", "ADD", "Output", device);
                        });
                        _this.stateCenter.deviceInfos = {
                            microphones: res.microphones,
                            speakers: res.speakers,
                            cameras: res.cameras
                        };
                    }, function (err) {
                        _this.logger.warn("zsc.rd.0 getDevices err:", err);
                    });
                }, 500);
            };
        }
    };
    PublishModule.prototype.getStreamThroughCanvas = function (stream) {
        if (stream.getVideoTracks().length == 0) {
            return stream;
        }
        var video = document.createElement("video");
        var canvas = document.createElement("canvas");
        var ctx = canvas.getContext("2d");
        video.setAttribute("style", "display:none");
        canvas.setAttribute("style", "display:none");
        video.setAttribute("muted", "");
        video.muted = !0;
        video.setAttribute("autoplay", "");
        video.autoplay = !0;
        video.setAttribute("playsinline", "");
        document.body.append(video);
        document.body.append(canvas);
        video.srcObject = stream;
        var draw = function () {
            ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            window.requestAnimationFrame(draw);
            // track.requestFrame && track.requestFrame();
            video.srcObject = stream;
        };
        video.oncanplay = function () {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            video.play();
            draw();
        };
        //@ts-ignore
        var media = canvas.captureStream(15);
        var track = media.getVideoTracks()[0];
        var q = track.stop;
        track.stop = function () {
            q.call(track);
            draw();
            video.remove();
            canvas.width = 0;
            canvas.remove();
        };
        if (stream instanceof MediaStream && stream.getAudioTracks().length) {
            var micro = stream.getAudioTracks()[0];
            media.addTrack(micro);
        }
        return media;
    };
    PublishModule.prototype.startWaitPublish = function () {
        var _this = this;
        this.streamCenter.waitPublishList.forEach(function (streamID) {
            _this.streamCenter.startPublishingStream(streamID, _this.stateCenter.useNetAgent);
        });
        this.streamCenter.waitPublishList = [];
    };
    return PublishModule;
}());
exports.PublishModule = PublishModule;


/***/ }),

/***/ "./sdk/src/webrtc/modules/publishModules/zego.preview.ts":
/*!***************************************************************!*\
  !*** ./sdk/src/webrtc/modules/publishModules/zego.preview.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoPreview = void 0;
var zego_entity_1 = __webpack_require__(/*! ../../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var action_1 = __webpack_require__(/*! ../../../common/action */ "./sdk/src/common/action.ts");
var ZegoPreview = /** @class */ (function () {
    function ZegoPreview(logger, ac, stateCenter, streamCenter, previewType) {
        var _this = this;
        this.logger = logger;
        this.ac = ac;
        this.stateCenter = stateCenter;
        this.streamCenter = streamCenter;
        this.previewType = previewType;
        this.localStream = null;
        this.videoInfo = {};
        this.previewSuc = false;
        this.soundLevel = 0;
        this.hasEmptyAudioTrack = false;
        this.script = null;
        this.mic = null;
        this._audioTrack = null;
        this._videoTrack = null;
        this.originVideoTrack = null;
        // 是否开启SEI插入功能
        this.activateSEIConfig = null;
        // 记录音频是否被静音
        this.isAudioEnabled = true;
        this.gainNode = null;
        this.cameraMaxResolution = {};
        /*
         *    "zp.emo.2": "enableMicrophoneOnly"
         */
        this.enableMicrophoneOnly = function (enable, streamCenter) {
            var _a;
            if (!_this.localStream) {
                _this.logger.error("zp.em.2 no localStream");
                return false;
            }
            else {
                var publisher = (_a = streamCenter.checkPublish(_this.localStream)) === null || _a === void 0 ? void 0 : _a.publisher;
                if (publisher) {
                    var camera_status = publisher.camera_status;
                    var mic_status = _this.isAudioEnabled && enable ? 0 : 20;
                    if (publisher.camera_status !== camera_status ||
                        publisher.mic_status !== mic_status) {
                        publisher.sendStreamStatus(camera_status, mic_status);
                    }
                }
            }
            if (!_this.micTrack) {
                _this.logger.info("zp.emo.2 no micTrack");
                return true;
            }
            _this.micTrack.enabled = _this.isAudioEnabled && enable;
            _this.logger.debug("zp.emo.2 call success");
            return true;
        };
    }
    Object.defineProperty(ZegoPreview.prototype, "audioTrack", {
        get: function () {
            var _a;
            return this._audioTrack || ((_a = this.localStream) === null || _a === void 0 ? void 0 : _a.getAudioTracks()[0]) || null;
        },
        set: function (val) {
            this._audioTrack = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ZegoPreview.prototype, "videoTrack", {
        get: function () {
            var _a;
            return this._videoTrack || ((_a = this.localStream) === null || _a === void 0 ? void 0 : _a.getVideoTracks()[0]) || null;
        },
        set: function (val) {
            this._videoTrack = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ZegoPreview.prototype, "micTrack", {
        get: function () {
            return (this.previewType === "camera" && this.audioTrack) || null;
        },
        enumerable: false,
        configurable: true
    });
    /*
     *    "zp.gmsc.2": "getMediaStreamConstraints"
     */
    ZegoPreview.prototype.getMediaStreamConstraints = function (mediaStreamConfig, force) {
        var mediaStreamConstraints = {
            audio: null,
            video: null
        };
        mediaStreamConstraints["audio"] = true;
        mediaStreamConstraints["video"] = {
            width: 640,
            height: 480,
            frameRate: 15,
            bitRate: this.stateCenter.settingConfig.getSetting("camera_video_bitrate")
        };
        //audio
        if (mediaStreamConfig.audio) {
            if (mediaStreamConfig.audioInput === undefined &&
                mediaStreamConfig.ANS === undefined &&
                mediaStreamConfig.AGC === undefined &&
                mediaStreamConfig.AEC === undefined &&
                mediaStreamConfig.channelCount === undefined) {
                mediaStreamConstraints.audio = {};
                mediaStreamConstraints.audio.noiseSuppression = this.stateCenter.settingConfig.getSetting("ANS");
                mediaStreamConstraints.audio.autoGainControl = this.stateCenter.settingConfig.getSetting("AGC");
                mediaStreamConstraints.audio.echoCancellation = this.stateCenter.settingConfig.getSetting("AEC");
                mediaStreamConstraints.audio.channelCount = 1;
            }
            else {
                mediaStreamConstraints.audio = {};
                if (mediaStreamConfig.audioInput !== undefined &&
                    mediaStreamConfig.audioInput !== null)
                    mediaStreamConstraints.audio.deviceId = {
                        exact: mediaStreamConfig.audioInput
                    };
                if (mediaStreamConfig.ANS !== undefined)
                    mediaStreamConstraints.audio.noiseSuppression = mediaStreamConfig.ANS;
                if (mediaStreamConfig.AGC !== undefined)
                    mediaStreamConstraints.audio.autoGainControl = mediaStreamConfig.AGC;
                if (mediaStreamConfig.AEC !== undefined)
                    mediaStreamConstraints.audio.echoCancellation = mediaStreamConfig.AEC;
                if (mediaStreamConfig.channelCount !== undefined)
                    mediaStreamConstraints.audio.channelCount =
                        mediaStreamConfig.channelCount;
            }
        }
        else if (mediaStreamConfig.audio === false) {
            mediaStreamConstraints.audio = false;
        }
        //video
        if (mediaStreamConfig.video) {
            var width = 640;
            var height = 480;
            var frameRate = 15;
            var bitRate = this.stateCenter.settingConfig.getSetting("camera_video_bitrate");
            //videoQuality
            //1 QVGA
            if (mediaStreamConfig.videoQuality === 1) {
                width = zego_entity_1.ENUM_RESOLUTION_TYPE.LOW.width;
                height = zego_entity_1.ENUM_RESOLUTION_TYPE.LOW.height;
                frameRate = zego_entity_1.ENUM_RESOLUTION_TYPE.LOW.frameRate;
                bitRate = zego_entity_1.ENUM_RESOLUTION_TYPE.LOW.bitRate;
            }
            //2 VGA
            else if (mediaStreamConfig.videoQuality === 2) {
                width = zego_entity_1.ENUM_RESOLUTION_TYPE.MEDIUM.width;
                height = zego_entity_1.ENUM_RESOLUTION_TYPE.MEDIUM.height;
                frameRate = zego_entity_1.ENUM_RESOLUTION_TYPE.MEDIUM.frameRate;
                bitRate = zego_entity_1.ENUM_RESOLUTION_TYPE.MEDIUM.bitRate;
            }
            //3 HD
            else if (mediaStreamConfig.videoQuality === 3) {
                width = zego_entity_1.ENUM_RESOLUTION_TYPE.HIGH.width;
                height = zego_entity_1.ENUM_RESOLUTION_TYPE.HIGH.height;
                frameRate = zego_entity_1.ENUM_RESOLUTION_TYPE.HIGH.frameRate;
                bitRate = zego_entity_1.ENUM_RESOLUTION_TYPE.HIGH.bitRate;
            }
            //custom
            else if (mediaStreamConfig.videoQuality === 4) {
                width = mediaStreamConfig.width;
                height = mediaStreamConfig.height;
                frameRate = mediaStreamConfig.frameRate;
                bitRate =
                    mediaStreamConfig.bitRate ||
                        this.stateCenter.settingConfig.getSetting("camera_video_bitrate");
            }
            else {
                this.logger.info("zp.gmsc.2 use default");
            }
            if (force) {
                mediaStreamConfig.width && (width = mediaStreamConfig.width);
                mediaStreamConfig.height &&
                    (height = mediaStreamConfig.height);
                mediaStreamConfig.frameRate &&
                    (frameRate = mediaStreamConfig.frameRate);
                mediaStreamConfig.bitRate && (bitRate = mediaStreamConfig.bitRate);
            }
            //switch
            if (mediaStreamConfig.horizontal === false) {
                var temp = height;
                height = width;
                width = temp;
            }
            if (mediaStreamConfig.isSwitch === true) {
                var temp = height;
                height = width;
                width = temp;
            }
            mediaStreamConstraints.video = {
                width: width,
                height: height,
                frameRate: frameRate,
                bitRate: bitRate
            };
            //facingMode
            if (mediaStreamConfig.facingMode != undefined) {
                mediaStreamConstraints.video.facingMode = mediaStreamConfig.facingMode;
            }
            else if (mediaStreamConfig.videoInput != undefined &&
                mediaStreamConfig.videoInput != null &&
                mediaStreamConfig.videoInput != "") {
                mediaStreamConstraints.video.deviceId = {
                    exact: mediaStreamConfig.videoInput
                };
            }
            this.logger.info("zp.gmsc.2 width: " +
                width +
                " height: " +
                height +
                " rate: " +
                frameRate);
        }
        else if (mediaStreamConfig.video === false) {
            if (mediaStreamConfig.audioBitrate) {
                mediaStreamConstraints.video = {};
            }
            mediaStreamConstraints.video = false;
        }
        return mediaStreamConstraints;
    };
    /*
     *    "zp.sv.2": "startPreview"
     */
    ZegoPreview.prototype.startPreview = function (mediaStreamConfig, successCallback, errorCallback) {
        return __awaiter(this, void 0, void 0, function () {
            var videoTracks, videoinfo, result, mediaStreamConstraints, _AEC, _AGC, _ANS;
            var _this = this;
            return __generator(this, function (_a) {
                this.logger.debug("zp.sv.2 called");
                this.mediaStreamConfig = mediaStreamConfig;
                if (navigator.mediaDevices === undefined ||
                    navigator.mediaDevices.getUserMedia == undefined) {
                    if (errorCallback) {
                        errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kBrowserNotSupportError);
                    }
                    return [2 /*return*/];
                }
                //自定义视频采集
                if (mediaStreamConfig.source instanceof MediaStream) {
                    videoTracks = mediaStreamConfig.source.getVideoTracks();
                    videoinfo = videoTracks.length > 0
                        ? videoTracks[0].getSettings()
                        : {
                            width: 0,
                            height: 0,
                            frameRate: 0
                        };
                    this.logger.debug("zp.sv.2 use external media stream");
                    this.previewSuc = true;
                    this.localStream = mediaStreamConfig.source;
                    this.initMediaTrack(mediaStreamConfig.source);
                    this.videoInfo = {
                        width: videoinfo.width,
                        height: videoinfo.height,
                        frameRate: videoinfo.frameRate,
                        bitRate: mediaStreamConfig.bitRate ||
                            this.stateCenter.settingConfig.getSetting("custom_video_bitrate"),
                        startBitrate: mediaStreamConfig.startBitrate ||
                            this.stateCenter.settingConfig.getSetting("bitrate_mode"),
                        channelCount: mediaStreamConfig.channelCount ||
                            (this.audioTrack
                                ? this.audioTrack.getSettings
                                    ? //@ts-ignore
                                        this.audioTrack.getSettings().channelCount
                                    : 1
                                : 1),
                        audioBitrate: mediaStreamConfig.audioBitrate * 1e3 || 48000
                    };
                    if (successCallback) {
                        successCallback(this.localStream);
                    }
                    return [2 /*return*/];
                }
                else if (mediaStreamConfig.source instanceof HTMLMediaElement) {
                    result = this.captureStream(mediaStreamConfig.source, mediaStreamConfig);
                    if (result) {
                        this.videoInfo.bitRate =
                            mediaStreamConfig.bitRate ||
                                this.stateCenter.settingConfig.getSetting("custom_video_bitrate");
                        this.previewSuc = true;
                        this.initMediaTrack(result);
                        if (successCallback) {
                            successCallback(result);
                        }
                    }
                    else {
                        if (errorCallback) {
                            errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kBrowserNotSupportError);
                        }
                    }
                    return [2 /*return*/];
                }
                mediaStreamConstraints = this.getMediaStreamConstraints(mediaStreamConfig);
                // 云控
                // 音频3A
                if (mediaStreamConstraints.audio) {
                    _AEC = this.stateCenter.settingConfig.getSetting("AEC", true);
                    _AGC = this.stateCenter.settingConfig.getSetting("AGC", true);
                    _ANS = this.stateCenter.settingConfig.getSetting("ANS", true);
                    if (typeof _AEC == "boolean") {
                        this.logger.info("zp.sv.2 setting AEC " + _AEC);
                        mediaStreamConstraints.audio.echoCancellation = _AEC;
                    }
                    if (typeof _AGC == "boolean") {
                        this.logger.info("zp.sv.2 setting AGC " + _AGC);
                        mediaStreamConstraints.audio.autoGainControl = _AGC;
                    }
                    if (typeof _ANS == "boolean") {
                        this.logger.info("zp.sv.2 setting ANS " + _ANS);
                        mediaStreamConstraints.audio.noiseSuppression = _ANS;
                    }
                }
                // 保存推流相关质量参数
                this.videoInfo = __assign({}, mediaStreamConstraints.video);
                if (this.videoInfo) {
                    this.videoInfo.audioBitrate =
                        mediaStreamConfig.audioBitrate * 1e3 || 48000;
                    this.videoInfo.startBitrate =
                        mediaStreamConfig.startBitrate ||
                            this.stateCenter.settingConfig.getSetting("bitrate_mode");
                }
                else if (mediaStreamConfig.audioBitrate) {
                    this.videoInfo = {
                        audioBitrate: mediaStreamConfig.audioBitrate * 1e3 || 48000
                    };
                }
                this.mediaStreamConfig.video = mediaStreamConstraints.video ? true : false;
                this.mediaStreamConfig.audio = mediaStreamConstraints.audio ? true : false;
                this.logger.info("zp.sv.2 ", JSON.stringify(mediaStreamConstraints));
                // 设置采集最大分辨率
                if (mediaStreamConfig.unlimitedCaptureResolution &&
                    mediaStreamConstraints.video.width) {
                    // 获取可采集最大分辨率
                    mediaStreamConstraints.video.width = { ideal: 4096 };
                    mediaStreamConstraints.video.height = { ideal: 2160 };
                    this.logger.info("zp.sv.2 ", "capture max resolution of camera");
                }
                navigator.mediaDevices.getUserMedia(mediaStreamConstraints).then(function (stream) {
                    _this.logger.info("zp.sv.2 success");
                    //this.localVideo.srcObject = stream;
                    _this.localStream = stream;
                    _this.previewSuc = true;
                    _this.initMediaTrack(stream);
                    if (_this.videoInfo) {
                        _this.videoInfo.channelCount =
                            mediaStreamConfig.channelCount ||
                                (_this.audioTrack
                                    ? _this.audioTrack.getSettings
                                        ? //@ts-ignore
                                            _this.audioTrack.getSettings().channelCount
                                        : 1
                                    : 1);
                    }
                    if (successCallback) {
                        successCallback(stream);
                    }
                }, function (error) {
                    _this.logger.info("zp.sv.2 failed ", error.name, " ", error.message);
                    if (errorCallback) {
                        var throwError = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kGetUserMediaError;
                        throwError.message =
                            throwError.message + " " + error.name + " " + error.message;
                        // 细化采集错误码;
                        if (error.name === "NotAllowedError" ||
                            error.name === "SecurityError") {
                            throwError = __assign({}, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error
                                .kDeviceNoAllowedError);
                            throwError.message = error.name + ": " + throwError.message;
                        }
                        else if (error.name === "NotReadableError") {
                            throwError = __assign({}, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error
                                .kDeviceNoReadableError);
                            throwError.message = error.name + ": " + throwError.message;
                        }
                        else if (error.name === "OverconstrainedError") {
                            throwError = __assign({}, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error
                                .kDeviceOverConstrainedError);
                            throwError.message =
                                error.name +
                                    ": " +
                                    throwError.message +
                                    (error.constraint ? ". such as " + error.constraint : "");
                        }
                        errorCallback(throwError);
                    }
                });
                return [2 /*return*/];
            });
        });
    };
    /*
     *    "zp.cs.2": "captureStream"
     */
    ZegoPreview.prototype.captureStream = function (localVideo, mediaStreamConfig) {
        if (!localVideo) {
            this.logger.info("zp.cs.2 no local video");
            return null;
        }
        var stream;
        if (localVideo["captureStream"]) {
            stream = localVideo["captureStream"]();
            this.logger.debug("zp.cs.2 captureStream");
        }
        else if (localVideo["mozCaptureStream"]) {
            stream = localVideo["mozCaptureStream"]();
            this.logger.debug("zp.cs.2 mozCaptureStream");
        }
        else {
            this.logger.info("zp.cs.2 don't support");
            return null;
        }
        if (stream.getTracks().length == 0) {
            this.logger.error("zp.cs.2 external capture tracks no found");
            return null;
        }
        this.localStream = stream;
        this.videoInfo = {
            width: localVideo["videoWidth"],
            height: localVideo["videoHeight"],
            frameRate: 0,
            bitRate: mediaStreamConfig.bitRate ||
                this.stateCenter.settingConfig.getSetting("custom_video_bitrate"),
            channelCount: mediaStreamConfig.channelCount ||
                (this.audioTrack
                    ? this.audioTrack.getSettings
                        ? //@ts-ignore
                            this.audioTrack.getSettings().channelCount
                        : 1
                    : 1),
            audioBitrate: mediaStreamConfig.audioBitrate * 1e3 || 48000,
            startBitrate: mediaStreamConfig.startBitrate ||
                this.stateCenter.settingConfig.getSetting("bitrate_mode")
        };
        this.logger.debug("zp.cs.2 called success");
        return this.localStream;
    };
    /*
     *    "zp.sv.2.1": "stopPreview"
     */
    ZegoPreview.prototype.stopPreview = function () {
        var _a, _b, _c;
        this.logger.info("zp.sv.2.1 called");
        if (!this.localStream) {
            return;
        }
        if (this.videoEffect) {
            this.videoEffect.setBeautyEffectOptions(false);
            this.videoEffect.destroy();
        }
        (_a = this.originVideoTrack) === null || _a === void 0 ? void 0 : _a.stop();
        (_b = this.videoTrack) === null || _b === void 0 ? void 0 : _b.stop();
        (_c = this.audioTrack) === null || _c === void 0 ? void 0 : _c.stop();
        this.localStream
            .getTracks()
            .reverse()
            .forEach(function (track) { return track.stop(); });
        this.localStream = null;
        this.videoInfo = {};
    };
    /*
     *    "zp.em.2": "enableMicrophone"
     */
    ZegoPreview.prototype.enableMicrophone = function (enable, streamCenter) {
        return false;
    };
    /*
     *    "zp.ec.2": "enableCamera"
     */
    ZegoPreview.prototype.enableCamera = function (enable, streamCenter, retain) {
        return false;
    };
    ZegoPreview.prototype.startSoundLevel = function () {
        var _this = this;
        if (!this.localStream || this.localStream.getAudioTracks().length == 0) {
            return;
        }
        this.script && this.script.disconnect() && (this.script = null);
        this.mic && this.mic.disconnect() && (this.mic = null);
        try {
            this.mic = this.ac.createMediaStreamSource(this.localStream);
            this.script = this.ac.createScriptProcessor(4096, 1, 1); //创建一个音频分析对象，采样的缓冲区大小为4096，输入和输出都是单声道
            this.mic.connect(this.script); //将该分析对象与麦克风音频进行连接
            this.script.connect(this.ac.destination); // 此举没有任何效果，仅仅是因为解决 Chrome 自身的 bug
            this.script.onaudioprocess = function (e) {
                //开始处理音频
                var buffer = e.inputBuffer.getChannelData(0); //获得缓冲区的输入音频，转换为包含了PCM通道数据的32位浮点数组
                //创建变量并迭代来获取最大的音量值
                var maxVal = 0;
                for (var i = 0; i < buffer.length; i++) {
                    if (maxVal < buffer[i]) {
                        maxVal = buffer[i];
                    }
                }
                _this.soundLevel = maxVal * 100;
            };
            this.ac.resume();
        }
        catch (err) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_SOUND_LEVEL +
                " get sound level failed " +
                err);
        }
    };
    ZegoPreview.prototype.stopSoundLevel = function () {
        this.soundLevel = 0;
        this.script && this.script.disconnect();
        this.mic && this.mic.disconnect();
        this.script = null;
        this.mic = null;
    };
    ZegoPreview.prototype.restartSoundLevel = function () {
        if (this.streamCenter.soundLevelDelegate) {
            this.stopSoundLevel();
            this.startSoundLevel();
        }
        else {
            this.stopSoundLevel();
        }
    };
    ZegoPreview.prototype.setBeautyEffect = function (enable, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/];
            });
        });
    };
    /**
     * 替换本地预览流的视轨
     * @param track 新视轨
     * @param isEffectTrack 是否为美颜视轨
     * @returns
     */
    ZegoPreview.prototype.replacePreviewTrack = function (track, isEffectTrack) {
        if (isEffectTrack === void 0) { isEffectTrack = false; }
        return;
    };
    ZegoPreview.prototype.initMediaTrack = function (stream) {
        if (stream.getVideoTracks().length > 0) {
            this.videoTrack = stream.getVideoTracks()[0];
            this.originVideoTrack = this.videoTrack;
        }
        stream.getAudioTracks().length > 0 &&
            (this.audioTrack = stream.getAudioTracks()[0]);
    };
    return ZegoPreview;
}());
exports.ZegoPreview = ZegoPreview;


/***/ }),

/***/ "./sdk/src/webrtc/modules/publishModules/zego.publish.ts":
/*!***************************************************************!*\
  !*** ./sdk/src/webrtc/modules/publishModules/zego.publish.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoPublish = void 0;
var zego_entity_1 = __webpack_require__(/*! ../../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var sdpUtil_1 = __webpack_require__(/*! ../../../util/sdpUtil */ "./sdk/src/util/sdpUtil.ts");
var client_util_1 = __webpack_require__(/*! ../../../util/client-util */ "./sdk/src/util/client-util.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var action_1 = __webpack_require__(/*! ../../../common/action */ "./sdk/src/common/action.ts");
var ZegoPublish = /** @class */ (function () {
    function ZegoPublish(streamId, log, dataReport, qualityTimeInterval, streamCenter, ac, mediaEleSources, stateCenter, localStream) {
        this.state = zego_entity_1.ENUM_PUBLISH_STATE.stop;
        this.sessionId = 0;
        this.sessionToken = "";
        // localVideo = null;
        // localStream = null;
        this.candidateInfo = [];
        this.qualityTimer = null;
        this.publishQualityList = [];
        this.maxQualityListCount = 10;
        this.lastPublishStats = {};
        this.reportSeq = NaN;
        this.streamReportSeq = zego_entity_1.getSeq();
        //quality signal
        this.qualityUpload = false;
        this.qualityUploadInterval = 30 * 1000;
        this.qualityUploadLastTime = 0;
        this.qualitySeq = 0;
        this.videoInfo = {
            width: 0,
            height: 0,
            frameRate: 0,
            bitRate: 0,
            channelCount: 1,
            audioBitrate: 48000
        };
        this.mediaStreamConfig = null;
        this.offerSeq = 0;
        this.audioMixList = [];
        this.arrayBufferMap = {};
        this.effectList = [];
        this.peerConnection = null;
        this.qualityCount = 0;
        this.closeSessionSignal = false;
        // playOption:PlayOption;
        this.channelCount = 1;
        this.localSdpOrder = [];
        this.remoteSdpOrder = [];
        this.videoCodec = "H264";
        this.stateNego = zego_entity_1.ENUM_PUBLISH_STATE_NEGO.stop;
        this.negoInterval = 25000;
        this.publishEvent = false;
        // soundLevel = 0;
        // script: ScriptProcessorNode | null = null;
        // mic: any = null;
        this.cameraState = "on";
        this.microState = "on";
        this.gwNode = "";
        this.gwNodeList = [];
        this.gwNodeTTL = 0;
        //码率调控相关
        this.needIncMax = false;
        this.probeCount = 0;
        this.gotMax = false;
        this.initFitCnt = 0;
        this.targetRate = 0;
        this.totalBitrateArray = [];
        this.totalTargetRateArray = [];
        this.totalRetransRateArray = [];
        //是否开启peer模式
        this.isPeer = false;
        this.peerFailCount = 0;
        //探测相关
        this.peerID = 0;
        this.netQuality = 0;
        this.probeTime = 0;
        this.probeInterval = 60000;
        this.probeState = zego_entity_1.ENUM_PROBE_STATE.probed;
        this.iceDisconnectedMaxTime = 15000;
        this.isUpdateSDP = false;
        // 带替换音视频轨
        this.toBeReplacedTracks = {};
        this.send_seq = 0;
        this.dataChannelState = 0;
        this.first_pkt = true;
        this.next_sn = [];
        this.pkt_list = [];
        this.camera_status = 2;
        this.mic_status = 2;
        this.streamId = streamId;
        this.logger = log;
        this.dataReport = dataReport;
        this.qualityTimeInterval = qualityTimeInterval;
        this.ac = ac;
        this.mediaEleSources = mediaEleSources;
        this.streamCenter = streamCenter;
        this.stateCenter = stateCenter;
        this.dataReport.newReport(this.streamReportSeq);
        this.videoCodec = this.stateCenter.settingConfig.getSetting("publish_video_codec");
        this.localStream = localStream;
    }
    Object.defineProperty(ZegoPublish.prototype, "previewer", {
        /**
         * 推流对应的 ZegoPreview 预览对象
         */
        get: function () {
            return this.streamCenter.checkPreview(this.localStream);
        },
        enumerable: false,
        configurable: true
    });
    ZegoPublish.prototype.publishStateUpdateError = function (error, stopRetry) {
        this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_STATE_ERROR + "  call ", this.streamId, JSON.stringify(error));
        this.streamId &&
            this.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.error, this.streamId, error, stopRetry);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_STATE_ERROR + "  ended");
    };
    ZegoPublish.prototype.resetPublish = function () {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_RESET_PUBLISH +
            "   " +
            this.streamId +
            " call");
        this.state = zego_entity_1.ENUM_PUBLISH_STATE.stop;
        this.publishEvent = false;
        if (this.peerConnection != undefined || this.peerConnection != null) {
            this.peerConnection.close();
            this.peerConnection = null;
        }
        if (this.negoTimer != null) {
            clearTimeout(this.negoTimer);
            this.negoTimer = null;
        }
        if (this.iceDisconnectedTimer != null) {
            clearTimeout(this.iceDisconnectedTimer);
            this.iceDisconnectedTimer = null;
        }
        this.clearPublishQualityTimer();
        if (this.signal) {
            this.signal.unregisterPushCallback("CandidateInfoPush", this.sessionId);
            this.signal.unregisterPushCallback("MediaDescPush", this.sessionId);
            this.signal.unregisterPushCallback("CloseSessionPush", this.sessionId);
            this.signal.unregisterPushCallback("SessionResetPush", this.sessionId);
            this.signal.unregisterPushCallback("PublishEventPush", this.sessionId);
            this.signal.unregisterPushCallback("ClientInfoPush", this.sessionId);
        }
        // this.sessionId = 0;
        this.sessionSeq = 0;
        this.offerSeq = 0;
        this.candidateInfo = [];
        this.publishQualityList = [];
        this.qualityUploadLastTime = 0;
        // 断网停止推流时，不要停止获取本地音浪
        // this.stopSoundLevel();
        this.resetEncBitrate();
        this.isUpdateSDP = false;
    };
    ZegoPublish.prototype.clearPublishQualityTimer = function () {
        if (this.qualityTimer != null) {
            clearInterval(this.qualityTimer);
            this.qualityTimer = null;
        }
        this.lastPublishStats = {};
        this.qualityCount = 0;
        //this.dataReport.uploadReport(this.qualitySeq, "RTCPublishQuality");
    };
    ZegoPublish.prototype.shouldSendCloseSession = function () {
        if (this.state != zego_entity_1.ENUM_PUBLISH_STATE.stop &&
            this.state != zego_entity_1.ENUM_PUBLISH_STATE.waitingSessionRsp) {
            return true;
        }
        return false;
    };
    /*
     *    "zp.sp.0": "ZegoPublish.startPublish"
     */
    ZegoPublish.prototype.startPublish = function (streamId, localStream, videoInfo, mediaStreamConfig, publishOption) {
        var _this = this;
        var _a;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH + " " + streamId + " called");
        this.signal &&
            this.signal.negoInterval &&
            (this.negoInterval = this.signal.negoInterval);
        if (!streamId) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " " +
                streamId +
                " streamId is null");
            return;
        }
        this.localStream = localStream;
        this.mediaStreamConfig = mediaStreamConfig;
        this.channelCount = mediaStreamConfig.channelCount;
        this.publishOption = publishOption || {};
        // firefox循环播放第三方视频时触发
        if (navigator.userAgent.toLowerCase().indexOf("firefox") > -1 &&
            mediaStreamConfig &&
            (mediaStreamConfig.externalCapture ||
                mediaStreamConfig.externalMediaStream)) {
            this.localStream.onaddtrack = function () {
                var _a, _b, _c, _d;
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                    " " +
                    _this.streamId +
                    " Track added");
                // 这里可以换成 previewer 的 videoTrack
                var videoTracks = [];
                ((_a = _this.previewer) === null || _a === void 0 ? void 0 : _a.videoTrack) &&
                    videoTracks.push((_b = _this.previewer) === null || _b === void 0 ? void 0 : _b.videoTrack);
                var audioTracks = _this.localStream.getAudioTracks();
                if (videoTracks.length > 1) {
                    var sender = (_c = _this.peerConnection) === null || _c === void 0 ? void 0 : _c.getSenders().find(function (s) { var _a; return ((_a = s.track) === null || _a === void 0 ? void 0 : _a.kind) === videoTracks[1].kind; });
                    sender === null || sender === void 0 ? void 0 : sender.replaceTrack(videoTracks[1]);
                    _this.localStream.removeTrack(videoTracks[0]);
                }
                else if (audioTracks.length > 1) {
                    var sender = (_d = _this.peerConnection) === null || _d === void 0 ? void 0 : _d.getSenders().find(function (s) { var _a; return ((_a = s.track) === null || _a === void 0 ? void 0 : _a.kind) === audioTracks[1].kind; });
                    sender === null || sender === void 0 ? void 0 : sender.replaceTrack(audioTracks[1]);
                    _this.localStream.removeTrack(audioTracks[0]);
                }
            };
        }
        if (videoInfo) {
            this.videoInfo = videoInfo;
        }
        if (publishOption && publishOption.videoCodec) {
            this.videoCodec = publishOption.videoCodec;
        }
        var _vBitrate;
        var previewType = (_a = this.previewer) === null || _a === void 0 ? void 0 : _a.previewType;
        switch (previewType) {
            case "camera":
                _vBitrate = this.stateCenter.settingConfig.getSetting("camera_video_bitrate", true);
                break;
            case "screen":
                _vBitrate = this.stateCenter.settingConfig.getSetting("screen_video_bitrate", true);
                break;
            case "custom":
                _vBitrate = this.stateCenter.settingConfig.getSetting("custom_video_bitrate", true);
                break;
            default:
                break;
        }
        if (_vBitrate) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " setting " +
                previewType +
                " " +
                _vBitrate);
            this.videoInfo.bitRate = _vBitrate;
        }
        var _startBitrate = this.stateCenter.settingConfig.getSetting("bitrate_mode", true);
        if (_startBitrate) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " setting bitrate_mode " +
                _startBitrate);
            this.videoInfo.startBitrate = _startBitrate;
        }
        var _videoCodec = this.stateCenter.settingConfig.getSetting("publish_video_codec", true);
        if (_videoCodec) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " setting publish_video_codec " +
                _videoCodec);
            this.videoCodec = _videoCodec;
        }
        //上报视频编码格式
        this.dataReport.addMsgInfo(this.reportSeq, {
            video_en_codec_id: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.video_en_codec_id(this.videoCodec == "VP8" ? 2 : 0),
            audio_c_channel_count: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.audio_c_channel_count(this.channelCount == 2 ? 2 : 1),
            audio_en_bps: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.audio_en_bps(this.videoInfo.audioBitrate),
            aec_level: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.aec_level(mediaStreamConfig.AEC == true
                ? 2
                : mediaStreamConfig.AEC == false
                    ? 0
                    : 2),
            ans_level: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.ans_level(mediaStreamConfig.ANS == true
                ? 2
                : mediaStreamConfig.ANS == false
                    ? 0
                    : 2),
            agc: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.agc(mediaStreamConfig.AGC == true
                ? 2
                : mediaStreamConfig.AGC == false
                    ? 0
                    : 2),
            traffic_control_min_video_bitrate: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.traffic_control_min_video_bitrate(this.videoInfo.bitRate)
        });
        this.isPeer ? this.createOffer() : this.createSession();
        // 下面的代码，在服务器没有返回任何错误码，且协商不成功时才会回调
        this.negoTimer = setTimeout(function () {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH + " waiting timeout");
            _this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishNegoTimeoutError);
        }, this.negoInterval);
    };
    ZegoPublish.prototype.activateSEIInsert = function (action, infoType) {
        return new Promise(function (resolve, reject) {
            resolve(false);
        });
    };
    ZegoPublish.prototype.createSession = function (desc) {
        var _this = this;
        //send to server
        this.sessionSeq = zego_entity_1.getSeq();
        var totalStreamId = this.streamId;
        if (this.streamCenter.testEnvironment == true) {
            totalStreamId =
                "zegotest-" + this.streamCenter.appid + "-" + this.streamId;
        }
        // 云控
        var gwNodes = this.stateCenter.settingConfig.getSetting("gw_nodes");
        if (gwNodes && gwNodes instanceof Array && gwNodes.length > 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " setting " +
                JSON.stringify(gwNodes));
            this.gwNodeList = gwNodes;
            this.gwNode = this.gwNodeList[0] || this.gwNode;
        }
        if (this.isPeer) {
            this.dataReport.eventStart(this.reportSeq, "CreateSessionWithSdp");
            this.dataReport.eventStart(this.streamReportSeq, "CreateSessionWithSdp");
            this.signal.createSessionWithSdp({
                seq: this.sessionSeq,
                type: 0,
                mode: 0,
                streamId: totalStreamId,
                videoInfo: this.videoInfo,
                strAuthParam: this.publishOption
                    ? this.publishOption.streamParams || ""
                    : "",
                sdp: desc.sdp,
                serverHost: this.gwNode
            }, function (seq, sessionID, msg) {
                _this.handleCreateSessionWithSdpResp(seq, sessionID, msg);
            }, function (err, seq) {
                _this.dataReport.eventEndWithMsg(_this.reportSeq, "CreateSession", {
                    error: err
                });
                _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "CreateSession", {
                    error: err
                });
                //后台网关若不支持peer模式则改用老模式
                if (err == zego_entity_1.SEND_MSG_TIMEOUT && _this.peerFailCount < 2) {
                    _this.peerFailCount++;
                    _this.createSession(desc);
                }
                else if (err == zego_entity_1.SEND_MSG_TIMEOUT && _this.peerFailCount >= 2) {
                    _this.isPeer = false;
                    _this.streamCenter.isPeer = false;
                    _this.createSession();
                }
                else {
                    _this.publishStateUpdateError(err == zego_entity_1.SEND_MSG_TIMEOUT
                        ? zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error
                            .kSessionTimeoutError
                        : zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error
                            .kSessionRequestError);
                }
            });
        }
        else {
            this.dataReport.eventStart(this.reportSeq, "CreateSession");
            this.dataReport.eventStart(this.streamReportSeq, "CreateSession");
            this.signal.createSession(this.sessionSeq, 0, 0, totalStreamId, this.publishOption && this.publishOption.streamParams, this.gwNode, function (seq, sessionId, msg) {
                _this.handleCreateSessionResp(seq, sessionId, msg);
            }, function (err, seq) {
                _this.reportSeq;
                _this.dataReport.eventEndWithMsg(_this.reportSeq, "CreateSession", {
                    error: err
                });
                _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "CreateSession", {
                    error: err
                });
                _this.publishStateUpdateError(err == zego_entity_1.SEND_MSG_TIMEOUT
                    ? zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kSessionTimeoutError
                    : zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kSessionRequestError);
            });
        }
        this.state = zego_entity_1.ENUM_PUBLISH_STATE.waitingSessionRsp;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
            " " +
            this.streamId +
            " called success");
        this.stateNego = zego_entity_1.ENUM_PUBLISH_STATE_NEGO.start;
    };
    ZegoPublish.prototype.handleCreateSessionResp = function (seq, sessionID, msg) {
        var turnServer = msg.turn_server;
        var ip = turnServer.split("?")[0] && turnServer.split("?")[0].slice(5);
        var serverArr = this.streamCenter.server.split("?");
        var app = serverArr[1] && serverArr[1].slice(2);
        this.dataReport.eventEndWithMsg(this.streamReportSeq, "CreateSession", {
            sessionId: msg.session_id,
            url: "webrtc://" + ip + "/" + app + "/" + this.streamId
        });
        this.dataReport.eventEndWithMsg(this.reportSeq, "CreateSession", {
            sessionId: msg.session_id,
            url: "webrtc://" + ip + "/" + app + "/" + this.streamId
        });
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
            " " +
            this.streamId +
            " sessionId:" +
            msg.session_id);
        if (this.sessionSeq != seq) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " " +
                this.streamId +
                " seq is not match.");
            return;
        }
        this.gwNodeList =
            msg.gw_nodes && msg.gw_nodes.length > 0 ? msg.gw_nodes : this.gwNodeList;
        this.gwNode =
            msg.gw_nodes && msg.gw_nodes.length > 0
                ? this.gwNodeList[0]
                : this.gwNode;
        this.gwNodeTTL = msg.gw_nodes_ttl
            ? new Date().getTime() + msg.gw_nodes_ttl * 1000
            : this.gwNodeTTL;
        this.stateCenter.clientIP = msg.clientip
            ? msg.clientip
            : this.stateCenter.clientIP;
        if (msg.result !== 0) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " " +
                this.streamId +
                " create session failed " +
                msg.result);
            this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kSessionRequestError);
        }
        else {
            this.sessionId = msg.session_id;
            this.sessionToken = msg.session_token;
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " " +
                this.streamId +
                " create session success " +
                this.sessionId);
            this.dataReport.addMsgInfo(this.reportSeq, {
                session_id: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.session_id(this.sessionId)
            });
            this.onCreatePublishSessionSuccess(msg);
        }
    };
    ZegoPublish.prototype.handleCreateSessionWithSdpResp = function (seq, sessionID, msg) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH + " sessionId:" + sessionID);
        if (this.sessionSeq != seq) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH + " seq is not match.");
            return;
        }
        this.gwNodeList =
            msg.gw_nodes && msg.gw_nodes.length > 0 ? msg.gw_nodes : this.gwNodeList;
        this.gwNode =
            msg.gw_nodes && msg.gw_nodes.length > 0
                ? this.gwNodeList[0]
                : this.gwNode;
        this.gwNodeTTL = msg.gw_nodes_ttl
            ? new Date().getTime() + msg.gw_nodes_ttl * 1000
            : this.gwNodeTTL;
        this.stateCenter.clientIP = msg.clientip
            ? msg.clientip
            : this.stateCenter.clientIP;
        this.dataReport.eventEndWithMsg(this.streamReportSeq, "CreateSessionWithSdp", {
            sessionId: sessionID
        });
        this.dataReport.eventEndWithMsg(this.reportSeq, "CreateSessionWithSdp", {
            sessionId: sessionID
        });
        if (msg.result !== 0) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " create session failed " +
                msg.result);
            this.publishStateUpdateError({
                code: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kSessionRequestError.code,
                message: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kSessionRequestError
                    .message +
                    " result:" +
                    msg.result
            });
        }
        else {
            this.sessionId = sessionID;
            this.sessionToken = msg.session_token;
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " get remote session success " +
                this.streamId);
            //register callback
            this.signal.registerPushCallback("CloseSessionPush", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvCloseSession(seq, sessionId, data);
            });
            // this.signal.registerPushCallback("WebSocketDisconnect", this.sessionId, onDisconnect, this);
            this.signal.registerPushCallback("SessionResetPush", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvResetSession(seq, sessionId, data);
            });
            this.signal.registerPushCallback("PublishEventPush", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvPublishEvent(seq, sessionId, data);
            });
            this.signal.registerPushCallback("ClientInfoPush", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvClientInfo(seq, sessionId, data);
            });
            this.signal.registerPushCallback("MediaDescUpdatePush", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvUpdateMediaDescription(seq, sessionId, data);
            });
            this.onGetRemoteOfferSuccess(msg.sdp);
        }
    };
    ZegoPublish.prototype.onCreatePublishSessionSuccess = function (data) {
        var _this = this;
        //create offer
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
            " " +
            this.streamId +
            " called");
        // this.state = ENUM_PUBLISH_STATE.Start;
        var urls = [];
        if (data.turn_server) {
            var turnServer = data.turn_server;
            var _turnToTcp = this.stateCenter.turnOverTcpOnly;
            var udpOrTcp = this.stateCenter.settingConfig.getSetting("udp_or_tcp", true);
            if (udpOrTcp) {
                this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
                    " setting udp_or_tcp " +
                    udpOrTcp);
                _turnToTcp = udpOrTcp === "tcp";
            }
            _turnToTcp && (turnServer = turnServer.replace("udp", "tcp"));
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
                " over tcp " +
                turnServer);
            urls.push(turnServer);
        }
        if (data.stun_server)
            urls.push(data.stun_server);
        var configuration = {
            iceTransportPolicy: "relay",
            iceServers: [
                {
                    urls: urls,
                    username: data.turn_username,
                    credential: data.turn_auth_key
                }
            ]
        };
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
            " " +
            this.streamId +
            " username: " +
            data.turn_username);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
            " " +
            this.streamId +
            " credential: " +
            data.turn_auth_key);
        this.createOffer(configuration);
        //register callback
        this.signal.registerPushCallback("CandidateInfoPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvCandidateInfo(seq, sessionId, data);
        });
        this.signal.registerPushCallback("CloseSessionPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvCloseSession(seq, sessionId, data);
        });
        this.signal.registerPushCallback("MediaDescPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvMediaDescription(seq, sessionId, data);
        });
        // this.signal.registerPushCallback("WebSocketDisconnect", this.sessionId, onDisconnect, this);
        this.signal.registerPushCallback("SessionResetPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvResetSession(seq, sessionId, data);
        });
        this.signal.registerPushCallback("PublishEventPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvPublishEvent(seq, sessionId, data);
        });
        this.signal.registerPushCallback("ClientInfoPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvClientInfo(seq, sessionId, data);
        });
        this.signal.registerPushCallback("MediaDescUpdatePush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvUpdateMediaDescription(seq, sessionId, data);
        });
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
            " " +
            this.streamId +
            " call success");
    };
    ZegoPublish.prototype.createOffer = function (configuration) {
        var _this = this;
        var _a, _b;
        this.peerConnection = new RTCPeerConnection(configuration);
        this.peerConnection.onicecandidate = function (e) {
            _this.onIceCandidate(e);
        };
        this.peerConnection.onsignalingstatechange = function (e) {
            _this.onConnectionStateChange(e);
        };
        this.peerConnection.oniceconnectionstatechange = function (e) {
            _this.onIceConnectionStateChange(e);
        };
        //默认不开启 datachannel
        if (this.streamCenter.isDataChannelEnabled) {
            this.dataChannel = this.peerConnection.createDataChannel(this.streamId);
            this.dataChannel.binaryType = "arraybuffer";
            this.dataChannel.onopen = function (event) {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
                    " " +
                    _this.streamId +
                    " data channel open");
                _this.dataChannelState = 1;
            };
            this.dataChannel.onclose = function (event) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
                    " " +
                    _this.streamId +
                    " data channel close ");
            };
        }
        var videoTracks = [];
        var audioTracks = [];
        if (this.localStream) {
            this.localStream.getTracks().forEach(function (track) {
                var _a;
                // if(track.kind === 'audio'){
                //         // @ts-ignore
                //         track.applyConstraints({noiseSuppression:{exact:true}})
                // }
                (_a = _this.peerConnection) === null || _a === void 0 ? void 0 : _a.addTrack(track, _this.localStream);
            });
            // 这里可以换成 previewer 的 videoTrack
            ((_a = this.previewer) === null || _a === void 0 ? void 0 : _a.videoTrack) &&
                (videoTracks = [(_b = this.previewer) === null || _b === void 0 ? void 0 : _b.videoTrack]);
            audioTracks = this.localStream.getAudioTracks();
            if (videoTracks.length > 0)
                this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
                    " " +
                    this.streamId +
                    " video device: " +
                    videoTracks[0].label);
            if (audioTracks.length > 0)
                this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
                    " " +
                    this.streamId +
                    " audio device: " +
                    audioTracks[0].label);
        }
        var offerOptions = {
            // @ts-ignore
            offerToReceiveAudio: audioTracks.length > 0 ? 1 : 0,
            // @ts-ignore
            offerToReceiveVideo: videoTracks.length > 0 ? 1 : 0
        };
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
            " " +
            this.streamId +
            " createOffer: " +
            JSON.stringify(offerOptions));
        //create offer
        this.dataReport.eventStart(this.reportSeq, "CreateOffer");
        this.dataReport.eventStart(this.streamReportSeq, "CreateOffer");
        this.peerConnection.createOffer(offerOptions).then(function (desc) {
            _this.dataReport.eventEnd(_this.reportSeq, "CreateOffer");
            _this.dataReport.eventEnd(_this.streamReportSeq, "CreateOffer");
            _this.onCreateOfferSuccess(desc);
        }, function (error) {
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "CreateOffer", {
                error: error.toString()
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "CreateOffer", {
                error: error.toString()
            });
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
                " " +
                _this.streamId +
                " create offer error " +
                error.toString());
            _this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kCreateOfferError, true);
        });
    };
    ZegoPublish.prototype.onCreateOfferSuccess = function (desc, isUpdate, videoInfo, callBack) {
        var _this = this;
        var _a;
        if (isUpdate) {
            this.isUpdateSDP = true;
            callBack && (this.updateSDPCallBack = callBack);
        }
        //change bandwidth
        if (this.videoInfo.bitRate > 0)
            desc.sdp = this.updateBandwidthRestriction(desc.sdp, this.videoInfo.bitRate);
        desc.sdp = desc.sdp.replace(/sendrecv/g, "sendonly");
        var dataChannelSdp = desc.sdp.match(/m=application[\s\S]+datachannel[\s\S]+/)
            ? desc.sdp.match(/m=application[\s\S]+datachannel[\s\S]+/)[0]
            : null;
        if (dataChannelSdp) {
            var newDataChannelSdp = dataChannelSdp.replace(/sendonly/, "sendrecv");
            desc.sdp = desc.sdp.replace(dataChannelSdp, newDataChannelSdp);
        }
        desc.sdp = desc.sdp.replace(/useinbandfec=\d+/, (this.videoInfo.audioBitrate
            ? "maxaveragebitrate=" + this.videoInfo.audioBitrate
            : "") + (this.videoInfo.channelCount === 2 ? ";stereo=1" : ""));
        // 部分浏览器 m-line 顺序不同，需要特殊处理
        this.localSdpOrder = desc.sdp.match(/m=(.\w*)\s/g) || [];
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_OFFER_SUCCESS +
            " " +
            this.streamId +
            " local sdp revert " +
            this.localSdpOrder.join(""));
        // desc.sdp = sdpUtil.zegoSdp(desc.sdp);
        desc.sdp = sdpUtil_1.SdpUtil.getSDPByVideDecodeType(desc.sdp, this.videoCodec, true);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_OFFER_SUCCESS +
            " " +
            this.streamId +
            " localSdp1 " +
            desc.sdp.substr(0, desc.sdp.length / 2));
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_OFFER_SUCCESS +
            " " +
            this.streamId +
            " localSdp2 " +
            desc.sdp.substr(desc.sdp.length / 2));
        this.dataReport.eventStart(this.reportSeq, "SetLocalDescription");
        this.dataReport.eventStart(this.streamReportSeq, "SetLocalDescription");
        (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.setLocalDescription(desc).then(function () {
            _this.dataReport.eventEnd(_this.reportSeq, "SetLocalDescription");
            _this.dataReport.eventEnd(_this.streamReportSeq, "SetLocalDescription");
            _this.onSetLocalDescriptionSuccess(desc, videoInfo);
        }, function (error) {
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "SetLocalDescription", {
                error: error.toString()
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "SetLocalDescription", {
                error: error.toString()
            });
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_OFFER_SUCCESS +
                " " +
                _this.streamId +
                " error " +
                error.toString());
            _this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kSetLocalDescError, true);
        });
    };
    ZegoPublish.prototype.updateBandwidthRestriction = function (sdp, bandwidth) {
        var modifier = "AS";
        if (this.stateCenter.browser === "firefox") {
            bandwidth = (bandwidth >>> 0) * 1000;
            modifier = "TIAS";
        }
        if (sdp.indexOf("b=" + modifier + ":") === -1) {
            // insert b= after c= line.
            sdp = sdp.replace(/(m=video.*\r\nc=IN.*\r\n)/g, "$1b=" + modifier + ":" + bandwidth + "\r\n");
        }
        else {
            // TODO: createOffer 得到的 sdp 所限制的码率 b=AS: 的位置不确定，不能针对性的修改视频的最大码率。当前得到的sdp第一个的为音频，第二个为视频。这样判断可以删掉第一个对音频码率限制
            sdp = sdp.replace(new RegExp("b=" + modifier + ":.*\r\n", "g"), "b=" + modifier + ":" + bandwidth + "\r\n");
            sdp = sdp.replace("b=" + modifier + ":" + bandwidth + "\r\n", "");
        }
        return sdp;
    };
    ZegoPublish.prototype.onSetLocalDescriptionSuccess = function (desc, videoInfo) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
            " " +
            this.streamId +
            " success");
        !this.isUpdateSDP && (this.state = zego_entity_1.ENUM_PUBLISH_STATE.waitingOfferRsp);
        if (videoInfo)
            this.videoInfo = __assign(__assign({}, this.videoInfo), videoInfo);
        //send offer to other peer
        var mediaDescription = {
            sdp: desc.sdp,
            width: this.videoInfo.width,
            height: this.videoInfo.height,
            frameRate: this.videoInfo.frameRate,
            video_min_kpbs: this.videoInfo.bitRate,
            video_max_kpbs: this.videoInfo.bitRate,
            audio_kpbs: 48,
            keyframe_intv: 2
        };
        this.offerSeq = zego_entity_1.getSeq();
        //更新 sdp
        if (this.isUpdateSDP) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
                " " +
                this.streamId +
                " update sdp");
            var updateMediaDescription = __assign(__assign({}, mediaDescription), { seq: this.sessionSeq, peerID: this.peerID, type: 0 });
            this.dataReport.eventStart(this.reportSeq, "SendMediaDescUpdate");
            this.dataReport.eventStart(this.streamReportSeq, "SendMediaDescUpdate");
            this.signal.sendMediaDescUpdateReq(this.offerSeq, this.sessionId, updateMediaDescription, function (seq, sessionID, msg) { }, function (err, seq) {
                _this.dataReport.eventEndWithMsg(_this.reportSeq, "SendMediaDescUpdate", {
                    error: err
                });
                _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "SendMediaDescUpdate", {
                    error: err
                });
                _this.updateSDPCallBack && _this.updateSDPCallBack(-1);
                _this.publishStateUpdateError(err == zego_entity_1.SEND_MSG_TIMEOUT
                    ? zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error
                        .kUpdateMediaDescriptionTimeOut
                    : zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error
                        .kUpdateMediaDescriptionError);
            });
            return;
        }
        if (this.isPeer) {
            this.createSession(desc);
            return;
        }
        this.dataReport.eventStart(this.reportSeq, "SendMediaDesc");
        this.dataReport.eventStart(this.streamReportSeq, "SendMediaDesc");
        this.signal.sendMediaDesc(this.offerSeq, this.sessionId, 0, mediaDescription, function (seq, sessionId, data) {
            if (_this.offerSeq != seq || _this.sessionId != sessionId) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
                    " " +
                    _this.streamId +
                    " seq or sessionId is not equal");
                return;
            }
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
                " " +
                _this.streamId +
                " send success");
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "SendMediaDesc", {
                mediaDescription: {
                    width: mediaDescription.width,
                    height: mediaDescription.height,
                    frameRate: mediaDescription.frameRate,
                    video_min_kpbs: mediaDescription.video_min_kpbs,
                    video_max_kpbs: mediaDescription.video_max_kpbs,
                    audio_kpbs: mediaDescription.audio_kpbs,
                    keyframe_intv: mediaDescription.keyframe_intv
                }
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "SendMediaDesc", {
                mediaDescription: {
                    width: mediaDescription.width,
                    height: mediaDescription.height,
                    frameRate: mediaDescription.frameRate,
                    video_min_kpbs: mediaDescription.video_min_kpbs,
                    video_max_kpbs: mediaDescription.video_max_kpbs,
                    audio_kpbs: mediaDescription.audio_kpbs,
                    keyframe_intv: mediaDescription.keyframe_intv
                }
            });
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
                " " +
                _this.streamId +
                " send success stateNego:waiterAnswer");
            _this.stateNego = zego_entity_1.ENUM_PUBLISH_STATE_NEGO.waiterAnswer;
            _this.state = zego_entity_1.ENUM_PUBLISH_STATE.waitingServerAnswer;
        }, function (err, seq) {
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "SendMediaDesc", {
                error: err
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "SendMediaDesc", {
                error: err
            });
            _this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kMediaDescError);
        });
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
            " " +
            this.streamId +
            " call success");
    };
    ZegoPublish.prototype.onRecvUpdateMediaDescription = function (seq, sessionId, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_UPDATE_MEDIA_DESC +
            " " +
            this.streamId +
            " received");
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_UPDATE_MEDIA_DESC +
            " " +
            this.streamId +
            " received stateNego:waitingCandidate");
        this.dataReport.addEvent(this.reportSeq, "RecvUpdateMediaDesc");
        this.dataReport.addEvent(this.streamReportSeq, "RecvUpdateMediaDesc");
        this.signal.sendUpdateMediaDescAck(seq, this.sessionId, 0, this.peerID);
        //not answer
        if (data.type == 1) {
            this.onGetRemoteOfferSuccess(data.sdp);
        }
        else {
            //server send error
            this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kMediaDescError);
        }
    };
    ZegoPublish.prototype.onRecvMediaDescription = function (seq, sessionId, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_MEDIA_DESC +
            " " +
            this.streamId +
            " received");
        if (this.state != zego_entity_1.ENUM_PUBLISH_STATE.waitingServerAnswer) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_MEDIA_DESC +
                " " +
                this.streamId +
                " current state " +
                this.state +
                " not allowed");
            return;
        }
        this.stateNego = zego_entity_1.ENUM_PUBLISH_STATE_NEGO.waitingCandidate;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_MEDIA_DESC +
            " " +
            this.streamId +
            " received stateNego:waitingCandidate");
        this.dataReport.addEvent(this.reportSeq, "RecvMediaDesc");
        this.dataReport.addEvent(this.streamReportSeq, "RecvMediaDesc");
        this.signal.sendMediaDescAck(seq, this.sessionId, 0);
        //not answer
        if (data.type == 1) {
            this.onGetRemoteOfferSuccess(data.sdp);
        }
        else {
            //server send error
            this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kMediaDescError);
        }
    };
    ZegoPublish.prototype.onGetRemoteOfferSuccess = function (desc) {
        var _this = this;
        var _a, _b, _c, _d, _e, _f;
        if (this.videoInfo.audioBitrate && this.videoInfo.audioBitrate !== 48000) {
            desc = desc.replace(/maxaveragebitrate=(\d+)/, "maxaveragebitrate=" + this.videoInfo.audioBitrate);
        }
        // 部分浏览器 m行顺序不一致---这里做一下特殊处理
        this.remoteSdpOrder = desc.match(/m=(.\w*)\s/g) || [];
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_GET_REMOTE_DESCRIPTION +
            " " +
            this.streamId +
            +" sdp revert " +
            this.remoteSdpOrder.join(""));
        var _turnToTcp = this.stateCenter.turnOverTcpOnly;
        var udpOrTcp = this.stateCenter.settingConfig.getSetting("udp_or_tcp", true);
        if (udpOrTcp) {
            this.logger.info("zp.oro.0 setting udp_or_tcp " + udpOrTcp);
            _turnToTcp = udpOrTcp === "tcp";
        }
        if (_turnToTcp) {
            (_a = desc.match(/candidate.*/g)) === null || _a === void 0 ? void 0 : _a.forEach(function (candStr) {
                var repCandStr = candStr.replace(/udp/, "tcp");
                desc = desc.replace(candStr, repCandStr);
            });
        }
        this.logger.info("zp.oro.0 " +
            this.streamId +
            " sdp revert " +
            this.localSdpOrder.join("") +
            " " +
            this.remoteSdpOrder.join(""));
        if (this.localSdpOrder.join() !== this.remoteSdpOrder.join() &&
            this.localSdpOrder.length == this.remoteSdpOrder.length) {
            var headerSdp = new RegExp("[\\s\\S]*" + this.remoteSdpOrder[0])
                .exec(desc)[0]
                .replace(this.remoteSdpOrder[0], "");
            var midOrder_1 = [];
            var sdp_1 = "";
            this.localSdpOrder.forEach(function (m) {
                var _index = _this.remoteSdpOrder.findIndex(function (_m) { return _m == m; });
                var mSdp = new RegExp(m + "[\\s\\S]*" + (_this.remoteSdpOrder[_index + 1] || ""))
                    .exec(desc)[0]
                    .replace(_this.remoteSdpOrder[_index + 1], "");
                var mid = /a=mid:(\w)/.exec(mSdp)[1];
                midOrder_1.push(mid);
                sdp_1 = sdp_1 + (mSdp || "");
            });
            desc =
                headerSdp.replace(/a=group:BUNDLE.*/, "a=group:BUNDLE " + midOrder_1.join(" ")) + sdp_1;
            this.localSdpOrder = [];
            this.remoteSdpOrder = [];
        }
        var video_fmtp = desc.match(/m=video(.|\r|\n)*a=rtpmap(.|\r|\n)*(a=fmtp:(\d+).*)/);
        // 设置起始码率，默认起始码率由小变大
        if (this.stateCenter.browser == "chrome") {
            var startBitrate = 0;
            if (this.videoInfo.bitRate && this.videoInfo.startBitrate === "target") {
                startBitrate = this.videoInfo.bitRate;
            }
            if (video_fmtp !== null && startBitrate) {
                var fmtp = video_fmtp[3];
                if (fmtp.indexOf("apt=") !== -1) {
                    desc = desc.replace(fmtp, "a=fmtp:96 x-google-start-bitrate=" + startBitrate + "\n" + fmtp);
                }
                else {
                    desc = desc.replace(fmtp, fmtp + ";x-google-start-bitrate=" + startBitrate);
                }
            }
        }
        // 限制最大码率为目标码率
        if (this.videoInfo.bitRate > 0) {
            // peer模式下，网关不返回AS参数，需要SDK补充AS参数来设定目标码率
            var hasAS = /b=AS.*(\r\n|\n)/.test(desc);
            if (hasAS) {
                desc = desc.replace(/AS:(\d+)/, "AS:" + this.videoInfo.bitRate);
            }
            else {
                desc = desc.replace(/m=video.*(\r\n|\n)c=.*(\r\n|\n)/, "$&b=AS:" + this.videoInfo.bitRate + "\n");
            }
            var videoSender = (_b = this.peerConnection) === null || _b === void 0 ? void 0 : _b.getSenders().find(function (s) { return s.track && s.track.kind === "video"; });
            if (videoSender &&
                videoSender.getParameters &&
                videoSender.setParameters) {
                var parameters = videoSender.getParameters();
                if (!parameters.encodings || parameters.encodings.length == 0) {
                    parameters.encodings = [{}];
                }
                // 设置最大码率
                parameters.encodings[0].maxBitrate = this.videoInfo.bitRate * 1e3;
                // 设置分辨率
                // 采集最大帧率的时候，当前的真正的编码帧率。 当 googBandwidthLimitedResolution 为 true的时候，编码帧率有可能会降低，因此编码分辨率降低的倍数也要减少。
                var encodeWidth = this.lastPublishStats.frameWidth;
                var maxWidth = ((_d = (_c = this.previewer) === null || _c === void 0 ? void 0 : _c.cameraMaxResolution) === null || _d === void 0 ? void 0 : _d.maxWidth) || 0;
                var targetWidth = (_e = this.previewer) === null || _e === void 0 ? void 0 : _e.videoInfo.width;
                var realMaxEncodeWidth = encodeWidth
                    ? Math.min(maxWidth, encodeWidth)
                    : maxWidth;
                if (maxWidth && targetWidth) {
                    // 降低的倍数，参数不能 < 1，设置为1则不变。
                    var downBy = Math.max(realMaxEncodeWidth / targetWidth, 1);
                    // 将编码分辨率降低的倍数:  目前最大的编码分辨率 / 目标分辨率。
                    parameters.encodings[0].scaleResolutionDownBy = downBy;
                }
                videoSender.setParameters(parameters);
            }
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_GET_REMOTE_DESCRIPTION +
            " " +
            this.streamId +
            " remoteSdp:", desc);
        var answerDescription = {
            type: "answer",
            sdp: desc,
            toJSON: function () { }
        };
        this.dataReport.eventStart(this.reportSeq, "SetRemoteDescription");
        this.dataReport.eventStart(this.streamReportSeq, "SetRemoteDescription");
        (_f = this.peerConnection) === null || _f === void 0 ? void 0 : _f.setRemoteDescription(new RTCSessionDescription(answerDescription)).then(function () {
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_GET_REMOTE_DESCRIPTION +
                " " +
                _this.streamId +
                " set success");
            _this.dataReport.eventEnd(_this.reportSeq, "SetRemoteDescription");
            _this.dataReport.eventEnd(_this.streamReportSeq, "SetRemoteDescription");
            if (_this.stateNego == zego_entity_1.ENUM_PUBLISH_STATE_NEGO.iceConnected &&
                _this.updateSDPCallBack) {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_GET_REMOTE_DESCRIPTION +
                    " " +
                    _this.streamId +
                    " update sdp success");
                _this.updateSDPCallBack(0);
                _this.updateSDPCallBack = undefined;
                _this.isUpdateSDP = false;
            }
        }, function (error) {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_GET_REMOTE_DESCRIPTION +
                " " +
                _this.streamId +
                " failed: " +
                error.toString());
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "SetRemoteDescription", {
                error: error.toString()
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "SetRemoteDescription", {
                error: error.toString()
            });
            _this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kSetRemoteDescError, true);
        });
        this.state = zego_entity_1.ENUM_PUBLISH_STATE.waitingServerICE;
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_GET_REMOTE_DESCRIPTION +
            " " +
            this.streamId +
            " call success");
    };
    ZegoPublish.prototype.onIceConnectionStateChange = function (event) {
        var _this = this;
        if (this.state == zego_entity_1.ENUM_PUBLISH_STATE.stop || this.peerConnection == null) {
            return;
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_ICE_CONNECTION_STATE_CHANGE +
            " " +
            this.streamId +
            " stateChanged " +
            this.peerConnection.iceConnectionState);
        if (this.peerConnection.iceConnectionState === "connected") {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_ICE_CONNECTION_STATE_CHANGE +
                " " +
                this.streamId +
                " connected state " +
                this.state);
            this.dataReport.eventEnd(this.reportSeq, "IceConnected");
            this.dataReport.eventEnd(this.streamReportSeq, "IceConnected");
            this.stateNego = zego_entity_1.ENUM_PUBLISH_STATE_NEGO.iceConnected;
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_ICE_CONNECTION_STATE_CHANGE +
                " " +
                this.streamId +
                " stateNego:iceConnected");
            if (this.negoTimer) {
                clearTimeout(this.negoTimer);
                this.negoTimer = null;
            }
            if (this.iceDisconnectedTimer != null) {
                clearTimeout(this.iceDisconnectedTimer);
                this.iceDisconnectedTimer = null;
            }
            if (this.publishEvent) {
                this.publishSuccess();
            }
            else {
                this.firstGetStatsTimer && clearTimeout(this.firstGetStatsTimer);
                this.firstGetStatsTimer = null;
                this.firstGetStatsTimer = setTimeout(function () {
                    var _a;
                    _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_ICE_CONNECTION_STATE_CHANGE +
                        " get first stats state " +
                        _this.state);
                    if (_this.state !== zego_entity_1.ENUM_PUBLISH_STATE.publishing) {
                        (_a = _this.peerConnection) === null || _a === void 0 ? void 0 : _a.getStats().then(function (results) {
                            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_ICE_CONNECTION_STATE_CHANGE +
                                " get first stats suc");
                            if (results.size > 0)
                                _this.publishSuccess();
                        });
                    }
                }, 1000);
            }
        }
        else if (this.peerConnection.iceConnectionState === "closed") {
            this.dataReport.addEvent(this.reportSeq, "IceClosed");
            this.stateNego = zego_entity_1.ENUM_PUBLISH_STATE_NEGO.iceClosed;
            this.checkPublishConnectionFailedState(this.peerConnection.iceConnectionState);
        }
        else if (this.peerConnection.iceConnectionState === "failed") {
            this.dataReport.addEvent(this.reportSeq, "IceFailed");
            this.stateNego = zego_entity_1.ENUM_PUBLISH_STATE_NEGO.iceFailed;
            this.checkPublishConnectionFailedState(this.peerConnection.iceConnectionState);
        }
        else if (this.peerConnection.iceConnectionState === "disconnected") {
            this.dataReport.addEvent(this.reportSeq, "IceDisconnected");
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_ICE_CONNECTION_STATE_CHANGE +
                " ice disconnected ");
            this.stateNego = zego_entity_1.ENUM_PUBLISH_STATE_NEGO.iceDisconnected;
            if (!this.iceDisconnectedTimer) {
                this.iceDisconnectedTimer = setTimeout(function () {
                    _this.checkPublishConnectionFailedState("disconnected");
                }, this.iceDisconnectedMaxTime);
            }
        }
    };
    ZegoPublish.prototype.onIceCandidate = function (event) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_ICE_CANDIDATE +
            " " +
            this.streamId +
            " candidate" +
            event.candidate);
        if (!event.candidate) {
            return;
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_ICE_CANDIDATE +
            " " +
            this.streamId +
            " candidate" +
            event.candidate.candidate);
        if (this.state < zego_entity_1.ENUM_PUBLISH_STATE.connecting ||
            this.state == zego_entity_1.ENUM_PUBLISH_STATE.stop) {
            //save candidate Info
            this.candidateInfo.push({
                candidate: event.candidate.candidate,
                sdpMid: event.candidate.sdpMid,
                sdpMLineIndex: event.candidate.sdpMLineIndex
            });
        }
        else {
            var candidate = {
                candidate: event.candidate.candidate,
                sdpMid: event.candidate.sdpMid,
                sdpMLineIndex: event.candidate.sdpMLineIndex
            };
            this.sendCandidateInfo([candidate]);
        }
    };
    ZegoPublish.prototype.sendCandidateInfo = function (candidateInfo) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SEND_CANDIDATE_INFO +
            " " +
            this.streamId +
            " called");
        candidateInfo = candidateInfo.filter(function (item) {
            if (item.candidate.indexOf("relay") > 0) {
                return true;
            }
            return false;
        });
        if (!candidateInfo || candidateInfo.length < 1) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SEND_CANDIDATE_INFO +
                " " +
                this.streamId +
                " cancelled");
            return;
        }
        this.dataReport.eventStart(this.reportSeq, "SendIceCandidate");
        this.dataReport.eventStart(this.streamReportSeq, "SendIceCandidate");
        if (this.stateNego !== zego_entity_1.ENUM_PUBLISH_STATE_NEGO.iceConnected)
            this.stateNego = zego_entity_1.ENUM_PUBLISH_STATE_NEGO.sendCandidate;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SEND_CANDIDATE_INFO +
            " " +
            this.streamId +
            " stateNego:sendCandidate");
        this.signal.sendCandidateInfo(zego_entity_1.getSeq(), this.sessionId, candidateInfo, function (seq, sessionId, data) {
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SEND_CANDIDATE_INFO +
                " " +
                _this.streamId +
                " send success");
            _this.dataReport.eventEnd(_this.reportSeq, "SendIceCandidate");
            _this.dataReport.eventEnd(_this.streamReportSeq, "SendIceCandidate");
        }, function (err, seq) {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SEND_CANDIDATE_INFO +
                " " +
                _this.streamId +
                " failed to send: " +
                err.toString());
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "SendIceCandidate", {
                error: err
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "SendIceCandidate", {
                error: err
            });
            _this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kCandidateError);
        });
    };
    ZegoPublish.prototype.onConnectionStateChange = function (event) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CONNECTION_STATE_CHANGE +
            " " +
            this.streamId +
            " called " +
            event.target.signalingState);
    };
    ZegoPublish.prototype.onRecvCandidateInfo = function (seq, sessionId, data) {
        var _this = this;
        var _a;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_CANDIDATE_INFO +
            " " +
            this.streamId +
            " received " +
            JSON.stringify(data.infos));
        if (this.state != zego_entity_1.ENUM_PUBLISH_STATE.waitingServerICE) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_CANDIDATE_INFO +
                " " +
                this.streamId +
                " current state " +
                this.state +
                " not allowed");
            return;
        }
        this.dataReport.addEvent(this.reportSeq, "RecvIceCandidate");
        this.dataReport.addEvent(this.streamReportSeq, "RecvIceCandidate");
        this.signal.sendCandidateInfoAck(seq, this.sessionId, 0);
        this.sendCandidateInfo(this.candidateInfo);
        this.candidateInfo = [];
        for (var i = 0; i < data.infos.length; i++) {
            var ice = {
                sdpMid: data.infos[i].sdpMid,
                sdpMLineIndex: data.infos[i].sdpMLineIndex,
                candidate: data.infos[i].candidate
            };
            this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_CANDIDATE_INFO +
                "" +
                this.streamId +
                " candidate " +
                ice.candidate);
            (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.addIceCandidate(new RTCIceCandidate(ice)).then(function () {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_CANDIDATE_INFO +
                    " " +
                    _this.streamId +
                    " add success");
            }, function (error) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_CANDIDATE_INFO +
                    " " +
                    _this.streamId +
                    " add error " +
                    error.toString());
                _this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kCandidateError, true);
            });
        }
        this.state = zego_entity_1.ENUM_PUBLISH_STATE.connecting;
        this.dataReport.eventStart(this.reportSeq, "IceConnected");
        this.dataReport.eventStart(this.streamReportSeq, "IceConnected");
    };
    ZegoPublish.prototype.onRecvCloseSession = function (seq, sessionId, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_CLOSE_SESSION +
            "" +
            this.streamId +
            " " +
            JSON.stringify(data));
        this.dataReport.addEvent(this.reportSeq, "RecvCloseSession");
        this.signal.sendCloseSessionAck(seq, this.sessionId, 0);
        var err_info = data.err_info
            ? JSON.parse(data.err_info.toLowerCase())
            : {};
        var action = err_info.action ? err_info.action : null;
        var reason = data.reason * 1;
        var error = JSON.parse(JSON.stringify(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishSessionClosedError));
        error.message += " reason:" + reason + " " + (action ? " action:" + action : "");
        // 处理展示推流被媒体服务禁止时报错
        if (err_info.err === 1011) {
            error =
                zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kMediaServerForbidError;
        }
        // 处理展示推流因 token 过期被媒体服务禁止时报错
        if (err_info.err === 1014) {
            error =
                zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishTokenExpiredError;
        }
        this.negoTimer && clearTimeout(this.negoTimer);
        var stopRetry = [4, 8, 10, 11, 12, 14, 26, 27].includes(reason) ||
            [2, 5, 6].includes(action)
            ? false
            : true;
        this.publishStateUpdateError(error, stopRetry);
    };
    ZegoPublish.prototype.onRecvResetSession = function (seq, sessionId, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_RESET_SESSION +
            " " +
            this.streamId +
            " received ");
        if (sessionId != this.sessionId) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_RESET_SESSION +
                " " +
                this.streamId +
                " cannot find session");
            return;
        }
        this.signal.sendCloseSessionAck(seq, this.sessionId, 0);
        var error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishSessionClosedError;
        // error.msg += data.reason;
        this.negoTimer && clearTimeout(this.negoTimer);
        this.publishStateUpdateError(error);
    };
    ZegoPublish.prototype.onRecvPublishEvent = function (seq, sessionId, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_PUBLISH_EVENT +
            " " +
            this.streamId +
            " received");
        this.publishEvent = true;
        if (this.firstGetStatsTimer) {
            clearTimeout(this.firstGetStatsTimer);
            this.firstGetStatsTimer = null;
        }
        this.stateNego === zego_entity_1.ENUM_PUBLISH_STATE_NEGO.iceConnected &&
            data.event == 0 &&
            this.publishSuccess();
    };
    ZegoPublish.prototype.onRecvClientInfo = function (seq, sessionId, data) {
        //客户端ip发生变化
        if (this.stateCenter.clientIP !== data.clientip) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_CLIENT_INFO +
                " " +
                "client ip changed " +
                this.stateCenter.clientIP +
                " " +
                data.clientip);
            // const error = ZegoRTCLogEvent.kZegoTaskPublishStart.error.kClientIPChangedError;
            // this.gwNode = "";
            // this.gwNodeList = [];
            // this.gwNodeTTL = 0;
            // this.publishStateUpdateError (error);
        }
        this.stateCenter.clientIP = data.clientip;
        this.peerID = data.peer_id;
        // 根据本地预览的流的activeteSEIConfig来设置是否启用SEI
        var previewer = this.previewer;
        if (previewer && previewer.activateSEIConfig !== null) {
            var _a = previewer === null || previewer === void 0 ? void 0 : previewer.activateSEIConfig, action = _a.action, infoType = _a.infoType;
            this.activateSEIInsert(action, infoType);
        }
    };
    ZegoPublish.prototype.checkPublishConnectionFailedState = function (connectionState) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_ICE_CONNECTION_STATE_CHANGE +
            " streamID " +
            this.streamId, " state " + this.state + " connectionState " + connectionState);
        this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kMediaConnectionError);
    };
    ZegoPublish.prototype.setPublishQualityTimer = function () {
        var _this = this;
        if (this.qualityTimer != null) {
            return;
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SET_PLAYER_QUALITY_TIMER +
            " " +
            this.streamId +
            " called");
        this.clearPublishQualityTimer();
        this.qualityTimer = setInterval(function () {
            _this.peerConnectionGetStats();
        }, this.qualityTimeInterval);
        this.lastPublishStats = {
            audioPacketsLost: 0,
            videoPacketsLost: 0,
            videoPacketsSent: 0,
            audioPacketsSent: 0,
            audioRetransmittedPacketsSent: 0,
            videoTime: new Date().getTime(),
            audioTime: new Date().getTime(),
            time: 0,
            audioBytesSent: 0,
            videoBytesSent: 0,
            framesEncoded: 0,
            framesSent: 0,
            videoRetransmittedPacketsSent: 0
        };
        this.qualitySeq = zego_entity_1.getSeq();
        this.qualityCount = 0;
    };
    ZegoPublish.prototype.peerConnectionGetStats = function (callback) {
        var _this = this;
        if (this.peerConnection) {
            var promiseList = [this.peerConnection.getStats(null)];
            if (this.stateCenter.browser == "chrome") {
                promiseList.push(new Promise(function (resolve, reject) {
                    var _a;
                    (_a = _this.peerConnection) === null || _a === void 0 ? void 0 : _a.getStats(function (results) { return resolve(results); }, 
                    // @ts-ignore
                    function (err) { return reject(err); });
                }));
            }
            Promise.all(promiseList)
                .then(function (values) {
                var stats = _this.getPublishStats(values[0], values[1]);
                callback && callback(stats, values[0], values[1]);
            })
                .catch(function (error) {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SET_PLAYER_QUALITY_TIMER +
                    " " +
                    _this.streamId +
                    " getStats error " +
                    error.toString());
            });
        }
    };
    ZegoPublish.prototype.getPublishStats = function (results, callbackResults) {
        var _this = this;
        var _a;
        if (!results) {
            return;
        }
        var medias = document.querySelectorAll("video, audio");
        var streamMedia;
        for (var i = 0; i < medias.length; i++) {
            if (medias[i].srcObject === this.localStream) {
                streamMedia = medias[i];
            }
        }
        var previewer = this.streamCenter.checkPreview(this.localStream);
        var publishData = {
            audioCodec: "opus",
            audioTargetBitrate: this.videoInfo.audioBitrate / 1000 || 0,
            audioBitrate: 0,
            videoTargetBitrate: this.videoInfo.bitRate || 0,
            videoTargetFPS: this.videoInfo.frameRate || 0,
            videoBitrate: 0,
            audioFPS: 0,
            audioLevel: 0,
            audioInputLevel: 0,
            audioPacketsLost: 0,
            audioPacketsLostRate: 0,
            sendLevel: 0,
            samplingRate: 0,
            videoFPS: 0,
            nackCount: 0,
            pliCount: 0,
            //sliCount: 0,
            audioQuality: 0,
            videoQuality: 0,
            frameHeight: 0,
            frameWidth: 0,
            videoTransferFPS: 0,
            videoPacketsLost: 0,
            videoPacketsLostRate: 0,
            totalRoundTripTime: 0,
            currentRoundTripTime: 0,
            googBandwidthLimitedResolution: undefined,
            videoCodecName: "",
            audioCodecName: "",
            googCpuLimitedResolution: undefined,
            googAvailableSendBandwidth: 0,
            googActualEncBitrate: 0,
            googTargetEncBitrate: 0,
            googFrameWidthInput: 0,
            googFrameHeightInput: 0,
            googFrameRateInput: 0,
            codecImplementationName: "",
            videoMuteState: ((_a = previewer === null || previewer === void 0 ? void 0 : previewer.videoTrack) === null || _a === void 0 ? void 0 : _a.enabled) ? "0" : "1",
            audioMuteState: this.localStream.getAudioTracks().length > 0
                ? this.localStream.getAudioTracks()[0].enabled
                    ? "0"
                    : "1"
                : "1",
            muted: streamMedia ? streamMedia.muted : undefined,
            paused: streamMedia ? streamMedia.paused : undefined,
            volume: streamMedia ? streamMedia.volume : undefined,
            sinkId: streamMedia ? streamMedia.sinkId : undefined
        };
        var time = this.lastPublishStats.time;
        var aRTT = 0;
        var vRTT = 0;
        var aLostRate = 0;
        var vLostRate = 0;
        var aJitter = 0;
        var vJitter = 0;
        results.forEach(function (result) {
            if ((result.type == "outbound-rtp" ||
                (result.type == "ssrc" && result.bytesSent != undefined)) &&
                result.mediaType == "audio") {
                //audio
                if (time != 0) {
                    publishData.audioBitrate =
                        (8 * (result.bytesSent - _this.lastPublishStats.audioBytesSent)) /
                            (result.timestamp - time);
                    publishData.audioFPS =
                        ((result.packetsSent -
                            (result.retransmittedPacketsSent -
                                _this.lastPublishStats.audioRetransmittedPacketsSent) -
                            _this.lastPublishStats.audioPacketsSent) /
                            (result.timestamp - time)) *
                            1000;
                    aLostRate =
                        (result.retransmittedPacketsSent -
                            _this.lastPublishStats.audioRetransmittedPacketsSent) /
                            (result.packetsSent - _this.lastPublishStats.audioPacketsSent);
                }
                if (publishData.audioBitrate < 0) {
                    publishData.audioBitrate = 0;
                }
                _this.lastPublishStats.audioBytesSent = result.bytesSent;
                _this.lastPublishStats.time = result.timestamp;
                _this.lastPublishStats.audioPacketsSentTimeStamp =
                    result.packetsSent - _this.lastPublishStats.audioPacketsSent;
                _this.lastPublishStats.audioPacketsSent = result.packetsSent;
                _this.lastPublishStats.audioRetransmittedPacketsSent =
                    result.retransmittedPacketsSent;
            }
            else if ((result.type == "outbound-rtp" ||
                (result.type == "ssrc" && result.bytesSent != undefined)) &&
                result.mediaType == "video") {
                //video
                if (time != 0) {
                    publishData.videoBitrate =
                        (8 * (result.bytesSent - _this.lastPublishStats.videoBytesSent)) /
                            (result.timestamp - time);
                    publishData.videoFPS =
                        (1000 *
                            (result.framesEncoded - _this.lastPublishStats.framesEncoded)) /
                            (result.timestamp - time);
                    vLostRate =
                        (result.retransmittedPacketsSent -
                            _this.lastPublishStats.videoRetransmittedPacketsSent) /
                            (result.packetsSent - _this.lastPublishStats.videoPacketsSent);
                }
                if (publishData.videoBitrate < 0) {
                    publishData.videoBitrate = 0;
                }
                if (publishData.videoFPS < 0) {
                    publishData.videoFPS = 0;
                }
                publishData.nackCount = result.nackCount;
                publishData.pliCount = result.pliCount;
                //publishData.sliCount = result.sliCount;
                _this.lastPublishStats.videoBytesSent = result.bytesSent;
                _this.lastPublishStats.framesEncoded = result.framesEncoded;
                _this.lastPublishStats.time = result.timestamp;
                _this.lastPublishStats.videoPacketsSentTimeStamp =
                    result.packetsSent - _this.lastPublishStats.videoPacketsSent;
                _this.lastPublishStats.videoPacketsSent = result.packetsSent;
                _this.lastPublishStats.videoRetransmittedPacketsSent =
                    result.retransmittedPacketsSent;
            }
            else if (result.type == "remote-inbound-rtp" &&
                result.kind == "video") {
                result.packetsLost > 0 &&
                    (publishData.videoPacketsLost = result.packetsLost);
                var videoLostDiff = result.packetsLost - _this.lastPublishStats.videoPacketsLost;
                if (videoLostDiff > 0) {
                    publishData.videoPacketsLostRate =
                        videoLostDiff / _this.lastPublishStats.videoPacketsSentTimeStamp;
                }
                else {
                    publishData.videoPacketsLostRate = 0;
                }
                result.packetsLost > 0 &&
                    (_this.lastPublishStats.videoPacketsLost = result.packetsLost);
                _this.lastPublishStats.videoTime = result.timestamp;
                vRTT = result.roundTripTime * 1000;
                vJitter = result.jitter;
            }
            else if (result.type == "remote-inbound-rtp" &&
                result.kind == "audio") {
                result.packetsLost > 0 &&
                    (publishData.audioPacketsLost = result.packetsLost);
                var audioLostDiff = result.packetsLost - _this.lastPublishStats.audioPacketsLost;
                if (audioLostDiff > 0) {
                    publishData.audioPacketsLostRate =
                        audioLostDiff / _this.lastPublishStats.audioPacketsSentTimeStamp;
                }
                else {
                    publishData.audioPacketsLostRate = 0;
                }
                result.packetsLost > 0 &&
                    (_this.lastPublishStats.audioPacketsLost = result.packetsLost);
                _this.lastPublishStats.audioTime = result.timestamp;
                aRTT = result.roundTripTime * 1000;
                aJitter = result.jitter;
            }
            //safari don't have this type
            else if (result.type == "media-source" &&
                (result.kind == "audio" ||
                    result.id.toLowerCase().indexOf("audio") >= 0)) {
                publishData.audioLevel = result.audioLevel;
                publishData.sendLevel = result.totalAudioEnergy;
                publishData.audioInputLevel = 32767 * result.totalAudioEnergy;
                publishData.samplingRate = result.totalSamplesDuration;
            }
            else if (result.type == "track" &&
                (result.kind == "video" ||
                    result.id.indexOf("video") >= 0 ||
                    result.frameWidth)) {
                publishData.frameHeight = result.frameHeight;
                publishData.frameWidth = result.frameWidth;
                // 上报分辨率变化
                if (time !== 0 &&
                    (_this.lastPublishStats.frameHeight !== result.frameHeight ||
                        _this.lastPublishStats.frameWidth !== result.frameWidth)) {
                    var reportSizeSeq = zego_entity_1.getReportSeq();
                    _this.dataReport.newReport(reportSizeSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskVideoCaptureSize.event);
                    _this.dataReport.addMsgInfo(reportSizeSeq, {
                        session_id: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskVideoCaptureSize.session_id(_this.sessionId),
                        w: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskVideoCaptureSize.w(result.frameWidth),
                        h: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskVideoCaptureSize.h(result.frameHeight)
                    });
                    _this.dataReport.uploadReport(reportSizeSeq);
                    _this.lastPublishStats.frameHeight = result.frameHeight;
                    _this.lastPublishStats.frameWidth = result.frameWidth;
                }
                else if (time === 0) {
                    _this.lastPublishStats.frameHeight = result.frameHeight;
                    _this.lastPublishStats.frameWidth = result.frameWidth;
                }
                if (time != 0) {
                    publishData.videoTransferFPS =
                        (1000 * (result.framesSent - _this.lastPublishStats.framesSent)) /
                            (result.timestamp - time);
                }
                if (publishData.videoTransferFPS < 0) {
                    publishData.videoTransferFPS = 0;
                }
                _this.lastPublishStats.framesSent = result.framesSent;
            }
            else if (result.type == "candidate-pair") {
                if (result.totalRoundTripTime != undefined) {
                    publishData.totalRoundTripTime = result.totalRoundTripTime;
                }
                if (result.currentRoundTripTime != undefined) {
                    publishData.currentRoundTripTime = result.currentRoundTripTime;
                }
            }
        });
        callbackResults &&
            callbackResults.result().forEach(function (result) {
                // if (result.type == 'ssrc' && result.id.indexOf('send') >=0 && result.stat('mediaType') == 'video' && result.names().indexOf('packetsLost') >= 0) {
                //     const packetsLost = parseInt(result.stat('packetsLost'));
                //     publishData.videoPacketsLost = packetsLost;
                //     const timediff = result.timestamp.getTime() - this.lastPublishStats.videoTime;
                //     publishData.videoPacketsLostRate = (packetsLost - this.lastPublishStats.videoPacketsLost) /
                //         timediff;
                //     this.lastPublishStats.videoTime = result.timestamp.getTime();
                //     this.lastPublishStats.videoPacketsLost = packetsLost;
                // }
                // if (result.type == 'ssrc' && result.id.indexOf('send') >=0 && result.stat('mediaType') == 'audio' && result.names().indexOf('packetsLost') >= 0) {
                //     const packetsLost = parseInt(result.stat('packetsLost'));
                //     publishData.audioPacketsLost = packetsLost;
                //     publishData.audioPacketsLostRate = (packetsLost - this.lastPublishStats.audioPacketsLost) /
                //         (result.timestamp.getTime() - this.lastPublishStats.audioTime);
                //     this.lastPublishStats.audioTime = result.timestamp.getTime();
                //     this.lastPublishStats.audioPacketsLost = packetsLost;
                // }
                if (result.type == "ssrc" &&
                    result.names().indexOf("googBandwidthLimitedResolution") >= 0) {
                    publishData.googBandwidthLimitedResolution = result.stat("googBandwidthLimitedResolution");
                }
                if (result.type == "ssrc" &&
                    result.stat("mediaType") == "video" &&
                    result.names().indexOf("googCodecName") >= 0) {
                    publishData.videoCodecName = result.stat("googCodecName");
                }
                if (result.type == "ssrc" &&
                    result.stat("mediaType") == "audio" &&
                    result.names().indexOf("googCodecName") >= 0) {
                    publishData.audioCodecName = result.stat("googCodecName");
                }
                if (result.type == "ssrc" &&
                    result.names().indexOf("googCpuLimitedResolution") >= 0) {
                    publishData.googCpuLimitedResolution = result.stat("googCpuLimitedResolution");
                }
                if (result.type == "ssrc" &&
                    result.names().indexOf("googFrameWidthInput") >= 0) {
                    publishData.googFrameWidthInput = result.stat("googFrameWidthInput");
                }
                if (result.type == "ssrc" &&
                    result.names().indexOf("googFrameHeightInput") >= 0) {
                    publishData.googFrameHeightInput = result.stat("googFrameHeightInput");
                }
                if (result.type == "ssrc" &&
                    result.names().indexOf("googFrameRateInput") >= 0) {
                    publishData.googFrameRateInput = result.stat("googFrameRateInput");
                }
                if (result.type == "ssrc" &&
                    result.names().indexOf("codecImplementationName") >= 0) {
                    publishData.codecImplementationName = result.stat("codecImplementationName");
                }
                if (result.type == "VideoBwe" &&
                    result.names().indexOf("googAvailableSendBandwidth") >= 0) {
                    publishData.googAvailableSendBandwidth = result.stat("googAvailableSendBandwidth");
                }
                if (result.type == "VideoBwe" &&
                    result.names().indexOf("googActualEncBitrate") >= 0) {
                    publishData.googActualEncBitrate = result.stat("googActualEncBitrate");
                }
                if (result.type == "VideoBwe" &&
                    result.names().indexOf("googTargetEncBitrate") >= 0) {
                    publishData.googTargetEncBitrate = result.stat("googTargetEncBitrate");
                }
                if (result.type == "VideoBwe" &&
                    result.names().indexOf("googRetransmitBitrate") >= 0) {
                    publishData.googRetransmitBitrate = result.stat("googRetransmitBitrate");
                }
            });
        this.stateCenter.browser === "chrome" &&
            this.handleEncBitrate(Number.parseInt(publishData.googTargetEncBitrate), Number.parseInt(publishData.googActualEncBitrate), Number.parseInt(publishData.googRetransmitBitrate));
        vRTT = isNaN(vRTT) || vRTT < 0 ? 0 : vRTT;
        vLostRate = isNaN(vLostRate) || vLostRate < 0 ? 0 : vLostRate;
        vJitter = isNaN(vJitter) || vJitter < 0 ? 0 : vJitter;
        aRTT = isNaN(aRTT) || aRTT < 0 ? 0 : aRTT;
        aLostRate = isNaN(aLostRate) || aLostRate < 0 ? 0 : aLostRate;
        aJitter = isNaN(aJitter) || aJitter < 0 ? 0 : aJitter;
        var videoQuality = client_util_1.ClientUtil.getNetQuality(vRTT, vLostRate, vJitter);
        var audioQuality = client_util_1.ClientUtil.getNetQuality(aRTT, aLostRate, aJitter);
        publishData.videoQuality =
            time > 0 ? client_util_1.ClientUtil.quality2QualityGrade(videoQuality) : 0;
        publishData.audioQuality =
            time > 0 ? client_util_1.ClientUtil.quality2QualityGrade(audioQuality) : 0;
        var netQuality = Math.min(videoQuality, audioQuality);
        this.netQuality = netQuality;
        if (time > 0 &&
            netQuality <= zego_entity_1.QUALITY_CONSTANT.MiddleMinQuality &&
            new Date().getTime() > this.probeTime + this.probeInterval) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SET_PLAYER_QUALITY_TIMER +
                " netQuality " +
                netQuality +
                " start net probe");
            this.probeState = zego_entity_1.ENUM_PROBE_STATE.tryProbe;
            this.streamCenter.startNetProbe(true, this, this.gwNodeList);
            this.probeTime = new Date().getTime();
        }
        var streamQuality = {
            video: {
                videoBitrate: publishData.videoBitrate,
                videoFPS: publishData.videoFPS,
                videoTransferFPS: publishData.videoTransferFPS,
                frameHeight: publishData.frameHeight,
                frameWidth: publishData.frameWidth,
                muteState: publishData.videoMuteState,
                videoQuality: publishData.videoQuality,
                videoPacketsLost: publishData.videoPacketsLost,
                videoPacketsLostRate: publishData.videoPacketsLostRate
            },
            audio: {
                audioBitrate: publishData.audioBitrate,
                audioCodec: publishData.audioCodec,
                muteState: publishData.audioMuteState,
                audioQuality: publishData.audioQuality,
                audioPacketsLost: publishData.audioPacketsLost,
                audioPacketsLostRate: publishData.audioPacketsLostRate,
                audioFPS: publishData.audioFPS
            },
            //roomId: '',
            nackCount: publishData.nackCount,
            pliCount: publishData.pliCount,
            totalRoundTripTime: publishData.totalRoundTripTime,
            currentRoundTripTime: publishData.currentRoundTripTime
        };
        if (publishData.videoPacketsLost !== undefined) {
            streamQuality.video.videoPacketsLost = publishData.videoPacketsLost;
            streamQuality.video.videoPacketsLostRate =
                publishData.videoPacketsLostRate;
            streamQuality.audio.audioPacketsLost = publishData.audioPacketsLost;
            streamQuality.audio.audioPacketsLostRate =
                publishData.audioPacketsLostRate;
        }
        if (publishData.muted !== undefined) {
            streamQuality.muted = publishData.muted;
            streamQuality.paused = publishData.paused;
            streamQuality.volume = publishData.volume;
            streamQuality.sinkId = publishData.sinkId;
        }
        if (publishData.googBandwidthLimitedResolution !== undefined) {
            streamQuality.googBandwidthLimitedResolution =
                publishData.googBandwidthLimitedResolution;
            streamQuality.video.googCodecName = publishData.videoCodecName;
            streamQuality.audio.googCodecName = publishData.audioCodecName;
            streamQuality.googCpuLimitedResolution =
                publishData.googCpuLimitedResolution;
            streamQuality.googFrameWidthInput = publishData.googFrameWidthInput;
            streamQuality.googFrameHeightInput = publishData.googFrameHeightInput;
            streamQuality.googFrameRateInput = publishData.googFrameRateInput;
            streamQuality.codecImplementationName =
                publishData.codecImplementationName;
            streamQuality.googAvailableSendBandwidth =
                publishData.googAvailableSendBandwidth;
            streamQuality.googActualEncBitrate = publishData.googActualEncBitrate;
            streamQuality.googTargetEncBitrate = publishData.googTargetEncBitrate;
        }
        if (time !== 0) {
            this.uploadPublishQuality(publishData);
            this.onPublishQualityUpdate(this.streamId, streamQuality, results, callbackResults);
        }
        return streamQuality;
    };
    ZegoPublish.prototype.uploadPublishQuality = function (publishData) {
        var _this = this;
        if (!this.qualityUpload) {
            return;
        }
        var timeStamp = new Date().getTime();
        if (this.qualityUploadLastTime == 0 ||
            timeStamp - this.qualityUploadLastTime >= this.qualityUploadInterval) {
            publishData["stream_type"] = "publish";
            publishData["stream_id"] = this.streamId;
            publishData["timeStamp"] = Math.round(timeStamp / 1000);
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_UPLOAD_PUBLISH_QUALITY +
                " " +
                this.streamId +
                " upload" +
                JSON.stringify(publishData));
            this.streamCenter.updateQuality(0, publishData);
            this.signal.QualityReport(zego_entity_1.getSeq(), this.sessionId, publishData, function (seq, sessionId, data) {
                console.error("QualityReport suc");
                if (data.report !== undefined) {
                    _this.qualityUpload = data.report;
                    _this.qualityUploadInterval = data.report_interval_ms;
                }
            }, function (err, seq) {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_UPLOAD_PUBLISH_QUALITY +
                    " " +
                    _this.streamId +
                    " upload failed " +
                    err);
            });
            this.qualityUploadLastTime = timeStamp;
        }
    };
    ZegoPublish.prototype.stopPublish = function () {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_STOP_PUBLISH +
            "  .1 " +
            this.streamId +
            " called");
        //sendBroadcasterStatusNotify
        if ((Object.keys(this.streamCenter.publisherList).length = 1)) {
            for (var i in this.streamCenter.playerList) {
                var player = this.streamCenter.playerList[i].player;
                if (player.state == zego_entity_1.ENUM_PLAY_STATE.playing &&
                    player.broadcasterStatus == zego_entity_1.ENUM_BROADCASTER_STATUS.start) {
                    this.signal &&
                        this.signal.sendBroadcasterStatus(zego_entity_1.getSeq(), player.sessionId, 0);
                    player.broadcasterStatus = zego_entity_1.ENUM_BROADCASTER_STATUS.stop;
                }
            }
        }
        //stop Audio Mix
        this.stopMixingAudio();
        this.stopMixingBuffer();
        this.stopEffect();
        //close session
        if (this.sessionId && !this.closeSessionSignal) {
            this.signal.sendCloseSession(zego_entity_1.getSeq(), this.sessionId, 0);
        }
        this.dataReport.eventEndWithMsg(this.streamReportSeq, "PublishState", {
            state: this.state + ""
        });
        this.dataReport.addEvent(this.streamReportSeq, "StopPublish");
        this.dataReport.addMsgExt(this.streamReportSeq, {
            stream: this.streamId,
            sessionId: this.sessionId
        });
        this.dataReport.addMsgInfo(this.streamReportSeq, {
            itemtype: "RTCPublishStream"
        });
        this.dataReport.uploadReport(this.streamReportSeq, "RTCPublishStream");
        this.resetPublish();
    };
    ZegoPublish.prototype.onPublishStateUpdate = function (type, streamId, error, stopRetry) { };
    ZegoPublish.prototype.onPublishQualityUpdate = function (streamId, quality, promiseresults, callbackresults) { };
    ZegoPublish.prototype.onDisconnect = function (error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_DISCONNECT + " " + this.streamId + " call");
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_DISCONNECT +
            " " +
            this.streamId +
            " websocket disconnect");
        this.dataReport.addEvent(this.reportSeq, "OnDisconnect");
        // 异常断开时停止重试
        this.publishStateUpdateError(error ||
            zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kWebsocketDisconnectedError, !!error);
    };
    //音效相关 空实现，由混音模块覆盖
    ZegoPublish.prototype.playEffect = function (AudioMixConfig, audioBuffer, start, end) { };
    ZegoPublish.prototype.pauseEffect = function (effectID) { };
    ZegoPublish.prototype.resumeEffect = function (effectID) { };
    ZegoPublish.prototype.stopEffect = function (effectID) { };
    ZegoPublish.prototype.setEffectVolume = function (volume, effectID) { };
    ZegoPublish.prototype.startMixingAudio = function (mediaList) { };
    ZegoPublish.prototype.stopMixingAudio = function (media) { };
    ZegoPublish.prototype.mixingBuffer = function (sourceID, arrayBuffer, callBack) { };
    ZegoPublish.prototype.stopMixingBuffer = function (sourceID) { };
    ZegoPublish.prototype.setMixingAudioVolume = function (volume, audio) { };
    ZegoPublish.prototype.publishSuccess = function () {
        var _a;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_PUBLISH_SUCCESS + " call");
        if (this.isUpdateSDP && this.updateSDPCallBack) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_PUBLISH_SUCCESS +
                " " +
                this.streamId +
                " update sdp success");
            this.updateSDPCallBack(0);
            this.updateSDPCallBack = undefined;
            this.isUpdateSDP = false;
            return;
        }
        if (this.state != zego_entity_1.ENUM_PUBLISH_STATE.publishing) {
            this.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.start, this.streamId, { code: 0, message: "" }, true);
        }
        if (this.isPeer) {
            this.peerFailCount = 0;
        }
        this.state = zego_entity_1.ENUM_PUBLISH_STATE.publishing;
        //publish started
        this.dataReport.eventStart(this.reportSeq, "PublishState");
        this.dataReport.eventStart(this.streamReportSeq, "PublishState");
        //BroadcasterStatusNotify
        for (var i in this.streamCenter.playerList) {
            var player = this.streamCenter.playerList[i].player;
            if (player.state == zego_entity_1.ENUM_PLAY_STATE.playing &&
                player.broadcasterStatus == zego_entity_1.ENUM_BROADCASTER_STATUS.stop) {
                this.signal &&
                    this.signal.sendBroadcasterStatus(zego_entity_1.getSeq(), player.sessionId, 1);
                player.broadcasterStatus = zego_entity_1.ENUM_BROADCASTER_STATUS.start;
            }
        }
        //start quality timeInterval
        this.setPublishQualityTimer();
        //report stream status
        var camera = 2;
        var microphone = 2;
        var videoTrack = (_a = this.previewer) === null || _a === void 0 ? void 0 : _a.videoTrack;
        var audioTrack = this.localStream.getAudioTracks().length !== 0 &&
            this.localStream.getAudioTracks()[0];
        if (videoTrack && videoTrack.enabled === true) {
            camera = 0;
        }
        if (audioTrack && audioTrack.enabled === true) {
            microphone = 0;
        }
        this.sendStreamStatus(camera, microphone);
        // this.localStream.onaddtrack = (): void => {
        //   this.restartSoundLevel();
        // };
        // this.localStream.onremovetrack = (): void => {
        //   this.restartSoundLevel();
        // };
        if (this.streamCenter.soundLevelDelegate) {
            this.previewer && this.previewer.startSoundLevel();
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_PUBLISH_SUCCESS + " call success");
    };
    ZegoPublish.prototype.startSoundLevel = function () {
        var _a;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_SOUND_LEVEL +
            " call streamID: " +
            this.streamId);
        if (!this.localStream || this.localStream.getAudioTracks().length == 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_SOUND_LEVEL +
                " " +
                this.streamId +
                " local stream no found");
            return;
        }
        // this.script && this.script.disconnect() && (this.script = null);
        // this.mic && this.mic.disconnect() && (this.mic = null);
        try {
            (_a = this.previewer) === null || _a === void 0 ? void 0 : _a.startSoundLevel();
        }
        catch (err) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_SOUND_LEVEL +
                " " +
                this.streamId +
                " get sound level failed " +
                err);
        }
    };
    ZegoPublish.prototype.stopSoundLevel = function () {
        var _a;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_STOP_SOUND_LEVEL +
            " call streamID: " +
            this.streamId);
        (_a = this.previewer) === null || _a === void 0 ? void 0 : _a.stopSoundLevel();
    };
    // restartSoundLevel(): void {
    //   this.previewer?.restartSoundLevel;
    // }
    ZegoPublish.prototype.rebackMic = function () {
        var _this = this;
        var _a;
        if (this.peerConnection &&
            this.micTrack instanceof MediaStreamTrack &&
            this.audioMixList.length == 0 &&
            Object.keys(this.arrayBufferMap).length == 0 &&
            this.effectList.length == 0) {
            var sender = (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.getSenders().find(function (s) { var _a, _b; return ((_a = s.track) === null || _a === void 0 ? void 0 : _a.kind) === ((_b = _this.micTrack) === null || _b === void 0 ? void 0 : _b.kind); });
            if (sender) {
                sender.replaceTrack(this.micTrack);
                this.localStream.removeTrack(this.localStream.getAudioTracks()[0]);
                this.localStream.addTrack(this.micTrack);
            }
        }
    };
    ZegoPublish.prototype.handleEncBitrate = function (targetEncBitrate, actEncBitrate, retransBitrate) {
        var _this = this;
        var _a;
        var maxBitrate = this.videoInfo.bitRate * 1000;
        var target_rate = 0;
        if (actEncBitrate > 0) {
            //根据实际编码码率和设置编码码率比值决定是否提升最大编码码率值
            if (!this.needIncMax && !this.gotMax) {
                this.probeCount++;
                if (actEncBitrate >= targetEncBitrate * 0.75) {
                    if (this.probeCount >= 10 &&
                        this.initFitCnt >= this.probeCount * 0.6) {
                        this.gotMax = true;
                        this.targetRate = maxBitrate;
                    }
                    this.initFitCnt++;
                }
                else {
                    if (this.probeCount >= 10 &&
                        this.initFitCnt / this.probeCount < 0.3) {
                        this.needIncMax = true;
                    }
                }
            }
            //编码器输出码率会存在大幅波动,这里做移动平滑处理
            var avgActBitrate = client_util_1.ClientUtil.arrAvg(this.totalBitrateArray, actEncBitrate, 10);
            if (this.needIncMax) {
                if (avgActBitrate >= maxBitrate * 1.05) {
                    if (this.targetRate > maxBitrate) {
                        var diff = void 0;
                        if (avgActBitrate > targetEncBitrate) {
                            diff = avgActBitrate - targetEncBitrate;
                            this.targetRate -= diff;
                        }
                        else {
                            diff = avgActBitrate - maxBitrate;
                            this.targetRate -= diff;
                        }
                        this.targetRate = Math.max(this.targetRate, maxBitrate);
                        this.targetRate = Math.min(this.targetRate, maxBitrate * 2);
                        target_rate = this.targetRate;
                    }
                }
                else if (avgActBitrate < maxBitrate * 0.8) {
                    if (this.targetRate === 0) {
                        this.targetRate = targetEncBitrate;
                    }
                    if (this.targetRate >= maxBitrate) {
                        this.targetRate = this.targetRate + maxBitrate * 0.08;
                    }
                    else {
                        this.targetRate = this.targetRate * 1.05;
                    }
                    this.targetRate = Math.min(this.targetRate, maxBitrate * 2);
                    target_rate = this.targetRate;
                }
            }
        }
        //如果有重传,调整最大目标码率值
        if (retransBitrate > 0 && retransBitrate < maxBitrate) {
            var avgRetrans = client_util_1.ClientUtil.arrAvg(this.totalRetransRateArray, retransBitrate, 5);
            if (this.needIncMax) {
                if (avgRetrans + actEncBitrate > maxBitrate * 1.05) {
                    var diff = avgRetrans + actEncBitrate - maxBitrate;
                    this.targetRate -= diff;
                    this.targetRate = Math.max(this.targetRate, maxBitrate - avgRetrans);
                    target_rate = this.targetRate;
                }
            }
            else {
                target_rate = this.targetRate - avgRetrans;
            }
        }
        else {
            if (this.targetRate < maxBitrate) {
                this.targetRate = maxBitrate;
                target_rate = this.targetRate;
            }
        }
        if (target_rate > 0) {
            //对最后设置的最大目标码率值也做平滑处理
            target_rate = client_util_1.ClientUtil.arrAvg(this.totalTargetRateArray, target_rate, 5);
            var sender = (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.getSenders().find(function (s) { return s.track && s.track.kind === "video"; });
            if (!sender) {
                return;
            }
            var parameters = sender.getParameters();
            if (!parameters.encodings) {
                parameters.encodings = [{}];
            }
            parameters.encodings[0].maxBitrate = target_rate;
            sender.setParameters(parameters).catch(function (err) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_HANDLE_ENC_BITRATE + " " + err);
            });
        }
    };
    ZegoPublish.prototype.resetEncBitrate = function () {
        this.needIncMax = false;
        this.probeCount = 0;
        this.gotMax = false;
        this.initFitCnt = 0;
        this.targetRate = 0;
        this.totalBitrateArray = [];
        this.totalTargetRateArray = [];
        this.totalRetransRateArray = [];
    };
    ZegoPublish.prototype.replacePublishedTrack = function (mediaStreamTrack, forStream) {
        if (forStream === void 0) { forStream = false; }
        return {
            errorCode: -1,
            extendedData: "should install advanced module first"
        };
    };
    ZegoPublish.prototype.sendStreamStatus = function (camera_status, mic_status, times) {
        var _this = this;
        if (times === void 0) { times = 0; }
        // 保存当前的摄像头的状态和麦克风状态
        this.camera_status = camera_status;
        this.mic_status = mic_status;
        times++;
        // 发送流状态信令
        this.signal.sendStreamStatus(zego_entity_1.getSeq(), this.sessionId, camera_status, mic_status, this.streamId, function () {
            if (_this.camera_status === camera_status &&
                _this.mic_status === mic_status) {
                // TODO: 超时失败补发，重试1次
                if (times <= 1) {
                    _this.sendStreamStatus(camera_status, mic_status, times);
                }
            }
        });
    };
    return ZegoPublish;
}());
exports.ZegoPublish = ZegoPublish;


/***/ }),

/***/ "./sdk/src/webrtc/modules/streamSignal.ts":
/*!************************************************!*\
  !*** ./sdk/src/webrtc/modules/streamSignal.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoSignal = void 0;
var zego_entity_1 = __webpack_require__(/*! ../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var action_1 = __webpack_require__(/*! ../../common/action */ "./sdk/src/common/action.ts");
var zego_error_1 = __webpack_require__(/*! ../../common/zego.error */ "./sdk/src/common/zego.error.ts");
var analogSocket_1 = __webpack_require__(/*! ./analogSocket */ "./sdk/src/webrtc/modules/analogSocket.ts");
var WEBRTC_PROTO_VERSION = "1.0.1"; //协议版本号
var ZegoSignal = /** @class */ (function () {
    function ZegoSignal(logger, stateCenter, netAgent, useNetAgent) {
        if (useNetAgent === void 0) { useNetAgent = false; }
        this.netAgent = netAgent;
        this.useNetAgent = useNetAgent;
        this.sendDataMap = {};
        this.sendDataList = new zego_entity_1.LinkedList();
        this.sendDataCheckOnceCount = 100;
        this.signalSeq = 0;
        this.pushCallback = {};
        this.sessionInfos = {};
        //tryheartbeat
        this.tryHeartbeatCount = 0;
        // heartbeatTimer = null;
        this.heartbeatInterval = 10 * 1000;
        this.sendDataTimeout = 5 * 1000; //发送消息超时
        this.sendDataDropTimeout = 10 * 1000; //丢弃过期消息的超时时间
        this.sendDataCheckTimer = null;
        this.sendDataCheckInterval = 2000; //检查发送消息间隔
        this.checkMessageList = [
            "ActivateVideoPlayStreamReq",
            "ActivateAudioPlayStreamReq",
            "CreateSessionReq",
            "CreateSessionWithSdpReq",
            "ActivateSEIInsertReq",
            "StreamStatusNotify",
            "MediaDescUpdateReq"
        ];
        this.tryConnectCount = 1;
        this.tryConnectTimer = null;
        this.tryConnectInterval = 3000;
        this.state = zego_entity_1.ENUM_CONNECT_STATE.disconnect;
        //token
        this.tokenType = 0;
        this.browser = this.getBrowserAndVersion();
        this.platform = navigator.platform;
        this._websocket = null;
        this.negoInterval = 25000;
        this.negoTryCount = 1;
        this.negoTryMaxCount = 2;
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.stateCenter.streamConnectTime &&
            (this.tryConnectInterval = this.stateCenter.streamConnectTime);
    }
    Object.defineProperty(ZegoSignal.prototype, "wsReadyState", {
        get: function () {
            var _a;
            return (_a = this.websocket) === null || _a === void 0 ? void 0 : _a.readyState;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ZegoSignal.prototype, "websocket", {
        get: function () {
            return this._websocket;
        },
        set: function (val) {
            // 不能将统一接入的socket置为null
            if (val === null && this.useNetAgent) {
                return;
            }
            this._websocket = val;
        },
        enumerable: false,
        configurable: true
    });
    ZegoSignal.prototype.getBrowserAndVersion = function () {
        var ua = navigator.userAgent;
        var tem, M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*([\d\.]+)/i) || [];
        if (/trident/i.test(M[1])) {
            tem = /\brv[ :]+([\d\.]+)/g.exec(ua) || [];
            return { name: "IE", version: tem[1] || "" };
        }
        if (M[1] === "Chrome") {
            tem = ua.match(/\bOPR|Edge\/([\d\.]+)/);
            if (tem != null) {
                return { name: "Opera", version: tem[1] };
            }
        }
        M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, "-?"];
        if ((tem = ua.match(/version\/([\d+\.]+)/i)) != null) {
            M.splice(1, 1, tem[1]);
        }
        return {
            name: M[0],
            version: M[1]
        };
    };
    ZegoSignal.prototype.setSessionInfo = function (appid, userid) {
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SET_SESSION_INFO + " call");
        this.appid = appid + "";
        this.userid = userid;
        // this.server = serverUrl;
    };
    ZegoSignal.prototype.onDisconnect = function (server, error) { };
    ZegoSignal.prototype.onUpdateHeartBeatInterval = function (interval) { };
    ZegoSignal.prototype.resetConnectTimer = function () {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_RESET_CONNECT_TIMER + " call");
        clearTimeout(this.tryConnectTimer);
        this.tryConnectTimer = null;
        this.tryConnectCount = 0;
    };
    /**
     * 处理媒体发送过来的消息
     */
    ZegoSignal.prototype.handleWsMessage = function (e) {
        // 统一接入不用将字符串转json
        var msg = JSON.parse(e.data);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_BIND_WEBSOCKET_HANDLE + " signmsg= ", msg.header.cmd);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_BIND_WEBSOCKET_HANDLE +
            " signmsg= " +
            JSON.stringify(msg));
        if (msg.header.appid != this.appid || msg.header.user_id !== this.userid) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_BIND_WEBSOCKET_HANDLE + " check header failed");
            return;
        }
        this.handleServerPush(msg);
    };
    /**
     * 媒体服务连接成功后重新注册 error 和 close 事件回调
     */
    ZegoSignal.prototype.bindWebSocketEvents = function () {
        var _this = this;
        // 只要重连成功，心跳次数重新算
        this.tryHeartbeatCount = 0;
        this.tryConnectInterval = this.stateCenter.streamConnectTime
            ? this.stateCenter.streamConnectTime
            : 3000;
        if (this.websocket) {
            this.websocket.onclose = function (e) {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_BIND_WEBSOCKET_HANDLE +
                    " close msg = " +
                    JSON.stringify(e.code ? e.code : e));
                // this.onSocketCloseCallBack();
                if (_this.state != zego_entity_1.ENUM_CONNECT_STATE.disconnect) {
                    //try connect
                    _this.resetConnectTimer();
                    _this.startConnectTimer(function (result) {
                        if (result === 1008) {
                            _this.disconnectCallback(zego_error_1.errorCodeList.TOKEN_EXPIRED);
                        }
                    });
                    //all request timeout
                    _this.resetCheckMessage();
                }
            };
            this.websocket.onerror = function (e) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_BIND_WEBSOCKET_HANDLE +
                    " msg = " +
                    JSON.stringify(e));
            };
        }
    };
    ZegoSignal.prototype.resetCheckMessage = function () {
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_RESET_CHECK_MESSAGE + " call");
        clearTimeout(this.sendDataCheckTimer);
        this.sendDataCheckTimer = null;
        var head = this.sendDataList.getFirst();
        while (head != null) {
            this.sendDataList.remove(head);
            if (head._data.error)
                head._data.error(zego_entity_1.SEND_MSG_RESET, head._data.seq);
            head = this.sendDataList.getFirst();
        }
        this.sendDataMap = {};
    };
    ZegoSignal.prototype.handleServerPush = function (msg) {
        switch (msg.header.cmd) {
            case "LoginRsp":
                this.handleRespondData("LoginReq", msg);
                break;
            case "CreateSessionRsp":
                this.handleRespondData("CreateSessionReq", msg);
                if (msg.body.result === 0)
                    this.addSession(msg.header.session_id, msg.body.session_token);
                break;
            case "CreateSessionWithSdpRsp":
                this.handleRespondData("CreateSessionWithSdpReq", msg);
                if (msg.body.result === 0)
                    this.addSession(msg.header.session_id, msg.body.session_token);
                break;
            case "MediaDescRsp":
                this.handleRespondData("MediaDescReq", msg);
                break;
            case "CandidateInfoRsp":
                this.handleRespondData("CandidateInfoReq", msg);
                break;
            case "CloseSessionRsp":
                this.handleRespondData("CloseSessionReq", msg);
                this.removeSession(msg.header.session_id);
                break;
            case "ClientHBRsp":
                this.handleRespondData("ClientHBReq", msg);
                break;
            case "MediaDescPush":
                this.handlePushData(msg);
                break;
            case "CandidateInfoPush":
                this.handlePushData(msg);
                break;
            case "CloseSessionPush":
                this.handlePushData(msg);
                this.removeSession(msg.header.session_id);
                break;
            case "QualityReportRsp":
                this.handleRespondData("QualityReportReq", msg);
                break;
            case "SessionResetPush":
                this.handlePushResetSessionData(msg);
                break;
            case "StreamStatusNotifyPush":
                this.handlePushData(msg);
                break;
            case "PublishEventPush":
                this.handlePushData(msg);
                break;
            case "PlayEventPush":
                this.handlePushData(msg);
                break;
            case "ClientInfoPush":
                this.handlePushData(msg);
                break;
            case "ActivateVideoPlayStreamRsp":
                this.handleRespondData("ActivateVideoPlayStreamReq", msg);
                break;
            case "ActivateAudioPlayStreamRsp":
                this.handleRespondData("ActivateAudioPlayStreamReq", msg);
                break;
            case "NetQualityProbeRsp":
                this.handleRespondData("NetQualityProbeReq", msg);
                break;
            case "NetQualityInfoPush":
                this.handlePushData(msg);
                break;
            case "ActivateSEIInsertRsp":
                this.handleRespondData("ActivateSEIInsertReq", msg);
                break;
            case "StreamStatusNotifyAck":
                this.handleRespondData("StreamStatusNotify", msg);
                break;
            case "Peer2PeerNetStatsGetRsp":
                this.handleRespondData("Peer2PeerNetStatsGetReq", msg);
                break;
            case "MediaDescUpdateRsp":
                this.handleRespondData("MediaDescUpdateReq", msg);
            case "MediaDescUpdatePush":
                this.handlePushData(msg);
        }
    };
    ZegoSignal.prototype.disconnectCallback = function (error) {
        if (this.connectCallback) {
            this.connectCallback(-1, this.server, undefined);
            this.connectCallback = null;
        }
        var server = this.server;
        this.disconnectServer();
        this.onDisconnect(server, error);
    };
    ZegoSignal.prototype.updateToken = function () {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_UPDATE_TOKEN + " call");
        var cmd = "LoginReq";
        var body = {
            token: this.token,
            tokenType: this.tokenType,
            roomid: this.roomID,
            anchorname: this.stateCenter.anchor_info.anchor_id,
            sdkversion: zego_entity_1.PROTO_VERSION,
            osinfo: navigator.appVersion
        };
        if (Object.keys(this.sessionInfos).length != 0) {
            var sessions = [];
            for (var sessionID in this.sessionInfos) {
                var session_id = parseInt(sessionID);
                sessions.push({
                    session_id: session_id,
                    session_token: this.sessionInfos[session_id].token
                });
            }
            body["sessions"] = sessions;
        }
        this.sendMessageWithCallback(cmd, this.stateCenter.getSeq(), 0, body, function (seq, session_id, data) {
            if (data.result == 0) {
                _this.token = data.token;
                _this.tokenType = data.tokenType;
                var tokenInfo = {
                    report: data.report,
                    report_interval: data.report_interval_ms
                };
                data.negoInterval && (_this.negoInterval = data.negoInterval);
                data.negoTryCount && (_this.negoTryCount = data.negoTryCount);
                data.negoTryMaxCount && (_this.negoTryMaxCount = data.negoTryMaxCount);
                if (_this.connectCallback != null) {
                    _this.connectCallback(0, _this.server, tokenInfo);
                    _this.connectCallback = null;
                }
                _this.checkMessageTimeout();
            }
            else {
                var errorTokenInfo = {
                    error: data.strError
                };
                if (_this.connectCallback != null) {
                    _this.connectCallback(data.result, _this.server, errorTokenInfo);
                    _this.connectCallback = null;
                }
            }
        }, function () {
            if (_this.connectCallback != null) {
                _this.connectCallback(-1, _this.server, undefined);
                _this.connectCallback = null;
            }
        });
    };
    ZegoSignal.prototype.sendMessageWithCallback = function (cmd, seq, sessionID, body, success, error) {
        if (success === void 0) { success = null; }
        if (error === void 0) { error = null; }
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MESSAGE_WITH_CALLBACK + " call " + cmd);
        if (!this.websocket ||
            (cmd !== "LoginReq" && this.websocket.readyState !== WebSocket.OPEN)) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MESSAGE_WITH_CALLBACK +
                " connect not establish");
            if (error) {
                // TODO: 错误码不符合实际情况，实际错误是socket断开
                error(zego_entity_1.SEND_MSG_TIMEOUT, seq);
            }
            return;
        }
        var header = this.getHeader(cmd, seq, sessionID);
        var data = {
            header: header,
            body: body
        };
        var cmdData = {
            // data: data,
            seq: seq,
            deleted: false,
            cmd: cmd,
            time: new Date().getTime(),
            success: success,
            error: error
        };
        var cmdDataNode = this.sendDataList.push(cmdData);
        this.sendDataMap[cmdData.seq] = cmdDataNode;
        var dataBuffer = JSON.stringify(data);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MESSAGE_WITH_CALLBACK + " " + dataBuffer);
        this.websocket.send(dataBuffer);
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MESSAGE_WITH_CALLBACK + " success");
    };
    ZegoSignal.prototype.getHeader = function (cmd, seq, sessionID) {
        var globalHeader = {
            version: WEBRTC_PROTO_VERSION,
            cmd: cmd,
            appid: this.appid + "",
            seq: seq,
            user_id: this.userid,
            session_id: sessionID
        };
        return globalHeader;
    };
    //rtc信令连接
    ZegoSignal.prototype.connectServer = function (roomID, token, serverUrl, result) {
        var _this = this;
        var _a;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER + " " + serverUrl);
        this.roomID = roomID;
        this.token = token;
        this.server = serverUrl;
        this.state = zego_entity_1.ENUM_CONNECT_STATE.connecting;
        this.connectCallback = result;
        if (!this.isServerConnected) {
            try {
                //connect websocket
                if (this.useNetAgent) {
                    if (!this.stateCenter.appConfig) {
                        console.error("no app config");
                        return;
                    }
                    var resource_info = this.stateCenter.appConfig.media_config.publish_config.resource_info;
                    var rtcs = resource_info.find(function (item) {
                        return item.resource_type === zego_entity_1.ResourceType.RTC;
                    });
                    if (!rtcs) {
                        result && result(zego_error_1.errorCodeList.GET_CONFIG_FAIL);
                        return;
                    }
                    var rtc_webrtc = (_a = rtcs === null || rtcs === void 0 ? void 0 : rtcs.service_info) === null || _a === void 0 ? void 0 : _a.find(function (rtc) {
                        return rtc.protocol === zego_entity_1.ProtocolType.WEBRTC;
                    });
                    if (!rtc_webrtc) {
                        // TODO
                        result && result(zego_error_1.errorCodeList.GET_CONFIG_FAIL);
                        return;
                    }
                    var urlTemplate = rtc_webrtc.url_template;
                    var url = urlTemplate.split("{IP}")[1];
                    var _b = url.split("?"), path = _b[0], query = _b[1];
                    var signalConfig = {
                        path: path,
                        query: query
                    };
                    console.error(signalConfig);
                    if (this.websocket instanceof WebSocket) {
                        this.websocket.onclose = null;
                        this.websocket.onerror = null;
                        this.websocket.close();
                        this.websocket = null;
                    }
                    !this.websocket &&
                        (this.websocket = new analogSocket_1.AnalogSocket(this.server, this.netAgent, signalConfig));
                    this.websocket.open();
                }
                else {
                    this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER + " need new websocket");
                    if (this.websocket) {
                        this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER +
                            " close error websocket");
                        this.websocket.onclose = null;
                        this.websocket.onerror = null;
                        this.websocket.close();
                    }
                    this.websocket = new WebSocket(this.server);
                }
                this.websocket.onclose = function (reason) {
                    console.warn("连接 socket websocket onclose");
                    _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER +
                        " websocket close call  " +
                        JSON.stringify(reason));
                };
                this.websocket.onerror = function (err) {
                    _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER +
                        " websocket onerror call  " +
                        JSON.stringify(err));
                };
                if (this.useNetAgent && this.websocket instanceof analogSocket_1.AnalogSocket) {
                    // 统一接入是在连接服务前发送token登录请求
                    this.websocket.onopen = function () {
                        console.warn("连接 socket websocket open");
                        //register onMessage
                        _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER + " websocket open call");
                        _this.bindWebSocketEvents();
                        _this.state = zego_entity_1.ENUM_CONNECT_STATE.connected;
                        _this.websocket &&
                            (_this.websocket.onmessage = _this.handleWsMessage.bind(_this));
                    };
                    this.websocket.onreconnnecting = function () {
                        console.warn("连接 socket websocket onreconnnecting");
                        _this.updateToken();
                    };
                    //update token
                    this.websocket.onmessage = this.handleWsMessage.bind(this);
                    this.updateToken();
                }
                else {
                    this.websocket.onopen = function () {
                        //reset connect timer
                        _this.resetConnectTimer();
                        //register onMessage
                        _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER + " websocket open call");
                        _this.websocket &&
                            (_this.websocket.onmessage = _this.handleWsMessage.bind(_this));
                        _this.bindWebSocketEvents();
                        //update token
                        _this.updateToken();
                        _this.state = zego_entity_1.ENUM_CONNECT_STATE.connected;
                    };
                }
            }
            catch (e) {
                this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER + " websocket error " + e);
            }
        }
        else {
            //websocket is already connect
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER + " websocket is connected");
            this.resetConnectTimer();
            this.state = zego_entity_1.ENUM_CONNECT_STATE.connected;
        }
        // 依赖统一接入重试后SDK不用重试节点
        if (!this.useNetAgent) {
            //单个节点目前只试一次，一组节点轮询三次
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER + " " + this.tryConnectInterval);
            this.tryConnectTimer = setTimeout(function () {
                _this.startConnectTimer(result);
            }, this.tryConnectInterval);
        }
    };
    ZegoSignal.prototype.startConnectTimer = function (callback) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_START_CONNECT_TIMER + " call");
        if (this.tryConnectCount >= zego_entity_1.MAX_TRY_CONNECT_COUNT) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_START_CONNECT_TIMER +
                " beyond " +
                this.server +
                "max limit");
            this.disconnectCallback();
            return;
        }
        if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
            this.tryConnectCount += 1;
            this.connectServer(this.roomID, this.token, this.server, callback);
        }
        else {
            //already connect
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_START_CONNECT_TIMER +
                " websocket is connected");
            this.resetConnectTimer();
        }
    };
    //rtc信令断开连接
    ZegoSignal.prototype.disconnectServer = function () {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_DISCONNECT_SERVER + " call");
        //this.server = null;
        this.connectCallback = null;
        this.resetCheckMessage();
        this.resetConnectTimer();
        if (this.websocket) {
            this.websocket.onclose = null;
            this.websocket.onerror = null;
            this.websocket.close();
            this.websocket = null;
        }
        this.token = "";
        this.sessionInfos = {};
        this.tokenType = 0;
        this.tryHeartbeatCount = 0;
        this.tryConnectCount = 0;
        this.state = zego_entity_1.ENUM_CONNECT_STATE.disconnect;
    };
    Object.defineProperty(ZegoSignal.prototype, "isServerConnected", {
        get: function () {
            var _a;
            return ((_a = this.websocket) === null || _a === void 0 ? void 0 : _a.readyState) === WebSocket.OPEN;
        },
        enumerable: false,
        configurable: true
    });
    ZegoSignal.prototype.createSession = function (seq, type, mode, streamId, strAuthParam, serverHost, success, error) {
        if (strAuthParam === void 0) { strAuthParam = ""; }
        if (serverHost === void 0) { serverHost = ""; }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CREATE_SESSION + " call: " + streamId);
        var sdkversion = "";
        zego_entity_1.PROTO_VERSION.split(".").forEach(function (e, ind) {
            return e.length == 1 && ind == 1 ? (sdkversion += "0" + e) : (sdkversion += e);
        });
        var cmd = "CreateSessionReq";
        var body = {
            type: type,
            stream_id: streamId,
            platform: this.platform,
            browser: this.browser.name,
            version: this.browser.version,
            app_id: this.appid,
            negotiate_mode: mode,
            strAuthParam: strAuthParam,
            sdk_version: sdkversion * 1,
            turn_server_host: typeof serverHost == "string" ? serverHost : ""
        };
        // //publish
        // if (type == 0) {
        //         body['negotiate_mode'] = 0;
        // } else {
        //         body['negotiate_mode'] = 1;
        // }
        this.sendMessageWithCallback(cmd, seq, 0, body, success, error);
    };
    ZegoSignal.prototype.createSessionWithSdp = function (options, success, error) {
        var seq = options.seq, type = options.type, streamId = options.streamId, strAuthParam = options.strAuthParam, sdp = options.sdp, serverHost = options.serverHost, playBufLevel = options.playBufLevel;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CREATE_SESSION + " call: " + streamId);
        var sdkversion = "";
        zego_entity_1.PROTO_VERSION.split(".").forEach(function (e, ind) {
            return e.length == 1 && ind == 1 ? (sdkversion += "0" + e) : (sdkversion += e);
        });
        var cmd = "CreateSessionWithSdpReq";
        var body = {
            type: type,
            app_id: this.appid,
            stream_id: streamId,
            sdp: sdp,
            user_id: this.userid,
            platform: this.platform,
            browser: this.browser.name,
            sdk_vers: parseInt(sdkversion),
            clientIp: "",
            media_server_host: typeof serverHost == "string" ? serverHost : "",
            strAuthParam: strAuthParam
        };
        if (playBufLevel) {
            body.min_play_buf_level_ms = playBufLevel;
        }
        // if (this.stateCenter.gatewayIP) {
        //     body.test_gw_nodeip = this.stateCenter.gatewayIP;
        // }
        this.sendMessageWithCallback(cmd, seq, 0, body, success, error);
    };
    ZegoSignal.prototype.sendMediaDescUpdateReq = function (seq, sessionID, description, success, error) {
        var body = {
            peer_id: description.peerID,
            type: description.type,
            sdp: description.sdp,
            width: description.width,
            height: description.height,
            framerate: description.frameRate,
            video_min_kpbs: description.video_min_kpbs,
            video_max_kpbs: description.video_max_kpbs,
            audio_kpbs: description.audio_kpbs,
            keyframe_intv: description.keyframe_intv
        };
        var cmd = "MediaDescUpdateReq";
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    };
    ZegoSignal.prototype.removeSession = function (sessionID) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_REMOVE_SESSION + " call" + sessionID);
        if (this.sessionInfos[sessionID]) {
            delete this.sessionInfos[sessionID];
        }
    };
    ZegoSignal.prototype.sendCloseSession = function (seq, sessionID, reason, success, error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_REMOVE_SESSION + " call: " + sessionID);
        var cmd = "CloseSessionReq";
        var body = {
            reason: reason
        };
        this.removeSession(sessionID);
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    };
    ZegoSignal.prototype.sendMessage = function (cmd, seq, sessionID, body) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MESSAGE + " call " + cmd);
        if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MESSAGE + " connect not establish");
            return;
        }
        var header = this.getHeader(cmd, seq, sessionID);
        var data = {
            header: header,
            body: body
        };
        var dataBuffer = JSON.stringify(data);
        this.websocket.send(dataBuffer);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MESSAGE + " success");
    };
    ZegoSignal.prototype.handleRespondData = function (cmd, msg) {
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_HANDLE_RESPOND_DATA + " call");
        //callback
        var sendDataNode = this.sendDataMap[msg.header.seq];
        if (sendDataNode == null) {
            if (msg.header.cmd == "CloseSessionRsp")
                return;
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_HANDLE_RESPOND_DATA +
                " cannot find data " +
                cmd);
            return;
        }
        var sendData = sendDataNode._data;
        if (sendData.cmd !== cmd) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_HANDLE_RESPOND_DATA + " command is not match");
        }
        else if (sendData.success) {
            sendData.success(msg.header.seq, msg.header.session_id, msg.body);
        }
        delete this.sendDataMap[msg.header.seq];
        this.sendDataList.remove(sendDataNode);
    };
    ZegoSignal.prototype.addSession = function (sessionID, token) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_ADD_SESSION + " call" + sessionID);
        this.sessionInfos[sessionID] = {
            token: token
        };
    };
    ZegoSignal.prototype.handlePushData = function (msg) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_HANDLE_PUSH_DATA +
            " call " +
            msg.header.cmd +
            " session " +
            msg.header.session_id);
        var callbackData = this.pushCallback[msg.header.cmd + msg.header.session_id];
        if (!callbackData) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_HANDLE_PUSH_DATA +
                " no callbackData " +
                msg.header.cmd +
                " session: " +
                msg.header.session_id);
            return;
        }
        if (callbackData.callback) {
            callbackData.callback(msg.header.seq, msg.header.session_id, msg.body);
        }
    };
    ZegoSignal.prototype.handlePushResetSessionData = function (msg) {
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_HANDLE_PUSH_RESET_SESSION_DATA + " call ");
        var sessionList = [];
        if (msg.body.cResetType == 0) {
            sessionList = Object.keys(this.sessionInfos);
        }
        else if (msg.body.cResetType == 1) {
            for (var i = 0; i < msg.body.session_ids.length; i++) {
                sessionList.push(msg.body.session_ids[i]);
            }
        }
        //send ack
        this.sendResetSessionAck(msg.header.seq, 0, 0);
        if (sessionList.length == 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_HANDLE_PUSH_RESET_SESSION_DATA +
                " no session to callback");
            return;
        }
        for (var j = 0; j < sessionList.length; j++) {
            var callbackData = this.pushCallback[msg.header.cmd + sessionList[j]];
            if (callbackData == null) {
                this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_HANDLE_PUSH_RESET_SESSION_DATA +
                    " no callbackData " +
                    sessionList[j]);
            }
            else {
                if (callbackData.callback) {
                    callbackData.callback(msg.header.seq, sessionList[j], msg.body);
                }
            }
        }
    };
    ZegoSignal.prototype.sendMediaDesc = function (seq, sessionID, type, desc, success, error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MEDIA_DESC + " call: " + sessionID);
        var cmd = "MediaDescReq";
        var body = {
            type: type,
            sdp: desc.sdp
        };
        if (desc.width != undefined) {
            body["width"] = desc.width;
        }
        if (desc.height != undefined) {
            body["height"] = desc.height;
        }
        if (desc.frameRate != undefined) {
            body["framerate"] = desc.frameRate;
        }
        if (desc.video_min_kpbs != undefined) {
            body["video_min_kpbs"] = desc.video_min_kpbs;
        }
        if (desc.video_max_kpbs != undefined) {
            body["video_max_kpbs"] = desc.video_max_kpbs;
        }
        if (desc.audio_kpbs != undefined) {
            body["audio_kpbs"] = desc.audio_kpbs;
        }
        if (desc.keyframe_intv != undefined) {
            body["keyframe_intv"] = desc.keyframe_intv;
        }
        if (desc.min_play_buf_level_ms != undefined) {
            body["min_play_buf_level_ms"] = desc.min_play_buf_level_ms;
        }
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    };
    ZegoSignal.prototype.sendCandidateInfo = function (seq, sessionID, candidateList, success, error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_CANDIDATE_INFO + " call: " + sessionID);
        var cmd = "CandidateInfoReq";
        var dataList = [];
        for (var i = 0; i < candidateList.length; i++) {
            var info = {
                candidate: candidateList[i].candidate,
                sdpMid: candidateList[i].sdpMid,
                sdpMLineIndex: candidateList[i].sdpMLineIndex
            };
            dataList.push(info);
        }
        var body = {
            infos: dataList
        };
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    };
    ZegoSignal.prototype.sendMediaDescAck = function (seq, sessionID, result) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MEDIA_DESC_ACK + " call: " + sessionID);
        var cmd = "MediaDescAck";
        var body = {
            result: result
        };
        this.sendMessage(cmd, seq, sessionID, body);
    };
    ZegoSignal.prototype.sendUpdateMediaDescAck = function (seq, sessionID, result, peerID) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MEDIA_DESC_ACK + " call: " + sessionID);
        var cmd = "MediaDescUpdateAck";
        var body = {
            peer_id: peerID,
            result: result
        };
        this.sendMessage(cmd, seq, sessionID, body);
    };
    ZegoSignal.prototype.sendCandidateInfoAck = function (seq, sessionID, result) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_CANDIDATE_INFO_ACK + " call: " + sessionID);
        var cmd = "CandidateInfoAck";
        var body = {
            result: result
        };
        this.sendMessage(cmd, seq, sessionID, body);
    };
    ZegoSignal.prototype.sendCloseSessionAck = function (seq, sessionID, result) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_CLOSE_SESSION_ACK + " call: " + sessionID);
        var cmd = "CloseSessionAck";
        var body = {
            result: result
        };
        this.sendMessage(cmd, seq, sessionID, body);
    };
    ZegoSignal.prototype.sendResetSessionAck = function (seq, sessionID, result) {
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_RESET_SESSION_ACK + " call: " + sessionID);
        var cmd = "SessionResetAck";
        var body = {
            result: result
        };
        this.sendMessage(cmd, seq, sessionID, body);
    };
    ZegoSignal.prototype.registerPushCallback = function (cmd, sessionID, callback) {
        if (callback && typeof callback === "function") {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_REGISTER_PUSH_CALLBACK +
                " set callback " +
                sessionID);
            this.pushCallback[cmd + sessionID] = { callback: callback };
        }
    };
    ZegoSignal.prototype.unregisterPushCallback = function (cmd, sessionID) {
        delete this.pushCallback[cmd + sessionID];
    };
    ZegoSignal.prototype.checkMessageTimeout = function () {
        var _this = this;
        var head = this.sendDataList.getFirst();
        var timestamp = new Date().getTime();
        var checkCount = 0;
        var timeoutMsgCount = 0;
        var dropMsgCount = 0;
        while (head != null) {
            if (head._data.time + this.sendDataTimeout > timestamp) {
                break;
            }
            delete this.sendDataMap[head._data.seq];
            this.sendDataList.remove(head);
            ++timeoutMsgCount;
            if (this.checkMessageList.indexOf(head._data.cmd) == -1) {
                head = this.sendDataList.getFirst();
                continue;
            }
            if (head._data.error == null ||
                (this.sendDataDropTimeout > 0 &&
                    head._data.time + this.sendDataDropTimeout < timestamp)) {
                ++dropMsgCount;
            }
            else {
                this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CHECK_MESSAGE_TIMEOUT +
                    " error cmd = " +
                    head._data.cmd);
                if (head._data.error)
                    head._data.error(zego_entity_1.SEND_MSG_TIMEOUT, head._data.seq);
            }
            ++checkCount;
            if (checkCount >= this.sendDataCheckOnceCount) {
                break;
            }
            head = this.sendDataList.getFirst();
        }
        this.sendDataCheckTimer = setTimeout(function () {
            _this.checkMessageTimeout();
        }, this.sendDataCheckInterval);
        if (timeoutMsgCount != 0 || dropMsgCount != 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CHECK_MESSAGE_TIMEOUT +
                " call success, state: timeout=" +
                timeoutMsgCount +
                " drop=" +
                dropMsgCount);
        }
    };
    ZegoSignal.prototype.sendHeartbeat = function () {
        var _this = this;
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_HEARTBEAT +
            "call tryHeartbeatCount:" +
            this.tryHeartbeatCount);
        if (Object.keys(this.sessionInfos).length == 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_HEARTBEAT + " no need to heartbeat");
            return;
        }
        if (this.state !== zego_entity_1.ENUM_CONNECT_STATE.connected) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_HEARTBEAT + " state error");
            return;
        }
        if (++this.tryHeartbeatCount > zego_entity_1.MAX_TRY_HEARTBEAT_COUNT) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_HEARTBEAT + " heartbeat try limit");
            this.disconnectCallback();
            return;
        }
        var sessionIdList = [];
        for (var sessionID in this.sessionInfos) {
            sessionIdList.push(parseInt(sessionID));
        }
        var body = {
            session_ids: sessionIdList
        };
        this.sendMessageWithCallback("ClientHBReq", this.stateCenter.getSeq(), 0, body, function (seq, sessionID, data) {
            if (_this.heartbeatInterval != data.hb_interval) {
                _this.heartbeatInterval = data.hb_interval;
                _this.onUpdateHeartBeatInterval(data.hb_interval);
            }
            _this.tryHeartbeatCount = 0;
        }, function (err, seq) {
            // this.tryHeartbeatCount += 1;
        });
    };
    ZegoSignal.prototype.QualityReport = function (seq, sessionID, qualityStat, success, error) {
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_QUALITY_REPORT + " call");
        var cmd = "QualityReportReq";
        var body = {
            streams: [
                __assign(__assign({}, qualityStat), {
                    aid: sessionID
                })
            ]
        };
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    };
    ZegoSignal.prototype.sendStreamStatus = function (seq, sessionID, camera, microphone, streamID, timeoutHandler) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_STREAM_STATUS + " call " + sessionID);
        var cmd = "StreamStatusNotify";
        var body = {
            mic_status: microphone,
            camera_status: camera
        };
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_STREAM_STATUS + " stream " + (streamID ||
            "") + " status " + JSON.stringify(body));
        this.sendMessageWithCallback(cmd, seq, sessionID, body, function () { }, function (error) {
            if (error === zego_entity_1.SEND_MSG_TIMEOUT) {
                timeoutHandler && timeoutHandler();
            }
        });
    };
    ZegoSignal.prototype.ActivatePlayVideoStream = function (seq, sessionID, mute, success, error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_ACTIVE_PLAY_VIDEO_STREAM + " call");
        var cmd = "ActivateVideoPlayStreamReq";
        var body = {
            active: mute ? 0 : 1,
            layer: 0
        };
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_ACTIVE_PLAY_VIDEO_STREAM +
            " activate video " +
            JSON.stringify(body));
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    };
    ZegoSignal.prototype.ActivatePlayAudioStream = function (seq, sessionID, mute, success, error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_ACTIVE_PLAY_AUDIO_STREAM + " call");
        var cmd = "ActivateAudioPlayStreamReq";
        var body = {
            active: mute ? 0 : 1,
            layer: 0
        };
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_ACTIVE_PLAY_AUDIO_STREAM +
            " activate audio " +
            JSON.stringify(body));
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    };
    ZegoSignal.prototype.sendBroadcasterStatus = function (seq, sessionID, status) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_BROADCAST_STATUS + " call " + sessionID);
        var cmd = "BroadcasterStatusNotify";
        var body = {
            status: status
        };
        this.sendMessage(cmd, seq, sessionID, body);
    };
    ZegoSignal.prototype.sendNetProbe = function (seq, sessionID, peerID, success, error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_NET_PROBE + " call " + sessionID);
        var cmd = "NetQualityProbeReq";
        var body = {
            peer_id: peerID,
            action: 1
        };
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    };
    ZegoSignal.prototype.sendNetQualityInfoPushAck = function (seq, sessionID, peerID, result) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_NET_PROBE + " call " + sessionID);
        var cmd = "NetQualityInfoAck";
        var body = {
            peer_id: peerID,
            result: result
        };
        this.sendMessage(cmd, seq, sessionID, body);
    };
    ZegoSignal.prototype.activateSEIInsert = function (seq, sessionID, peerID, action, infoType, success, error) { };
    // 关于最终上报的端到端延迟说明：
    // 1 由于目前没有办法精确测量单向延时(one-way-delay),所以在sdk拿到推流端到拉流端的往返时延（p2p_rtt) 后，以 p2p_rtt / 2 做为单向延迟。
    // 2 拉流端在接收到媒体数据之后一般做jitter buffer处理才会解码，所以最终主观感受的延迟需要加上这一部分时间： jitter_delay。
    //  如果拉流只有音频或者音视频都有，jitter_delay =  googCurrentDelayMs(音频流)
    //  如果拉流只有视频，jitter_delay =  googCurrentDelayMs(视频流)
    // 最终上报 p2p_delay = p2p_rtt / 2 + jitter_delay
    ZegoSignal.prototype.getP2PNetStats = function (seq, sessionID, peerID, success, error) {
        var cmd = "Peer2PeerNetStatsGetReq";
        var body = {
            peer_id: peerID
        };
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    };
    return ZegoSignal;
}());
exports.ZegoSignal = ZegoSignal;


/***/ }),

/***/ "./sdk/src/webrtc/modules/zego.streamCenter.web.ts":
/*!*********************************************************!*\
  !*** ./sdk/src/webrtc/modules/zego.streamCenter.web.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoStreamCenterWeb = void 0;
var zego_entity_1 = __webpack_require__(/*! ../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var zego_preview_1 = __webpack_require__(/*! ./publishModules/zego.preview */ "./sdk/src/webrtc/modules/publishModules/zego.preview.ts");
var zego_publish_1 = __webpack_require__(/*! ./publishModules/zego.publish */ "./sdk/src/webrtc/modules/publishModules/zego.publish.ts");
var streamCenter_1 = __webpack_require__(/*! ../../common/streamCenter */ "./sdk/src/common/streamCenter.ts");
var zego_entity_2 = __webpack_require__(/*! ../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var streamSignal_1 = __webpack_require__(/*! ./streamSignal */ "./sdk/src/webrtc/modules/streamSignal.ts");
var zego_play_web_1 = __webpack_require__(/*! ./playModules/zego.play.web */ "./sdk/src/webrtc/modules/playModules/zego.play.web.ts");
var retryStreamHandler_1 = __webpack_require__(/*! ./externModules/retryStreamHandler */ "./sdk/src/webrtc/modules/externModules/retryStreamHandler.ts");
var retryDispatchHandler_1 = __webpack_require__(/*! ./externModules/retryDispatchHandler */ "./sdk/src/webrtc/modules/externModules/retryDispatchHandler.ts");
var zego_error_1 = __webpack_require__(/*! ../../common/zego.error */ "./sdk/src/common/zego.error.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var speed_log_1 = __webpack_require__(/*! ../../proto/speed_log */ "./sdk/src/proto/speed_log.js");
var ZegoStreamCenterWeb = /** @class */ (function (_super) {
    __extends(ZegoStreamCenterWeb, _super);
    function ZegoStreamCenterWeb(logger, stateCenter, dataReport, rtm, ac, mediaEleSources) {
        var _this = _super.call(this) || this;
        _this.logger = logger;
        _this.stateCenter = stateCenter;
        _this.dataReport = dataReport;
        _this.rtm = rtm;
        _this.ac = ac;
        _this.mediaEleSources = mediaEleSources;
        _this.testEnvironment = false;
        //由streamcenter统一管理每个signal的心跳逻辑
        _this.heartbeatTimer = null;
        _this.heartbeatInterval = 10 * 1000;
        //质量回调时间间隔,默认3s
        _this.qualityTimerInterval = 3 * 1000;
        _this.previewStreamList = [];
        _this.signalList = {};
        //人头计费上报
        _this.chargeInfos = {
            itemtype: "ChargeInfos",
            timestamp_begin: 0,
            timestamp_end: 0,
            timestamp_diff_flag: 0,
            timestamp_diff: 0,
            infos: []
        };
        _this.chargeInfosTimer = null;
        _this.chargeInfosInterval = 60 * 1000;
        _this.chargeInfoSeq = 0;
        _this.soundLevelDelegate = false;
        _this.soundLevelInterval = 1000;
        //peer模式
        _this.isPeer = true;
        //探测相关
        _this.probeList = {};
        // 麦克风是否启用
        _this.isMicEnabled = true;
        //是否开启datachannel
        _this.isDataChannelEnabled = false;
        //质量上报
        _this.publishQualityInfos = [];
        _this.playQualityInfos = [];
        _this.qualityUploadTimestamp = 0;
        _this.qualityHeadTimestamp = 0;
        //自定义gwNode
        _this.gwNode = "";
        _this.playerList = {};
        _this.publisherList = {};
        _this.playSuccessCallBackList = {};
        _this.playErrorCallBackList = {};
        _this.waitPublishList = [];
        _this.waitPlayList = [];
        _this.tryCountConnectInterval = 3000;
        _this.checkMessageTimeout = function () {
            for (var serverUrl in _this.signalList) {
                if (_this.signalList[serverUrl].signal) {
                    _this.signalList[serverUrl].signal.checkMessageTimeout();
                }
            }
        };
        _this.getAllInUseUrl = function () {
            var serverUrls = [];
            for (var serverUrl in _this.signalList) {
                serverUrls.push(serverUrl);
            }
            return serverUrls;
        };
        // 当媒体信令断开时通知所有推拉流停止，并进行相应处理。
        _this.onDisconnectHandle = function (server, error) {
            _this.logger.info("zsc.od.0 call");
            if (_this.signalList[server]) {
                var signalInfo = _this.signalList[server];
                for (var i = 0; i < signalInfo.publishConnectedList.length; i++) {
                    var publish = _this.publisherList[signalInfo.publishConnectedList[i]];
                    if (publish && publish.publisher) {
                        publish.publisher.onDisconnect(error);
                    }
                }
                for (var i = 0; i < signalInfo.playConnectedList.length; i++) {
                    var play = _this.playerList[signalInfo.playConnectedList[i]];
                    if (play && play.player) {
                        play.player.onDisconnect(error);
                    }
                }
                delete _this.signalList[server];
                _this.stopSignalHeartbeat();
                _this.stopChargeInfosUpload();
                _this.stopSoundLevel();
            }
        };
        _this.stateCenter.type == "PRIVATE" && (_this.isPeer = false);
        return _this;
    }
    Object.defineProperty(ZegoStreamCenterWeb.prototype, "cameraPreviewStream", {
        /**
         * 摄像头预览流
         */
        get: function () {
            return this.previewStreamList.find(function (item) {
                return item.previewType === "camera";
            });
        },
        enumerable: false,
        configurable: true
    });
    ZegoStreamCenterWeb.prototype.onSignalDisconnected = function (server) { };
    /*
     *    "zsc.qmc.0": "ZegoStreamCenter.setQualityMonitorCycle"
     */
    ZegoStreamCenterWeb.prototype.setQualityMonitorCycle = function (timeInMs) {
        var _this = this;
        this.logger.debug("zsc.qmc.0 timeInterval " + timeInMs);
        if (Object.keys(this.publisherList).length == 0) {
            this.qualityTimerInterval = timeInMs;
        }
        else {
            Object.keys(this.publisherList).forEach(function (streamid) {
                _this.publisherList[streamid].publisher.qualityTimeInterval = timeInMs;
                _this.publisherList[streamid].publisher.setPublishQualityTimer();
            });
        }
        return true;
    };
    /*
     *    "zsc.ssi.0": "ZegoStreamCenter.setSessionInfo"
     */
    ZegoStreamCenterWeb.prototype.setSessionInfo = function (appid, userid, testEnvironment) {
        this.logger.debug("zsc.ssi.0 called");
        // this.signal.setSessionInfo(appid, userid, serverUrl);
        this.appid = appid;
        this.userid = userid;
        this.testEnvironment = testEnvironment;
    };
    ZegoStreamCenterWeb.prototype.onPlayStateUpdate = function (type, streamid, error) { };
    ZegoStreamCenterWeb.prototype.onPlayQualityUpdate = function (streamID, streamQuality) { };
    ZegoStreamCenterWeb.prototype.onPublishStateUpdate = function (type, streamid, error) { };
    ZegoStreamCenterWeb.prototype.onPublishQualityUpdate = function (streamID, streamQuality) { };
    ZegoStreamCenterWeb.prototype.onUpdateHeartBeatIntervalHandle = function (interval) {
        if (interval != this.heartbeatInterval) {
            this.logger.debug("zsc.uhb.0 update " + interval);
            if (this.heartbeatTimer) {
                clearTimeout(this.heartbeatTimer);
                this.heartbeatTimer = null;
            }
            this.heartbeatInterval = interval;
            this.startSignalHeartbeat();
        }
    };
    ZegoStreamCenterWeb.prototype.setPublishStateStart = function (room, streamid, localStream, publishOption, isDataChannel) {
        var _this = this;
        var _a, _b;
        this.logger.info("zsc.pss.0 call " + streamid);
        if (this.stateCenter.networkState == zego_entity_1.ENUM_NETWORK_STATE.offline) {
            this.logger.error("zsc.pss.0 network offline");
            return false;
        }
        var publish = this.publisherList[streamid];
        var reportSeq = this.stateCenter.reportSeqList.startPublish[streamid];
        this.dataReport.eventStart(reportSeq, "setPublishState");
        if (publish) {
            this.logger.error("zsc.pss.0 publisher already exist");
            this.dataReport.eventEndWithMsgInfo(reportSeq, "setPublishState", {
                message: "publisher already exist"
            });
            this.dataReport.uploadReport(reportSeq, undefined, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kIsPublishing);
            delete this.stateCenter.reportSeqList.startPublish[streamid];
            return false;
        }
        var publisher = new zego_publish_1.ZegoPublish(streamid, this.logger, this.dataReport, this.qualityTimerInterval, this, this.ac, this.mediaEleSources, this.stateCenter, localStream);
        publisher.state = zego_entity_2.ENUM_PUBLISH_STATE.start;
        publisher.isPeer = this.isPeer;
        publisher.reportSeq = this.stateCenter.reportSeqList.startPublish[streamid];
        var previewer = publisher.previewer;
        var cameraLabel = (_a = previewer === null || previewer === void 0 ? void 0 : previewer.videoTrack) === null || _a === void 0 ? void 0 : _a.label;
        var microLabel = localStream.getAudioTracks()[0] && localStream.getAudioTracks()[0].label;
        var cameraDeviceId = (_b = previewer === null || previewer === void 0 ? void 0 : previewer.videoTrack) === null || _b === void 0 ? void 0 : _b.getSettings().deviceId;
        var microDeviceId = localStream.getAudioTracks()[0] &&
            localStream.getAudioTracks()[0].getSettings().deviceId;
        var retryStreamHandler = new retryStreamHandler_1.RetryStreamHandler(this.logger, this.stateCenter, this, true);
        this.publisherList[streamid] = {
            seq: 0,
            room: room,
            localStream: localStream,
            publisher: publisher,
            serverUrls: [],
            ttl: 0,
            isCenterNode: true,
            streamID: streamid,
            publishOption: publishOption,
            cameraLabel: cameraLabel || "",
            microLabel: microLabel || "",
            cameraDeviceId: cameraDeviceId || "",
            microDeviceId: microDeviceId || "",
            deviceStateCount: 0,
            retryStreamHandler: retryStreamHandler,
            retryDispatchHandler: new retryDispatchHandler_1.RetryDispatchHandler(this.logger, this.stateCenter, this.rtm, this),
            isDataChannel: isDataChannel
        };
        publisher.onPublishStateUpdate = function (type, _streamid, error, stopRetry) {
            var publish = _this.publisherList[_streamid];
            if (publish) {
                retryStreamHandler.publishStateHandle(type, publish.streamID, error, stopRetry);
            }
            else {
                _this.logger.error("zsc.psuh.0 cannot find publish " + streamid);
            }
        };
        publisher.onPublishQualityUpdate = function (_streamid, streamQuality) {
            var publish = _this.publisherList[_streamid];
            if (publish) {
                if (_this.stateCenter.deviceStateOut &&
                    streamQuality.audio.audioBitrate === 0) {
                    publish.deviceStateCount++;
                    if (publish.deviceStateCount >= 2) {
                        publish.deviceStateCount = 0;
                        _this.stateCenter.deviceStateOut = false;
                        _this.logger.warn("zsc.pss.0 publish audio error by device");
                        // this.onPublishStateUpdate(
                        //     ENUM_PUBLISH_STATE_UPDATE.error,
                        //     publish.streamID,
                        //     errorCodeList.PUBLISH_DEVICE_OUT_ERR,
                        // );
                    }
                }
                else {
                    publish.deviceStateCount = 0;
                }
                _this.onPublishQualityUpdate(publish.streamID, streamQuality);
            }
            else {
                _this.logger.error("zsc.psuh.0 cannot find publish " + streamid);
            }
        };
        this.dataReport.eventStart(publisher.reportSeq, "GetSignalUrl");
        this.dataReport.eventStart(publisher.streamReportSeq, "GetSignalUrl");
        return true;
    };
    ZegoStreamCenterWeb.prototype.startPublishingStream = function (streamid, useNetAgent) {
        if (useNetAgent === void 0) { useNetAgent = false; }
        this.logger.info("zsc.sps.0 call");
        //const totalStreamid = this.getTotalStreamId(streamid);
        var publish = this.publisherList[streamid];
        if (!publish) {
            this.logger.error("zsc.sps.0 publisher don't exist");
            return false;
        }
        var publisher = publish.publisher;
        if (useNetAgent) {
            // TODO: 统一接入调度连接媒体
        }
        else {
            // 非统一接入需要处理重试媒体节点
            this.dataReport.eventEndWithMsg(publisher.reportSeq, "GetSignalUrl", {
                urls: publish.serverUrls,
                is_center: publish.isCenterNode
            });
            this.dataReport.eventEndWithMsg(publisher.streamReportSeq, "GetSignalUrl", {
                urls: publish.serverUrls,
                is_center: publish.isCenterNode
            });
            if (!publish.serverUrls || publish.serverUrls.length === 0) {
                publish.retryStreamHandler.publishStateHandle(zego_entity_2.ENUM_PUBLISH_STATE_UPDATE.error, streamid, zego_error_1.errorCodeList.DISPATCH_ERROR);
                this.logger.info("zsc.sps.0 server don't have signal url");
                return true;
            }
            var index = publish.serverUrls.indexOf(this.server);
            if (index !== -1) {
                publish.serverUrls.splice(index, 1);
                publish.serverUrls.unshift(this.server);
            }
        }
        var retryStreamHandler = publish.retryStreamHandler;
        //流重试初始化
        retryStreamHandler.invalid();
        retryStreamHandler.init(this.stateCenter.streamRetryTime);
        retryStreamHandler.initStream(streamid, publish.serverUrls);
        retryStreamHandler.startMaxTime();
        return retryStreamHandler.activePublish(0);
    };
    ZegoStreamCenterWeb.prototype.updateWaitingList = function (signalInfo, isPublish, streamID, success, error) {
        var waitingItem = {
            streamID: streamID,
            success: success,
            error: error
        };
        if (isPublish) {
            signalInfo.publishWaitingList.push(waitingItem);
        }
        else {
            signalInfo.playWaitingList.push(waitingItem);
        }
    };
    ZegoStreamCenterWeb.prototype.publishStream = function (streamid) {
        var publisher = this.publisherList[streamid].publisher;
        if (!publisher) {
            this.logger.info("zsc.ps.0 publisher don't exist");
            return;
        }
        var localStream = null, videoInfo = null;
        var publishOption = this.publisherList[streamid].publishOption;
        var preview = this.checkPreview(this.publisherList[streamid].localStream);
        if (preview) {
            localStream = preview.localStream;
            videoInfo = preview.videoInfo;
            var reportSeq = this.stateCenter.reportSeqList.startPublish[streamid];
            this.dataReport.addMsgInfo(reportSeq, {
                cap_w: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.cap_w(preview.videoInfo.width),
                cap_h: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.cap_h(preview.videoInfo.height),
                w: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.w(preview.videoInfo.width),
                h: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.h(preview.videoInfo.height),
                video_en_fps: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.video_en_fps(preview.videoInfo.frameRate),
                video_en_bps: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.video_en_bps(preview.videoInfo.bitRate)
            });
        }
        else {
            this.logger.error("zsc.ps.0 no preview found");
            return;
        }
        if (!localStream) {
            this.logger.error("zsc.ps.0 no localStream found");
            return;
        }
        this.logger.info("zsc.ps.0 call success");
        if (publisher.gwNodeTTL < new Date().getTime() && !this.gwNode) {
            publisher.gwNode = "";
            publisher.gwNodeList = [];
            publisher.gwNodeTTL = 0;
        }
        else if (this.gwNode) {
            publisher.gwNode = this.gwNode;
        }
        publisher.startPublish(streamid, localStream, videoInfo, preview.mediaStreamConfig, publishOption);
    };
    ZegoStreamCenterWeb.prototype.connectPublishServer = function (streamID, server) {
        var _this = this;
        var publish = this.publisherList[streamID];
        if (!publish) {
            this.logger.error("zsc.cps.0 publisher don't exist");
            return false;
        }
        this.dataReport.eventStart(publish.publisher.reportSeq, "ConnectServer");
        this.dataReport.eventStart(publish.publisher.streamReportSeq, "ConnectServer");
        var useNetAgent = this.stateCenter.useNetAgent;
        this.connectWithReuseSignalServer(streamID, true, server, function (streamid, signalInfo, serverUrl) {
            //check streamid exist
            var checkPublish = _this.publisherList[streamid];
            if (!checkPublish) {
                _this.logger.info("zsc.cps.0 after connect publisher don't exist");
                return;
            }
            var checkPublisher = checkPublish.publisher;
            if (!checkPublisher) {
                _this.logger.info("zsc.cps.1 check publisher don't exist");
                return;
            }
            _this.dataReport.eventEndWithMsg(checkPublisher.reportSeq, "ConnectServer", {
                result: 0,
                server: serverUrl
            });
            _this.dataReport.eventEndWithMsg(checkPublisher.streamReportSeq, "ConnectServer", {
                result: 0,
                server: serverUrl
            });
            var tokenInfo = signalInfo.tokenInfo;
            _this.logger.info("zsc.cps.0 update token success");
            if (tokenInfo && tokenInfo.report) {
                checkPublisher.qualityUpload = tokenInfo.report;
                checkPublisher.qualityUploadInterval = tokenInfo.report_interval;
            }
            checkPublisher.signal = signalInfo.signal;
            _this.server = serverUrl;
            _this.publishStream(streamid);
            _this.getTokenSuccess();
        }, function (streamID, result) {
            _this.logger.error("zsc.cps.0 " + streamID + " connect fail " + result);
            //check streamid exist
            var checkPublish = _this.publisherList[streamID];
            if (!checkPublish) {
                _this.logger.info("zsc.cps.0 after connect publisher don't exist");
                return;
            }
            var checkPublisher = checkPublish.publisher;
            if (!checkPublisher) {
                _this.logger.info("zsc.cps.1 check publisher don't exist");
                return;
            }
            _this.dataReport.eventEndWithMsg(checkPublisher.reportSeq, "ConnectServer", {
                result: result
            });
            _this.dataReport.uploadReport(checkPublisher.reportSeq);
            delete _this.stateCenter.reportSeqList.startPublish[streamID];
            var error;
            var stopRetry = false;
            if (result && result.code === zego_error_1.errorCodeList.GET_CONFIG_FAIL.code) {
                error = zego_error_1.errorCodeList.GET_CONFIG_FAIL;
                stopRetry = true;
            }
            else {
                error = __assign({}, zego_error_1.errorCodeList.CONNECT_FAILED);
                error.message = error.message + " " + result;
                if (result === 1008) {
                    error = zego_error_1.errorCodeList.TOKEN_EXPIRED;
                    stopRetry = true;
                }
            }
            checkPublish.retryStreamHandler.publishStateHandle(zego_entity_2.ENUM_PUBLISH_STATE_UPDATE.error, streamID, error, stopRetry);
        });
        return true;
    };
    /*
     *    "zsc.gts.0": "ZegoStreamCenter.getTokenSuccess"
     */
    ZegoStreamCenterWeb.prototype.getTokenSuccess = function () {
        this.logger.debug("zsc.gts.0 call");
    };
    /*
     *    "zsc.sps.0.1": "ZegoStreamCenter.stopPublishingStream"
     */
    ZegoStreamCenterWeb.prototype.stopPublishingStream = function (streamid) {
        //const totalStreamId = this.getTotalStreamId(streamid);
        var publish = this.publisherList[streamid];
        if (!publish) {
            this.logger.warn("zsc.sps.0.1 publisher don't exist");
            return;
        }
        var retryStreamHandler = publish.retryStreamHandler;
        //清除重试计时
        if (retryStreamHandler) {
            retryStreamHandler.stopMaxTime();
            retryStreamHandler.invalid();
        }
        for (var signalUrl in this.signalList) {
            this.signalList[signalUrl].publishWaitingList = this.signalList[signalUrl].publishWaitingList.filter(function (info) { return info.streamID !== streamid; });
        }
        delete this.publisherList[streamid];
        if (publish.publisher) {
            publish.publisher.stopPublish();
            //@ts-ignore
            delete publish.publisher;
        }
        //update signal
        this.removeStreamFromSignal(true, streamid);
        this.stopSignalHeartbeat();
        this.stopChargeInfosUpload();
        this.stopSoundLevel();
        this.logger.debug("zsc.sps.0.1 call success");
    };
    /*
     *    "zsc.crss.0": "ZegoStreamCenter.connectWithReuseSignalServer"
     */
    ZegoStreamCenterWeb.prototype.connectWithReuseSignalServer = function (streamID, isPublish, serverUrl, success, error) {
        var _this = this;
        this.logger.info("zsc.crss.0 begin " + serverUrl);
        var signalInfo = null;
        if (this.signalList[serverUrl]) {
            signalInfo = this.signalList[serverUrl];
            //already connected
            if (signalInfo.state == zego_entity_2.ENUM_SIGNAL_STATE.connected) {
                this.logger.info("zsc.crss.0 already connected " + serverUrl + " streamId: " + streamID);
                if (isPublish) {
                    signalInfo.publishConnectedList.push(streamID);
                }
                else {
                    signalInfo.playConnectedList.push(streamID);
                }
                success(streamID, signalInfo, serverUrl);
            }
            else if (signalInfo.state == zego_entity_2.ENUM_SIGNAL_STATE.connecting) {
                //isConnecting
                this.logger.info("zsc.crss.0 signal is connecting " +
                    serverUrl +
                    " streamId: " +
                    streamID);
                this.updateWaitingList(signalInfo, isPublish, streamID, success, error);
            }
        }
        else {
            //no connect
            this.logger.info("zsc.crss.0 new signal " + serverUrl + ", streamId: " + streamID);
            var useNetAgent_1 = this.stateCenter.useNetAgent;
            var signal = new streamSignal_1.ZegoSignal(this.logger, this.stateCenter, this.rtm.netAgent, useNetAgent_1);
            signal.setSessionInfo(this.appid, this.userid);
            if (!useNetAgent_1) {
                signal.onUpdateHeartBeatInterval = this.onUpdateHeartBeatIntervalHandle.bind(this);
            }
            // signal.onSocketCloseCallBack = (): void => {
            //     this.stopSignalHeartbeat();
            // };
            // 注册断开回调
            signal.onDisconnect = this.onDisconnectHandle;
            var publishAndPlay = this.publisherList[streamID] || this.playerList[streamID] || null;
            // 获取尝试重连的时间间隔
            var streamRetry = publishAndPlay === null || publishAndPlay === void 0 ? void 0 : publishAndPlay.retryStreamHandler;
            if (this.stateCenter.streamConnectTime) {
                signal.tryConnectInterval = this.stateCenter.streamConnectTime;
            }
            else if (streamRetry && streamRetry.retryActiveCount) {
                var _tryConnectInterval = (streamRetry.retryActiveCount * (streamRetry.retryActiveCount - 1)) /
                    2 +
                    2;
                _tryConnectInterval =
                    _tryConnectInterval > zego_entity_2.MAX_RETRY_CONNECT_INTERVAL
                        ? zego_entity_2.MAX_RETRY_CONNECT_INTERVAL
                        : _tryConnectInterval;
                signal.tryConnectInterval = _tryConnectInterval * 1000;
            }
            this.signalList[serverUrl] = {
                signal: signal,
                state: zego_entity_2.ENUM_SIGNAL_STATE.connecting,
                publishWaitingList: [],
                playWaitingList: [],
                publishConnectedList: [],
                playConnectedList: [],
                tokenInfo: null
            };
            this.updateWaitingList(this.signalList[serverUrl], isPublish, streamID, success, error);
            var token = publishAndPlay === null || publishAndPlay === void 0 ? void 0 : publishAndPlay.room.token;
            var roomID = publishAndPlay === null || publishAndPlay === void 0 ? void 0 : publishAndPlay.room.roomID;
            this.logger.info("zsc.crss.0 " + token);
            // 连接媒体服务的方式改为通过统一接入连接
            signal.connectServer(roomID ? roomID : this.stateCenter.roomList[0].roomID, token ? token : this.stateCenter.roomList[0].token, serverUrl, function (result, server, tokenInfo) {
                signalInfo = _this.signalList[serverUrl];
                if (result != 0) {
                    //connected failed, notify and delete
                    _this.logger.info("zsc.crss.0 connect failed " + server);
                    // 触发每个推拉流失败回调
                    signalInfo.publishWaitingList.forEach(function (item) {
                        if (item.error) {
                            item.error(item.streamID, result);
                        }
                    });
                    signalInfo.playWaitingList.forEach(function (item) {
                        if (item.error) {
                            item.error(item.streamID, result);
                        }
                    });
                    delete _this.signalList[serverUrl];
                }
                else {
                    //connected success, notify and update state
                    _this.logger.debug("zsc.crss.0 connected success " + server);
                    signalInfo.state = zego_entity_2.ENUM_SIGNAL_STATE.connected;
                    signalInfo.tokenInfo = tokenInfo;
                    // 触发每个推拉流成功回调
                    signalInfo.publishWaitingList.forEach(function (item) {
                        if (item.success) {
                            item.success(item.streamID, signalInfo, server);
                        }
                        signalInfo && signalInfo.publishConnectedList.push(item.streamID);
                    });
                    signalInfo.playWaitingList.forEach(function (item) {
                        if (item.success) {
                            item.success(item.streamID, signalInfo, server);
                        }
                        signalInfo && signalInfo.playConnectedList.push(item.streamID);
                    });
                    signalInfo.publishWaitingList = [];
                    signalInfo.playWaitingList = [];
                    // !useNetAgent &&
                    if (!useNetAgent_1 && _this.heartbeatTimer == null)
                        _this.startSignalHeartbeat();
                    // TODO: 需要确认是否需要根据统一接入做区分
                    if (_this.chargeInfosTimer == null)
                        _this.startChargeInfosUpload();
                    _this.activeSoundLevel();
                }
            });
        }
    };
    ZegoStreamCenterWeb.prototype.setPlayStateStart = function (streamid, playOption, isDataChannel) {
        var _this = this;
        this.logger.info("zsc.pss.1 call " + streamid);
        if (this.stateCenter.networkState == zego_entity_1.ENUM_NETWORK_STATE.offline) {
            this.logger.error("zsc.pss.1 network offline");
            return false;
        }
        var play = this.playerList[streamid];
        var reportSeq = this.stateCenter.reportSeqList.startPlay[streamid];
        this.dataReport.eventStart(reportSeq, "setPlayState");
        if (play) {
            this.logger.error("zsc.pss.1 player already exist");
            this.dataReport.eventEndWithMsgInfo(reportSeq, "setPlayState", {
                message: "player already exist"
            });
            this.dataReport.uploadReport(reportSeq, undefined, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kIsPlaying);
            delete this.stateCenter.reportSeqList.startPlay[streamid];
            return false;
        }
        var room = this.getPlayRoom(streamid) || this.stateCenter.roomList[0];
        // TODO
        // 处理拉流未完成就退出了房间的情况
        if (!room) {
            this.logger.error("zsc.pss.1 not login room");
            this.dataReport.eventEndWithMsgInfo(reportSeq, "setPlayState", {
                message: "not login room"
            });
            this.dataReport.uploadReport(reportSeq, undefined, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayNoLoginError);
            return false;
        }
        var player = new zego_play_web_1.ZegoPlayWeb(this.logger, null, this.dataReport, this.qualityTimerInterval, this, this.ac, this.stateCenter);
        if (playOption && [0, 2, 3].includes(playOption.resourceMode)) {
            player.resourceMode = playOption.resourceMode;
        }
        this.dataReport.addMsgInfo(reportSeq, {
            resourceMode: player.resourceMode,
            play_room_id: room === null || room === void 0 ? void 0 : room.roomID,
            isMulti: this.stateCenter.isMultiRoom
        });
        player.state = zego_entity_2.ENUM_PLAY_STATE.start;
        player.isPeer = this.isPeer;
        player.reportSeq = this.stateCenter.reportSeqList.startPlay[streamid];
        player.beginTime = new Date().getTime();
        var retryStreamHandler = new retryStreamHandler_1.RetryStreamHandler(this.logger, this.stateCenter, this, false);
        this.playerList[streamid] = {
            seq: 0,
            room: room,
            player: player,
            signal: null,
            serverUrls: [],
            ttl: 0,
            isCenterNode: true,
            streamID: streamid,
            playOption: playOption,
            retryStreamHandler: retryStreamHandler,
            retryDispatchHandler: new retryDispatchHandler_1.RetryDispatchHandler(this.logger, this.stateCenter, this.rtm, this),
            isDataChannel: isDataChannel
        };
        player.onPlayStateUpdate = function (type, _streamid, error, stopRetry) {
            var play = _this.playerList[_streamid];
            if (play) {
                retryStreamHandler.playStateHandle(type, play.streamID, error, stopRetry);
            }
            else {
                _this.logger.error("zsc.pss.1 cannot find play " + _streamid);
            }
        };
        player.onPlayQualityUpdate = function (_streamid, streamQuality) {
            var play = _this.playerList[_streamid];
            if (play) {
                _this.onPlayQualityUpdate(play.streamID, streamQuality);
            }
            else {
                _this.logger.error("zsc.pss.1 cannot find play " + _streamid);
            }
        };
        player.onRemoteCameraStatusUpdate = function (_streamid, status, originalStatus) {
            var play = _this.playerList[_streamid];
            if (play) {
                _this.onRemoteCameraStatusUpdate(play.streamID, status, originalStatus);
            }
            else {
                _this.logger.error("zsc.pss.1 cannot find play " + _streamid);
            }
        };
        player.onRemoteMicStatusUpdate = function (_streamid, status, originalStatus) {
            var play = _this.playerList[_streamid];
            if (play) {
                _this.onRemoteMicStatusUpdate(play.streamID, status, originalStatus);
            }
            else {
                _this.logger.error("zsc.pss.1 cannot find play " + _streamid);
            }
        };
        this.dataReport.eventStart(player.reportSeq, "GetSignalUrl");
        this.dataReport.eventStart(player.streamReportSeq, "GetSignalUrl");
        return true;
    };
    ZegoStreamCenterWeb.prototype.onRemoteMicStatusUpdate = function (streamID, status, initialStatus) { };
    ZegoStreamCenterWeb.prototype.onRemoteCameraStatusUpdate = function (streamID, status, initialStatus) { };
    /*
     *    "zsc.sps.1": "ZegoStreamCenter.startPlayingStream"
     */
    ZegoStreamCenterWeb.prototype.startPlayingStream = function (streamid, useNetAgent, success) {
        if (useNetAgent === void 0) { useNetAgent = false; }
        this.logger.info("zsc.sps.1 start play called");
        //const totalStreamId = this.getTotalStreamId(streamid);
        var play = this.playerList[streamid];
        if (!play) {
            this.logger.error("zsc.sps.1 player don't exist");
            return false;
        }
        var player = play.player;
        if (useNetAgent) {
            // TODO: 统一接入调度连接媒体
        }
        else {
            // 非统一接入需要处理重试媒体节点
            this.dataReport.eventEndWithMsg(player.reportSeq, "GetSignalUrl", {
                urls: play.serverUrls
            });
            this.dataReport.eventEndWithMsg(player.streamReportSeq, "GetSignalUrl", {
                urls: play.serverUrls
            });
            if (play.serverUrls.length == 0) {
                play.retryStreamHandler.playStateHandle(zego_entity_2.ENUM_PLAY_STATE_UPDATE.error, streamid, zego_error_1.errorCodeList.DISPATCH_ERROR);
                this.logger.info("zsc.sps.1 server don't have signal url");
                return false;
            }
            // this.server 为已经连接上的节点，如果serverUrls中包含该节点则优先使用该节点
            var index = play.serverUrls.indexOf(this.server);
            if (index !== -1) {
                play.serverUrls.splice(index, 1);
                play.serverUrls.unshift(this.server);
            }
        }
        var retryStreamHandler = play.retryStreamHandler;
        //流重试初始化
        retryStreamHandler.invalid();
        retryStreamHandler.init(this.stateCenter.streamRetryTime);
        retryStreamHandler.initStream(streamid, play.serverUrls);
        retryStreamHandler.startMaxTime();
        return retryStreamHandler.activePull(0, success);
    };
    /*
     *    "zsc.cps.1": "ZegoStreamCenter.connectPlayServer"
     */
    ZegoStreamCenterWeb.prototype.connectPlayServer = function (streamId, success, server) {
        var _this = this;
        var play = this.playerList[streamId];
        if (!play) {
            this.logger.error("zsc.cps.1 player don't exist");
            return false;
        }
        this.dataReport.eventStart(play.player.reportSeq, "ConnectServer");
        this.dataReport.eventStart(play.player.streamReportSeq, "ConnectServer");
        this.connectWithReuseSignalServer(streamId, false, server, function (streamid, signalInfo, serverUrl) {
            //check streamid exist
            var checkPlay = _this.playerList[streamid];
            if (!checkPlay) {
                _this.logger.error("zsc.cps.1 after connect player don't exist");
                return;
            }
            var checkPlayer = checkPlay.player;
            if (!checkPlayer) {
                _this.logger.error("zsc.cps.1 checkplayer don't exist");
                return;
            }
            _this.dataReport.eventEndWithMsg(checkPlayer.reportSeq, "ConnectServer", {
                result: 0,
                server: serverUrl
            });
            _this.dataReport.eventEndWithMsg(checkPlayer.streamReportSeq, "ConnectServer", {
                result: 0,
                server: serverUrl
            });
            var tokenInfo = signalInfo.tokenInfo;
            _this.logger.info("zsc.cps.1 update token success");
            if (tokenInfo && tokenInfo.report) {
                checkPlayer.qualityHandler.qualityUpload = tokenInfo.report;
                checkPlayer.qualityHandler.qualityUploadInterval =
                    tokenInfo.report_interval;
            }
            checkPlayer.signal = signalInfo.signal;
            _this.server = serverUrl;
            _this.playStream(streamid, success);
            _this.getTokenSuccess();
        }, function (streamid, result) {
            var checkPlay = _this.playerList[streamid];
            if (!checkPlay) {
                _this.logger.error("zsc.cps.1 after connect player don't exist");
                return;
            }
            _this.dataReport.eventEndWithMsg(checkPlay.player.reportSeq, "ConnectServer", {
                result: result
            });
            !checkPlay.player.isProbe &&
                _this.dataReport.uploadReport(checkPlay.player.reportSeq);
            delete _this.stateCenter.reportSeqList.startPlay[streamId];
            var error = __assign({}, zego_error_1.errorCodeList.CONNECT_FAILED);
            error.message = error.message + " " + result;
            if (result === 1008) {
                error = zego_error_1.errorCodeList.TOKEN_EXPIRED;
            }
            checkPlay.retryStreamHandler.playStateHandle(zego_entity_2.ENUM_PLAY_STATE_UPDATE.error, streamid, error, 
            //1008 token 失败不触发重试逻辑
            result == 1008 ? true : false);
        });
        return true;
    };
    ZegoStreamCenterWeb.prototype.playStream = function (streamid, success) {
        var player = this.playerList[streamid].player;
        if (!player) {
            this.logger.warn("zsc.ps.1 player don't exist");
            return;
        }
        this.logger.info("zsc.ps.1 call success");
        if (player.gwNodeTTL < new Date().getTime() && !this.gwNode) {
            player.gwNode = "";
            player.gwNodeList = [];
            player.gwNodeTTL = 0;
        }
        else if (this.gwNode) {
            player.gwNode = this.gwNode;
        }
        player.startPlay(streamid, success, this.playerList[streamid].playOption);
    };
    ZegoStreamCenterWeb.prototype.stopSignalHeartbeat = function () {
        this.logger.debug("zsc.ssh.1 call");
        var count = 0;
        for (var url in this.signalList) {
            count += 1;
        }
        if (this.heartbeatTimer && count == 0) {
            this.logger.info("zsc.ssh.1 stop");
            clearTimeout(this.heartbeatTimer);
            this.heartbeatTimer = null;
        }
    };
    ZegoStreamCenterWeb.prototype.removeStreamFromSignal = function (isPublish, streamID) {
        var deleteSignal = [];
        for (var serverUrl in this.signalList) {
            var signalInfo = this.signalList[serverUrl];
            if (isPublish) {
                for (var i = 0; i < signalInfo.publishConnectedList.length; i++) {
                    if (signalInfo.publishConnectedList[i] === streamID) {
                        this.logger.debug("zsc.rsfs.0 found from publish");
                        signalInfo.publishConnectedList.splice(i, 1);
                        break;
                    }
                }
                for (var i = 0; i < signalInfo.publishWaitingList.length; i++) {
                    if (signalInfo.publishWaitingList[i].streamID === streamID) {
                        this.logger.debug("zsc.rsfs.0 found from publish");
                        signalInfo.publishWaitingList.splice(i, 1);
                        break;
                    }
                }
            }
            else {
                for (var j = 0; j < signalInfo.playConnectedList.length; j++) {
                    if (signalInfo.playConnectedList[j] === streamID) {
                        this.logger.debug("zsc.rsfs.0 found from play");
                        signalInfo.playConnectedList.splice(j, 1);
                        break;
                    }
                }
                for (var j = 0; j < signalInfo.playWaitingList.length; j++) {
                    if (signalInfo.playWaitingList[j].streamID === streamID) {
                        this.logger.debug("zsc.rsfs.0 found from play");
                        signalInfo.playWaitingList.splice(j, 1);
                        break;
                    }
                }
            }
            if (signalInfo.publishConnectedList.length == 0 &&
                signalInfo.playConnectedList.length == 0 &&
                signalInfo.publishWaitingList.length == 0 &&
                signalInfo.playWaitingList.length == 0) {
                signalInfo.signal.disconnectServer();
                deleteSignal.push(serverUrl);
            }
        }
        for (var k = 0; k < deleteSignal.length; k++) {
            delete this.signalList[deleteSignal[k]];
            this.server == deleteSignal[k] && (this.server = "");
        }
    };
    ZegoStreamCenterWeb.prototype.stopPlayingStream = function (streamid) {
        //const totalStreamId = this.getTotalStreamId(streamid);
        var player = this.playerList[streamid];
        if (!player) {
            this.logger.info("zsc.sps.1.1 player don't exist");
            return;
        }
        var retryStreamHandler = player.retryStreamHandler;
        if (retryStreamHandler) {
            retryStreamHandler.stopMaxTime();
            retryStreamHandler.invalid();
        }
        // 人头计费
        // this.checkChargeInfos();
        for (var signalUrl in this.signalList) {
            this.signalList[signalUrl].playWaitingList = this.signalList[signalUrl].playWaitingList.filter(function (info) { return info.streamID !== streamid; });
        }
        delete this.playerList[streamid];
        if (player.player) {
            player.player.stopPlay();
            //@ts-ignore
            delete player.player;
        }
        //update signal
        this.removeStreamFromSignal(false, streamid);
        this.stopSignalHeartbeat();
        this.stopChargeInfosUpload();
        this.stopSoundLevel();
        delete this.playSuccessCallBackList[streamid];
        delete this.playErrorCallBackList[streamid];
        this.logger.debug("zsc.sps.1.1 call success");
    };
    ZegoStreamCenterWeb.prototype.reset = function (roomID) {
        // 人头计费
        // this.checkChargeInfos();
        // this.stopChargeInfosUpload();
        for (var publishStreamId in this.publisherList) {
            (this.publisherList[publishStreamId].room.roomID == roomID || !roomID) &&
                this.stopPublishingStream(publishStreamId);
        }
        var _loop_1 = function (playStreamId) {
            var room = this_1.playerList[playStreamId].room;
            if (room.roomID == roomID &&
                (!!room.streamList.find(function (stream) { return stream.stream_id == playStreamId; }) ||
                    this_1.stateCenter.roomList.length == 1)) {
                this_1.stopPlayingStream(playStreamId);
            }
            else if (room.roomID == roomID &&
                this_1.stateCenter.roomList.length > 1) {
                //跨房间拉流且存在其它房间，则将流转移至其它房间
                var _room = this_1.stateCenter.roomList.find(function (roomInfo) { return roomInfo.roomID !== roomID; });
                _room
                    ? (this_1.playerList[playStreamId].room = _room)
                    : this_1.stopPlayingStream(playStreamId);
            }
        };
        var this_1 = this;
        for (var playStreamId in this.playerList) {
            _loop_1(playStreamId);
        }
        if (Object.keys(this.publisherList).length == 0 &&
            Object.keys(this.playerList).length == 0) {
            this.probeList = {};
        }
        this.waitPublishList = [];
        this.waitPlayList = [];
        //重置推拉裤质量上报
        this.publishQualityInfos = [];
        this.playQualityInfos = [];
        this.qualityHeadTimestamp = 0;
        this.qualityUploadTimestamp = 0;
        if (this.qualityWebsocket) {
            this.qualityWebsocket.close();
            this.qualityWebsocket = undefined;
        }
    };
    ZegoStreamCenterWeb.prototype.startSignalHeartbeat = function () {
        var _this = this;
        this.logger.debug("zsc.ssh.0 call");
        if (this.heartbeatTimer) {
            clearTimeout(this.heartbeatTimer);
            this.heartbeatTimer = null;
        }
        this.heartbeatTimer = setTimeout(function () {
            _this.checkSignalHeartbeat();
        }, this.heartbeatInterval);
    };
    ZegoStreamCenterWeb.prototype.startChargeInfosUpload = function () {
        var _this = this;
        this.logger.debug("zsc.sciu.0 call");
        if (this.chargeInfosTimer) {
            clearTimeout(this.chargeInfosTimer);
            this.chargeInfosTimer = null;
        }
        this.chargeInfosTimer = setTimeout(function () {
            _this.checkChargeInfos();
        }, this.chargeInfosInterval);
    };
    ZegoStreamCenterWeb.prototype.checkChargeInfos = function () {
        this.logger.debug("zsc.cci.0 call");
        var chargeinfo = {
            is_publishing: 0,
            play_max_audio_bitrate: 0,
            play_stream_resolution_infos: []
        };
        this.chargeInfos.timestamp_begin = new Date().getTime();
        for (var j in this.publisherList) {
            var publisher = this.publisherList[j].publisher;
            publisher.state === zego_entity_2.ENUM_PUBLISH_STATE.publishing &&
                (chargeinfo.is_publishing = 1);
            break;
        }
        chargeinfo.play_max_audio_bitrate = 0;
        var _loop_2 = function (i) {
            var remoteStream = this_2.playerList[i].player.playStream;
            var videoInfo = remoteStream && remoteStream.getVideoTracks().length !== 0
                ? remoteStream.getVideoTracks()[0].getSettings()
                : undefined;
            var resolutionInfo = {
                video_width: videoInfo ? (videoInfo.width ? videoInfo.width : 0) : 0,
                video_height: videoInfo ? (videoInfo.height ? videoInfo.height : 0) : 0,
                count: 1
            };
            !chargeinfo.play_stream_resolution_infos.find(function (val) {
                if (val.video_width == resolutionInfo.video_width &&
                    val.video_height == resolutionInfo.video_height) {
                    val.count++;
                    return true;
                }
                else {
                    return false;
                }
            }) && chargeinfo.play_stream_resolution_infos.push(resolutionInfo);
            if (resolutionInfo.video_width == 0 && resolutionInfo.video_height == 0) {
                var audioBitrate = this_2.playerList[i].player.qualityHandler.lastPlayStats.audioBitrate *
                    1000;
                audioBitrate > chargeinfo.play_max_audio_bitrate &&
                    (chargeinfo.play_max_audio_bitrate = audioBitrate);
            }
        };
        var this_2 = this;
        for (var i in this.playerList) {
            _loop_2(i);
        }
        if (this.chargeInfos.timestamp_end !== 0) {
            this.chargeInfos.timestamp_diff =
                this.chargeInfos.timestamp_begin - this.chargeInfos.timestamp_end;
            this.chargeInfos.timestamp_diff_flag = 1;
        }
        else {
            this.chargeInfos.timestamp_diff = 0;
            this.chargeInfos.timestamp_diff_flag = 0;
        }
        this.chargeInfos.timestamp_end = new Date().getTime();
        this.chargeInfos.infos = [chargeinfo];
        chargeinfo.play_stream_resolution_infos.length !== 0 &&
            this.logger.report(this.chargeInfos);
        this.chargeInfosTimer && this.startChargeInfosUpload();
    };
    ZegoStreamCenterWeb.prototype.checkSignalHeartbeat = function () {
        this.logger.debug("zsc.csh.0 call");
        for (var streamUrl in this.signalList) {
            if (this.signalList[streamUrl].signal) {
                this.signalList[streamUrl].signal.sendHeartbeat();
            }
        }
        if (this.heartbeatTimer)
            this.startSignalHeartbeat();
    };
    ZegoStreamCenterWeb.prototype.stopChargeInfosUpload = function () {
        this.logger.debug("zsc.sciu.0 call");
        var count = 0;
        for (var url in this.signalList) {
            count += 1;
        }
        if (this.chargeInfosTimer && count == 0) {
            this.logger.info("zsc.sciu.0 stop");
            clearTimeout(this.chargeInfosTimer);
            this.chargeInfosTimer = null;
        }
    };
    ZegoStreamCenterWeb.prototype.getPublisher = function (streamID) {
        var publisher = null;
        //const tototalStreamId = this.getTotalStreamId(streamID);
        if (this.publisherList[streamID] &&
            this.publisherList[streamID].publisher) {
            publisher = this.publisherList[streamID].publisher;
        }
        return publisher;
    };
    ZegoStreamCenterWeb.prototype.checkPreview = function (localStream) {
        for (var i = 0; i < this.previewStreamList.length; i++) {
            if (this.previewStreamList[i].localStream === localStream) {
                return this.previewStreamList[i];
            }
        }
        return null;
    };
    ZegoStreamCenterWeb.prototype.checkPublish = function (localStream) {
        for (var streamID in this.publisherList) {
            if (this.publisherList[streamID].localStream == localStream) {
                return this.publisherList[streamID];
            }
        }
        return null;
    };
    ZegoStreamCenterWeb.prototype.removePreview = function (preview) {
        for (var i = 0; i < this.previewStreamList.length; i++) {
            if (this.previewStreamList[i] === preview) {
                this.previewStreamList.splice(i, 1);
                break;
            }
        }
    };
    ZegoStreamCenterWeb.prototype.onPlayerStreamUrlUpdate = function (streamid, url, type) { };
    // 补充完整设置参数
    ZegoStreamCenterWeb.prototype.getScreenConstrains = function (screen) {
        var config = {};
        if (typeof screen == "boolean" && screen) {
            config = {
                audio: false,
                frameRate: zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.MEDIUM.frameRate,
                bitRate: this.stateCenter.settingConfig.getSetting("screen_video_bitrate") ||
                    zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.MEDIUM.bitRate
            };
        }
        else if (typeof screen == "object") {
            switch (screen.videoQuality) {
                case 1:
                    config = {
                        frameRate: zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.LOW.frameRate,
                        bitRate: zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.LOW.bitRate
                    };
                    break;
                case 3:
                    config = {
                        frameRate: zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.HIGH.frameRate,
                        bitRate: zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.HIGH.bitRate
                    };
                    break;
                case 4:
                    config = {
                        frameRate: screen.frameRate,
                        bitRate: screen.bitRate,
                        width: screen.width,
                        height: screen.height
                    };
                    break;
                case 2:
                    config = {
                        frameRate: zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.MEDIUM.frameRate,
                        bitRate: zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.MEDIUM.bitRate
                    };
                    break;
                default:
                    config = {
                        frameRate: zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.MEDIUM.frameRate,
                        bitRate: this.stateCenter.settingConfig.getSetting("screen_video_bitrate") || zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.MEDIUM.bitRate
                    };
                    break;
            }
            config.audio = typeof screen.audio == "boolean" ? screen.audio : false;
            config = __assign(__assign({}, screen), config);
        }
        return config;
    };
    ZegoStreamCenterWeb.prototype.createScreenPreviewer = function (stream, screenConfig) {
        var preview = new zego_preview_1.ZegoPreview(this.logger, this.ac, this.stateCenter, this, "screen");
        var videoInfo = stream.getVideoTracks()[0].getSettings();
        // this.stateCenter.screenShotStream = stream;
        this.previewStreamList.push(preview);
        preview.mediaStreamConfig = screenConfig;
        if (stream.getAudioTracks().length > 0)
            preview.audioTrack = stream.getAudioTracks()[0];
        preview.localStream = stream;
        preview.videoInfo = {
            width: videoInfo.width,
            height: videoInfo.height,
            frameRate: videoInfo.frameRate || 15,
            bitRate: (screenConfig === null || screenConfig === void 0 ? void 0 : screenConfig.bitRate) || 1000,
            startBitrate: (screenConfig === null || screenConfig === void 0 ? void 0 : screenConfig.startBitrate) ||
                this.stateCenter.settingConfig.getSetting("bitrate_mode")
        };
        preview.previewSuc = true;
        preview.previewType = "screen";
        // 修改contentHint
        if (screenConfig === null || screenConfig === void 0 ? void 0 : screenConfig.videoOptimizationMode) {
            this.setVideoTrackContentHint(stream, screenConfig === null || screenConfig === void 0 ? void 0 : screenConfig.videoOptimizationMode);
        }
        return preview;
    };
    ZegoStreamCenterWeb.prototype.setSoundLevelDelegate = function (bool, timeInMs) {
        this.logger.info("zsc.ssd.0 call");
        timeInMs && (this.soundLevelInterval = timeInMs);
        this.soundLevelDelegate = bool;
        for (var i in this.previewStreamList) {
            var previwer = this.previewStreamList[i];
            if (bool) {
                previwer.startSoundLevel();
            }
            else {
                previwer.stopSoundLevel();
            }
        }
        // for (const i in this.publisherList) {
        //   const publisher = this.publisherList[i].publisher;
        //   if (publisher.previewer?.previewType !== "camera") {
        //     if (bool) {
        //       publisher.startSoundLevel();
        //     } else {
        //       publisher.stopSoundLevel();
        //     }
        //   }
        // }
        for (var i in this.playerList) {
            var player = this.playerList[i].player;
            if (bool) {
                player.startSoundLevel();
            }
            else {
                player.stopSoundLevel();
            }
        }
        if (!bool) {
            this.logger.info("zsc.ssd.0 stop getting sound");
            this.soundLevelTimer && clearTimeout(this.soundLevelTimer);
            this.soundLevelTimer = null;
            this.soundLevelInterval = 1000;
        }
        else {
            this.logger.info("zsc.ssd.0 start getting sound");
            this.activeSoundLevel();
        }
    };
    Object.defineProperty(ZegoStreamCenterWeb.prototype, "hasRemoteStream", {
        get: function () {
            return Object.keys(this.signalList).length > 0;
        },
        enumerable: false,
        configurable: true
    });
    // 开启响应音浪回调
    ZegoStreamCenterWeb.prototype.activeSoundLevel = function () {
        if (!this.soundLevelTimer && this.soundLevelDelegate) {
            this.startSoundLevel();
        }
    };
    ZegoStreamCenterWeb.prototype.startSoundLevel = function () {
        var _this = this;
        if (this.soundLevelTimer) {
            clearTimeout(this.soundLevelTimer);
            this.soundLevelTimer = null;
        }
        if (this.soundLevelDelegate) {
            this.hasRemoteStream && this.checkSoundLevel();
            this.checkMicSoundLevel();
            this.soundLevelTimer = setTimeout(function () {
                _this.startSoundLevel();
            }, this.soundLevelInterval);
        }
    };
    /**
     * 获取推拉流的音浪
     */
    ZegoStreamCenterWeb.prototype.checkSoundLevel = function () {
        this.logger.debug("zsc.csl.0 call");
        var soundLevelList = [];
        for (var i in this.publisherList) {
            var soundLevel = 0;
            var publisher = this.publisherList[i].publisher;
            var previewer = publisher.previewer;
            if (previewer) {
                soundLevel = previewer.soundLevel;
            }
            soundLevelList.push({
                streamID: this.getBackStreamId(publisher.streamId),
                soundLevel: soundLevel,
                type: "push"
            });
        }
        for (var i in this.playerList) {
            var player = this.playerList[i].player;
            // 过滤掉探测流的音浪回调
            if (player.streamId && !player.isProbe) {
                soundLevelList.push({
                    streamID: this.getBackStreamId(player.streamId),
                    soundLevel: player.soundLevel,
                    type: "pull"
                });
            }
        }
        this.soundLevelDelegate &&
            soundLevelList.length > 0 &&
            this.onSoundLevelUpdate(soundLevelList);
    };
    /**
     * 获取摄像头流的麦克风音浪
     */
    ZegoStreamCenterWeb.prototype.checkMicSoundLevel = function () {
        if (this.cameraPreviewStream && this.soundLevelDelegate) {
            var soundLevel = this.cameraPreviewStream.soundLevel;
            this.onMicSoundLevelUpdate(soundLevel);
        }
    };
    ZegoStreamCenterWeb.prototype.getBackStreamId = function (streamid) {
        if (this.testEnvironment && streamid) {
            var backStreamId = streamid.replace("zegotest-" + this.appid + "-", "");
            //this.logger.debug ('zsc.gbs.0 test back streamid ' + backStreamId);
            return backStreamId;
        }
        return streamid;
    };
    /**推拉流音浪回调 */
    ZegoStreamCenterWeb.prototype.onSoundLevelUpdate = function (soundLevelList) { };
    /**本地麦克风音浪回调 */
    ZegoStreamCenterWeb.prototype.onMicSoundLevelUpdate = function (soundLevel) { };
    ZegoStreamCenterWeb.prototype.stopSoundLevel = function () {
        // 修复推流后停止推流时本地音浪回调停止触发
        // let count = 0;
        // for (const url in this.signalList) {
        //   count += 1;
        // }
        var count = this.previewStreamList.length;
        if (this.soundLevelTimer && !this.hasRemoteStream && count === 0) {
            this.logger.info("zsc.ssl.0 stop");
            clearTimeout(this.soundLevelTimer);
            this.soundLevelTimer = null;
        }
    };
    ZegoStreamCenterWeb.prototype.startNetProbe = function (isPublish, pushOrPull, nodeList) {
        var _this = this;
        var reportSeq = zego_entity_1.getReportSeq();
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoNetProbe.event);
        if (!this.isPeer) {
            //非peer模式不支持探测
            this.dataReport.uploadReport(reportSeq, undefined, {
                code: -1,
                message: "not support peer"
            });
            return;
        }
        var isCenter = true;
        if (nodeList.length == 0) {
            //非单中心
            isCenter = false;
            if (isPublish) {
                nodeList = this.publisherList[pushOrPull.streamId].serverUrls;
            }
            else {
                nodeList = this.playerList[pushOrPull.streamId].serverUrls;
            }
        }
        nodeList.forEach(function (gwNode) {
            if ((_this.probeList[gwNode] &&
                _this.probeList[gwNode].timeStamp + 15 * 60000 <
                    new Date().getTime()) ||
                pushOrPull.probeState == zego_entity_2.ENUM_PROBE_STATE.probed) {
                return;
            }
            var streamID = "zegoprobe-" + new Date().getTime();
            _this.setPlayStateStart(streamID);
            var prober = _this.playerList[streamID]
                ? _this.playerList[streamID].player
                : null;
            if (!prober) {
                return;
            }
            prober.isProbe = true;
            if (isCenter) {
                //单中心
                prober.gwNode = gwNode;
                prober.signal = pushOrPull.signal;
                prober.startPlay(streamID, function () { });
            }
            else {
                //非单中心
                _this.connectPlayServer(streamID, function () { }, gwNode);
            }
            prober.onCalNetQualityResult = function (result, netQuality) {
                _this.logger.info("zc.ocnqr.0 " + prober.gwNode + " " + result + " " + netQuality);
                _this.probeList[gwNode] = {
                    result: result,
                    netQuality: netQuality,
                    timeStamp: new Date().getTime()
                };
                if (pushOrPull.gwNode == gwNode || pushOrPull.signal.server == gwNode) {
                    pushOrPull.netQuality = netQuality;
                }
                else {
                    _this.handleCalNetQualityResult(isPublish, result, netQuality, pushOrPull, gwNode);
                }
                _this.stopPlayingStream(streamID);
            };
        });
        this.dataReport.addMsgInfo(reportSeq, {
            netQuality: pushOrPull.netQuality,
            nodeList: nodeList
        });
        this.dataReport.uploadReport(reportSeq);
    };
    ZegoStreamCenterWeb.prototype.handleCalNetQualityResult = function (isPublish, result, netQuality, pushOrPull, gwNode) {
        this.logger.info("zc.hcqr.0 " +
            pushOrPull.netQuality +
            " probe " +
            netQuality +
            " " +
            gwNode);
        if (result !== 0)
            return;
        var reportSeq = zego_entity_1.getReportSeq();
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoNetProbeResult.event);
        var isSwitch = false;
        if (netQuality > Math.max(75, pushOrPull.netQuality + 20) &&
            pushOrPull.probeState == zego_entity_2.ENUM_PROBE_STATE.tryProbe) {
            isSwitch = true;
            if (isPublish) {
                //推流处理
                var publisher = pushOrPull;
                var streamID = publisher.streamId;
                var localStream = publisher.localStream;
                var videoInfo = publisher.videoInfo;
                var mediaStreamConfig = publisher.mediaStreamConfig;
                var publishOption = publisher.publishOption;
                if (publisher.sessionId != 0 &&
                    publisher.signal &&
                    publisher.shouldSendCloseSession()) {
                    //send close session request
                    publisher.signal.sendCloseSession(this.stateCenter.getSeq(), publisher.sessionId, 1);
                    publisher.signal.removeSession(publisher.sessionId);
                    publisher.closeSessionSignal = true;
                }
                publisher.resetPublish();
                if (this.publisherList[streamID].isCenterNode) {
                    publisher.gwNode = gwNode;
                    publisher.startPublish(streamID, localStream, videoInfo, mediaStreamConfig, publishOption);
                }
                else {
                    this.connectPublishServer(streamID, gwNode);
                }
            }
            else {
                //拉流处理
                var player = pushOrPull;
                var streamID = player.streamId;
                var success = player.getRemoteStreamSuc;
                var playOption = player.playOption;
                if (player.sessionId != 0 &&
                    player.signal &&
                    player.shouldSendCloseSession()) {
                    //send close session request
                    player.signal.sendCloseSession(this.stateCenter.getSeq(), player.sessionId, 1);
                    player.signal.removeSession(player.sessionId);
                    player.closeSessionSignal = true;
                }
                player.resetPlay();
                if (this.playerList[streamID].isCenterNode) {
                    player.gwNode = gwNode;
                    player.startPlay(streamID, success, playOption);
                }
                else {
                    this.connectPlayServer(streamID, success, gwNode);
                }
            }
        }
        else {
            isSwitch = false;
            this.logger.warn("zc.hcqr.0 " +
                pushOrPull.netQuality +
                " probe " +
                netQuality +
                " " +
                gwNode);
        }
        this.dataReport.addMsgInfo(reportSeq, {
            isSwitch: isSwitch,
            isPublish: isPublish,
            streamID: pushOrPull.streamId,
            result: result,
            node: gwNode,
            netQuality: pushOrPull.netQuality,
            probeNetQuality: netQuality
        });
        this.dataReport.uploadReport(reportSeq);
        //停止探测
        pushOrPull.probeState = zego_entity_2.ENUM_PROBE_STATE.probed;
    };
    ZegoStreamCenterWeb.prototype.getRoomByStreamID = function (streamID) {
        if (this.publisherList[streamID]) {
            return this.publisherList[streamID].room;
        }
        else if (this.playerList[streamID]) {
            return this.playerList[streamID].room;
        }
        else {
            return undefined;
        }
    };
    ZegoStreamCenterWeb.prototype.setVideoTrackContentHint = function (stream, videoOptimizationMode) {
        if (typeof videoOptimizationMode !== "string") {
            this.logger.warn("zc.svtch videoOptimizationMode type wrong");
            return;
        }
        var contentHint = videoOptimizationMode.toLowerCase();
        if (!["default", "motion", "detail", "text"].includes(contentHint)) {
            this.logger.warn("zc.svtch videoOptimizationMode wrong");
            return;
        }
        var videoTrack = stream.getVideoTracks()[0];
        if (!videoTrack) {
            this.logger.warn("zc.svtch" + " video track no found");
            return;
        }
        if ("contentHint" in videoTrack) {
            this.logger.info("zc.svtch " + contentHint);
            videoTrack.contentHint =
                contentHint == "default" ? "" : contentHint;
        }
        else {
            this.logger.warn("zc.svtch mediaStreamTrack contentHint attribute not supported");
        }
    };
    ZegoStreamCenterWeb.prototype.getPlayRoom = function (streamID) {
        return this.stateCenter.roomList.find(function (room) {
            return !!room.streamList.find(function (streamInfo) { return streamInfo.stream_id == streamID; });
        });
    };
    ZegoStreamCenterWeb.prototype.getQualityHead = function (SpeedLogHeadBuffer, QualityEventBuffer) {
        var preHead = new Uint8Array(12);
        preHead[0] = 0;
        preHead[1] = 12;
        preHead[2] = SpeedLogHeadBuffer.length >> 8;
        preHead[3] = SpeedLogHeadBuffer.length - (preHead[2] << 8);
        preHead[4] = QualityEventBuffer.length >> 24;
        preHead[5] = (QualityEventBuffer.length - (preHead[4] << 24)) >> 16;
        preHead[6] =
            (QualityEventBuffer.length - (preHead[4] << 24) - (preHead[5] << 16)) >>
                8;
        preHead[7] =
            QualityEventBuffer.length -
                (preHead[4] << 24) -
                (preHead[5] << 16) -
                (preHead[6] << 8);
        var timestamp = Math.ceil(new Date().getTime() / 1000);
        preHead[8] = timestamp >> 24;
        preHead[9] = (timestamp - (preHead[8] << 24)) >> 16;
        preHead[10] = (timestamp - (preHead[8] << 24) - (preHead[9] << 16)) >> 8;
        preHead[11] =
            timestamp - (preHead[8] << 24) - (preHead[9] << 16) - (preHead[10] << 8);
        return preHead;
    };
    ZegoStreamCenterWeb.prototype.streamQualityUpload = function () {
        var _this = this;
        var _a;
        if (Object.keys(this.publisherList).length > 0 ||
            Object.keys(this.playerList).length > 0) {
            var _SpeedLogHead = {
                version: 0,
                timestamp: new Date().getTime(),
                event: 0,
                app_id: this.stateCenter.appid,
                user_id: this.stateCenter.idName,
                biz_type: 1
            };
            var _QualityEvent = {
                publish_quality_infos: this.publishQualityInfos,
                play_quality_infos: this.playQualityInfos
            };
            var SpeedLogHeadMessage = speed_log_1.logreport.SpeedLogHead.create(_SpeedLogHead);
            var QualityEventMessage = speed_log_1.logreport.QualityEvent.create(_QualityEvent);
            var SpeedLogHeadBuffer = speed_log_1.logreport.SpeedLogHead.encode(SpeedLogHeadMessage).finish();
            var QualityEventBuffer = speed_log_1.logreport.QualityEvent.encode(QualityEventMessage).finish();
            var preHead = this.getQualityHead(SpeedLogHeadBuffer, QualityEventBuffer);
            var unit8_1 = new Uint8Array(12 + SpeedLogHeadBuffer.length + QualityEventBuffer.length);
            unit8_1.set(preHead);
            unit8_1.set(SpeedLogHeadBuffer, 12);
            unit8_1.set(QualityEventBuffer, 12 + SpeedLogHeadBuffer.length);
            var logDomain = (_a = this.logger.url) === null || _a === void 0 ? void 0 : _a.split("/")[2];
            if (!logDomain)
                return;
            if (!this.qualityWebsocket ||
                this.qualityWebsocket.readyState == 2 ||
                this.qualityWebsocket.readyState == 3) {
                var appID = this.stateCenter.appid;
                var userID = this.stateCenter.idName;
                var token = this.stateCenter.roomList[0].token;
                this.qualityWebsocket = new WebSocket("wss://" + logDomain + "/ws/report/stream?appid=" + appID + "&product=rtc&token=" + encodeURIComponent(token) + "&id_name=" + userID);
                this.qualityWebsocket.onopen = function () {
                    var _a;
                    (_a = _this.qualityWebsocket) === null || _a === void 0 ? void 0 : _a.send(unit8_1);
                };
            }
            else if (this.qualityWebsocket.readyState == 1) {
                this.qualityWebsocket.send(unit8_1);
            }
        }
    };
    ZegoStreamCenterWeb.prototype.updateQuality = function (type, qualityData) {
        var _this = this;
        var timeStamp = new Date().getTime();
        if ((this.qualityUploadTimestamp !== 0 &&
            timeStamp - this.qualityUploadTimestamp > 60000) ||
            this.publishQualityInfos.join("").length +
                this.playQualityInfos.join().length >
                8000) {
            //timestamp_offset_end 为最后一个采集与SpeedLogHead.timestamp的时间差
            this.publishQualityInfos.forEach(function (info) {
                return (info.timestamp_offset_end =
                    Math.round(timeStamp / 1000) - _this.qualityHeadTimestamp);
            });
            this.playQualityInfos.forEach(function (info) {
                return (info.timestamp_offset_end =
                    Math.round(timeStamp / 1000) - _this.qualityHeadTimestamp);
            });
            this.streamQualityUpload();
            this.publishQualityInfos = [];
            this.playQualityInfos = [];
            this.qualityHeadTimestamp = Math.round(new Date().getTime() / 1000);
            this.qualityUploadTimestamp = timeStamp;
        }
        else if (this.qualityHeadTimestamp == 0) {
            this.qualityHeadTimestamp = Math.round(new Date().getTime() / 1000);
            this.qualityUploadTimestamp = timeStamp;
        }
        //推流
        if (type == 0) {
            this.handlePublishQualityData(qualityData);
        }
        else {
            //拉流
            this.handlePlayQualityData(qualityData);
        }
    };
    ZegoStreamCenterWeb.prototype.handlePublishQualityData = function (qualityData) {
        var publishQualityInfo = this.publishQualityInfos.find(function (info) {
            return info.stream_id == qualityData.stream_id &&
                info.video_width == qualityData.frameWidth &&
                info.video_height == qualityData.frameHeight;
        });
        if (!publishQualityInfo) {
            var room = this.getRoomByStreamID(qualityData.stream_id);
            publishQualityInfo = {
                //timestamp_offset_begin是第一个采样的时间和SpeedLogHead.timestamp的时间差
                timestamp_offset_begin: Math.abs(Number(qualityData.timeStamp - this.qualityHeadTimestamp)),
                timestamp_offset_end: 0,
                stream_id: qualityData.stream_id,
                session_id: room ? Number(room.sessionID) : 0,
                video_width: qualityData.frameWidth,
                video_height: qualityData.frameHeight,
                infos: [],
                room_id: room ? room.roomID : "",
                evnvironment: 1,
                room_session_id: room ? Number(room.roomSessionID) : 0
            };
            this.publishQualityInfos.push(publishQualityInfo);
        }
        publishQualityInfo.infos.push({
            audio_bitrate: Math.round(qualityData.audioBitrate) || 0,
            video_bitrate: Math.round(qualityData.videoBitrate) || 0,
            video_capture_fps: Math.round(qualityData.videoFPS * 10) || 0,
            video_network_fps: Math.round(qualityData.videoTransferFPS * 10) || 0,
            uplink_plr: qualityData.audioPacketsLostRate,
            rtt: Math.round(qualityData.currentRoundTripTime),
            audio_network_fps: Math.round(qualityData.audioFPS * 10),
            captured_sound_level: Math.round(qualityData.audioLevel),
            sample_time_window: Math.round(qualityData.timeStamp / 10)
        });
    };
    ZegoStreamCenterWeb.prototype.handlePlayQualityData = function (qualityData) {
        var playQualityInfo = this.playQualityInfos.find(function (info) {
            return info.stream_id == qualityData.stream_id &&
                info.video_width == qualityData.frameWidth &&
                info.video_height == qualityData.frameHeight;
        });
        if (!playQualityInfo) {
            var room = this.getRoomByStreamID(qualityData.stream_id);
            playQualityInfo = {
                //timestamp_offset_begin是第一个采样的时间和SpeedLogHead.timestamp的时间差
                timestamp_offset_begin: Math.abs(Number(qualityData.timeStamp - this.qualityHeadTimestamp)),
                timestamp_offset_end: 0,
                stream_id: qualityData.stream_id,
                session_id: room ? Number(room.sessionID) : 0,
                video_width: qualityData.frameWidth,
                video_height: qualityData.frameHeight,
                infos: [],
                room_id: room ? room.roomID : "",
                room_session_id: room ? Number(room.roomSessionID) : 0
            };
            this.playQualityInfos.push(playQualityInfo);
        }
        playQualityInfo.infos.push({
            audio_bitrate: Math.round(qualityData.audioBitrate) || 0,
            video_bitrate: Math.round(qualityData.videoBitrate) || 0,
            video_network_fps: Math.round(qualityData.videoFPS * 10) || 0,
            downlink_plr: Math.round(qualityData.audioPacketsLostRate) || 0,
            audio_network_fps: Math.round(qualityData.audioFPS * 10) || 0,
            audio_break_duration: Math.round(qualityData.audio_break_duration / 10),
            video_break_duration: Math.round(qualityData.video_break_duration / 10),
            rtt: qualityData.currentRoundTripTime,
            rendered_sound_level: Math.round(qualityData.audioLevel),
            audio_break_cancel_duration: Math.round(qualityData.audio_break_cancel_duration / 10),
            video_break_cancel_duration: Math.round(qualityData.video_break_cancel_duration / 10),
            audio_decode_time: Math.round(qualityData.audio_decode_time / 10),
            video_decode_time: Math.round(qualityData.video_decode_time / 10),
            real_sampling_interval: Math.round(qualityData.real_sampling_interval / 10),
            video_frames_decoded: Math.round(qualityData.videoFramesDecoded) || 0,
            video_frames_dropped: Math.round(qualityData.videoFramesDropped) || 0,
            sample_time_window: Math.round(qualityData.timeStamp / 10) //拉流质量信息采样时长，单位10ms
        });
    };
    return ZegoStreamCenterWeb;
}(streamCenter_1.ZegoStreamCenter));
exports.ZegoStreamCenterWeb = ZegoStreamCenterWeb;


/***/ }),

/***/ "./sdk/src/proto/speed_log.js":
/*!************************************!*\
  !*** ./sdk/src/proto/speed_log.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/


var $protobuf = __webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.logreport = (function() {

    /**
     * Namespace logreport.
     * @exports logreport
     * @namespace
     */
    var logreport = {};

    logreport.SpeedLogHead = (function() {

        /**
         * Properties of a SpeedLogHead.
         * @memberof logreport
         * @interface ISpeedLogHead
         * @property {number|null} [version] SpeedLogHead version
         * @property {Uint8Array|null} [signature] SpeedLogHead signature
         * @property {number|null} [timestamp] SpeedLogHead timestamp
         * @property {number|null} [event] SpeedLogHead event
         * @property {number|null} [app_id] SpeedLogHead app_id
         * @property {string|null} [user_id] SpeedLogHead user_id
         * @property {number|null} [biz_type] SpeedLogHead biz_type
         * @property {string|null} [device_id] SpeedLogHead device_id
         */

        /**
         * Constructs a new SpeedLogHead.
         * @memberof logreport
         * @classdesc Represents a SpeedLogHead.
         * @implements ISpeedLogHead
         * @constructor
         * @param {logreport.ISpeedLogHead=} [properties] Properties to set
         */
        function SpeedLogHead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SpeedLogHead version.
         * @member {number} version
         * @memberof logreport.SpeedLogHead
         * @instance
         */
        SpeedLogHead.prototype.version = 0;

        /**
         * SpeedLogHead signature.
         * @member {Uint8Array} signature
         * @memberof logreport.SpeedLogHead
         * @instance
         */
        SpeedLogHead.prototype.signature = $util.newBuffer([]);

        /**
         * SpeedLogHead timestamp.
         * @member {number} timestamp
         * @memberof logreport.SpeedLogHead
         * @instance
         */
        SpeedLogHead.prototype.timestamp = 0;

        /**
         * SpeedLogHead event.
         * @member {number} event
         * @memberof logreport.SpeedLogHead
         * @instance
         */
        SpeedLogHead.prototype.event = 0;

        /**
         * SpeedLogHead app_id.
         * @member {number} app_id
         * @memberof logreport.SpeedLogHead
         * @instance
         */
        SpeedLogHead.prototype.app_id = 0;

        /**
         * SpeedLogHead user_id.
         * @member {string} user_id
         * @memberof logreport.SpeedLogHead
         * @instance
         */
        SpeedLogHead.prototype.user_id = "";

        /**
         * SpeedLogHead biz_type.
         * @member {number} biz_type
         * @memberof logreport.SpeedLogHead
         * @instance
         */
        SpeedLogHead.prototype.biz_type = 0;

        /**
         * SpeedLogHead device_id.
         * @member {string} device_id
         * @memberof logreport.SpeedLogHead
         * @instance
         */
        SpeedLogHead.prototype.device_id = "";

        /**
         * Creates a new SpeedLogHead instance using the specified properties.
         * @function create
         * @memberof logreport.SpeedLogHead
         * @static
         * @param {logreport.ISpeedLogHead=} [properties] Properties to set
         * @returns {logreport.SpeedLogHead} SpeedLogHead instance
         */
        SpeedLogHead.create = function create(properties) {
            return new SpeedLogHead(properties);
        };

        /**
         * Encodes the specified SpeedLogHead message. Does not implicitly {@link logreport.SpeedLogHead.verify|verify} messages.
         * @function encode
         * @memberof logreport.SpeedLogHead
         * @static
         * @param {logreport.ISpeedLogHead} message SpeedLogHead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpeedLogHead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.version);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.timestamp);
            if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.event);
            if (message.app_id != null && Object.hasOwnProperty.call(message, "app_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.app_id);
            if (message.user_id != null && Object.hasOwnProperty.call(message, "user_id"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.user_id);
            if (message.biz_type != null && Object.hasOwnProperty.call(message, "biz_type"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.biz_type);
            if (message.device_id != null && Object.hasOwnProperty.call(message, "device_id"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.device_id);
            return writer;
        };

        /**
         * Encodes the specified SpeedLogHead message, length delimited. Does not implicitly {@link logreport.SpeedLogHead.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.SpeedLogHead
         * @static
         * @param {logreport.ISpeedLogHead} message SpeedLogHead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpeedLogHead.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SpeedLogHead message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.SpeedLogHead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.SpeedLogHead} SpeedLogHead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpeedLogHead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.SpeedLogHead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.uint32();
                    break;
                case 2:
                    message.signature = reader.bytes();
                    break;
                case 3:
                    message.timestamp = reader.uint32();
                    break;
                case 4:
                    message.event = reader.uint32();
                    break;
                case 5:
                    message.app_id = reader.uint32();
                    break;
                case 6:
                    message.user_id = reader.string();
                    break;
                case 7:
                    message.biz_type = reader.uint32();
                    break;
                case 8:
                    message.device_id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SpeedLogHead message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.SpeedLogHead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.SpeedLogHead} SpeedLogHead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpeedLogHead.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SpeedLogHead message.
         * @function verify
         * @memberof logreport.SpeedLogHead
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SpeedLogHead.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp))
                    return "timestamp: integer expected";
            if (message.event != null && message.hasOwnProperty("event"))
                if (!$util.isInteger(message.event))
                    return "event: integer expected";
            if (message.app_id != null && message.hasOwnProperty("app_id"))
                if (!$util.isInteger(message.app_id))
                    return "app_id: integer expected";
            if (message.user_id != null && message.hasOwnProperty("user_id"))
                if (!$util.isString(message.user_id))
                    return "user_id: string expected";
            if (message.biz_type != null && message.hasOwnProperty("biz_type"))
                if (!$util.isInteger(message.biz_type))
                    return "biz_type: integer expected";
            if (message.device_id != null && message.hasOwnProperty("device_id"))
                if (!$util.isString(message.device_id))
                    return "device_id: string expected";
            return null;
        };

        /**
         * Creates a SpeedLogHead message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.SpeedLogHead
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.SpeedLogHead} SpeedLogHead
         */
        SpeedLogHead.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.SpeedLogHead)
                return object;
            var message = new $root.logreport.SpeedLogHead();
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            if (object.timestamp != null)
                message.timestamp = object.timestamp >>> 0;
            if (object.event != null)
                message.event = object.event >>> 0;
            if (object.app_id != null)
                message.app_id = object.app_id >>> 0;
            if (object.user_id != null)
                message.user_id = String(object.user_id);
            if (object.biz_type != null)
                message.biz_type = object.biz_type >>> 0;
            if (object.device_id != null)
                message.device_id = String(object.device_id);
            return message;
        };

        /**
         * Creates a plain object from a SpeedLogHead message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.SpeedLogHead
         * @static
         * @param {logreport.SpeedLogHead} message SpeedLogHead
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SpeedLogHead.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.version = 0;
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
                object.timestamp = 0;
                object.event = 0;
                object.app_id = 0;
                object.user_id = "";
                object.biz_type = 0;
                object.device_id = "";
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            if (message.event != null && message.hasOwnProperty("event"))
                object.event = message.event;
            if (message.app_id != null && message.hasOwnProperty("app_id"))
                object.app_id = message.app_id;
            if (message.user_id != null && message.hasOwnProperty("user_id"))
                object.user_id = message.user_id;
            if (message.biz_type != null && message.hasOwnProperty("biz_type"))
                object.biz_type = message.biz_type;
            if (message.device_id != null && message.hasOwnProperty("device_id"))
                object.device_id = message.device_id;
            return object;
        };

        /**
         * Converts this SpeedLogHead to JSON.
         * @function toJSON
         * @memberof logreport.SpeedLogHead
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SpeedLogHead.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ProtoVersion enum.
         * @name logreport.SpeedLogHead.ProtoVersion
         * @enum {number}
         * @property {number} PROTO_VERSION=0 PROTO_VERSION value
         * @property {number} PROTO_VERSION1=1 PROTO_VERSION1 value
         * @property {number} PROTO_VERSION2=2 PROTO_VERSION2 value
         * @property {number} PROTO_VERSION3=3 PROTO_VERSION3 value
         * @property {number} PROTO_VERSION4=4 PROTO_VERSION4 value
         * @property {number} PROTO_VERSION5=5 PROTO_VERSION5 value
         * @property {number} PROTO_VERSION6=6 PROTO_VERSION6 value
         */
        SpeedLogHead.ProtoVersion = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PROTO_VERSION"] = 0;
            values[valuesById[1] = "PROTO_VERSION1"] = 1;
            values[valuesById[2] = "PROTO_VERSION2"] = 2;
            values[valuesById[3] = "PROTO_VERSION3"] = 3;
            values[valuesById[4] = "PROTO_VERSION4"] = 4;
            values[valuesById[5] = "PROTO_VERSION5"] = 5;
            values[valuesById[6] = "PROTO_VERSION6"] = 6;
            return values;
        })();

        /**
         * Event enum.
         * @name logreport.SpeedLogHead.Event
         * @enum {number}
         * @property {number} QUALITY_EVENT=0 QUALITY_EVENT value
         * @property {number} NO_BILLING_EVENT=100 NO_BILLING_EVENT value
         * @property {number} DETECT_QUALITY_EVENT=300 DETECT_QUALITY_EVENT value
         */
        SpeedLogHead.Event = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "QUALITY_EVENT"] = 0;
            values[valuesById[100] = "NO_BILLING_EVENT"] = 100;
            values[valuesById[300] = "DETECT_QUALITY_EVENT"] = 300;
            return values;
        })();

        /**
         * BizType enum.
         * @name logreport.SpeedLogHead.BizType
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} LIVE=1 LIVE value
         * @property {number} RTV=2 RTV value
         */
        SpeedLogHead.BizType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "LIVE"] = 1;
            values[valuesById[2] = "RTV"] = 2;
            return values;
        })();

        return SpeedLogHead;
    })();

    logreport.SpeedLogRsp = (function() {

        /**
         * Properties of a SpeedLogRsp.
         * @memberof logreport
         * @interface ISpeedLogRsp
         * @property {number|null} [code] SpeedLogRsp code
         * @property {string|null} [message] SpeedLogRsp message
         */

        /**
         * Constructs a new SpeedLogRsp.
         * @memberof logreport
         * @classdesc Represents a SpeedLogRsp.
         * @implements ISpeedLogRsp
         * @constructor
         * @param {logreport.ISpeedLogRsp=} [properties] Properties to set
         */
        function SpeedLogRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SpeedLogRsp code.
         * @member {number} code
         * @memberof logreport.SpeedLogRsp
         * @instance
         */
        SpeedLogRsp.prototype.code = 0;

        /**
         * SpeedLogRsp message.
         * @member {string} message
         * @memberof logreport.SpeedLogRsp
         * @instance
         */
        SpeedLogRsp.prototype.message = "";

        /**
         * Creates a new SpeedLogRsp instance using the specified properties.
         * @function create
         * @memberof logreport.SpeedLogRsp
         * @static
         * @param {logreport.ISpeedLogRsp=} [properties] Properties to set
         * @returns {logreport.SpeedLogRsp} SpeedLogRsp instance
         */
        SpeedLogRsp.create = function create(properties) {
            return new SpeedLogRsp(properties);
        };

        /**
         * Encodes the specified SpeedLogRsp message. Does not implicitly {@link logreport.SpeedLogRsp.verify|verify} messages.
         * @function encode
         * @memberof logreport.SpeedLogRsp
         * @static
         * @param {logreport.ISpeedLogRsp} message SpeedLogRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpeedLogRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.code);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            return writer;
        };

        /**
         * Encodes the specified SpeedLogRsp message, length delimited. Does not implicitly {@link logreport.SpeedLogRsp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.SpeedLogRsp
         * @static
         * @param {logreport.ISpeedLogRsp} message SpeedLogRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpeedLogRsp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SpeedLogRsp message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.SpeedLogRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.SpeedLogRsp} SpeedLogRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpeedLogRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.SpeedLogRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.uint32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SpeedLogRsp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.SpeedLogRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.SpeedLogRsp} SpeedLogRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpeedLogRsp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SpeedLogRsp message.
         * @function verify
         * @memberof logreport.SpeedLogRsp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SpeedLogRsp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isInteger(message.code))
                    return "code: integer expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };

        /**
         * Creates a SpeedLogRsp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.SpeedLogRsp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.SpeedLogRsp} SpeedLogRsp
         */
        SpeedLogRsp.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.SpeedLogRsp)
                return object;
            var message = new $root.logreport.SpeedLogRsp();
            if (object.code != null)
                message.code = object.code >>> 0;
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };

        /**
         * Creates a plain object from a SpeedLogRsp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.SpeedLogRsp
         * @static
         * @param {logreport.SpeedLogRsp} message SpeedLogRsp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SpeedLogRsp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.code = 0;
                object.message = "";
            }
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };

        /**
         * Converts this SpeedLogRsp to JSON.
         * @function toJSON
         * @memberof logreport.SpeedLogRsp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SpeedLogRsp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SpeedLogRsp;
    })();

    logreport.QualityEvent = (function() {

        /**
         * Properties of a QualityEvent.
         * @memberof logreport
         * @interface IQualityEvent
         * @property {logreport.IHardwareInfos|null} [hardware_infos] QualityEvent hardware_infos
         * @property {Array.<logreport.IPublishQualityInfos>|null} [publish_quality_infos] QualityEvent publish_quality_infos
         * @property {Array.<logreport.IPlayQualityInfos>|null} [play_quality_infos] QualityEvent play_quality_infos
         * @property {number|null} [network_type] QualityEvent network_type
         * @property {logreport.IChargeInfos|null} [charge_infos] QualityEvent charge_infos
         * @property {number|null} [client_type] QualityEvent client_type
         */

        /**
         * Constructs a new QualityEvent.
         * @memberof logreport
         * @classdesc Represents a QualityEvent.
         * @implements IQualityEvent
         * @constructor
         * @param {logreport.IQualityEvent=} [properties] Properties to set
         */
        function QualityEvent(properties) {
            this.publish_quality_infos = [];
            this.play_quality_infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QualityEvent hardware_infos.
         * @member {logreport.IHardwareInfos|null|undefined} hardware_infos
         * @memberof logreport.QualityEvent
         * @instance
         */
        QualityEvent.prototype.hardware_infos = null;

        /**
         * QualityEvent publish_quality_infos.
         * @member {Array.<logreport.IPublishQualityInfos>} publish_quality_infos
         * @memberof logreport.QualityEvent
         * @instance
         */
        QualityEvent.prototype.publish_quality_infos = $util.emptyArray;

        /**
         * QualityEvent play_quality_infos.
         * @member {Array.<logreport.IPlayQualityInfos>} play_quality_infos
         * @memberof logreport.QualityEvent
         * @instance
         */
        QualityEvent.prototype.play_quality_infos = $util.emptyArray;

        /**
         * QualityEvent network_type.
         * @member {number} network_type
         * @memberof logreport.QualityEvent
         * @instance
         */
        QualityEvent.prototype.network_type = 0;

        /**
         * QualityEvent charge_infos.
         * @member {logreport.IChargeInfos|null|undefined} charge_infos
         * @memberof logreport.QualityEvent
         * @instance
         */
        QualityEvent.prototype.charge_infos = null;

        /**
         * QualityEvent client_type.
         * @member {number} client_type
         * @memberof logreport.QualityEvent
         * @instance
         */
        QualityEvent.prototype.client_type = 0;

        /**
         * Creates a new QualityEvent instance using the specified properties.
         * @function create
         * @memberof logreport.QualityEvent
         * @static
         * @param {logreport.IQualityEvent=} [properties] Properties to set
         * @returns {logreport.QualityEvent} QualityEvent instance
         */
        QualityEvent.create = function create(properties) {
            return new QualityEvent(properties);
        };

        /**
         * Encodes the specified QualityEvent message. Does not implicitly {@link logreport.QualityEvent.verify|verify} messages.
         * @function encode
         * @memberof logreport.QualityEvent
         * @static
         * @param {logreport.IQualityEvent} message QualityEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QualityEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hardware_infos != null && Object.hasOwnProperty.call(message, "hardware_infos"))
                $root.logreport.HardwareInfos.encode(message.hardware_infos, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.publish_quality_infos != null && message.publish_quality_infos.length)
                for (var i = 0; i < message.publish_quality_infos.length; ++i)
                    $root.logreport.PublishQualityInfos.encode(message.publish_quality_infos[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.play_quality_infos != null && message.play_quality_infos.length)
                for (var i = 0; i < message.play_quality_infos.length; ++i)
                    $root.logreport.PlayQualityInfos.encode(message.play_quality_infos[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.network_type != null && Object.hasOwnProperty.call(message, "network_type"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.network_type);
            if (message.charge_infos != null && Object.hasOwnProperty.call(message, "charge_infos"))
                $root.logreport.ChargeInfos.encode(message.charge_infos, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.client_type != null && Object.hasOwnProperty.call(message, "client_type"))
                writer.uint32(/* id 100, wireType 0 =*/800).uint32(message.client_type);
            return writer;
        };

        /**
         * Encodes the specified QualityEvent message, length delimited. Does not implicitly {@link logreport.QualityEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.QualityEvent
         * @static
         * @param {logreport.IQualityEvent} message QualityEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QualityEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QualityEvent message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.QualityEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.QualityEvent} QualityEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QualityEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.QualityEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hardware_infos = $root.logreport.HardwareInfos.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.publish_quality_infos && message.publish_quality_infos.length))
                        message.publish_quality_infos = [];
                    message.publish_quality_infos.push($root.logreport.PublishQualityInfos.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.play_quality_infos && message.play_quality_infos.length))
                        message.play_quality_infos = [];
                    message.play_quality_infos.push($root.logreport.PlayQualityInfos.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.network_type = reader.uint32();
                    break;
                case 5:
                    message.charge_infos = $root.logreport.ChargeInfos.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.client_type = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QualityEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.QualityEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.QualityEvent} QualityEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QualityEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QualityEvent message.
         * @function verify
         * @memberof logreport.QualityEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QualityEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hardware_infos != null && message.hasOwnProperty("hardware_infos")) {
                var error = $root.logreport.HardwareInfos.verify(message.hardware_infos);
                if (error)
                    return "hardware_infos." + error;
            }
            if (message.publish_quality_infos != null && message.hasOwnProperty("publish_quality_infos")) {
                if (!Array.isArray(message.publish_quality_infos))
                    return "publish_quality_infos: array expected";
                for (var i = 0; i < message.publish_quality_infos.length; ++i) {
                    var error = $root.logreport.PublishQualityInfos.verify(message.publish_quality_infos[i]);
                    if (error)
                        return "publish_quality_infos." + error;
                }
            }
            if (message.play_quality_infos != null && message.hasOwnProperty("play_quality_infos")) {
                if (!Array.isArray(message.play_quality_infos))
                    return "play_quality_infos: array expected";
                for (var i = 0; i < message.play_quality_infos.length; ++i) {
                    var error = $root.logreport.PlayQualityInfos.verify(message.play_quality_infos[i]);
                    if (error)
                        return "play_quality_infos." + error;
                }
            }
            if (message.network_type != null && message.hasOwnProperty("network_type"))
                if (!$util.isInteger(message.network_type))
                    return "network_type: integer expected";
            if (message.charge_infos != null && message.hasOwnProperty("charge_infos")) {
                var error = $root.logreport.ChargeInfos.verify(message.charge_infos);
                if (error)
                    return "charge_infos." + error;
            }
            if (message.client_type != null && message.hasOwnProperty("client_type"))
                if (!$util.isInteger(message.client_type))
                    return "client_type: integer expected";
            return null;
        };

        /**
         * Creates a QualityEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.QualityEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.QualityEvent} QualityEvent
         */
        QualityEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.QualityEvent)
                return object;
            var message = new $root.logreport.QualityEvent();
            if (object.hardware_infos != null) {
                if (typeof object.hardware_infos !== "object")
                    throw TypeError(".logreport.QualityEvent.hardware_infos: object expected");
                message.hardware_infos = $root.logreport.HardwareInfos.fromObject(object.hardware_infos);
            }
            if (object.publish_quality_infos) {
                if (!Array.isArray(object.publish_quality_infos))
                    throw TypeError(".logreport.QualityEvent.publish_quality_infos: array expected");
                message.publish_quality_infos = [];
                for (var i = 0; i < object.publish_quality_infos.length; ++i) {
                    if (typeof object.publish_quality_infos[i] !== "object")
                        throw TypeError(".logreport.QualityEvent.publish_quality_infos: object expected");
                    message.publish_quality_infos[i] = $root.logreport.PublishQualityInfos.fromObject(object.publish_quality_infos[i]);
                }
            }
            if (object.play_quality_infos) {
                if (!Array.isArray(object.play_quality_infos))
                    throw TypeError(".logreport.QualityEvent.play_quality_infos: array expected");
                message.play_quality_infos = [];
                for (var i = 0; i < object.play_quality_infos.length; ++i) {
                    if (typeof object.play_quality_infos[i] !== "object")
                        throw TypeError(".logreport.QualityEvent.play_quality_infos: object expected");
                    message.play_quality_infos[i] = $root.logreport.PlayQualityInfos.fromObject(object.play_quality_infos[i]);
                }
            }
            if (object.network_type != null)
                message.network_type = object.network_type >>> 0;
            if (object.charge_infos != null) {
                if (typeof object.charge_infos !== "object")
                    throw TypeError(".logreport.QualityEvent.charge_infos: object expected");
                message.charge_infos = $root.logreport.ChargeInfos.fromObject(object.charge_infos);
            }
            if (object.client_type != null)
                message.client_type = object.client_type >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a QualityEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.QualityEvent
         * @static
         * @param {logreport.QualityEvent} message QualityEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QualityEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.publish_quality_infos = [];
                object.play_quality_infos = [];
            }
            if (options.defaults) {
                object.hardware_infos = null;
                object.network_type = 0;
                object.charge_infos = null;
                object.client_type = 0;
            }
            if (message.hardware_infos != null && message.hasOwnProperty("hardware_infos"))
                object.hardware_infos = $root.logreport.HardwareInfos.toObject(message.hardware_infos, options);
            if (message.publish_quality_infos && message.publish_quality_infos.length) {
                object.publish_quality_infos = [];
                for (var j = 0; j < message.publish_quality_infos.length; ++j)
                    object.publish_quality_infos[j] = $root.logreport.PublishQualityInfos.toObject(message.publish_quality_infos[j], options);
            }
            if (message.play_quality_infos && message.play_quality_infos.length) {
                object.play_quality_infos = [];
                for (var j = 0; j < message.play_quality_infos.length; ++j)
                    object.play_quality_infos[j] = $root.logreport.PlayQualityInfos.toObject(message.play_quality_infos[j], options);
            }
            if (message.network_type != null && message.hasOwnProperty("network_type"))
                object.network_type = message.network_type;
            if (message.charge_infos != null && message.hasOwnProperty("charge_infos"))
                object.charge_infos = $root.logreport.ChargeInfos.toObject(message.charge_infos, options);
            if (message.client_type != null && message.hasOwnProperty("client_type"))
                object.client_type = message.client_type;
            return object;
        };

        /**
         * Converts this QualityEvent to JSON.
         * @function toJSON
         * @memberof logreport.QualityEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QualityEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ResourceType enum.
         * @name logreport.QualityEvent.ResourceType
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} CDN=1 CDN value
         * @property {number} RTC=2 RTC value
         * @property {number} L3=3 L3 value
         */
        QualityEvent.ResourceType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "CDN"] = 1;
            values[valuesById[2] = "RTC"] = 2;
            values[valuesById[3] = "L3"] = 3;
            return values;
        })();

        return QualityEvent;
    })();

    logreport.HardwareInfos = (function() {

        /**
         * Properties of a HardwareInfos.
         * @memberof logreport
         * @interface IHardwareInfos
         * @property {number|null} [timestamp_offset_begin] HardwareInfos timestamp_offset_begin
         * @property {number|null} [timestamp_offset_end] HardwareInfos timestamp_offset_end
         * @property {Array.<logreport.IHardwareInfo>|null} [infos] HardwareInfos infos
         * @property {number|null} [sys_mem_total] HardwareInfos sys_mem_total
         */

        /**
         * Constructs a new HardwareInfos.
         * @memberof logreport
         * @classdesc Represents a HardwareInfos.
         * @implements IHardwareInfos
         * @constructor
         * @param {logreport.IHardwareInfos=} [properties] Properties to set
         */
        function HardwareInfos(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HardwareInfos timestamp_offset_begin.
         * @member {number} timestamp_offset_begin
         * @memberof logreport.HardwareInfos
         * @instance
         */
        HardwareInfos.prototype.timestamp_offset_begin = 0;

        /**
         * HardwareInfos timestamp_offset_end.
         * @member {number} timestamp_offset_end
         * @memberof logreport.HardwareInfos
         * @instance
         */
        HardwareInfos.prototype.timestamp_offset_end = 0;

        /**
         * HardwareInfos infos.
         * @member {Array.<logreport.IHardwareInfo>} infos
         * @memberof logreport.HardwareInfos
         * @instance
         */
        HardwareInfos.prototype.infos = $util.emptyArray;

        /**
         * HardwareInfos sys_mem_total.
         * @member {number} sys_mem_total
         * @memberof logreport.HardwareInfos
         * @instance
         */
        HardwareInfos.prototype.sys_mem_total = 0;

        /**
         * Creates a new HardwareInfos instance using the specified properties.
         * @function create
         * @memberof logreport.HardwareInfos
         * @static
         * @param {logreport.IHardwareInfos=} [properties] Properties to set
         * @returns {logreport.HardwareInfos} HardwareInfos instance
         */
        HardwareInfos.create = function create(properties) {
            return new HardwareInfos(properties);
        };

        /**
         * Encodes the specified HardwareInfos message. Does not implicitly {@link logreport.HardwareInfos.verify|verify} messages.
         * @function encode
         * @memberof logreport.HardwareInfos
         * @static
         * @param {logreport.IHardwareInfos} message HardwareInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HardwareInfos.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp_offset_begin != null && Object.hasOwnProperty.call(message, "timestamp_offset_begin"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timestamp_offset_begin);
            if (message.timestamp_offset_end != null && Object.hasOwnProperty.call(message, "timestamp_offset_end"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.timestamp_offset_end);
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.logreport.HardwareInfo.encode(message.infos[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.sys_mem_total != null && Object.hasOwnProperty.call(message, "sys_mem_total"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.sys_mem_total);
            return writer;
        };

        /**
         * Encodes the specified HardwareInfos message, length delimited. Does not implicitly {@link logreport.HardwareInfos.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.HardwareInfos
         * @static
         * @param {logreport.IHardwareInfos} message HardwareInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HardwareInfos.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HardwareInfos message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.HardwareInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.HardwareInfos} HardwareInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HardwareInfos.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.HardwareInfos();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp_offset_begin = reader.uint32();
                    break;
                case 2:
                    message.timestamp_offset_end = reader.uint32();
                    break;
                case 3:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.logreport.HardwareInfo.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.sys_mem_total = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HardwareInfos message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.HardwareInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.HardwareInfos} HardwareInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HardwareInfos.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HardwareInfos message.
         * @function verify
         * @memberof logreport.HardwareInfos
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HardwareInfos.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                if (!$util.isInteger(message.timestamp_offset_begin))
                    return "timestamp_offset_begin: integer expected";
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                if (!$util.isInteger(message.timestamp_offset_end))
                    return "timestamp_offset_end: integer expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.logreport.HardwareInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            if (message.sys_mem_total != null && message.hasOwnProperty("sys_mem_total"))
                if (!$util.isInteger(message.sys_mem_total))
                    return "sys_mem_total: integer expected";
            return null;
        };

        /**
         * Creates a HardwareInfos message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.HardwareInfos
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.HardwareInfos} HardwareInfos
         */
        HardwareInfos.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.HardwareInfos)
                return object;
            var message = new $root.logreport.HardwareInfos();
            if (object.timestamp_offset_begin != null)
                message.timestamp_offset_begin = object.timestamp_offset_begin >>> 0;
            if (object.timestamp_offset_end != null)
                message.timestamp_offset_end = object.timestamp_offset_end >>> 0;
            if (object.infos) {
                if (!Array.isArray(object.infos))
                    throw TypeError(".logreport.HardwareInfos.infos: array expected");
                message.infos = [];
                for (var i = 0; i < object.infos.length; ++i) {
                    if (typeof object.infos[i] !== "object")
                        throw TypeError(".logreport.HardwareInfos.infos: object expected");
                    message.infos[i] = $root.logreport.HardwareInfo.fromObject(object.infos[i]);
                }
            }
            if (object.sys_mem_total != null)
                message.sys_mem_total = object.sys_mem_total >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a HardwareInfos message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.HardwareInfos
         * @static
         * @param {logreport.HardwareInfos} message HardwareInfos
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HardwareInfos.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.infos = [];
            if (options.defaults) {
                object.timestamp_offset_begin = 0;
                object.timestamp_offset_end = 0;
                object.sys_mem_total = 0;
            }
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                object.timestamp_offset_begin = message.timestamp_offset_begin;
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                object.timestamp_offset_end = message.timestamp_offset_end;
            if (message.infos && message.infos.length) {
                object.infos = [];
                for (var j = 0; j < message.infos.length; ++j)
                    object.infos[j] = $root.logreport.HardwareInfo.toObject(message.infos[j], options);
            }
            if (message.sys_mem_total != null && message.hasOwnProperty("sys_mem_total"))
                object.sys_mem_total = message.sys_mem_total;
            return object;
        };

        /**
         * Converts this HardwareInfos to JSON.
         * @function toJSON
         * @memberof logreport.HardwareInfos
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HardwareInfos.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HardwareInfos;
    })();

    logreport.PublishQualityInfos = (function() {

        /**
         * Properties of a PublishQualityInfos.
         * @memberof logreport
         * @interface IPublishQualityInfos
         * @property {number|null} [timestamp_offset_begin] PublishQualityInfos timestamp_offset_begin
         * @property {number|null} [timestamp_offset_end] PublishQualityInfos timestamp_offset_end
         * @property {string|null} [stream_id] PublishQualityInfos stream_id
         * @property {number|null} [session_id] PublishQualityInfos session_id
         * @property {number|null} [video_width] PublishQualityInfos video_width
         * @property {number|null} [video_height] PublishQualityInfos video_height
         * @property {number|null} [ipv4] PublishQualityInfos ipv4
         * @property {string|null} [ipv6] PublishQualityInfos ipv6
         * @property {number|null} [resource_type] PublishQualityInfos resource_type
         * @property {Array.<logreport.IPublishQualityInfo>|null} [infos] PublishQualityInfos infos
         * @property {string|null} [room_id] PublishQualityInfos room_id
         * @property {number|null} [evnvironment] PublishQualityInfos evnvironment
         * @property {string|null} [ap] PublishQualityInfos ap
         * @property {string|null} [session] PublishQualityInfos session
         * @property {number|Long|null} [room_session_id] PublishQualityInfos room_session_id
         * @property {number|null} [protocol_type] PublishQualityInfos protocol_type
         */

        /**
         * Constructs a new PublishQualityInfos.
         * @memberof logreport
         * @classdesc Represents a PublishQualityInfos.
         * @implements IPublishQualityInfos
         * @constructor
         * @param {logreport.IPublishQualityInfos=} [properties] Properties to set
         */
        function PublishQualityInfos(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublishQualityInfos timestamp_offset_begin.
         * @member {number} timestamp_offset_begin
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.timestamp_offset_begin = 0;

        /**
         * PublishQualityInfos timestamp_offset_end.
         * @member {number} timestamp_offset_end
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.timestamp_offset_end = 0;

        /**
         * PublishQualityInfos stream_id.
         * @member {string} stream_id
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.stream_id = "";

        /**
         * PublishQualityInfos session_id.
         * @member {number} session_id
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.session_id = 0;

        /**
         * PublishQualityInfos video_width.
         * @member {number} video_width
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.video_width = 0;

        /**
         * PublishQualityInfos video_height.
         * @member {number} video_height
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.video_height = 0;

        /**
         * PublishQualityInfos ipv4.
         * @member {number} ipv4
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.ipv4 = 0;

        /**
         * PublishQualityInfos ipv6.
         * @member {string} ipv6
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.ipv6 = "";

        /**
         * PublishQualityInfos resource_type.
         * @member {number} resource_type
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.resource_type = 0;

        /**
         * PublishQualityInfos infos.
         * @member {Array.<logreport.IPublishQualityInfo>} infos
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.infos = $util.emptyArray;

        /**
         * PublishQualityInfos room_id.
         * @member {string} room_id
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.room_id = "";

        /**
         * PublishQualityInfos evnvironment.
         * @member {number} evnvironment
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.evnvironment = 0;

        /**
         * PublishQualityInfos ap.
         * @member {string} ap
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.ap = "";

        /**
         * PublishQualityInfos session.
         * @member {string} session
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.session = "";

        /**
         * PublishQualityInfos room_session_id.
         * @member {number|Long} room_session_id
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.room_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PublishQualityInfos protocol_type.
         * @member {number} protocol_type
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.protocol_type = 0;

        /**
         * Creates a new PublishQualityInfos instance using the specified properties.
         * @function create
         * @memberof logreport.PublishQualityInfos
         * @static
         * @param {logreport.IPublishQualityInfos=} [properties] Properties to set
         * @returns {logreport.PublishQualityInfos} PublishQualityInfos instance
         */
        PublishQualityInfos.create = function create(properties) {
            return new PublishQualityInfos(properties);
        };

        /**
         * Encodes the specified PublishQualityInfos message. Does not implicitly {@link logreport.PublishQualityInfos.verify|verify} messages.
         * @function encode
         * @memberof logreport.PublishQualityInfos
         * @static
         * @param {logreport.IPublishQualityInfos} message PublishQualityInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishQualityInfos.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp_offset_begin != null && Object.hasOwnProperty.call(message, "timestamp_offset_begin"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timestamp_offset_begin);
            if (message.timestamp_offset_end != null && Object.hasOwnProperty.call(message, "timestamp_offset_end"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.timestamp_offset_end);
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.stream_id);
            if (message.session_id != null && Object.hasOwnProperty.call(message, "session_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.session_id);
            if (message.video_width != null && Object.hasOwnProperty.call(message, "video_width"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.video_width);
            if (message.video_height != null && Object.hasOwnProperty.call(message, "video_height"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.video_height);
            if (message.ipv4 != null && Object.hasOwnProperty.call(message, "ipv4"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.ipv4);
            if (message.ipv6 != null && Object.hasOwnProperty.call(message, "ipv6"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.ipv6);
            if (message.resource_type != null && Object.hasOwnProperty.call(message, "resource_type"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.resource_type);
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.logreport.PublishQualityInfo.encode(message.infos[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.room_id);
            if (message.evnvironment != null && Object.hasOwnProperty.call(message, "evnvironment"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.evnvironment);
            if (message.ap != null && Object.hasOwnProperty.call(message, "ap"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.ap);
            if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.session);
            if (message.room_session_id != null && Object.hasOwnProperty.call(message, "room_session_id"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint64(message.room_session_id);
            if (message.protocol_type != null && Object.hasOwnProperty.call(message, "protocol_type"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint32(message.protocol_type);
            return writer;
        };

        /**
         * Encodes the specified PublishQualityInfos message, length delimited. Does not implicitly {@link logreport.PublishQualityInfos.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.PublishQualityInfos
         * @static
         * @param {logreport.IPublishQualityInfos} message PublishQualityInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishQualityInfos.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PublishQualityInfos message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.PublishQualityInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.PublishQualityInfos} PublishQualityInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishQualityInfos.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.PublishQualityInfos();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp_offset_begin = reader.uint32();
                    break;
                case 2:
                    message.timestamp_offset_end = reader.uint32();
                    break;
                case 3:
                    message.stream_id = reader.string();
                    break;
                case 4:
                    message.session_id = reader.uint32();
                    break;
                case 5:
                    message.video_width = reader.uint32();
                    break;
                case 6:
                    message.video_height = reader.uint32();
                    break;
                case 7:
                    message.ipv4 = reader.uint32();
                    break;
                case 8:
                    message.ipv6 = reader.string();
                    break;
                case 9:
                    message.resource_type = reader.uint32();
                    break;
                case 10:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.logreport.PublishQualityInfo.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.room_id = reader.string();
                    break;
                case 13:
                    message.evnvironment = reader.uint32();
                    break;
                case 14:
                    message.ap = reader.string();
                    break;
                case 15:
                    message.session = reader.string();
                    break;
                case 16:
                    message.room_session_id = reader.uint64();
                    break;
                case 17:
                    message.protocol_type = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PublishQualityInfos message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.PublishQualityInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.PublishQualityInfos} PublishQualityInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishQualityInfos.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PublishQualityInfos message.
         * @function verify
         * @memberof logreport.PublishQualityInfos
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PublishQualityInfos.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                if (!$util.isInteger(message.timestamp_offset_begin))
                    return "timestamp_offset_begin: integer expected";
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                if (!$util.isInteger(message.timestamp_offset_end))
                    return "timestamp_offset_end: integer expected";
            if (message.stream_id != null && message.hasOwnProperty("stream_id"))
                if (!$util.isString(message.stream_id))
                    return "stream_id: string expected";
            if (message.session_id != null && message.hasOwnProperty("session_id"))
                if (!$util.isInteger(message.session_id))
                    return "session_id: integer expected";
            if (message.video_width != null && message.hasOwnProperty("video_width"))
                if (!$util.isInteger(message.video_width))
                    return "video_width: integer expected";
            if (message.video_height != null && message.hasOwnProperty("video_height"))
                if (!$util.isInteger(message.video_height))
                    return "video_height: integer expected";
            if (message.ipv4 != null && message.hasOwnProperty("ipv4"))
                if (!$util.isInteger(message.ipv4))
                    return "ipv4: integer expected";
            if (message.ipv6 != null && message.hasOwnProperty("ipv6"))
                if (!$util.isString(message.ipv6))
                    return "ipv6: string expected";
            if (message.resource_type != null && message.hasOwnProperty("resource_type"))
                if (!$util.isInteger(message.resource_type))
                    return "resource_type: integer expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.logreport.PublishQualityInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            if (message.room_id != null && message.hasOwnProperty("room_id"))
                if (!$util.isString(message.room_id))
                    return "room_id: string expected";
            if (message.evnvironment != null && message.hasOwnProperty("evnvironment"))
                if (!$util.isInteger(message.evnvironment))
                    return "evnvironment: integer expected";
            if (message.ap != null && message.hasOwnProperty("ap"))
                if (!$util.isString(message.ap))
                    return "ap: string expected";
            if (message.session != null && message.hasOwnProperty("session"))
                if (!$util.isString(message.session))
                    return "session: string expected";
            if (message.room_session_id != null && message.hasOwnProperty("room_session_id"))
                if (!$util.isInteger(message.room_session_id) && !(message.room_session_id && $util.isInteger(message.room_session_id.low) && $util.isInteger(message.room_session_id.high)))
                    return "room_session_id: integer|Long expected";
            if (message.protocol_type != null && message.hasOwnProperty("protocol_type"))
                if (!$util.isInteger(message.protocol_type))
                    return "protocol_type: integer expected";
            return null;
        };

        /**
         * Creates a PublishQualityInfos message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.PublishQualityInfos
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.PublishQualityInfos} PublishQualityInfos
         */
        PublishQualityInfos.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.PublishQualityInfos)
                return object;
            var message = new $root.logreport.PublishQualityInfos();
            if (object.timestamp_offset_begin != null)
                message.timestamp_offset_begin = object.timestamp_offset_begin >>> 0;
            if (object.timestamp_offset_end != null)
                message.timestamp_offset_end = object.timestamp_offset_end >>> 0;
            if (object.stream_id != null)
                message.stream_id = String(object.stream_id);
            if (object.session_id != null)
                message.session_id = object.session_id >>> 0;
            if (object.video_width != null)
                message.video_width = object.video_width >>> 0;
            if (object.video_height != null)
                message.video_height = object.video_height >>> 0;
            if (object.ipv4 != null)
                message.ipv4 = object.ipv4 >>> 0;
            if (object.ipv6 != null)
                message.ipv6 = String(object.ipv6);
            if (object.resource_type != null)
                message.resource_type = object.resource_type >>> 0;
            if (object.infos) {
                if (!Array.isArray(object.infos))
                    throw TypeError(".logreport.PublishQualityInfos.infos: array expected");
                message.infos = [];
                for (var i = 0; i < object.infos.length; ++i) {
                    if (typeof object.infos[i] !== "object")
                        throw TypeError(".logreport.PublishQualityInfos.infos: object expected");
                    message.infos[i] = $root.logreport.PublishQualityInfo.fromObject(object.infos[i]);
                }
            }
            if (object.room_id != null)
                message.room_id = String(object.room_id);
            if (object.evnvironment != null)
                message.evnvironment = object.evnvironment >>> 0;
            if (object.ap != null)
                message.ap = String(object.ap);
            if (object.session != null)
                message.session = String(object.session);
            if (object.room_session_id != null)
                if ($util.Long)
                    (message.room_session_id = $util.Long.fromValue(object.room_session_id)).unsigned = true;
                else if (typeof object.room_session_id === "string")
                    message.room_session_id = parseInt(object.room_session_id, 10);
                else if (typeof object.room_session_id === "number")
                    message.room_session_id = object.room_session_id;
                else if (typeof object.room_session_id === "object")
                    message.room_session_id = new $util.LongBits(object.room_session_id.low >>> 0, object.room_session_id.high >>> 0).toNumber(true);
            if (object.protocol_type != null)
                message.protocol_type = object.protocol_type >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PublishQualityInfos message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.PublishQualityInfos
         * @static
         * @param {logreport.PublishQualityInfos} message PublishQualityInfos
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PublishQualityInfos.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.infos = [];
            if (options.defaults) {
                object.timestamp_offset_begin = 0;
                object.timestamp_offset_end = 0;
                object.stream_id = "";
                object.session_id = 0;
                object.video_width = 0;
                object.video_height = 0;
                object.ipv4 = 0;
                object.ipv6 = "";
                object.resource_type = 0;
                object.room_id = "";
                object.evnvironment = 0;
                object.ap = "";
                object.session = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.room_session_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.room_session_id = options.longs === String ? "0" : 0;
                object.protocol_type = 0;
            }
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                object.timestamp_offset_begin = message.timestamp_offset_begin;
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                object.timestamp_offset_end = message.timestamp_offset_end;
            if (message.stream_id != null && message.hasOwnProperty("stream_id"))
                object.stream_id = message.stream_id;
            if (message.session_id != null && message.hasOwnProperty("session_id"))
                object.session_id = message.session_id;
            if (message.video_width != null && message.hasOwnProperty("video_width"))
                object.video_width = message.video_width;
            if (message.video_height != null && message.hasOwnProperty("video_height"))
                object.video_height = message.video_height;
            if (message.ipv4 != null && message.hasOwnProperty("ipv4"))
                object.ipv4 = message.ipv4;
            if (message.ipv6 != null && message.hasOwnProperty("ipv6"))
                object.ipv6 = message.ipv6;
            if (message.resource_type != null && message.hasOwnProperty("resource_type"))
                object.resource_type = message.resource_type;
            if (message.infos && message.infos.length) {
                object.infos = [];
                for (var j = 0; j < message.infos.length; ++j)
                    object.infos[j] = $root.logreport.PublishQualityInfo.toObject(message.infos[j], options);
            }
            if (message.room_id != null && message.hasOwnProperty("room_id"))
                object.room_id = message.room_id;
            if (message.evnvironment != null && message.hasOwnProperty("evnvironment"))
                object.evnvironment = message.evnvironment;
            if (message.ap != null && message.hasOwnProperty("ap"))
                object.ap = message.ap;
            if (message.session != null && message.hasOwnProperty("session"))
                object.session = message.session;
            if (message.room_session_id != null && message.hasOwnProperty("room_session_id"))
                if (typeof message.room_session_id === "number")
                    object.room_session_id = options.longs === String ? String(message.room_session_id) : message.room_session_id;
                else
                    object.room_session_id = options.longs === String ? $util.Long.prototype.toString.call(message.room_session_id) : options.longs === Number ? new $util.LongBits(message.room_session_id.low >>> 0, message.room_session_id.high >>> 0).toNumber(true) : message.room_session_id;
            if (message.protocol_type != null && message.hasOwnProperty("protocol_type"))
                object.protocol_type = message.protocol_type;
            return object;
        };

        /**
         * Converts this PublishQualityInfos to JSON.
         * @function toJSON
         * @memberof logreport.PublishQualityInfos
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PublishQualityInfos.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PublishQualityInfos;
    })();

    logreport.PlayQualityInfos = (function() {

        /**
         * Properties of a PlayQualityInfos.
         * @memberof logreport
         * @interface IPlayQualityInfos
         * @property {number|null} [timestamp_offset_begin] PlayQualityInfos timestamp_offset_begin
         * @property {number|null} [timestamp_offset_end] PlayQualityInfos timestamp_offset_end
         * @property {string|null} [stream_id] PlayQualityInfos stream_id
         * @property {number|null} [session_id] PlayQualityInfos session_id
         * @property {number|null} [video_width] PlayQualityInfos video_width
         * @property {number|null} [video_height] PlayQualityInfos video_height
         * @property {number|null} [ipv4] PlayQualityInfos ipv4
         * @property {string|null} [ipv6] PlayQualityInfos ipv6
         * @property {number|null} [resource_type] PlayQualityInfos resource_type
         * @property {Array.<logreport.IPlayQualityInfo>|null} [infos] PlayQualityInfos infos
         * @property {string|null} [room_id] PlayQualityInfos room_id
         * @property {string|null} [session] PlayQualityInfos session
         * @property {number|Long|null} [room_session_id] PlayQualityInfos room_session_id
         * @property {number|null} [protocol_type] PlayQualityInfos protocol_type
         */

        /**
         * Constructs a new PlayQualityInfos.
         * @memberof logreport
         * @classdesc Represents a PlayQualityInfos.
         * @implements IPlayQualityInfos
         * @constructor
         * @param {logreport.IPlayQualityInfos=} [properties] Properties to set
         */
        function PlayQualityInfos(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlayQualityInfos timestamp_offset_begin.
         * @member {number} timestamp_offset_begin
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.timestamp_offset_begin = 0;

        /**
         * PlayQualityInfos timestamp_offset_end.
         * @member {number} timestamp_offset_end
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.timestamp_offset_end = 0;

        /**
         * PlayQualityInfos stream_id.
         * @member {string} stream_id
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.stream_id = "";

        /**
         * PlayQualityInfos session_id.
         * @member {number} session_id
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.session_id = 0;

        /**
         * PlayQualityInfos video_width.
         * @member {number} video_width
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.video_width = 0;

        /**
         * PlayQualityInfos video_height.
         * @member {number} video_height
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.video_height = 0;

        /**
         * PlayQualityInfos ipv4.
         * @member {number} ipv4
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.ipv4 = 0;

        /**
         * PlayQualityInfos ipv6.
         * @member {string} ipv6
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.ipv6 = "";

        /**
         * PlayQualityInfos resource_type.
         * @member {number} resource_type
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.resource_type = 0;

        /**
         * PlayQualityInfos infos.
         * @member {Array.<logreport.IPlayQualityInfo>} infos
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.infos = $util.emptyArray;

        /**
         * PlayQualityInfos room_id.
         * @member {string} room_id
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.room_id = "";

        /**
         * PlayQualityInfos session.
         * @member {string} session
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.session = "";

        /**
         * PlayQualityInfos room_session_id.
         * @member {number|Long} room_session_id
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.room_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PlayQualityInfos protocol_type.
         * @member {number} protocol_type
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.protocol_type = 0;

        /**
         * Creates a new PlayQualityInfos instance using the specified properties.
         * @function create
         * @memberof logreport.PlayQualityInfos
         * @static
         * @param {logreport.IPlayQualityInfos=} [properties] Properties to set
         * @returns {logreport.PlayQualityInfos} PlayQualityInfos instance
         */
        PlayQualityInfos.create = function create(properties) {
            return new PlayQualityInfos(properties);
        };

        /**
         * Encodes the specified PlayQualityInfos message. Does not implicitly {@link logreport.PlayQualityInfos.verify|verify} messages.
         * @function encode
         * @memberof logreport.PlayQualityInfos
         * @static
         * @param {logreport.IPlayQualityInfos} message PlayQualityInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayQualityInfos.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp_offset_begin != null && Object.hasOwnProperty.call(message, "timestamp_offset_begin"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timestamp_offset_begin);
            if (message.timestamp_offset_end != null && Object.hasOwnProperty.call(message, "timestamp_offset_end"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.timestamp_offset_end);
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.stream_id);
            if (message.session_id != null && Object.hasOwnProperty.call(message, "session_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.session_id);
            if (message.video_width != null && Object.hasOwnProperty.call(message, "video_width"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.video_width);
            if (message.video_height != null && Object.hasOwnProperty.call(message, "video_height"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.video_height);
            if (message.ipv4 != null && Object.hasOwnProperty.call(message, "ipv4"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.ipv4);
            if (message.ipv6 != null && Object.hasOwnProperty.call(message, "ipv6"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.ipv6);
            if (message.resource_type != null && Object.hasOwnProperty.call(message, "resource_type"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.resource_type);
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.logreport.PlayQualityInfo.encode(message.infos[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.room_id);
            if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.session);
            if (message.room_session_id != null && Object.hasOwnProperty.call(message, "room_session_id"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint64(message.room_session_id);
            if (message.protocol_type != null && Object.hasOwnProperty.call(message, "protocol_type"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.protocol_type);
            return writer;
        };

        /**
         * Encodes the specified PlayQualityInfos message, length delimited. Does not implicitly {@link logreport.PlayQualityInfos.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.PlayQualityInfos
         * @static
         * @param {logreport.IPlayQualityInfos} message PlayQualityInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayQualityInfos.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlayQualityInfos message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.PlayQualityInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.PlayQualityInfos} PlayQualityInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayQualityInfos.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.PlayQualityInfos();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp_offset_begin = reader.uint32();
                    break;
                case 2:
                    message.timestamp_offset_end = reader.uint32();
                    break;
                case 3:
                    message.stream_id = reader.string();
                    break;
                case 4:
                    message.session_id = reader.uint32();
                    break;
                case 5:
                    message.video_width = reader.uint32();
                    break;
                case 6:
                    message.video_height = reader.uint32();
                    break;
                case 7:
                    message.ipv4 = reader.uint32();
                    break;
                case 8:
                    message.ipv6 = reader.string();
                    break;
                case 9:
                    message.resource_type = reader.uint32();
                    break;
                case 10:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.logreport.PlayQualityInfo.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.room_id = reader.string();
                    break;
                case 13:
                    message.session = reader.string();
                    break;
                case 14:
                    message.room_session_id = reader.uint64();
                    break;
                case 15:
                    message.protocol_type = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlayQualityInfos message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.PlayQualityInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.PlayQualityInfos} PlayQualityInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayQualityInfos.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlayQualityInfos message.
         * @function verify
         * @memberof logreport.PlayQualityInfos
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayQualityInfos.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                if (!$util.isInteger(message.timestamp_offset_begin))
                    return "timestamp_offset_begin: integer expected";
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                if (!$util.isInteger(message.timestamp_offset_end))
                    return "timestamp_offset_end: integer expected";
            if (message.stream_id != null && message.hasOwnProperty("stream_id"))
                if (!$util.isString(message.stream_id))
                    return "stream_id: string expected";
            if (message.session_id != null && message.hasOwnProperty("session_id"))
                if (!$util.isInteger(message.session_id))
                    return "session_id: integer expected";
            if (message.video_width != null && message.hasOwnProperty("video_width"))
                if (!$util.isInteger(message.video_width))
                    return "video_width: integer expected";
            if (message.video_height != null && message.hasOwnProperty("video_height"))
                if (!$util.isInteger(message.video_height))
                    return "video_height: integer expected";
            if (message.ipv4 != null && message.hasOwnProperty("ipv4"))
                if (!$util.isInteger(message.ipv4))
                    return "ipv4: integer expected";
            if (message.ipv6 != null && message.hasOwnProperty("ipv6"))
                if (!$util.isString(message.ipv6))
                    return "ipv6: string expected";
            if (message.resource_type != null && message.hasOwnProperty("resource_type"))
                if (!$util.isInteger(message.resource_type))
                    return "resource_type: integer expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.logreport.PlayQualityInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            if (message.room_id != null && message.hasOwnProperty("room_id"))
                if (!$util.isString(message.room_id))
                    return "room_id: string expected";
            if (message.session != null && message.hasOwnProperty("session"))
                if (!$util.isString(message.session))
                    return "session: string expected";
            if (message.room_session_id != null && message.hasOwnProperty("room_session_id"))
                if (!$util.isInteger(message.room_session_id) && !(message.room_session_id && $util.isInteger(message.room_session_id.low) && $util.isInteger(message.room_session_id.high)))
                    return "room_session_id: integer|Long expected";
            if (message.protocol_type != null && message.hasOwnProperty("protocol_type"))
                if (!$util.isInteger(message.protocol_type))
                    return "protocol_type: integer expected";
            return null;
        };

        /**
         * Creates a PlayQualityInfos message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.PlayQualityInfos
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.PlayQualityInfos} PlayQualityInfos
         */
        PlayQualityInfos.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.PlayQualityInfos)
                return object;
            var message = new $root.logreport.PlayQualityInfos();
            if (object.timestamp_offset_begin != null)
                message.timestamp_offset_begin = object.timestamp_offset_begin >>> 0;
            if (object.timestamp_offset_end != null)
                message.timestamp_offset_end = object.timestamp_offset_end >>> 0;
            if (object.stream_id != null)
                message.stream_id = String(object.stream_id);
            if (object.session_id != null)
                message.session_id = object.session_id >>> 0;
            if (object.video_width != null)
                message.video_width = object.video_width >>> 0;
            if (object.video_height != null)
                message.video_height = object.video_height >>> 0;
            if (object.ipv4 != null)
                message.ipv4 = object.ipv4 >>> 0;
            if (object.ipv6 != null)
                message.ipv6 = String(object.ipv6);
            if (object.resource_type != null)
                message.resource_type = object.resource_type >>> 0;
            if (object.infos) {
                if (!Array.isArray(object.infos))
                    throw TypeError(".logreport.PlayQualityInfos.infos: array expected");
                message.infos = [];
                for (var i = 0; i < object.infos.length; ++i) {
                    if (typeof object.infos[i] !== "object")
                        throw TypeError(".logreport.PlayQualityInfos.infos: object expected");
                    message.infos[i] = $root.logreport.PlayQualityInfo.fromObject(object.infos[i]);
                }
            }
            if (object.room_id != null)
                message.room_id = String(object.room_id);
            if (object.session != null)
                message.session = String(object.session);
            if (object.room_session_id != null)
                if ($util.Long)
                    (message.room_session_id = $util.Long.fromValue(object.room_session_id)).unsigned = true;
                else if (typeof object.room_session_id === "string")
                    message.room_session_id = parseInt(object.room_session_id, 10);
                else if (typeof object.room_session_id === "number")
                    message.room_session_id = object.room_session_id;
                else if (typeof object.room_session_id === "object")
                    message.room_session_id = new $util.LongBits(object.room_session_id.low >>> 0, object.room_session_id.high >>> 0).toNumber(true);
            if (object.protocol_type != null)
                message.protocol_type = object.protocol_type >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PlayQualityInfos message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.PlayQualityInfos
         * @static
         * @param {logreport.PlayQualityInfos} message PlayQualityInfos
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayQualityInfos.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.infos = [];
            if (options.defaults) {
                object.timestamp_offset_begin = 0;
                object.timestamp_offset_end = 0;
                object.stream_id = "";
                object.session_id = 0;
                object.video_width = 0;
                object.video_height = 0;
                object.ipv4 = 0;
                object.ipv6 = "";
                object.resource_type = 0;
                object.room_id = "";
                object.session = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.room_session_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.room_session_id = options.longs === String ? "0" : 0;
                object.protocol_type = 0;
            }
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                object.timestamp_offset_begin = message.timestamp_offset_begin;
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                object.timestamp_offset_end = message.timestamp_offset_end;
            if (message.stream_id != null && message.hasOwnProperty("stream_id"))
                object.stream_id = message.stream_id;
            if (message.session_id != null && message.hasOwnProperty("session_id"))
                object.session_id = message.session_id;
            if (message.video_width != null && message.hasOwnProperty("video_width"))
                object.video_width = message.video_width;
            if (message.video_height != null && message.hasOwnProperty("video_height"))
                object.video_height = message.video_height;
            if (message.ipv4 != null && message.hasOwnProperty("ipv4"))
                object.ipv4 = message.ipv4;
            if (message.ipv6 != null && message.hasOwnProperty("ipv6"))
                object.ipv6 = message.ipv6;
            if (message.resource_type != null && message.hasOwnProperty("resource_type"))
                object.resource_type = message.resource_type;
            if (message.infos && message.infos.length) {
                object.infos = [];
                for (var j = 0; j < message.infos.length; ++j)
                    object.infos[j] = $root.logreport.PlayQualityInfo.toObject(message.infos[j], options);
            }
            if (message.room_id != null && message.hasOwnProperty("room_id"))
                object.room_id = message.room_id;
            if (message.session != null && message.hasOwnProperty("session"))
                object.session = message.session;
            if (message.room_session_id != null && message.hasOwnProperty("room_session_id"))
                if (typeof message.room_session_id === "number")
                    object.room_session_id = options.longs === String ? String(message.room_session_id) : message.room_session_id;
                else
                    object.room_session_id = options.longs === String ? $util.Long.prototype.toString.call(message.room_session_id) : options.longs === Number ? new $util.LongBits(message.room_session_id.low >>> 0, message.room_session_id.high >>> 0).toNumber(true) : message.room_session_id;
            if (message.protocol_type != null && message.hasOwnProperty("protocol_type"))
                object.protocol_type = message.protocol_type;
            return object;
        };

        /**
         * Converts this PlayQualityInfos to JSON.
         * @function toJSON
         * @memberof logreport.PlayQualityInfos
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayQualityInfos.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlayQualityInfos;
    })();

    logreport.ChargeInfos = (function() {

        /**
         * Properties of a ChargeInfos.
         * @memberof logreport
         * @interface IChargeInfos
         * @property {number|null} [timestamp_offset_begin] ChargeInfos timestamp_offset_begin
         * @property {number|null} [timestamp_offset_end] ChargeInfos timestamp_offset_end
         * @property {number|null} [timestamp_diff_flag] ChargeInfos timestamp_diff_flag
         * @property {number|null} [timestamp_diff] ChargeInfos timestamp_diff
         * @property {string|null} [room_id] ChargeInfos room_id
         * @property {Array.<logreport.IChargeInfo>|null} [infos] ChargeInfos infos
         */

        /**
         * Constructs a new ChargeInfos.
         * @memberof logreport
         * @classdesc Represents a ChargeInfos.
         * @implements IChargeInfos
         * @constructor
         * @param {logreport.IChargeInfos=} [properties] Properties to set
         */
        function ChargeInfos(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChargeInfos timestamp_offset_begin.
         * @member {number} timestamp_offset_begin
         * @memberof logreport.ChargeInfos
         * @instance
         */
        ChargeInfos.prototype.timestamp_offset_begin = 0;

        /**
         * ChargeInfos timestamp_offset_end.
         * @member {number} timestamp_offset_end
         * @memberof logreport.ChargeInfos
         * @instance
         */
        ChargeInfos.prototype.timestamp_offset_end = 0;

        /**
         * ChargeInfos timestamp_diff_flag.
         * @member {number} timestamp_diff_flag
         * @memberof logreport.ChargeInfos
         * @instance
         */
        ChargeInfos.prototype.timestamp_diff_flag = 0;

        /**
         * ChargeInfos timestamp_diff.
         * @member {number} timestamp_diff
         * @memberof logreport.ChargeInfos
         * @instance
         */
        ChargeInfos.prototype.timestamp_diff = 0;

        /**
         * ChargeInfos room_id.
         * @member {string} room_id
         * @memberof logreport.ChargeInfos
         * @instance
         */
        ChargeInfos.prototype.room_id = "";

        /**
         * ChargeInfos infos.
         * @member {Array.<logreport.IChargeInfo>} infos
         * @memberof logreport.ChargeInfos
         * @instance
         */
        ChargeInfos.prototype.infos = $util.emptyArray;

        /**
         * Creates a new ChargeInfos instance using the specified properties.
         * @function create
         * @memberof logreport.ChargeInfos
         * @static
         * @param {logreport.IChargeInfos=} [properties] Properties to set
         * @returns {logreport.ChargeInfos} ChargeInfos instance
         */
        ChargeInfos.create = function create(properties) {
            return new ChargeInfos(properties);
        };

        /**
         * Encodes the specified ChargeInfos message. Does not implicitly {@link logreport.ChargeInfos.verify|verify} messages.
         * @function encode
         * @memberof logreport.ChargeInfos
         * @static
         * @param {logreport.IChargeInfos} message ChargeInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChargeInfos.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp_offset_begin != null && Object.hasOwnProperty.call(message, "timestamp_offset_begin"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timestamp_offset_begin);
            if (message.timestamp_offset_end != null && Object.hasOwnProperty.call(message, "timestamp_offset_end"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.timestamp_offset_end);
            if (message.timestamp_diff_flag != null && Object.hasOwnProperty.call(message, "timestamp_diff_flag"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.timestamp_diff_flag);
            if (message.timestamp_diff != null && Object.hasOwnProperty.call(message, "timestamp_diff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.timestamp_diff);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.room_id);
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.logreport.ChargeInfo.encode(message.infos[i], writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChargeInfos message, length delimited. Does not implicitly {@link logreport.ChargeInfos.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.ChargeInfos
         * @static
         * @param {logreport.IChargeInfos} message ChargeInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChargeInfos.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChargeInfos message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.ChargeInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.ChargeInfos} ChargeInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChargeInfos.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.ChargeInfos();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp_offset_begin = reader.uint32();
                    break;
                case 2:
                    message.timestamp_offset_end = reader.uint32();
                    break;
                case 3:
                    message.timestamp_diff_flag = reader.uint32();
                    break;
                case 4:
                    message.timestamp_diff = reader.uint32();
                    break;
                case 5:
                    message.room_id = reader.string();
                    break;
                case 100:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.logreport.ChargeInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChargeInfos message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.ChargeInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.ChargeInfos} ChargeInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChargeInfos.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChargeInfos message.
         * @function verify
         * @memberof logreport.ChargeInfos
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChargeInfos.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                if (!$util.isInteger(message.timestamp_offset_begin))
                    return "timestamp_offset_begin: integer expected";
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                if (!$util.isInteger(message.timestamp_offset_end))
                    return "timestamp_offset_end: integer expected";
            if (message.timestamp_diff_flag != null && message.hasOwnProperty("timestamp_diff_flag"))
                if (!$util.isInteger(message.timestamp_diff_flag))
                    return "timestamp_diff_flag: integer expected";
            if (message.timestamp_diff != null && message.hasOwnProperty("timestamp_diff"))
                if (!$util.isInteger(message.timestamp_diff))
                    return "timestamp_diff: integer expected";
            if (message.room_id != null && message.hasOwnProperty("room_id"))
                if (!$util.isString(message.room_id))
                    return "room_id: string expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.logreport.ChargeInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ChargeInfos message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.ChargeInfos
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.ChargeInfos} ChargeInfos
         */
        ChargeInfos.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.ChargeInfos)
                return object;
            var message = new $root.logreport.ChargeInfos();
            if (object.timestamp_offset_begin != null)
                message.timestamp_offset_begin = object.timestamp_offset_begin >>> 0;
            if (object.timestamp_offset_end != null)
                message.timestamp_offset_end = object.timestamp_offset_end >>> 0;
            if (object.timestamp_diff_flag != null)
                message.timestamp_diff_flag = object.timestamp_diff_flag >>> 0;
            if (object.timestamp_diff != null)
                message.timestamp_diff = object.timestamp_diff >>> 0;
            if (object.room_id != null)
                message.room_id = String(object.room_id);
            if (object.infos) {
                if (!Array.isArray(object.infos))
                    throw TypeError(".logreport.ChargeInfos.infos: array expected");
                message.infos = [];
                for (var i = 0; i < object.infos.length; ++i) {
                    if (typeof object.infos[i] !== "object")
                        throw TypeError(".logreport.ChargeInfos.infos: object expected");
                    message.infos[i] = $root.logreport.ChargeInfo.fromObject(object.infos[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ChargeInfos message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.ChargeInfos
         * @static
         * @param {logreport.ChargeInfos} message ChargeInfos
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChargeInfos.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.infos = [];
            if (options.defaults) {
                object.timestamp_offset_begin = 0;
                object.timestamp_offset_end = 0;
                object.timestamp_diff_flag = 0;
                object.timestamp_diff = 0;
                object.room_id = "";
            }
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                object.timestamp_offset_begin = message.timestamp_offset_begin;
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                object.timestamp_offset_end = message.timestamp_offset_end;
            if (message.timestamp_diff_flag != null && message.hasOwnProperty("timestamp_diff_flag"))
                object.timestamp_diff_flag = message.timestamp_diff_flag;
            if (message.timestamp_diff != null && message.hasOwnProperty("timestamp_diff"))
                object.timestamp_diff = message.timestamp_diff;
            if (message.room_id != null && message.hasOwnProperty("room_id"))
                object.room_id = message.room_id;
            if (message.infos && message.infos.length) {
                object.infos = [];
                for (var j = 0; j < message.infos.length; ++j)
                    object.infos[j] = $root.logreport.ChargeInfo.toObject(message.infos[j], options);
            }
            return object;
        };

        /**
         * Converts this ChargeInfos to JSON.
         * @function toJSON
         * @memberof logreport.ChargeInfos
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChargeInfos.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChargeInfos;
    })();

    logreport.HardwareInfo = (function() {

        /**
         * Properties of a HardwareInfo.
         * @memberof logreport
         * @interface IHardwareInfo
         * @property {number|null} [sys_cpu_used] HardwareInfo sys_cpu_used
         * @property {number|null} [app_cpu_used] HardwareInfo app_cpu_used
         * @property {number|null} [sys_mem_used] HardwareInfo sys_mem_used
         * @property {number|null} [app_mem_used] HardwareInfo app_mem_used
         */

        /**
         * Constructs a new HardwareInfo.
         * @memberof logreport
         * @classdesc Represents a HardwareInfo.
         * @implements IHardwareInfo
         * @constructor
         * @param {logreport.IHardwareInfo=} [properties] Properties to set
         */
        function HardwareInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HardwareInfo sys_cpu_used.
         * @member {number} sys_cpu_used
         * @memberof logreport.HardwareInfo
         * @instance
         */
        HardwareInfo.prototype.sys_cpu_used = 0;

        /**
         * HardwareInfo app_cpu_used.
         * @member {number} app_cpu_used
         * @memberof logreport.HardwareInfo
         * @instance
         */
        HardwareInfo.prototype.app_cpu_used = 0;

        /**
         * HardwareInfo sys_mem_used.
         * @member {number} sys_mem_used
         * @memberof logreport.HardwareInfo
         * @instance
         */
        HardwareInfo.prototype.sys_mem_used = 0;

        /**
         * HardwareInfo app_mem_used.
         * @member {number} app_mem_used
         * @memberof logreport.HardwareInfo
         * @instance
         */
        HardwareInfo.prototype.app_mem_used = 0;

        /**
         * Creates a new HardwareInfo instance using the specified properties.
         * @function create
         * @memberof logreport.HardwareInfo
         * @static
         * @param {logreport.IHardwareInfo=} [properties] Properties to set
         * @returns {logreport.HardwareInfo} HardwareInfo instance
         */
        HardwareInfo.create = function create(properties) {
            return new HardwareInfo(properties);
        };

        /**
         * Encodes the specified HardwareInfo message. Does not implicitly {@link logreport.HardwareInfo.verify|verify} messages.
         * @function encode
         * @memberof logreport.HardwareInfo
         * @static
         * @param {logreport.IHardwareInfo} message HardwareInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HardwareInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sys_cpu_used != null && Object.hasOwnProperty.call(message, "sys_cpu_used"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.sys_cpu_used);
            if (message.app_cpu_used != null && Object.hasOwnProperty.call(message, "app_cpu_used"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.app_cpu_used);
            if (message.sys_mem_used != null && Object.hasOwnProperty.call(message, "sys_mem_used"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.sys_mem_used);
            if (message.app_mem_used != null && Object.hasOwnProperty.call(message, "app_mem_used"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.app_mem_used);
            return writer;
        };

        /**
         * Encodes the specified HardwareInfo message, length delimited. Does not implicitly {@link logreport.HardwareInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.HardwareInfo
         * @static
         * @param {logreport.IHardwareInfo} message HardwareInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HardwareInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HardwareInfo message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.HardwareInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.HardwareInfo} HardwareInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HardwareInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.HardwareInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sys_cpu_used = reader.uint32();
                    break;
                case 2:
                    message.app_cpu_used = reader.uint32();
                    break;
                case 3:
                    message.sys_mem_used = reader.uint32();
                    break;
                case 4:
                    message.app_mem_used = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HardwareInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.HardwareInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.HardwareInfo} HardwareInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HardwareInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HardwareInfo message.
         * @function verify
         * @memberof logreport.HardwareInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HardwareInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sys_cpu_used != null && message.hasOwnProperty("sys_cpu_used"))
                if (!$util.isInteger(message.sys_cpu_used))
                    return "sys_cpu_used: integer expected";
            if (message.app_cpu_used != null && message.hasOwnProperty("app_cpu_used"))
                if (!$util.isInteger(message.app_cpu_used))
                    return "app_cpu_used: integer expected";
            if (message.sys_mem_used != null && message.hasOwnProperty("sys_mem_used"))
                if (!$util.isInteger(message.sys_mem_used))
                    return "sys_mem_used: integer expected";
            if (message.app_mem_used != null && message.hasOwnProperty("app_mem_used"))
                if (!$util.isInteger(message.app_mem_used))
                    return "app_mem_used: integer expected";
            return null;
        };

        /**
         * Creates a HardwareInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.HardwareInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.HardwareInfo} HardwareInfo
         */
        HardwareInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.HardwareInfo)
                return object;
            var message = new $root.logreport.HardwareInfo();
            if (object.sys_cpu_used != null)
                message.sys_cpu_used = object.sys_cpu_used >>> 0;
            if (object.app_cpu_used != null)
                message.app_cpu_used = object.app_cpu_used >>> 0;
            if (object.sys_mem_used != null)
                message.sys_mem_used = object.sys_mem_used >>> 0;
            if (object.app_mem_used != null)
                message.app_mem_used = object.app_mem_used >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a HardwareInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.HardwareInfo
         * @static
         * @param {logreport.HardwareInfo} message HardwareInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HardwareInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sys_cpu_used = 0;
                object.app_cpu_used = 0;
                object.sys_mem_used = 0;
                object.app_mem_used = 0;
            }
            if (message.sys_cpu_used != null && message.hasOwnProperty("sys_cpu_used"))
                object.sys_cpu_used = message.sys_cpu_used;
            if (message.app_cpu_used != null && message.hasOwnProperty("app_cpu_used"))
                object.app_cpu_used = message.app_cpu_used;
            if (message.sys_mem_used != null && message.hasOwnProperty("sys_mem_used"))
                object.sys_mem_used = message.sys_mem_used;
            if (message.app_mem_used != null && message.hasOwnProperty("app_mem_used"))
                object.app_mem_used = message.app_mem_used;
            return object;
        };

        /**
         * Converts this HardwareInfo to JSON.
         * @function toJSON
         * @memberof logreport.HardwareInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HardwareInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HardwareInfo;
    })();

    logreport.PublishQualityInfo = (function() {

        /**
         * Properties of a PublishQualityInfo.
         * @memberof logreport
         * @interface IPublishQualityInfo
         * @property {number|null} [audio_bitrate] PublishQualityInfo audio_bitrate
         * @property {number|null} [video_bitrate] PublishQualityInfo video_bitrate
         * @property {number|null} [video_capture_fps] PublishQualityInfo video_capture_fps
         * @property {number|null} [video_network_fps] PublishQualityInfo video_network_fps
         * @property {number|null} [uplink_plr] PublishQualityInfo uplink_plr
         * @property {number|null} [rtt] PublishQualityInfo rtt
         * @property {number|null} [audio_network_fps] PublishQualityInfo audio_network_fps
         * @property {number|null} [captured_sound_level] PublishQualityInfo captured_sound_level
         * @property {number|null} [sample_time_window] PublishQualityInfo sample_time_window
         */

        /**
         * Constructs a new PublishQualityInfo.
         * @memberof logreport
         * @classdesc Represents a PublishQualityInfo.
         * @implements IPublishQualityInfo
         * @constructor
         * @param {logreport.IPublishQualityInfo=} [properties] Properties to set
         */
        function PublishQualityInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublishQualityInfo audio_bitrate.
         * @member {number} audio_bitrate
         * @memberof logreport.PublishQualityInfo
         * @instance
         */
        PublishQualityInfo.prototype.audio_bitrate = 0;

        /**
         * PublishQualityInfo video_bitrate.
         * @member {number} video_bitrate
         * @memberof logreport.PublishQualityInfo
         * @instance
         */
        PublishQualityInfo.prototype.video_bitrate = 0;

        /**
         * PublishQualityInfo video_capture_fps.
         * @member {number} video_capture_fps
         * @memberof logreport.PublishQualityInfo
         * @instance
         */
        PublishQualityInfo.prototype.video_capture_fps = 0;

        /**
         * PublishQualityInfo video_network_fps.
         * @member {number} video_network_fps
         * @memberof logreport.PublishQualityInfo
         * @instance
         */
        PublishQualityInfo.prototype.video_network_fps = 0;

        /**
         * PublishQualityInfo uplink_plr.
         * @member {number} uplink_plr
         * @memberof logreport.PublishQualityInfo
         * @instance
         */
        PublishQualityInfo.prototype.uplink_plr = 0;

        /**
         * PublishQualityInfo rtt.
         * @member {number} rtt
         * @memberof logreport.PublishQualityInfo
         * @instance
         */
        PublishQualityInfo.prototype.rtt = 0;

        /**
         * PublishQualityInfo audio_network_fps.
         * @member {number} audio_network_fps
         * @memberof logreport.PublishQualityInfo
         * @instance
         */
        PublishQualityInfo.prototype.audio_network_fps = 0;

        /**
         * PublishQualityInfo captured_sound_level.
         * @member {number} captured_sound_level
         * @memberof logreport.PublishQualityInfo
         * @instance
         */
        PublishQualityInfo.prototype.captured_sound_level = 0;

        /**
         * PublishQualityInfo sample_time_window.
         * @member {number} sample_time_window
         * @memberof logreport.PublishQualityInfo
         * @instance
         */
        PublishQualityInfo.prototype.sample_time_window = 0;

        /**
         * Creates a new PublishQualityInfo instance using the specified properties.
         * @function create
         * @memberof logreport.PublishQualityInfo
         * @static
         * @param {logreport.IPublishQualityInfo=} [properties] Properties to set
         * @returns {logreport.PublishQualityInfo} PublishQualityInfo instance
         */
        PublishQualityInfo.create = function create(properties) {
            return new PublishQualityInfo(properties);
        };

        /**
         * Encodes the specified PublishQualityInfo message. Does not implicitly {@link logreport.PublishQualityInfo.verify|verify} messages.
         * @function encode
         * @memberof logreport.PublishQualityInfo
         * @static
         * @param {logreport.IPublishQualityInfo} message PublishQualityInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishQualityInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audio_bitrate != null && Object.hasOwnProperty.call(message, "audio_bitrate"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.audio_bitrate);
            if (message.video_bitrate != null && Object.hasOwnProperty.call(message, "video_bitrate"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.video_bitrate);
            if (message.video_capture_fps != null && Object.hasOwnProperty.call(message, "video_capture_fps"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.video_capture_fps);
            if (message.video_network_fps != null && Object.hasOwnProperty.call(message, "video_network_fps"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.video_network_fps);
            if (message.uplink_plr != null && Object.hasOwnProperty.call(message, "uplink_plr"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.uplink_plr);
            if (message.rtt != null && Object.hasOwnProperty.call(message, "rtt"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.rtt);
            if (message.audio_network_fps != null && Object.hasOwnProperty.call(message, "audio_network_fps"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.audio_network_fps);
            if (message.captured_sound_level != null && Object.hasOwnProperty.call(message, "captured_sound_level"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.captured_sound_level);
            if (message.sample_time_window != null && Object.hasOwnProperty.call(message, "sample_time_window"))
                writer.uint32(/* id 100, wireType 0 =*/800).uint32(message.sample_time_window);
            return writer;
        };

        /**
         * Encodes the specified PublishQualityInfo message, length delimited. Does not implicitly {@link logreport.PublishQualityInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.PublishQualityInfo
         * @static
         * @param {logreport.IPublishQualityInfo} message PublishQualityInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishQualityInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PublishQualityInfo message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.PublishQualityInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.PublishQualityInfo} PublishQualityInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishQualityInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.PublishQualityInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.audio_bitrate = reader.uint32();
                    break;
                case 2:
                    message.video_bitrate = reader.uint32();
                    break;
                case 3:
                    message.video_capture_fps = reader.uint32();
                    break;
                case 4:
                    message.video_network_fps = reader.uint32();
                    break;
                case 5:
                    message.uplink_plr = reader.uint32();
                    break;
                case 6:
                    message.rtt = reader.uint32();
                    break;
                case 7:
                    message.audio_network_fps = reader.uint32();
                    break;
                case 8:
                    message.captured_sound_level = reader.uint32();
                    break;
                case 100:
                    message.sample_time_window = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PublishQualityInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.PublishQualityInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.PublishQualityInfo} PublishQualityInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishQualityInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PublishQualityInfo message.
         * @function verify
         * @memberof logreport.PublishQualityInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PublishQualityInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.audio_bitrate != null && message.hasOwnProperty("audio_bitrate"))
                if (!$util.isInteger(message.audio_bitrate))
                    return "audio_bitrate: integer expected";
            if (message.video_bitrate != null && message.hasOwnProperty("video_bitrate"))
                if (!$util.isInteger(message.video_bitrate))
                    return "video_bitrate: integer expected";
            if (message.video_capture_fps != null && message.hasOwnProperty("video_capture_fps"))
                if (!$util.isInteger(message.video_capture_fps))
                    return "video_capture_fps: integer expected";
            if (message.video_network_fps != null && message.hasOwnProperty("video_network_fps"))
                if (!$util.isInteger(message.video_network_fps))
                    return "video_network_fps: integer expected";
            if (message.uplink_plr != null && message.hasOwnProperty("uplink_plr"))
                if (!$util.isInteger(message.uplink_plr))
                    return "uplink_plr: integer expected";
            if (message.rtt != null && message.hasOwnProperty("rtt"))
                if (!$util.isInteger(message.rtt))
                    return "rtt: integer expected";
            if (message.audio_network_fps != null && message.hasOwnProperty("audio_network_fps"))
                if (!$util.isInteger(message.audio_network_fps))
                    return "audio_network_fps: integer expected";
            if (message.captured_sound_level != null && message.hasOwnProperty("captured_sound_level"))
                if (!$util.isInteger(message.captured_sound_level))
                    return "captured_sound_level: integer expected";
            if (message.sample_time_window != null && message.hasOwnProperty("sample_time_window"))
                if (!$util.isInteger(message.sample_time_window))
                    return "sample_time_window: integer expected";
            return null;
        };

        /**
         * Creates a PublishQualityInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.PublishQualityInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.PublishQualityInfo} PublishQualityInfo
         */
        PublishQualityInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.PublishQualityInfo)
                return object;
            var message = new $root.logreport.PublishQualityInfo();
            if (object.audio_bitrate != null)
                message.audio_bitrate = object.audio_bitrate >>> 0;
            if (object.video_bitrate != null)
                message.video_bitrate = object.video_bitrate >>> 0;
            if (object.video_capture_fps != null)
                message.video_capture_fps = object.video_capture_fps >>> 0;
            if (object.video_network_fps != null)
                message.video_network_fps = object.video_network_fps >>> 0;
            if (object.uplink_plr != null)
                message.uplink_plr = object.uplink_plr >>> 0;
            if (object.rtt != null)
                message.rtt = object.rtt >>> 0;
            if (object.audio_network_fps != null)
                message.audio_network_fps = object.audio_network_fps >>> 0;
            if (object.captured_sound_level != null)
                message.captured_sound_level = object.captured_sound_level >>> 0;
            if (object.sample_time_window != null)
                message.sample_time_window = object.sample_time_window >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PublishQualityInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.PublishQualityInfo
         * @static
         * @param {logreport.PublishQualityInfo} message PublishQualityInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PublishQualityInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.audio_bitrate = 0;
                object.video_bitrate = 0;
                object.video_capture_fps = 0;
                object.video_network_fps = 0;
                object.uplink_plr = 0;
                object.rtt = 0;
                object.audio_network_fps = 0;
                object.captured_sound_level = 0;
                object.sample_time_window = 0;
            }
            if (message.audio_bitrate != null && message.hasOwnProperty("audio_bitrate"))
                object.audio_bitrate = message.audio_bitrate;
            if (message.video_bitrate != null && message.hasOwnProperty("video_bitrate"))
                object.video_bitrate = message.video_bitrate;
            if (message.video_capture_fps != null && message.hasOwnProperty("video_capture_fps"))
                object.video_capture_fps = message.video_capture_fps;
            if (message.video_network_fps != null && message.hasOwnProperty("video_network_fps"))
                object.video_network_fps = message.video_network_fps;
            if (message.uplink_plr != null && message.hasOwnProperty("uplink_plr"))
                object.uplink_plr = message.uplink_plr;
            if (message.rtt != null && message.hasOwnProperty("rtt"))
                object.rtt = message.rtt;
            if (message.audio_network_fps != null && message.hasOwnProperty("audio_network_fps"))
                object.audio_network_fps = message.audio_network_fps;
            if (message.captured_sound_level != null && message.hasOwnProperty("captured_sound_level"))
                object.captured_sound_level = message.captured_sound_level;
            if (message.sample_time_window != null && message.hasOwnProperty("sample_time_window"))
                object.sample_time_window = message.sample_time_window;
            return object;
        };

        /**
         * Converts this PublishQualityInfo to JSON.
         * @function toJSON
         * @memberof logreport.PublishQualityInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PublishQualityInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PublishQualityInfo;
    })();

    logreport.PlayQualityInfo = (function() {

        /**
         * Properties of a PlayQualityInfo.
         * @memberof logreport
         * @interface IPlayQualityInfo
         * @property {number|null} [audio_bitrate] PlayQualityInfo audio_bitrate
         * @property {number|null} [video_bitrate] PlayQualityInfo video_bitrate
         * @property {number|null} [video_network_fps] PlayQualityInfo video_network_fps
         * @property {number|null} [audio_break_count] PlayQualityInfo audio_break_count
         * @property {number|null} [video_break_count] PlayQualityInfo video_break_count
         * @property {number|null} [downlink_plr] PlayQualityInfo downlink_plr
         * @property {number|null} [peer_to_peer_plr] PlayQualityInfo peer_to_peer_plr
         * @property {number|null} [peer_to_peer_delay] PlayQualityInfo peer_to_peer_delay
         * @property {number|null} [audio_network_fps] PlayQualityInfo audio_network_fps
         * @property {number|null} [audio_break_duration] PlayQualityInfo audio_break_duration
         * @property {number|null} [video_break_duration] PlayQualityInfo video_break_duration
         * @property {number|null} [audio_break_rate] PlayQualityInfo audio_break_rate
         * @property {number|null} [video_break_rate] PlayQualityInfo video_break_rate
         * @property {number|null} [audio_break_cancel] PlayQualityInfo audio_break_cancel
         * @property {number|null} [video_break_cancel] PlayQualityInfo video_break_cancel
         * @property {number|null} [rtt] PlayQualityInfo rtt
         * @property {number|null} [rendered_sound_level] PlayQualityInfo rendered_sound_level
         * @property {number|null} [audio_break_cancel_duration] PlayQualityInfo audio_break_cancel_duration
         * @property {number|null} [video_break_cancel_duration] PlayQualityInfo video_break_cancel_duration
         * @property {number|null} [audio_decode_time] PlayQualityInfo audio_decode_time
         * @property {number|null} [video_decode_time] PlayQualityInfo video_decode_time
         * @property {number|null} [real_sampling_interval] PlayQualityInfo real_sampling_interval
         * @property {number|null} [mos] PlayQualityInfo mos
         * @property {number|null} [audio_decode_fps] PlayQualityInfo audio_decode_fps
         * @property {number|null} [video_decode_fps] PlayQualityInfo video_decode_fps
         * @property {number|null} [video_frames_decoded] PlayQualityInfo video_frames_decoded
         * @property {number|null} [video_frames_dropped] PlayQualityInfo video_frames_dropped
         * @property {number|null} [sample_time_window] PlayQualityInfo sample_time_window
         */

        /**
         * Constructs a new PlayQualityInfo.
         * @memberof logreport
         * @classdesc Represents a PlayQualityInfo.
         * @implements IPlayQualityInfo
         * @constructor
         * @param {logreport.IPlayQualityInfo=} [properties] Properties to set
         */
        function PlayQualityInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlayQualityInfo audio_bitrate.
         * @member {number} audio_bitrate
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.audio_bitrate = 0;

        /**
         * PlayQualityInfo video_bitrate.
         * @member {number} video_bitrate
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_bitrate = 0;

        /**
         * PlayQualityInfo video_network_fps.
         * @member {number} video_network_fps
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_network_fps = 0;

        /**
         * PlayQualityInfo audio_break_count.
         * @member {number} audio_break_count
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.audio_break_count = 0;

        /**
         * PlayQualityInfo video_break_count.
         * @member {number} video_break_count
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_break_count = 0;

        /**
         * PlayQualityInfo downlink_plr.
         * @member {number} downlink_plr
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.downlink_plr = 0;

        /**
         * PlayQualityInfo peer_to_peer_plr.
         * @member {number} peer_to_peer_plr
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.peer_to_peer_plr = 0;

        /**
         * PlayQualityInfo peer_to_peer_delay.
         * @member {number} peer_to_peer_delay
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.peer_to_peer_delay = 0;

        /**
         * PlayQualityInfo audio_network_fps.
         * @member {number} audio_network_fps
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.audio_network_fps = 0;

        /**
         * PlayQualityInfo audio_break_duration.
         * @member {number} audio_break_duration
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.audio_break_duration = 0;

        /**
         * PlayQualityInfo video_break_duration.
         * @member {number} video_break_duration
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_break_duration = 0;

        /**
         * PlayQualityInfo audio_break_rate.
         * @member {number} audio_break_rate
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.audio_break_rate = 0;

        /**
         * PlayQualityInfo video_break_rate.
         * @member {number} video_break_rate
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_break_rate = 0;

        /**
         * PlayQualityInfo audio_break_cancel.
         * @member {number} audio_break_cancel
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.audio_break_cancel = 0;

        /**
         * PlayQualityInfo video_break_cancel.
         * @member {number} video_break_cancel
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_break_cancel = 0;

        /**
         * PlayQualityInfo rtt.
         * @member {number} rtt
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.rtt = 0;

        /**
         * PlayQualityInfo rendered_sound_level.
         * @member {number} rendered_sound_level
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.rendered_sound_level = 0;

        /**
         * PlayQualityInfo audio_break_cancel_duration.
         * @member {number} audio_break_cancel_duration
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.audio_break_cancel_duration = 0;

        /**
         * PlayQualityInfo video_break_cancel_duration.
         * @member {number} video_break_cancel_duration
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_break_cancel_duration = 0;

        /**
         * PlayQualityInfo audio_decode_time.
         * @member {number} audio_decode_time
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.audio_decode_time = 0;

        /**
         * PlayQualityInfo video_decode_time.
         * @member {number} video_decode_time
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_decode_time = 0;

        /**
         * PlayQualityInfo real_sampling_interval.
         * @member {number} real_sampling_interval
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.real_sampling_interval = 0;

        /**
         * PlayQualityInfo mos.
         * @member {number} mos
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.mos = 0;

        /**
         * PlayQualityInfo audio_decode_fps.
         * @member {number} audio_decode_fps
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.audio_decode_fps = 0;

        /**
         * PlayQualityInfo video_decode_fps.
         * @member {number} video_decode_fps
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_decode_fps = 0;

        /**
         * PlayQualityInfo video_frames_decoded.
         * @member {number} video_frames_decoded
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_frames_decoded = 0;

        /**
         * PlayQualityInfo video_frames_dropped.
         * @member {number} video_frames_dropped
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_frames_dropped = 0;

        /**
         * PlayQualityInfo sample_time_window.
         * @member {number} sample_time_window
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.sample_time_window = 0;

        /**
         * Creates a new PlayQualityInfo instance using the specified properties.
         * @function create
         * @memberof logreport.PlayQualityInfo
         * @static
         * @param {logreport.IPlayQualityInfo=} [properties] Properties to set
         * @returns {logreport.PlayQualityInfo} PlayQualityInfo instance
         */
        PlayQualityInfo.create = function create(properties) {
            return new PlayQualityInfo(properties);
        };

        /**
         * Encodes the specified PlayQualityInfo message. Does not implicitly {@link logreport.PlayQualityInfo.verify|verify} messages.
         * @function encode
         * @memberof logreport.PlayQualityInfo
         * @static
         * @param {logreport.IPlayQualityInfo} message PlayQualityInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayQualityInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audio_bitrate != null && Object.hasOwnProperty.call(message, "audio_bitrate"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.audio_bitrate);
            if (message.video_bitrate != null && Object.hasOwnProperty.call(message, "video_bitrate"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.video_bitrate);
            if (message.video_network_fps != null && Object.hasOwnProperty.call(message, "video_network_fps"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.video_network_fps);
            if (message.audio_break_count != null && Object.hasOwnProperty.call(message, "audio_break_count"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.audio_break_count);
            if (message.video_break_count != null && Object.hasOwnProperty.call(message, "video_break_count"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.video_break_count);
            if (message.downlink_plr != null && Object.hasOwnProperty.call(message, "downlink_plr"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.downlink_plr);
            if (message.peer_to_peer_plr != null && Object.hasOwnProperty.call(message, "peer_to_peer_plr"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.peer_to_peer_plr);
            if (message.peer_to_peer_delay != null && Object.hasOwnProperty.call(message, "peer_to_peer_delay"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.peer_to_peer_delay);
            if (message.audio_network_fps != null && Object.hasOwnProperty.call(message, "audio_network_fps"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.audio_network_fps);
            if (message.audio_break_duration != null && Object.hasOwnProperty.call(message, "audio_break_duration"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.audio_break_duration);
            if (message.video_break_duration != null && Object.hasOwnProperty.call(message, "video_break_duration"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.video_break_duration);
            if (message.audio_break_rate != null && Object.hasOwnProperty.call(message, "audio_break_rate"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.audio_break_rate);
            if (message.video_break_rate != null && Object.hasOwnProperty.call(message, "video_break_rate"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.video_break_rate);
            if (message.audio_break_cancel != null && Object.hasOwnProperty.call(message, "audio_break_cancel"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.audio_break_cancel);
            if (message.video_break_cancel != null && Object.hasOwnProperty.call(message, "video_break_cancel"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.video_break_cancel);
            if (message.rtt != null && Object.hasOwnProperty.call(message, "rtt"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.rtt);
            if (message.rendered_sound_level != null && Object.hasOwnProperty.call(message, "rendered_sound_level"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint32(message.rendered_sound_level);
            if (message.audio_break_cancel_duration != null && Object.hasOwnProperty.call(message, "audio_break_cancel_duration"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.audio_break_cancel_duration);
            if (message.video_break_cancel_duration != null && Object.hasOwnProperty.call(message, "video_break_cancel_duration"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.video_break_cancel_duration);
            if (message.audio_decode_time != null && Object.hasOwnProperty.call(message, "audio_decode_time"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.audio_decode_time);
            if (message.video_decode_time != null && Object.hasOwnProperty.call(message, "video_decode_time"))
                writer.uint32(/* id 21, wireType 0 =*/168).uint32(message.video_decode_time);
            if (message.real_sampling_interval != null && Object.hasOwnProperty.call(message, "real_sampling_interval"))
                writer.uint32(/* id 22, wireType 0 =*/176).uint32(message.real_sampling_interval);
            if (message.mos != null && Object.hasOwnProperty.call(message, "mos"))
                writer.uint32(/* id 23, wireType 0 =*/184).int32(message.mos);
            if (message.audio_decode_fps != null && Object.hasOwnProperty.call(message, "audio_decode_fps"))
                writer.uint32(/* id 24, wireType 0 =*/192).uint32(message.audio_decode_fps);
            if (message.video_decode_fps != null && Object.hasOwnProperty.call(message, "video_decode_fps"))
                writer.uint32(/* id 25, wireType 0 =*/200).uint32(message.video_decode_fps);
            if (message.video_frames_decoded != null && Object.hasOwnProperty.call(message, "video_frames_decoded"))
                writer.uint32(/* id 26, wireType 0 =*/208).uint32(message.video_frames_decoded);
            if (message.video_frames_dropped != null && Object.hasOwnProperty.call(message, "video_frames_dropped"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint32(message.video_frames_dropped);
            if (message.sample_time_window != null && Object.hasOwnProperty.call(message, "sample_time_window"))
                writer.uint32(/* id 100, wireType 0 =*/800).uint32(message.sample_time_window);
            return writer;
        };

        /**
         * Encodes the specified PlayQualityInfo message, length delimited. Does not implicitly {@link logreport.PlayQualityInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.PlayQualityInfo
         * @static
         * @param {logreport.IPlayQualityInfo} message PlayQualityInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayQualityInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlayQualityInfo message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.PlayQualityInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.PlayQualityInfo} PlayQualityInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayQualityInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.PlayQualityInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.audio_bitrate = reader.uint32();
                    break;
                case 2:
                    message.video_bitrate = reader.uint32();
                    break;
                case 3:
                    message.video_network_fps = reader.uint32();
                    break;
                case 4:
                    message.audio_break_count = reader.uint32();
                    break;
                case 5:
                    message.video_break_count = reader.uint32();
                    break;
                case 6:
                    message.downlink_plr = reader.uint32();
                    break;
                case 7:
                    message.peer_to_peer_plr = reader.uint32();
                    break;
                case 8:
                    message.peer_to_peer_delay = reader.uint32();
                    break;
                case 9:
                    message.audio_network_fps = reader.uint32();
                    break;
                case 10:
                    message.audio_break_duration = reader.uint32();
                    break;
                case 11:
                    message.video_break_duration = reader.uint32();
                    break;
                case 12:
                    message.audio_break_rate = reader.uint32();
                    break;
                case 13:
                    message.video_break_rate = reader.uint32();
                    break;
                case 14:
                    message.audio_break_cancel = reader.uint32();
                    break;
                case 15:
                    message.video_break_cancel = reader.uint32();
                    break;
                case 16:
                    message.rtt = reader.uint32();
                    break;
                case 17:
                    message.rendered_sound_level = reader.uint32();
                    break;
                case 18:
                    message.audio_break_cancel_duration = reader.uint32();
                    break;
                case 19:
                    message.video_break_cancel_duration = reader.uint32();
                    break;
                case 20:
                    message.audio_decode_time = reader.uint32();
                    break;
                case 21:
                    message.video_decode_time = reader.uint32();
                    break;
                case 22:
                    message.real_sampling_interval = reader.uint32();
                    break;
                case 23:
                    message.mos = reader.int32();
                    break;
                case 24:
                    message.audio_decode_fps = reader.uint32();
                    break;
                case 25:
                    message.video_decode_fps = reader.uint32();
                    break;
                case 26:
                    message.video_frames_decoded = reader.uint32();
                    break;
                case 27:
                    message.video_frames_dropped = reader.uint32();
                    break;
                case 100:
                    message.sample_time_window = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlayQualityInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.PlayQualityInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.PlayQualityInfo} PlayQualityInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayQualityInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlayQualityInfo message.
         * @function verify
         * @memberof logreport.PlayQualityInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayQualityInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.audio_bitrate != null && message.hasOwnProperty("audio_bitrate"))
                if (!$util.isInteger(message.audio_bitrate))
                    return "audio_bitrate: integer expected";
            if (message.video_bitrate != null && message.hasOwnProperty("video_bitrate"))
                if (!$util.isInteger(message.video_bitrate))
                    return "video_bitrate: integer expected";
            if (message.video_network_fps != null && message.hasOwnProperty("video_network_fps"))
                if (!$util.isInteger(message.video_network_fps))
                    return "video_network_fps: integer expected";
            if (message.audio_break_count != null && message.hasOwnProperty("audio_break_count"))
                if (!$util.isInteger(message.audio_break_count))
                    return "audio_break_count: integer expected";
            if (message.video_break_count != null && message.hasOwnProperty("video_break_count"))
                if (!$util.isInteger(message.video_break_count))
                    return "video_break_count: integer expected";
            if (message.downlink_plr != null && message.hasOwnProperty("downlink_plr"))
                if (!$util.isInteger(message.downlink_plr))
                    return "downlink_plr: integer expected";
            if (message.peer_to_peer_plr != null && message.hasOwnProperty("peer_to_peer_plr"))
                if (!$util.isInteger(message.peer_to_peer_plr))
                    return "peer_to_peer_plr: integer expected";
            if (message.peer_to_peer_delay != null && message.hasOwnProperty("peer_to_peer_delay"))
                if (!$util.isInteger(message.peer_to_peer_delay))
                    return "peer_to_peer_delay: integer expected";
            if (message.audio_network_fps != null && message.hasOwnProperty("audio_network_fps"))
                if (!$util.isInteger(message.audio_network_fps))
                    return "audio_network_fps: integer expected";
            if (message.audio_break_duration != null && message.hasOwnProperty("audio_break_duration"))
                if (!$util.isInteger(message.audio_break_duration))
                    return "audio_break_duration: integer expected";
            if (message.video_break_duration != null && message.hasOwnProperty("video_break_duration"))
                if (!$util.isInteger(message.video_break_duration))
                    return "video_break_duration: integer expected";
            if (message.audio_break_rate != null && message.hasOwnProperty("audio_break_rate"))
                if (!$util.isInteger(message.audio_break_rate))
                    return "audio_break_rate: integer expected";
            if (message.video_break_rate != null && message.hasOwnProperty("video_break_rate"))
                if (!$util.isInteger(message.video_break_rate))
                    return "video_break_rate: integer expected";
            if (message.audio_break_cancel != null && message.hasOwnProperty("audio_break_cancel"))
                if (!$util.isInteger(message.audio_break_cancel))
                    return "audio_break_cancel: integer expected";
            if (message.video_break_cancel != null && message.hasOwnProperty("video_break_cancel"))
                if (!$util.isInteger(message.video_break_cancel))
                    return "video_break_cancel: integer expected";
            if (message.rtt != null && message.hasOwnProperty("rtt"))
                if (!$util.isInteger(message.rtt))
                    return "rtt: integer expected";
            if (message.rendered_sound_level != null && message.hasOwnProperty("rendered_sound_level"))
                if (!$util.isInteger(message.rendered_sound_level))
                    return "rendered_sound_level: integer expected";
            if (message.audio_break_cancel_duration != null && message.hasOwnProperty("audio_break_cancel_duration"))
                if (!$util.isInteger(message.audio_break_cancel_duration))
                    return "audio_break_cancel_duration: integer expected";
            if (message.video_break_cancel_duration != null && message.hasOwnProperty("video_break_cancel_duration"))
                if (!$util.isInteger(message.video_break_cancel_duration))
                    return "video_break_cancel_duration: integer expected";
            if (message.audio_decode_time != null && message.hasOwnProperty("audio_decode_time"))
                if (!$util.isInteger(message.audio_decode_time))
                    return "audio_decode_time: integer expected";
            if (message.video_decode_time != null && message.hasOwnProperty("video_decode_time"))
                if (!$util.isInteger(message.video_decode_time))
                    return "video_decode_time: integer expected";
            if (message.real_sampling_interval != null && message.hasOwnProperty("real_sampling_interval"))
                if (!$util.isInteger(message.real_sampling_interval))
                    return "real_sampling_interval: integer expected";
            if (message.mos != null && message.hasOwnProperty("mos"))
                if (!$util.isInteger(message.mos))
                    return "mos: integer expected";
            if (message.audio_decode_fps != null && message.hasOwnProperty("audio_decode_fps"))
                if (!$util.isInteger(message.audio_decode_fps))
                    return "audio_decode_fps: integer expected";
            if (message.video_decode_fps != null && message.hasOwnProperty("video_decode_fps"))
                if (!$util.isInteger(message.video_decode_fps))
                    return "video_decode_fps: integer expected";
            if (message.video_frames_decoded != null && message.hasOwnProperty("video_frames_decoded"))
                if (!$util.isInteger(message.video_frames_decoded))
                    return "video_frames_decoded: integer expected";
            if (message.video_frames_dropped != null && message.hasOwnProperty("video_frames_dropped"))
                if (!$util.isInteger(message.video_frames_dropped))
                    return "video_frames_dropped: integer expected";
            if (message.sample_time_window != null && message.hasOwnProperty("sample_time_window"))
                if (!$util.isInteger(message.sample_time_window))
                    return "sample_time_window: integer expected";
            return null;
        };

        /**
         * Creates a PlayQualityInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.PlayQualityInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.PlayQualityInfo} PlayQualityInfo
         */
        PlayQualityInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.PlayQualityInfo)
                return object;
            var message = new $root.logreport.PlayQualityInfo();
            if (object.audio_bitrate != null)
                message.audio_bitrate = object.audio_bitrate >>> 0;
            if (object.video_bitrate != null)
                message.video_bitrate = object.video_bitrate >>> 0;
            if (object.video_network_fps != null)
                message.video_network_fps = object.video_network_fps >>> 0;
            if (object.audio_break_count != null)
                message.audio_break_count = object.audio_break_count >>> 0;
            if (object.video_break_count != null)
                message.video_break_count = object.video_break_count >>> 0;
            if (object.downlink_plr != null)
                message.downlink_plr = object.downlink_plr >>> 0;
            if (object.peer_to_peer_plr != null)
                message.peer_to_peer_plr = object.peer_to_peer_plr >>> 0;
            if (object.peer_to_peer_delay != null)
                message.peer_to_peer_delay = object.peer_to_peer_delay >>> 0;
            if (object.audio_network_fps != null)
                message.audio_network_fps = object.audio_network_fps >>> 0;
            if (object.audio_break_duration != null)
                message.audio_break_duration = object.audio_break_duration >>> 0;
            if (object.video_break_duration != null)
                message.video_break_duration = object.video_break_duration >>> 0;
            if (object.audio_break_rate != null)
                message.audio_break_rate = object.audio_break_rate >>> 0;
            if (object.video_break_rate != null)
                message.video_break_rate = object.video_break_rate >>> 0;
            if (object.audio_break_cancel != null)
                message.audio_break_cancel = object.audio_break_cancel >>> 0;
            if (object.video_break_cancel != null)
                message.video_break_cancel = object.video_break_cancel >>> 0;
            if (object.rtt != null)
                message.rtt = object.rtt >>> 0;
            if (object.rendered_sound_level != null)
                message.rendered_sound_level = object.rendered_sound_level >>> 0;
            if (object.audio_break_cancel_duration != null)
                message.audio_break_cancel_duration = object.audio_break_cancel_duration >>> 0;
            if (object.video_break_cancel_duration != null)
                message.video_break_cancel_duration = object.video_break_cancel_duration >>> 0;
            if (object.audio_decode_time != null)
                message.audio_decode_time = object.audio_decode_time >>> 0;
            if (object.video_decode_time != null)
                message.video_decode_time = object.video_decode_time >>> 0;
            if (object.real_sampling_interval != null)
                message.real_sampling_interval = object.real_sampling_interval >>> 0;
            if (object.mos != null)
                message.mos = object.mos | 0;
            if (object.audio_decode_fps != null)
                message.audio_decode_fps = object.audio_decode_fps >>> 0;
            if (object.video_decode_fps != null)
                message.video_decode_fps = object.video_decode_fps >>> 0;
            if (object.video_frames_decoded != null)
                message.video_frames_decoded = object.video_frames_decoded >>> 0;
            if (object.video_frames_dropped != null)
                message.video_frames_dropped = object.video_frames_dropped >>> 0;
            if (object.sample_time_window != null)
                message.sample_time_window = object.sample_time_window >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PlayQualityInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.PlayQualityInfo
         * @static
         * @param {logreport.PlayQualityInfo} message PlayQualityInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayQualityInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.audio_bitrate = 0;
                object.video_bitrate = 0;
                object.video_network_fps = 0;
                object.audio_break_count = 0;
                object.video_break_count = 0;
                object.downlink_plr = 0;
                object.peer_to_peer_plr = 0;
                object.peer_to_peer_delay = 0;
                object.audio_network_fps = 0;
                object.audio_break_duration = 0;
                object.video_break_duration = 0;
                object.audio_break_rate = 0;
                object.video_break_rate = 0;
                object.audio_break_cancel = 0;
                object.video_break_cancel = 0;
                object.rtt = 0;
                object.rendered_sound_level = 0;
                object.audio_break_cancel_duration = 0;
                object.video_break_cancel_duration = 0;
                object.audio_decode_time = 0;
                object.video_decode_time = 0;
                object.real_sampling_interval = 0;
                object.mos = 0;
                object.audio_decode_fps = 0;
                object.video_decode_fps = 0;
                object.video_frames_decoded = 0;
                object.video_frames_dropped = 0;
                object.sample_time_window = 0;
            }
            if (message.audio_bitrate != null && message.hasOwnProperty("audio_bitrate"))
                object.audio_bitrate = message.audio_bitrate;
            if (message.video_bitrate != null && message.hasOwnProperty("video_bitrate"))
                object.video_bitrate = message.video_bitrate;
            if (message.video_network_fps != null && message.hasOwnProperty("video_network_fps"))
                object.video_network_fps = message.video_network_fps;
            if (message.audio_break_count != null && message.hasOwnProperty("audio_break_count"))
                object.audio_break_count = message.audio_break_count;
            if (message.video_break_count != null && message.hasOwnProperty("video_break_count"))
                object.video_break_count = message.video_break_count;
            if (message.downlink_plr != null && message.hasOwnProperty("downlink_plr"))
                object.downlink_plr = message.downlink_plr;
            if (message.peer_to_peer_plr != null && message.hasOwnProperty("peer_to_peer_plr"))
                object.peer_to_peer_plr = message.peer_to_peer_plr;
            if (message.peer_to_peer_delay != null && message.hasOwnProperty("peer_to_peer_delay"))
                object.peer_to_peer_delay = message.peer_to_peer_delay;
            if (message.audio_network_fps != null && message.hasOwnProperty("audio_network_fps"))
                object.audio_network_fps = message.audio_network_fps;
            if (message.audio_break_duration != null && message.hasOwnProperty("audio_break_duration"))
                object.audio_break_duration = message.audio_break_duration;
            if (message.video_break_duration != null && message.hasOwnProperty("video_break_duration"))
                object.video_break_duration = message.video_break_duration;
            if (message.audio_break_rate != null && message.hasOwnProperty("audio_break_rate"))
                object.audio_break_rate = message.audio_break_rate;
            if (message.video_break_rate != null && message.hasOwnProperty("video_break_rate"))
                object.video_break_rate = message.video_break_rate;
            if (message.audio_break_cancel != null && message.hasOwnProperty("audio_break_cancel"))
                object.audio_break_cancel = message.audio_break_cancel;
            if (message.video_break_cancel != null && message.hasOwnProperty("video_break_cancel"))
                object.video_break_cancel = message.video_break_cancel;
            if (message.rtt != null && message.hasOwnProperty("rtt"))
                object.rtt = message.rtt;
            if (message.rendered_sound_level != null && message.hasOwnProperty("rendered_sound_level"))
                object.rendered_sound_level = message.rendered_sound_level;
            if (message.audio_break_cancel_duration != null && message.hasOwnProperty("audio_break_cancel_duration"))
                object.audio_break_cancel_duration = message.audio_break_cancel_duration;
            if (message.video_break_cancel_duration != null && message.hasOwnProperty("video_break_cancel_duration"))
                object.video_break_cancel_duration = message.video_break_cancel_duration;
            if (message.audio_decode_time != null && message.hasOwnProperty("audio_decode_time"))
                object.audio_decode_time = message.audio_decode_time;
            if (message.video_decode_time != null && message.hasOwnProperty("video_decode_time"))
                object.video_decode_time = message.video_decode_time;
            if (message.real_sampling_interval != null && message.hasOwnProperty("real_sampling_interval"))
                object.real_sampling_interval = message.real_sampling_interval;
            if (message.mos != null && message.hasOwnProperty("mos"))
                object.mos = message.mos;
            if (message.audio_decode_fps != null && message.hasOwnProperty("audio_decode_fps"))
                object.audio_decode_fps = message.audio_decode_fps;
            if (message.video_decode_fps != null && message.hasOwnProperty("video_decode_fps"))
                object.video_decode_fps = message.video_decode_fps;
            if (message.video_frames_decoded != null && message.hasOwnProperty("video_frames_decoded"))
                object.video_frames_decoded = message.video_frames_decoded;
            if (message.video_frames_dropped != null && message.hasOwnProperty("video_frames_dropped"))
                object.video_frames_dropped = message.video_frames_dropped;
            if (message.sample_time_window != null && message.hasOwnProperty("sample_time_window"))
                object.sample_time_window = message.sample_time_window;
            return object;
        };

        /**
         * Converts this PlayQualityInfo to JSON.
         * @function toJSON
         * @memberof logreport.PlayQualityInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayQualityInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlayQualityInfo;
    })();

    logreport.ChargeInfo = (function() {

        /**
         * Properties of a ChargeInfo.
         * @memberof logreport
         * @interface IChargeInfo
         * @property {number|null} [is_publishing] ChargeInfo is_publishing
         * @property {Array.<logreport.IResolutionInfo>|null} [play_stream_resolution_infos] ChargeInfo play_stream_resolution_infos
         * @property {number|null} [play_max_audio_bitrate] ChargeInfo play_max_audio_bitrate
         */

        /**
         * Constructs a new ChargeInfo.
         * @memberof logreport
         * @classdesc Represents a ChargeInfo.
         * @implements IChargeInfo
         * @constructor
         * @param {logreport.IChargeInfo=} [properties] Properties to set
         */
        function ChargeInfo(properties) {
            this.play_stream_resolution_infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChargeInfo is_publishing.
         * @member {number} is_publishing
         * @memberof logreport.ChargeInfo
         * @instance
         */
        ChargeInfo.prototype.is_publishing = 0;

        /**
         * ChargeInfo play_stream_resolution_infos.
         * @member {Array.<logreport.IResolutionInfo>} play_stream_resolution_infos
         * @memberof logreport.ChargeInfo
         * @instance
         */
        ChargeInfo.prototype.play_stream_resolution_infos = $util.emptyArray;

        /**
         * ChargeInfo play_max_audio_bitrate.
         * @member {number} play_max_audio_bitrate
         * @memberof logreport.ChargeInfo
         * @instance
         */
        ChargeInfo.prototype.play_max_audio_bitrate = 0;

        /**
         * Creates a new ChargeInfo instance using the specified properties.
         * @function create
         * @memberof logreport.ChargeInfo
         * @static
         * @param {logreport.IChargeInfo=} [properties] Properties to set
         * @returns {logreport.ChargeInfo} ChargeInfo instance
         */
        ChargeInfo.create = function create(properties) {
            return new ChargeInfo(properties);
        };

        /**
         * Encodes the specified ChargeInfo message. Does not implicitly {@link logreport.ChargeInfo.verify|verify} messages.
         * @function encode
         * @memberof logreport.ChargeInfo
         * @static
         * @param {logreport.IChargeInfo} message ChargeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChargeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.is_publishing != null && Object.hasOwnProperty.call(message, "is_publishing"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.is_publishing);
            if (message.play_stream_resolution_infos != null && message.play_stream_resolution_infos.length)
                for (var i = 0; i < message.play_stream_resolution_infos.length; ++i)
                    $root.logreport.ResolutionInfo.encode(message.play_stream_resolution_infos[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.play_max_audio_bitrate != null && Object.hasOwnProperty.call(message, "play_max_audio_bitrate"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.play_max_audio_bitrate);
            return writer;
        };

        /**
         * Encodes the specified ChargeInfo message, length delimited. Does not implicitly {@link logreport.ChargeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.ChargeInfo
         * @static
         * @param {logreport.IChargeInfo} message ChargeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChargeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChargeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.ChargeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.ChargeInfo} ChargeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChargeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.ChargeInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.is_publishing = reader.uint32();
                    break;
                case 2:
                    if (!(message.play_stream_resolution_infos && message.play_stream_resolution_infos.length))
                        message.play_stream_resolution_infos = [];
                    message.play_stream_resolution_infos.push($root.logreport.ResolutionInfo.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.play_max_audio_bitrate = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChargeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.ChargeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.ChargeInfo} ChargeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChargeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChargeInfo message.
         * @function verify
         * @memberof logreport.ChargeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChargeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.is_publishing != null && message.hasOwnProperty("is_publishing"))
                if (!$util.isInteger(message.is_publishing))
                    return "is_publishing: integer expected";
            if (message.play_stream_resolution_infos != null && message.hasOwnProperty("play_stream_resolution_infos")) {
                if (!Array.isArray(message.play_stream_resolution_infos))
                    return "play_stream_resolution_infos: array expected";
                for (var i = 0; i < message.play_stream_resolution_infos.length; ++i) {
                    var error = $root.logreport.ResolutionInfo.verify(message.play_stream_resolution_infos[i]);
                    if (error)
                        return "play_stream_resolution_infos." + error;
                }
            }
            if (message.play_max_audio_bitrate != null && message.hasOwnProperty("play_max_audio_bitrate"))
                if (!$util.isInteger(message.play_max_audio_bitrate))
                    return "play_max_audio_bitrate: integer expected";
            return null;
        };

        /**
         * Creates a ChargeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.ChargeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.ChargeInfo} ChargeInfo
         */
        ChargeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.ChargeInfo)
                return object;
            var message = new $root.logreport.ChargeInfo();
            if (object.is_publishing != null)
                message.is_publishing = object.is_publishing >>> 0;
            if (object.play_stream_resolution_infos) {
                if (!Array.isArray(object.play_stream_resolution_infos))
                    throw TypeError(".logreport.ChargeInfo.play_stream_resolution_infos: array expected");
                message.play_stream_resolution_infos = [];
                for (var i = 0; i < object.play_stream_resolution_infos.length; ++i) {
                    if (typeof object.play_stream_resolution_infos[i] !== "object")
                        throw TypeError(".logreport.ChargeInfo.play_stream_resolution_infos: object expected");
                    message.play_stream_resolution_infos[i] = $root.logreport.ResolutionInfo.fromObject(object.play_stream_resolution_infos[i]);
                }
            }
            if (object.play_max_audio_bitrate != null)
                message.play_max_audio_bitrate = object.play_max_audio_bitrate >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ChargeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.ChargeInfo
         * @static
         * @param {logreport.ChargeInfo} message ChargeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChargeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.play_stream_resolution_infos = [];
            if (options.defaults) {
                object.is_publishing = 0;
                object.play_max_audio_bitrate = 0;
            }
            if (message.is_publishing != null && message.hasOwnProperty("is_publishing"))
                object.is_publishing = message.is_publishing;
            if (message.play_stream_resolution_infos && message.play_stream_resolution_infos.length) {
                object.play_stream_resolution_infos = [];
                for (var j = 0; j < message.play_stream_resolution_infos.length; ++j)
                    object.play_stream_resolution_infos[j] = $root.logreport.ResolutionInfo.toObject(message.play_stream_resolution_infos[j], options);
            }
            if (message.play_max_audio_bitrate != null && message.hasOwnProperty("play_max_audio_bitrate"))
                object.play_max_audio_bitrate = message.play_max_audio_bitrate;
            return object;
        };

        /**
         * Converts this ChargeInfo to JSON.
         * @function toJSON
         * @memberof logreport.ChargeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChargeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChargeInfo;
    })();

    logreport.ResolutionInfo = (function() {

        /**
         * Properties of a ResolutionInfo.
         * @memberof logreport
         * @interface IResolutionInfo
         * @property {number|null} [video_width] ResolutionInfo video_width
         * @property {number|null} [video_height] ResolutionInfo video_height
         * @property {number|null} [count] ResolutionInfo count
         */

        /**
         * Constructs a new ResolutionInfo.
         * @memberof logreport
         * @classdesc Represents a ResolutionInfo.
         * @implements IResolutionInfo
         * @constructor
         * @param {logreport.IResolutionInfo=} [properties] Properties to set
         */
        function ResolutionInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResolutionInfo video_width.
         * @member {number} video_width
         * @memberof logreport.ResolutionInfo
         * @instance
         */
        ResolutionInfo.prototype.video_width = 0;

        /**
         * ResolutionInfo video_height.
         * @member {number} video_height
         * @memberof logreport.ResolutionInfo
         * @instance
         */
        ResolutionInfo.prototype.video_height = 0;

        /**
         * ResolutionInfo count.
         * @member {number} count
         * @memberof logreport.ResolutionInfo
         * @instance
         */
        ResolutionInfo.prototype.count = 0;

        /**
         * Creates a new ResolutionInfo instance using the specified properties.
         * @function create
         * @memberof logreport.ResolutionInfo
         * @static
         * @param {logreport.IResolutionInfo=} [properties] Properties to set
         * @returns {logreport.ResolutionInfo} ResolutionInfo instance
         */
        ResolutionInfo.create = function create(properties) {
            return new ResolutionInfo(properties);
        };

        /**
         * Encodes the specified ResolutionInfo message. Does not implicitly {@link logreport.ResolutionInfo.verify|verify} messages.
         * @function encode
         * @memberof logreport.ResolutionInfo
         * @static
         * @param {logreport.IResolutionInfo} message ResolutionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResolutionInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.video_width != null && Object.hasOwnProperty.call(message, "video_width"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.video_width);
            if (message.video_height != null && Object.hasOwnProperty.call(message, "video_height"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.video_height);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.count);
            return writer;
        };

        /**
         * Encodes the specified ResolutionInfo message, length delimited. Does not implicitly {@link logreport.ResolutionInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.ResolutionInfo
         * @static
         * @param {logreport.IResolutionInfo} message ResolutionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResolutionInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResolutionInfo message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.ResolutionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.ResolutionInfo} ResolutionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResolutionInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.ResolutionInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.video_width = reader.uint32();
                    break;
                case 2:
                    message.video_height = reader.uint32();
                    break;
                case 3:
                    message.count = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResolutionInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.ResolutionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.ResolutionInfo} ResolutionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResolutionInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResolutionInfo message.
         * @function verify
         * @memberof logreport.ResolutionInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResolutionInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.video_width != null && message.hasOwnProperty("video_width"))
                if (!$util.isInteger(message.video_width))
                    return "video_width: integer expected";
            if (message.video_height != null && message.hasOwnProperty("video_height"))
                if (!$util.isInteger(message.video_height))
                    return "video_height: integer expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        /**
         * Creates a ResolutionInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.ResolutionInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.ResolutionInfo} ResolutionInfo
         */
        ResolutionInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.ResolutionInfo)
                return object;
            var message = new $root.logreport.ResolutionInfo();
            if (object.video_width != null)
                message.video_width = object.video_width >>> 0;
            if (object.video_height != null)
                message.video_height = object.video_height >>> 0;
            if (object.count != null)
                message.count = object.count >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ResolutionInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.ResolutionInfo
         * @static
         * @param {logreport.ResolutionInfo} message ResolutionInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResolutionInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.video_width = 0;
                object.video_height = 0;
                object.count = 0;
            }
            if (message.video_width != null && message.hasOwnProperty("video_width"))
                object.video_width = message.video_width;
            if (message.video_height != null && message.hasOwnProperty("video_height"))
                object.video_height = message.video_height;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };

        /**
         * Converts this ResolutionInfo to JSON.
         * @function toJSON
         * @memberof logreport.ResolutionInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResolutionInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResolutionInfo;
    })();

    logreport.NoBillingEvent = (function() {

        /**
         * Properties of a NoBillingEvent.
         * @memberof logreport
         * @interface INoBillingEvent
         * @property {string|null} [platform_info] NoBillingEvent platform_info
         * @property {string|null} [room_id] NoBillingEvent room_id
         */

        /**
         * Constructs a new NoBillingEvent.
         * @memberof logreport
         * @classdesc Represents a NoBillingEvent.
         * @implements INoBillingEvent
         * @constructor
         * @param {logreport.INoBillingEvent=} [properties] Properties to set
         */
        function NoBillingEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NoBillingEvent platform_info.
         * @member {string} platform_info
         * @memberof logreport.NoBillingEvent
         * @instance
         */
        NoBillingEvent.prototype.platform_info = "";

        /**
         * NoBillingEvent room_id.
         * @member {string} room_id
         * @memberof logreport.NoBillingEvent
         * @instance
         */
        NoBillingEvent.prototype.room_id = "";

        /**
         * Creates a new NoBillingEvent instance using the specified properties.
         * @function create
         * @memberof logreport.NoBillingEvent
         * @static
         * @param {logreport.INoBillingEvent=} [properties] Properties to set
         * @returns {logreport.NoBillingEvent} NoBillingEvent instance
         */
        NoBillingEvent.create = function create(properties) {
            return new NoBillingEvent(properties);
        };

        /**
         * Encodes the specified NoBillingEvent message. Does not implicitly {@link logreport.NoBillingEvent.verify|verify} messages.
         * @function encode
         * @memberof logreport.NoBillingEvent
         * @static
         * @param {logreport.INoBillingEvent} message NoBillingEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoBillingEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.platform_info != null && Object.hasOwnProperty.call(message, "platform_info"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.platform_info);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.room_id);
            return writer;
        };

        /**
         * Encodes the specified NoBillingEvent message, length delimited. Does not implicitly {@link logreport.NoBillingEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.NoBillingEvent
         * @static
         * @param {logreport.INoBillingEvent} message NoBillingEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoBillingEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NoBillingEvent message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.NoBillingEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.NoBillingEvent} NoBillingEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoBillingEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.NoBillingEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.platform_info = reader.string();
                    break;
                case 2:
                    message.room_id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NoBillingEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.NoBillingEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.NoBillingEvent} NoBillingEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoBillingEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NoBillingEvent message.
         * @function verify
         * @memberof logreport.NoBillingEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NoBillingEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.platform_info != null && message.hasOwnProperty("platform_info"))
                if (!$util.isString(message.platform_info))
                    return "platform_info: string expected";
            if (message.room_id != null && message.hasOwnProperty("room_id"))
                if (!$util.isString(message.room_id))
                    return "room_id: string expected";
            return null;
        };

        /**
         * Creates a NoBillingEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.NoBillingEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.NoBillingEvent} NoBillingEvent
         */
        NoBillingEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.NoBillingEvent)
                return object;
            var message = new $root.logreport.NoBillingEvent();
            if (object.platform_info != null)
                message.platform_info = String(object.platform_info);
            if (object.room_id != null)
                message.room_id = String(object.room_id);
            return message;
        };

        /**
         * Creates a plain object from a NoBillingEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.NoBillingEvent
         * @static
         * @param {logreport.NoBillingEvent} message NoBillingEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NoBillingEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.platform_info = "";
                object.room_id = "";
            }
            if (message.platform_info != null && message.hasOwnProperty("platform_info"))
                object.platform_info = message.platform_info;
            if (message.room_id != null && message.hasOwnProperty("room_id"))
                object.room_id = message.room_id;
            return object;
        };

        /**
         * Converts this NoBillingEvent to JSON.
         * @function toJSON
         * @memberof logreport.NoBillingEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NoBillingEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NoBillingEvent;
    })();

    logreport.DynQualityEvent = (function() {

        /**
         * Properties of a DynQualityEvent.
         * @memberof logreport
         * @interface IDynQualityEvent
         * @property {string|null} [seq_no] DynQualityEvent seq_no
         * @property {number|null} [num] DynQualityEvent num
         * @property {Array.<logreport.IDynQualityInfos>|null} [dyn_quality_infos] DynQualityEvent dyn_quality_infos
         * @property {string|null} [device_id] DynQualityEvent device_id
         * @property {number|null} [latitude] DynQualityEvent latitude
         * @property {number|null} [longitude] DynQualityEvent longitude
         * @property {string|null} [country] DynQualityEvent country
         * @property {string|null} [region] DynQualityEvent region
         * @property {string|null} [city] DynQualityEvent city
         * @property {string|null} [isp] DynQualityEvent isp
         * @property {number|null} [ve_mode] DynQualityEvent ve_mode
         */

        /**
         * Constructs a new DynQualityEvent.
         * @memberof logreport
         * @classdesc Represents a DynQualityEvent.
         * @implements IDynQualityEvent
         * @constructor
         * @param {logreport.IDynQualityEvent=} [properties] Properties to set
         */
        function DynQualityEvent(properties) {
            this.dyn_quality_infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DynQualityEvent seq_no.
         * @member {string} seq_no
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.seq_no = "";

        /**
         * DynQualityEvent num.
         * @member {number} num
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.num = 0;

        /**
         * DynQualityEvent dyn_quality_infos.
         * @member {Array.<logreport.IDynQualityInfos>} dyn_quality_infos
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.dyn_quality_infos = $util.emptyArray;

        /**
         * DynQualityEvent device_id.
         * @member {string} device_id
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.device_id = "";

        /**
         * DynQualityEvent latitude.
         * @member {number} latitude
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.latitude = 0;

        /**
         * DynQualityEvent longitude.
         * @member {number} longitude
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.longitude = 0;

        /**
         * DynQualityEvent country.
         * @member {string} country
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.country = "";

        /**
         * DynQualityEvent region.
         * @member {string} region
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.region = "";

        /**
         * DynQualityEvent city.
         * @member {string} city
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.city = "";

        /**
         * DynQualityEvent isp.
         * @member {string} isp
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.isp = "";

        /**
         * DynQualityEvent ve_mode.
         * @member {number} ve_mode
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.ve_mode = 0;

        /**
         * Creates a new DynQualityEvent instance using the specified properties.
         * @function create
         * @memberof logreport.DynQualityEvent
         * @static
         * @param {logreport.IDynQualityEvent=} [properties] Properties to set
         * @returns {logreport.DynQualityEvent} DynQualityEvent instance
         */
        DynQualityEvent.create = function create(properties) {
            return new DynQualityEvent(properties);
        };

        /**
         * Encodes the specified DynQualityEvent message. Does not implicitly {@link logreport.DynQualityEvent.verify|verify} messages.
         * @function encode
         * @memberof logreport.DynQualityEvent
         * @static
         * @param {logreport.IDynQualityEvent} message DynQualityEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DynQualityEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seq_no != null && Object.hasOwnProperty.call(message, "seq_no"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.seq_no);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.num);
            if (message.dyn_quality_infos != null && message.dyn_quality_infos.length)
                for (var i = 0; i < message.dyn_quality_infos.length; ++i)
                    $root.logreport.DynQualityInfos.encode(message.dyn_quality_infos[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.device_id != null && Object.hasOwnProperty.call(message, "device_id"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.device_id);
            if (message.latitude != null && Object.hasOwnProperty.call(message, "latitude"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.latitude);
            if (message.longitude != null && Object.hasOwnProperty.call(message, "longitude"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.longitude);
            if (message.country != null && Object.hasOwnProperty.call(message, "country"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.country);
            if (message.region != null && Object.hasOwnProperty.call(message, "region"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.region);
            if (message.city != null && Object.hasOwnProperty.call(message, "city"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.city);
            if (message.isp != null && Object.hasOwnProperty.call(message, "isp"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.isp);
            if (message.ve_mode != null && Object.hasOwnProperty.call(message, "ve_mode"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.ve_mode);
            return writer;
        };

        /**
         * Encodes the specified DynQualityEvent message, length delimited. Does not implicitly {@link logreport.DynQualityEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.DynQualityEvent
         * @static
         * @param {logreport.IDynQualityEvent} message DynQualityEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DynQualityEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DynQualityEvent message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.DynQualityEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.DynQualityEvent} DynQualityEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DynQualityEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.DynQualityEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.seq_no = reader.string();
                    break;
                case 2:
                    message.num = reader.uint32();
                    break;
                case 3:
                    if (!(message.dyn_quality_infos && message.dyn_quality_infos.length))
                        message.dyn_quality_infos = [];
                    message.dyn_quality_infos.push($root.logreport.DynQualityInfos.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.device_id = reader.string();
                    break;
                case 5:
                    message.latitude = reader.uint32();
                    break;
                case 6:
                    message.longitude = reader.uint32();
                    break;
                case 7:
                    message.country = reader.string();
                    break;
                case 8:
                    message.region = reader.string();
                    break;
                case 9:
                    message.city = reader.string();
                    break;
                case 10:
                    message.isp = reader.string();
                    break;
                case 11:
                    message.ve_mode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DynQualityEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.DynQualityEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.DynQualityEvent} DynQualityEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DynQualityEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DynQualityEvent message.
         * @function verify
         * @memberof logreport.DynQualityEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DynQualityEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seq_no != null && message.hasOwnProperty("seq_no"))
                if (!$util.isString(message.seq_no))
                    return "seq_no: string expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.dyn_quality_infos != null && message.hasOwnProperty("dyn_quality_infos")) {
                if (!Array.isArray(message.dyn_quality_infos))
                    return "dyn_quality_infos: array expected";
                for (var i = 0; i < message.dyn_quality_infos.length; ++i) {
                    var error = $root.logreport.DynQualityInfos.verify(message.dyn_quality_infos[i]);
                    if (error)
                        return "dyn_quality_infos." + error;
                }
            }
            if (message.device_id != null && message.hasOwnProperty("device_id"))
                if (!$util.isString(message.device_id))
                    return "device_id: string expected";
            if (message.latitude != null && message.hasOwnProperty("latitude"))
                if (!$util.isInteger(message.latitude))
                    return "latitude: integer expected";
            if (message.longitude != null && message.hasOwnProperty("longitude"))
                if (!$util.isInteger(message.longitude))
                    return "longitude: integer expected";
            if (message.country != null && message.hasOwnProperty("country"))
                if (!$util.isString(message.country))
                    return "country: string expected";
            if (message.region != null && message.hasOwnProperty("region"))
                if (!$util.isString(message.region))
                    return "region: string expected";
            if (message.city != null && message.hasOwnProperty("city"))
                if (!$util.isString(message.city))
                    return "city: string expected";
            if (message.isp != null && message.hasOwnProperty("isp"))
                if (!$util.isString(message.isp))
                    return "isp: string expected";
            if (message.ve_mode != null && message.hasOwnProperty("ve_mode"))
                if (!$util.isInteger(message.ve_mode))
                    return "ve_mode: integer expected";
            return null;
        };

        /**
         * Creates a DynQualityEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.DynQualityEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.DynQualityEvent} DynQualityEvent
         */
        DynQualityEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.DynQualityEvent)
                return object;
            var message = new $root.logreport.DynQualityEvent();
            if (object.seq_no != null)
                message.seq_no = String(object.seq_no);
            if (object.num != null)
                message.num = object.num >>> 0;
            if (object.dyn_quality_infos) {
                if (!Array.isArray(object.dyn_quality_infos))
                    throw TypeError(".logreport.DynQualityEvent.dyn_quality_infos: array expected");
                message.dyn_quality_infos = [];
                for (var i = 0; i < object.dyn_quality_infos.length; ++i) {
                    if (typeof object.dyn_quality_infos[i] !== "object")
                        throw TypeError(".logreport.DynQualityEvent.dyn_quality_infos: object expected");
                    message.dyn_quality_infos[i] = $root.logreport.DynQualityInfos.fromObject(object.dyn_quality_infos[i]);
                }
            }
            if (object.device_id != null)
                message.device_id = String(object.device_id);
            if (object.latitude != null)
                message.latitude = object.latitude >>> 0;
            if (object.longitude != null)
                message.longitude = object.longitude >>> 0;
            if (object.country != null)
                message.country = String(object.country);
            if (object.region != null)
                message.region = String(object.region);
            if (object.city != null)
                message.city = String(object.city);
            if (object.isp != null)
                message.isp = String(object.isp);
            if (object.ve_mode != null)
                message.ve_mode = object.ve_mode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a DynQualityEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.DynQualityEvent
         * @static
         * @param {logreport.DynQualityEvent} message DynQualityEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DynQualityEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.dyn_quality_infos = [];
            if (options.defaults) {
                object.seq_no = "";
                object.num = 0;
                object.device_id = "";
                object.latitude = 0;
                object.longitude = 0;
                object.country = "";
                object.region = "";
                object.city = "";
                object.isp = "";
                object.ve_mode = 0;
            }
            if (message.seq_no != null && message.hasOwnProperty("seq_no"))
                object.seq_no = message.seq_no;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.dyn_quality_infos && message.dyn_quality_infos.length) {
                object.dyn_quality_infos = [];
                for (var j = 0; j < message.dyn_quality_infos.length; ++j)
                    object.dyn_quality_infos[j] = $root.logreport.DynQualityInfos.toObject(message.dyn_quality_infos[j], options);
            }
            if (message.device_id != null && message.hasOwnProperty("device_id"))
                object.device_id = message.device_id;
            if (message.latitude != null && message.hasOwnProperty("latitude"))
                object.latitude = message.latitude;
            if (message.longitude != null && message.hasOwnProperty("longitude"))
                object.longitude = message.longitude;
            if (message.country != null && message.hasOwnProperty("country"))
                object.country = message.country;
            if (message.region != null && message.hasOwnProperty("region"))
                object.region = message.region;
            if (message.city != null && message.hasOwnProperty("city"))
                object.city = message.city;
            if (message.isp != null && message.hasOwnProperty("isp"))
                object.isp = message.isp;
            if (message.ve_mode != null && message.hasOwnProperty("ve_mode"))
                object.ve_mode = message.ve_mode;
            return object;
        };

        /**
         * Converts this DynQualityEvent to JSON.
         * @function toJSON
         * @memberof logreport.DynQualityEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DynQualityEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DynQualityEvent;
    })();

    logreport.DynQualityInfos = (function() {

        /**
         * Properties of a DynQualityInfos.
         * @memberof logreport
         * @interface IDynQualityInfos
         * @property {number|Long|null} [timestamp_offset_begin] DynQualityInfos timestamp_offset_begin
         * @property {number|Long|null} [timestamp_offset_end] DynQualityInfos timestamp_offset_end
         * @property {string|null} [server_ip] DynQualityInfos server_ip
         * @property {Array.<logreport.IDynQualityInfo>|null} [infos] DynQualityInfos infos
         * @property {number|null} [network_type] DynQualityInfos network_type
         * @property {string|null} [stream_id] DynQualityInfos stream_id
         */

        /**
         * Constructs a new DynQualityInfos.
         * @memberof logreport
         * @classdesc Represents a DynQualityInfos.
         * @implements IDynQualityInfos
         * @constructor
         * @param {logreport.IDynQualityInfos=} [properties] Properties to set
         */
        function DynQualityInfos(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DynQualityInfos timestamp_offset_begin.
         * @member {number|Long} timestamp_offset_begin
         * @memberof logreport.DynQualityInfos
         * @instance
         */
        DynQualityInfos.prototype.timestamp_offset_begin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DynQualityInfos timestamp_offset_end.
         * @member {number|Long} timestamp_offset_end
         * @memberof logreport.DynQualityInfos
         * @instance
         */
        DynQualityInfos.prototype.timestamp_offset_end = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DynQualityInfos server_ip.
         * @member {string} server_ip
         * @memberof logreport.DynQualityInfos
         * @instance
         */
        DynQualityInfos.prototype.server_ip = "";

        /**
         * DynQualityInfos infos.
         * @member {Array.<logreport.IDynQualityInfo>} infos
         * @memberof logreport.DynQualityInfos
         * @instance
         */
        DynQualityInfos.prototype.infos = $util.emptyArray;

        /**
         * DynQualityInfos network_type.
         * @member {number} network_type
         * @memberof logreport.DynQualityInfos
         * @instance
         */
        DynQualityInfos.prototype.network_type = 0;

        /**
         * DynQualityInfos stream_id.
         * @member {string} stream_id
         * @memberof logreport.DynQualityInfos
         * @instance
         */
        DynQualityInfos.prototype.stream_id = "";

        /**
         * Creates a new DynQualityInfos instance using the specified properties.
         * @function create
         * @memberof logreport.DynQualityInfos
         * @static
         * @param {logreport.IDynQualityInfos=} [properties] Properties to set
         * @returns {logreport.DynQualityInfos} DynQualityInfos instance
         */
        DynQualityInfos.create = function create(properties) {
            return new DynQualityInfos(properties);
        };

        /**
         * Encodes the specified DynQualityInfos message. Does not implicitly {@link logreport.DynQualityInfos.verify|verify} messages.
         * @function encode
         * @memberof logreport.DynQualityInfos
         * @static
         * @param {logreport.IDynQualityInfos} message DynQualityInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DynQualityInfos.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp_offset_begin != null && Object.hasOwnProperty.call(message, "timestamp_offset_begin"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.timestamp_offset_begin);
            if (message.timestamp_offset_end != null && Object.hasOwnProperty.call(message, "timestamp_offset_end"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp_offset_end);
            if (message.server_ip != null && Object.hasOwnProperty.call(message, "server_ip"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.server_ip);
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.logreport.DynQualityInfo.encode(message.infos[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.network_type != null && Object.hasOwnProperty.call(message, "network_type"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.network_type);
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.stream_id);
            return writer;
        };

        /**
         * Encodes the specified DynQualityInfos message, length delimited. Does not implicitly {@link logreport.DynQualityInfos.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.DynQualityInfos
         * @static
         * @param {logreport.IDynQualityInfos} message DynQualityInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DynQualityInfos.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DynQualityInfos message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.DynQualityInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.DynQualityInfos} DynQualityInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DynQualityInfos.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.DynQualityInfos();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp_offset_begin = reader.uint64();
                    break;
                case 2:
                    message.timestamp_offset_end = reader.uint64();
                    break;
                case 3:
                    message.server_ip = reader.string();
                    break;
                case 4:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.logreport.DynQualityInfo.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.network_type = reader.uint32();
                    break;
                case 6:
                    message.stream_id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DynQualityInfos message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.DynQualityInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.DynQualityInfos} DynQualityInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DynQualityInfos.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DynQualityInfos message.
         * @function verify
         * @memberof logreport.DynQualityInfos
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DynQualityInfos.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                if (!$util.isInteger(message.timestamp_offset_begin) && !(message.timestamp_offset_begin && $util.isInteger(message.timestamp_offset_begin.low) && $util.isInteger(message.timestamp_offset_begin.high)))
                    return "timestamp_offset_begin: integer|Long expected";
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                if (!$util.isInteger(message.timestamp_offset_end) && !(message.timestamp_offset_end && $util.isInteger(message.timestamp_offset_end.low) && $util.isInteger(message.timestamp_offset_end.high)))
                    return "timestamp_offset_end: integer|Long expected";
            if (message.server_ip != null && message.hasOwnProperty("server_ip"))
                if (!$util.isString(message.server_ip))
                    return "server_ip: string expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.logreport.DynQualityInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            if (message.network_type != null && message.hasOwnProperty("network_type"))
                if (!$util.isInteger(message.network_type))
                    return "network_type: integer expected";
            if (message.stream_id != null && message.hasOwnProperty("stream_id"))
                if (!$util.isString(message.stream_id))
                    return "stream_id: string expected";
            return null;
        };

        /**
         * Creates a DynQualityInfos message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.DynQualityInfos
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.DynQualityInfos} DynQualityInfos
         */
        DynQualityInfos.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.DynQualityInfos)
                return object;
            var message = new $root.logreport.DynQualityInfos();
            if (object.timestamp_offset_begin != null)
                if ($util.Long)
                    (message.timestamp_offset_begin = $util.Long.fromValue(object.timestamp_offset_begin)).unsigned = true;
                else if (typeof object.timestamp_offset_begin === "string")
                    message.timestamp_offset_begin = parseInt(object.timestamp_offset_begin, 10);
                else if (typeof object.timestamp_offset_begin === "number")
                    message.timestamp_offset_begin = object.timestamp_offset_begin;
                else if (typeof object.timestamp_offset_begin === "object")
                    message.timestamp_offset_begin = new $util.LongBits(object.timestamp_offset_begin.low >>> 0, object.timestamp_offset_begin.high >>> 0).toNumber(true);
            if (object.timestamp_offset_end != null)
                if ($util.Long)
                    (message.timestamp_offset_end = $util.Long.fromValue(object.timestamp_offset_end)).unsigned = true;
                else if (typeof object.timestamp_offset_end === "string")
                    message.timestamp_offset_end = parseInt(object.timestamp_offset_end, 10);
                else if (typeof object.timestamp_offset_end === "number")
                    message.timestamp_offset_end = object.timestamp_offset_end;
                else if (typeof object.timestamp_offset_end === "object")
                    message.timestamp_offset_end = new $util.LongBits(object.timestamp_offset_end.low >>> 0, object.timestamp_offset_end.high >>> 0).toNumber(true);
            if (object.server_ip != null)
                message.server_ip = String(object.server_ip);
            if (object.infos) {
                if (!Array.isArray(object.infos))
                    throw TypeError(".logreport.DynQualityInfos.infos: array expected");
                message.infos = [];
                for (var i = 0; i < object.infos.length; ++i) {
                    if (typeof object.infos[i] !== "object")
                        throw TypeError(".logreport.DynQualityInfos.infos: object expected");
                    message.infos[i] = $root.logreport.DynQualityInfo.fromObject(object.infos[i]);
                }
            }
            if (object.network_type != null)
                message.network_type = object.network_type >>> 0;
            if (object.stream_id != null)
                message.stream_id = String(object.stream_id);
            return message;
        };

        /**
         * Creates a plain object from a DynQualityInfos message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.DynQualityInfos
         * @static
         * @param {logreport.DynQualityInfos} message DynQualityInfos
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DynQualityInfos.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.infos = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp_offset_begin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp_offset_begin = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp_offset_end = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp_offset_end = options.longs === String ? "0" : 0;
                object.server_ip = "";
                object.network_type = 0;
                object.stream_id = "";
            }
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                if (typeof message.timestamp_offset_begin === "number")
                    object.timestamp_offset_begin = options.longs === String ? String(message.timestamp_offset_begin) : message.timestamp_offset_begin;
                else
                    object.timestamp_offset_begin = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp_offset_begin) : options.longs === Number ? new $util.LongBits(message.timestamp_offset_begin.low >>> 0, message.timestamp_offset_begin.high >>> 0).toNumber(true) : message.timestamp_offset_begin;
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                if (typeof message.timestamp_offset_end === "number")
                    object.timestamp_offset_end = options.longs === String ? String(message.timestamp_offset_end) : message.timestamp_offset_end;
                else
                    object.timestamp_offset_end = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp_offset_end) : options.longs === Number ? new $util.LongBits(message.timestamp_offset_end.low >>> 0, message.timestamp_offset_end.high >>> 0).toNumber(true) : message.timestamp_offset_end;
            if (message.server_ip != null && message.hasOwnProperty("server_ip"))
                object.server_ip = message.server_ip;
            if (message.infos && message.infos.length) {
                object.infos = [];
                for (var j = 0; j < message.infos.length; ++j)
                    object.infos[j] = $root.logreport.DynQualityInfo.toObject(message.infos[j], options);
            }
            if (message.network_type != null && message.hasOwnProperty("network_type"))
                object.network_type = message.network_type;
            if (message.stream_id != null && message.hasOwnProperty("stream_id"))
                object.stream_id = message.stream_id;
            return object;
        };

        /**
         * Converts this DynQualityInfos to JSON.
         * @function toJSON
         * @memberof logreport.DynQualityInfos
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DynQualityInfos.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DynQualityInfos;
    })();

    logreport.DynQualityInfo = (function() {

        /**
         * Properties of a DynQualityInfo.
         * @memberof logreport
         * @interface IDynQualityInfo
         * @property {number|Long|null} [time] DynQualityInfo time
         * @property {number|null} [plr] DynQualityInfo plr
         * @property {number|null} [rtt] DynQualityInfo rtt
         * @property {number|null} [score] DynQualityInfo score
         * @property {number|null} [sample_time] DynQualityInfo sample_time
         */

        /**
         * Constructs a new DynQualityInfo.
         * @memberof logreport
         * @classdesc Represents a DynQualityInfo.
         * @implements IDynQualityInfo
         * @constructor
         * @param {logreport.IDynQualityInfo=} [properties] Properties to set
         */
        function DynQualityInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DynQualityInfo time.
         * @member {number|Long} time
         * @memberof logreport.DynQualityInfo
         * @instance
         */
        DynQualityInfo.prototype.time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DynQualityInfo plr.
         * @member {number} plr
         * @memberof logreport.DynQualityInfo
         * @instance
         */
        DynQualityInfo.prototype.plr = 0;

        /**
         * DynQualityInfo rtt.
         * @member {number} rtt
         * @memberof logreport.DynQualityInfo
         * @instance
         */
        DynQualityInfo.prototype.rtt = 0;

        /**
         * DynQualityInfo score.
         * @member {number} score
         * @memberof logreport.DynQualityInfo
         * @instance
         */
        DynQualityInfo.prototype.score = 0;

        /**
         * DynQualityInfo sample_time.
         * @member {number} sample_time
         * @memberof logreport.DynQualityInfo
         * @instance
         */
        DynQualityInfo.prototype.sample_time = 0;

        /**
         * Creates a new DynQualityInfo instance using the specified properties.
         * @function create
         * @memberof logreport.DynQualityInfo
         * @static
         * @param {logreport.IDynQualityInfo=} [properties] Properties to set
         * @returns {logreport.DynQualityInfo} DynQualityInfo instance
         */
        DynQualityInfo.create = function create(properties) {
            return new DynQualityInfo(properties);
        };

        /**
         * Encodes the specified DynQualityInfo message. Does not implicitly {@link logreport.DynQualityInfo.verify|verify} messages.
         * @function encode
         * @memberof logreport.DynQualityInfo
         * @static
         * @param {logreport.IDynQualityInfo} message DynQualityInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DynQualityInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.time);
            if (message.plr != null && Object.hasOwnProperty.call(message, "plr"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.plr);
            if (message.rtt != null && Object.hasOwnProperty.call(message, "rtt"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.rtt);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.score);
            if (message.sample_time != null && Object.hasOwnProperty.call(message, "sample_time"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.sample_time);
            return writer;
        };

        /**
         * Encodes the specified DynQualityInfo message, length delimited. Does not implicitly {@link logreport.DynQualityInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.DynQualityInfo
         * @static
         * @param {logreport.IDynQualityInfo} message DynQualityInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DynQualityInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DynQualityInfo message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.DynQualityInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.DynQualityInfo} DynQualityInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DynQualityInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.DynQualityInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.uint64();
                    break;
                case 2:
                    message.plr = reader.uint32();
                    break;
                case 3:
                    message.rtt = reader.uint32();
                    break;
                case 4:
                    message.score = reader.uint32();
                    break;
                case 5:
                    message.sample_time = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DynQualityInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.DynQualityInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.DynQualityInfo} DynQualityInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DynQualityInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DynQualityInfo message.
         * @function verify
         * @memberof logreport.DynQualityInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DynQualityInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            if (message.plr != null && message.hasOwnProperty("plr"))
                if (!$util.isInteger(message.plr))
                    return "plr: integer expected";
            if (message.rtt != null && message.hasOwnProperty("rtt"))
                if (!$util.isInteger(message.rtt))
                    return "rtt: integer expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.sample_time != null && message.hasOwnProperty("sample_time"))
                if (!$util.isInteger(message.sample_time))
                    return "sample_time: integer expected";
            return null;
        };

        /**
         * Creates a DynQualityInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.DynQualityInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.DynQualityInfo} DynQualityInfo
         */
        DynQualityInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.DynQualityInfo)
                return object;
            var message = new $root.logreport.DynQualityInfo();
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = true;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber(true);
            if (object.plr != null)
                message.plr = object.plr >>> 0;
            if (object.rtt != null)
                message.rtt = object.rtt >>> 0;
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.sample_time != null)
                message.sample_time = object.sample_time >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a DynQualityInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.DynQualityInfo
         * @static
         * @param {logreport.DynQualityInfo} message DynQualityInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DynQualityInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
                object.plr = 0;
                object.rtt = 0;
                object.score = 0;
                object.sample_time = 0;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber(true) : message.time;
            if (message.plr != null && message.hasOwnProperty("plr"))
                object.plr = message.plr;
            if (message.rtt != null && message.hasOwnProperty("rtt"))
                object.rtt = message.rtt;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.sample_time != null && message.hasOwnProperty("sample_time"))
                object.sample_time = message.sample_time;
            return object;
        };

        /**
         * Converts this DynQualityInfo to JSON.
         * @function toJSON
         * @memberof logreport.DynQualityInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DynQualityInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DynQualityInfo;
    })();

    return logreport;
})();

module.exports = $root;


/***/ }),

/***/ "./sdk/src/webrtc/adapter.js":
/*!***********************************!*\
  !*** ./sdk/src/webrtc/adapter.js ***!
  \***********************************/
/***/ (function(module) {

(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=undefined;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=undefined,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */

  'use strict';

  var _adapter_factory = require('./adapter_factory.js');

  var adapter = (0, _adapter_factory.adapterFactory)({ window: window });
  module.exports = adapter; // this is the difference from adapter_core.

  },{"./adapter_factory.js":2}],2:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.adapterFactory = adapterFactory;

  var _utils = require('./utils');

  var utils = _interopRequireWildcard(_utils);

  var _chrome_shim = require('./chrome/chrome_shim');

  var chromeShim = _interopRequireWildcard(_chrome_shim);

  var _edge_shim = require('./edge/edge_shim');

  var edgeShim = _interopRequireWildcard(_edge_shim);

  var _firefox_shim = require('./firefox/firefox_shim');

  var firefoxShim = _interopRequireWildcard(_firefox_shim);

  var _safari_shim = require('./safari/safari_shim');

  var safariShim = _interopRequireWildcard(_safari_shim);

  var _common_shim = require('./common_shim');

  var commonShim = _interopRequireWildcard(_common_shim);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  // Shimming starts here.
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  function adapterFactory() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        window = _ref.window;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      shimChrome: true,
      shimFirefox: true,
      shimEdge: true,
      shimSafari: true
    };

    // Utils.
    var logging = utils.log;
    var browserDetails = utils.detectBrowser(window);

    var adapter = {
      browserDetails: browserDetails,
      commonShim: commonShim,
      extractVersion: utils.extractVersion,
      disableLog: utils.disableLog,
      disableWarnings: utils.disableWarnings
    };

    // Shim browser if found.
    switch (browserDetails.browser) {
      case 'chrome':
        if (!chromeShim || !chromeShim.shimPeerConnection || !options.shimChrome) {
          logging('Chrome shim is not included in this adapter release.');
          return adapter;
        }
        logging('adapter.js shimming chrome.');
        // Export to the adapter global object visible in the browser.
        adapter.browserShim = chromeShim;

        chromeShim.shimGetUserMedia(window);
        chromeShim.shimMediaStream(window);
        chromeShim.shimPeerConnection(window);
        chromeShim.shimOnTrack(window);
        chromeShim.shimAddTrackRemoveTrack(window);
        chromeShim.shimGetSendersWithDtmf(window);
        chromeShim.shimGetStats(window);
        chromeShim.shimSenderReceiverGetStats(window);
        chromeShim.fixNegotiationNeeded(window);

        commonShim.shimRTCIceCandidate(window);
        commonShim.shimConnectionState(window);
        commonShim.shimMaxMessageSize(window);
        commonShim.shimSendThrowTypeError(window);
        commonShim.removeAllowExtmapMixed(window);
        break;
      case 'firefox':
        if (!firefoxShim || !firefoxShim.shimPeerConnection || !options.shimFirefox) {
          logging('Firefox shim is not included in this adapter release.');
          return adapter;
        }
        logging('adapter.js shimming firefox.');
        // Export to the adapter global object visible in the browser.
        adapter.browserShim = firefoxShim;

        firefoxShim.shimGetUserMedia(window);
        firefoxShim.shimPeerConnection(window);
        firefoxShim.shimOnTrack(window);
        firefoxShim.shimRemoveStream(window);
        firefoxShim.shimSenderGetStats(window);
        firefoxShim.shimReceiverGetStats(window);
        firefoxShim.shimRTCDataChannel(window);

        commonShim.shimRTCIceCandidate(window);
        commonShim.shimConnectionState(window);
        commonShim.shimMaxMessageSize(window);
        commonShim.shimSendThrowTypeError(window);
        break;
      case 'edge':
        if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
          logging('MS edge shim is not included in this adapter release.');
          return adapter;
        }
        logging('adapter.js shimming edge.');
        // Export to the adapter global object visible in the browser.
        adapter.browserShim = edgeShim;

        edgeShim.shimGetUserMedia(window);
        edgeShim.shimGetDisplayMedia(window);
        edgeShim.shimPeerConnection(window);
        edgeShim.shimReplaceTrack(window);

        // the edge shim implements the full RTCIceCandidate object.

        commonShim.shimMaxMessageSize(window);
        commonShim.shimSendThrowTypeError(window);
        break;
      case 'safari':
        if (!safariShim || !options.shimSafari) {
          logging('Safari shim is not included in this adapter release.');
          return adapter;
        }
        logging('adapter.js shimming safari.');
        // Export to the adapter global object visible in the browser.
        adapter.browserShim = safariShim;

        safariShim.shimRTCIceServerUrls(window);
        safariShim.shimCreateOfferLegacy(window);
        safariShim.shimCallbacksAPI(window);
        safariShim.shimLocalStreamsAPI(window);
        safariShim.shimRemoteStreamsAPI(window);
        safariShim.shimTrackEventTransceiver(window);
        safariShim.shimGetUserMedia(window);

        commonShim.shimRTCIceCandidate(window);
        commonShim.shimMaxMessageSize(window);
        commonShim.shimSendThrowTypeError(window);
        commonShim.removeAllowExtmapMixed(window);
        break;
      default:
        logging('Unsupported browser!');
        break;
    }

    return adapter;
  }

  // Browser shims.

  },{"./chrome/chrome_shim":3,"./common_shim":6,"./edge/edge_shim":7,"./firefox/firefox_shim":11,"./safari/safari_shim":14,"./utils":15}],3:[function(require,module,exports){

  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _getusermedia = require('./getusermedia');

  Object.defineProperty(exports, 'shimGetUserMedia', {
    enumerable: true,
    get: function get() {
      return _getusermedia.shimGetUserMedia;
    }
  });

  var _getdisplaymedia = require('./getdisplaymedia');

  Object.defineProperty(exports, 'shimGetDisplayMedia', {
    enumerable: true,
    get: function get() {
      return _getdisplaymedia.shimGetDisplayMedia;
    }
  });
  exports.shimMediaStream = shimMediaStream;
  exports.shimOnTrack = shimOnTrack;
  exports.shimGetSendersWithDtmf = shimGetSendersWithDtmf;
  exports.shimGetStats = shimGetStats;
  exports.shimSenderReceiverGetStats = shimSenderReceiverGetStats;
  exports.shimAddTrackRemoveTrackWithNative = shimAddTrackRemoveTrackWithNative;
  exports.shimAddTrackRemoveTrack = shimAddTrackRemoveTrack;
  exports.shimPeerConnection = shimPeerConnection;
  exports.fixNegotiationNeeded = fixNegotiationNeeded;

  var _utils = require('../utils.js');

  var utils = _interopRequireWildcard(_utils);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function shimMediaStream(window) {
    window.MediaStream = window.MediaStream || window.webkitMediaStream;
  }

  function shimOnTrack(window) {
    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function get() {
          return this._ontrack;
        },
        set: function set(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
          }
          this.addEventListener('track', this._ontrack = f);
        },

        enumerable: true,
        configurable: true
      });
      var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription = function () {
        var _this = this;

        if (!this._ontrackpoly) {
          this._ontrackpoly = function (e) {
            // onaddstream does not fire when a track is added to an existing
            // stream. But stream.onaddtrack is implemented so we use that.
            e.stream.addEventListener('addtrack', function (te) {
              var receiver = void 0;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = _this.getReceivers().find(function (r) {
                  return r.track && r.track.id === te.track.id;
                });
              } else {
                receiver = { track: te.track };
              }

              var event = new Event('track');
              event.track = te.track;
              event.receiver = receiver;
              event.transceiver = { receiver: receiver };
              event.streams = [e.stream];
              _this.dispatchEvent(event);
            });
            e.stream.getTracks().forEach(function (track) {
              var receiver = void 0;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = _this.getReceivers().find(function (r) {
                  return r.track && r.track.id === track.id;
                });
              } else {
                receiver = { track: track };
              }
              var event = new Event('track');
              event.track = track;
              event.receiver = receiver;
              event.transceiver = { receiver: receiver };
              event.streams = [e.stream];
              _this.dispatchEvent(event);
            });
          };
          this.addEventListener('addstream', this._ontrackpoly);
        }
        return origSetRemoteDescription.apply(this, arguments);
      };
    } else {
      // even if RTCRtpTransceiver is in window, it is only used and
      // emitted in unified-plan. Unfortunately this means we need
      // to unconditionally wrap the event.
      utils.wrapPeerConnectionEvent(window, 'track', function (e) {
        if (!e.transceiver) {
          Object.defineProperty(e, 'transceiver', { value: { receiver: e.receiver } });
        }
        return e;
      });
    }
  }

  function shimGetSendersWithDtmf(window) {
    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {
      var shimSenderWithDtmf = function shimSenderWithDtmf(pc, track) {
        return {
          track: track,
          get dtmf() {
            if (this._dtmf === undefined) {
              if (track.kind === 'audio') {
                this._dtmf = pc.createDTMFSender(track);
              } else {
                this._dtmf = null;
              }
            }
            return this._dtmf;
          },
          _pc: pc
        };
      };

      // augment addTrack when getSenders is not available.
      if (!window.RTCPeerConnection.prototype.getSenders) {
        window.RTCPeerConnection.prototype.getSenders = function () {
          this._senders = this._senders || [];
          return this._senders.slice(); // return a copy of the internal state.
        };
        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
        window.RTCPeerConnection.prototype.addTrack = function (track, stream) {
          var sender = origAddTrack.apply(this, arguments);
          if (!sender) {
            sender = shimSenderWithDtmf(this, track);
            this._senders.push(sender);
          }
          return sender;
        };

        var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
        window.RTCPeerConnection.prototype.removeTrack = function (sender) {
          origRemoveTrack.apply(this, arguments);
          var idx = this._senders.indexOf(sender);
          if (idx !== -1) {
            this._senders.splice(idx, 1);
          }
        };
      }
      var origAddStream = window.RTCPeerConnection.prototype.addStream;
      window.RTCPeerConnection.prototype.addStream = function (stream) {
        var _this2 = this;

        this._senders = this._senders || [];
        origAddStream.apply(this, [stream]);
        stream.getTracks().forEach(function (track) {
          _this2._senders.push(shimSenderWithDtmf(_this2, track));
        });
      };

      var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
      window.RTCPeerConnection.prototype.removeStream = function (stream) {
        var _this3 = this;

        this._senders = this._senders || [];
        origRemoveStream.apply(this, [stream]);

        stream.getTracks().forEach(function (track) {
          var sender = _this3._senders.find(function (s) {
            return s.track === track;
          });
          if (sender) {
            // remove sender
            _this3._senders.splice(_this3._senders.indexOf(sender), 1);
          }
        });
      };
    } else if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      window.RTCPeerConnection.prototype.getSenders = function () {
        var _this4 = this;

        var senders = origGetSenders.apply(this, []);
        senders.forEach(function (sender) {
          return sender._pc = _this4;
        });
        return senders;
      };

      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get: function get() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = this._pc.createDTMFSender(this.track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
  }

  function shimGetStats(window) {
    if (!window.RTCPeerConnection) {
      return;
    }

    var origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function (selector, successCallback, errorCallback) {
      var _this5 = this;

      var args = arguments;

      // If selector is a function then we are in the old style stats so just
      // pass back the original getStats format to avoid breaking old users.
      if (arguments.length > 0 && typeof selector === 'function') {
        return origGetStats.apply(this, arguments);
      }

      // When spec-style getStats is supported, return those when called with
      // either no arguments or the selector argument is null.
      if (origGetStats.length === 0 && (arguments.length === 0 || typeof arguments[0] !== 'function')) {
        return origGetStats.apply(this, []);
      }

      var fixChromeStats_ = function fixChromeStats_(response) {
        var standardReport = {};
        var reports = response.result();
        reports.forEach(function (report) {
          var standardStats = {
            id: report.id,
            timestamp: report.timestamp,
            type: {
              localcandidate: 'local-candidate',
              remotecandidate: 'remote-candidate'
            }[report.type] || report.type
          };
          report.names().forEach(function (name) {
            standardStats[name] = report.stat(name);
          });
          standardReport[standardStats.id] = standardStats;
        });

        return standardReport;
      };

      // shim getStats with maplike support
      var makeMapStats = function makeMapStats(stats) {
        return new Map(Object.keys(stats).map(function (key) {
          return [key, stats[key]];
        }));
      };

      if (arguments.length >= 2) {
        var successCallbackWrapper_ = function successCallbackWrapper_(response) {
          args[1](makeMapStats(fixChromeStats_(response)));
        };

        return origGetStats.apply(this, [successCallbackWrapper_, arguments[0]]);
      }

      // promise-support
      return new Promise(function (resolve, reject) {
        origGetStats.apply(_this5, [function (response) {
          resolve(makeMapStats(fixChromeStats_(response)));
        }, reject]);
      }).then(successCallback, errorCallback);
    };
  }

  function shimSenderReceiverGetStats(window) {
    if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {
      return;
    }

    // shim sender stats.
    if (!('getStats' in window.RTCRtpSender.prototype)) {
      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      if (origGetSenders) {
        window.RTCPeerConnection.prototype.getSenders = function () {
          var _this6 = this;

          var senders = origGetSenders.apply(this, []);
          senders.forEach(function (sender) {
            return sender._pc = _this6;
          });
          return senders;
        };
      }

      var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
      if (origAddTrack) {
        window.RTCPeerConnection.prototype.addTrack = function () {
          var sender = origAddTrack.apply(this, arguments);
          sender._pc = this;
          return sender;
        };
      }
      window.RTCRtpSender.prototype.getStats = function () {
        var sender = this;
        return this._pc.getStats().then(function (result) {
          return (
            /* Note: this will include stats of all senders that
             *   send a track with the same id as sender.track as
             *   it is not possible to identify the RTCRtpSender.
             */
            utils.filterStats(result, sender.track, true)
          );
        });
      };
    }

    // shim receiver stats.
    if (!('getStats' in window.RTCRtpReceiver.prototype)) {
      var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
      if (origGetReceivers) {
        window.RTCPeerConnection.prototype.getReceivers = function () {
          var _this7 = this;

          var receivers = origGetReceivers.apply(this, []);
          receivers.forEach(function (receiver) {
            return receiver._pc = _this7;
          });
          return receivers;
        };
      }
      utils.wrapPeerConnectionEvent(window, 'track', function (e) {
        e.receiver._pc = e.srcElement;
        return e;
      });
      window.RTCRtpReceiver.prototype.getStats = function () {
        var receiver = this;
        return this._pc.getStats().then(function (result) {
          return utils.filterStats(result, receiver.track, false);
        });
      };
    }

    if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {
      return;
    }

    // shim RTCPeerConnection.getStats(track).
    var origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function () {
      if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {
        var track = arguments[0];
        var sender = void 0;
        var receiver = void 0;
        var err = void 0;
        this.getSenders().forEach(function (s) {
          if (s.track === track) {
            if (sender) {
              err = true;
            } else {
              sender = s;
            }
          }
        });
        this.getReceivers().forEach(function (r) {
          if (r.track === track) {
            if (receiver) {
              err = true;
            } else {
              receiver = r;
            }
          }
          return r.track === track;
        });
        if (err || sender && receiver) {
          return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));
        } else if (sender) {
          return sender.getStats();
        } else if (receiver) {
          return receiver.getStats();
        }
        return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));
      }
      return origGetStats.apply(this, arguments);
    };
  }

  function shimAddTrackRemoveTrackWithNative(window) {
    // shim addTrack/removeTrack with native variants in order to make
    // the interactions with legacy getLocalStreams behave as in other browsers.
    // Keeps a mapping stream.id => [stream, rtpsenders...]
    window.RTCPeerConnection.prototype.getLocalStreams = function () {
      var _this8 = this;

      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      return Object.keys(this._shimmedLocalStreams).map(function (streamId) {
        return _this8._shimmedLocalStreams[streamId][0];
      });
    };

    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    window.RTCPeerConnection.prototype.addTrack = function (track, stream) {
      if (!stream) {
        return origAddTrack.apply(this, arguments);
      }
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};

      var sender = origAddTrack.apply(this, arguments);
      if (!this._shimmedLocalStreams[stream.id]) {
        this._shimmedLocalStreams[stream.id] = [stream, sender];
      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
        this._shimmedLocalStreams[stream.id].push(sender);
      }
      return sender;
    };

    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function (stream) {
      var _this9 = this;

      this._shimmedLocalStreams = this._shimmedLocalStreams || {};

      stream.getTracks().forEach(function (track) {
        var alreadyExists = _this9.getSenders().find(function (s) {
          return s.track === track;
        });
        if (alreadyExists) {
          throw new DOMException('Track already exists.', 'InvalidAccessError');
        }
      });
      var existingSenders = this.getSenders();
      origAddStream.apply(this, arguments);
      var newSenders = this.getSenders().filter(function (newSender) {
        return existingSenders.indexOf(newSender) === -1;
      });
      this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function (stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      delete this._shimmedLocalStreams[stream.id];
      return origRemoveStream.apply(this, arguments);
    };

    var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
    window.RTCPeerConnection.prototype.removeTrack = function (sender) {
      var _this10 = this;

      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      if (sender) {
        Object.keys(this._shimmedLocalStreams).forEach(function (streamId) {
          var idx = _this10._shimmedLocalStreams[streamId].indexOf(sender);
          if (idx !== -1) {
            _this10._shimmedLocalStreams[streamId].splice(idx, 1);
          }
          if (_this10._shimmedLocalStreams[streamId].length === 1) {
            delete _this10._shimmedLocalStreams[streamId];
          }
        });
      }
      return origRemoveTrack.apply(this, arguments);
    };
  }

  function shimAddTrackRemoveTrack(window) {
    if (!window.RTCPeerConnection) {
      return;
    }
    var browserDetails = utils.detectBrowser(window);
    // shim addTrack and removeTrack.
    if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
      return shimAddTrackRemoveTrackWithNative(window);
    }

    // also shim pc.getLocalStreams when addTrack is shimmed
    // to return the original streams.
    var origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;
    window.RTCPeerConnection.prototype.getLocalStreams = function () {
      var _this11 = this;

      var nativeStreams = origGetLocalStreams.apply(this);
      this._reverseStreams = this._reverseStreams || {};
      return nativeStreams.map(function (stream) {
        return _this11._reverseStreams[stream.id];
      });
    };

    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function (stream) {
      var _this12 = this;

      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};

      stream.getTracks().forEach(function (track) {
        var alreadyExists = _this12.getSenders().find(function (s) {
          return s.track === track;
        });
        if (alreadyExists) {
          throw new DOMException('Track already exists.', 'InvalidAccessError');
        }
      });
      // Add identity mapping for consistency with addTrack.
      // Unless this is being used with a stream from addTrack.
      if (!this._reverseStreams[stream.id]) {
        var newStream = new window.MediaStream(stream.getTracks());
        this._streams[stream.id] = newStream;
        this._reverseStreams[newStream.id] = stream;
        stream = newStream;
      }
      origAddStream.apply(this, [stream]);
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function (stream) {
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};

      origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
      delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
      delete this._streams[stream.id];
    };

    window.RTCPeerConnection.prototype.addTrack = function (track, stream) {
      var _this13 = this;

      if (this.signalingState === 'closed') {
        throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
      }
      var streams = [].slice.call(arguments, 1);
      if (streams.length !== 1 || !streams[0].getTracks().find(function (t) {
        return t === track;
      })) {
        // this is not fully correct but all we can manage without
        // [[associated MediaStreams]] internal slot.
        throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');
      }

      var alreadyExists = this.getSenders().find(function (s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException('Track already exists.', 'InvalidAccessError');
      }

      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
      var oldStream = this._streams[stream.id];
      if (oldStream) {
        // this is using odd Chrome behaviour, use with caution:
        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
        // Note: we rely on the high-level addTrack/dtmf shim to
        // create the sender with a dtmf sender.
        oldStream.addTrack(track);

        // Trigger ONN async.
        Promise.resolve().then(function () {
          _this13.dispatchEvent(new Event('negotiationneeded'));
        });
      } else {
        var newStream = new window.MediaStream([track]);
        this._streams[stream.id] = newStream;
        this._reverseStreams[newStream.id] = stream;
        this.addStream(newStream);
      }
      return this.getSenders().find(function (s) {
        return s.track === track;
      });
    };

    // replace the internal stream id with the external one and
    // vice versa.
    function replaceInternalStreamId(pc, description) {
      var sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
        var externalStream = pc._reverseStreams[internalId];
        var internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp
      });
    }
    function replaceExternalStreamId(pc, description) {
      var sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
        var externalStream = pc._reverseStreams[internalId];
        var internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp
      });
    }
    ['createOffer', 'createAnswer'].forEach(function (method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      window.RTCPeerConnection.prototype[method] = function () {
        var _this14 = this;

        var args = arguments;
        var isLegacyCall = arguments.length && typeof arguments[0] === 'function';
        if (isLegacyCall) {
          return nativeMethod.apply(this, [function (description) {
            var desc = replaceInternalStreamId(_this14, description);
            args[0].apply(null, [desc]);
          }, function (err) {
            if (args[1]) {
              args[1].apply(null, err);
            }
          }, arguments[2]]);
        }
        return nativeMethod.apply(this, arguments).then(function (description) {
          return replaceInternalStreamId(_this14, description);
        });
      };
    });

    var origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;
    window.RTCPeerConnection.prototype.setLocalDescription = function () {
      if (!arguments.length || !arguments[0].type) {
        return origSetLocalDescription.apply(this, arguments);
      }
      arguments[0] = replaceExternalStreamId(this, arguments[0]);
      return origSetLocalDescription.apply(this, arguments);
    };

    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

    var origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');
    Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {
      get: function get() {
        var description = origLocalDescription.get.apply(this);
        if (description.type === '') {
          return description;
        }
        return replaceInternalStreamId(this, description);
      }
    });

    window.RTCPeerConnection.prototype.removeTrack = function (sender) {
      var _this15 = this;

      if (this.signalingState === 'closed') {
        throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
      }
      // We can not yet check for sender instanceof RTCRtpSender
      // since we shim RTPSender. So we check if sender._pc is set.
      if (!sender._pc) {
        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');
      }
      var isLocal = sender._pc === this;
      if (!isLocal) {
        throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');
      }

      // Search for the native stream the senders track belongs to.
      this._streams = this._streams || {};
      var stream = void 0;
      Object.keys(this._streams).forEach(function (streamid) {
        var hasTrack = _this15._streams[streamid].getTracks().find(function (track) {
          return sender.track === track;
        });
        if (hasTrack) {
          stream = _this15._streams[streamid];
        }
      });

      if (stream) {
        if (stream.getTracks().length === 1) {
          // if this is the last track of the stream, remove the stream. This
          // takes care of any shimmed _senders.
          this.removeStream(this._reverseStreams[stream.id]);
        } else {
          // relying on the same odd chrome behaviour as above.
          stream.removeTrack(sender.track);
        }
        this.dispatchEvent(new Event('negotiationneeded'));
      }
    };
  }

  function shimPeerConnection(window) {
    if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
      // very basic support for old versions.
      window.RTCPeerConnection = window.webkitRTCPeerConnection;
    }
    if (!window.RTCPeerConnection) {
      return;
    }

    // shim implicit creation of RTCSessionDescription/RTCIceCandidate
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      window.RTCPeerConnection.prototype[method] = function () {
        arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      };
    });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function () {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  }

  function fixNegotiationNeeded(window) {
    utils.wrapPeerConnectionEvent(window, 'negotiationneeded', function (e) {
      var pc = e.target;
      if (pc.signalingState !== 'stable') {
        return;
      }
      return e;
    });
  }

  },{"../utils.js":15,"./getdisplaymedia":4,"./getusermedia":5}],4:[function(require,module,exports){
  /*
   *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.shimGetDisplayMedia = shimGetDisplayMedia;
  function shimGetDisplayMedia(window, getSourceId) {
    if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
      return;
    }
    if (!window.navigator.mediaDevices) {
      return;
    }
    // getSourceId is a function that returns a promise resolving with
    // the sourceId of the screen/window/tab to be shared.
    if (typeof getSourceId !== 'function') {
      console.error('shimGetDisplayMedia: getSourceId argument is not ' + 'a function');
      return;
    }
    window.navigator.mediaDevices.getDisplayMedia = function (constraints) {
      return getSourceId(constraints).then(function (sourceId) {
        var widthSpecified = constraints.video && constraints.video.width;
        var heightSpecified = constraints.video && constraints.video.height;
        var frameRateSpecified = constraints.video && constraints.video.frameRate;
        constraints.video = {
          mandatory: {
            chromeMediaSource: 'desktop',
            chromeMediaSourceId: sourceId,
            maxFrameRate: frameRateSpecified || 3
          }
        };
        if (widthSpecified) {
          constraints.video.mandatory.maxWidth = widthSpecified;
        }
        if (heightSpecified) {
          constraints.video.mandatory.maxHeight = heightSpecified;
        }
        return window.navigator.mediaDevices.getUserMedia(constraints);
      });
    };
  }

  },{}],5:[function(require,module,exports){
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  exports.shimGetUserMedia = shimGetUserMedia;

  var _utils = require('../utils.js');

  var utils = _interopRequireWildcard(_utils);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  var logging = utils.log;

  function shimGetUserMedia(window) {
    var navigator = window && window.navigator;

    if (!navigator.mediaDevices) {
      return;
    }

    var browserDetails = utils.detectBrowser(window);

    var constraintsToChrome_ = function constraintsToChrome_(c) {
      if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) !== 'object' || c.mandatory || c.optional) {
        return c;
      }
      var cc = {};
      Object.keys(c).forEach(function (key) {
        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
          return;
        }
        var r = _typeof(c[key]) === 'object' ? c[key] : { ideal: c[key] };
        if (r.exact !== undefined && typeof r.exact === 'number') {
          r.min = r.max = r.exact;
        }
        var oldname_ = function oldname_(prefix, name) {
          if (prefix) {
            return prefix + name.charAt(0).toUpperCase() + name.slice(1);
          }
          return name === 'deviceId' ? 'sourceId' : name;
        };
        if (r.ideal !== undefined) {
          cc.optional = cc.optional || [];
          var oc = {};
          if (typeof r.ideal === 'number') {
            oc[oldname_('min', key)] = r.ideal;
            cc.optional.push(oc);
            oc = {};
            oc[oldname_('max', key)] = r.ideal;
            cc.optional.push(oc);
          } else {
            oc[oldname_('', key)] = r.ideal;
            cc.optional.push(oc);
          }
        }
        if (r.exact !== undefined && typeof r.exact !== 'number') {
          cc.mandatory = cc.mandatory || {};
          cc.mandatory[oldname_('', key)] = r.exact;
        } else {
          ['min', 'max'].forEach(function (mix) {
            if (r[mix] !== undefined) {
              cc.mandatory = cc.mandatory || {};
              cc.mandatory[oldname_(mix, key)] = r[mix];
            }
          });
        }
      });
      if (c.advanced) {
        cc.optional = (cc.optional || []).concat(c.advanced);
      }
      return cc;
    };

    var shimConstraints_ = function shimConstraints_(constraints, func) {
      if (browserDetails.version >= 61) {
        return func(constraints);
      }
      constraints = JSON.parse(JSON.stringify(constraints));
      if (constraints && _typeof(constraints.audio) === 'object') {
        var remap = function remap(obj, a, b) {
          if (a in obj && !(b in obj)) {
            obj[b] = obj[a];
            delete obj[a];
          }
        };
        constraints = JSON.parse(JSON.stringify(constraints));
        remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
        remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
        constraints.audio = constraintsToChrome_(constraints.audio);
      }
      if (constraints && _typeof(constraints.video) === 'object') {
        // Shim facingMode for mobile & surface pro.
        var face = constraints.video.facingMode;
        face = face && ((typeof face === 'undefined' ? 'undefined' : _typeof(face)) === 'object' ? face : { ideal: face });
        var getSupportedFacingModeLies = browserDetails.version < 66;

        if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
          delete constraints.video.facingMode;
          var matches = void 0;
          if (face.exact === 'environment' || face.ideal === 'environment') {
            matches = ['back', 'rear'];
          } else if (face.exact === 'user' || face.ideal === 'user') {
            matches = ['front'];
          }
          if (matches) {
            // Look for matches in label, or use last cam for back (typical).
            return navigator.mediaDevices.enumerateDevices().then(function (devices) {
              devices = devices.filter(function (d) {
                return d.kind === 'videoinput';
              });
              var dev = devices.find(function (d) {
                return matches.some(function (match) {
                  return d.label.toLowerCase().includes(match);
                });
              });
              if (!dev && devices.length && matches.includes('back')) {
                dev = devices[devices.length - 1]; // more likely the back cam
              }
              if (dev) {
                constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };
              }
              constraints.video = constraintsToChrome_(constraints.video);
              logging('chrome: ' + JSON.stringify(constraints));
              return func(constraints);
            });
          }
        }
        constraints.video = constraintsToChrome_(constraints.video);
      }
      logging('chrome: ' + JSON.stringify(constraints));
      return func(constraints);
    };

    var shimError_ = function shimError_(e) {
      if (browserDetails.version >= 64) {
        return e;
      }
      return {
        name: {
          PermissionDeniedError: 'NotAllowedError',
          PermissionDismissedError: 'NotAllowedError',
          InvalidStateError: 'NotAllowedError',
          DevicesNotFoundError: 'NotFoundError',
          ConstraintNotSatisfiedError: 'OverconstrainedError',
          TrackStartError: 'NotReadableError',
          MediaDeviceFailedDueToShutdown: 'NotAllowedError',
          MediaDeviceKillSwitchOn: 'NotAllowedError',
          TabCaptureError: 'AbortError',
          ScreenCaptureError: 'AbortError',
          DeviceCaptureError: 'AbortError'
        }[e.name] || e.name,
        message: e.message,
        constraint: e.constraint || e.constraintName,
        toString: function toString() {
          return this.name + (this.message && ': ') + this.message;
        }
      };
    };

    var getUserMedia_ = function getUserMedia_(constraints, onSuccess, onError) {
      shimConstraints_(constraints, function (c) {
        navigator.webkitGetUserMedia(c, onSuccess, function (e) {
          if (onError) {
            onError(shimError_(e));
          }
        });
      });
    };
    navigator.getUserMedia = getUserMedia_.bind(navigator);

    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
    // function which returns a Promise, it does not accept spec-style
    // constraints.
    if (navigator.mediaDevices.getUserMedia) {
      var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
      navigator.mediaDevices.getUserMedia = function (cs) {
        return shimConstraints_(cs, function (c) {
          return origGetUserMedia(c).then(function (stream) {
            if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
              stream.getTracks().forEach(function (track) {
                track.stop();
              });
              throw new DOMException('', 'NotFoundError');
            }
            return stream;
          }, function (e) {
            return Promise.reject(shimError_(e));
          });
        });
      };
    }
  }

  },{"../utils.js":15}],6:[function(require,module,exports){
  /*
   *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  exports.shimRTCIceCandidate = shimRTCIceCandidate;
  exports.shimMaxMessageSize = shimMaxMessageSize;
  exports.shimSendThrowTypeError = shimSendThrowTypeError;
  exports.shimConnectionState = shimConnectionState;
  exports.removeAllowExtmapMixed = removeAllowExtmapMixed;

  var _sdp = require('sdp');

  var _sdp2 = _interopRequireDefault(_sdp);

  var _utils = require('./utils');

  var utils = _interopRequireWildcard(_utils);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function shimRTCIceCandidate(window) {
    // foundation is arbitrarily chosen as an indicator for full support for
    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
    if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {
      return;
    }

    var NativeRTCIceCandidate = window.RTCIceCandidate;
    window.RTCIceCandidate = function (args) {
      // Remove the a= which shouldn't be part of the candidate string.
      if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {
        args = JSON.parse(JSON.stringify(args));
        args.candidate = args.candidate.substr(2);
      }

      if (args.candidate && args.candidate.length) {
        // Augment the native candidate with the parsed fields.
        var nativeCandidate = new NativeRTCIceCandidate(args);
        var parsedCandidate = _sdp2.default.parseCandidate(args.candidate);
        var augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate);

        // Add a serializer that does not serialize the extra attributes.
        augmentedCandidate.toJSON = function () {
          return {
            candidate: augmentedCandidate.candidate,
            sdpMid: augmentedCandidate.sdpMid,
            sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
            usernameFragment: augmentedCandidate.usernameFragment
          };
        };
        return augmentedCandidate;
      }
      return new NativeRTCIceCandidate(args);
    };
    window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

    // Hook up the augmented candidate in onicecandidate and
    // addEventListener('icecandidate', ...)
    utils.wrapPeerConnectionEvent(window, 'icecandidate', function (e) {
      if (e.candidate) {
        Object.defineProperty(e, 'candidate', {
          value: new window.RTCIceCandidate(e.candidate),
          writable: 'false'
        });
      }
      return e;
    });
  }

  function shimMaxMessageSize(window) {
    if (window.RTCSctpTransport || !window.RTCPeerConnection) {
      return;
    }
    var browserDetails = utils.detectBrowser(window);

    if (!('sctp' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
        get: function get() {
          return typeof this._sctp === 'undefined' ? null : this._sctp;
        }
      });
    }

    var sctpInDescription = function sctpInDescription(description) {
      if (!description || !description.sdp) {
        return false;
      }
      var sections = _sdp2.default.splitSections(description.sdp);
      sections.shift();
      return sections.some(function (mediaSection) {
        var mLine = _sdp2.default.parseMLine(mediaSection);
        return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;
      });
    };

    var getRemoteFirefoxVersion = function getRemoteFirefoxVersion(description) {
      // TODO: Is there a better solution for detecting Firefox?
      var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
      if (match === null || match.length < 2) {
        return -1;
      }
      var version = parseInt(match[1], 10);
      // Test for NaN (yes, this is ugly)
      return version !== version ? -1 : version;
    };

    var getCanSendMaxMessageSize = function getCanSendMaxMessageSize(remoteIsFirefox) {
      // Every implementation we know can send at least 64 KiB.
      // Note: Although Chrome is technically able to send up to 256 KiB, the
      //       data does not reach the other peer reliably.
      //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
      var canSendMaxMessageSize = 65536;
      if (browserDetails.browser === 'firefox') {
        if (browserDetails.version < 57) {
          if (remoteIsFirefox === -1) {
            // FF < 57 will send in 16 KiB chunks using the deprecated PPID
            // fragmentation.
            canSendMaxMessageSize = 16384;
          } else {
            // However, other FF (and RAWRTC) can reassemble PPID-fragmented
            // messages. Thus, supporting ~2 GiB when sending.
            canSendMaxMessageSize = 2147483637;
          }
        } else if (browserDetails.version < 60) {
          // Currently, all FF >= 57 will reset the remote maximum message size
          // to the default value when a data channel is created at a later
          // stage. :(
          // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
          canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
        } else {
          // FF >= 60 supports sending ~2 GiB
          canSendMaxMessageSize = 2147483637;
        }
      }
      return canSendMaxMessageSize;
    };

    var getMaxMessageSize = function getMaxMessageSize(description, remoteIsFirefox) {
      // Note: 65536 bytes is the default value from the SDP spec. Also,
      //       every implementation we know supports receiving 65536 bytes.
      var maxMessageSize = 65536;

      // FF 57 has a slightly incorrect default remote max message size, so
      // we need to adjust it here to avoid a failure when sending.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
      if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {
        maxMessageSize = 65535;
      }

      var match = _sdp2.default.matchPrefix(description.sdp, 'a=max-message-size:');
      if (match.length > 0) {
        maxMessageSize = parseInt(match[0].substr(19), 10);
      } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {
        // If the maximum message size is not present in the remote SDP and
        // both local and remote are Firefox, the remote peer can receive
        // ~2 GiB.
        maxMessageSize = 2147483637;
      }
      return maxMessageSize;
    };

    var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function () {
      this._sctp = null;

      if (sctpInDescription(arguments[0])) {
        // Check if the remote is FF.
        var isFirefox = getRemoteFirefoxVersion(arguments[0]);

        // Get the maximum message size the local peer is capable of sending
        var canSendMMS = getCanSendMaxMessageSize(isFirefox);

        // Get the maximum message size of the remote peer.
        var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

        // Determine final maximum message size
        var maxMessageSize = void 0;
        if (canSendMMS === 0 && remoteMMS === 0) {
          maxMessageSize = Number.POSITIVE_INFINITY;
        } else if (canSendMMS === 0 || remoteMMS === 0) {
          maxMessageSize = Math.max(canSendMMS, remoteMMS);
        } else {
          maxMessageSize = Math.min(canSendMMS, remoteMMS);
        }

        // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
        // attribute.
        var sctp = {};
        Object.defineProperty(sctp, 'maxMessageSize', {
          get: function get() {
            return maxMessageSize;
          }
        });
        this._sctp = sctp;
      }

      return origSetRemoteDescription.apply(this, arguments);
    };
  }

  function shimSendThrowTypeError(window) {
    if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {
      return;
    }

    // Note: Although Firefox >= 57 has a native implementation, the maximum
    //       message size can be reset for all data channels at a later stage.
    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

    function wrapDcSend(dc, pc) {
      var origDataChannelSend = dc.send;
      dc.send = function () {
        var data = arguments[0];
        var length = data.length || data.size || data.byteLength;
        if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {
          throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');
        }
        return origDataChannelSend.apply(dc, arguments);
      };
    }
    var origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;
    window.RTCPeerConnection.prototype.createDataChannel = function () {
      var dataChannel = origCreateDataChannel.apply(this, arguments);
      wrapDcSend(dataChannel, this);
      return dataChannel;
    };
    utils.wrapPeerConnectionEvent(window, 'datachannel', function (e) {
      wrapDcSend(e.channel, e.target);
      return e;
    });
  }

  /* shims RTCConnectionState by pretending it is the same as iceConnectionState.
   * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12
   * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect
   * since DTLS failures would be hidden. See
   * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827
   * for the Firefox tracking bug.
   */
  function shimConnectionState(window) {
    if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {
      return;
    }
    var proto = window.RTCPeerConnection.prototype;
    Object.defineProperty(proto, 'connectionState', {
      get: function get() {
        return {
          completed: 'connected',
          checking: 'connecting'
        }[this.iceConnectionState] || this.iceConnectionState;
      },

      enumerable: true,
      configurable: true
    });
    Object.defineProperty(proto, 'onconnectionstatechange', {
      get: function get() {
        return this._onconnectionstatechange || null;
      },
      set: function set(cb) {
        if (this._onconnectionstatechange) {
          this.removeEventListener('connectionstatechange', this._onconnectionstatechange);
          delete this._onconnectionstatechange;
        }
        if (cb) {
          this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);
        }
      },

      enumerable: true,
      configurable: true
    });

    ['setLocalDescription', 'setRemoteDescription'].forEach(function (method) {
      var origMethod = proto[method];
      proto[method] = function () {
        if (!this._connectionstatechangepoly) {
          this._connectionstatechangepoly = function (e) {
            var pc = e.target;
            if (pc._lastConnectionState !== pc.connectionState) {
              pc._lastConnectionState = pc.connectionState;
              var newEvent = new Event('connectionstatechange', e);
              pc.dispatchEvent(newEvent);
            }
            return e;
          };
          this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);
        }
        return origMethod.apply(this, arguments);
      };
    });
  }

  function removeAllowExtmapMixed(window) {
    /* remove a=extmap-allow-mixed for Chrome < M71 */
    if (!window.RTCPeerConnection) {
      return;
    }
    var browserDetails = utils.detectBrowser(window);
    if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {
      return;
    }
    var nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function (desc) {
      if (desc && desc.sdp && desc.sdp.indexOf('\na=extmap-allow-mixed') !== -1) {
        desc.sdp = desc.sdp.split('\n').filter(function (line) {
          return line.trim() !== 'a=extmap-allow-mixed';
        }).join('\n');
      }
      return nativeSRD.apply(this, arguments);
    };
  }

  },{"./utils":15,"sdp":17}],7:[function(require,module,exports){
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

  var _getusermedia = require('./getusermedia');

  Object.defineProperty(exports, 'shimGetUserMedia', {
    enumerable: true,
    get: function get() {
      return _getusermedia.shimGetUserMedia;
    }
  });

  var _getdisplaymedia = require('./getdisplaymedia');

  Object.defineProperty(exports, 'shimGetDisplayMedia', {
    enumerable: true,
    get: function get() {
      return _getdisplaymedia.shimGetDisplayMedia;
    }
  });
  exports.shimPeerConnection = shimPeerConnection;
  exports.shimReplaceTrack = shimReplaceTrack;

  var _utils = require('../utils');

  var utils = _interopRequireWildcard(_utils);

  var _filtericeservers = require('./filtericeservers');

  var _rtcpeerconnectionShim = require('rtcpeerconnection-shim');

  var _rtcpeerconnectionShim2 = _interopRequireDefault(_rtcpeerconnectionShim);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function shimPeerConnection(window) {
    var browserDetails = utils.detectBrowser(window);

    if (window.RTCIceGatherer) {
      if (!window.RTCIceCandidate) {
        window.RTCIceCandidate = function (args) {
          return args;
        };
      }
      if (!window.RTCSessionDescription) {
        window.RTCSessionDescription = function (args) {
          return args;
        };
      }
      // this adds an additional event listener to MediaStrackTrack that signals
      // when a tracks enabled property was changed. Workaround for a bug in
      // addStream, see below. No longer required in 15025+
      if (browserDetails.version < 15025) {
        var origMSTEnabled = Object.getOwnPropertyDescriptor(window.MediaStreamTrack.prototype, 'enabled');
        Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {
          set: function set(value) {
            origMSTEnabled.set.call(this, value);
            var ev = new Event('enabled');
            ev.enabled = value;
            this.dispatchEvent(ev);
          }
        });
      }
    }

    // ORTC defines the DTMF sender a bit different.
    // https://github.com/w3c/ortc/issues/714
    if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get: function get() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = new window.RTCDtmfSender(this);
            } else if (this.track.kind === 'video') {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
    // Edge currently only implements the RTCDtmfSender, not the
    // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*
    if (window.RTCDtmfSender && !window.RTCDTMFSender) {
      window.RTCDTMFSender = window.RTCDtmfSender;
    }

    var RTCPeerConnectionShim = (0, _rtcpeerconnectionShim2.default)(window, browserDetails.version);
    window.RTCPeerConnection = function (config) {
      if (config && config.iceServers) {
        config.iceServers = (0, _filtericeservers.filterIceServers)(config.iceServers, browserDetails.version);
        utils.log('ICE servers after filtering:', config.iceServers);
      }
      return new RTCPeerConnectionShim(config);
    };
    window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;
  }

  function shimReplaceTrack(window) {
    // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
    if (window.RTCRtpSender && !('replaceTrack' in window.RTCRtpSender.prototype)) {
      window.RTCRtpSender.prototype.replaceTrack = window.RTCRtpSender.prototype.setTrack;
    }
  }

  },{"../utils":15,"./filtericeservers":8,"./getdisplaymedia":9,"./getusermedia":10,"rtcpeerconnection-shim":16}],8:[function(require,module,exports){
  /*
   *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.filterIceServers = filterIceServers;

  var _utils = require('../utils');

  var utils = _interopRequireWildcard(_utils);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  // Edge does not like
  // 1) stun: filtered after 14393 unless ?transport=udp is present
  // 2) turn: that does not have all of turn:host:port?transport=udp
  // 3) turn: with ipv6 addresses
  // 4) turn: occurring muliple times
  function filterIceServers(iceServers, edgeVersion) {
    var hasTurn = false;
    iceServers = JSON.parse(JSON.stringify(iceServers));
    return iceServers.filter(function (server) {
      if (server && (server.urls || server.url)) {
        var urls = server.urls || server.url;
        if (server.url && !server.urls) {
          utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
        }
        var isString = typeof urls === 'string';
        if (isString) {
          urls = [urls];
        }
        urls = urls.filter(function (url) {
          // filter STUN unconditionally.
          if (url.indexOf('stun:') === 0) {
            return false;
          }

          var validTurn = url.startsWith('turn') && !url.startsWith('turn:[') && url.includes('transport=udp');
          if (validTurn && !hasTurn) {
            hasTurn = true;
            return true;
          }
          return validTurn && !hasTurn;
        });

        delete server.url;
        server.urls = isString ? urls[0] : urls;
        return !!urls.length;
      }
    });
  }

  },{"../utils":15}],9:[function(require,module,exports){
  /*
   *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.shimGetDisplayMedia = shimGetDisplayMedia;
  function shimGetDisplayMedia(window) {
    if (!('getDisplayMedia' in window.navigator)) {
      return;
    }
    if (!window.navigator.mediaDevices) {
      return;
    }
    if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
      return;
    }
    window.navigator.mediaDevices.getDisplayMedia = window.navigator.getDisplayMedia.bind(window.navigator);
  }

  },{}],10:[function(require,module,exports){
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.shimGetUserMedia = shimGetUserMedia;
  function shimGetUserMedia(window) {
    var navigator = window && window.navigator;

    var shimError_ = function shimError_(e) {
      return {
        name: { PermissionDeniedError: 'NotAllowedError' }[e.name] || e.name,
        message: e.message,
        constraint: e.constraint,
        toString: function toString() {
          return this.name;
        }
      };
    };

    // getUserMedia error shim.
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function (c) {
      return origGetUserMedia(c).catch(function (e) {
        return Promise.reject(shimError_(e));
      });
    };
  }

  },{}],11:[function(require,module,exports){
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _getusermedia = require('./getusermedia');

  Object.defineProperty(exports, 'shimGetUserMedia', {
    enumerable: true,
    get: function get() {
      return _getusermedia.shimGetUserMedia;
    }
  });

  var _getdisplaymedia = require('./getdisplaymedia');

  Object.defineProperty(exports, 'shimGetDisplayMedia', {
    enumerable: true,
    get: function get() {
      return _getdisplaymedia.shimGetDisplayMedia;
    }
  });
  exports.shimOnTrack = shimOnTrack;
  exports.shimPeerConnection = shimPeerConnection;
  exports.shimSenderGetStats = shimSenderGetStats;
  exports.shimReceiverGetStats = shimReceiverGetStats;
  exports.shimRemoveStream = shimRemoveStream;
  exports.shimRTCDataChannel = shimRTCDataChannel;

  var _utils = require('../utils');

  var utils = _interopRequireWildcard(_utils);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function shimOnTrack(window) {
    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get: function get() {
          return { receiver: this.receiver };
        }
      });
    }
  }

  function shimPeerConnection(window) {
    var browserDetails = utils.detectBrowser(window);

    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
      return; // probably media.peerconnection.enabled=false in about:config
    }
    if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {
      // very basic support for old versions.
      window.RTCPeerConnection = window.mozRTCPeerConnection;
    }

    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      window.RTCPeerConnection.prototype[method] = function () {
        arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      };
    });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function () {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };

    var modernStatsTypes = {
      inboundrtp: 'inbound-rtp',
      outboundrtp: 'outbound-rtp',
      candidatepair: 'candidate-pair',
      localcandidate: 'local-candidate',
      remotecandidate: 'remote-candidate'
    };

    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function (selector, onSucc, onErr) {
      return nativeGetStats.apply(this, [selector || null]).then(function (stats) {
        if (browserDetails.version < 53 && !onSucc) {
          // Shim only promise getStats with spec-hyphens in type names
          // Leave callback version alone; misc old uses of forEach before Map
          try {
            stats.forEach(function (stat) {
              stat.type = modernStatsTypes[stat.type] || stat.type;
            });
          } catch (e) {
            if (e.name !== 'TypeError') {
              throw e;
            }
            // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
            stats.forEach(function (stat, i) {
              stats.set(i, Object.assign({}, stat, {
                type: modernStatsTypes[stat.type] || stat.type
              }));
            });
          }
        }
        return stats;
      }).then(onSucc, onErr);
    };
  }

  function shimSenderGetStats(window) {
    if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
      return;
    }
    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window.RTCPeerConnection.prototype.getSenders = function () {
        var _this = this;

        var senders = origGetSenders.apply(this, []);
        senders.forEach(function (sender) {
          return sender._pc = _this;
        });
        return senders;
      };
    }

    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window.RTCPeerConnection.prototype.addTrack = function () {
        var sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window.RTCRtpSender.prototype.getStats = function () {
      return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());
    };
  }

  function shimReceiverGetStats(window) {
    if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
      return;
    }
    var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window.RTCPeerConnection.prototype.getReceivers = function () {
        var _this2 = this;

        var receivers = origGetReceivers.apply(this, []);
        receivers.forEach(function (receiver) {
          return receiver._pc = _this2;
        });
        return receivers;
      };
    }
    utils.wrapPeerConnectionEvent(window, 'track', function (e) {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window.RTCRtpReceiver.prototype.getStats = function () {
      return this._pc.getStats(this.track);
    };
  }

  function shimRemoveStream(window) {
    if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {
      return;
    }
    window.RTCPeerConnection.prototype.removeStream = function (stream) {
      var _this3 = this;

      utils.deprecated('removeStream', 'removeTrack');
      this.getSenders().forEach(function (sender) {
        if (sender.track && stream.getTracks().includes(sender.track)) {
          _this3.removeTrack(sender);
        }
      });
    };
  }

  function shimRTCDataChannel(window) {
    // rename DataChannel to RTCDataChannel (native fix in FF60):
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
    if (window.DataChannel && !window.RTCDataChannel) {
      window.RTCDataChannel = window.DataChannel;
    }
  }

  },{"../utils":15,"./getdisplaymedia":12,"./getusermedia":13}],12:[function(require,module,exports){
  /*
   *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.shimGetDisplayMedia = shimGetDisplayMedia;
  function shimGetDisplayMedia(window, preferredMediaSource) {
    if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
      return;
    }
    if (!window.navigator.mediaDevices) {
      return;
    }
    window.navigator.mediaDevices.getDisplayMedia = function (constraints) {
      if (!(constraints && constraints.video)) {
        var err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');
        err.name = 'NotFoundError';
        // from https://heycam.github.io/webidl/#idl-DOMException-error-names
        err.code = 8;
        return Promise.reject(err);
      }
      if (constraints.video === true) {
        constraints.video = { mediaSource: preferredMediaSource };
      } else {
        constraints.video.mediaSource = preferredMediaSource;
      }
      return window.navigator.mediaDevices.getUserMedia(constraints);
    };
  }

  },{}],13:[function(require,module,exports){
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  exports.shimGetUserMedia = shimGetUserMedia;

  var _utils = require('../utils');

  var utils = _interopRequireWildcard(_utils);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function shimGetUserMedia(window) {
    var browserDetails = utils.detectBrowser(window);
    var navigator = window && window.navigator;
    var MediaStreamTrack = window && window.MediaStreamTrack;

    navigator.getUserMedia = function (constraints, onSuccess, onError) {
      // Replace Firefox 44+'s deprecation warning with unprefixed version.
      utils.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');
      navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
    };

    if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
      var remap = function remap(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };

      var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
      navigator.mediaDevices.getUserMedia = function (c) {
        if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object' && _typeof(c.audio) === 'object') {
          c = JSON.parse(JSON.stringify(c));
          remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
          remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
        }
        return nativeGetUserMedia(c);
      };

      if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
        var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
        MediaStreamTrack.prototype.getSettings = function () {
          var obj = nativeGetSettings.apply(this, arguments);
          remap(obj, 'mozAutoGainControl', 'autoGainControl');
          remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
          return obj;
        };
      }

      if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
        var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
        MediaStreamTrack.prototype.applyConstraints = function (c) {
          if (this.kind === 'audio' && (typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object') {
            c = JSON.parse(JSON.stringify(c));
            remap(c, 'autoGainControl', 'mozAutoGainControl');
            remap(c, 'noiseSuppression', 'mozNoiseSuppression');
          }
          return nativeApplyConstraints.apply(this, [c]);
        };
      }
    }
  }

  },{"../utils":15}],14:[function(require,module,exports){
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  exports.shimLocalStreamsAPI = shimLocalStreamsAPI;
  exports.shimRemoteStreamsAPI = shimRemoteStreamsAPI;
  exports.shimCallbacksAPI = shimCallbacksAPI;
  exports.shimGetUserMedia = shimGetUserMedia;
  exports.shimConstraints = shimConstraints;
  exports.shimRTCIceServerUrls = shimRTCIceServerUrls;
  exports.shimTrackEventTransceiver = shimTrackEventTransceiver;
  exports.shimCreateOfferLegacy = shimCreateOfferLegacy;

  var _utils = require('../utils');

  var utils = _interopRequireWildcard(_utils);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function shimLocalStreamsAPI(window) {
    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getLocalStreams = function () {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        return this._localStreams;
      };
    }
    if (!('addStream' in window.RTCPeerConnection.prototype)) {
      var _addTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addStream = function (stream) {
        var _this = this;

        if (!this._localStreams) {
          this._localStreams = [];
        }
        if (!this._localStreams.includes(stream)) {
          this._localStreams.push(stream);
        }
        stream.getTracks().forEach(function (track) {
          return _addTrack.call(_this, track, stream);
        });
      };

      window.RTCPeerConnection.prototype.addTrack = function (track, stream) {
        if (stream) {
          if (!this._localStreams) {
            this._localStreams = [stream];
          } else if (!this._localStreams.includes(stream)) {
            this._localStreams.push(stream);
          }
        }
        return _addTrack.call(this, track, stream);
      };
    }
    if (!('removeStream' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.removeStream = function (stream) {
        var _this2 = this;

        if (!this._localStreams) {
          this._localStreams = [];
        }
        var index = this._localStreams.indexOf(stream);
        if (index === -1) {
          return;
        }
        this._localStreams.splice(index, 1);
        var tracks = stream.getTracks();
        this.getSenders().forEach(function (sender) {
          if (tracks.includes(sender.track)) {
            _this2.removeTrack(sender);
          }
        });
      };
    }
  }

  function shimRemoteStreamsAPI(window) {
    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getRemoteStreams = function () {
        return this._remoteStreams ? this._remoteStreams : [];
      };
    }
    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
        get: function get() {
          return this._onaddstream;
        },
        set: function set(f) {
          var _this3 = this;

          if (this._onaddstream) {
            this.removeEventListener('addstream', this._onaddstream);
            this.removeEventListener('track', this._onaddstreampoly);
          }
          this.addEventListener('addstream', this._onaddstream = f);
          this.addEventListener('track', this._onaddstreampoly = function (e) {
            e.streams.forEach(function (stream) {
              if (!_this3._remoteStreams) {
                _this3._remoteStreams = [];
              }
              if (_this3._remoteStreams.includes(stream)) {
                return;
              }
              _this3._remoteStreams.push(stream);
              var event = new Event('addstream');
              event.stream = stream;
              _this3.dispatchEvent(event);
            });
          });
        }
      });
      var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription = function () {
        var pc = this;
        if (!this._onaddstreampoly) {
          this.addEventListener('track', this._onaddstreampoly = function (e) {
            e.streams.forEach(function (stream) {
              if (!pc._remoteStreams) {
                pc._remoteStreams = [];
              }
              if (pc._remoteStreams.indexOf(stream) >= 0) {
                return;
              }
              pc._remoteStreams.push(stream);
              var event = new Event('addstream');
              event.stream = stream;
              pc.dispatchEvent(event);
            });
          });
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
    }
  }

  function shimCallbacksAPI(window) {
    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    var prototype = window.RTCPeerConnection.prototype;
    var createOffer = prototype.createOffer;
    var createAnswer = prototype.createAnswer;
    var setLocalDescription = prototype.setLocalDescription;
    var setRemoteDescription = prototype.setRemoteDescription;
    var addIceCandidate = prototype.addIceCandidate;

    prototype.createOffer = function (successCallback, failureCallback) {
      var options = arguments.length >= 2 ? arguments[2] : arguments[0];
      var promise = createOffer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    prototype.createAnswer = function (successCallback, failureCallback) {
      var options = arguments.length >= 2 ? arguments[2] : arguments[0];
      var promise = createAnswer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    var withCallback = function withCallback(description, successCallback, failureCallback) {
      var promise = setLocalDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setLocalDescription = withCallback;

    withCallback = function withCallback(description, successCallback, failureCallback) {
      var promise = setRemoteDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setRemoteDescription = withCallback;

    withCallback = function withCallback(candidate, successCallback, failureCallback) {
      var promise = addIceCandidate.apply(this, [candidate]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.addIceCandidate = withCallback;
  }

  function shimGetUserMedia(window) {
    var navigator = window && window.navigator;

    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      // shim not needed in Safari 12.1
      var mediaDevices = navigator.mediaDevices;
      var _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
      navigator.mediaDevices.getUserMedia = function (constraints) {
        return _getUserMedia(shimConstraints(constraints));
      };
    }

    if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      navigator.getUserMedia = function (constraints, cb, errcb) {
        navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);
      }.bind(navigator);
    }
  }

  function shimConstraints(constraints) {
    if (constraints && constraints.video !== undefined) {
      return Object.assign({}, constraints, { video: utils.compactObject(constraints.video) });
    }

    return constraints;
  }

  function shimRTCIceServerUrls(window) {
    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
    var OrigPeerConnection = window.RTCPeerConnection;
    window.RTCPeerConnection = function (pcConfig, pcConstraints) {
      if (pcConfig && pcConfig.iceServers) {
        var newIceServers = [];
        for (var i = 0; i < pcConfig.iceServers.length; i++) {
          var server = pcConfig.iceServers[i];
          if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {
            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
            server = JSON.parse(JSON.stringify(server));
            server.urls = server.url;
            delete server.url;
            newIceServers.push(server);
          } else {
            newIceServers.push(pcConfig.iceServers[i]);
          }
        }
        pcConfig.iceServers = newIceServers;
      }
      return new OrigPeerConnection(pcConfig, pcConstraints);
    };
    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
    // wrap static methods. Currently just generateCertificate.
    if ('generateCertificate' in window.RTCPeerConnection) {
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function get() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }
  }

  function shimTrackEventTransceiver(window) {
    // Add event.transceiver member over deprecated event.receiver
    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && 'receiver' in window.RTCTrackEvent.prototype &&
    // can't check 'transceiver' in window.RTCTrackEvent.prototype, as it is
    // defined for some reason even when window.RTCTransceiver is not.
    !window.RTCTransceiver) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get: function get() {
          return { receiver: this.receiver };
        }
      });
    }
  }

  function shimCreateOfferLegacy(window) {
    var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
    window.RTCPeerConnection.prototype.createOffer = function (offerOptions) {
      if (offerOptions) {
        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
        }
        var audioTransceiver = this.getTransceivers().find(function (transceiver) {
          return transceiver.receiver.track.kind === 'audio';
        });
        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
          if (audioTransceiver.direction === 'sendrecv') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('sendonly');
            } else {
              audioTransceiver.direction = 'sendonly';
            }
          } else if (audioTransceiver.direction === 'recvonly') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('inactive');
            } else {
              audioTransceiver.direction = 'inactive';
            }
          }
        } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
          this.addTransceiver('audio');
        }

        if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
        }
        var videoTransceiver = this.getTransceivers().find(function (transceiver) {
          return transceiver.receiver.track.kind === 'video';
        });
        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
          if (videoTransceiver.direction === 'sendrecv') {
            if (videoTransceiver.setDirection) {
              videoTransceiver.setDirection('sendonly');
            } else {
              videoTransceiver.direction = 'sendonly';
            }
          } else if (videoTransceiver.direction === 'recvonly') {
            if (videoTransceiver.setDirection) {
              videoTransceiver.setDirection('inactive');
            } else {
              videoTransceiver.direction = 'inactive';
            }
          }
        } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
          this.addTransceiver('video');
        }
      }
      return origCreateOffer.apply(this, arguments);
    };
  }

  },{"../utils":15}],15:[function(require,module,exports){
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  exports.extractVersion = extractVersion;
  exports.wrapPeerConnectionEvent = wrapPeerConnectionEvent;
  exports.disableLog = disableLog;
  exports.disableWarnings = disableWarnings;
  exports.log = log;
  exports.deprecated = deprecated;
  exports.detectBrowser = detectBrowser;
  exports.compactObject = compactObject;
  exports.walkStats = walkStats;
  exports.filterStats = filterStats;

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  var logDisabled_ = true;
  var deprecationWarnings_ = true;

  /**
   * Extract browser version out of the provided user agent string.
   *
   * @param {!string} uastring userAgent string.
   * @param {!string} expr Regular expression used as match criteria.
   * @param {!number} pos position in the version string to be returned.
   * @return {!number} browser version.
   */
  function extractVersion(uastring, expr, pos) {
    var match = uastring.match(expr);
    return match && match.length >= pos && parseInt(match[pos], 10);
  }

  // Wraps the peerconnection event eventNameToWrap in a function
  // which returns the modified event object (or false to prevent
  // the event).
  function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
    if (!window.RTCPeerConnection) {
      return;
    }
    var proto = window.RTCPeerConnection.prototype;
    var nativeAddEventListener = proto.addEventListener;
    proto.addEventListener = function (nativeEventName, cb) {
      if (nativeEventName !== eventNameToWrap) {
        return nativeAddEventListener.apply(this, arguments);
      }
      var wrappedCallback = function wrappedCallback(e) {
        var modifiedEvent = wrapper(e);
        if (modifiedEvent) {
          cb(modifiedEvent);
        }
      };
      this._eventMap = this._eventMap || {};
      this._eventMap[cb] = wrappedCallback;
      return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
    };

    var nativeRemoveEventListener = proto.removeEventListener;
    proto.removeEventListener = function (nativeEventName, cb) {
      if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[cb]) {
        return nativeRemoveEventListener.apply(this, arguments);
      }
      var unwrappedCb = this._eventMap[cb];
      delete this._eventMap[cb];
      return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
    };

    Object.defineProperty(proto, 'on' + eventNameToWrap, {
      get: function get() {
        return this['_on' + eventNameToWrap];
      },
      set: function set(cb) {
        if (this['_on' + eventNameToWrap]) {
          this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);
          delete this['_on' + eventNameToWrap];
        }
        if (cb) {
          this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);
        }
      },

      enumerable: true,
      configurable: true
    });
  }

  function disableLog(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
    }
    logDisabled_ = bool;
    return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';
  }

  /**
   * Disable or enable deprecation warnings
   * @param {!boolean} bool set to true to disable warnings.
   */
  function disableWarnings(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
    }
    deprecationWarnings_ = !bool;
    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
  }

  function log() {
    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object') {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== 'undefined' && typeof console.log === 'function') {
        console.log.apply(console, arguments);
      }
    }
  }

  /**
   * Shows a deprecation warning suggesting the modern and spec-compatible API.
   */
  function deprecated(oldMethod, newMethod) {
    if (!deprecationWarnings_) {
      return;
    }
    console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');
  }

  /**
   * Browser detector.
   *
   * @return {object} result containing browser and version
   *     properties.
   */
  function detectBrowser(window) {
    var navigator = window.navigator;

    // Returned result object.

    var result = { browser: null, version: null };

    // Fail early if it's not a browser
    if (typeof window === 'undefined' || !window.navigator) {
      result.browser = 'Not a browser.';
      return result;
    }

    if (navigator.mozGetUserMedia) {
      // Firefox.
      result.browser = 'firefox';
      result.version = extractVersion(navigator.userAgent, /Firefox\/(\d+)\./, 1);
    } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection && !window.RTCIceGatherer) {
      // Chrome, Chromium, Webview, Opera.
      // Version matches Chrome/WebRTC version.
      // Chrome 74 removed webkitGetUserMedia on http as well so we need the
      // more complicated fallback to webkitRTCPeerConnection.
      result.browser = 'chrome';
      result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
    } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
      // Edge.
      result.browser = 'edge';
      result.version = extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);
    } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
      // Safari.
      result.browser = 'safari';
      result.version = extractVersion(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
    } else {
      // Default fallthrough: not supported.
      result.browser = 'Not a supported browser.';
      return result;
    }

    return result;
  }

  /**
   * Remove all empty objects and undefined values
   * from a nested object -- an enhanced and vanilla version
   * of Lodash's `compact`.
   */
  function compactObject(data) {
    if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
      return data;
    }

    return Object.keys(data).reduce(function (accumulator, key) {
      var isObject = _typeof(data[key]) === 'object';
      var value = isObject ? compactObject(data[key]) : data[key];
      var isEmptyObject = isObject && !Object.keys(value).length;
      if (value === undefined || isEmptyObject) {
        return accumulator;
      }

      return Object.assign(accumulator, _defineProperty({}, key, value));
    }, {});
  }

  /* iterates the stats graph recursively. */
  function walkStats(stats, base, resultSet) {
    if (!base || resultSet.has(base.id)) {
      return;
    }
    resultSet.set(base.id, base);
    Object.keys(base).forEach(function (name) {
      if (name.endsWith('Id')) {
        walkStats(stats, stats.get(base[name]), resultSet);
      } else if (name.endsWith('Ids')) {
        base[name].forEach(function (id) {
          walkStats(stats, stats.get(id), resultSet);
        });
      }
    });
  }

  /* filter getStats for a sender/receiver track. */
  function filterStats(result, track, outbound) {
    var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
    var filteredResult = new Map();
    if (track === null) {
      return filteredResult;
    }
    var trackStats = [];
    result.forEach(function (value) {
      if (value.type === 'track' && value.trackIdentifier === track.id) {
        trackStats.push(value);
      }
    });
    trackStats.forEach(function (trackStat) {
      result.forEach(function (stats) {
        if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
          walkStats(result, stats, filteredResult);
        }
      });
    });
    return filteredResult;
  }

  },{}],16:[function(require,module,exports){
  /*
   *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
   /* eslint-env node */
  'use strict';

  var SDPUtils = require('sdp');

  function fixStatsType(stat) {
    return {
      inboundrtp: 'inbound-rtp',
      outboundrtp: 'outbound-rtp',
      candidatepair: 'candidate-pair',
      localcandidate: 'local-candidate',
      remotecandidate: 'remote-candidate'
    }[stat.type] || stat.type;
  }

  function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
    var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

    // Map ICE parameters (ufrag, pwd) to SDP.
    sdp += SDPUtils.writeIceParameters(
        transceiver.iceGatherer.getLocalParameters());

    // Map DTLS parameters to SDP.
    sdp += SDPUtils.writeDtlsParameters(
        transceiver.dtlsTransport.getLocalParameters(),
        type === 'offer' ? 'actpass' : dtlsRole || 'active');

    sdp += 'a=mid:' + transceiver.mid + '\r\n';

    if (transceiver.rtpSender && transceiver.rtpReceiver) {
      sdp += 'a=sendrecv\r\n';
    } else if (transceiver.rtpSender) {
      sdp += 'a=sendonly\r\n';
    } else if (transceiver.rtpReceiver) {
      sdp += 'a=recvonly\r\n';
    } else {
      sdp += 'a=inactive\r\n';
    }

    if (transceiver.rtpSender) {
      var trackId = transceiver.rtpSender._initialTrackId ||
          transceiver.rtpSender.track.id;
      transceiver.rtpSender._initialTrackId = trackId;
      // spec.
      var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +
          trackId + '\r\n';
      sdp += 'a=' + msid;
      // for Chrome. Legacy should no longer be required.
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
          ' ' + msid;

      // RTX
      if (transceiver.sendEncodingParameters[0].rtx) {
        sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
            ' ' + msid;
        sdp += 'a=ssrc-group:FID ' +
            transceiver.sendEncodingParameters[0].ssrc + ' ' +
            transceiver.sendEncodingParameters[0].rtx.ssrc +
            '\r\n';
      }
    }
    // FIXME: this should be written by writeRtpDescription.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
    if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' cname:' + SDPUtils.localCName + '\r\n';
    }
    return sdp;
  }

  // Edge does not like
  // 1) stun: filtered after 14393 unless ?transport=udp is present
  // 2) turn: that does not have all of turn:host:port?transport=udp
  // 3) turn: with ipv6 addresses
  // 4) turn: occurring muliple times
  function filterIceServers(iceServers, edgeVersion) {
    var hasTurn = false;
    iceServers = JSON.parse(JSON.stringify(iceServers));
    return iceServers.filter(function(server) {
      if (server && (server.urls || server.url)) {
        var urls = server.urls || server.url;
        if (server.url && !server.urls) {
          console.warn('RTCIceServer.url is deprecated! Use urls instead.');
        }
        var isString = typeof urls === 'string';
        if (isString) {
          urls = [urls];
        }
        urls = urls.filter(function(url) {
          var validTurn = url.indexOf('turn:') === 0 &&
              url.indexOf('transport=udp') !== -1 &&
              url.indexOf('turn:[') === -1 &&
              !hasTurn;

          if (validTurn) {
            hasTurn = true;
            return true;
          }
          return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
              url.indexOf('?transport=udp') === -1;
        });

        delete server.url;
        server.urls = isString ? urls[0] : urls;
        return !!urls.length;
      }
    });
  }

  // Determines the intersection of local and remote capabilities.
  function getCommonCapabilities(localCapabilities, remoteCapabilities) {
    var commonCapabilities = {
      codecs: [],
      headerExtensions: [],
      fecMechanisms: []
    };

    var findCodecByPayloadType = function(pt, codecs) {
      pt = parseInt(pt, 10);
      for (var i = 0; i < codecs.length; i++) {
        if (codecs[i].payloadType === pt ||
            codecs[i].preferredPayloadType === pt) {
          return codecs[i];
        }
      }
    };

    var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {
      var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
      var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
      return lCodec && rCodec &&
          lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
    };

    localCapabilities.codecs.forEach(function(lCodec) {
      for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
        var rCodec = remoteCapabilities.codecs[i];
        if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
            lCodec.clockRate === rCodec.clockRate) {
          if (lCodec.name.toLowerCase() === 'rtx' &&
              lCodec.parameters && rCodec.parameters.apt) {
            // for RTX we need to find the local rtx that has a apt
            // which points to the same local codec as the remote one.
            if (!rtxCapabilityMatches(lCodec, rCodec,
                localCapabilities.codecs, remoteCapabilities.codecs)) {
              continue;
            }
          }
          rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
          // number of channels is the highest common number of channels
          rCodec.numChannels = Math.min(lCodec.numChannels,
              rCodec.numChannels);
          // push rCodec so we reply with offerer payload type
          commonCapabilities.codecs.push(rCodec);

          // determine common feedback mechanisms
          rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
            for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
              if (lCodec.rtcpFeedback[j].type === fb.type &&
                  lCodec.rtcpFeedback[j].parameter === fb.parameter) {
                return true;
              }
            }
            return false;
          });
          // FIXME: also need to determine .parameters
          //  see https://github.com/openpeer/ortc/issues/569
          break;
        }
      }
    });

    localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
      for (var i = 0; i < remoteCapabilities.headerExtensions.length;
           i++) {
        var rHeaderExtension = remoteCapabilities.headerExtensions[i];
        if (lHeaderExtension.uri === rHeaderExtension.uri) {
          commonCapabilities.headerExtensions.push(rHeaderExtension);
          break;
        }
      }
    });

    // FIXME: fecMechanisms
    return commonCapabilities;
  }

  // is action=setLocalDescription with type allowed in signalingState
  function isActionAllowedInSignalingState(action, type, signalingState) {
    return {
      offer: {
        setLocalDescription: ['stable', 'have-local-offer'],
        setRemoteDescription: ['stable', 'have-remote-offer']
      },
      answer: {
        setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
        setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']
      }
    }[type][action].indexOf(signalingState) !== -1;
  }

  function maybeAddCandidate(iceTransport, candidate) {
    // Edge's internal representation adds some fields therefore
    // not all fieldѕ are taken into account.
    var alreadyAdded = iceTransport.getRemoteCandidates()
        .find(function(remoteCandidate) {
          return candidate.foundation === remoteCandidate.foundation &&
              candidate.ip === remoteCandidate.ip &&
              candidate.port === remoteCandidate.port &&
              candidate.priority === remoteCandidate.priority &&
              candidate.protocol === remoteCandidate.protocol &&
              candidate.type === remoteCandidate.type;
        });
    if (!alreadyAdded) {
      iceTransport.addRemoteCandidate(candidate);
    }
    return !alreadyAdded;
  }


  function makeError(name, description) {
    var e = new Error(description);
    e.name = name;
    // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names
    e.code = {
      NotSupportedError: 9,
      InvalidStateError: 11,
      InvalidAccessError: 15,
      TypeError: undefined,
      OperationError: undefined
    }[name];
    return e;
  }

  module.exports = function(window, edgeVersion) {
    // https://w3c.github.io/mediacapture-main/#mediastream
    // Helper function to add the track to the stream and
    // dispatch the event ourselves.
    function addTrackToStreamAndFireEvent(track, stream) {
      stream.addTrack(track);
      stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',
          {track: track}));
    }

    function removeTrackFromStreamAndFireEvent(track, stream) {
      stream.removeTrack(track);
      stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',
          {track: track}));
    }

    function fireAddTrack(pc, track, receiver, streams) {
      var trackEvent = new Event('track');
      trackEvent.track = track;
      trackEvent.receiver = receiver;
      trackEvent.transceiver = {receiver: receiver};
      trackEvent.streams = streams;
      window.setTimeout(function() {
        pc._dispatchEvent('track', trackEvent);
      });
    }

    var RTCPeerConnection = function(config) {
      var pc = this;

      var _eventTarget = document.createDocumentFragment();
      ['addEventListener', 'removeEventListener', 'dispatchEvent']
          .forEach(function(method) {
            pc[method] = _eventTarget[method].bind(_eventTarget);
          });

      this.canTrickleIceCandidates = null;

      this.needNegotiation = false;

      this.localStreams = [];
      this.remoteStreams = [];

      this._localDescription = null;
      this._remoteDescription = null;

      this.signalingState = 'stable';
      this.iceConnectionState = 'new';
      this.connectionState = 'new';
      this.iceGatheringState = 'new';

      config = JSON.parse(JSON.stringify(config || {}));

      this.usingBundle = config.bundlePolicy === 'max-bundle';
      if (config.rtcpMuxPolicy === 'negotiate') {
        throw(makeError('NotSupportedError',
            'rtcpMuxPolicy \'negotiate\' is not supported'));
      } else if (!config.rtcpMuxPolicy) {
        config.rtcpMuxPolicy = 'require';
      }

      switch (config.iceTransportPolicy) {
        case 'all':
        case 'relay':
          break;
        default:
          config.iceTransportPolicy = 'all';
          break;
      }

      switch (config.bundlePolicy) {
        case 'balanced':
        case 'max-compat':
        case 'max-bundle':
          break;
        default:
          config.bundlePolicy = 'balanced';
          break;
      }

      config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);

      this._iceGatherers = [];
      if (config.iceCandidatePoolSize) {
        for (var i = config.iceCandidatePoolSize; i > 0; i--) {
          this._iceGatherers.push(new window.RTCIceGatherer({
            iceServers: config.iceServers,
            gatherPolicy: config.iceTransportPolicy
          }));
        }
      } else {
        config.iceCandidatePoolSize = 0;
      }

      this._config = config;

      // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
      // everything that is needed to describe a SDP m-line.
      this.transceivers = [];

      this._sdpSessionId = SDPUtils.generateSessionId();
      this._sdpSessionVersion = 0;

      this._dtlsRole = undefined; // role for a=setup to use in answers.

      this._isClosed = false;
    };

    Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {
      configurable: true,
      get: function() {
        return this._localDescription;
      }
    });
    Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {
      configurable: true,
      get: function() {
        return this._remoteDescription;
      }
    });

    // set up event handlers on prototype
    RTCPeerConnection.prototype.onicecandidate = null;
    RTCPeerConnection.prototype.onaddstream = null;
    RTCPeerConnection.prototype.ontrack = null;
    RTCPeerConnection.prototype.onremovestream = null;
    RTCPeerConnection.prototype.onsignalingstatechange = null;
    RTCPeerConnection.prototype.oniceconnectionstatechange = null;
    RTCPeerConnection.prototype.onconnectionstatechange = null;
    RTCPeerConnection.prototype.onicegatheringstatechange = null;
    RTCPeerConnection.prototype.onnegotiationneeded = null;
    RTCPeerConnection.prototype.ondatachannel = null;

    RTCPeerConnection.prototype._dispatchEvent = function(name, event) {
      if (this._isClosed) {
        return;
      }
      this.dispatchEvent(event);
      if (typeof this['on' + name] === 'function') {
        this['on' + name](event);
      }
    };

    RTCPeerConnection.prototype._emitGatheringStateChange = function() {
      var event = new Event('icegatheringstatechange');
      this._dispatchEvent('icegatheringstatechange', event);
    };

    RTCPeerConnection.prototype.getConfiguration = function() {
      return this._config;
    };

    RTCPeerConnection.prototype.getLocalStreams = function() {
      return this.localStreams;
    };

    RTCPeerConnection.prototype.getRemoteStreams = function() {
      return this.remoteStreams;
    };

    // internal helper to create a transceiver object.
    // (which is not yet the same as the WebRTC 1.0 transceiver)
    RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {
      var hasBundleTransport = this.transceivers.length > 0;
      var transceiver = {
        track: null,
        iceGatherer: null,
        iceTransport: null,
        dtlsTransport: null,
        localCapabilities: null,
        remoteCapabilities: null,
        rtpSender: null,
        rtpReceiver: null,
        kind: kind,
        mid: null,
        sendEncodingParameters: null,
        recvEncodingParameters: null,
        stream: null,
        associatedRemoteMediaStreams: [],
        wantReceive: true
      };
      if (this.usingBundle && hasBundleTransport) {
        transceiver.iceTransport = this.transceivers[0].iceTransport;
        transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
      } else {
        var transports = this._createIceAndDtlsTransports();
        transceiver.iceTransport = transports.iceTransport;
        transceiver.dtlsTransport = transports.dtlsTransport;
      }
      if (!doNotAdd) {
        this.transceivers.push(transceiver);
      }
      return transceiver;
    };

    RTCPeerConnection.prototype.addTrack = function(track, stream) {
      if (this._isClosed) {
        throw makeError('InvalidStateError',
            'Attempted to call addTrack on a closed peerconnection.');
      }

      var alreadyExists = this.transceivers.find(function(s) {
        return s.track === track;
      });

      if (alreadyExists) {
        throw makeError('InvalidAccessError', 'Track already exists.');
      }

      var transceiver;
      for (var i = 0; i < this.transceivers.length; i++) {
        if (!this.transceivers[i].track &&
            this.transceivers[i].kind === track.kind) {
          transceiver = this.transceivers[i];
        }
      }
      if (!transceiver) {
        transceiver = this._createTransceiver(track.kind);
      }

      this._maybeFireNegotiationNeeded();

      if (this.localStreams.indexOf(stream) === -1) {
        this.localStreams.push(stream);
      }

      transceiver.track = track;
      transceiver.stream = stream;
      transceiver.rtpSender = new window.RTCRtpSender(track,
          transceiver.dtlsTransport);
      return transceiver.rtpSender;
    };

    RTCPeerConnection.prototype.addStream = function(stream) {
      var pc = this;
      if (edgeVersion >= 15025) {
        stream.getTracks().forEach(function(track) {
          pc.addTrack(track, stream);
        });
      } else {
        // Clone is necessary for local demos mostly, attaching directly
        // to two different senders does not work (build 10547).
        // Fixed in 15025 (or earlier)
        var clonedStream = stream.clone();
        stream.getTracks().forEach(function(track, idx) {
          var clonedTrack = clonedStream.getTracks()[idx];
          track.addEventListener('enabled', function(event) {
            clonedTrack.enabled = event.enabled;
          });
        });
        clonedStream.getTracks().forEach(function(track) {
          pc.addTrack(track, clonedStream);
        });
      }
    };

    RTCPeerConnection.prototype.removeTrack = function(sender) {
      if (this._isClosed) {
        throw makeError('InvalidStateError',
            'Attempted to call removeTrack on a closed peerconnection.');
      }

      if (!(sender instanceof window.RTCRtpSender)) {
        throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +
            'does not implement interface RTCRtpSender.');
      }

      var transceiver = this.transceivers.find(function(t) {
        return t.rtpSender === sender;
      });

      if (!transceiver) {
        throw makeError('InvalidAccessError',
            'Sender was not created by this connection.');
      }
      var stream = transceiver.stream;

      transceiver.rtpSender.stop();
      transceiver.rtpSender = null;
      transceiver.track = null;
      transceiver.stream = null;

      // remove the stream from the set of local streams
      var localStreams = this.transceivers.map(function(t) {
        return t.stream;
      });
      if (localStreams.indexOf(stream) === -1 &&
          this.localStreams.indexOf(stream) > -1) {
        this.localStreams.splice(this.localStreams.indexOf(stream), 1);
      }

      this._maybeFireNegotiationNeeded();
    };

    RTCPeerConnection.prototype.removeStream = function(stream) {
      var pc = this;
      stream.getTracks().forEach(function(track) {
        var sender = pc.getSenders().find(function(s) {
          return s.track === track;
        });
        if (sender) {
          pc.removeTrack(sender);
        }
      });
    };

    RTCPeerConnection.prototype.getSenders = function() {
      return this.transceivers.filter(function(transceiver) {
        return !!transceiver.rtpSender;
      })
      .map(function(transceiver) {
        return transceiver.rtpSender;
      });
    };

    RTCPeerConnection.prototype.getReceivers = function() {
      return this.transceivers.filter(function(transceiver) {
        return !!transceiver.rtpReceiver;
      })
      .map(function(transceiver) {
        return transceiver.rtpReceiver;
      });
    };


    RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,
        usingBundle) {
      var pc = this;
      if (usingBundle && sdpMLineIndex > 0) {
        return this.transceivers[0].iceGatherer;
      } else if (this._iceGatherers.length) {
        return this._iceGatherers.shift();
      }
      var iceGatherer = new window.RTCIceGatherer({
        iceServers: this._config.iceServers,
        gatherPolicy: this._config.iceTransportPolicy
      });
      Object.defineProperty(iceGatherer, 'state',
          {value: 'new', writable: true}
      );

      this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
      this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {
        var end = !event.candidate || Object.keys(event.candidate).length === 0;
        // polyfill since RTCIceGatherer.state is not implemented in
        // Edge 10547 yet.
        iceGatherer.state = end ? 'completed' : 'gathering';
        if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {
          pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
        }
      };
      iceGatherer.addEventListener('localcandidate',
        this.transceivers[sdpMLineIndex].bufferCandidates);
      return iceGatherer;
    };

    // start gathering from an RTCIceGatherer.
    RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {
      var pc = this;
      var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
      if (iceGatherer.onlocalcandidate) {
        return;
      }
      var bufferedCandidateEvents =
        this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
      this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
      iceGatherer.removeEventListener('localcandidate',
        this.transceivers[sdpMLineIndex].bufferCandidates);
      iceGatherer.onlocalcandidate = function(evt) {
        if (pc.usingBundle && sdpMLineIndex > 0) {
          // if we know that we use bundle we can drop candidates with
          // ѕdpMLineIndex > 0. If we don't do this then our state gets
          // confused since we dispose the extra ice gatherer.
          return;
        }
        var event = new Event('icecandidate');
        event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

        var cand = evt.candidate;
        // Edge emits an empty object for RTCIceCandidateComplete‥
        var end = !cand || Object.keys(cand).length === 0;
        if (end) {
          // polyfill since RTCIceGatherer.state is not implemented in
          // Edge 10547 yet.
          if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
            iceGatherer.state = 'completed';
          }
        } else {
          if (iceGatherer.state === 'new') {
            iceGatherer.state = 'gathering';
          }
          // RTCIceCandidate doesn't have a component, needs to be added
          cand.component = 1;
          // also the usernameFragment. TODO: update SDP to take both variants.
          cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;

          var serializedCandidate = SDPUtils.writeCandidate(cand);
          event.candidate = Object.assign(event.candidate,
              SDPUtils.parseCandidate(serializedCandidate));

          event.candidate.candidate = serializedCandidate;
          event.candidate.toJSON = function() {
            return {
              candidate: event.candidate.candidate,
              sdpMid: event.candidate.sdpMid,
              sdpMLineIndex: event.candidate.sdpMLineIndex,
              usernameFragment: event.candidate.usernameFragment
            };
          };
        }

        // update local description.
        var sections = SDPUtils.getMediaSections(pc._localDescription.sdp);
        if (!end) {
          sections[event.candidate.sdpMLineIndex] +=
              'a=' + event.candidate.candidate + '\r\n';
        } else {
          sections[event.candidate.sdpMLineIndex] +=
              'a=end-of-candidates\r\n';
        }
        pc._localDescription.sdp =
            SDPUtils.getDescription(pc._localDescription.sdp) +
            sections.join('');
        var complete = pc.transceivers.every(function(transceiver) {
          return transceiver.iceGatherer &&
              transceiver.iceGatherer.state === 'completed';
        });

        if (pc.iceGatheringState !== 'gathering') {
          pc.iceGatheringState = 'gathering';
          pc._emitGatheringStateChange();
        }

        // Emit candidate. Also emit null candidate when all gatherers are
        // complete.
        if (!end) {
          pc._dispatchEvent('icecandidate', event);
        }
        if (complete) {
          pc._dispatchEvent('icecandidate', new Event('icecandidate'));
          pc.iceGatheringState = 'complete';
          pc._emitGatheringStateChange();
        }
      };

      // emit already gathered candidates.
      window.setTimeout(function() {
        bufferedCandidateEvents.forEach(function(e) {
          iceGatherer.onlocalcandidate(e);
        });
      }, 0);
    };

    // Create ICE transport and DTLS transport.
    RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {
      var pc = this;
      var iceTransport = new window.RTCIceTransport(null);
      iceTransport.onicestatechange = function() {
        pc._updateIceConnectionState();
        pc._updateConnectionState();
      };

      var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
      dtlsTransport.ondtlsstatechange = function() {
        pc._updateConnectionState();
      };
      dtlsTransport.onerror = function() {
        // onerror does not set state to failed by itself.
        Object.defineProperty(dtlsTransport, 'state',
            {value: 'failed', writable: true});
        pc._updateConnectionState();
      };

      return {
        iceTransport: iceTransport,
        dtlsTransport: dtlsTransport
      };
    };

    // Destroy ICE gatherer, ICE transport and DTLS transport.
    // Without triggering the callbacks.
    RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(
        sdpMLineIndex) {
      var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
      if (iceGatherer) {
        delete iceGatherer.onlocalcandidate;
        delete this.transceivers[sdpMLineIndex].iceGatherer;
      }
      var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
      if (iceTransport) {
        delete iceTransport.onicestatechange;
        delete this.transceivers[sdpMLineIndex].iceTransport;
      }
      var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
      if (dtlsTransport) {
        delete dtlsTransport.ondtlsstatechange;
        delete dtlsTransport.onerror;
        delete this.transceivers[sdpMLineIndex].dtlsTransport;
      }
    };

    // Start the RTP Sender and Receiver for a transceiver.
    RTCPeerConnection.prototype._transceive = function(transceiver,
        send, recv) {
      var params = getCommonCapabilities(transceiver.localCapabilities,
          transceiver.remoteCapabilities);
      if (send && transceiver.rtpSender) {
        params.encodings = transceiver.sendEncodingParameters;
        params.rtcp = {
          cname: SDPUtils.localCName,
          compound: transceiver.rtcpParameters.compound
        };
        if (transceiver.recvEncodingParameters.length) {
          params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
        }
        transceiver.rtpSender.send(params);
      }
      if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
        // remove RTX field in Edge 14942
        if (transceiver.kind === 'video'
            && transceiver.recvEncodingParameters
            && edgeVersion < 15019) {
          transceiver.recvEncodingParameters.forEach(function(p) {
            delete p.rtx;
          });
        }
        if (transceiver.recvEncodingParameters.length) {
          params.encodings = transceiver.recvEncodingParameters;
        } else {
          params.encodings = [{}];
        }
        params.rtcp = {
          compound: transceiver.rtcpParameters.compound
        };
        if (transceiver.rtcpParameters.cname) {
          params.rtcp.cname = transceiver.rtcpParameters.cname;
        }
        if (transceiver.sendEncodingParameters.length) {
          params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
        }
        transceiver.rtpReceiver.receive(params);
      }
    };

    RTCPeerConnection.prototype.setLocalDescription = function(description) {
      var pc = this;

      // Note: pranswer is not supported.
      if (['offer', 'answer'].indexOf(description.type) === -1) {
        return Promise.reject(makeError('TypeError',
            'Unsupported type "' + description.type + '"'));
      }

      if (!isActionAllowedInSignalingState('setLocalDescription',
          description.type, pc.signalingState) || pc._isClosed) {
        return Promise.reject(makeError('InvalidStateError',
            'Can not set local ' + description.type +
            ' in state ' + pc.signalingState));
      }

      var sections;
      var sessionpart;
      if (description.type === 'offer') {
        // VERY limited support for SDP munging. Limited to:
        // * changing the order of codecs
        sections = SDPUtils.splitSections(description.sdp);
        sessionpart = sections.shift();
        sections.forEach(function(mediaSection, sdpMLineIndex) {
          var caps = SDPUtils.parseRtpParameters(mediaSection);
          pc.transceivers[sdpMLineIndex].localCapabilities = caps;
        });

        pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
          pc._gather(transceiver.mid, sdpMLineIndex);
        });
      } else if (description.type === 'answer') {
        sections = SDPUtils.splitSections(pc._remoteDescription.sdp);
        sessionpart = sections.shift();
        var isIceLite = SDPUtils.matchPrefix(sessionpart,
            'a=ice-lite').length > 0;
        sections.forEach(function(mediaSection, sdpMLineIndex) {
          var transceiver = pc.transceivers[sdpMLineIndex];
          var iceGatherer = transceiver.iceGatherer;
          var iceTransport = transceiver.iceTransport;
          var dtlsTransport = transceiver.dtlsTransport;
          var localCapabilities = transceiver.localCapabilities;
          var remoteCapabilities = transceiver.remoteCapabilities;

          // treat bundle-only as not-rejected.
          var rejected = SDPUtils.isRejected(mediaSection) &&
              SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;

          if (!rejected && !transceiver.rejected) {
            var remoteIceParameters = SDPUtils.getIceParameters(
                mediaSection, sessionpart);
            var remoteDtlsParameters = SDPUtils.getDtlsParameters(
                mediaSection, sessionpart);
            if (isIceLite) {
              remoteDtlsParameters.role = 'server';
            }

            if (!pc.usingBundle || sdpMLineIndex === 0) {
              pc._gather(transceiver.mid, sdpMLineIndex);
              if (iceTransport.state === 'new') {
                iceTransport.start(iceGatherer, remoteIceParameters,
                    isIceLite ? 'controlling' : 'controlled');
              }
              if (dtlsTransport.state === 'new') {
                dtlsTransport.start(remoteDtlsParameters);
              }
            }

            // Calculate intersection of capabilities.
            var params = getCommonCapabilities(localCapabilities,
                remoteCapabilities);

            // Start the RTCRtpSender. The RTCRtpReceiver for this
            // transceiver has already been started in setRemoteDescription.
            pc._transceive(transceiver,
                params.codecs.length > 0,
                false);
          }
        });
      }

      pc._localDescription = {
        type: description.type,
        sdp: description.sdp
      };
      if (description.type === 'offer') {
        pc._updateSignalingState('have-local-offer');
      } else {
        pc._updateSignalingState('stable');
      }

      return Promise.resolve();
    };

    RTCPeerConnection.prototype.setRemoteDescription = function(description) {
      var pc = this;

      // Note: pranswer is not supported.
      if (['offer', 'answer'].indexOf(description.type) === -1) {
        return Promise.reject(makeError('TypeError',
            'Unsupported type "' + description.type + '"'));
      }

      if (!isActionAllowedInSignalingState('setRemoteDescription',
          description.type, pc.signalingState) || pc._isClosed) {
        return Promise.reject(makeError('InvalidStateError',
            'Can not set remote ' + description.type +
            ' in state ' + pc.signalingState));
      }

      var streams = {};
      pc.remoteStreams.forEach(function(stream) {
        streams[stream.id] = stream;
      });
      var receiverList = [];
      var sections = SDPUtils.splitSections(description.sdp);
      var sessionpart = sections.shift();
      var isIceLite = SDPUtils.matchPrefix(sessionpart,
          'a=ice-lite').length > 0;
      var usingBundle = SDPUtils.matchPrefix(sessionpart,
          'a=group:BUNDLE ').length > 0;
      pc.usingBundle = usingBundle;
      var iceOptions = SDPUtils.matchPrefix(sessionpart,
          'a=ice-options:')[0];
      if (iceOptions) {
        pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')
            .indexOf('trickle') >= 0;
      } else {
        pc.canTrickleIceCandidates = false;
      }

      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var lines = SDPUtils.splitLines(mediaSection);
        var kind = SDPUtils.getKind(mediaSection);
        // treat bundle-only as not-rejected.
        var rejected = SDPUtils.isRejected(mediaSection) &&
            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
        var protocol = lines[0].substr(2).split(' ')[2];

        var direction = SDPUtils.getDirection(mediaSection, sessionpart);
        var remoteMsid = SDPUtils.parseMsid(mediaSection);

        var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();

        // Reject datachannels which are not implemented yet.
        if (rejected || (kind === 'application' && (protocol === 'DTLS/SCTP' ||
            protocol === 'UDP/DTLS/SCTP'))) {
          // TODO: this is dangerous in the case where a non-rejected m-line
          //     becomes rejected.
          pc.transceivers[sdpMLineIndex] = {
            mid: mid,
            kind: kind,
            protocol: protocol,
            rejected: true
          };
          return;
        }

        if (!rejected && pc.transceivers[sdpMLineIndex] &&
            pc.transceivers[sdpMLineIndex].rejected) {
          // recycle a rejected transceiver.
          pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
        }

        var transceiver;
        var iceGatherer;
        var iceTransport;
        var dtlsTransport;
        var rtpReceiver;
        var sendEncodingParameters;
        var recvEncodingParameters;
        var localCapabilities;

        var track;
        // FIXME: ensure the mediaSection has rtcp-mux set.
        var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
        var remoteIceParameters;
        var remoteDtlsParameters;
        if (!rejected) {
          remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
              sessionpart);
          remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
              sessionpart);
          remoteDtlsParameters.role = 'client';
        }
        recvEncodingParameters =
            SDPUtils.parseRtpEncodingParameters(mediaSection);

        var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);

        var isComplete = SDPUtils.matchPrefix(mediaSection,
            'a=end-of-candidates', sessionpart).length > 0;
        var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
            .map(function(cand) {
              return SDPUtils.parseCandidate(cand);
            })
            .filter(function(cand) {
              return cand.component === 1;
            });

        // Check if we can use BUNDLE and dispose transports.
        if ((description.type === 'offer' || description.type === 'answer') &&
            !rejected && usingBundle && sdpMLineIndex > 0 &&
            pc.transceivers[sdpMLineIndex]) {
          pc._disposeIceAndDtlsTransports(sdpMLineIndex);
          pc.transceivers[sdpMLineIndex].iceGatherer =
              pc.transceivers[0].iceGatherer;
          pc.transceivers[sdpMLineIndex].iceTransport =
              pc.transceivers[0].iceTransport;
          pc.transceivers[sdpMLineIndex].dtlsTransport =
              pc.transceivers[0].dtlsTransport;
          if (pc.transceivers[sdpMLineIndex].rtpSender) {
            pc.transceivers[sdpMLineIndex].rtpSender.setTransport(
                pc.transceivers[0].dtlsTransport);
          }
          if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
            pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(
                pc.transceivers[0].dtlsTransport);
          }
        }
        if (description.type === 'offer' && !rejected) {
          transceiver = pc.transceivers[sdpMLineIndex] ||
              pc._createTransceiver(kind);
          transceiver.mid = mid;

          if (!transceiver.iceGatherer) {
            transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
                usingBundle);
          }

          if (cands.length && transceiver.iceTransport.state === 'new') {
            if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
              transceiver.iceTransport.setRemoteCandidates(cands);
            } else {
              cands.forEach(function(candidate) {
                maybeAddCandidate(transceiver.iceTransport, candidate);
              });
            }
          }

          localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

          // filter RTX until additional stuff needed for RTX is implemented
          // in adapter.js
          if (edgeVersion < 15019) {
            localCapabilities.codecs = localCapabilities.codecs.filter(
                function(codec) {
                  return codec.name !== 'rtx';
                });
          }

          sendEncodingParameters = transceiver.sendEncodingParameters || [{
            ssrc: (2 * sdpMLineIndex + 2) * 1001
          }];

          // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
          var isNewTrack = false;
          if (direction === 'sendrecv' || direction === 'sendonly') {
            isNewTrack = !transceiver.rtpReceiver;
            rtpReceiver = transceiver.rtpReceiver ||
                new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);

            if (isNewTrack) {
              var stream;
              track = rtpReceiver.track;
              // FIXME: does not work with Plan B.
              if (remoteMsid && remoteMsid.stream === '-') {
                // no-op. a stream id of '-' means: no associated stream.
              } else if (remoteMsid) {
                if (!streams[remoteMsid.stream]) {
                  streams[remoteMsid.stream] = new window.MediaStream();
                  Object.defineProperty(streams[remoteMsid.stream], 'id', {
                    get: function() {
                      return remoteMsid.stream;
                    }
                  });
                }
                Object.defineProperty(track, 'id', {
                  get: function() {
                    return remoteMsid.track;
                  }
                });
                stream = streams[remoteMsid.stream];
              } else {
                if (!streams.default) {
                  streams.default = new window.MediaStream();
                }
                stream = streams.default;
              }
              if (stream) {
                addTrackToStreamAndFireEvent(track, stream);
                transceiver.associatedRemoteMediaStreams.push(stream);
              }
              receiverList.push([track, rtpReceiver, stream]);
            }
          } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
            transceiver.associatedRemoteMediaStreams.forEach(function(s) {
              var nativeTrack = s.getTracks().find(function(t) {
                return t.id === transceiver.rtpReceiver.track.id;
              });
              if (nativeTrack) {
                removeTrackFromStreamAndFireEvent(nativeTrack, s);
              }
            });
            transceiver.associatedRemoteMediaStreams = [];
          }

          transceiver.localCapabilities = localCapabilities;
          transceiver.remoteCapabilities = remoteCapabilities;
          transceiver.rtpReceiver = rtpReceiver;
          transceiver.rtcpParameters = rtcpParameters;
          transceiver.sendEncodingParameters = sendEncodingParameters;
          transceiver.recvEncodingParameters = recvEncodingParameters;

          // Start the RTCRtpReceiver now. The RTPSender is started in
          // setLocalDescription.
          pc._transceive(pc.transceivers[sdpMLineIndex],
              false,
              isNewTrack);
        } else if (description.type === 'answer' && !rejected) {
          transceiver = pc.transceivers[sdpMLineIndex];
          iceGatherer = transceiver.iceGatherer;
          iceTransport = transceiver.iceTransport;
          dtlsTransport = transceiver.dtlsTransport;
          rtpReceiver = transceiver.rtpReceiver;
          sendEncodingParameters = transceiver.sendEncodingParameters;
          localCapabilities = transceiver.localCapabilities;

          pc.transceivers[sdpMLineIndex].recvEncodingParameters =
              recvEncodingParameters;
          pc.transceivers[sdpMLineIndex].remoteCapabilities =
              remoteCapabilities;
          pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

          if (cands.length && iceTransport.state === 'new') {
            if ((isIceLite || isComplete) &&
                (!usingBundle || sdpMLineIndex === 0)) {
              iceTransport.setRemoteCandidates(cands);
            } else {
              cands.forEach(function(candidate) {
                maybeAddCandidate(transceiver.iceTransport, candidate);
              });
            }
          }

          if (!usingBundle || sdpMLineIndex === 0) {
            if (iceTransport.state === 'new') {
              iceTransport.start(iceGatherer, remoteIceParameters,
                  'controlling');
            }
            if (dtlsTransport.state === 'new') {
              dtlsTransport.start(remoteDtlsParameters);
            }
          }

          // If the offer contained RTX but the answer did not,
          // remove RTX from sendEncodingParameters.
          var commonCapabilities = getCommonCapabilities(
            transceiver.localCapabilities,
            transceiver.remoteCapabilities);

          var hasRtx = commonCapabilities.codecs.filter(function(c) {
            return c.name.toLowerCase() === 'rtx';
          }).length;
          if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
            delete transceiver.sendEncodingParameters[0].rtx;
          }

          pc._transceive(transceiver,
              direction === 'sendrecv' || direction === 'recvonly',
              direction === 'sendrecv' || direction === 'sendonly');

          // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
          if (rtpReceiver &&
              (direction === 'sendrecv' || direction === 'sendonly')) {
            track = rtpReceiver.track;
            if (remoteMsid) {
              if (!streams[remoteMsid.stream]) {
                streams[remoteMsid.stream] = new window.MediaStream();
              }
              addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
              receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
            } else {
              if (!streams.default) {
                streams.default = new window.MediaStream();
              }
              addTrackToStreamAndFireEvent(track, streams.default);
              receiverList.push([track, rtpReceiver, streams.default]);
            }
          } else {
            // FIXME: actually the receiver should be created later.
            delete transceiver.rtpReceiver;
          }
        }
      });

      if (pc._dtlsRole === undefined) {
        pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
      }

      pc._remoteDescription = {
        type: description.type,
        sdp: description.sdp
      };
      if (description.type === 'offer') {
        pc._updateSignalingState('have-remote-offer');
      } else {
        pc._updateSignalingState('stable');
      }
      Object.keys(streams).forEach(function(sid) {
        var stream = streams[sid];
        if (stream.getTracks().length) {
          if (pc.remoteStreams.indexOf(stream) === -1) {
            pc.remoteStreams.push(stream);
            var event = new Event('addstream');
            event.stream = stream;
            window.setTimeout(function() {
              pc._dispatchEvent('addstream', event);
            });
          }

          receiverList.forEach(function(item) {
            var track = item[0];
            var receiver = item[1];
            if (stream.id !== item[2].id) {
              return;
            }
            fireAddTrack(pc, track, receiver, [stream]);
          });
        }
      });
      receiverList.forEach(function(item) {
        if (item[2]) {
          return;
        }
        fireAddTrack(pc, item[0], item[1], []);
      });

      // check whether addIceCandidate({}) was called within four seconds after
      // setRemoteDescription.
      window.setTimeout(function() {
        if (!(pc && pc.transceivers)) {
          return;
        }
        pc.transceivers.forEach(function(transceiver) {
          if (transceiver.iceTransport &&
              transceiver.iceTransport.state === 'new' &&
              transceiver.iceTransport.getRemoteCandidates().length > 0) {
            console.warn('Timeout for addRemoteCandidate. Consider sending ' +
                'an end-of-candidates notification');
            transceiver.iceTransport.addRemoteCandidate({});
          }
        });
      }, 4000);

      return Promise.resolve();
    };

    RTCPeerConnection.prototype.close = function() {
      this.transceivers.forEach(function(transceiver) {
        /* not yet
        if (transceiver.iceGatherer) {
          transceiver.iceGatherer.close();
        }
        */
        if (transceiver.iceTransport) {
          transceiver.iceTransport.stop();
        }
        if (transceiver.dtlsTransport) {
          transceiver.dtlsTransport.stop();
        }
        if (transceiver.rtpSender) {
          transceiver.rtpSender.stop();
        }
        if (transceiver.rtpReceiver) {
          transceiver.rtpReceiver.stop();
        }
      });
      // FIXME: clean up tracks, local streams, remote streams, etc
      this._isClosed = true;
      this._updateSignalingState('closed');
    };

    // Update the signaling state.
    RTCPeerConnection.prototype._updateSignalingState = function(newState) {
      this.signalingState = newState;
      var event = new Event('signalingstatechange');
      this._dispatchEvent('signalingstatechange', event);
    };

    // Determine whether to fire the negotiationneeded event.
    RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
      var pc = this;
      if (this.signalingState !== 'stable' || this.needNegotiation === true) {
        return;
      }
      this.needNegotiation = true;
      window.setTimeout(function() {
        if (pc.needNegotiation) {
          pc.needNegotiation = false;
          var event = new Event('negotiationneeded');
          pc._dispatchEvent('negotiationneeded', event);
        }
      }, 0);
    };

    // Update the ice connection state.
    RTCPeerConnection.prototype._updateIceConnectionState = function() {
      var newState;
      var states = {
        'new': 0,
        closed: 0,
        checking: 0,
        connected: 0,
        completed: 0,
        disconnected: 0,
        failed: 0
      };
      this.transceivers.forEach(function(transceiver) {
        if (transceiver.iceTransport && !transceiver.rejected) {
          states[transceiver.iceTransport.state]++;
        }
      });

      newState = 'new';
      if (states.failed > 0) {
        newState = 'failed';
      } else if (states.checking > 0) {
        newState = 'checking';
      } else if (states.disconnected > 0) {
        newState = 'disconnected';
      } else if (states.new > 0) {
        newState = 'new';
      } else if (states.connected > 0) {
        newState = 'connected';
      } else if (states.completed > 0) {
        newState = 'completed';
      }

      if (newState !== this.iceConnectionState) {
        this.iceConnectionState = newState;
        var event = new Event('iceconnectionstatechange');
        this._dispatchEvent('iceconnectionstatechange', event);
      }
    };

    // Update the connection state.
    RTCPeerConnection.prototype._updateConnectionState = function() {
      var newState;
      var states = {
        'new': 0,
        closed: 0,
        connecting: 0,
        connected: 0,
        completed: 0,
        disconnected: 0,
        failed: 0
      };
      this.transceivers.forEach(function(transceiver) {
        if (transceiver.iceTransport && transceiver.dtlsTransport &&
            !transceiver.rejected) {
          states[transceiver.iceTransport.state]++;
          states[transceiver.dtlsTransport.state]++;
        }
      });
      // ICETransport.completed and connected are the same for this purpose.
      states.connected += states.completed;

      newState = 'new';
      if (states.failed > 0) {
        newState = 'failed';
      } else if (states.connecting > 0) {
        newState = 'connecting';
      } else if (states.disconnected > 0) {
        newState = 'disconnected';
      } else if (states.new > 0) {
        newState = 'new';
      } else if (states.connected > 0) {
        newState = 'connected';
      }

      if (newState !== this.connectionState) {
        this.connectionState = newState;
        var event = new Event('connectionstatechange');
        this._dispatchEvent('connectionstatechange', event);
      }
    };

    RTCPeerConnection.prototype.createOffer = function() {
      var pc = this;

      if (pc._isClosed) {
        return Promise.reject(makeError('InvalidStateError',
            'Can not call createOffer after close'));
      }

      var numAudioTracks = pc.transceivers.filter(function(t) {
        return t.kind === 'audio';
      }).length;
      var numVideoTracks = pc.transceivers.filter(function(t) {
        return t.kind === 'video';
      }).length;

      // Determine number of audio and video tracks we need to send/recv.
      var offerOptions = arguments[0];
      if (offerOptions) {
        // Reject Chrome legacy constraints.
        if (offerOptions.mandatory || offerOptions.optional) {
          throw new TypeError(
              'Legacy mandatory/optional constraints not supported.');
        }
        if (offerOptions.offerToReceiveAudio !== undefined) {
          if (offerOptions.offerToReceiveAudio === true) {
            numAudioTracks = 1;
          } else if (offerOptions.offerToReceiveAudio === false) {
            numAudioTracks = 0;
          } else {
            numAudioTracks = offerOptions.offerToReceiveAudio;
          }
        }
        if (offerOptions.offerToReceiveVideo !== undefined) {
          if (offerOptions.offerToReceiveVideo === true) {
            numVideoTracks = 1;
          } else if (offerOptions.offerToReceiveVideo === false) {
            numVideoTracks = 0;
          } else {
            numVideoTracks = offerOptions.offerToReceiveVideo;
          }
        }
      }

      pc.transceivers.forEach(function(transceiver) {
        if (transceiver.kind === 'audio') {
          numAudioTracks--;
          if (numAudioTracks < 0) {
            transceiver.wantReceive = false;
          }
        } else if (transceiver.kind === 'video') {
          numVideoTracks--;
          if (numVideoTracks < 0) {
            transceiver.wantReceive = false;
          }
        }
      });

      // Create M-lines for recvonly streams.
      while (numAudioTracks > 0 || numVideoTracks > 0) {
        if (numAudioTracks > 0) {
          pc._createTransceiver('audio');
          numAudioTracks--;
        }
        if (numVideoTracks > 0) {
          pc._createTransceiver('video');
          numVideoTracks--;
        }
      }

      var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
          pc._sdpSessionVersion++);
      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
        // For each track, create an ice gatherer, ice transport,
        // dtls transport, potentially rtpsender and rtpreceiver.
        var track = transceiver.track;
        var kind = transceiver.kind;
        var mid = transceiver.mid || SDPUtils.generateIdentifier();
        transceiver.mid = mid;

        if (!transceiver.iceGatherer) {
          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
              pc.usingBundle);
        }

        var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
        // filter RTX until additional stuff needed for RTX is implemented
        // in adapter.js
        if (edgeVersion < 15019) {
          localCapabilities.codecs = localCapabilities.codecs.filter(
              function(codec) {
                return codec.name !== 'rtx';
              });
        }
        localCapabilities.codecs.forEach(function(codec) {
          // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
          // by adding level-asymmetry-allowed=1
          if (codec.name === 'H264' &&
              codec.parameters['level-asymmetry-allowed'] === undefined) {
            codec.parameters['level-asymmetry-allowed'] = '1';
          }

          // for subsequent offers, we might have to re-use the payload
          // type of the last offer.
          if (transceiver.remoteCapabilities &&
              transceiver.remoteCapabilities.codecs) {
            transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {
              if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&
                  codec.clockRate === remoteCodec.clockRate) {
                codec.preferredPayloadType = remoteCodec.payloadType;
              }
            });
          }
        });
        localCapabilities.headerExtensions.forEach(function(hdrExt) {
          var remoteExtensions = transceiver.remoteCapabilities &&
              transceiver.remoteCapabilities.headerExtensions || [];
          remoteExtensions.forEach(function(rHdrExt) {
            if (hdrExt.uri === rHdrExt.uri) {
              hdrExt.id = rHdrExt.id;
            }
          });
        });

        // generate an ssrc now, to be used later in rtpSender.send
        var sendEncodingParameters = transceiver.sendEncodingParameters || [{
          ssrc: (2 * sdpMLineIndex + 1) * 1001
        }];
        if (track) {
          // add RTX
          if (edgeVersion >= 15019 && kind === 'video' &&
              !sendEncodingParameters[0].rtx) {
            sendEncodingParameters[0].rtx = {
              ssrc: sendEncodingParameters[0].ssrc + 1
            };
          }
        }

        if (transceiver.wantReceive) {
          transceiver.rtpReceiver = new window.RTCRtpReceiver(
              transceiver.dtlsTransport, kind);
        }

        transceiver.localCapabilities = localCapabilities;
        transceiver.sendEncodingParameters = sendEncodingParameters;
      });

      // always offer BUNDLE and dispose on return if not supported.
      if (pc._config.bundlePolicy !== 'max-compat') {
        sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
          return t.mid;
        }).join(' ') + '\r\n';
      }
      sdp += 'a=ice-options:trickle\r\n';

      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
        sdp += writeMediaSection(transceiver, transceiver.localCapabilities,
            'offer', transceiver.stream, pc._dtlsRole);
        sdp += 'a=rtcp-rsize\r\n';

        if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&
            (sdpMLineIndex === 0 || !pc.usingBundle)) {
          transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {
            cand.component = 1;
            sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\r\n';
          });

          if (transceiver.iceGatherer.state === 'completed') {
            sdp += 'a=end-of-candidates\r\n';
          }
        }
      });

      var desc = new window.RTCSessionDescription({
        type: 'offer',
        sdp: sdp
      });
      return Promise.resolve(desc);
    };

    RTCPeerConnection.prototype.createAnswer = function() {
      var pc = this;

      if (pc._isClosed) {
        return Promise.reject(makeError('InvalidStateError',
            'Can not call createAnswer after close'));
      }

      if (!(pc.signalingState === 'have-remote-offer' ||
          pc.signalingState === 'have-local-pranswer')) {
        return Promise.reject(makeError('InvalidStateError',
            'Can not call createAnswer in signalingState ' + pc.signalingState));
      }

      var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
          pc._sdpSessionVersion++);
      if (pc.usingBundle) {
        sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
          return t.mid;
        }).join(' ') + '\r\n';
      }
      sdp += 'a=ice-options:trickle\r\n';

      var mediaSectionsInOffer = SDPUtils.getMediaSections(
          pc._remoteDescription.sdp).length;
      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
        if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
          return;
        }
        if (transceiver.rejected) {
          if (transceiver.kind === 'application') {
            if (transceiver.protocol === 'DTLS/SCTP') { // legacy fmt
              sdp += 'm=application 0 DTLS/SCTP 5000\r\n';
            } else {
              sdp += 'm=application 0 ' + transceiver.protocol +
                  ' webrtc-datachannel\r\n';
            }
          } else if (transceiver.kind === 'audio') {
            sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\r\n' +
                'a=rtpmap:0 PCMU/8000\r\n';
          } else if (transceiver.kind === 'video') {
            sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\r\n' +
                'a=rtpmap:120 VP8/90000\r\n';
          }
          sdp += 'c=IN IP4 0.0.0.0\r\n' +
              'a=inactive\r\n' +
              'a=mid:' + transceiver.mid + '\r\n';
          return;
        }

        // FIXME: look at direction.
        if (transceiver.stream) {
          var localTrack;
          if (transceiver.kind === 'audio') {
            localTrack = transceiver.stream.getAudioTracks()[0];
          } else if (transceiver.kind === 'video') {
            localTrack = transceiver.stream.getVideoTracks()[0];
          }
          if (localTrack) {
            // add RTX
            if (edgeVersion >= 15019 && transceiver.kind === 'video' &&
                !transceiver.sendEncodingParameters[0].rtx) {
              transceiver.sendEncodingParameters[0].rtx = {
                ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
              };
            }
          }
        }

        // Calculate intersection of capabilities.
        var commonCapabilities = getCommonCapabilities(
            transceiver.localCapabilities,
            transceiver.remoteCapabilities);

        var hasRtx = commonCapabilities.codecs.filter(function(c) {
          return c.name.toLowerCase() === 'rtx';
        }).length;
        if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
          delete transceiver.sendEncodingParameters[0].rtx;
        }

        sdp += writeMediaSection(transceiver, commonCapabilities,
            'answer', transceiver.stream, pc._dtlsRole);
        if (transceiver.rtcpParameters &&
            transceiver.rtcpParameters.reducedSize) {
          sdp += 'a=rtcp-rsize\r\n';
        }
      });

      var desc = new window.RTCSessionDescription({
        type: 'answer',
        sdp: sdp
      });
      return Promise.resolve(desc);
    };

    RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
      var pc = this;
      var sections;
      if (candidate && !(candidate.sdpMLineIndex !== undefined ||
          candidate.sdpMid)) {
        return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));
      }

      // TODO: needs to go into ops queue.
      return new Promise(function(resolve, reject) {
        if (!pc._remoteDescription) {
          return reject(makeError('InvalidStateError',
              'Can not add ICE candidate without a remote description'));
        } else if (!candidate || candidate.candidate === '') {
          for (var j = 0; j < pc.transceivers.length; j++) {
            if (pc.transceivers[j].rejected) {
              continue;
            }
            pc.transceivers[j].iceTransport.addRemoteCandidate({});
            sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
            sections[j] += 'a=end-of-candidates\r\n';
            pc._remoteDescription.sdp =
                SDPUtils.getDescription(pc._remoteDescription.sdp) +
                sections.join('');
            if (pc.usingBundle) {
              break;
            }
          }
        } else {
          var sdpMLineIndex = candidate.sdpMLineIndex;
          if (candidate.sdpMid) {
            for (var i = 0; i < pc.transceivers.length; i++) {
              if (pc.transceivers[i].mid === candidate.sdpMid) {
                sdpMLineIndex = i;
                break;
              }
            }
          }
          var transceiver = pc.transceivers[sdpMLineIndex];
          if (transceiver) {
            if (transceiver.rejected) {
              return resolve();
            }
            var cand = Object.keys(candidate.candidate).length > 0 ?
                SDPUtils.parseCandidate(candidate.candidate) : {};
            // Ignore Chrome's invalid candidates since Edge does not like them.
            if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
              return resolve();
            }
            // Ignore RTCP candidates, we assume RTCP-MUX.
            if (cand.component && cand.component !== 1) {
              return resolve();
            }
            // when using bundle, avoid adding candidates to the wrong
            // ice transport. And avoid adding candidates added in the SDP.
            if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&
                transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {
              if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
                return reject(makeError('OperationError',
                    'Can not add ICE candidate'));
              }
            }

            // update the remoteDescription.
            var candidateString = candidate.candidate.trim();
            if (candidateString.indexOf('a=') === 0) {
              candidateString = candidateString.substr(2);
            }
            sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
            sections[sdpMLineIndex] += 'a=' +
                (cand.type ? candidateString : 'end-of-candidates')
                + '\r\n';
            pc._remoteDescription.sdp =
                SDPUtils.getDescription(pc._remoteDescription.sdp) +
                sections.join('');
          } else {
            return reject(makeError('OperationError',
                'Can not add ICE candidate'));
          }
        }
        resolve();
      });
    };

    RTCPeerConnection.prototype.getStats = function(selector) {
      if (selector && selector instanceof window.MediaStreamTrack) {
        var senderOrReceiver = null;
        this.transceivers.forEach(function(transceiver) {
          if (transceiver.rtpSender &&
              transceiver.rtpSender.track === selector) {
            senderOrReceiver = transceiver.rtpSender;
          } else if (transceiver.rtpReceiver &&
              transceiver.rtpReceiver.track === selector) {
            senderOrReceiver = transceiver.rtpReceiver;
          }
        });
        if (!senderOrReceiver) {
          throw makeError('InvalidAccessError', 'Invalid selector.');
        }
        return senderOrReceiver.getStats();
      }

      var promises = [];
      this.transceivers.forEach(function(transceiver) {
        ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
            'dtlsTransport'].forEach(function(method) {
              if (transceiver[method]) {
                promises.push(transceiver[method].getStats());
              }
            });
      });
      return Promise.all(promises).then(function(allStats) {
        var results = new Map();
        allStats.forEach(function(stats) {
          stats.forEach(function(stat) {
            results.set(stat.id, stat);
          });
        });
        return results;
      });
    };

    // fix low-level stat names and return Map instead of object.
    var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',
      'RTCIceTransport', 'RTCDtlsTransport'];
    ortcObjects.forEach(function(ortcObjectName) {
      var obj = window[ortcObjectName];
      if (obj && obj.prototype && obj.prototype.getStats) {
        var nativeGetstats = obj.prototype.getStats;
        obj.prototype.getStats = function() {
          return nativeGetstats.apply(this)
          .then(function(nativeStats) {
            var mapStats = new Map();
            Object.keys(nativeStats).forEach(function(id) {
              nativeStats[id].type = fixStatsType(nativeStats[id]);
              mapStats.set(id, nativeStats[id]);
            });
            return mapStats;
          });
        };
      }
    });

    // legacy callback shims. Should be moved to adapter.js some days.
    var methods = ['createOffer', 'createAnswer'];
    methods.forEach(function(method) {
      var nativeMethod = RTCPeerConnection.prototype[method];
      RTCPeerConnection.prototype[method] = function() {
        var args = arguments;
        if (typeof args[0] === 'function' ||
            typeof args[1] === 'function') { // legacy
          return nativeMethod.apply(this, [arguments[2]])
          .then(function(description) {
            if (typeof args[0] === 'function') {
              args[0].apply(null, [description]);
            }
          }, function(error) {
            if (typeof args[1] === 'function') {
              args[1].apply(null, [error]);
            }
          });
        }
        return nativeMethod.apply(this, arguments);
      };
    });

    methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];
    methods.forEach(function(method) {
      var nativeMethod = RTCPeerConnection.prototype[method];
      RTCPeerConnection.prototype[method] = function() {
        var args = arguments;
        if (typeof args[1] === 'function' ||
            typeof args[2] === 'function') { // legacy
          return nativeMethod.apply(this, arguments)
          .then(function() {
            if (typeof args[1] === 'function') {
              args[1].apply(null);
            }
          }, function(error) {
            if (typeof args[2] === 'function') {
              args[2].apply(null, [error]);
            }
          });
        }
        return nativeMethod.apply(this, arguments);
      };
    });

    // getStats is special. It doesn't have a spec legacy method yet we support
    // getStats(something, cb) without error callbacks.
    ['getStats'].forEach(function(method) {
      var nativeMethod = RTCPeerConnection.prototype[method];
      RTCPeerConnection.prototype[method] = function() {
        var args = arguments;
        if (typeof args[1] === 'function') {
          return nativeMethod.apply(this, arguments)
          .then(function() {
            if (typeof args[1] === 'function') {
              args[1].apply(null);
            }
          });
        }
        return nativeMethod.apply(this, arguments);
      };
    });

    return RTCPeerConnection;
  };

  },{"sdp":17}],17:[function(require,module,exports){
   /* eslint-env node */
  'use strict';

  // SDP helpers.
  var SDPUtils = {};

  // Generate an alphanumeric identifier for cname or mids.
  // TODO: use UUIDs instead? https://gist.github.com/jed/982883
  SDPUtils.generateIdentifier = function() {
    return Math.random().toString(36).substr(2, 10);
  };

  // The RTCP CNAME used by all peerconnections from the same JS.
  SDPUtils.localCName = SDPUtils.generateIdentifier();

  // Splits SDP into lines, dealing with both CRLF and LF.
  SDPUtils.splitLines = function(blob) {
    return blob.trim().split('\n').map(function(line) {
      return line.trim();
    });
  };
  // Splits SDP into sessionpart and mediasections. Ensures CRLF.
  SDPUtils.splitSections = function(blob) {
    var parts = blob.split('\nm=');
    return parts.map(function(part, index) {
      return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
    });
  };

  // returns the session description.
  SDPUtils.getDescription = function(blob) {
    var sections = SDPUtils.splitSections(blob);
    return sections && sections[0];
  };

  // returns the individual media sections.
  SDPUtils.getMediaSections = function(blob) {
    var sections = SDPUtils.splitSections(blob);
    sections.shift();
    return sections;
  };

  // Returns lines that start with a certain prefix.
  SDPUtils.matchPrefix = function(blob, prefix) {
    return SDPUtils.splitLines(blob).filter(function(line) {
      return line.indexOf(prefix) === 0;
    });
  };

  // Parses an ICE candidate line. Sample input:
  // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
  // rport 55996"
  SDPUtils.parseCandidate = function(line) {
    var parts;
    // Parse both variants.
    if (line.indexOf('a=candidate:') === 0) {
      parts = line.substring(12).split(' ');
    } else {
      parts = line.substring(10).split(' ');
    }

    var candidate = {
      foundation: parts[0],
      component: parseInt(parts[1], 10),
      protocol: parts[2].toLowerCase(),
      priority: parseInt(parts[3], 10),
      ip: parts[4],
      address: parts[4], // address is an alias for ip.
      port: parseInt(parts[5], 10),
      // skip parts[6] == 'typ'
      type: parts[7]
    };

    for (var i = 8; i < parts.length; i += 2) {
      switch (parts[i]) {
        case 'raddr':
          candidate.relatedAddress = parts[i + 1];
          break;
        case 'rport':
          candidate.relatedPort = parseInt(parts[i + 1], 10);
          break;
        case 'tcptype':
          candidate.tcpType = parts[i + 1];
          break;
        case 'ufrag':
          candidate.ufrag = parts[i + 1]; // for backward compability.
          candidate.usernameFragment = parts[i + 1];
          break;
        default: // extension handling, in particular ufrag
          candidate[parts[i]] = parts[i + 1];
          break;
      }
    }
    return candidate;
  };

  // Translates a candidate object into SDP candidate attribute.
  SDPUtils.writeCandidate = function(candidate) {
    var sdp = [];
    sdp.push(candidate.foundation);
    sdp.push(candidate.component);
    sdp.push(candidate.protocol.toUpperCase());
    sdp.push(candidate.priority);
    sdp.push(candidate.address || candidate.ip);
    sdp.push(candidate.port);

    var type = candidate.type;
    sdp.push('typ');
    sdp.push(type);
    if (type !== 'host' && candidate.relatedAddress &&
        candidate.relatedPort) {
      sdp.push('raddr');
      sdp.push(candidate.relatedAddress);
      sdp.push('rport');
      sdp.push(candidate.relatedPort);
    }
    if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
      sdp.push('tcptype');
      sdp.push(candidate.tcpType);
    }
    if (candidate.usernameFragment || candidate.ufrag) {
      sdp.push('ufrag');
      sdp.push(candidate.usernameFragment || candidate.ufrag);
    }
    return 'candidate:' + sdp.join(' ');
  };

  // Parses an ice-options line, returns an array of option tags.
  // a=ice-options:foo bar
  SDPUtils.parseIceOptions = function(line) {
    return line.substr(14).split(' ');
  };

  // Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
  // a=rtpmap:111 opus/48000/2
  SDPUtils.parseRtpMap = function(line) {
    var parts = line.substr(9).split(' ');
    var parsed = {
      payloadType: parseInt(parts.shift(), 10) // was: id
    };

    parts = parts[0].split('/');

    parsed.name = parts[0];
    parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
    parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
    // legacy alias, got renamed back to channels in ORTC.
    parsed.numChannels = parsed.channels;
    return parsed;
  };

  // Generate an a=rtpmap line from RTCRtpCodecCapability or
  // RTCRtpCodecParameters.
  SDPUtils.writeRtpMap = function(codec) {
    var pt = codec.payloadType;
    if (codec.preferredPayloadType !== undefined) {
      pt = codec.preferredPayloadType;
    }
    var channels = codec.channels || codec.numChannels || 1;
    return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
        (channels !== 1 ? '/' + channels : '') + '\r\n';
  };

  // Parses an a=extmap line (headerextension from RFC 5285). Sample input:
  // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
  // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
  SDPUtils.parseExtmap = function(line) {
    var parts = line.substr(9).split(' ');
    return {
      id: parseInt(parts[0], 10),
      direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
      uri: parts[1]
    };
  };

  // Generates a=extmap line from RTCRtpHeaderExtensionParameters or
  // RTCRtpHeaderExtension.
  SDPUtils.writeExtmap = function(headerExtension) {
    return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
        (headerExtension.direction && headerExtension.direction !== 'sendrecv'
            ? '/' + headerExtension.direction
            : '') +
        ' ' + headerExtension.uri + '\r\n';
  };

  // Parses an ftmp line, returns dictionary. Sample input:
  // a=fmtp:96 vbr=on;cng=on
  // Also deals with vbr=on; cng=on
  SDPUtils.parseFmtp = function(line) {
    var parsed = {};
    var kv;
    var parts = line.substr(line.indexOf(' ') + 1).split(';');
    for (var j = 0; j < parts.length; j++) {
      kv = parts[j].trim().split('=');
      parsed[kv[0].trim()] = kv[1];
    }
    return parsed;
  };

  // Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
  SDPUtils.writeFmtp = function(codec) {
    var line = '';
    var pt = codec.payloadType;
    if (codec.preferredPayloadType !== undefined) {
      pt = codec.preferredPayloadType;
    }
    if (codec.parameters && Object.keys(codec.parameters).length) {
      var params = [];
      Object.keys(codec.parameters).forEach(function(param) {
        if (codec.parameters[param]) {
          params.push(param + '=' + codec.parameters[param]);
        } else {
          params.push(param);
        }
      });
      line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
    }
    return line;
  };

  // Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
  // a=rtcp-fb:98 nack rpsi
  SDPUtils.parseRtcpFb = function(line) {
    var parts = line.substr(line.indexOf(' ') + 1).split(' ');
    return {
      type: parts.shift(),
      parameter: parts.join(' ')
    };
  };
  // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
  SDPUtils.writeRtcpFb = function(codec) {
    var lines = '';
    var pt = codec.payloadType;
    if (codec.preferredPayloadType !== undefined) {
      pt = codec.preferredPayloadType;
    }
    if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
      // FIXME: special handling for trr-int?
      codec.rtcpFeedback.forEach(function(fb) {
        lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
        (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
            '\r\n';
      });
    }
    return lines;
  };

  // Parses an RFC 5576 ssrc media attribute. Sample input:
  // a=ssrc:3735928559 cname:something
  SDPUtils.parseSsrcMedia = function(line) {
    var sp = line.indexOf(' ');
    var parts = {
      ssrc: parseInt(line.substr(7, sp - 7), 10)
    };
    var colon = line.indexOf(':', sp);
    if (colon > -1) {
      parts.attribute = line.substr(sp + 1, colon - sp - 1);
      parts.value = line.substr(colon + 1);
    } else {
      parts.attribute = line.substr(sp + 1);
    }
    return parts;
  };

  SDPUtils.parseSsrcGroup = function(line) {
    var parts = line.substr(13).split(' ');
    return {
      semantics: parts.shift(),
      ssrcs: parts.map(function(ssrc) {
        return parseInt(ssrc, 10);
      })
    };
  };

  // Extracts the MID (RFC 5888) from a media section.
  // returns the MID or undefined if no mid line was found.
  SDPUtils.getMid = function(mediaSection) {
    var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
    if (mid) {
      return mid.substr(6);
    }
  };

  SDPUtils.parseFingerprint = function(line) {
    var parts = line.substr(14).split(' ');
    return {
      algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
      value: parts[1]
    };
  };

  // Extracts DTLS parameters from SDP media section or sessionpart.
  // FIXME: for consistency with other functions this should only
  //   get the fingerprint line as input. See also getIceParameters.
  SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
    var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
        'a=fingerprint:');
    // Note: a=setup line is ignored since we use the 'auto' role.
    // Note2: 'algorithm' is not case sensitive except in Edge.
    return {
      role: 'auto',
      fingerprints: lines.map(SDPUtils.parseFingerprint)
    };
  };

  // Serializes DTLS parameters to SDP.
  SDPUtils.writeDtlsParameters = function(params, setupType) {
    var sdp = 'a=setup:' + setupType + '\r\n';
    params.fingerprints.forEach(function(fp) {
      sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
    });
    return sdp;
  };
  // Parses ICE information from SDP media section or sessionpart.
  // FIXME: for consistency with other functions this should only
  //   get the ice-ufrag and ice-pwd lines as input.
  SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
    var lines = SDPUtils.splitLines(mediaSection);
    // Search in session part, too.
    lines = lines.concat(SDPUtils.splitLines(sessionpart));
    var iceParameters = {
      usernameFragment: lines.filter(function(line) {
        return line.indexOf('a=ice-ufrag:') === 0;
      })[0].substr(12),
      password: lines.filter(function(line) {
        return line.indexOf('a=ice-pwd:') === 0;
      })[0].substr(10)
    };
    return iceParameters;
  };

  // Serializes ICE parameters to SDP.
  SDPUtils.writeIceParameters = function(params) {
    return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
        'a=ice-pwd:' + params.password + '\r\n';
  };

  // Parses the SDP media section and returns RTCRtpParameters.
  SDPUtils.parseRtpParameters = function(mediaSection) {
    var description = {
      codecs: [],
      headerExtensions: [],
      fecMechanisms: [],
      rtcp: []
    };
    var lines = SDPUtils.splitLines(mediaSection);
    var mline = lines[0].split(' ');
    for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
      var pt = mline[i];
      var rtpmapline = SDPUtils.matchPrefix(
          mediaSection, 'a=rtpmap:' + pt + ' ')[0];
      if (rtpmapline) {
        var codec = SDPUtils.parseRtpMap(rtpmapline);
        var fmtps = SDPUtils.matchPrefix(
            mediaSection, 'a=fmtp:' + pt + ' ');
        // Only the first a=fmtp:<pt> is considered.
        codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
        codec.rtcpFeedback = SDPUtils.matchPrefix(
            mediaSection, 'a=rtcp-fb:' + pt + ' ')
          .map(SDPUtils.parseRtcpFb);
        description.codecs.push(codec);
        // parse FEC mechanisms from rtpmap lines.
        switch (codec.name.toUpperCase()) {
          case 'RED':
          case 'ULPFEC':
            description.fecMechanisms.push(codec.name.toUpperCase());
            break;
          default: // only RED and ULPFEC are recognized as FEC mechanisms.
            break;
        }
      }
    }
    SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
      description.headerExtensions.push(SDPUtils.parseExtmap(line));
    });
    // FIXME: parse rtcp.
    return description;
  };

  // Generates parts of the SDP media section describing the capabilities /
  // parameters.
  SDPUtils.writeRtpDescription = function(kind, caps) {
    var sdp = '';

    // Build the mline.
    sdp += 'm=' + kind + ' ';
    sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
    sdp += ' UDP/TLS/RTP/SAVPF ';
    sdp += caps.codecs.map(function(codec) {
      if (codec.preferredPayloadType !== undefined) {
        return codec.preferredPayloadType;
      }
      return codec.payloadType;
    }).join(' ') + '\r\n';

    sdp += 'c=IN IP4 0.0.0.0\r\n';
    sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

    // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
    caps.codecs.forEach(function(codec) {
      sdp += SDPUtils.writeRtpMap(codec);
      sdp += SDPUtils.writeFmtp(codec);
      sdp += SDPUtils.writeRtcpFb(codec);
    });
    var maxptime = 0;
    caps.codecs.forEach(function(codec) {
      if (codec.maxptime > maxptime) {
        maxptime = codec.maxptime;
      }
    });
    if (maxptime > 0) {
      sdp += 'a=maxptime:' + maxptime + '\r\n';
    }
    sdp += 'a=rtcp-mux\r\n';

    if (caps.headerExtensions) {
      caps.headerExtensions.forEach(function(extension) {
        sdp += SDPUtils.writeExtmap(extension);
      });
    }
    // FIXME: write fecMechanisms.
    return sdp;
  };

  // Parses the SDP media section and returns an array of
  // RTCRtpEncodingParameters.
  SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
    var encodingParameters = [];
    var description = SDPUtils.parseRtpParameters(mediaSection);
    var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
    var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

    // filter a=ssrc:... cname:, ignore PlanB-msid
    var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(function(line) {
      return SDPUtils.parseSsrcMedia(line);
    })
    .filter(function(parts) {
      return parts.attribute === 'cname';
    });
    var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
    var secondarySsrc;

    var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
    .map(function(line) {
      var parts = line.substr(17).split(' ');
      return parts.map(function(part) {
        return parseInt(part, 10);
      });
    });
    if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
      secondarySsrc = flows[0][1];
    }

    description.codecs.forEach(function(codec) {
      if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
        var encParam = {
          ssrc: primarySsrc,
          codecPayloadType: parseInt(codec.parameters.apt, 10)
        };
        if (primarySsrc && secondarySsrc) {
          encParam.rtx = {ssrc: secondarySsrc};
        }
        encodingParameters.push(encParam);
        if (hasRed) {
          encParam = JSON.parse(JSON.stringify(encParam));
          encParam.fec = {
            ssrc: primarySsrc,
            mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
          };
          encodingParameters.push(encParam);
        }
      }
    });
    if (encodingParameters.length === 0 && primarySsrc) {
      encodingParameters.push({
        ssrc: primarySsrc
      });
    }

    // we support both b=AS and b=TIAS but interpret AS as TIAS.
    var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
    if (bandwidth.length) {
      if (bandwidth[0].indexOf('b=TIAS:') === 0) {
        bandwidth = parseInt(bandwidth[0].substr(7), 10);
      } else if (bandwidth[0].indexOf('b=AS:') === 0) {
        // use formula from JSEP to convert b=AS to TIAS value.
        bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
            - (50 * 40 * 8);
      } else {
        bandwidth = undefined;
      }
      encodingParameters.forEach(function(params) {
        params.maxBitrate = bandwidth;
      });
    }
    return encodingParameters;
  };

  // parses http://draft.ortc.org/#rtcrtcpparameters*
  SDPUtils.parseRtcpParameters = function(mediaSection) {
    var rtcpParameters = {};

    // Gets the first SSRC. Note tha with RTX there might be multiple
    // SSRCs.
    var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
        .map(function(line) {
          return SDPUtils.parseSsrcMedia(line);
        })
        .filter(function(obj) {
          return obj.attribute === 'cname';
        })[0];
    if (remoteSsrc) {
      rtcpParameters.cname = remoteSsrc.value;
      rtcpParameters.ssrc = remoteSsrc.ssrc;
    }

    // Edge uses the compound attribute instead of reducedSize
    // compound is !reducedSize
    var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
    rtcpParameters.reducedSize = rsize.length > 0;
    rtcpParameters.compound = rsize.length === 0;

    // parses the rtcp-mux attrіbute.
    // Note that Edge does not support unmuxed RTCP.
    var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
    rtcpParameters.mux = mux.length > 0;

    return rtcpParameters;
  };

  // parses either a=msid: or a=ssrc:... msid lines and returns
  // the id of the MediaStream and MediaStreamTrack.
  SDPUtils.parseMsid = function(mediaSection) {
    var parts;
    var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
    if (spec.length === 1) {
      parts = spec[0].substr(7).split(' ');
      return {stream: parts[0], track: parts[1]};
    }
    var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(function(line) {
      return SDPUtils.parseSsrcMedia(line);
    })
    .filter(function(msidParts) {
      return msidParts.attribute === 'msid';
    });
    if (planB.length > 0) {
      parts = planB[0].value.split(' ');
      return {stream: parts[0], track: parts[1]};
    }
  };

  // Generate a session ID for SDP.
  // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
  // recommends using a cryptographically random +ve 64-bit value
  // but right now this should be acceptable and within the right range
  SDPUtils.generateSessionId = function() {
    return Math.random().toString().substr(2, 21);
  };

  // Write boilder plate for start of SDP
  // sessId argument is optional - if not supplied it will
  // be generated randomly
  // sessVersion is optional and defaults to 2
  // sessUser is optional and defaults to 'thisisadapterortc'
  SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
    var sessionId;
    var version = sessVer !== undefined ? sessVer : 2;
    if (sessId) {
      sessionId = sessId;
    } else {
      sessionId = SDPUtils.generateSessionId();
    }
    var user = sessUser || 'thisisadapterortc';
    // FIXME: sess-id should be an NTP timestamp.
    return 'v=0\r\n' +
        'o=' + user + ' ' + sessionId + ' ' + version +
          ' IN IP4 127.0.0.1\r\n' +
        's=-\r\n' +
        't=0 0\r\n';
  };

  SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
    var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

    // Map ICE parameters (ufrag, pwd) to SDP.
    sdp += SDPUtils.writeIceParameters(
        transceiver.iceGatherer.getLocalParameters());

    // Map DTLS parameters to SDP.
    sdp += SDPUtils.writeDtlsParameters(
        transceiver.dtlsTransport.getLocalParameters(),
        type === 'offer' ? 'actpass' : 'active');

    sdp += 'a=mid:' + transceiver.mid + '\r\n';

    if (transceiver.direction) {
      sdp += 'a=' + transceiver.direction + '\r\n';
    } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
      sdp += 'a=sendrecv\r\n';
    } else if (transceiver.rtpSender) {
      sdp += 'a=sendonly\r\n';
    } else if (transceiver.rtpReceiver) {
      sdp += 'a=recvonly\r\n';
    } else {
      sdp += 'a=inactive\r\n';
    }

    if (transceiver.rtpSender) {
      // spec.
      var msid = 'msid:' + stream.id + ' ' +
          transceiver.rtpSender.track.id + '\r\n';
      sdp += 'a=' + msid;

      // for Chrome.
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
          ' ' + msid;
      if (transceiver.sendEncodingParameters[0].rtx) {
        sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
            ' ' + msid;
        sdp += 'a=ssrc-group:FID ' +
            transceiver.sendEncodingParameters[0].ssrc + ' ' +
            transceiver.sendEncodingParameters[0].rtx.ssrc +
            '\r\n';
      }
    }
    // FIXME: this should be written by writeRtpDescription.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
    if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' cname:' + SDPUtils.localCName + '\r\n';
    }
    return sdp;
  };

  // Gets the direction from the mediaSection or the sessionpart.
  SDPUtils.getDirection = function(mediaSection, sessionpart) {
    // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
    var lines = SDPUtils.splitLines(mediaSection);
    for (var i = 0; i < lines.length; i++) {
      switch (lines[i]) {
        case 'a=sendrecv':
        case 'a=sendonly':
        case 'a=recvonly':
        case 'a=inactive':
          return lines[i].substr(2);
        default:
          // FIXME: What should happen here?
      }
    }
    if (sessionpart) {
      return SDPUtils.getDirection(sessionpart);
    }
    return 'sendrecv';
  };

  SDPUtils.getKind = function(mediaSection) {
    var lines = SDPUtils.splitLines(mediaSection);
    var mline = lines[0].split(' ');
    return mline[0].substr(2);
  };

  SDPUtils.isRejected = function(mediaSection) {
    return mediaSection.split(' ', 2)[1] === '0';
  };

  SDPUtils.parseMLine = function(mediaSection) {
    var lines = SDPUtils.splitLines(mediaSection);
    var parts = lines[0].substr(2).split(' ');
    return {
      kind: parts[0],
      port: parseInt(parts[1], 10),
      protocol: parts[2],
      fmt: parts.slice(3).join(' ')
    };
  };

  SDPUtils.parseOLine = function(mediaSection) {
    var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
    var parts = line.substr(2).split(' ');
    return {
      username: parts[0],
      sessionId: parts[1],
      sessionVersion: parseInt(parts[2], 10),
      netType: parts[3],
      addressType: parts[4],
      address: parts[5]
    };
  };

  // a very naive interpretation of a valid SDP.
  SDPUtils.isValidSDP = function(blob) {
    if (typeof blob !== 'string' || blob.length === 0) {
      return false;
    }
    var lines = SDPUtils.splitLines(blob);
    for (var i = 0; i < lines.length; i++) {
      if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
        return false;
      }
      // TODO: check the modifier a bit more.
    }
    return true;
  };

  // Expose public methods.
  if (typeof module === 'object') {
    module.exports = SDPUtils;
  }

  },{}]},{},[1])(1)
  });

/***/ }),

/***/ "../zego_express_web_rtm/dist/ZegoExpressWebRTM.js":
/*!*********************************************************!*\
  !*** ../zego_express_web_rtm/dist/ZegoExpressWebRTM.js ***!
  \*********************************************************/
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_573__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_573__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_573__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_573__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_573__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_573__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_573__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__nested_webpack_require_573__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __nested_webpack_require_573__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__nested_webpack_require_573__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_573__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_573__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_573__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_573__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_573__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_573__(__nested_webpack_require_573__.s = "./sdk/code/zh/zego.client.web.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/zego-express-logger/ZegoExpressLogger.js":
/*!****************************************************************!*\
  !*** ../node_modules/zego-express-logger/ZegoExpressLogger.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){if(true)module.exports=t();else { var n, o; }}("undefined"!=typeof self?self:this,(function(){return function(e){var t={};function o(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,o),i.l=!0,i.exports}return o.m=e,o.c=t,o.d=function(e,t,n){o.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},o.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,t){if(1&t&&(e=o(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(o.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)o.d(n,i,function(t){return e[t]}.bind(null,i));return n},o.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return o.d(t,"a",t),t},o.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},o.p="",o(o.s=3)}([function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.E_CLIENT_TYPE=t.ENUM_LOG_LEVEL=t.ENUM_REMOTE_TYPE=t.ZEGO_ENV=t.ZEGO_BROWSER_TYPE=void 0,function(e){e[e.IE=0]="IE",e[e.FIREFOX=1]="FIREFOX",e[e.CHROME=2]="CHROME",e[e.SAFARI=3]="SAFARI",e[e.OPERA=4]="OPERA",e[e.WEIXIN=5]="WEIXIN",e[e.WEIXINMINI=6]="WEIXINMINI",e[e.UNKOWN=7]="UNKOWN"}(t.ZEGO_BROWSER_TYPE||(t.ZEGO_BROWSER_TYPE={})),function(e){e[e.BROWSER=0]="BROWSER",e[e.WEIXINMINI=1]="WEIXINMINI"}(t.ZEGO_ENV||(t.ZEGO_ENV={})),function(e){e[e.DISABLE=0]="DISABLE",e[e.WEBSOCKET=1]="WEBSOCKET",e[e.HTTPS=2]="HTTPS"}(t.ENUM_REMOTE_TYPE||(t.ENUM_REMOTE_TYPE={})),t.ENUM_LOG_LEVEL={DEBUG:0,INFO:1,WARN:2,ERROR:3,REPORT:99,DISABLE:100,debug:0,info:1,warn:2,error:3,report:99,disable:100},function(e){e[e.ClientType_None=0]="ClientType_None",e[e.ClientType_H5=1]="ClientType_H5",e[e.ClientType_SmallPragram=2]="ClientType_SmallPragram",e[e.ClientType_Webrtc=3]="ClientType_Webrtc"}(t.E_CLIENT_TYPE||(t.E_CLIENT_TYPE={}))},function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.LoggerStateCenter=void 0;var n=function(){function e(){this._testEnvironment=!0,this._ENV=0,this._debug=!0}return e.getInstance=function(){return e.instance||(e.instance=new e,e.instance.init()),e.instance},e.prototype.init=function(){},Object.defineProperty(e.prototype,"testEnvironment",{get:function(){return this._testEnvironment},set:function(e){this._testEnvironment=e},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"ENV",{get:function(){return this._ENV},set:function(e){this._ENV=e},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"debug",{get:function(){return this._debug},set:function(e){this._debug=e},enumerable:!1,configurable:!0}),e.instance=new e,e}();t.LoggerStateCenter=n},function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createZegoWebSocket=t.ZegoWeiXinMiniWebSocket=void 0;var n=o(0),i=function(){function e(e,t){this.url=e,this.readyState=3,this._websocket=wx.connectSocket({url:e}),this.init()}return e.prototype.init=function(){var e=this;this._websocket&&(this.readyState=0,this._websocket.onOpen((function(t){e.readyState=e._websocket.readyState,"function"==typeof e.onopen&&(e.onopen(t),e._websocket.onClose((function(t){e.readyState=e._websocket.readyState,"function"==typeof e.onclose&&e.onclose(t)})),e._websocket.onMessage((function(t){"function"==typeof e.onmessage&&e.onmessage(t)})))})),this._websocket.onError((function(t){e.readyState=e._websocket.readyState,"function"==typeof e.onerror&&e.onerror(t)})))},e.prototype.onopen=function(e){},e.prototype.onerror=function(e){},e.prototype.onclose=function(e){},e.prototype.onmessage=function(e){},e.prototype.send=function(e){this._websocket&&this._websocket.send({data:e})},e.prototype.close=function(){this._websocket&&this._websocket.close()},e}();t.ZegoWeiXinMiniWebSocket=i,t.createZegoWebSocket=function(e,t){return t%2===n.ZEGO_ENV.BROWSER?new WebSocket(e):new i(e)}},function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.LoggerStateCenter=t.createZegoWebSocket=t.ZegoDataReport=t.ZegoLogger=void 0;var n=o(1);Object.defineProperty(t,"LoggerStateCenter",{enumerable:!0,get:function(){return n.LoggerStateCenter}});var i=o(2);Object.defineProperty(t,"createZegoWebSocket",{enumerable:!0,get:function(){return i.createZegoWebSocket}});var s=o(4);Object.defineProperty(t,"ZegoDataReport",{enumerable:!0,get:function(){return s.ZegoDataReport}});var r=o(5);Object.defineProperty(t,"ZegoLogger",{enumerable:!0,get:function(){return r.ZegoLogger}})},function(e,t,o){"use strict";var n=this&&this.__assign||function(){return(n=Object.assign||function(e){for(var t,o=1,n=arguments.length;o<n;o++)for(var i in t=arguments[o])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.ZegoDataReport=void 0;var i=function(){function e(e){this.dataStatistics={},this.logger=e}return e.prototype.newReport=function(e,t){this.dataStatistics[e]={event_time:Date.now(),time_consumed:0,seq:e,error:0,message:"success",event:t,events:[]}},e.prototype.addMsgExt=function(e,t){this.dataStatistics[e]?this.dataStatistics[e].msg_ext=t:console.warn(e+" not exist")},e.prototype.addMsgInfo=function(e,t){this.dataStatistics[e]?Object.assign(this.dataStatistics[e],t):console.warn(e+" not exist")},e.prototype.eventStart=function(e,t){this.dataStatistics[e]?null!=this.dataStatistics[e].events?this.dataStatistics[e].events.push({event:t,event_time:Date.now(),time_consumed:0}):this.logger.warn("zd.es.0 no events"):this.logger.warn("zd.es.0 no seq match")},e.prototype.eventEnd=function(e,t,o){if(this.dataStatistics[e]){var n=this.dataStatistics[e].events;if(n&&0!==n.length){for(var i=n.length-1;i>=0;i--)if(n[i].event==t&&0==n[i].time_consumed){n[i].time_consumed=Date.now()-n[i].event_time;break}}else this.logger.info("zd.ee.0 no events")}else this.logger.info("zd.ee.0 no seq match")},e.prototype.eventEndWithMsg=function(e,t,o){if(this.dataStatistics[e]){var i=this.dataStatistics[e].events;if(i){for(var s=i.length-1;s>=0;s--)if(i[s].event==t&&0==i[s].time_consumed){i[s].time_consumed=Date.now()-i[s].event_time,null==i[s].msg_ext&&(i[s].msg_ext={}),i[s].msg_ext=n({},o);break}}else this.logger.warn("zd.ee.0 no events")}else this.logger.warn("zd.ee.0 no seq match")},e.prototype.eventEndWithMsgInfo=function(e,t,o){if(this.dataStatistics[e]){var n=this.dataStatistics[e].events;if(n){for(var i=n.length-1;i>=0;i--)if(n[i].event==t&&0==n[i].time_consumed){n[i].time_consumed=Date.now()-n[i].event_time,Object.assign(n[i],o);break}}else this.logger.warn("zd.ee.0 no events")}else this.logger.warn("zd.ee.0 no seq match")},e.prototype.addEventInfo=function(e,t,o,n){if(this.dataStatistics[e]){var i=this.dataStatistics[e].events;if(null!=i){for(var s=i.length-1;s>=0;s--)if(i[s].event==t&&null!=i[s].time_consumed){null==i[s].msg_ext?i[s].msg_ext={}:i[s].msg_ext&&(i[s].msg_ext[o]=n);break}}else this.logger.warn("zd.aei.0 no events")}else this.logger.warn("zd.aei.0 no seq match")},e.prototype.addEventMsg=function(e,t,o,n){if(this.dataStatistics[e]){var i=this.dataStatistics[e].events;if(null!=i){for(var s=i.length-1;s>=0;s--)if(i[s].event==t){i[s][o]=n;break}}else this.logger.warn("zd.aem.0 no events")}else this.logger.warn("zd.aem.0 no seq match")},e.prototype.addEvent=function(e,t,o){this.dataStatistics[e]?this.dataStatistics[e].events&&(o?this.dataStatistics[e].events.push({event:t,event_time:Date.now(),msg_ext:o}):this.dataStatistics[e].events.push({event:t,event_time:Date.now()})):this.logger.warn("zd.ae.0 no seq match")},e.prototype.uploadReport=function(e,t,o,n){var i=this.dataStatistics[e];null!=i&&(t&&(i.event=t),i.time_consumed=Date.now()-i.event_time,o&&this.addMsgInfo(e,{error:o.code,message:o.message||o.msg+" "+(n||"")}),this.logger.report(i),delete this.dataStatistics[e])},e}();t.ZegoDataReport=i},function(e,t,o){"use strict";var n=this&&this.__assign||function(){return(n=Object.assign||function(e){for(var t,o=1,n=arguments.length;o<n;o++)for(var i in t=arguments[o])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.ZegoLogger=void 0;var i=o(0),s=o(2),r=o(1),a=o(6),c=function(){function e(e){this.logLevel=i.ENUM_LOG_LEVEL.INFO,this.logRemoteLevel=0,this.websocket=null,this.logUploadTimer=null,this.logUploadInterval=1e4,this.logCache=[],this.logCacheSend=[],this.logCacheMax=100,this.existUserID=!1,this.stateCenter=r.LoggerStateCenter.getInstance(),this.env=e}return e.prototype.setLogLevel=function(e){var t=i.ENUM_LOG_LEVEL[e];return void 0!==t&&(this.logLevel=t,!0)},e.prototype.setRemoteLogLevel=function(e){var t=i.ENUM_LOG_LEVEL[e];return void 0!==t&&(this.logRemoteLevel=t,!0)},e.prototype.setSessionInfo=function(e,t,o,n,i,s){this.appid=e,this.roomid=t,this.sessionid=o,this.userid=n,this.userName=i,this.version=s},e.prototype.report=function(e){var t=this.logReportParamList(i.ENUM_LOG_LEVEL.REPORT,e);this.logLevel!==i.ENUM_LOG_LEVEL.DISABLE&&this.logLevel<=i.ENUM_LOG_LEVEL.REPORT&&console.debug(t),this.RemoteLog(i.ENUM_LOG_LEVEL.REPORT,t,!0)},e.prototype.debug=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var o=this.logParamList(i.ENUM_LOG_LEVEL.DEBUG,e.join(""));this.logLevel!==i.ENUM_LOG_LEVEL.DISABLE&&this.logLevel<=i.ENUM_LOG_LEVEL.DEBUG&&console.debug(o),this.log(i.ENUM_LOG_LEVEL.DEBUG,o)},e.prototype.info=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var o=this.logParamList(i.ENUM_LOG_LEVEL.INFO,e.join(""));this.logLevel!==i.ENUM_LOG_LEVEL.DISABLE&&this.logLevel<=i.ENUM_LOG_LEVEL.INFO&&console.info(o),this.log(i.ENUM_LOG_LEVEL.INFO,o)},e.prototype.warn=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var o=this.logParamList(i.ENUM_LOG_LEVEL.WARN,e.join(""));this.logLevel!==i.ENUM_LOG_LEVEL.DISABLE&&this.logLevel<=i.ENUM_LOG_LEVEL.WARN&&console.warn(o),this.log(i.ENUM_LOG_LEVEL.WARN,o)},e.prototype.error=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var o=this.logParamList(i.ENUM_LOG_LEVEL.ERROR,e.join(""));this.logLevel!==i.ENUM_LOG_LEVEL.DISABLE&&this.logLevel<=i.ENUM_LOG_LEVEL.ERROR&&(console.error(o),window?this.stateCenter.debug&&window.alert(e.join("").substr(e.join("").indexOf(" ")+1,4500)):wx&&this.stateCenter.debug&&wx.showModal({title:"",content:e.join("").substr(e.join("").indexOf(" ")+1,4500)})),this.log(i.ENUM_LOG_LEVEL.ERROR,o)},e.prototype.log=function(e,t){this.logRemoteLevel!==i.ENUM_LOG_LEVEL.DISABLE&&this.logRemoteLevel<=e&&this.RemoteLog(e,t)},e.prototype.setLogServer=function(e){try{return e.startsWith("wss:")?(this.logType=i.ENUM_REMOTE_TYPE.WEBSOCKET,this.openWebSocketLogServer(e)):e.startsWith("https:")?(this.logType=i.ENUM_REMOTE_TYPE.HTTPS,this.openHttpsLogServer(e)):this.logType=i.ENUM_REMOTE_TYPE.DISABLE,!0}catch(e){return this.error(JSON.stringify(e)),!1}},e.prototype.stopLogServer=function(){this.logType==i.ENUM_REMOTE_TYPE.WEBSOCKET?this.stopWebSocketServer():this.logType==i.ENUM_REMOTE_TYPE.HTTPS&&(this.SendHttpsLog(),this.stopHttpsServer()),this.logType=i.ENUM_REMOTE_TYPE.DISABLE},e.prototype.stopWebSocketServer=function(){this.websocket&&(this.websocket.onclose=null,this.websocket.onerror=null,this.websocket.close(),this.websocket=null)},e.prototype.openHttpsLogServer=function(e){var t=this;this.url=e,e&&(this.stopHttpsServer(),this.logUploadTimer||(this.logUploadTimer=setInterval((function(){t.SendHttpsLog()}),this.logUploadInterval)))},e.prototype.stopHttpsServer=function(){this.logUploadTimer&&(clearInterval(this.logUploadTimer),this.logUploadTimer=null)},e.prototype.RemoteLog=function(e,t,o){if(void 0===o&&(o=!1),""!=this.url)if(this.logType==i.ENUM_REMOTE_TYPE.WEBSOCKET)this.RemoteWebSocketLog(e,t);else if(this.logType==i.ENUM_REMOTE_TYPE.HTTPS)this.RemoteHttpsLog(e,t,o);else if(this.logLevel!==i.ENUM_LOG_LEVEL.DISABLE&&this.logLevel<=e)for(this.logCacheSend.push(t);this.logCacheSend.length>this.logCacheMax;)this.logCacheSend.shift()},e.prototype.RemoteWebSocketLog=function(e,t){if("string"==typeof t&&t.length>4e3)console.info("log over maximum, ignore");else if(null==this.websocket||2==this.websocket.readyState||3==this.websocket.readyState){var o=this.url;this.url="",this.setLogServer(o),this.logCacheSend.length<this.logCacheMax&&this.logCacheSend.push(t)}else if(0==this.websocket.readyState)this.logCacheSend.length<this.logCacheMax&&this.logCacheSend.push(t);else if(1==this.websocket.readyState)if(this.logCacheSend.length>0){for(var i="",s=0;s<this.logCacheSend.length;s++){(i+this.logCacheSend[s]).length>4e3&&(this.websocket.send(i),i="");var r=JSON.parse(this.logCacheSend[s]);r=n(n({},r),{userid:r.userid||this.userid,roomid:r.roomid||this.roomid,userName:r.roomid||this.userName}),i=i+JSON.stringify(r)+"\n"}t=i+t,this.logCacheSend=[],this.websocket.send(t)}else this.websocket.send(t);else console.warn("wrong socket state:"+this.websocket.readyState),this.logCacheSend.length<this.logCacheMax&&this.logCacheSend.push(t)},e.prototype.RemoteHttpsLog=function(e,t,o){this.logCacheSend.push(t),(this.logCacheSend.length>=this.logCacheMax||!0===o)&&this.SendHttpsLog()},e.prototype.logParamList=function(e,t){var o=a.getCurrentTime(),n=[t.substr(0,t.indexOf(" "))||t,t.substr(t.indexOf(" ")+1,4500)||t],i={time:o,level:e,action:n[0],content:n[1],appid:this.appid,roomid:this.roomid,userid:this.userid,userName:this.userName,sessionid:this.sessionid};return JSON.stringify(i)},e.prototype.logReportParamList=function(e,t){var o=a.getCurrentTime();return t=n(n({},t),{time:o,level:e,console:this.env%2===i.ZEGO_ENV.BROWSER?"rtc":"xcx",appid:this.appid,room_id:this.roomid,roomid:this.roomid,userid:this.userid,id_name:this.userid,userName:this.userName,sessionid:this.sessionid,sdk_version:this.version,test_environment:this.stateCenter.testEnvironment,version:this.version,event_id:this.appid+"_"+this.userid+"_"+t.event_time+"_"+t.seq}),JSON.stringify(t)},e.prototype.openWebSocketLogServer=function(e){if(this.url!=e){if(this.url=e,!e)return;this.stopWebSocketServer(),this.websocket=s.createZegoWebSocket(e,this.env),this.websocket.onopen=function(){},this.websocket.onclose=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];console.warn("onclose   websocket error:",e)},this.websocket.onmessage=function(){},this.websocket.onerror=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];console.warn("open log websocket error:",e)}}},e.prototype.SendHttpsLog=function(){0!=this.logCacheSend.length&&(this.env%2===i.ZEGO_ENV.BROWSER?this.SendHttpsLogWeb():this.SendHttpsLogWeChatMini())},e.prototype.SendHttpsLogWeb=function(){var e=this,t=this.logCacheSend.join("\n"),o=new XMLHttpRequest;o.onreadystatechange=function(){if(4==o.readyState)if(200==o.status){if(0==o.responseText.length)return;try{var t=JSON.parse(o.responseText).interval;"number"==typeof t&&e.logUploadInterval!==t&&(e.timeInterval=t,e.openHttpsLogServer(e.url))}catch(e){console.log("send result failed "+e)}}else console.log("send failed "+o.status)},o.open("POST",this.url,!0),0==this.env?o.send(t):2==this.env&&(o.setRequestHeader("content-type","application/json"),o.send(JSON.stringify({user_id:this.userid,log:t}))),this.logCacheSend=[]},e.prototype.SendHttpsLogWeChatMini=function(){var e=this;!this.existUserID&&this.userid&&this.logCacheSend.forEach((function(t){Array.isArray(t)&&t.forEach((function(o,n){var i=JSON.parse(o);i&&""==JSON.parse(o).userid?(i.userid=e.userid,i.id_name=e.userid,t[n]=JSON.stringify(i)):e.existUserID=!0}))}));var t=this.logCacheSend.join("\n"),o=1==this.env?t:JSON.stringify({user_id:this.userid,log:t});wx.request({url:this.url,data:o,method:"POST",success:function(t){if(0!=t.data.length){var o=t&&t.data&&t.data.interval;"number"==typeof o&&e.logUploadInterval!==o&&(e.timeInterval=o,e.openHttpsLogServer(e.url))}},fail:function(e){console.log("send failed "+e.statusCode)}}),this.logCacheSend=[]},e}();t.ZegoLogger=c},function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getCurrentTime=t.getCurrentEnv=t.getBrowser=void 0;var n=o(0);t.getBrowser=function(){var e=window.navigator.userAgent,t=null!=window.ActiveXObject&&-1!=e.indexOf("MSIE"),o=-1!=e.indexOf("Firefox"),i=null!=window.opr,s=e.indexOf("Chrome")&&window.chrome,r=-1!=e.indexOf("Safari")&&-1!=e.indexOf("Version"),a=e.toLowerCase().match(/MicroMessenger/i)&&"micromessenger"===e.toLowerCase().match(/MicroMessenger/i)[0];return t?n.ZEGO_BROWSER_TYPE.IE:o?n.ZEGO_BROWSER_TYPE.FIREFOX:i?n.ZEGO_BROWSER_TYPE.OPERA:s?n.ZEGO_BROWSER_TYPE.CHROME:r?n.ZEGO_BROWSER_TYPE.SAFARI:a?n.ZEGO_BROWSER_TYPE.WEIXIN:n.ZEGO_BROWSER_TYPE.UNKOWN},t.getCurrentEnv=function(){var e=window.navigator.userAgent;return new Promise((function(t){-1==e.indexOf("MicroMessage")?t(n.ZEGO_ENV.BROWSER):wx.miniProgram.getEnv((function(e){e.miniprogram}))}))};var i=["00","01","02","03","04","05","06","07","08","09"];t.getCurrentTime=function(){var e=new Date;return[e.getFullYear()+"/",(i[e.getMonth()+1]||e.getMonth()+1)+"/",(i[e.getDate()]||e.getDate())+" ",(i[e.getHours()]||e.getHours())+":",(i[e.getMinutes()]||e.getMinutes())+":",i[e.getSeconds()]||e.getSeconds(),"."+e.getTime()%1e3].join("")}}])}));

/***/ }),

/***/ "./node_modules/@protobufjs/aspromise/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}


/***/ }),

/***/ "./node_modules/@protobufjs/base64/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};


/***/ }),

/***/ "./node_modules/@protobufjs/eventemitter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};


/***/ }),

/***/ "./node_modules/@protobufjs/float/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}


/***/ }),

/***/ "./node_modules/@protobufjs/inquire/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}


/***/ }),

/***/ "./node_modules/@protobufjs/pool/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}


/***/ }),

/***/ "./node_modules/@protobufjs/utf8/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};


/***/ }),

/***/ "./node_modules/crypto-js/aes.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/aes.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_48460__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_48460__(/*! ./core */ "./node_modules/crypto-js/core.js"), __nested_webpack_require_48460__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __nested_webpack_require_48460__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __nested_webpack_require_48460__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __nested_webpack_require_48460__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            var t;

	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));

/***/ }),

/***/ "./node_modules/crypto-js/cipher-core.js":
/*!***********************************************!*\
  !*** ./node_modules/crypto-js/cipher-core.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_57465__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_57465__(/*! ./core */ "./node_modules/crypto-js/core.js"), __nested_webpack_require_57465__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            var block;

	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            var modeCreator;

	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            var finalProcessedBlocks;

	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            var wordArray;

	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            var salt;

	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));

/***/ }),

/***/ "./node_modules/crypto-js/core.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/core.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_87317__) {

/* WEBPACK VAR INJECTION */(function(global) {;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native crypto in web worker (Browser)
	    if (typeof self !== 'undefined' && self.crypto) {
	        crypto = self.crypto;
	    }

	    // Native crypto from worker
	    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
	        crypto = globalThis.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof global !== 'undefined' && global.crypto) {
	        crypto = global.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __nested_webpack_require_87317__(/*! crypto */ 0);
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }());

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var j = 0; j < thatSigBytes; j += 4) {
	                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_87317__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/crypto-js/enc-base64.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-js/enc-base64.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_111288__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_111288__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              var bitsCombined = bits1 | bits2;
	              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),

/***/ "./node_modules/crypto-js/enc-hex.js":
/*!*******************************************!*\
  !*** ./node_modules/crypto-js/enc-hex.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_115541__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_115541__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Hex;

}));

/***/ }),

/***/ "./node_modules/crypto-js/enc-utf8.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/enc-utf8.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_116076__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_116076__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Utf8;

}));

/***/ }),

/***/ "./node_modules/crypto-js/evpkdf.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/evpkdf.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_116604__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_116604__(/*! ./core */ "./node_modules/crypto-js/core.js"), __nested_webpack_require_116604__(/*! ./sha1 */ "./node_modules/crypto-js/sha1.js"), __nested_webpack_require_116604__(/*! ./hmac */ "./node_modules/crypto-js/hmac.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            var block;

	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));

/***/ }),

/***/ "./node_modules/crypto-js/hmac.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/hmac.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_120841__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_120841__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),

/***/ "./node_modules/crypto-js/lib-typedarrays.js":
/*!***************************************************!*\
  !*** ./node_modules/crypto-js/lib-typedarrays.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_125029__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_125029__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));

/***/ }),

/***/ "./node_modules/crypto-js/md5.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/md5.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_127413__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_127413__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),

/***/ "./node_modules/crypto-js/sha1.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/sha1.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_136991__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_136991__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));

/***/ }),

/***/ "./node_modules/js-base64/base64.mjs":
/*!*******************************************!*\
  !*** ./node_modules/js-base64/base64.mjs ***!
  \*******************************************/
/*! exports provided: version, VERSION, atob, atobPolyfill, btoa, btoaPolyfill, fromBase64, toBase64, utob, encode, encodeURI, encodeURL, btou, decode, isValid, fromUint8Array, toUint8Array, extendString, extendUint8Array, extendBuiltins, Base64 */
/***/ (function(__webpack_module__, __webpack_exports__, __nested_webpack_require_141468__) {

"use strict";
__nested_webpack_require_141468__.r(__webpack_exports__);
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "version", function() { return version; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "atob", function() { return _atob; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "atobPolyfill", function() { return atobPolyfill; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "btoa", function() { return _btoa; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "btoaPolyfill", function() { return btoaPolyfill; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "fromBase64", function() { return decode; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "toBase64", function() { return encode; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "utob", function() { return utob; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "encode", function() { return encode; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "encodeURI", function() { return encodeURI; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "encodeURL", function() { return encodeURI; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "btou", function() { return btou; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "decode", function() { return decode; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "isValid", function() { return isValid; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "fromUint8Array", function() { return fromUint8Array; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "toUint8Array", function() { return toUint8Array; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "extendString", function() { return extendString; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "extendUint8Array", function() { return extendUint8Array; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "extendBuiltins", function() { return extendBuiltins; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "Base64", function() { return gBase64; });
/**
 *  base64.ts
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 *
 * @author Dan Kogai (https://github.com/dankogai)
 */
const version = '3.6.0';
/**
 * @deprecated use lowercase `version`.
 */
const VERSION = version;
const _hasatob = typeof atob === 'function';
const _hasbtoa = typeof btoa === 'function';
const _hasBuffer = typeof Buffer === 'function';
const _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;
const _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;
const b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
const b64chs = [...b64ch];
const b64tab = ((a) => {
    let tab = {};
    a.forEach((c, i) => tab[c] = i);
    return tab;
})(b64chs);
const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
const _fromCC = String.fromCharCode.bind(String);
const _U8Afrom = typeof Uint8Array.from === 'function'
    ? Uint8Array.from.bind(Uint8Array)
    : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
const _mkUriSafe = (src) => src
    .replace(/[+\/]/g, (m0) => m0 == '+' ? '-' : '_')
    .replace(/=+$/m, '');
const _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, '');
/**
 * polyfill version of `btoa`
 */
const btoaPolyfill = (bin) => {
    // console.log('polyfilled');
    let u32, c0, c1, c2, asc = '';
    const pad = bin.length % 3;
    for (let i = 0; i < bin.length;) {
        if ((c0 = bin.charCodeAt(i++)) > 255 ||
            (c1 = bin.charCodeAt(i++)) > 255 ||
            (c2 = bin.charCodeAt(i++)) > 255)
            throw new TypeError('invalid character found');
        u32 = (c0 << 16) | (c1 << 8) | c2;
        asc += b64chs[u32 >> 18 & 63]
            + b64chs[u32 >> 12 & 63]
            + b64chs[u32 >> 6 & 63]
            + b64chs[u32 & 63];
    }
    return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
/**
 * does what `window.btoa` of web browsers do.
 * @param {String} bin binary string
 * @returns {string} Base64-encoded string
 */
const _btoa = _hasbtoa ? (bin) => btoa(bin)
    : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')
        : btoaPolyfill;
const _fromUint8Array = _hasBuffer
    ? (u8a) => Buffer.from(u8a).toString('base64')
    : (u8a) => {
        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
        const maxargs = 0x1000;
        let strs = [];
        for (let i = 0, l = u8a.length; i < l; i += maxargs) {
            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
        }
        return _btoa(strs.join(''));
    };
/**
 * converts a Uint8Array to a Base64 string.
 * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5
 * @returns {string} Base64 string
 */
const fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const utob = (src: string) => unescape(encodeURIComponent(src));
// reverting good old fationed regexp
const cb_utob = (c) => {
    if (c.length < 2) {
        var cc = c.charCodeAt(0);
        return cc < 0x80 ? c
            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))
                + _fromCC(0x80 | (cc & 0x3f)))
                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))
                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
                    + _fromCC(0x80 | (cc & 0x3f)));
    }
    else {
        var cc = 0x10000
            + (c.charCodeAt(0) - 0xD800) * 0x400
            + (c.charCodeAt(1) - 0xDC00);
        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))
            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))
            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
            + _fromCC(0x80 | (cc & 0x3f)));
    }
};
const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-8 string
 * @returns {string} UTF-16 string
 */
const utob = (u) => u.replace(re_utob, cb_utob);
//
const _encode = _hasBuffer
    ? (s) => Buffer.from(s, 'utf8').toString('base64')
    : _TE
        ? (s) => _fromUint8Array(_TE.encode(s))
        : (s) => _btoa(utob(s));
/**
 * converts a UTF-8-encoded string to a Base64 string.
 * @param {boolean} [urlsafe] if `true` make the result URL-safe
 * @returns {string} Base64 string
 */
const encode = (src, urlsafe = false) => urlsafe
    ? _mkUriSafe(_encode(src))
    : _encode(src);
/**
 * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.
 * @returns {string} Base64 string
 */
const encodeURI = (src) => encode(src, true);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const btou = (src: string) => decodeURIComponent(escape(src));
// reverting good old fationed regexp
const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
const cb_btou = (cccc) => {
    switch (cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                | ((0x3f & cccc.charCodeAt(1)) << 12)
                | ((0x3f & cccc.charCodeAt(2)) << 6)
                | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;
            return (_fromCC((offset >>> 10) + 0xD800)
                + _fromCC((offset & 0x3FF) + 0xDC00));
        case 3:
            return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)
                | ((0x3f & cccc.charCodeAt(1)) << 6)
                | (0x3f & cccc.charCodeAt(2)));
        default:
            return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)
                | (0x3f & cccc.charCodeAt(1)));
    }
};
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-16 string
 * @returns {string} UTF-8 string
 */
const btou = (b) => b.replace(re_btou, cb_btou);
/**
 * polyfill version of `atob`
 */
const atobPolyfill = (asc) => {
    // console.log('polyfilled');
    asc = asc.replace(/\s+/g, '');
    if (!b64re.test(asc))
        throw new TypeError('malformed base64.');
    asc += '=='.slice(2 - (asc.length & 3));
    let u24, bin = '', r1, r2;
    for (let i = 0; i < asc.length;) {
        u24 = b64tab[asc.charAt(i++)] << 18
            | b64tab[asc.charAt(i++)] << 12
            | (r1 = b64tab[asc.charAt(i++)]) << 6
            | (r2 = b64tab[asc.charAt(i++)]);
        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)
            : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)
                : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
    }
    return bin;
};
/**
 * does what `window.atob` of web browsers do.
 * @param {String} asc Base64-encoded string
 * @returns {string} binary string
 */
const _atob = _hasatob ? (asc) => atob(_tidyB64(asc))
    : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')
        : atobPolyfill;
//
const _toUint8Array = _hasBuffer
    ? (a) => _U8Afrom(Buffer.from(a, 'base64'))
    : (a) => _U8Afrom(_atob(a), c => c.charCodeAt(0));
/**
 * converts a Base64 string to a Uint8Array.
 */
const toUint8Array = (a) => _toUint8Array(_unURI(a));
//
const _decode = _hasBuffer
    ? (a) => Buffer.from(a, 'base64').toString('utf8')
    : _TD
        ? (a) => _TD.decode(_toUint8Array(a))
        : (a) => btou(_atob(a));
const _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));
/**
 * converts a Base64 string to a UTF-8 string.
 * @param {String} src Base64 string.  Both normal and URL-safe are supported
 * @returns {string} UTF-8 string
 */
const decode = (src) => _decode(_unURI(src));
/**
 * check if a value is a valid Base64 string
 * @param {String} src a value to check
  */
const isValid = (src) => {
    if (typeof src !== 'string')
        return false;
    const s = src.replace(/\s+/g, '').replace(/=+$/, '');
    return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
//
const _noEnum = (v) => {
    return {
        value: v, enumerable: false, writable: true, configurable: true
    };
};
/**
 * extend String.prototype with relevant methods
 */
const extendString = function () {
    const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
    _add('fromBase64', function () { return decode(this); });
    _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });
    _add('toBase64URI', function () { return encode(this, true); });
    _add('toBase64URL', function () { return encode(this, true); });
    _add('toUint8Array', function () { return toUint8Array(this); });
};
/**
 * extend Uint8Array.prototype with relevant methods
 */
const extendUint8Array = function () {
    const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
    _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });
    _add('toBase64URI', function () { return fromUint8Array(this, true); });
    _add('toBase64URL', function () { return fromUint8Array(this, true); });
};
/**
 * extend Builtin prototypes with relevant methods
 */
const extendBuiltins = () => {
    extendString();
    extendUint8Array();
};
const gBase64 = {
    version: version,
    VERSION: VERSION,
    atob: _atob,
    atobPolyfill: atobPolyfill,
    btoa: _btoa,
    btoaPolyfill: btoaPolyfill,
    fromBase64: decode,
    toBase64: encode,
    encode: encode,
    encodeURI: encodeURI,
    encodeURL: encodeURI,
    utob: utob,
    btou: btou,
    decode: decode,
    isValid: isValid,
    fromUint8Array: fromUint8Array,
    toUint8Array: toUint8Array,
    extendString: extendString,
    extendUint8Array: extendUint8Array,
    extendBuiltins: extendBuiltins,
};
// makecjs:CUT //




















// and finally,



/***/ }),

/***/ "./node_modules/localforage/dist/localforage.js":
/*!******************************************************!*\
  !*** ./node_modules/localforage/dist/localforage.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_154248__) {

/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/*!
    localForage -- Offline Storage, Improved
    Version 1.9.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw (f.code="MODULE_NOT_FOUND", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
'use strict';
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],2:[function(_dereq_,module,exports){
'use strict';
var immediate = _dereq_(1);

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
    typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"1":1}],3:[function(_dereq_,module,exports){
(function (global){
'use strict';
if (typeof global.Promise !== 'function') {
  global.Promise = _dereq_(2);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"2":2}],4:[function(_dereq_,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getIDB() {
    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */
    try {
        if (typeof indexedDB !== 'undefined') {
            return indexedDB;
        }
        if (typeof webkitIndexedDB !== 'undefined') {
            return webkitIndexedDB;
        }
        if (typeof mozIndexedDB !== 'undefined') {
            return mozIndexedDB;
        }
        if (typeof OIndexedDB !== 'undefined') {
            return OIndexedDB;
        }
        if (typeof msIndexedDB !== 'undefined') {
            return msIndexedDB;
        }
    } catch (e) {
        return;
    }
}

var idb = getIDB();

function isIndexedDBValid() {
    try {
        // Initialize IndexedDB; fall back to vendor-prefixed versions
        // if needed.
        if (!idb || !idb.open) {
            return false;
        }
        // We mimic PouchDB here;
        //
        // We test for openDatabase because IE Mobile identifies itself
        // as Safari. Oh the lulz...
        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);

        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;

        // Safari <10.1 does not meet our requirements for IDB support
        // (see: https://github.com/pouchdb/pouchdb/issues/5572).
        // Safari 10.1 shipped with fetch, we can use that to detect it.
        // Note: this creates issues with `window.fetch` polyfills and
        // overrides; see:
        // https://github.com/localForage/localForage/issues/856
        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&
        // some outdated implementations of IDB that appear on Samsung
        // and HTC Android devices <4.4 are missing IDBKeyRange
        // See: https://github.com/mozilla/localForage/issues/128
        // See: https://github.com/mozilla/localForage/issues/272
        typeof IDBKeyRange !== 'undefined';
    } catch (e) {
        return false;
    }
}

// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor. (i.e.
// old QtWebKit versions, at least).
// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor. (i.e.
// old QtWebKit versions, at least).
function createBlob(parts, properties) {
    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
    parts = parts || [];
    properties = properties || {};
    try {
        return new Blob(parts, properties);
    } catch (e) {
        if (e.name !== 'TypeError') {
            throw e;
        }
        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;
        var builder = new Builder();
        for (var i = 0; i < parts.length; i += 1) {
            builder.append(parts[i]);
        }
        return builder.getBlob(properties.type);
    }
}

// This is CommonJS because lie is an external dependency, so Rollup
// can just ignore it.
if (typeof Promise === 'undefined') {
    // In the "nopromises" build this will just throw if you don't have
    // a global promise object, but it would throw anyway later.
    _dereq_(3);
}
var Promise$1 = Promise;

function executeCallback(promise, callback) {
    if (callback) {
        promise.then(function (result) {
            callback(null, result);
        }, function (error) {
            callback(error);
        });
    }
}

function executeTwoCallbacks(promise, callback, errorCallback) {
    if (typeof callback === 'function') {
        promise.then(callback);
    }

    if (typeof errorCallback === 'function') {
        promise["catch"](errorCallback);
    }
}

function normalizeKey(key) {
    // Cast the key to a string, as that's all we can set as a key.
    if (typeof key !== 'string') {
        console.warn(key + ' used as a key, but it is not a string.');
        key = String(key);
    }

    return key;
}

function getCallback() {
    if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {
        return arguments[arguments.length - 1];
    }
}

// Some code originally from async_storage.js in
// [Gaia](https://github.com/mozilla-b2g/gaia).

var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';
var supportsBlobs = void 0;
var dbContexts = {};
var toString = Object.prototype.toString;

// Transaction Modes
var READ_ONLY = 'readonly';
var READ_WRITE = 'readwrite';

// Transform a binary string to an array buffer, because otherwise
// weird stuff happens when you try to work with the binary string directly.
// It is known.
// From http://stackoverflow.com/questions/14967647/ (continues on next line)
// encode-decode-image-with-base64-breaks-image (2013-04-21)
function _binStringToArrayBuffer(bin) {
    var length = bin.length;
    var buf = new ArrayBuffer(length);
    var arr = new Uint8Array(buf);
    for (var i = 0; i < length; i++) {
        arr[i] = bin.charCodeAt(i);
    }
    return buf;
}

//
// Blobs are not supported in all versions of IndexedDB, notably
// Chrome <37 and Android <5. In those versions, storing a blob will throw.
//
// Various other blob bugs exist in Chrome v37-42 (inclusive).
// Detecting them is expensive and confusing to users, and Chrome 37-42
// is at very low usage worldwide, so we do a hacky userAgent check instead.
//
// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
//
// Code borrowed from PouchDB. See:
// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js
//
function _checkBlobSupportWithoutCaching(idb) {
    return new Promise$1(function (resolve) {
        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
        var blob = createBlob(['']);
        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');

        txn.onabort = function (e) {
            // If the transaction aborts now its due to not being able to
            // write to the database, likely due to the disk being full
            e.preventDefault();
            e.stopPropagation();
            resolve(false);
        };

        txn.oncomplete = function () {
            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
            var matchedEdge = navigator.userAgent.match(/Edge\//);
            // MS Edge pretends to be Chrome 42:
            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
        };
    })["catch"](function () {
        return false; // error, so assume unsupported
    });
}

function _checkBlobSupport(idb) {
    if (typeof supportsBlobs === 'boolean') {
        return Promise$1.resolve(supportsBlobs);
    }
    return _checkBlobSupportWithoutCaching(idb).then(function (value) {
        supportsBlobs = value;
        return supportsBlobs;
    });
}

function _deferReadiness(dbInfo) {
    var dbContext = dbContexts[dbInfo.name];

    // Create a deferred object representing the current database operation.
    var deferredOperation = {};

    deferredOperation.promise = new Promise$1(function (resolve, reject) {
        deferredOperation.resolve = resolve;
        deferredOperation.reject = reject;
    });

    // Enqueue the deferred operation.
    dbContext.deferredOperations.push(deferredOperation);

    // Chain its promise to the database readiness.
    if (!dbContext.dbReady) {
        dbContext.dbReady = deferredOperation.promise;
    } else {
        dbContext.dbReady = dbContext.dbReady.then(function () {
            return deferredOperation.promise;
        });
    }
}

function _advanceReadiness(dbInfo) {
    var dbContext = dbContexts[dbInfo.name];

    // Dequeue a deferred operation.
    var deferredOperation = dbContext.deferredOperations.pop();

    // Resolve its promise (which is part of the database readiness
    // chain of promises).
    if (deferredOperation) {
        deferredOperation.resolve();
        return deferredOperation.promise;
    }
}

function _rejectReadiness(dbInfo, err) {
    var dbContext = dbContexts[dbInfo.name];

    // Dequeue a deferred operation.
    var deferredOperation = dbContext.deferredOperations.pop();

    // Reject its promise (which is part of the database readiness
    // chain of promises).
    if (deferredOperation) {
        deferredOperation.reject(err);
        return deferredOperation.promise;
    }
}

function _getConnection(dbInfo, upgradeNeeded) {
    return new Promise$1(function (resolve, reject) {
        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();

        if (dbInfo.db) {
            if (upgradeNeeded) {
                _deferReadiness(dbInfo);
                dbInfo.db.close();
            } else {
                return resolve(dbInfo.db);
            }
        }

        var dbArgs = [dbInfo.name];

        if (upgradeNeeded) {
            dbArgs.push(dbInfo.version);
        }

        var openreq = idb.open.apply(idb, dbArgs);

        if (upgradeNeeded) {
            openreq.onupgradeneeded = function (e) {
                var db = openreq.result;
                try {
                    db.createObjectStore(dbInfo.storeName);
                    if (e.oldVersion <= 1) {
                        // Added when support for blob shims was added
                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                    }
                } catch (ex) {
                    if (ex.name === 'ConstraintError') {
                        console.warn('The database "' + dbInfo.name + '"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                    } else {
                        throw ex;
                    }
                }
            };
        }

        openreq.onerror = function (e) {
            e.preventDefault();
            reject(openreq.error);
        };

        openreq.onsuccess = function () {
            resolve(openreq.result);
            _advanceReadiness(dbInfo);
        };
    });
}

function _getOriginalConnection(dbInfo) {
    return _getConnection(dbInfo, false);
}

function _getUpgradedConnection(dbInfo) {
    return _getConnection(dbInfo, true);
}

function _isUpgradeNeeded(dbInfo, defaultVersion) {
    if (!dbInfo.db) {
        return true;
    }

    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
    var isDowngrade = dbInfo.version < dbInfo.db.version;
    var isUpgrade = dbInfo.version > dbInfo.db.version;

    if (isDowngrade) {
        // If the version is not the default one
        // then warn for impossible downgrade.
        if (dbInfo.version !== defaultVersion) {
            console.warn('The database "' + dbInfo.name + '"' + " can't be downgraded from version " + dbInfo.db.version + ' to version ' + dbInfo.version + '.');
        }
        // Align the versions to prevent errors.
        dbInfo.version = dbInfo.db.version;
    }

    if (isUpgrade || isNewStore) {
        // If the store is new then increment the version (if needed).
        // This will trigger an "upgradeneeded" event which is required
        // for creating a store.
        if (isNewStore) {
            var incVersion = dbInfo.db.version + 1;
            if (incVersion > dbInfo.version) {
                dbInfo.version = incVersion;
            }
        }

        return true;
    }

    return false;
}

// encode a blob for indexeddb engines that don't support blobs
function _encodeBlob(blob) {
    return new Promise$1(function (resolve, reject) {
        var reader = new FileReader();
        reader.onerror = reject;
        reader.onloadend = function (e) {
            var base64 = btoa(e.target.result || '');
            resolve({
                __local_forage_encoded_blob: true,
                data: base64,
                type: blob.type
            });
        };
        reader.readAsBinaryString(blob);
    });
}

// decode an encoded blob
function _decodeBlob(encodedBlob) {
    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
    return createBlob([arrayBuff], { type: encodedBlob.type });
}

// is this one of our fancy encoded blobs?
function _isEncodedBlob(value) {
    return value && value.__local_forage_encoded_blob;
}

// Specialize the default `ready()` function by making it dependent
// on the current database operations. Thus, the driver will be actually
// ready when it's been initialized (default) *and* there are no pending
// operations on the database (initiated by some other instances).
function _fullyReady(callback) {
    var self = this;

    var promise = self._initReady().then(function () {
        var dbContext = dbContexts[self._dbInfo.name];

        if (dbContext && dbContext.dbReady) {
            return dbContext.dbReady;
        }
    });

    executeTwoCallbacks(promise, callback, callback);
    return promise;
}

// Try to establish a new db connection to replace the
// current one which is broken (i.e. experiencing
// InvalidStateError while creating a transaction).
function _tryReconnect(dbInfo) {
    _deferReadiness(dbInfo);

    var dbContext = dbContexts[dbInfo.name];
    var forages = dbContext.forages;

    for (var i = 0; i < forages.length; i++) {
        var forage = forages[i];
        if (forage._dbInfo.db) {
            forage._dbInfo.db.close();
            forage._dbInfo.db = null;
        }
    }
    dbInfo.db = null;

    return _getOriginalConnection(dbInfo).then(function (db) {
        dbInfo.db = db;
        if (_isUpgradeNeeded(dbInfo)) {
            // Reopen the database for upgrading.
            return _getUpgradedConnection(dbInfo);
        }
        return db;
    }).then(function (db) {
        // store the latest db reference
        // in case the db was upgraded
        dbInfo.db = dbContext.db = db;
        for (var i = 0; i < forages.length; i++) {
            forages[i]._dbInfo.db = db;
        }
    })["catch"](function (err) {
        _rejectReadiness(dbInfo, err);
        throw err;
    });
}

// FF doesn't like Promises (micro-tasks) and IDDB store operations,
// so we have to do it with callbacks
function createTransaction(dbInfo, mode, callback, retries) {
    if (retries === undefined) {
        retries = 1;
    }

    try {
        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
        callback(null, tx);
    } catch (err) {
        if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {
            return Promise$1.resolve().then(function () {
                if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                    // increase the db version, to create the new ObjectStore
                    if (dbInfo.db) {
                        dbInfo.version = dbInfo.db.version + 1;
                    }
                    // Reopen the database for upgrading.
                    return _getUpgradedConnection(dbInfo);
                }
            }).then(function () {
                return _tryReconnect(dbInfo).then(function () {
                    createTransaction(dbInfo, mode, callback, retries - 1);
                });
            })["catch"](callback);
        }

        callback(err);
    }
}

function createDbContext() {
    return {
        // Running localForages sharing a database.
        forages: [],
        // Shared database.
        db: null,
        // Database readiness (promise).
        dbReady: null,
        // Deferred operations on the database.
        deferredOperations: []
    };
}

// Open the IndexedDB database (automatically creates one if one didn't
// previously exist), using any options set in the config.
function _initStorage(options) {
    var self = this;
    var dbInfo = {
        db: null
    };

    if (options) {
        for (var i in options) {
            dbInfo[i] = options[i];
        }
    }

    // Get the current context of the database;
    var dbContext = dbContexts[dbInfo.name];

    // ...or create a new context.
    if (!dbContext) {
        dbContext = createDbContext();
        // Register the new context in the global container.
        dbContexts[dbInfo.name] = dbContext;
    }

    // Register itself as a running localForage in the current context.
    dbContext.forages.push(self);

    // Replace the default `ready()` function with the specialized one.
    if (!self._initReady) {
        self._initReady = self.ready;
        self.ready = _fullyReady;
    }

    // Create an array of initialization states of the related localForages.
    var initPromises = [];

    function ignoreErrors() {
        // Don't handle errors here,
        // just makes sure related localForages aren't pending.
        return Promise$1.resolve();
    }

    for (var j = 0; j < dbContext.forages.length; j++) {
        var forage = dbContext.forages[j];
        if (forage !== self) {
            // Don't wait for itself...
            initPromises.push(forage._initReady()["catch"](ignoreErrors));
        }
    }

    // Take a snapshot of the related localForages.
    var forages = dbContext.forages.slice(0);

    // Initialize the connection process only when
    // all the related localForages aren't pending.
    return Promise$1.all(initPromises).then(function () {
        dbInfo.db = dbContext.db;
        // Get the connection or open a new one without upgrade.
        return _getOriginalConnection(dbInfo);
    }).then(function (db) {
        dbInfo.db = db;
        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {
            // Reopen the database for upgrading.
            return _getUpgradedConnection(dbInfo);
        }
        return db;
    }).then(function (db) {
        dbInfo.db = dbContext.db = db;
        self._dbInfo = dbInfo;
        // Share the final connection amongst related localForages.
        for (var k = 0; k < forages.length; k++) {
            var forage = forages[k];
            if (forage !== self) {
                // Self is already up-to-date.
                forage._dbInfo.db = dbInfo.db;
                forage._dbInfo.version = dbInfo.version;
            }
        }
    });
}

function getItem(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.get(key);

                    req.onsuccess = function () {
                        var value = req.result;
                        if (value === undefined) {
                            value = null;
                        }
                        if (_isEncodedBlob(value)) {
                            value = _decodeBlob(value);
                        }
                        resolve(value);
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Iterate over all items stored in database.
function iterate(iterator, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.openCursor();
                    var iterationNumber = 1;

                    req.onsuccess = function () {
                        var cursor = req.result;

                        if (cursor) {
                            var value = cursor.value;
                            if (_isEncodedBlob(value)) {
                                value = _decodeBlob(value);
                            }
                            var result = iterator(value, cursor.key, iterationNumber++);

                            // when the iterator callback returns any
                            // (non-`undefined`) value, then we stop
                            // the iteration immediately
                            if (result !== void 0) {
                                resolve(result);
                            } else {
                                cursor["continue"]();
                            }
                        } else {
                            resolve();
                        }
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);

    return promise;
}

function setItem(key, value, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        var dbInfo;
        self.ready().then(function () {
            dbInfo = self._dbInfo;
            if (toString.call(value) === '[object Blob]') {
                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {
                    if (blobSupport) {
                        return value;
                    }
                    return _encodeBlob(value);
                });
            }
            return value;
        }).then(function (value) {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);

                    // The reason we don't _save_ null is because IE 10 does
                    // not support saving the `null` type in IndexedDB. How
                    // ironic, given the bug below!
                    // See: https://github.com/mozilla/localForage/issues/161
                    if (value === null) {
                        value = undefined;
                    }

                    var req = store.put(value, key);

                    transaction.oncomplete = function () {
                        // Cast to undefined so the value passed to
                        // callback/promise is the same as what one would get out
                        // of `getItem()` later. This leads to some weirdness
                        // (setItem('foo', undefined) will return `null`), but
                        // it's not my fault localStorage is our baseline and that
                        // it's weird.
                        if (value === undefined) {
                            value = null;
                        }

                        resolve(value);
                    };
                    transaction.onabort = transaction.onerror = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function removeItem(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    // We use a Grunt task to make this safe for IE and some
                    // versions of Android (including those used by Cordova).
                    // Normally IE won't like `.delete()` and will insist on
                    // using `['delete']()`, but we have a build step that
                    // fixes this for us now.
                    var req = store["delete"](key);
                    transaction.oncomplete = function () {
                        resolve();
                    };

                    transaction.onerror = function () {
                        reject(req.error);
                    };

                    // The request will be also be aborted if we've exceeded our storage
                    // space.
                    transaction.onabort = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function clear(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.clear();

                    transaction.oncomplete = function () {
                        resolve();
                    };

                    transaction.onabort = transaction.onerror = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function length(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.count();

                    req.onsuccess = function () {
                        resolve(req.result);
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function key(n, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        if (n < 0) {
            resolve(null);

            return;
        }

        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var advanced = false;
                    var req = store.openKeyCursor();

                    req.onsuccess = function () {
                        var cursor = req.result;
                        if (!cursor) {
                            // this means there weren't enough keys
                            resolve(null);

                            return;
                        }

                        if (n === 0) {
                            // We have the first key, return it if that's what they
                            // wanted.
                            resolve(cursor.key);
                        } else {
                            if (!advanced) {
                                // Otherwise, ask the cursor to skip ahead n
                                // records.
                                advanced = true;
                                cursor.advance(n);
                            } else {
                                // When we get here, we've got the nth key.
                                resolve(cursor.key);
                            }
                        }
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function keys(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.openKeyCursor();
                    var keys = [];

                    req.onsuccess = function () {
                        var cursor = req.result;

                        if (!cursor) {
                            resolve(keys);
                            return;
                        }

                        keys.push(cursor.key);
                        cursor["continue"]();
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function dropInstance(options, callback) {
    callback = getCallback.apply(this, arguments);

    var currentConfig = this.config();
    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;

        var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {
            var dbContext = dbContexts[options.name];
            var forages = dbContext.forages;
            dbContext.db = db;
            for (var i = 0; i < forages.length; i++) {
                forages[i]._dbInfo.db = db;
            }
            return db;
        });

        if (!options.storeName) {
            promise = dbPromise.then(function (db) {
                _deferReadiness(options);

                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;

                db.close();
                for (var i = 0; i < forages.length; i++) {
                    var forage = forages[i];
                    forage._dbInfo.db = null;
                }

                var dropDBPromise = new Promise$1(function (resolve, reject) {
                    var req = idb.deleteDatabase(options.name);

                    req.onerror = req.onblocked = function (err) {
                        var db = req.result;
                        if (db) {
                            db.close();
                        }
                        reject(err);
                    };

                    req.onsuccess = function () {
                        var db = req.result;
                        if (db) {
                            db.close();
                        }
                        resolve(db);
                    };
                });

                return dropDBPromise.then(function (db) {
                    dbContext.db = db;
                    for (var i = 0; i < forages.length; i++) {
                        var _forage = forages[i];
                        _advanceReadiness(_forage._dbInfo);
                    }
                })["catch"](function (err) {
                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                    throw err;
                });
            });
        } else {
            promise = dbPromise.then(function (db) {
                if (!db.objectStoreNames.contains(options.storeName)) {
                    return;
                }

                var newVersion = db.version + 1;

                _deferReadiness(options);

                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;

                db.close();
                for (var i = 0; i < forages.length; i++) {
                    var forage = forages[i];
                    forage._dbInfo.db = null;
                    forage._dbInfo.version = newVersion;
                }

                var dropObjectPromise = new Promise$1(function (resolve, reject) {
                    var req = idb.open(options.name, newVersion);

                    req.onerror = function (err) {
                        var db = req.result;
                        db.close();
                        reject(err);
                    };

                    req.onupgradeneeded = function () {
                        var db = req.result;
                        db.deleteObjectStore(options.storeName);
                    };

                    req.onsuccess = function () {
                        var db = req.result;
                        db.close();
                        resolve(db);
                    };
                });

                return dropObjectPromise.then(function (db) {
                    dbContext.db = db;
                    for (var j = 0; j < forages.length; j++) {
                        var _forage2 = forages[j];
                        _forage2._dbInfo.db = db;
                        _advanceReadiness(_forage2._dbInfo);
                    }
                })["catch"](function (err) {
                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                    throw err;
                });
            });
        }
    }

    executeCallback(promise, callback);
    return promise;
}

var asyncStorage = {
    _driver: 'asyncStorage',
    _initStorage: _initStorage,
    _support: isIndexedDBValid(),
    iterate: iterate,
    getItem: getItem,
    setItem: setItem,
    removeItem: removeItem,
    clear: clear,
    length: length,
    key: key,
    keys: keys,
    dropInstance: dropInstance
};

function isWebSQLValid() {
    return typeof openDatabase === 'function';
}

// Sadly, the best way to save binary data in WebSQL/localStorage is serializing
// it to Base64, so this is how we store it to prevent very strange errors with less
// verbose ways of binary <-> string data storage.
var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

var BLOB_TYPE_PREFIX = '~~local_forage_type~';
var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;

var SERIALIZED_MARKER = '__lfsc__:';
var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;

// OMG the serializations!
var TYPE_ARRAYBUFFER = 'arbf';
var TYPE_BLOB = 'blob';
var TYPE_INT8ARRAY = 'si08';
var TYPE_UINT8ARRAY = 'ui08';
var TYPE_UINT8CLAMPEDARRAY = 'uic8';
var TYPE_INT16ARRAY = 'si16';
var TYPE_INT32ARRAY = 'si32';
var TYPE_UINT16ARRAY = 'ur16';
var TYPE_UINT32ARRAY = 'ui32';
var TYPE_FLOAT32ARRAY = 'fl32';
var TYPE_FLOAT64ARRAY = 'fl64';
var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;

var toString$1 = Object.prototype.toString;

function stringToBuffer(serializedString) {
    // Fill the string into a ArrayBuffer.
    var bufferLength = serializedString.length * 0.75;
    var len = serializedString.length;
    var i;
    var p = 0;
    var encoded1, encoded2, encoded3, encoded4;

    if (serializedString[serializedString.length - 1] === '=') {
        bufferLength--;
        if (serializedString[serializedString.length - 2] === '=') {
            bufferLength--;
        }
    }

    var buffer = new ArrayBuffer(bufferLength);
    var bytes = new Uint8Array(buffer);

    for (i = 0; i < len; i += 4) {
        encoded1 = BASE_CHARS.indexOf(serializedString[i]);
        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);

        /*jslint bitwise: true */
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return buffer;
}

// Converts a buffer to a string to store, serialized, in the backend
// storage library.
function bufferToString(buffer) {
    // base64-arraybuffer
    var bytes = new Uint8Array(buffer);
    var base64String = '';
    var i;

    for (i = 0; i < bytes.length; i += 3) {
        /*jslint bitwise: true */
        base64String += BASE_CHARS[bytes[i] >> 2];
        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
        base64String += BASE_CHARS[bytes[i + 2] & 63];
    }

    if (bytes.length % 3 === 2) {
        base64String = base64String.substring(0, base64String.length - 1) + '=';
    } else if (bytes.length % 3 === 1) {
        base64String = base64String.substring(0, base64String.length - 2) + '==';
    }

    return base64String;
}

// Serialize a value, afterwards executing a callback (which usually
// instructs the `setItem()` callback/promise to be executed). This is how
// we store binary data with localStorage.
function serialize(value, callback) {
    var valueType = '';
    if (value) {
        valueType = toString$1.call(value);
    }

    // Cannot use `value instanceof ArrayBuffer` or such here, as these
    // checks fail when running the tests using casper.js...
    //
    // TODO: See why those tests fail and use a better solution.
    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {
        // Convert binary arrays to a string and prefix the string with
        // a special marker.
        var buffer;
        var marker = SERIALIZED_MARKER;

        if (value instanceof ArrayBuffer) {
            buffer = value;
            marker += TYPE_ARRAYBUFFER;
        } else {
            buffer = value.buffer;

            if (valueType === '[object Int8Array]') {
                marker += TYPE_INT8ARRAY;
            } else if (valueType === '[object Uint8Array]') {
                marker += TYPE_UINT8ARRAY;
            } else if (valueType === '[object Uint8ClampedArray]') {
                marker += TYPE_UINT8CLAMPEDARRAY;
            } else if (valueType === '[object Int16Array]') {
                marker += TYPE_INT16ARRAY;
            } else if (valueType === '[object Uint16Array]') {
                marker += TYPE_UINT16ARRAY;
            } else if (valueType === '[object Int32Array]') {
                marker += TYPE_INT32ARRAY;
            } else if (valueType === '[object Uint32Array]') {
                marker += TYPE_UINT32ARRAY;
            } else if (valueType === '[object Float32Array]') {
                marker += TYPE_FLOAT32ARRAY;
            } else if (valueType === '[object Float64Array]') {
                marker += TYPE_FLOAT64ARRAY;
            } else {
                callback(new Error('Failed to get type for BinaryArray'));
            }
        }

        callback(marker + bufferToString(buffer));
    } else if (valueType === '[object Blob]') {
        // Conver the blob to a binaryArray and then to a string.
        var fileReader = new FileReader();

        fileReader.onload = function () {
            // Backwards-compatible prefix for the blob type.
            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);

            callback(SERIALIZED_MARKER + TYPE_BLOB + str);
        };

        fileReader.readAsArrayBuffer(value);
    } else {
        try {
            callback(JSON.stringify(value));
        } catch (e) {
            console.error("Couldn't convert value into a JSON string: ", value);

            callback(null, e);
        }
    }
}

// Deserialize data we've inserted into a value column/field. We place
// special markers into our strings to mark them as encoded; this isn't
// as nice as a meta field, but it's the only sane thing we can do whilst
// keeping localStorage support intact.
//
// Oftentimes this will just deserialize JSON content, but if we have a
// special marker (SERIALIZED_MARKER, defined above), we will extract
// some kind of arraybuffer/binary data/typed array out of the string.
function deserialize(value) {
    // If we haven't marked this string as being specially serialized (i.e.
    // something other than serialized JSON), we can just return it and be
    // done with it.
    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
        return JSON.parse(value);
    }

    // The following code deals with deserializing some kind of Blob or
    // TypedArray. First we separate out the type of data we're dealing
    // with from the data itself.
    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);

    var blobType;
    // Backwards-compatible blob type serialization strategy.
    // DBs created with older versions of localForage will simply not have the blob type.
    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
        blobType = matcher[1];
        serializedString = serializedString.substring(matcher[0].length);
    }
    var buffer = stringToBuffer(serializedString);

    // Return the right type based on the code/type set during
    // serialization.
    switch (type) {
        case TYPE_ARRAYBUFFER:
            return buffer;
        case TYPE_BLOB:
            return createBlob([buffer], { type: blobType });
        case TYPE_INT8ARRAY:
            return new Int8Array(buffer);
        case TYPE_UINT8ARRAY:
            return new Uint8Array(buffer);
        case TYPE_UINT8CLAMPEDARRAY:
            return new Uint8ClampedArray(buffer);
        case TYPE_INT16ARRAY:
            return new Int16Array(buffer);
        case TYPE_UINT16ARRAY:
            return new Uint16Array(buffer);
        case TYPE_INT32ARRAY:
            return new Int32Array(buffer);
        case TYPE_UINT32ARRAY:
            return new Uint32Array(buffer);
        case TYPE_FLOAT32ARRAY:
            return new Float32Array(buffer);
        case TYPE_FLOAT64ARRAY:
            return new Float64Array(buffer);
        default:
            throw new Error('Unkown type: ' + type);
    }
}

var localforageSerializer = {
    serialize: serialize,
    deserialize: deserialize,
    stringToBuffer: stringToBuffer,
    bufferToString: bufferToString
};

/*
 * Includes code from:
 *
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */

function createDbTable(t, dbInfo, callback, errorCallback) {
    t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);
}

// Open the WebSQL database (automatically creates one if one didn't
// previously exist), using any options set in the config.
function _initStorage$1(options) {
    var self = this;
    var dbInfo = {
        db: null
    };

    if (options) {
        for (var i in options) {
            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];
        }
    }

    var dbInfoPromise = new Promise$1(function (resolve, reject) {
        // Open the database; the openDatabase API will automatically
        // create it for us if it doesn't exist.
        try {
            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
        } catch (e) {
            return reject(e);
        }

        // Create our key/value table if it doesn't exist.
        dbInfo.db.transaction(function (t) {
            createDbTable(t, dbInfo, function () {
                self._dbInfo = dbInfo;
                resolve();
            }, function (t, error) {
                reject(error);
            });
        }, reject);
    });

    dbInfo.serializer = localforageSerializer;
    return dbInfoPromise;
}

function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
    t.executeSql(sqlStatement, args, callback, function (t, error) {
        if (error.code === error.SYNTAX_ERR) {
            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name = ?", [dbInfo.storeName], function (t, results) {
                if (!results.rows.length) {
                    // if the table is missing (was deleted)
                    // re-create it table and retry
                    createDbTable(t, dbInfo, function () {
                        t.executeSql(sqlStatement, args, callback, errorCallback);
                    }, errorCallback);
                } else {
                    errorCallback(t, error);
                }
            }, errorCallback);
        } else {
            errorCallback(t, error);
        }
    }, errorCallback);
}

function getItem$1(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {
                    var result = results.rows.length ? results.rows.item(0).value : null;

                    // Check to see if this is serialized content we need to
                    // unpack.
                    if (result) {
                        result = dbInfo.serializer.deserialize(result);
                    }

                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function iterate$1(iterator, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;

            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {
                    var rows = results.rows;
                    var length = rows.length;

                    for (var i = 0; i < length; i++) {
                        var item = rows.item(i);
                        var result = item.value;

                        // Check to see if this is serialized content
                        // we need to unpack.
                        if (result) {
                            result = dbInfo.serializer.deserialize(result);
                        }

                        result = iterator(result, item.key, i + 1);

                        // void(0) prevents problems with redefinition
                        // of `undefined`.
                        if (result !== void 0) {
                            resolve(result);
                            return;
                        }
                    }

                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function _setItem(key, value, callback, retriesLeft) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            // The localStorage API doesn't return undefined values in an
            // "expected" way, so undefined is always cast to null in all
            // drivers. See: https://github.com/mozilla/localForage/pull/42
            if (value === undefined) {
                value = null;
            }

            // Save the original value to pass to the callback.
            var originalValue = value;

            var dbInfo = self._dbInfo;
            dbInfo.serializer.serialize(value, function (value, error) {
                if (error) {
                    reject(error);
                } else {
                    dbInfo.db.transaction(function (t) {
                        tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {
                            resolve(originalValue);
                        }, function (t, error) {
                            reject(error);
                        });
                    }, function (sqlError) {
                        // The transaction failed; check
                        // to see if it's a quota error.
                        if (sqlError.code === sqlError.QUOTA_ERR) {
                            // We reject the callback outright for now, but
                            // it's worth trying to re-run the transaction.
                            // Even if the user accepts the prompt to use
                            // more storage on Safari, this error will
                            // be called.
                            //
                            // Try to re-run the transaction.
                            if (retriesLeft > 0) {
                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));
                                return;
                            }
                            reject(sqlError);
                        }
                    });
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function setItem$1(key, value, callback) {
    return _setItem.apply(this, [key, value, callback, 1]);
}

function removeItem$1(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {
                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Deletes every item in the table.
// TODO: Find out if this resets the AUTO_INCREMENT number.
function clear$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {
                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Does a simple `COUNT(key)` to get the number of items stored in
// localForage.
function length$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                // Ahhh, SQL makes this one soooooo easy.
                tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {
                    var result = results.rows.item(0).c;
                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Return the key located at key index X; essentially gets the key from a
// `WHERE id = ?`. This is the most efficient way I can think to implement
// this rarely-used (in my experience) part of the API, but it can seem
// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so
// the ID of each key will change every time it's updated. Perhaps a stored
// procedure for the `setItem()` SQL would solve this problem?
// TODO: Don't change ID on `setItem()`.
function key$1(n, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {
                    var result = results.rows.length ? results.rows.item(0).key : null;
                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function keys$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {
                    var keys = [];

                    for (var i = 0; i < results.rows.length; i++) {
                        keys.push(results.rows.item(i).key);
                    }

                    resolve(keys);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// https://www.w3.org/TR/webdatabase/#databases
// > There is no way to enumerate or delete the databases available for an origin from this API.
function getAllStoreNames(db) {
    return new Promise$1(function (resolve, reject) {
        db.transaction(function (t) {
            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (t, results) {
                var storeNames = [];

                for (var i = 0; i < results.rows.length; i++) {
                    storeNames.push(results.rows.item(i).name);
                }

                resolve({
                    db: db,
                    storeNames: storeNames
                });
            }, function (t, error) {
                reject(error);
            });
        }, function (sqlError) {
            reject(sqlError);
        });
    });
}

function dropInstance$1(options, callback) {
    callback = getCallback.apply(this, arguments);

    var currentConfig = this.config();
    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        promise = new Promise$1(function (resolve) {
            var db;
            if (options.name === currentConfig.name) {
                // use the db reference of the current instance
                db = self._dbInfo.db;
            } else {
                db = openDatabase(options.name, '', '', 0);
            }

            if (!options.storeName) {
                // drop all database tables
                resolve(getAllStoreNames(db));
            } else {
                resolve({
                    db: db,
                    storeNames: [options.storeName]
                });
            }
        }).then(function (operationInfo) {
            return new Promise$1(function (resolve, reject) {
                operationInfo.db.transaction(function (t) {
                    function dropTable(storeName) {
                        return new Promise$1(function (resolve, reject) {
                            t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {
                                resolve();
                            }, function (t, error) {
                                reject(error);
                            });
                        });
                    }

                    var operations = [];
                    for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                        operations.push(dropTable(operationInfo.storeNames[i]));
                    }

                    Promise$1.all(operations).then(function () {
                        resolve();
                    })["catch"](function (e) {
                        reject(e);
                    });
                }, function (sqlError) {
                    reject(sqlError);
                });
            });
        });
    }

    executeCallback(promise, callback);
    return promise;
}

var webSQLStorage = {
    _driver: 'webSQLStorage',
    _initStorage: _initStorage$1,
    _support: isWebSQLValid(),
    iterate: iterate$1,
    getItem: getItem$1,
    setItem: setItem$1,
    removeItem: removeItem$1,
    clear: clear$1,
    length: length$1,
    key: key$1,
    keys: keys$1,
    dropInstance: dropInstance$1
};

function isLocalStorageValid() {
    try {
        return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&
        // in IE8 typeof localStorage.setItem === 'object'
        !!localStorage.setItem;
    } catch (e) {
        return false;
    }
}

function _getKeyPrefix(options, defaultConfig) {
    var keyPrefix = options.name + '/';

    if (options.storeName !== defaultConfig.storeName) {
        keyPrefix += options.storeName + '/';
    }
    return keyPrefix;
}

// Check if localStorage throws when saving an item
function checkIfLocalStorageThrows() {
    var localStorageTestKey = '_localforage_support_test';

    try {
        localStorage.setItem(localStorageTestKey, true);
        localStorage.removeItem(localStorageTestKey);

        return false;
    } catch (e) {
        return true;
    }
}

// Check if localStorage is usable and allows to save an item
// This method checks if localStorage is usable in Safari Private Browsing
// mode, or in any other case where the available quota for localStorage
// is 0 and there wasn't any saved items yet.
function _isLocalStorageUsable() {
    return !checkIfLocalStorageThrows() || localStorage.length > 0;
}

// Config the localStorage backend, using options set in the config.
function _initStorage$2(options) {
    var self = this;
    var dbInfo = {};
    if (options) {
        for (var i in options) {
            dbInfo[i] = options[i];
        }
    }

    dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);

    if (!_isLocalStorageUsable()) {
        return Promise$1.reject();
    }

    self._dbInfo = dbInfo;
    dbInfo.serializer = localforageSerializer;

    return Promise$1.resolve();
}

// Remove all keys from the datastore, effectively destroying all data in
// the app's key/value store!
function clear$2(callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var keyPrefix = self._dbInfo.keyPrefix;

        for (var i = localStorage.length - 1; i >= 0; i--) {
            var key = localStorage.key(i);

            if (key.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key);
            }
        }
    });

    executeCallback(promise, callback);
    return promise;
}

// Retrieve an item from the store. Unlike the original async_storage
// library in Gaia, we don't modify return values at all. If a key's value
// is `undefined`, we pass that value to the callback function.
function getItem$2(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var result = localStorage.getItem(dbInfo.keyPrefix + key);

        // If a result was found, parse it from the serialized
        // string into a JS object. If result isn't truthy, the key
        // is likely undefined and we'll pass it straight to the
        // callback.
        if (result) {
            result = dbInfo.serializer.deserialize(result);
        }

        return result;
    });

    executeCallback(promise, callback);
    return promise;
}

// Iterate over all items in the store.
function iterate$2(iterator, callback) {
    var self = this;

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var keyPrefix = dbInfo.keyPrefix;
        var keyPrefixLength = keyPrefix.length;
        var length = localStorage.length;

        // We use a dedicated iterator instead of the `i` variable below
        // so other keys we fetch in localStorage aren't counted in
        // the `iterationNumber` argument passed to the `iterate()`
        // callback.
        //
        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530
        var iterationNumber = 1;

        for (var i = 0; i < length; i++) {
            var key = localStorage.key(i);
            if (key.indexOf(keyPrefix) !== 0) {
                continue;
            }
            var value = localStorage.getItem(key);

            // If a result was found, parse it from the serialized
            // string into a JS object. If result isn't truthy, the
            // key is likely undefined and we'll pass it straight
            // to the iterator.
            if (value) {
                value = dbInfo.serializer.deserialize(value);
            }

            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);

            if (value !== void 0) {
                return value;
            }
        }
    });

    executeCallback(promise, callback);
    return promise;
}

// Same as localStorage's key() method, except takes a callback.
function key$2(n, callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var result;
        try {
            result = localStorage.key(n);
        } catch (error) {
            result = null;
        }

        // Remove the prefix from the key, if a key is found.
        if (result) {
            result = result.substring(dbInfo.keyPrefix.length);
        }

        return result;
    });

    executeCallback(promise, callback);
    return promise;
}

function keys$2(callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var length = localStorage.length;
        var keys = [];

        for (var i = 0; i < length; i++) {
            var itemKey = localStorage.key(i);
            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                keys.push(itemKey.substring(dbInfo.keyPrefix.length));
            }
        }

        return keys;
    });

    executeCallback(promise, callback);
    return promise;
}

// Supply the number of keys in the datastore to the callback function.
function length$2(callback) {
    var self = this;
    var promise = self.keys().then(function (keys) {
        return keys.length;
    });

    executeCallback(promise, callback);
    return promise;
}

// Remove an item from the store, nice and simple.
function removeItem$2(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        localStorage.removeItem(dbInfo.keyPrefix + key);
    });

    executeCallback(promise, callback);
    return promise;
}

// Set a key's value and run an optional callback once the value is set.
// Unlike Gaia's implementation, the callback function is passed the value,
// in case you want to operate on that value only after you're sure it
// saved, or something like that.
function setItem$2(key, value, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        // Convert undefined values to null.
        // https://github.com/mozilla/localForage/pull/42
        if (value === undefined) {
            value = null;
        }

        // Save the original value to pass to the callback.
        var originalValue = value;

        return new Promise$1(function (resolve, reject) {
            var dbInfo = self._dbInfo;
            dbInfo.serializer.serialize(value, function (value, error) {
                if (error) {
                    reject(error);
                } else {
                    try {
                        localStorage.setItem(dbInfo.keyPrefix + key, value);
                        resolve(originalValue);
                    } catch (e) {
                        // localStorage capacity exceeded.
                        // TODO: Make this a specific error/event.
                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                            reject(e);
                        }
                        reject(e);
                    }
                }
            });
        });
    });

    executeCallback(promise, callback);
    return promise;
}

function dropInstance$2(options, callback) {
    callback = getCallback.apply(this, arguments);

    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        var currentConfig = this.config();
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        promise = new Promise$1(function (resolve) {
            if (!options.storeName) {
                resolve(options.name + '/');
            } else {
                resolve(_getKeyPrefix(options, self._defaultConfig));
            }
        }).then(function (keyPrefix) {
            for (var i = localStorage.length - 1; i >= 0; i--) {
                var key = localStorage.key(i);

                if (key.indexOf(keyPrefix) === 0) {
                    localStorage.removeItem(key);
                }
            }
        });
    }

    executeCallback(promise, callback);
    return promise;
}

var localStorageWrapper = {
    _driver: 'localStorageWrapper',
    _initStorage: _initStorage$2,
    _support: isLocalStorageValid(),
    iterate: iterate$2,
    getItem: getItem$2,
    setItem: setItem$2,
    removeItem: removeItem$2,
    clear: clear$2,
    length: length$2,
    key: key$2,
    keys: keys$2,
    dropInstance: dropInstance$2
};

var sameValue = function sameValue(x, y) {
    return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);
};

var includes = function includes(array, searchElement) {
    var len = array.length;
    var i = 0;
    while (i < len) {
        if (sameValue(array[i], searchElement)) {
            return true;
        }
        i++;
    }

    return false;
};

var isArray = Array.isArray || function (arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
};

// Drivers are stored here when `defineDriver()` is called.
// They are shared across all instances of localForage.
var DefinedDrivers = {};

var DriverSupport = {};

var DefaultDrivers = {
    INDEXEDDB: asyncStorage,
    WEBSQL: webSQLStorage,
    LOCALSTORAGE: localStorageWrapper
};

var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];

var OptionalDriverMethods = ['dropInstance'];

var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);

var DefaultConfig = {
    description: '',
    driver: DefaultDriverOrder.slice(),
    name: 'localforage',
    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
    // we can use without a prompt.
    size: 4980736,
    storeName: 'keyvaluepairs',
    version: 1.0
};

function callWhenReady(localForageInstance, libraryMethod) {
    localForageInstance[libraryMethod] = function () {
        var _args = arguments;
        return localForageInstance.ready().then(function () {
            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
        });
    };
}

function extend() {
    for (var i = 1; i < arguments.length; i++) {
        var arg = arguments[i];

        if (arg) {
            for (var _key in arg) {
                if (arg.hasOwnProperty(_key)) {
                    if (isArray(arg[_key])) {
                        arguments[0][_key] = arg[_key].slice();
                    } else {
                        arguments[0][_key] = arg[_key];
                    }
                }
            }
        }
    }

    return arguments[0];
}

var LocalForage = function () {
    function LocalForage(options) {
        _classCallCheck(this, LocalForage);

        for (var driverTypeKey in DefaultDrivers) {
            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                var driver = DefaultDrivers[driverTypeKey];
                var driverName = driver._driver;
                this[driverTypeKey] = driverName;

                if (!DefinedDrivers[driverName]) {
                    // we don't need to wait for the promise,
                    // since the default drivers can be defined
                    // in a blocking manner
                    this.defineDriver(driver);
                }
            }
        }

        this._defaultConfig = extend({}, DefaultConfig);
        this._config = extend({}, this._defaultConfig, options);
        this._driverSet = null;
        this._initDriver = null;
        this._ready = false;
        this._dbInfo = null;

        this._wrapLibraryMethodsWithReady();
        this.setDriver(this._config.driver)["catch"](function () {});
    }

    // Set any config values for localForage; can be called anytime before
    // the first API call (e.g. `getItem`, `setItem`).
    // We loop through options so we don't overwrite existing config
    // values.


    LocalForage.prototype.config = function config(options) {
        // If the options argument is an object, we use it to set values.
        // Otherwise, we return either a specified config value or all
        // config values.
        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
            // If localforage is ready and fully initialized, we can't set
            // any new configuration values. Instead, we return an error.
            if (this._ready) {
                return new Error("Can't call config() after localforage " + 'has been used.');
            }

            for (var i in options) {
                if (i === 'storeName') {
                    options[i] = options[i].replace(/\W/g, '_');
                }

                if (i === 'version' && typeof options[i] !== 'number') {
                    return new Error('Database version must be a number.');
                }

                this._config[i] = options[i];
            }

            // after all config options are set and
            // the driver option is used, try setting it
            if ('driver' in options && options.driver) {
                return this.setDriver(this._config.driver);
            }

            return true;
        } else if (typeof options === 'string') {
            return this._config[options];
        } else {
            return this._config;
        }
    };

    // Used to define a custom driver, shared across all instances of
    // localForage.


    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
        var promise = new Promise$1(function (resolve, reject) {
            try {
                var driverName = driverObject._driver;
                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');

                // A driver name should be defined and not overlap with the
                // library-defined, default drivers.
                if (!driverObject._driver) {
                    reject(complianceError);
                    return;
                }

                var driverMethods = LibraryMethods.concat('_initStorage');
                for (var i = 0, len = driverMethods.length; i < len; i++) {
                    var driverMethodName = driverMethods[i];

                    // when the property is there,
                    // it should be a method even when optional
                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {
                        reject(complianceError);
                        return;
                    }
                }

                var configureMissingMethods = function configureMissingMethods() {
                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {
                        return function () {
                            var error = new Error('Method ' + methodName + ' is not implemented by the current driver');
                            var promise = Promise$1.reject(error);
                            executeCallback(promise, arguments[arguments.length - 1]);
                            return promise;
                        };
                    };

                    for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                        var optionalDriverMethod = OptionalDriverMethods[_i];
                        if (!driverObject[optionalDriverMethod]) {
                            driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                        }
                    }
                };

                configureMissingMethods();

                var setDriverSupport = function setDriverSupport(support) {
                    if (DefinedDrivers[driverName]) {
                        console.info('Redefining LocalForage driver: ' + driverName);
                    }
                    DefinedDrivers[driverName] = driverObject;
                    DriverSupport[driverName] = support;
                    // don't use a then, so that we can define
                    // drivers that have simple _support methods
                    // in a blocking manner
                    resolve();
                };

                if ('_support' in driverObject) {
                    if (driverObject._support && typeof driverObject._support === 'function') {
                        driverObject._support().then(setDriverSupport, reject);
                    } else {
                        setDriverSupport(!!driverObject._support);
                    }
                } else {
                    setDriverSupport(true);
                }
            } catch (e) {
                reject(e);
            }
        });

        executeTwoCallbacks(promise, callback, errorCallback);
        return promise;
    };

    LocalForage.prototype.driver = function driver() {
        return this._driver || null;
    };

    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));

        executeTwoCallbacks(getDriverPromise, callback, errorCallback);
        return getDriverPromise;
    };

    LocalForage.prototype.getSerializer = function getSerializer(callback) {
        var serializerPromise = Promise$1.resolve(localforageSerializer);
        executeTwoCallbacks(serializerPromise, callback);
        return serializerPromise;
    };

    LocalForage.prototype.ready = function ready(callback) {
        var self = this;

        var promise = self._driverSet.then(function () {
            if (self._ready === null) {
                self._ready = self._initDriver();
            }

            return self._ready;
        });

        executeTwoCallbacks(promise, callback, callback);
        return promise;
    };

    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
        var self = this;

        if (!isArray(drivers)) {
            drivers = [drivers];
        }

        var supportedDrivers = this._getSupportedDrivers(drivers);

        function setDriverToConfig() {
            self._config.driver = self.driver();
        }

        function extendSelfWithDriver(driver) {
            self._extend(driver);
            setDriverToConfig();

            self._ready = self._initStorage(self._config);
            return self._ready;
        }

        function initDriver(supportedDrivers) {
            return function () {
                var currentDriverIndex = 0;

                function driverPromiseLoop() {
                    while (currentDriverIndex < supportedDrivers.length) {
                        var driverName = supportedDrivers[currentDriverIndex];
                        currentDriverIndex++;

                        self._dbInfo = null;
                        self._ready = null;

                        return self.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                    }

                    setDriverToConfig();
                    var error = new Error('No available storage method found.');
                    self._driverSet = Promise$1.reject(error);
                    return self._driverSet;
                }

                return driverPromiseLoop();
            };
        }

        // There might be a driver initialization in progress
        // so wait for it to finish in order to avoid a possible
        // race condition to set _dbInfo
        var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function () {
            return Promise$1.resolve();
        }) : Promise$1.resolve();

        this._driverSet = oldDriverSetDone.then(function () {
            var driverName = supportedDrivers[0];
            self._dbInfo = null;
            self._ready = null;

            return self.getDriver(driverName).then(function (driver) {
                self._driver = driver._driver;
                setDriverToConfig();
                self._wrapLibraryMethodsWithReady();
                self._initDriver = initDriver(supportedDrivers);
            });
        })["catch"](function () {
            setDriverToConfig();
            var error = new Error('No available storage method found.');
            self._driverSet = Promise$1.reject(error);
            return self._driverSet;
        });

        executeTwoCallbacks(this._driverSet, callback, errorCallback);
        return this._driverSet;
    };

    LocalForage.prototype.supports = function supports(driverName) {
        return !!DriverSupport[driverName];
    };

    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {
        extend(this, libraryMethodsAndProperties);
    };

    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
        var supportedDrivers = [];
        for (var i = 0, len = drivers.length; i < len; i++) {
            var driverName = drivers[i];
            if (this.supports(driverName)) {
                supportedDrivers.push(driverName);
            }
        }
        return supportedDrivers;
    };

    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
        // Add a stub for each driver API method that delays the call to the
        // corresponding driver method until localForage is ready. These stubs
        // will be replaced by the driver methods as soon as the driver is
        // loaded, so there is no performance impact.
        for (var i = 0, len = LibraryMethods.length; i < len; i++) {
            callWhenReady(this, LibraryMethods[i]);
        }
    };

    LocalForage.prototype.createInstance = function createInstance(options) {
        return new LocalForage(options);
    };

    return LocalForage;
}();

// The actual localForage object that we expose as a module or via a
// global. It's extended by pulling in one of our other libraries.


var localforage_js = new LocalForage();

module.exports = localforage_js;

},{"3":3}]},{},[4])(4)
});

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_154248__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};


/***/ }),

/***/ "./node_modules/protobufjs/minimal.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_287605__) {

"use strict";
// minimal library entry point.


module.exports = __nested_webpack_require_287605__(/*! ./src/index-minimal */ "./node_modules/protobufjs/src/index-minimal.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_288104__) {

"use strict";

var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = __nested_webpack_require_288104__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
protobuf.BufferWriter = __nested_webpack_require_288104__(/*! ./writer_buffer */ "./node_modules/protobufjs/src/writer_buffer.js");
protobuf.Reader       = __nested_webpack_require_288104__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
protobuf.BufferReader = __nested_webpack_require_288104__(/*! ./reader_buffer */ "./node_modules/protobufjs/src/reader_buffer.js");

// Utility
protobuf.util         = __nested_webpack_require_288104__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");
protobuf.rpc          = __nested_webpack_require_288104__(/*! ./rpc */ "./node_modules/protobufjs/src/rpc.js");
protobuf.roots        = __nested_webpack_require_288104__(/*! ./roots */ "./node_modules/protobufjs/src/roots.js");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_289767__) {

"use strict";

module.exports = Reader;

var util      = __nested_webpack_require_289767__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};


/***/ }),

/***/ "./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_301432__) {

"use strict";

module.exports = BufferReader;

// extends Reader
var Reader = __nested_webpack_require_301432__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = __nested_webpack_require_301432__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_303865__) {

"use strict";


/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = __nested_webpack_require_303865__(/*! ./rpc/service */ "./node_modules/protobufjs/src/rpc/service.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_305462__) {

"use strict";

module.exports = Service;

var util = __nested_webpack_require_305462__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_310627__) {

"use strict";

module.exports = LongBits;

var util = __nested_webpack_require_310627__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_316418__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = __nested_webpack_require_316418__(/*! @protobufjs/aspromise */ "./node_modules/@protobufjs/aspromise/index.js");

// converts to / from base64 encoded strings
util.base64 = __nested_webpack_require_316418__(/*! @protobufjs/base64 */ "./node_modules/@protobufjs/base64/index.js");

// base class of rpc.Service
util.EventEmitter = __nested_webpack_require_316418__(/*! @protobufjs/eventemitter */ "./node_modules/@protobufjs/eventemitter/index.js");

// float handling accross browsers
util.float = __nested_webpack_require_316418__(/*! @protobufjs/float */ "./node_modules/@protobufjs/float/index.js");

// requires modules optionally and hides the call from bundlers
util.inquire = __nested_webpack_require_316418__(/*! @protobufjs/inquire */ "./node_modules/@protobufjs/inquire/index.js");

// converts to / from utf8 encoded strings
util.utf8 = __nested_webpack_require_316418__(/*! @protobufjs/utf8 */ "./node_modules/@protobufjs/utf8/index.js");

// provides a node-like buffer pool in the browser
util.pool = __nested_webpack_require_316418__(/*! @protobufjs/pool */ "./node_modules/@protobufjs/pool/index.js");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = __nested_webpack_require_316418__(/*! ./longbits */ "./node_modules/protobufjs/src/util/longbits.js");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_316418__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_330123__) {

"use strict";

module.exports = Writer;

var util      = __nested_webpack_require_330123__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};


/***/ }),

/***/ "./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_342597__) {

"use strict";

module.exports = BufferWriter;

// extends Writer
var Writer = __nested_webpack_require_342597__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = __nested_webpack_require_342597__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/zego-setting/ZegoSetting.js":
/*!**************************************************!*\
  !*** ./node_modules/zego-setting/ZegoSetting.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_346122__) {

!function(e,t){if(true)module.exports=t(__nested_webpack_require_346122__(/*! localforage */ "./node_modules/localforage/dist/localforage.js"));else { var n, i; }}("undefined"!=typeof self?self:this,(function(e){return i={},t.m=n=[function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ZEGO_SETTING_ACTION=void 0,(t=t.ZEGO_SETTING_ACTION||(t.ZEGO_SETTING_ACTION={})).CONSTRUCTOR="zs.0",t.SETTING_INIT="zs.ii.0",t.SETTING_FETCH_SETTING="zs.fs.0",t.SETTING__FETCH_SETTING="zs.fs.1",t.SETTING_GET_CLOUD_SETTING="zs.gcs.0",t.SETTING_POLLING_SETTING="zs.ps.0",t.SETTINGCACHEHANDLER_GET_CACHE_SETTING="zs.sch.gcs.0",t.SETTINGCACHEHANDLER_STORE_SETTING="zs.sch.ss.0",t.SETTINGFETCHHANDLER_FETCHSETTING="zs.sfh.fs.0"},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.errorList=void 0,t.errorList={NOT_INIT:{code:1001,msg:"not init"},FILE_REQUEST_FAIL:{code:1002,msg:"fetch request fail"},INFLATE_DATA_FAIL:{code:1003,msg:"inflate fail"},MULTI_FILE_NOT_EXIST:{code:1004,msg:"get multi file fail"}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.generateUUID=t.checkValidNumber=t.analyzeKey=t.getCurrentTime=t.getBrowser=void 0,t.getBrowser=function(){var e=window.navigator.userAgent,t=null!=window.ActiveXObject&&-1!=e.indexOf("MSIE"),n=-1!=e.indexOf("Firefox"),i=null!=window.opr,r=e.indexOf("Chrome")&&window.chrome,o=-1!=e.indexOf("Safari")&&-1!=e.indexOf("Version");e=e.toLowerCase().match(/MicroMessenger/i)&&"micromessenger"===e.toLowerCase().match(/MicroMessenger/i)[0];return t?"IE":n?"FIREFOX":i?"OPERA":r?"CHROME":o?"SAFARI":e?"WEIXIN":"UNKOWN"};var i=["00","01","02","03","04","05","06","07","08","09"];t.getCurrentTime=function(){var e=new Date;return[e.getFullYear()+"/",(i[e.getMonth()+1]||e.getMonth()+1)+"/",(i[e.getDate()]||e.getDate())+" ",(i[e.getHours()]||e.getHours())+":",(i[e.getMinutes()]||e.getMinutes())+":",i[e.getSeconds()]||e.getSeconds(),"."+e.getTime()%1e3].join("")},t.analyzeKey=function(e){return e=e.split("_"),{level:Number(e[0]),timestamp:e[1],seq:e[2]}},t.checkValidNumber=function(e,t,n){return t=t||1,n=n||1e4,"number"==typeof e&&e%1==0&&t<=e&&e<=n},t.generateUUID=function(e){if(0===(e=void 0===e?0:e)?n=localStorage.getItem("z_deviceID"):wx.getStorageSync("z_deviceID"),n)return n;var t=(new Date).getTime(),n="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(function(e){var n=(t+16*Math.random())%16|0;return t=Math.floor(t/16),("x"==e?n:3&n|8).toString(36)}));return 0===e?localStorage.setItem("z_deviceID",n):wx.setStorageSync("z_deviceID",n),n}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ZegoSetting=void 0;var i=n(4);Object.defineProperty(t,"ZegoSetting",{enumerable:!0,get:function(){return i.ZegoSetting}})},function(e,t,n){"use strict";var i=this&&this.__assign||function(){return(i=Object.assign||function(e){for(var t,n=1,i=arguments.length;n<i;n++)for(var r in t=arguments[n])Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e}).apply(this,arguments)},r=this&&this.__awaiter||function(e,t,n,i){return new(n=n||Promise)((function(r,o){function s(e){try{l(i.next(e))}catch(e){o(e)}}function a(e){try{l(i.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?r(e.value):((t=e.value)instanceof n?t:new n((function(e){e(t)}))).then(s,a)}l((i=i.apply(e,t||[])).next())}))},o=this&&this.__generator||function(e,t){var n,i,r,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]},s={next:a(0),throw:a(1),return:a(2)};return"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function a(s){return function(a){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,i&&(r=2&s[0]?i.return:s[0]?i.throw||((r=i.return)&&r.call(i),0):i.next)&&!(r=r.call(i,s[1])).done)return r;switch(i=0,(s=r?[2&s[0],r.value]:s)[0]){case 0:case 1:r=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,i=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(r=0<(r=o.trys).length&&r[r.length-1])&&(6===s[0]||2===s[0])){o=0;continue}if(3===s[0]&&(!r||s[1]>r[0]&&s[1]<r[3])){o.label=s[1];break}if(6===s[0]&&o.label<r[1]){o.label=r[1],r=s;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(s);break}r[2]&&o.ops.pop(),o.trys.pop();continue}s=t.call(e,o)}catch(e){s=[6,e],i=0}finally{n=r=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,a])}}};Object.defineProperty(t,"__esModule",{value:!0}),t.ZegoSetting=void 0;var s=n(5),a=n(6),l=n(10),c=n(0),u=n(12),f=n(1),h=n(2);Object.defineProperty(g.prototype,"envVariable",{get:function(){return Object.assign({},this.publicEnvVariable,this.proEnvVariable)},enumerable:!1,configurable:!0}),g.prototype.init=function(e){var t=this;return e.pollingFreq&&!h.checkValidNumber(e.pollingFreq)?(this.log.error(c.ZEGO_SETTING_ACTION.SETTING_INIT+" pollingFreq must be integer number"),!1):(this.options=Object.assign({},u.INIT_CONFIG,e),this.getPublicEnvVariable(),this.settingFetchHandler=new l.SettingFetchHandler(this.options,this.log),this.settingFetchHandler.setDataReport(this.options.reportNotify),e=Math.round(60*Math.random()),this.log.info(c.ZEGO_SETTING_ACTION.SETTING_INIT+" delay "+e),this.delayTimer&&(clearTimeout(this.delayTimer),this.delayTimer=null),this.options.pollingFreq&&60<=this.options.pollingFreq&&(this.pollingInterval=this.options.pollingFreq),this.delayTimer=setTimeout((function(){t.pollingSetting(1e3*t.pollingInterval)}),1e3*e),this.settingCacheHandler=new a.SettingCacheHandler("setting_"+(this.options.online?"online_":"test_")+this.options.product+"_"+this.options.appID,this.log,this.options.env),this.inited=!0)},g.prototype.uninit=function(){this.pollingTimer&&(clearTimeout(this.pollingTimer),this.pollingTimer=null)},g.prototype.setEnvVariable=function(e,t){this.proEnvVariable[e]=String(t)},g.prototype.getEnvVariable=function(e){return this.envVariable[e]},g.prototype.setEnvVariables=function(e){var t=this;Object.keys(e).forEach((function(n){"string"!=typeof e[n]&&"number"!=typeof e[n]&&t.log.error("zs.sev env "+n+" type error"),t.proEnvVariable[n]=String(e[n])}))},g.prototype.getEnvVariables=function(){return this.envVariable},g.prototype.enablePolling=function(e,t){var n=this;t?t.forEach((function(t){var i=n.fileList.find((function(e){return e.fileName===t}));i&&(i.needPolling=e)})):this.fileList.forEach((function(t){return t.needPolling=e}))},g.prototype.setToken=function(e){this.token=e},g.prototype.setUserID=function(e){this.userID=e},g.prototype.getSettingCache=function(e){return r(this,void 0,void 0,(function(){var t,n,i;return o(this,(function(r){switch(r.label){case 0:return this.inited?(t=this.fileList.find((function(t){return t.fileName===e})))?[2,Promise.resolve({setting:t.setting,versions:t.versions})]:[3,1]:[2,Promise.reject(f.errorList.NOT_INIT)];case 1:return n=this._getFileName(e),[4,this.settingCacheHandler.getCacheSetting(n)];case 2:return(n=r.sent())&&(this.fileList.find((function(t){return t.fileName===e}))||this.fileList.push({fileName:e,fetchedTime:0,needPolling:!1,setting:n.setting,versions:n.versions}),i={setting:n.setting,versions:n.versions}),[2,Promise.resolve(i)]}}))}))},g.prototype.fetchSetting=function(e,t,n){return void 0===t&&(t={}),void 0===n&&(n=!0),this.log.info(c.ZEGO_SETTING_ACTION.SETTING_FETCH_SETTING+" call "+e),this.inited?(this.activePolling(),0<Object.keys(t).length?(this.log.info(c.ZEGO_SETTING_ACTION.SETTING_FETCH_SETTING+" get file with params"),this._getCloudSetting(e,i(i({},this.envVariable),t))):(t=this.fileList.find((function(t){return t.fileName===e})))?(this.log.info(c.ZEGO_SETTING_ACTION.SETTING_FETCH_SETTING+" file exist"),(new Date).getTime()-t.fetchedTime<1e3*this.pollingInterval?(this.log.info(c.ZEGO_SETTING_ACTION.SETTING_FETCH_SETTING+" fetch time interval in freq"),t.needPolling=n,Promise.resolve({setting:t.setting,versions:t.versions})):this._fetchSetting(e,t,n)):(this.log.info(c.ZEGO_SETTING_ACTION.SETTING_FETCH_SETTING+" file not found"),this._fetchSetting(e,t,n))):Promise.reject(f.errorList.NOT_INIT)},g.prototype.fetchMultiSetting=function(e,t,n){var s=this;return void 0===t&&(t={}),void 0===n&&(n=!0),this.inited?(this.activePolling(),0<Object.keys(t).length?(this.log.info(c.ZEGO_SETTING_ACTION.SETTING_FETCH_SETTING+" get file with params"),this._getCloudSetting(e,i(i({},this.envVariable),t))):new Promise((function(t,i){var a={},l=[];if(e.forEach((function(e){return r(s,void 0,void 0,(function(){var t;return o(this,(function(n){return(t=this.fileList.find((function(t){return t.fileName===e})))?(new Date).getTime()-t.fetchedTime<1e3*this.pollingInterval?(this.log.info(c.ZEGO_SETTING_ACTION.SETTING_FETCH_SETTING+" fetch time interval in freq"),a[e]={setting:t.setting,versions:t.versions}):l.push(e):l.push(e),[2]}))}))})),!(0<l.length))return t(a);s._getCloudSetting(l,s.envVariable).then((function(e){return s.handleFetchFiles(e,n),Object.assign(a,e),t(a)})).catch((function(e){l.forEach((function(e){return r(s,void 0,void 0,(function(){var t;return o(this,(function(i){switch(i.label){case 0:return(t=this.fileList.find((function(t){return t.fileName==e})))?t.fetchedTime=(new Date).getTime():this.fileList.find((function(t){return t.fileName===e}))||this.fileList.push({fileName:e,fetchedTime:(new Date).getTime(),needPolling:n,setting:{},versions:{}}),[4,this.settingCacheHandler.getCacheSetting(e)];case 1:return t=i.sent(),a[e]={setting:t.setting,versions:t.versions},[2]}}))}))})),0<Object.keys(a).length?t(a):i(e)}))}))):Promise.reject(f.errorList.NOT_INIT)},g.prototype.setLog=function(e){this.log=e},g.prototype._getCloudSetting=function(e,t){var n=this;return new Promise((function(i,s){return r(n,void 0,void 0,(function(){var n,r,a,l,u,h;return o(this,(function(o){switch(o.label){case 0:return o.trys.push([0,2,,3]),l=e instanceof Array,[4,this.settingFetchHandler.fetchSetting(l?e:[e],t,this.token,this.userID)];case 1:return r=o.sent(),n=r.data,"number"==typeof(r=r.polling_interval)&&5<=r&&this.pollingInterval!==60*r&&(this.log.warn(c.ZEGO_SETTING_ACTION.SETTING_GET_CLOUD_SETTING+" polling interval change"),this.pollingInterval=60*r,this.uninit(),this.activePolling()),l?(a={},e.forEach((function(e){var t,i;0==(null===(t=n[e])||void 0===t?void 0:t.code)&&void 0!==(null===(i=n[e])||void 0===i?void 0:i.data)&&(a[e]={setting:null===(i=n[e])||void 0===i?void 0:i.data,versions:null===(e=n[e])||void 0===e?void 0:e.versions})})),0<Object.keys(a).length?i(a):s(f.errorList.MULTI_FILE_NOT_EXIST)):0===(null===(l=n[e])||void 0===l?void 0:l.code)&&null!==(u=n[e])&&void 0!==u&&u.data?i({setting:null===(u=n[e])||void 0===u?void 0:u.data,versions:null===(u=n[e])||void 0===u?void 0:u.versions}):s({code:null===(h=n[e])||void 0===h?void 0:h.code,msg:null===(h=n[e])||void 0===h?void 0:h.message}),[3,3];case 2:return h=o.sent(),s(h),this.log.info(c.ZEGO_SETTING_ACTION.SETTING_GET_CLOUD_SETTING+" fail"),[3,3];case 3:return[2]}}))}))}))},g.prototype.handleFetchFiles=function(e,t){var n=this;Object.keys(e).forEach((function(i){var r=n.fileList.find((function(e){return e.fileName==i}));r?(r.fetchedTime=(new Date).getTime(),r.setting=e[i].setting,r.versions=e[i].versions,r.needPolling=t):n.fileList.find((function(e){return e.fileName===i}))||n.fileList.push({fileName:i,fetchedTime:(new Date).getTime(),needPolling:t,setting:e[i].setting,versions:e[i].versions}),r=n._getFileName(i),n.settingCacheHandler.storeSetting(r,e[i])}))},g.prototype._fetchSetting=function(e,t,n){var i=this;return new Promise((function(s,a){i.log.info(c.ZEGO_SETTING_ACTION.SETTING__FETCH_SETTING+" call"),i._getCloudSetting(e,i.envVariable).then((function(r){t?(t.fetchedTime=(new Date).getTime(),t.setting=r.setting,t.versions=r.versions,t.needPolling=n):i.fileList.find((function(t){return t.fileName===e}))||i.fileList.push({fileName:e,fetchedTime:(new Date).getTime(),needPolling:n,setting:r.setting,versions:r.versions});var o=i._getFileName(e);i.settingCacheHandler.storeSetting(o,r),s(r),i.log.info(c.ZEGO_SETTING_ACTION.SETTING__FETCH_SETTING+" call suc")})).catch((function(l){return r(i,void 0,void 0,(function(){var i;return o(this,(function(r){switch(r.label){case 0:t?t.fetchedTime=(new Date).getTime():this.fileList.find((function(t){return t.fileName===e}))||this.fileList.push({fileName:e,fetchedTime:(new Date).getTime(),needPolling:n,setting:{},versions:{}}),i=this._getFileName(e),r.label=1;case 1:return r.trys.push([1,3,,4]),[4,this.settingCacheHandler.getCacheSetting(i)];case 2:return i=r.sent(),s(i),[3,4];case 3:return r.sent(),a(l),[3,4];case 4:return this.log.info(c.ZEGO_SETTING_ACTION.SETTING__FETCH_SETTING+" setting not contain or fetch file fail"),[2]}}))}))}))}))},g.prototype.getPublicEnvVariable=function(){var e;0==this.options.env?(this.publicEnvVariable.userAgent=navigator.userAgent,this.publicEnvVariable.platform=navigator.platform,this.publicEnvVariable.browser=h.getBrowser(),this.publicEnvVariable.deviceid=h.generateUUID()):1==this.options.env&&(e=wx.getSystemInfoSync(),this.publicEnvVariable.brand=e.brand,this.publicEnvVariable.model=e.model,this.publicEnvVariable.system=e.system,this.publicEnvVariable.platform=e.platform,this.publicEnvVariable.wechatVersion=e.version,this.publicEnvVariable.wechatSDKVersion=e.SDKVersion,this.publicEnvVariable.deviceid=h.generateUUID(this.options.env))},g.prototype.pollingSetting=function(e){return r(this,void 0,void 0,(function(){var t,n,i,s,a=this;return o(this,(function(l){switch(l.label){case 0:if(this.log.info(c.ZEGO_SETTING_ACTION.SETTING_POLLING_SETTING+" call "+e),t=[],this.fileList.forEach((function(e){e.fileName,e.needPolling&&t.push(e.fileName)})),n=e,!(0<t.length))return[3,5];l.label=1;case 1:return l.trys.push([1,3,,4]),[4,this.settingFetchHandler.fetchSetting(t,this.envVariable,this.token,this.userID)];case 2:return s=l.sent(),i=s.data,"number"==typeof(s=s.polling_interval)&&5<=s&&this.pollingInterval!==60*s&&(this.log.warn(c.ZEGO_SETTING_ACTION.SETTING_POLLING_SETTING+" polling interval change"),this.pollingInterval=60*s,n=1e3*this.pollingInterval),this.fileList.forEach((function(e){return r(a,void 0,void 0,(function(){var t,n,r,s;return o(this,(function(o){switch(o.label){case 0:return e.fetchedTime=(new Date).getTime(),t=this._getFileName(e.fileName),i[e.fileName]&&0===i[e.fileName].code&&i[e.fileName].data?(n=JSON.stringify(i[e.fileName].data),r=JSON.stringify(e.setting),s={setting:i[e.fileName].data,versions:null===(s=i[e.fileName])||void 0===s?void 0:s.versions},r!==n&&(this.log.info(c.ZEGO_SETTING_ACTION.SETTING_POLLING_SETTING+" "+e.fileName+" setting changed"),e.setting=s.setting,e.versions=s.versions,this.options.pollingNotify(e.fileName,s)),[4,this.settingCacheHandler.getCacheSetting(t)]):[3,2];case 1:r=o.sent(),n=JSON.stringify(r),r=JSON.stringify(s),n!==r&&this.settingCacheHandler.storeSetting(t,s),o.label=2;case 2:return[2]}}))}))})),[3,4];case 3:return s=l.sent(),this.log.error(c.ZEGO_SETTING_ACTION.SETTING_POLLING_SETTING+" fetch fail "+JSON.stringify(s)),[3,4];case 4:return[3,6];case 5:this.log.info(c.ZEGO_SETTING_ACTION.SETTING_POLLING_SETTING+" polling no file"),l.label=6;case 6:return this.pollingTimer&&clearTimeout(this.pollingTimer),this.pollingTimer=setTimeout((function(){a.pollingSetting(n)}),n),[2]}}))}))},g.prototype._getFileName=function(e){return e},g.prototype.activePolling=function(){this.pollingTimer||this.pollingSetting(1e3*this.pollingInterval)},n=g;function g(){this.fileList=[],this.publicEnvVariable={},this.proEnvVariable={},this.pollingTimer=null,this.pollingInterval=300,this.inited=!1,this.log=new s.ZegoLog}t.ZegoSetting=n},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ZegoLog=void 0;var i=(r.prototype.log=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];e.join(" ")},r.prototype.debug=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];e.join(" ")},r.prototype.info=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];e.join(" ")},r.prototype.warn=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];e.join(" ")},r.prototype.error=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];e.join(" ")},r);function r(){}t.ZegoLog=i},function(e,t,n){"use strict";var i=this&&this.__awaiter||function(e,t,n,i){return new(n=n||Promise)((function(r,o){function s(e){try{l(i.next(e))}catch(e){o(e)}}function a(e){try{l(i.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?r(e.value):((t=e.value)instanceof n?t:new n((function(e){e(t)}))).then(s,a)}l((i=i.apply(e,t||[])).next())}))},r=this&&this.__generator||function(e,t){var n,i,r,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]},s={next:a(0),throw:a(1),return:a(2)};return"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function a(s){return function(a){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,i&&(r=2&s[0]?i.return:s[0]?i.throw||((r=i.return)&&r.call(i),0):i.next)&&!(r=r.call(i,s[1])).done)return r;switch(i=0,(s=r?[2&s[0],r.value]:s)[0]){case 0:case 1:r=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,i=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(r=0<(r=o.trys).length&&r[r.length-1])&&(6===s[0]||2===s[0])){o=0;continue}if(3===s[0]&&(!r||s[1]>r[0]&&s[1]<r[3])){o.label=s[1];break}if(6===s[0]&&o.label<r[1]){o.label=r[1],r=s;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(s);break}r[2]&&o.ops.pop(),o.trys.pop();continue}s=t.call(e,o)}catch(e){s=[6,e],i=0}finally{n=r=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,a])}}};Object.defineProperty(t,"__esModule",{value:!0}),t.SettingCacheHandler=void 0;var o=n(0),s=n(7);a.prototype.getCacheSetting=function(e){return i(this,void 0,void 0,(function(){return r(this,(function(t){switch(t.label){case 0:return this.log.info(o.ZEGO_SETTING_ACTION.SETTINGCACHEHANDLER_GET_CACHE_SETTING+" call"),[4,this.store.getItem(e)];case 1:return[2,t.sent()||""]}}))}))},a.prototype.storeSetting=function(e,t){return i(this,void 0,void 0,(function(){return r(this,(function(n){switch(n.label){case 0:return this.log.info(o.ZEGO_SETTING_ACTION.SETTINGCACHEHANDLER_STORE_SETTING+" call"),[4,this.store.setItem(e,t)];case 1:return n.sent(),[2]}}))}))},n=a;function a(e,t,n){void 0===n&&(n=0),this.storeName=e,this.log=t,this.store=s.createZegoStore(e,n)}t.SettingCacheHandler=n},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createZegoStore=t.ZegoWechatMiniStore=void 0;var i=n(8),r=n(9),o=(s.prototype.getItem=function(e){var t=this;return new Promise((function(n,i){try{n(wx.getStorageSync(t.keyPrefix+e))}catch(n){i(n)}}))},s.prototype.setItem=function(e,t){var n=this;return new Promise((function(i,r){try{wx.setStorageSync(n.keyPrefix+e,t),i()}catch(i){r(i)}}))},s.prototype.removeItem=function(e){var t=this;return new Promise((function(n,i){try{n(wx.removeStorageSync(t.keyPrefix+e))}catch(n){i(n)}}))},s.prototype.clear=function(){return new Promise((function(e,t){try{wx.clearStorageSync(),e()}catch(e){t(e)}}))},s.prototype.keys=function(){var e=this;return new Promise((function(t,n){try{var i=wx.getStorageInfoSync().keys,r=[];i.forEach((function(t){0==t.indexOf(e.keyPrefix)&&r.push(t.replace(e.keyPrefix,""))})),r.sort(),t(r)}catch(t){n(t)}}))},s);function s(e){this.storeName=e,this.keyPrefix=e+"/",this.storeName}t.ZegoWechatMiniStore=o,t.createZegoStore=function(e,t){return t===r.ZEGO_ENV.BROWSER?i.createInstance({name:e}):new o(e)}},function(t,n){t.exports=e},function(e,t,n){"use strict";var i;Object.defineProperty(t,"__esModule",{value:!0}),t.SOCKET_DISCONNECT=t.ENUM_REMOTE_TYPE=t.ZEGO_BROWSER_TYPE=t.ZEGO_ENV=t.PROTO_VERSION=void 0,t.PROTO_VERSION="1.0.3",(i=t.ZEGO_ENV||(t.ZEGO_ENV={}))[i.BROWSER=0]="BROWSER",i[i.WEIXINMINI=1]="WEIXINMINI",(i=t.ZEGO_BROWSER_TYPE||(t.ZEGO_BROWSER_TYPE={}))[i.IE=0]="IE",i[i.FIREFOX=1]="FIREFOX",i[i.CHROME=2]="CHROME",i[i.SAFARI=3]="SAFARI",i[i.OPERA=4]="OPERA",i[i.WEIXIN=5]="WEIXIN",i[i.WEIXINMINI=6]="WEIXINMINI",i[i.UNKOWN=7]="UNKOWN",(i=t.ENUM_REMOTE_TYPE||(t.ENUM_REMOTE_TYPE={}))[i.DISABLE=0]="DISABLE",i[i.WEBSOCKET=1]="WEBSOCKET",i[i.HTTPS=2]="HTTPS",t.SOCKET_DISCONNECT=-1},function(e,t,n){"use strict";var i=this&&this.__assign||function(){return(i=Object.assign||function(e){for(var t,n=1,i=arguments.length;n<i;n++)for(var r in t=arguments[n])Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e}).apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.SettingFetchHandler=void 0;var r=n(0),o=n(11),s=n(2);a.prototype.setOptions=function(e){this.options=e},a.prototype.setDataReport=function(e){this.reportFunc=e},a.prototype.fetchSetting=function(e,t,n,a){var l=this;return new Promise((function(c,u){var f={product:l.options.product,files:e,param:i(i({},t),{deviceid:void 0}),appid:l.options.appID,token:n,id_name:a,timestamp:(new Date).getTime(),biztype:0,deviceid:t.deviceid||s.generateUUID(l.options.env),compress:!1,mode:l.options.online?"online":"test"},h=l.seq++;l.reportFunc&&l.reportFunc(h,"request_start"),o.fetch(l.options.urls,f,l.options.env||0).then((function(e){var t,n=e.code,i=(e.msg,e.data),o=e.polling_interval;e=e.reportData;l.log.info(r.ZEGO_SETTING_ACTION.SETTINGFETCHHANDLER_FETCHSETTING+" "+n),i&&(t=[],Object.keys(i).forEach((function(e){t.push({name:e,error:i[e].code})}))),l.reportFunc&&l.reportFunc(h,"request_end",{code:n,reportData:e,params:f,files:t}),c({data:i,polling_interval:o})})).catch((function(e){var t=e.code,n=e.msg;e.data,e=e.reportData;l.log.warn(r.ZEGO_SETTING_ACTION.SETTINGFETCHHANDLER_FETCHSETTING+" "+t),l.reportFunc&&l.reportFunc(h,"request_end",{code:t,params:f,reportData:e}),u({code:t,msg:n})}))}))},n=a;function a(e,t){this.options=e,this.log=t,this.seq=0}t.SettingFetchHandler=n},function(e,t,n){"use strict";var i=this&&this.__assign||function(){return(i=Object.assign||function(e){for(var t,n=1,i=arguments.length;n<i;n++)for(var r in t=arguments[n])Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e}).apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.fetch=void 0;var r=n(1);t.fetch=function e(t,n,o,s,a,l){return void 0===s&&(s=5),void 0===a&&(a=0),void 0===l&&(l=[]),new Promise((function(c,u){a=a||(new Date).getTime();var f,h,g,T=(new Date).getTime();0===o?(f=new XMLHttpRequest,h=t[(s+1)%2]||t[0],f.open("post",h),1==n.compress&&(f.responseType="arraybuffer"),f.ontimeout=function(){},f.onreadystatechange=function(){var g,p,d,v,E;4==f.readyState&&(200<=f.status&&f.status<300||304==f.status?(p=void 0,1==n.compress||(p=f.responseText),E=(new Date).getTime()-T,g=(d=JSON.parse(p)).code,v=d.message,p=d.data,d=d.polling_interval,l.push({timestamp:T,url:h,error:g,duration:E}),0===g?c({code:g,msg:v,data:p,polling_interval:d,reportData:l}):u({code:g,msg:v,reportData:l})):(v=(new Date).getTime()-T,l.push({timestamp:T,url:h,error:f.status,duration:v}),E=(new Date).getTime()-a,0<s&&E<8e3?e(t,n,o,--s,a,l).then((function(e){c(e)})).catch((function(e){u(e)})):u(i(i({},r.errorList.FILE_REQUEST_FAIL),{reportData:l}))))},f.timeout=8e3,f.send(JSON.stringify(n))):(g=t[(s+1)%2]||t[0],wx.request({url:g,data:n,method:"POST",success:function(f){var h=(v=f.data).code,p=v.message,d=v.data,v=v.polling_interval;void 0!==h?0===h?c({code:h,msg:p,data:d,polling_interval:v,reportData:l}):u({code:h,msg:p,reportData:l}):(p=(new Date).getTime()-T,l.push({timestamp:T,url:g,error:r.errorList.FILE_REQUEST_FAIL.code,msg:f.data,duration:p}),0<s?e(t,n,o,--s,a,l).then((function(e){c(e)})).catch((function(e){u(e)})):u(i(i({},r.errorList.FILE_REQUEST_FAIL),{reportData:l})))},fail:function(f){var h=(new Date).getTime()-T;l.push({timestamp:T,url:g,error:r.errorList.FILE_REQUEST_FAIL.code,msg:f.errMsg,duration:h}),0<s?e(t,n,o,--s,a,l).then((function(e){c(e)})).catch((function(e){u(e)})):u(i(i({},r.errorList.FILE_REQUEST_FAIL),{reportData:l}))}}))}))}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.INIT_CONFIG=void 0,t.INIT_CONFIG={env:0}}],t.c=i,t.d=function(e,n,i){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:i})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(t.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)t.d(i,r,function(t){return e[t]}.bind(null,r));return i},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=3);function t(e){if(i[e])return i[e].exports;var r=i[e]={i:e,l:!1,exports:{}};return n[e].call(r.exports,r,r.exports,t),r.l=!0,r.exports}var n,i}));

/***/ }),

/***/ "./sdk/code/zh/zego.client.web.ts":
/*!****************************************!*\
  !*** ./sdk/code/zh/zego.client.web.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_371329__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BusinessService = exports.NetAgentHttpRequest = exports.NetAgentPCRequest = exports.NetAgentConnect = exports.ZegoExpressWebRTM = exports.ZegoDataReport = exports.ZegoLogger = exports.getSeq = exports.getReportSeq = exports.ZegoExpressWebRTMEngine = void 0;
var src_1 = __nested_webpack_require_371329__(/*! ../../src */ "./sdk/src/index.ts");
Object.defineProperty(exports, "ZegoExpressWebRTM", { enumerable: true, get: function () { return src_1.ZegoExpressWebRTM; } });
var zego_setting_1 = __nested_webpack_require_371329__(/*! zego-setting */ "./node_modules/zego-setting/ZegoSetting.js");
var zego_entity_1 = __nested_webpack_require_371329__(/*! ../../src/zego.entity */ "./sdk/src/zego.entity.ts");
var net_1 = __nested_webpack_require_371329__(/*! ../../src/modules/net */ "./sdk/src/modules/net/index.ts");
Object.defineProperty(exports, "NetAgentConnect", { enumerable: true, get: function () { return net_1.NetAgentConnect; } });
Object.defineProperty(exports, "NetAgentPCRequest", { enumerable: true, get: function () { return net_1.NetAgentPCRequest; } });
Object.defineProperty(exports, "NetAgentHttpRequest", { enumerable: true, get: function () { return net_1.NetAgentHttpRequest; } });
Object.defineProperty(exports, "BusinessService", { enumerable: true, get: function () { return net_1.BusinessService; } });
var ZegoExpressWebRTMEngine = /** @class */ (function () {
    /**
     * 初始化Engine
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述：实例化对象。
     *
     * Note: 业务场景：所有场景必须。
     *
     * Note: 默认值：无默认值，所有参数必须填写。
     *
     * Note: 调用时机：第一个调用。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项：server 建议填写数组，备用域名抗弱网能力更强。
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：无
     *
     * Note: 相关接口：无
     *
     * Note: 平台差异：无
     *
     * @param appID 用于区分不同客户和项目的唯一标识（必须是number类型）; 一个appID对应一个客户项目，不同端共有一个appID实现互通 ;一个客户可以申请多个appID,
     *              必须从即构控制台获取
     * @param server 表示SDK连接的即构服务器地址（支持备用域名）;SDK内的大多数功能由它交互 ; 同一个appID可以填写多个server; 必须从控制台获取
     * @param ENV 表示sdk 环境，rtc或是小程序
     */
    function ZegoExpressWebRTMEngine(appID, server, ENV, options) {
        if (ENV === void 0) { ENV = 0; }
        this.logger = new zego_entity_1.ZegoLogger(ENV);
        this.dataReport = new zego_entity_1.ZegoDataReport(this.logger);
        this.cloudSetting = new zego_setting_1.ZegoSetting();
        this.zegoWebRTM = new src_1.ZegoExpressWebRTM(appID, server, this.logger, this.dataReport, this.cloudSetting, ZegoExpressWebRTMEngine.version, ENV, options);
    }
    /**
     * 是否开启多房间模式
     *
     * 支持版本：2.8.0 及以上。
     *
     * 详情描述：是否需要开启多房间，同一个用户可以同时加入多个房间，并同时在多个房间内推流、拉流、发送实时消息和接收消息回调。
     *
     * 业务场景：用于跨房间连麦和在线教育的超级小班场景。
     *
     * 默认值：默认不开启多房间。
     *
     * 调用时机：需要在初始化 SDK 后，第一次登录房间 loginRoom 前调用。
     *
     * 使用限制：一次完整的生命周期内只能调用一次。
     *
     * 相关接口：可调用 loginRoom 登录房间，调用  logoutRoom 退出房间，调用 startPublishingStream 开始推流。
     *
     * @param enable 是否开启，true 为开启，false 为关闭。
     */
    ZegoExpressWebRTMEngine.prototype.enableMultiRoom = function (enable) {
        return this.zegoWebRTM.enableMultiRoom(enable);
    };
    /**
     * 登录房间
     *
     * Note: 支持版本：1.0.0 及以上。
     *
     * Note: 详情描述：登录房间，同房间用户共享流、消息、用户等信息变化。
     *
     * Note: 业务场景：通过登录房间来获取与其他用户进行音视频或消息互动的接口权限。
     *
     * Note: 调用时机：初始化且获取到 token 之后。
     *
     * Note: 注意事项：
     * 1. token 是使用登录房间的钥匙，需要开发者自行实现，为保证安全，一定要在开发者自己的服务端生成 token，参考文章 [登录房间鉴权](https://doc-zh.zego.im/article/7646)。
     * 2. 默认为单房间模式，同一个用户（即 userID 相同）不能同时登录两个及以上房间。
     * 3. 若想监听房间内其他用户的变化，则 config 对象下的 “userUpdate” 参数必须设置为 “true”。
     *
     * Note: 隐私保护声明:  请勿在此接口填写用户敏感信息，包括但不限于手机号、身份证号、护照编号、真实姓名等。
     *
     * Note: 影响范围：大部分接口都需要在登录房间后才能调用。
     *
     * Note: 相关回调：房间状态回调 roomStateUpdate。
     *
     * Note: 相关接口：可调用 logoutRoom 接口退出房间。
     *
     * @param roomID 房间 ID，最大长度为 128 字节的字符串。仅支持数字，英文字符 和 '~', '!', '@', '#', '$', '', '^', '&', '*', '(', ')', '_', '+', '=', '-', ', ';', '’', ',', '.', '<', '>', '/',
     * @param token 登录验证 token，是通过在即构控制台注册项目获得密钥，加上指定算法获得。测试阶段可以通过 ZEGO 提供的接口获取，正式环境一定要用户自己实现。
     * @param user 登录用户信息。
     * @param config? 房间相关配置，可选。
     *
     * @return promise 异步返回登录结果，true 表示登录成功，false 表示登录失败。
     */
    ZegoExpressWebRTMEngine.prototype.loginRoom = function (roomID, token, user, config) {
        return this.zegoWebRTM.loginRoom(roomID, token, user, config);
    };
    /**
     * 退出房间，不再接受各种房间内状态
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述：退出房间,，结束同房间用户共享流、消息、用户等信息变化。
     *
     * Note: 业务场景：结束音视频通话或其他功能后需要调用该接口退出房间，以保证对端能及时同步本端当前状态。调用该接口后会向 ZEGO 服务器发送退出房间信令，然后重置当前房间中用户与 ZEGO 服务器进行交互所需的关键数据，并置空 websocket 对象。
     *
     * Note: 默认值：无
     *
     * Note: 调用时机：登录房间成功后。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项： 无
     *
     * Note: 影响范围：大部分接口都在退出房间后，不能再调用。
     *
     * Note: 相关回调：房间状态回调 roomStateUpdate。
     *
     * Note: 相关接口：可调用 loginRoom 接口登录号房间。
     *
     * Note: 平台差异：无
     *
     * @param roomID? 和登录房间的roomID保持一致，可选
     */
    ZegoExpressWebRTMEngine.prototype.logoutRoom = function (roomID) {
        return this.zegoWebRTM.logoutRoom(roomID);
    };
    /**
     * 更新房间权限token
     *
     * 支持版本：2.6.0
     *
     * 详情描述：token权限变更,或者token过期时调用,更新token权限
     *
     * 业务场景：登录权限和推流权限隔离时使用, 利用token控制权限
     *
     * 默认值：无
     *
     * 调用时机：登录房间后,主动变更用户在房间内的权限; 登录房间后,收到token将要过期回调;
     *
     * 使用限制：无
     *
     * 注意事项：token是使用登录房间的钥匙, 这个是需要客户自己实现,为保证安全,一定要在自己的服务端生成token
     *
     * 影响范围：token内包含的过期时间,在过期前30s会触发tokenWillExpire回调
     *
     * 相关回调：房间token将要过期回调tokenWillExpire
     *
     * 相关接口：无
     *
     * Note: 平台差异：无
     *
     * @param token 指定算法生成的token, 即构提供生成token的不同语言版SDK;
     * @param roomID 房间 ID，最大长度为 128 字节的字符串。仅支持数字，英文字符 和 '~', '!', '@', '#', '$', '', '^', '&', '*', '(', ')', '_', '+', '=', '-', ', ';', '’', ',', '.', '<', '>', '/',
     *
     * @return true: 调用成功, false: 调用失败 (SDK 初步格式校验)
     */
    ZegoExpressWebRTMEngine.prototype.renewToken = function (token, roomID) {
        return this.zegoWebRTM.renewToken(token, roomID);
    };
    /**
     * 发送房间弹幕消息（消息不保证可靠）
     *
     * Note: 支持版本：1.0.0 及以上。
     *
     * Note: 详情描述：向 roomID 对应的房间内所有用户发送弹幕消息，消息不保证可靠。
     *
     * Note: 业务场景：房间内用户发送弹幕消息互动。
     *
     * Note: 调用时机：调用接口 loginRoom 登录房间成功之后。
     *
     * Note: 使用限制：关于此接口的使用限制，请参考 https://doc-zh.zego.im/article/7584 或联系 ZEGO 技术支持。
     *
     * Note: 安全性提醒：请勿在此接口填写用户敏感信息，包括但不限于手机号、身份证号、护照编号、真实姓名等。
     *
     * Note: 相关回调：房间内用户可以通过房间弹幕消息通知回调 IMRecvBarrageMessage 来接收消息。
     *
     * @param roomID 房间Id
     * @param message 消息内容，长度不超过1024字节
     */
    ZegoExpressWebRTMEngine.prototype.sendBarrageMessage = function (roomID, message) {
        return this.zegoWebRTM.sendBarrageMessage(roomID, message);
    };
    /**
     * 发送房间广播消息（消息保证可靠）
     *
     * Note: 支持版本：1.0.0 及以上。
     *
     * Note: 详情描述：向 roomID 对应的房间内所有用户发送文本消息。
     *
     * Note: 业务场景：房间内用户发送消息聊天互动，例如语聊房。
     *
     * Note: 调用时机：调用接口 loginRoom 登录房间成功之后。
     *
     * Note: 使用限制：关于此接口的使用限制，请参考 https://doc-zh.zego.im/article/7584 或联系 ZEGO 技术支持。
     *
     * Note: 安全性提醒：请勿在此接口填写用户敏感信息，包括但不限于手机号、身份证号、护照编号、真实姓名等。
     *
     * Note: 影响范围：需要在登录房间后才能调用。
     *
     * Note: 相关回调：其他房间用户可以通过广播消息通知回调 IMRecvBroadcastMessage 来接收消息。
     *
     * @param roomID 房间 ID。
     * @param message 消息内容，长度不超过1024 字节。
     */
    ZegoExpressWebRTMEngine.prototype.sendBroadcastMessage = function (roomID, message) {
        return this.zegoWebRTM.sendBroadcastMessage(roomID, message);
    };
    /**
     * 发送自定义信令（消息可靠）
     *
     * Note: 支持版本：1.0.0 及以上。
     *
     * Note: 详情描述：向 roomID 对应的房间内指定用户发送自定义消息，消息保证可靠。
     *
     * Note: 业务场景：私聊个别用户。
     *
     * Note: 调用时机：登录房间成功之后。
     *
     * Note: 使用限制：关于此接口的使用限制，请参考 https://doc-zh.zego.im/article/7584 或联系 ZEGO 技术支持。
     *
     * Note: 安全性提醒：请勿在此接口填写用户敏感信息，包括但不限于手机号、身份证号、护照编号、真实姓名等。
     *
     * Note: 影响范围：大部分接口都需要在登录房间后才能调用。
     *
     * Note: 相关回调：房间内用户可以通过监听自定义命令信令回调 IMRecvCustomCommand 来接收消息。
     *
     * @param roomID 房间 ID。
     * @param message 自定义消息内容，长度不超过 1024 字节。
     * @param toUserIDList 目标用户uerId 数组。
     */
    ZegoExpressWebRTMEngine.prototype.sendCustomCommand = function (roomID, message, toUserIDList) {
        return this.zegoWebRTM.sendCustomCommand(roomID, message, toUserIDList);
    };
    /**
     * 设置房间附加消息
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述：该功能可以设置一个以房间为单位的附加消息，该消息跟随整个房间的生命周期，每个登录到房间的用户都能够同步消息。
     *
     * Note: 业务场景：开发者可用于实现各种业务逻辑，如房间公告等等。
     *
     * Note: 默认值：无
     *
     * Note: 调用时机：登录房间成功之后。
     *
     * Note: 使用限制：关于此接口的使用限制，请参考 https://doc-zh.zego.im/article/7584 或 联系 ZEGO 技术支持。
     *
     * Note: 注意事项： 目前房间附加消息只允许设置一个键值对，且 key 最大长度为 10 字节，value 最大长度为 100 字节。
     *
     * Note: 安全性提醒:  请勿在此接口填写用户敏感信息，包括但不限于手机号、身份证号、护照编号、真实姓名等。
     *
     * Note: 影响范围：大部分接口都需要在登录房间后才能调用。
     *
     * Note: 相关回调：房间附加信息回调 roomExtraInfoUpdate。
     *
     * Note: 相关接口：无
     *
     * Note: 平台差异：无
     *
     * @param roomID 房间 ID
     * @param key 附加消息键
     * @param value 附加消息值
     */
    ZegoExpressWebRTMEngine.prototype.setRoomExtraInfo = function (roomID, key, value) {
        return this.zegoWebRTM.setRoomExtraInfo(roomID, key, value);
    };
    /**
     * 日志高级配置
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述：配置客户端打印日志级别和远端日志上传级别，日志是定位问题的重要手段。
     *
     * Note: 业务场景：在多数场景下，客户不用调用该接口，使用默认配置即可。
     *
     * Note: 默认值：本地日志和上传级别均为 info。
     *
     * Note: 调用时机：在初始化之后，其他任何接口之前调用。
     *
     * Note: 使用限制：无，但建议整个生命周期内只调用一次。
     *
     * Note: 注意事项：除非有明确的特殊需求，否则请勿调用该接口更改默认配置。
     *
     * Note: 相关回调：无
     *
     * Note: 相关接口：无
     *
     * @param config 日志相关高级配置
     *
     * @return 调用是否成功; 失败情况: 输入参数格式有误
     */
    ZegoExpressWebRTMEngine.prototype.setLogConfig = function (config) {
        return this.zegoWebRTM.setLogConfig(config);
    };
    /**
     * 错误日志信息 alert 提示，默认测试环境下都是开启状态
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述：打开或关闭错误弹窗提示。
     *
     * Note: 业务场景：用于开发环节提示错误。
     *
     * Note: 默认值：测试环境默认值为 “true“， 可以手动关闭。
     *
     * Note: 调用时机：初始化后，立刻调用。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项：建议保持默认行为，尽量不使用该接口。
     *
     * Note: 影响范围：所有 SDK 内部错误，都会弹框提示，中断整个进程。
     *
     * Note: 相关回调：无
     *
     * Note: 相关接口：无
     *
     * Note: 平台差异：无
     *
     * @param enable 是否打开 debug 模式;默认sdk会自动判断
     */
    ZegoExpressWebRTMEngine.prototype.setDebugVerbose = function (enable) {
        return this.zegoWebRTM.setDebugVerbose(enable);
    };
    /**
     * 注册回调事件
     *
     * Note: 支持版本：1.0.0 及以上。
     *
     * Note: 详情描述：用于处理 SDK 主动通知开发者回调的接口，通过注册不同 event 的事件，可以收到不同功能的回调。
     *
     * Note: 业务场景：通用接口，必选。
     *
     * Note: 调用时机：初始化之后，登录房间之前。
     *
     * Note: 注意事项：同样的事件可以注册多个，相同的注册事件，会根据注册的先后顺序依次触发。
     *
     * Note: 相关接口：调用接口 off 来注销对应回调事件处理。
     *
     * @param event 监听事件名。
     * @param callBack 回调函数。
     *
     * @return 注册是否成功。
     */
    ZegoExpressWebRTMEngine.prototype.on = function (event, callBack) {
        return this.zegoWebRTM.on(event, callBack);
    };
    /**
     * 获取当前SDK版本
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述：需要查看当前版本时调用。
     *
     * Note: 业务场景：日志收集时建议使用。
     *
     * Note: 默认值：无
     *
     * Note: 调用时机：初始化后任意时机可调用。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项：无
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：无
     *
     * Note: 相关接口：无
     *
     * Note: 平台差异：无
     *
     * @return 为 string 字符串，例如“1.0.0.标识”
     */
    ZegoExpressWebRTMEngine.prototype.getVersion = function () {
        return this.zegoWebRTM.getVersion();
    };
    /**
     * 删除注册过的回调事件
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 详情描述：用于处理SDK主动通知开发者回调的接口，用于删除注册的同一类回调事件。
     *
     * Note: 业务场景：通用接口，必选。
     *
     * Note: 支默认值：无
     *
     * Note: 调用时机：初始化之后，登录房间之前。
     *
     * Note: 使用限制：无
     *
     * Note: 注意事项：同样的事件可以注册多个，的注册事件，会根据注册的先后顺序依次触发。
     *
     * Note: 影响范围：无
     *
     * Note: 相关回调：无
     *
     * Note: 相关接口：无
     *
     * Note: 平台差异：无
     *
     * @param event 监听事件名
     * @param callBack? 回调函数，可选
     */
    ZegoExpressWebRTMEngine.prototype.off = function (event, callBack) {
        return this.zegoWebRTM.off(event, callBack);
    };
    /**
     * 登录大厅
     *
     * Note: 详情描述： 大部分功能接口必须在登录房间后调用 , 登录成功后同一个房间里的用户，共享状态（用户状态，流状态，消息等)
     *
     * Note: 调用时机：初始化后,且拿到token后
     *
     * Note: 限制频率：无
     *
     * Note: 关注回调： 房间状态回调roomStateUpdate, 房间用户变化回调roomUserUpdate, 房间总人数变化回调roomOnlineUserCountUpdate
     *
     * Note: 重点提示：
     *        token是使用登录房间的钥匙, 这个是需要客户自己实现,为保证安全,一定要在自己的服务端生成token;
     *        同一个用户（即userID相同）不能同时登录两个及以上房间;
     *        若想监听房间内其他用户的变化，则config对象下的userUpdate参数必须设置为“true”
     * Note: 支持版本：1.0.0
     *
     * Note: 废弃时间：无
     *
     * @param roomID 房间 ID，最大长度为 128 字节的字符串。仅支持数字，英文字符 和 '~', '!', '@', '#', '$', '', '^', '&', '*', '(', ')', '_', '+', '=', '-', ', ';', '’', ',', '.', '<', '>', '/',
     * @param token 登录验证 token, 是通过在即构控制台注册项目获得密钥,加上指定算法获得; 测试阶段可以通过即构的接口绕过, 正式环境一定要用户自己实现
     * @param user 登录用户信息
     * @param config? 房间相关配置
     */
    ZegoExpressWebRTMEngine.prototype.loginHall = function (token, user, config) {
        return this.zegoWebRTM.loginHall(token, user, config);
    };
    /**
     * 退出大厅，不再接受各种房间内状态
     *
     * Note: 详情描述：结束音视频通话或其他功能后需要调用该接口退出房间，以保证对端能及时同步你的当前状态; 调用该接口后会向 Zego 服务器发送登出信令，之后重置当前房间中用户与 Zego 服务器进行交互所需的关键数据，并置空 websocket 对象
     *
     * Note: 调用时机：初始化后,登录前
     *
     * Note: 限制频率：无
     *
     * Note: 关注回调：无
     *
     * Note: 重点提示：无
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 废弃时间：无
     *
     * @param roomID 和登录房间的roomID保持一致
     */
    ZegoExpressWebRTMEngine.prototype.logoutHall = function () {
        return this.zegoWebRTM.logoutHall();
    };
    /**
     * 登录房间
     *
     * Note: 详情描述： 大部分功能接口必须在登录房间后调用 , 登录成功后同一个房间里的用户，共享状态（用户状态，流状态，消息等)
     *
     * Note: 调用时机：初始化后,且拿到token后
     *
     * Note: 限制频率：无
     *
     * Note: 关注回调： 房间状态回调roomStateUpdate, 房间用户变化回调roomUserUpdate, 房间总人数变化回调roomOnlineUserCountUpdate
     *
     * Note: 重点提示：
     *        token是使用登录房间的钥匙, 这个是需要客户自己实现,为保证安全,一定要在自己的服务端生成token;
     *        同一个用户（即userID相同）不能同时登录两个及以上房间;
     *        若想监听房间内其他用户的变化，则config对象下的userUpdate参数必须设置为“true”
     * Note: 支持版本：1.0.0
     *
     * Note: 废弃时间：无
     *
     * @param roomID 房间 ID，最大长度为 128 字节的字符串。仅支持数字，英文字符 和 '~', '!', '@', '#', '$', '', '^', '&', '*', '(', ')', '_', '+', '=', '-', ', ';', '’', ',', '.', '<', '>', '/',
     * @param token 登录验证 token, 是通过在即构控制台注册项目获得密钥,加上指定算法获得; 测试阶段可以通过即构的接口绕过, 正式环境一定要用户自己实现
     * @param user 登录用户信息
     * @param config? 房间相关配置
     */
    ZegoExpressWebRTMEngine.prototype.enterRoom = function (roomID, role) {
        return this.zegoWebRTM.enterRoom(roomID, role);
    };
    /**
     * 退出房间，不再接受各种房间内状态
     *
     * Note: 详情描述：结束音视频通话或其他功能后需要调用该接口退出房间，以保证对端能及时同步你的当前状态; 调用该接口后会向 Zego 服务器发送登出信令，之后重置当前房间中用户与 Zego 服务器进行交互所需的关键数据，并置空 websocket 对象
     *
     * Note: 调用时机：初始化后,登录前
     *
     * Note: 限制频率：无
     *
     * Note: 关注回调：无
     *
     * Note: 重点提示：无
     *
     * Note: 支持版本：1.0.0
     *
     * Note: 废弃时间：无
     *
     * @param roomID 和登录房间的roomID保持一致
     */
    ZegoExpressWebRTMEngine.prototype.leaveRoom = function () {
        return this.zegoWebRTM.leaveRoom();
    };
    ZegoExpressWebRTMEngine.use = function (module) {
        src_1.ZegoExpressWebRTM.use(module);
    };
    ZegoExpressWebRTMEngine.version = zego_entity_1.PROTO_VERSION;
    return ZegoExpressWebRTMEngine;
}());
exports.ZegoExpressWebRTMEngine = ZegoExpressWebRTMEngine;
var zego_entity_2 = __nested_webpack_require_371329__(/*! ../../src/zego.entity */ "./sdk/src/zego.entity.ts");
Object.defineProperty(exports, "getReportSeq", { enumerable: true, get: function () { return zego_entity_2.getReportSeq; } });
Object.defineProperty(exports, "getSeq", { enumerable: true, get: function () { return zego_entity_2.getSeq; } });
Object.defineProperty(exports, "ZegoLogger", { enumerable: true, get: function () { return zego_entity_2.ZegoLogger; } });
Object.defineProperty(exports, "ZegoDataReport", { enumerable: true, get: function () { return zego_entity_2.ZegoDataReport; } });


/***/ }),

/***/ "./sdk/src/index.ts":
/*!**************************!*\
  !*** ./sdk/src/index.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_387581__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZegoExpressWebRTM = void 0;
var zego_entity_1 = __nested_webpack_require_387581__(/*! ./zego.entity */ "./sdk/src/zego.entity.ts");
var zego_externalError_1 = __nested_webpack_require_387581__(/*! ./zego.externalError */ "./sdk/src/zego.externalError.ts");
var client_util_1 = __nested_webpack_require_387581__(/*! ../util/client-util */ "./sdk/util/client-util.ts");
var zego_entity_2 = __nested_webpack_require_387581__(/*! ./zego.entity */ "./sdk/src/zego.entity.ts");
var zego_config_1 = __nested_webpack_require_387581__(/*! ./zego.config */ "./sdk/src/zego.config.ts");
var retryRoomHandler_1 = __nested_webpack_require_387581__(/*! ./modules/retryRoomHandler */ "./sdk/src/modules/retryRoomHandler.ts");
var param_util_1 = __nested_webpack_require_387581__(/*! ../util/param-util */ "./sdk/util/param-util.ts");
var stateCenter_1 = __nested_webpack_require_387581__(/*! ./stateCenter */ "./sdk/src/stateCenter.ts");
var modules_1 = __nested_webpack_require_387581__(/*! ./modules */ "./sdk/src/modules/index.ts");
var index_private_1 = __nested_webpack_require_387581__(/*! ./modules/index.private */ "./sdk/src/modules/index.private.ts");
var zego_action_1 = __nested_webpack_require_387581__(/*! ./zego.action */ "./sdk/src/zego.action.ts");
var zego_log_event_1 = __nested_webpack_require_387581__(/*! ./zego.log.event */ "./sdk/src/zego.log.event.ts");
var service_1 = __nested_webpack_require_387581__(/*! ./service */ "./sdk/src/service.ts");
var service_private_1 = __nested_webpack_require_387581__(/*! ./service.private */ "./sdk/src/service.private.ts");
var setting_config_1 = __nested_webpack_require_387581__(/*! ./setting.config */ "./sdk/src/setting.config.ts");
var net_1 = __nested_webpack_require_387581__(/*! ./modules/net */ "./sdk/src/modules/net/index.ts");
var AccessHubDefine_1 = __nested_webpack_require_387581__(/*! ./modules/net/entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var AccessHubDefine_2 = __nested_webpack_require_387581__(/*! ./modules/net/entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var liveroomHandler_1 = __nested_webpack_require_387581__(/*! ./modules/liveroomHandler */ "./sdk/src/modules/liveroomHandler.ts");
var net_config_1 = __nested_webpack_require_387581__(/*! ./modules/net/net.config */ "./sdk/src/modules/net/net.config.ts");
// 对外开发接口，与文档保持一致；调度中心
var ZegoExpressWebRTM = /** @class */ (function () {
    // static getReportSeq = getReportSeq;
    // static getSeq = getSeq;
    function ZegoExpressWebRTM(appID, server, logger, dataReport, cloudSetting, version, ENV, options) {
        var _this = this;
        this.logger = logger;
        this.dataReport = dataReport;
        this.cloudSetting = cloudSetting;
        this.version = version;
        this.options = options;
        this.stateCenter = new stateCenter_1.StateCenter(this.logger, this.dataReport);
        this.stateCenter.ENV = ENV;
        // 挂上 getReportSeq
        this.getReportSeq = zego_entity_2.getReportSeq;
        this.getSeq = zego_entity_1.getSeq;
        this.initCallback();
        // 数据上报准备
        var seq = zego_entity_2.getReportSeq();
        this.dataReport.newReport(seq);
        (ENV == 0 || ENV == 1) && this.setDebug(server);
        if (!client_util_1.ClientUtil.checkConfigParam(appID, server, this.logger)) {
            //参数有误
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CONSTRUCTOR + " init sdk error");
            this.dataReport.addMsgInfo(seq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskInitSetting.error.kInvalidParamError);
        }
        else {
            //参数正确
            this.stateCenter.appid = appID;
            this.stateCenter.configOK = true;
            this.stateCenter.sdKVersion = this.version;
            this.netAgent = new net_1.NetAgentConnect(this.stateCenter.appid, this.stateCenter.ENV, this.logger, this.stateCenter);
            this.liveRoomHandler = new liveroomHandler_1.LiveRoomHandler(this.logger, this.stateCenter, this.netAgent, this);
            this.service = new service_1.LiveRoomService(this.stateCenter, this.logger, this);
            this.stateCenter.deviceID = client_util_1.ClientUtil.generateUUID();
            // 云控配置初始化
            this.stateCenter.settingConfig = new setting_config_1.ZegoSettingConfig();
            // @ts-ignore
            this.cloudSetting.setLog(this.logger);
            this.cloudSetting.init({
                product: zego_config_1.CLOUD_SETTING.product,
                appID: appID,
                urls: zego_config_1.CLOUD_SETTING.URL,
                pollingFreq: zego_config_1.CLOUD_SETTING.POLLING_FREQ,
                env: ENV,
                pollingNotify: function (file, settingJson) {
                    _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CONSTRUCTOR, ' setting file changed ' + file + ' ' + JSON.stringify(settingJson));
                    _this.stateCenter.actionListener('_cloudSettingNotify', file, settingJson);
                },
                reportNotify: this.cloudReportNotify.bind(this),
                online: !this.stateCenter.testEnvironment,
            });
            var env = '';
            if (ENV === 0) {
                env = 'rtc';
            }
            else if (ENV === 1) {
                env = 'xcx';
            }
            this.cloudSetting.setEnvVariable('environment', env);
            var promise1 = this.cloudSetting.getSettingCache(zego_config_1.INIT);
            var promise2 = this.cloudSetting.getSettingCache(zego_config_1.ROOM_BASIC);
            Promise.all([promise1, promise2])
                .then(function (values) {
                var initConfig = values === null || values === void 0 ? void 0 : values[0];
                _this.stateCenter.settingConfig.setSetting(initConfig === null || initConfig === void 0 ? void 0 : initConfig.setting);
                var unify = _this.stateCenter.settingConfig.getSetting('unify');
                if (unify) {
                    var enable = unify.enable, sdk_conn_ver = unify.sdk_conn_ver;
                    if (enable && sdk_conn_ver >= net_1.NET_ACCESS_CONFIG.connectVer) {
                        _this.stateCenter.useNetAgent = true;
                    }
                    else {
                        _this.stateCenter.useNetAgent = false;
                    }
                }
                if (_this.stateCenter.useNetAgent) {
                    _this.createNetAgent();
                    _this.getStoreAppConfig();
                }
                var level = _this.stateCenter.settingConfig.getSetting('remote_log_level', true);
                if (level) {
                    _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CONSTRUCTOR + "  setting remote_log_level " + level);
                    _this.logger.setRemoteLogLevel(level);
                }
                var roomConfig = values === null || values === void 0 ? void 0 : values[1];
                _this.stateCenter.settingConfig.setSetting(roomConfig === null || roomConfig === void 0 ? void 0 : roomConfig.setting);
                var reportSeq = zego_entity_2.getReportSeq();
                _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskCloudSettingCache.event);
                _this.dataReport.addMsgInfo(reportSeq, {
                    files: [
                        {
                            name: zego_config_1.INIT,
                            content: initConfig === null || initConfig === void 0 ? void 0 : initConfig.setting,
                            versions: initConfig === null || initConfig === void 0 ? void 0 : initConfig.versions,
                        },
                        {
                            name: zego_config_1.ROOM_BASIC,
                            content: roomConfig === null || roomConfig === void 0 ? void 0 : roomConfig.setting,
                            versions: roomConfig === null || roomConfig === void 0 ? void 0 : roomConfig.versions,
                        },
                    ],
                });
                _this.dataReport.uploadReport(reportSeq);
            })
                .catch(function (err) {
                _this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CONSTRUCTOR + "  initConfig " + JSON.stringify(err));
            });
            if (typeof server === 'string') {
                this.stateCenter.server = server;
                this.stateCenter.serverBak = server;
            }
            else if (Array.isArray(server) && server.length > 0) {
                this.stateCenter.server = server[0];
                this.stateCenter.serverBak = server[1] || server[0];
            }
            if (ENV == 0 || ENV == 2) {
                this.bindWindowListener();
                this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CONSTRUCTOR + "  " + navigator.appVersion);
                this.stateCenter.networkState = navigator
                    ? navigator.onLine
                        ? zego_entity_1.ENUM_NETWORK_STATE.online
                        : zego_entity_1.ENUM_NETWORK_STATE.offline
                    : zego_entity_1.ENUM_NETWORK_STATE.online;
                this.dataReport.addMsgInfo(seq, {
                    system_info: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskInitSetting.system_info,
                });
            }
            else if (ENV == 1 || ENV == 3) {
                this.bindWxListener();
                try {
                    var res = wx.getSystemInfoSync();
                    var systemInfo = {
                        brand: res.brand,
                        model: res.model,
                        system: res.system,
                        platform: res.platform,
                        version: res.version,
                        SDKVersion: res.SDKVersion,
                    };
                    this.dataReport.addMsgInfo(seq, {
                        system_info: systemInfo,
                    });
                }
                catch (e) {
                    this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CONSTRUCTOR + ' get system info error');
                }
            }
            this.logger.setSessionInfo(this.stateCenter.appid, '', '', '', '', this.version);
        }
        this.dataReport.uploadReport(seq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskInitSetting.event);
    }
    Object.defineProperty(ZegoExpressWebRTM.prototype, "modules", {
        //  modules.service 兼容白板SDK的调用
        get: function () {
            return { service: this.service };
        },
        enumerable: false,
        configurable: true
    });
    ZegoExpressWebRTM.prototype.initCallback = function () {
        this.proxyRes = client_util_1.ClientUtil.proxyRes;
        this.actionSuccessCallback = client_util_1.ClientUtil.actionSuccessCallback;
        this.actionErrorCallback = client_util_1.ClientUtil.actionErrorCallback;
        this.getServerError = client_util_1.ClientUtil.getServerError;
        this.generateRandumNumber = client_util_1.ClientUtil.generateRandumNumber;
        this.unregisterCallback = client_util_1.ClientUtil.unregisterCallback;
        this.logReportCallback = client_util_1.ClientUtil.logReportCallback;
        this.registerCallback = client_util_1.ClientUtil.registerCallback;
    };
    ZegoExpressWebRTM.prototype.getStoreAppConfig = function () {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_GETSTOREAPPCONFIG + ' call');
        var ciphertext = localStorage.getItem(net_config_1.APP_CONFIG_KEY + '_' + this.getAppID() + '_' + net_1.NET_ACCESS_CONFIG.modeNo);
        if (!ciphertext) {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_GETSTOREAPPCONFIG + ' no store config');
            return;
        }
        try {
            var originalText = client_util_1.ClientUtil.decryptStores(ciphertext, zego_config_1.STORE_SECRET);
            if (originalText) {
                this.stateCenter.appConfig = JSON.parse(originalText);
                this.stateCenter.actionListener('_appConfigRsp');
                this.handleLogUpload();
            }
        }
        catch (error) {
            this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_GETSTOREAPPCONFIG + ' ' + JSON.stringify(error));
        }
    };
    ZegoExpressWebRTM.prototype.createNetAgent = function () {
        var _this = this;
        var _a, _b, _c;
        // 统一接入 start
        this.netAgent.on('disconnected', function () {
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CREATENETAGENT + " netAgent disconnect");
            __spreadArrays(_this.stateCenter.roomModulesList).forEach(function (room) { return room.roomHandler.resetRoom(); });
        });
        this.netAgent.on('connected', function () {
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CREATENETAGENT + " netAgent connect");
            _this.fetchAppConfig();
            //房间处理
            _this.stateCenter.roomModulesList.forEach(function (roomModules) {
                if (roomModules.roomTryHandler &&
                    _this.netAgent.isConnect()
                // @ts-ignore
                // roomModules.runState !== ENUM_RUN_STATE.trylogin
                ) {
                    roomModules.roomTryHandler.active(true);
                }
            });
        });
        this.netAgent.on('broken', function () {
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CREATENETAGENT + " netAgent broken");
        });
        var _domains;
        if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.accessDomains) && ((_b = this.options) === null || _b === void 0 ? void 0 : _b.accessDomains.length) > 0) {
            _domains = (_c = this.options) === null || _c === void 0 ? void 0 : _c.accessDomains;
        }
        else {
            _domains = net_1.NET_ACCESS_CONFIG.domains;
        }
        var servers = _domains.map(function (item) { return "wss://" + item + "/accesshub"; });
        this.netAgent.connect(servers);
        // 统一接入 end
    };
    ZegoExpressWebRTM.prototype.bindWindowListener = function () {
        var _this = this;
        //防止，暴力退出（关闭或刷新页面）
        var isOnIOS = navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPhone/i);
        var browser = client_util_1.ClientUtil.getBrowser();
        var eventName = isOnIOS ? 'pagehide' : browser === 'Firefox' ? 'beforeunload' : 'unload';
        window.addEventListener(eventName, function () {
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_BIND_WINDOW_LISTENER + ' ' + eventName);
            if (_this.stateCenter.type === 'PUBLIC') {
                _this.logoutRoom();
            }
            else {
                _this.leaveRoom();
                // TODO
                // this.logoutHall();
            }
            _this.logoutRoom();
        });
        //监听到网络断开
        window.addEventListener('offline', function () {
            _this.netOffLineHandle();
        });
        //监听到网络连接
        window.addEventListener('online', function () {
            _this.netOnLineHandle();
        });
    };
    ZegoExpressWebRTM.prototype.bindWxListener = function () {
        var _this = this;
        //监听到网络断开
        wx.onNetworkStatusChange(function (res) {
            if (res.isConnected) {
                _this.netOnLineHandle();
            }
            else {
                _this.netOffLineHandle();
            }
        });
    };
    ZegoExpressWebRTM.prototype.retryRoom = function () {
        var _this = this;
        this.stateCenter.roomModulesList.forEach(function (roomModules) {
            if (roomModules.roomTryHandler &&
                _this.netAgent.isConnect()
            // @ts-ignore
            // roomModules.runState !== ENUM_RUN_STATE.trylogin
            ) {
                roomModules.resetSessionInfo();
                roomModules.roomTryHandler.active(true);
            }
        });
    };
    ZegoExpressWebRTM.prototype.netOnLineHandle = function () {
        var _this = this;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_BIND_WINDOW_LISTENER + 'network is online');
        this.stateCenter.networkState = zego_entity_1.ENUM_NETWORK_STATE.online;
        if (this.stateCenter.useNetAgent) {
            // 统一接入处理
            this.netAgent.netOnLineHandler();
        }
        else {
            //房间处理
            this.stateCenter.roomModulesList.forEach(function (roomModules) {
                if (roomModules.roomTryHandler && _this.service.isDisConnect()) {
                    roomModules.roomTryHandler.active();
                }
                else if (roomModules.roomTryHandler) {
                    roomModules.roomTryHandler.stopMaxTime();
                    roomModules.roomHandler.roomStateHandle('CONNECTED', { code: 0, msg: '' });
                }
            });
        }
    };
    ZegoExpressWebRTM.prototype.netOffLineHandle = function () {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_BIND_WINDOW_LISTENER + ' network is broken');
        this.stateCenter.networkState = zego_entity_1.ENUM_NETWORK_STATE.offline;
        if (this.stateCenter.useNetAgent) {
            // 统一接入处理
            this.netAgent.netOffLineHandler();
        }
        else {
            //房间处理
            this.stateCenter.roomModulesList.forEach(function (roomModules) {
                if (roomModules.roomTryHandler) {
                    //断网停止重试
                    roomModules.roomTryHandler.invalid();
                    roomModules.roomTryHandler.onactive = function (success, error) {
                        roomModules.roomHandler.disconnectedHandle(error);
                    };
                    //异常发生
                    roomModules.roomTryHandler.startMaxTime();
                    roomModules.roomHandler.roomStateHandle('CONNECTING', zego_externalError_1.errorCodeList.NETWORK_BROKEN);
                }
            });
        }
    };
    ZegoExpressWebRTM.prototype.setLogConfig = function (option) {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SET_LOG_CONFIG + ' call');
        var reportSeq = zego_entity_2.getReportSeq();
        this.dataReport.newReport(reportSeq);
        if (option.logLevel && ['debug', 'info', 'warn', 'error', 'report', 'disable'].includes(option.logLevel)) {
            this.logger.setLogLevel(option.logLevel);
            this.dataReport.addMsgInfo(reportSeq, {
                log_level: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskSetLog.log_level(option.logLevel),
            });
        }
        if (option.remoteLogLevel &&
            ['debug', 'info', 'warn', 'error', 'report', 'disable'].includes(option.remoteLogLevel)) {
            // this.logger.setRemoteLogLevel(option.remoteLogLevel);
            this.dataReport.addMsgInfo(reportSeq, {
                remote_log_level: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskSetLog.remote_log_level(option.remoteLogLevel),
            });
        }
        if (typeof option.logURL == 'string' &&
            (option.logURL.startsWith('wss://') || option.logURL.startsWith('https://'))) {
            this.logger.setLogServer(option.logURL);
            this.dataReport.addMsgInfo(reportSeq, {
                log_url: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskSetLog.log_url(option.logURL),
            });
            this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskSetLog.event);
        }
        else if (option.logURL) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SET_LOG_CONFIG + 'log url must be a wss or https url');
            this.dataReport.addMsgInfo(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskSetLog.error.kInvalidParamError);
            this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskSetLog.event);
            return false;
        }
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SET_LOG_CONFIG + ' call success');
        return true;
    };
    ZegoExpressWebRTM.prototype.setDebugVerbose = function (enable) {
        var reportSeq = zego_entity_2.getReportSeq();
        this.dataReport.newReport(reportSeq);
        if (typeof enable == 'boolean') {
            this.stateCenter.debug = enable;
            this.stateCenter.debugCustom = true;
            this.dataReport.addMsgInfo(reportSeq, {
                debug: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskSetDebug.debug(enable ? 'true' : 'false'),
            });
        }
        this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskSetDebug.event);
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SET_DEBUG_VERBOSE + ' call success');
    };
    ZegoExpressWebRTM.prototype.setDebug = function (server) {
        if (typeof server === 'string' && server.indexOf('wss') > -1) {
            this.stateCenter.debug = client_util_1.ClientUtil.isTestEnv(server);
        }
        else if (Array.isArray(server) &&
            server.length > 0 &&
            server.every(function (v) { return typeof v === 'string' && v.indexOf('wss') > -1; })) {
            this.stateCenter.debug = client_util_1.ClientUtil.isTestEnv(server[0]);
            // TODO
            // !this.stateCenter.debug && server[1] && (this.stateCenter.debug = ClientUtil.isTestEnv(server[1]));
        }
        else {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CONSTRUCTOR + ' server wrong');
        }
        this.stateCenter.testEnvironment = this.stateCenter.debug;
    };
    ZegoExpressWebRTM.prototype.renewToken = function (token, roomID) {
        var _this = this;
        var _a, _b;
        var reportSeq = zego_entity_2.getReportSeq();
        this.dataReport.newReport(reportSeq);
        if (typeof roomID !== 'undefined' && (typeof roomID !== 'string' || roomID == '')) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_RENEWTOKEN + ' roomID must be string and no empty');
            return false;
        }
        var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
        if (!room) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_RENEWTOKEN + ' calling must after loginRoom');
            this.dataReport.addMsgInfo(reportSeq, {
                error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.error.NOT_LOGIN.code,
                message: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.error.NOT_LOGIN.msg,
            });
            this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.event);
            return false;
        }
        if (typeof token === 'string' && room.roomTryHandler) {
            if (token === room.roomTryHandler.token) {
                this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_RENEWTOKEN + ' token has not changed');
            }
            else {
                (_a = room.roomTryHandler) === null || _a === void 0 ? void 0 : _a.renewLocalToken(token);
                this.cloudSetting.setToken(token);
                var sucCallBack = function (msg) {
                    var _a, _b;
                    (_a = room.roomTryHandler) === null || _a === void 0 ? void 0 : _a.renewLocalToken(token, (_b = msg === null || msg === void 0 ? void 0 : msg.body) === null || _b === void 0 ? void 0 : _b.token_remain_time);
                    _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_RENEWTOKEN + ' ' + JSON.stringify(msg));
                };
                var failCallBack = function (error) {
                    // 临时调试 token
                    _this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_RENEWTOKEN + ' ' + JSON.stringify(error));
                };
                if (this.stateCenter.useNetAgent) {
                    (_b = this.liveRoomHandler) === null || _b === void 0 ? void 0 : _b.renewToken({ token: token }, sucCallBack, failCallBack, room);
                }
                else {
                    this.service.sendMessage('renew_token', { token: token }, sucCallBack, failCallBack, undefined, {
                        sessionID: room.sessionID,
                        roomID: roomID,
                        roomSessionID: room.roomSessionID,
                    });
                }
            }
            this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.event);
            return true;
        }
        else if (typeof token === 'string' && !room.roomTryHandler) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_RENEWTOKEN + ' calling must after loginRoom');
            this.dataReport.addMsgInfo(reportSeq, {
                error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.error.NOT_LOGIN.code,
                message: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.error.NOT_LOGIN.msg,
            });
            this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.event);
            return false;
        }
        else {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_RENEWTOKEN + ' token must be string and not empty');
            this.dataReport.addMsgInfo(reportSeq, {
                error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.error.INPUT_PARAM.code,
                message: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.error.INPUT_PARAM.msg + ' param token error',
            });
            this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.event);
            return false;
        }
    };
    ZegoExpressWebRTM.prototype.setCloudSettingURLs = function (urls) {
        var _this = this;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SET_CLOUD_SETTING_URLS + ' call ');
        if (Array.isArray(urls) &&
            urls.length > 0 &&
            urls.every(function (v) { return typeof v === 'string' && v.indexOf('http') > -1; })) {
            this.cloudSetting.init({
                product: zego_config_1.CLOUD_SETTING.product,
                appID: this.stateCenter.appid,
                urls: urls,
                pollingFreq: zego_config_1.CLOUD_SETTING.POLLING_FREQ,
                env: this.stateCenter.ENV,
                pollingNotify: function (file, settingJson) {
                    _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SET_CLOUD_SETTING_URLS, ' setting file changed ' + file + ' ' + JSON.stringify(settingJson));
                    _this.stateCenter.actionListener('_cloudSettingNotify', file, settingJson);
                },
                reportNotify: this.cloudReportNotify.bind(this),
                online: !this.stateCenter.testEnvironment,
            });
        }
    };
    //房间相关---登录，房间人员变化
    ZegoExpressWebRTM.prototype.loginRoom = function (roomID, token, user, config) {
        var _this = this;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM + ' call by user ' + (user === null || user === void 0 ? void 0 : user.userID) + ' ' + roomID);
        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
            var _a, interResolve, interReject, res, roomModules, roomServer;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(this.stateCenter.ENV === 1)) return [3 /*break*/, 2];
                        return [4 /*yield*/, new Promise(function (resolveNetWoke) {
                                wx.getNetworkType({
                                    success: function (res) {
                                        _this.stateCenter.networkState =
                                            res.networkType === 'none' ? zego_entity_1.ENUM_NETWORK_STATE.offline : zego_entity_1.ENUM_NETWORK_STATE.online;
                                        resolveNetWoke();
                                    },
                                    fail: function (err) {
                                        _this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CONSTRUCTOR + ' network ' + JSON.stringify(err));
                                        _this.stateCenter.networkState = zego_entity_1.ENUM_NETWORK_STATE.online;
                                        resolveNetWoke();
                                    },
                                });
                            })];
                    case 1:
                        _b.sent();
                        _b.label = 2;
                    case 2:
                        _a = this.loginReport(resolve, reject, token, config), interResolve = _a.interResolve, interReject = _a.interReject;
                        config = config || {};
                        !config.maxMemberCount && (config.maxMemberCount = 0);
                        res = param_util_1.checkParams({
                            roomID: {
                                order: 0,
                                value: roomID,
                                rules: [
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.NOT_EMPTY,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.ROOM_ID_NULL,
                                    },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.TYPE_STRING,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.INPUT_PARAM,
                                        extMsg: 'roomID must be string',
                                    },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.MAX_LENGTH_128,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.ROOM_ID_TOO_LONG,
                                    },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.ILLEGAL_CHARACTERS,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.ROOM_ID_INVALID_CHARACTER,
                                    },
                                ],
                            },
                            token: {
                                order: 1,
                                value: token,
                                rules: [
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.NOT_EMPTY,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.INPUT_PARAM,
                                    },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.TYPE_STRING,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.INPUT_PARAM,
                                    },
                                ],
                            },
                            user: {
                                order: 2,
                                value: user,
                                rules: [
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.NOT_EMPTY,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.INPUT_PARAM,
                                        extMsg: ' param user error.',
                                    },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.TYPE_OBJECT,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.INPUT_PARAM,
                                        extMsg: ' param user error.',
                                    },
                                ],
                            },
                            'user.userID': {
                                order: 3,
                                value: user.userID,
                                rules: [
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.NOT_EMPTY,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.USER_ID_NULL,
                                        extMsg: ' param user error.',
                                    },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.TYPE_STRING,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.INPUT_PARAM,
                                        extMsg: ' param userID error.',
                                    },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.MAX_LENGTH_100,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.USER_ID_TOO_LONG,
                                    },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.ILLEGAL_CHARACTERS,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.USER_ID_INVALID_CHARACTER,
                                    },
                                ],
                            },
                            'user.userName': {
                                order: 4,
                                value: user.userName,
                                rules: [
                                    // {
                                    //     name: RULE_PARAM_NAME.NOT_EMPTY,
                                    //     error: ZegoRTMLogEvent.kZegoTaskLoginRoom.error.USER_NAME_NULL,
                                    // },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.TYPE_STRING,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.INPUT_PARAM,
                                        extMsg: ' userName must be string.',
                                    },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.MAX_LENGTH_256,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.USER_NAME_TOO_LONG,
                                    },
                                ],
                            },
                            config: {
                                order: 5,
                                value: config,
                                rules: [],
                            },
                            'config.maxMemberCount': {
                                order: 6,
                                value: config.maxMemberCount,
                                rules: [
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.TYPE_INTEGER,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.INPUT_PARAM,
                                        extMsg: ' maxMemberCount must be integer number.',
                                    },
                                ],
                            },
                        }, {
                            action: zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM,
                            logger: this.logger,
                        });
                        if (res !== param_util_1.RULE_SUCCESS) {
                            interReject(res.error, res.extMsg);
                            return [2 /*return*/];
                        }
                        if (this.netAgent) {
                            this.stateCenter.idName = user.userID;
                            this.stateCenter.actionListener('_roomLogin', roomID, token);
                            if (this.netAgent.isConnect()) {
                                this.fetchAppConfig(token);
                            }
                        }
                        // 云控
                        this.cloudSetting.setUserID(user.userID);
                        this.cloudSetting.setToken(token);
                        this.cloudSetting.activePolling();
                        this.stateCenter.onListener('roomLoginResponse', function (msg) {
                            if (!_this.stateCenter.settingFetched) {
                                _this.getCloudSetting();
                                _this.stateCenter.actionListener('_settingCanFetch');
                                _this.stateCenter.settingFetched = true;
                            }
                        });
                        roomModules = this.getRoomModules(roomID);
                        if (!roomModules) {
                            roomModules = new modules_1.LiveRoomModules(roomID, this.stateCenter, this.logger, this.dataReport, this.service, this, this.liveRoomHandler);
                            if (this.stateCenter.roomModulesList.length > 0 && this.stateCenter.isMultiRoom == true) {
                                //当前为多房间且已存在其它房间
                                roomModules.isMulti = true;
                            }
                            else {
                                __spreadArrays(this.stateCenter.roomModulesList).forEach(function (room) { return room.roomHandler.logout(); });
                            }
                            this.stateCenter.roomModulesList.push(roomModules);
                        }
                        else {
                            //忽略二次登录
                            interReject(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.REPEATEDLY_LOGIN);
                            return [2 /*return*/];
                        }
                        if (!roomModules.roomTryHandler) {
                            roomModules.roomTryHandler = new retryRoomHandler_1.RetryRoomHandler(this.logger, this.stateCenter, roomModules);
                        }
                        roomServer = this.stateCenter.settingConfig.getSetting('room_server', true);
                        if (Array.isArray(roomServer) && roomServer.length > 0) {
                            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM, ' setting room_server ' + roomServer);
                            this.stateCenter.server = roomServer[0];
                            this.stateCenter.serverBak = roomServer[1] || roomServer[0];
                        }
                        roomModules.roomTryHandler.init(this.stateCenter.roomRetryTime);
                        roomModules.roomTryHandler.initRoom(roomModules.roomHandler, roomID, token, user, this.stateCenter.server, this.stateCenter.serverBak, config);
                        roomModules.roomTryHandler.setLoginRoomCallback(interResolve, interReject);
                        //登录房间则不再允许设置multiRoom
                        this.stateCenter.setMultiRoom = true;
                        if (this.stateCenter.useNetAgent && !this.netAgent.isConnect()) {
                            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM, ' us is not connected');
                            this.netAgent.connectUa();
                            return [2 /*return*/];
                        }
                        roomModules.roomTryHandler.active(true);
                        return [2 /*return*/];
                }
            });
        }); });
    };
    ZegoExpressWebRTM.prototype.handleLogUpload = function () {
        var domain = this.stateCenter.appConfig.app_config.domain;
        // 主域名，不同 appid 可能不同
        if (!domain) {
            return;
        }
        this.stateCenter.logDomain = "weblogger" + this.stateCenter.appid + "-api." + domain;
        var logUrl = '';
        if (this.stateCenter.ENV === 0) {
            logUrl = "wss://" + this.stateCenter.logDomain + "/log";
        }
        else {
            logUrl = "https://" + this.stateCenter.logDomain + "/httplog";
        }
        this.logger.setLogServer(logUrl);
    };
    ZegoExpressWebRTM.prototype.fetchAppConfig = function (token) {
        return __awaiter(this, void 0, void 0, function () {
            var userID, _token, _a, code, data, app_config, _b, publish_config, play_config, configString, ciphertext, error_1;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (this.stateCenter.appConfigFetched) {
                            this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_FETCH_APP_CONFIG + ' config fetched');
                            return [2 /*return*/];
                        }
                        userID = this.getUserID();
                        if (!userID) {
                            this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_FETCH_APP_CONFIG + ' user not exist');
                            return [2 /*return*/];
                        }
                        _token = '';
                        if (token) {
                            _token = token;
                        }
                        else if (this.stateCenter.roomModulesList.length > 0) {
                            _token = this.getToken();
                        }
                        else {
                            this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_FETCH_APP_CONFIG + ' token not exist');
                            return [2 /*return*/];
                        }
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.netAgent.getAppConfig(userID, _token)];
                    case 2:
                        _a = _c.sent(), code = _a.code, data = _a.data;
                        this.stateCenter.appConfigFetched = true;
                        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM + ' initConfig code:' + code + ' data: ' + JSON.stringify(data));
                        app_config = data.app_config, _b = data.media_config, publish_config = _b.publish_config, play_config = _b.play_config;
                        this.stateCenter.appConfig = { app_config: app_config, media_config: { publish_config: publish_config, play_config: play_config } };
                        configString = JSON.stringify(this.stateCenter.appConfig);
                        ciphertext = client_util_1.ClientUtil.encryptStores(configString, zego_config_1.STORE_SECRET);
                        localStorage.setItem(net_config_1.APP_CONFIG_KEY + '_' + this.getAppID() + '_' + net_1.NET_ACCESS_CONFIG.modeNo, ciphertext);
                        if (!this.stateCenter.appConfig) {
                            this.stateCenter.actionListener('_appConfigRsp');
                            this.handleLogUpload();
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _c.sent();
                        this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM + ' fail ' + JSON.stringify(error_1));
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    ZegoExpressWebRTM.prototype.getHttpRequest = function () {
        var mixRequest = this.netAgent.getHttpRequest(AccessHubDefine_1.BusinessService.SERVICE_MIX);
        mixRequest &&
            mixRequest.sendRequest({
                headers: [],
                body: {},
                idName: this.stateCenter.idName,
                method_no: AccessHubDefine_2.Method.METHOD_POST,
                ack: true,
                location: '',
            }, function () { }, function () { }, function () { });
    };
    ZegoExpressWebRTM.prototype.getLiveRoomPCRequest = function () {
        var liveroomRequest = this.netAgent.getPCRequest(AccessHubDefine_1.BusinessService.SERVICE_SWITCH4LIVEROOM);
        // if (liveroomRequest) {
        liveroomRequest.on('connected', function () { });
        liveroomRequest.on('broken', function () { });
        liveroomRequest.on('disconnected', function () { });
        liveroomRequest.on('downLoadMessage', function (payload) { });
        liveroomRequest.sendRequest({ payload: '' }, function () { }, function (err) { });
        // }
    };
    ZegoExpressWebRTM.prototype.getCloudSetting = function () {
        var _this = this;
        this.cloudSetting
            .fetchMultiSetting([zego_config_1.INIT, zego_config_1.ROOM_BASIC])
            .then(function (settingConfig) {
            var _a;
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM, ' settingConfig ' + JSON.stringify(settingConfig));
            _this.stateCenter.settingConfig.setSetting((_a = settingConfig === null || settingConfig === void 0 ? void 0 : settingConfig[zego_config_1.INIT]) === null || _a === void 0 ? void 0 : _a.setting, ['remote_log_level']);
            var level = _this.stateCenter.settingConfig.getSetting('remote_log_level', true);
            if (level) {
                _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM + "  setting remote_log_level " + level);
                _this.logger.setRemoteLogLevel(level);
            }
        })
            .catch(function (err) {
            _this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM, ' settingConfig ' + JSON.stringify(err));
        });
        this.stateCenter.onListener('_cloudSettingNotify', function (file, settingFile) {
            var reportSeq = zego_entity_2.getReportSeq();
            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskCloudSettingRefresh.event);
            var params = _this.cloudSetting.getEnvVariables();
            _this.dataReport.addMsgInfo(reportSeq, {
                params: params,
                files: [
                    {
                        name: file,
                        content: settingFile.setting,
                        versions: settingFile.versions,
                    },
                ],
            });
            _this.dataReport.uploadReport(reportSeq);
            if (file === zego_config_1.INIT) {
                _this.stateCenter.settingConfig.setSetting(settingFile === null || settingFile === void 0 ? void 0 : settingFile.setting, ['remote_log_level']);
                var level = _this.stateCenter.settingConfig.getSetting('remote_log_level');
                if (level) {
                    _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM, " setting remote_log_level " + level);
                    _this.logger.setRemoteLogLevel(level);
                }
            }
        });
    };
    ZegoExpressWebRTM.prototype.cloudReportNotify = function (seq, event, extData) {
        // console.warn(seq, event, reportData);
        if (event === 'request_start') {
            var requestSeq = zego_entity_2.getReportSeq();
            this.dataReport.newReport(requestSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskCloudSettingRequest.event);
            this.stateCenter.settingConfig.requestList[seq] = requestSeq;
        }
        else if (event === 'request_end') {
            var rseq = this.stateCenter.settingConfig.requestList[seq];
            if (rseq) {
                this.dataReport.addMsgInfo(rseq, {
                    request_detail: extData === null || extData === void 0 ? void 0 : extData.reportData,
                    files: extData === null || extData === void 0 ? void 0 : extData.files,
                    error: extData === null || extData === void 0 ? void 0 : extData.code,
                    request_params: extData === null || extData === void 0 ? void 0 : extData.params,
                });
                this.dataReport.uploadReport(rseq);
            }
        }
    };
    // 日志事件上报
    ZegoExpressWebRTM.prototype.loginReport = function (resolve, reject, token, config) {
        var _this = this;
        // 检查事件存在
        if (this.stateCenter.reportSeqList.login !== 0) {
            this.dataReport.uploadReport(this.stateCenter.reportSeqList.login);
            this.stateCenter.reportSeqList.login = 0;
            client_util_1.ClientUtil.unregisterCallback(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.event, this.stateCenter.reportList);
        }
        // 事件开始
        var reportSeq = zego_entity_2.getReportSeq();
        this.stateCenter.reportSeqList.login = reportSeq;
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.event);
        var deviceid = this.cloudSetting.getEnvVariable('deviceid');
        this.dataReport.addMsgInfo(reportSeq, {
            deviceid: deviceid,
        });
        typeof token === 'string' &&
            this.dataReport.addMsgInfo(reportSeq, {
                token: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.token(token),
                isMulti: this.stateCenter.isMultiRoom,
            });
        if (config) {
            if (config.userUpdate && typeof config.userUpdate == 'boolean') {
                this.dataReport.addMsgInfo(reportSeq, {
                    user_update: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.user_update(config.userUpdate + ''),
                });
            }
            if (config.maxMemberCount && typeof config.maxMemberCount == 'number') {
                this.dataReport.addMsgInfo(reportSeq, {
                    max_member_count: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.max_member_count(config.maxMemberCount + ''),
                });
            }
        }
        // register event trigger, can add report event by actionSuccessCallback
        client_util_1.ClientUtil.logReportCallback(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.event, this.dataReport, reportSeq, this.stateCenter.reportList);
        var interResolve = function (suc) {
            _this.dataReport.uploadReport(reportSeq);
            _this.stateCenter.reportSeqList.login = 0;
            client_util_1.ClientUtil.unregisterCallback(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.event, _this.stateCenter.reportList);
            resolve(suc);
        };
        var interReject = function (err, exterMsg) {
            if (exterMsg === void 0) { exterMsg = ''; }
            var reportErr, exterErr;
            // 登录相关的 liveroom 错误码转换
            if ((err.code < 2000000000 && err.code > 1000000000) || err.code < 1000000) {
                reportErr = client_util_1.ClientUtil.decodeServerError(err.code, err.msg);
                exterErr = client_util_1.ClientUtil.getLiveRoomError(err.code, _this.stateCenter.useNetAgent);
            }
            else {
                reportErr = {
                    code: err.code,
                    message: err.msg,
                };
            }
            reportErr &&
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: reportErr.code,
                    message: reportErr.message + exterMsg,
                });
            _this.dataReport.uploadReport(reportSeq);
            _this.stateCenter.reportSeqList.login = 0;
            client_util_1.ClientUtil.unregisterCallback(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.event, _this.stateCenter.reportList);
            // @ts-ignore
            if (exterErr && zego_externalError_1.errorCodeList[exterErr]) {
                // @ts-ignore
                err.code = zego_externalError_1.errorCodeList[exterErr].code;
                // @ts-ignore
                // err.msg = errorCodeList[exterErr].msg + exterMsg;
            }
            if (err.code && err.msg && exterMsg !== '') {
                reject({
                    code: err.code,
                    msg: err.msg + exterMsg,
                });
            }
            else {
                reject(err);
            }
        };
        return { interResolve: interResolve, interReject: interReject };
    };
    ZegoExpressWebRTM.prototype.logoutRoom = function (roomID) {
        this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGOUT_ROOM + ' call by user ' + roomID);
        var reportSeq = zego_entity_2.getReportSeq();
        this.dataReport.newReport(reportSeq);
        this.dataReport.addMsgInfo(reportSeq, {
            roomid: roomID,
            isMulti: this.stateCenter.isMultiRoom,
        });
        if (roomID === undefined) {
            //未传roomID,默认认为退出所有房间
            __spreadArrays(this.stateCenter.roomModulesList).forEach(function (room) { return room.roomHandler.logout(true); });
            this.cloudSetting.uninit();
        }
        else {
            if (typeof roomID !== 'string' || roomID == '') {
                this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGOUT_ROOM + ' roomID must be string and not empty');
                this.dataReport.addMsgInfo(reportSeq, {
                    error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLogoutRoom.error.INPUT_PARAM.code,
                    message: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLogoutRoom.error.INPUT_PARAM.msg + ' param roomID error',
                });
                this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLogoutRoom.event);
                return;
            }
            var room = this.getRoomModules(roomID);
            if (room) {
                room.roomHandler.logout();
                if (this.stateCenter.roomModulesList.length === 0) {
                    this.cloudSetting.uninit();
                }
                this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLogoutRoom.event);
            }
            else {
                this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGOUT_ROOM + ' room not exist');
                this.dataReport.addMsgInfo(reportSeq, {
                    error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLogoutRoom.error.ROOM_NOT_EXIST.code,
                    message: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLogoutRoom.error.ROOM_NOT_EXIST.msg,
                });
                this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLogoutRoom.event);
            }
        }
    };
    //登录大厅
    ZegoExpressWebRTM.prototype.loginHall = function (token, user, config) {
        var _this = this;
        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2 /*return*/];
        }); }); });
    };
    ZegoExpressWebRTM.prototype.loginHallReport = function (resolve, reject, token, config) { };
    //退出大厅
    ZegoExpressWebRTM.prototype.logoutHall = function () { };
    //房间相关---登录，房间人员变化
    ZegoExpressWebRTM.prototype.enterRoom = function (roomID, role) {
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    ZegoExpressWebRTM.prototype.leaveRoom = function () {
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    // public getRoomInfo(callBack: Function): void {
    //     (this.module as LiveRoomPriModules).roomPrivateHandler.getRoomInfo();
    // }
    ZegoExpressWebRTM.prototype.sendCustomCommand = function (roomID, command, toUserList) {
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    ZegoExpressWebRTM.prototype._sendCustomCommand = function (roomID, command, toUserList) {
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    ZegoExpressWebRTM.prototype.sendBroadcastMessage = function (roomID, message) {
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    ZegoExpressWebRTM.prototype._sendBroadcastMessage = function (roomID, message, category, type) {
        if (category === void 0) { category = 1; }
        if (type === void 0) { type = 1; }
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    ZegoExpressWebRTM.prototype.setRoomExtraInfo = function (roomID, type, data) {
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    ZegoExpressWebRTM.prototype._setRoomExtraInfo = function (roomID, type, data) {
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    ZegoExpressWebRTM.prototype.sendBarrageMessage = function (roomID, message) {
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    ZegoExpressWebRTM.prototype._sendBarrageMessage = function (roomID, message, category, type) {
        if (category === void 0) { category = 1; }
        if (type === void 0) { type = 1; }
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    ZegoExpressWebRTM.prototype.sendRelayMessage = function (type, data, success, error, roomID) {
        console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
    };
    ZegoExpressWebRTM.prototype.requestJoinLive = function (destIdName, success, error, resultCallback, roomID) {
        console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
        return false;
    };
    ZegoExpressWebRTM.prototype.inviteJoinLive = function (destIdName, success, error, resultCallback, roomID) {
        console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
        return false;
    };
    ZegoExpressWebRTM.prototype.endJoinLive = function (destIdName, success, error, roomID) {
        console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
        return false;
    };
    ZegoExpressWebRTM.prototype.respondJoinLive = function (requestId, respondResult, success, error, roomID) {
        console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
        return false;
    };
    ZegoExpressWebRTM.prototype.getVersion = function () {
        return this.version;
    };
    ZegoExpressWebRTM.prototype.setSdkBizVersion = function (bizVersion) {
        if (typeof bizVersion === 'string' && bizVersion !== '') {
            this.stateCenter.bizVersion = bizVersion;
        }
    };
    ZegoExpressWebRTM.prototype.on = function (event, callBack) {
        if (!this.stateCenter.listenerList[event]) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_ON + ' event ' + event + ' no found');
            return false;
        }
        if (typeof callBack !== 'function') {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_ON + ' listener callBack must be funciton');
            return false;
        }
        this.stateCenter.listenerList[event].indexOf(callBack) == -1 &&
            this.stateCenter.listenerList[event].push(callBack);
        return true;
    };
    ZegoExpressWebRTM.prototype.off = function (event, callBack) {
        if (!this.stateCenter.listenerList[event]) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_OFF + ' listener no found');
            return false;
        }
        var li = this.stateCenter.listenerList[event];
        if (callBack) {
            li.splice(li.indexOf(callBack), 1);
        }
        else {
            this.stateCenter.listenerList[event] = [];
        }
        return true;
    };
    ZegoExpressWebRTM.prototype._on = function (event, callBack) {
        if (!this.stateCenter.listenerList[event]) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_ON + ' event ' + event + ' no found');
            return false;
        }
        if (typeof callBack !== 'function') {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_ON + ' listener callBack must be funciton');
            return false;
        }
        this.stateCenter.listenerList[event].indexOf(callBack) == -1 &&
            this.stateCenter.listenerList[event].push(callBack);
        return true;
    };
    ZegoExpressWebRTM.prototype._off = function (event, callBack) {
        if (!this.stateCenter.listenerList[event]) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_OFF + ' listener no found');
            return false;
        }
        var li = this.stateCenter.listenerList[event];
        if (callBack) {
            li.splice(li.indexOf(callBack), 1);
        }
        else {
            this.stateCenter.listenerList[event] = [];
        }
        return true;
    };
    ZegoExpressWebRTM.prototype.isTestEnvironment = function () {
        return this.stateCenter.testEnvironment;
    };
    ZegoExpressWebRTM.prototype.isLogin = function (roomID) {
        var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
        return room ? room.isLogin() : false;
    };
    ZegoExpressWebRTM.prototype.getMultiRoom = function () {
        return this.stateCenter.isMultiRoom;
    };
    ZegoExpressWebRTM.prototype.getAppID = function () {
        return this.stateCenter.appid;
    };
    ZegoExpressWebRTM.prototype.getUserID = function () {
        return this.stateCenter.idName;
    };
    ZegoExpressWebRTM.prototype.getUseNetAgent = function () {
        return this.stateCenter.useNetAgent;
    };
    ZegoExpressWebRTM.prototype.getToken = function (roomID) {
        var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
        return room.token;
    };
    // public getAnType(): number {
    //     return (this.module as LiveRoomPriModules).anType;
    // }
    // public getRoomSid(): string {
    //     return (this.module as LiveRoomPriModules).roomSid;
    // }
    ZegoExpressWebRTM.prototype.setRoomCreateFlag = function (flag) {
        this.stateCenter.roomCreateFlag = flag;
    };
    ZegoExpressWebRTM.prototype.setRole = function (role) {
        this.stateCenter.role = role;
    };
    ZegoExpressWebRTM.prototype.getSessionId = function (roomID) {
        var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
        return room ? room.sessionID : '0';
    };
    ZegoExpressWebRTM.prototype.getRoomSessionID = function (roomID) {
        var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
        return room ? room.roomSessionID : '0';
    };
    ZegoExpressWebRTM.prototype.getAppConfig = function () {
        return this.stateCenter.appConfig;
    };
    ZegoExpressWebRTM.prototype.enableMultiRoom = function (isMulti) {
        var reportSeq = zego_entity_2.getReportSeq();
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoEnableMultiRoom.event);
        this.dataReport.addMsgInfo(reportSeq, {
            isMulti: isMulti,
        });
        if (typeof isMulti !== 'boolean') {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_ENABLE_MULTI_ROOM + ' param must be boolean');
            this.dataReport.uploadReport(reportSeq, undefined, zego_log_event_1.ZegoRTMLogEvent.kZegoEnableMultiRoom.error.kAlreadyLoginError);
            return false;
        }
        if (this.stateCenter.roomModulesList.length > 0 || this.stateCenter.setMultiRoom) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_ENABLE_MULTI_ROOM +
                ' multi room can only be set once before first login');
            this.dataReport.uploadReport(reportSeq, undefined, zego_log_event_1.ZegoRTMLogEvent.kZegoEnableMultiRoom.error.kAlreadyLoginError);
            return false;
        }
        this.dataReport.uploadReport(reportSeq);
        this.stateCenter.isMultiRoom = isMulti;
        this.stateCenter.setMultiRoom = true;
        return true;
    };
    ZegoExpressWebRTM.prototype.getRoomModules = function (roomID) {
        return this.stateCenter.roomModulesList.find(function (roomModules) { return roomModules.roomID == roomID; });
    };
    // private dispatchBodyData() {
    //     return {
    //         seq: 1,
    //         timestamp: new Date().getTime,
    //         app_id: this.stateCenter.appid,
    //         user_id: this.stateCenter.idName,
    //         user_name: this.stateCenter.nickName,
    //         net_type: 2,
    //         device_id: (this.module as LiveRoomPriModules).deviceID,
    //         login_token: (this.module as LiveRoomPriModules).hallToken,
    //         an_type: (this.module as LiveRoomPriModules).anType,
    //     };
    // }
    ZegoExpressWebRTM.use = function (module) {
        switch (module.type) {
            case 'message':
                module.install(ZegoExpressWebRTM, modules_1.LiveRoomModules, service_1.LiveRoomService, liveroomHandler_1.LiveRoomHandler, index_private_1.LiveRoomModules, service_private_1.LiveRoomPrivateService);
                break;
            case 'live':
                module.install(ZegoExpressWebRTM, modules_1.LiveRoomModules, service_1.LiveRoomService, liveroomHandler_1.LiveRoomHandler);
                break;
            case 'privates':
                module.install(ZegoExpressWebRTM, index_private_1.LiveRoomModules, service_private_1.LiveRoomPrivateService);
                break;
        }
    };
    // support RTC
    ZegoExpressWebRTM.prototype.resetRoomTokenTimer = function (roomID, remainTime) {
        var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
        if (room && remainTime && remainTime > 0) {
            room.roomHandler.resetTokenTimer(remainTime * 1000 - this.stateCenter.local_time_deviation);
        }
    };
    ZegoExpressWebRTM.prototype.isDisConnect = function () {
        if (this.stateCenter.useNetAgent) {
            return this.liveRoomHandler.isDisConnect();
        }
        else {
            return this.service.isDisConnect();
        }
    };
    ZegoExpressWebRTM.prototype.sendMessage = function (cmd, body, suc, err) {
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.sendMessage(cmd, body, suc, err);
    };
    // support whiteborad 提供白板需要方法
    // 设置协议格式类型，可选值 “json”、“pb”
    ZegoExpressWebRTM.prototype.setProtoFormat = function (format) {
        if (format === void 0) { format = 'json'; }
        if (['json', 'pb'].includes(format)) {
            this.stateCenter.protoFormat = format;
        }
        else {
            throw new Error("Failed to execute 'setProtoFormat': Arguments 'format' must be 'json' or 'pb'.");
        }
    };
    // 登录前同步
    ZegoExpressWebRTM.prototype.setSdkLoginRelateService = function (relateService) {
        if (Array.isArray(relateService) && relateService.every(function (v) { return typeof v === 'string'; })) {
            this.stateCenter.relateService = relateService;
        }
    };
    // 发送消息（JSON请求）
    ZegoExpressWebRTM.prototype.sendMessageByService = function (cmd, body, suc, err, theHeader, customRoom) {
        return this.service.sendMessage(cmd, body, suc, err, theHeader, customRoom);
    };
    // 获取请求头（PB请求）
    ZegoExpressWebRTM.prototype.getHeader = function (cmd) {
        var room = this.stateCenter.roomModulesList[0];
        if (!room || !room.isLogin()) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_GET_HEADER + ' room no found or no login');
            return;
        }
        var roomID = room.roomID;
        var sessionID = room.sessionID;
        var roomSessionID = room.roomSessionID;
        return this.service.getHeader(cmd, sessionID, roomID, roomSessionID);
    };
    // 发送消息（PB请求）
    ZegoExpressWebRTM.prototype.sendPB = function (msg) {
        if (!(msg instanceof Uint8Array)) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_PB + ' type error');
            return false;
        }
        return this.service.sendPB(msg);
    };
    // 注册 biz_channel 推送消息
    ZegoExpressWebRTM.prototype.onPushBizChannel = function (callback) {
        callback && this.service.on('push_biz_channel', callback);
    };
    // 获取信息接口
    ZegoExpressWebRTM.prototype.getRoomID = function () {
        return this.stateCenter.roomid;
    };
    ZegoExpressWebRTM.prototype.getServerTimeOffset = function () {
        return this.stateCenter.serverTimeOffset;
    };
    // 是否使用统一接入
    ZegoExpressWebRTM.prototype.isUseNetAgent = function () {
        return this.stateCenter.useNetAgent;
    };
    ZegoExpressWebRTM.prototype.getReqHead = function (roomID) {
        var room;
        if (typeof roomID === 'string' && roomID !== '') {
            room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
        }
        else {
            room = this.stateCenter.roomModulesList[0];
        }
        return this.liveRoomHandler.getReqHead(room);
    };
    ZegoExpressWebRTM.prototype.sendSwitchMessage = function (cmd, body) {
        if (typeof cmd !== 'string' || !body) {
            return -1;
        }
        return this.liveRoomHandler.sendMessage(cmd, body, undefined, undefined, undefined, false);
    };
    ZegoExpressWebRTM.prototype.onSwitchMessage = function (callback) {
        console.error('onSwitchMessage', callback, this.liveRoomHandler);
        callback && this.liveRoomHandler && (this.liveRoomHandler.onSwitchMessage = callback);
    };
    return ZegoExpressWebRTM;
}());
exports.ZegoExpressWebRTM = ZegoExpressWebRTM;


/***/ }),

/***/ "./sdk/src/modules/EventManager.ts":
/*!*****************************************!*\
  !*** ./sdk/src/modules/EventManager.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EventManager = void 0;
var EventManager = /** @class */ (function () {
    function EventManager() {
        this.handlerListMap = {};
    }
    EventManager.prototype.addEventHandler = function (listener, callBack) {
        if (!this.handlerListMap[listener]) {
            // return false;
            this.handlerListMap[listener] = [];
        }
        if (typeof callBack !== 'function') {
            throw new Error('Params callBack is not a Function');
        }
        this.handlerListMap[listener] &&
            this.handlerListMap[listener].indexOf(callBack) == -1 &&
            this.handlerListMap[listener].push(callBack);
        return true;
    };
    EventManager.prototype.removeEventHandler = function (listener, callBack) {
        if (!this.handlerListMap[listener]) {
            return false;
        }
        if (callBack) {
            this.handlerListMap[listener] = this.handlerListMap[listener].filter(function (item) { return item !== callBack; });
        }
        else {
            this.handlerListMap[listener] = [];
        }
        return true;
    };
    EventManager.prototype.emit = function (listener) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.handlerListMap[listener] &&
            this.handlerListMap[listener].forEach(function (func) {
                try {
                    setTimeout(function () {
                        func.apply(void 0, args);
                    }, 0);
                }
                catch (error) {
                    console.error('dispatch ' + listener + ' ' + error);
                }
            });
    };
    return EventManager;
}());
exports.EventManager = EventManager;


/***/ }),

/***/ "./sdk/src/modules/heartBeatHandler.ts":
/*!*********************************************!*\
  !*** ./sdk/src/modules/heartBeatHandler.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_463726__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HeartBeatHandler = void 0;
var zego_entity_1 = __nested_webpack_require_463726__(/*! ../zego.entity */ "./sdk/src/zego.entity.ts");
var client_util_1 = __nested_webpack_require_463726__(/*! ../../util/client-util */ "./sdk/util/client-util.ts");
var zego_externalError_1 = __nested_webpack_require_463726__(/*! ../zego.externalError */ "./sdk/src/zego.externalError.ts");
var zego_action_1 = __nested_webpack_require_463726__(/*! ../zego.action */ "./sdk/src/zego.action.ts");
var zego_log_event_1 = __nested_webpack_require_463726__(/*! ../zego.log.event */ "./sdk/src/zego.log.event.ts");
var MAX_TRY_HEARTBEAT_COUNT = 3; //最大心跳尝试次数
var HeartBeatHandler = /** @class */ (function () {
    function HeartBeatHandler(logger, stateCenter, dataReport, service, liveRoomHandler, room) {
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.dataReport = dataReport;
        this.service = service;
        this.liveRoomHandler = liveRoomHandler;
        this.room = room;
        this.tryHeartbeatCount = 0;
        this.heartbeatTimer = null;
        this.loginHeartbeatTimer = null;
        this.initCount = 0;
    }
    //处理心跳
    HeartBeatHandler.prototype.init = function (msg) {
        var _this = this;
        var heartbeatInterval;
        // if (this.stateCenter.type == 'PRIVATE') {
        //     heartbeatInterval =
        //         msg.body.hb_interval < MINIUM_HEARTBEAT_INTERVAL ? MINIUM_HEARTBEAT_INTERVAL : msg.body.hb_interval;
        //     const heartbeatTimeout = msg.body.hb_timeout || 40000;
        //     MAX_TRY_HEARTBEAT_COUNT = heartbeatTimeout / heartbeatInterval + 1;
        // } else {
        heartbeatInterval =
            msg.body.hearbeat_interval < zego_entity_1.MINIUM_HEARTBEAT_INTERVAL
                ? zego_entity_1.MINIUM_HEARTBEAT_INTERVAL
                : msg.body.hearbeat_interval;
        // }
        this.tryHeartbeatCount = 0;
        this.heartbeatTimer && clearTimeout(this.heartbeatTimer);
        this.loginHeartbeatTimer = setTimeout(function () {
            _this.start(heartbeatInterval);
        }, heartbeatInterval);
        this.initCount++;
    };
    HeartBeatHandler.prototype.start = function (heartbeatInterval) {
        var _this = this;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.HEARTBEAT_START + ' call');
        var reportSeq = zego_entity_1.getReportSeq();
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomHB.event);
        this.dataReport.addMsgInfo(reportSeq, {
            room_sid: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomHB.room_sid(this.room.sessionID),
        });
        // 若当前不是处于login登录状态，则返回不做心跳
        if (!this.room.isLogin()) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.HEARTBEAT_START + ' state error');
            this.dataReport.addMsgInfo(reportSeq, {
                error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomHB.error.NOT_LOGIN.code,
                message: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomHB.error.NOT_LOGIN.msg,
            });
            this.dataReport.uploadReport(reportSeq);
            return;
        }
        // 若尝试心跳次数大于最大尝试次数，则置为登出状态，清除状态数据
        if (++this.tryHeartbeatCount > MAX_TRY_HEARTBEAT_COUNT) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.HEARTBEAT_START + ' come to try limit');
            this.dataReport.addMsgInfo(reportSeq, {
                error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomHB.error.HB_TIMEOUT.code,
                message: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomHB.error.HB_TIMEOUT.msg,
            });
            this.dataReport.uploadReport(reportSeq);
            this.hbLogout(zego_externalError_1.errorCodeList.HEARTBEAT_TIMEOUT);
            return;
        }
        var heartBeatCallBack = function (msg) {
            var code = _this.stateCenter.type == 'PRIVATE' ? msg.body && msg.body.code : msg.body && msg.body.err_code;
            if (!msg.header || !msg.body) {
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: msg.code > 0 ? msg.code : zego_externalError_1.errorCodeList.ROOM_INNER_ERROR.code,
                    message: msg.msg ? msg.msg : zego_externalError_1.errorCodeList.ROOM_INNER_ERROR,
                });
            }
            else if (code !== 0) {
                var err = client_util_1.ClientUtil.decodeServerError(msg.body.err_code || msg.body.code, msg.body.err_message || msg.body.message);
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: err.code,
                    message: err.message + msg.body.err_code,
                });
            }
            _this.dataReport.uploadReport(reportSeq);
            // this.stateCenter.type == 'PRIVATE' ? this.handlePrivateHeartbeatRsp(msg) : 
            _this.handleHeartbeatRsp(msg);
        };
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.heartBeat(heartBeatCallBack, heartBeatCallBack, this.room);
        this.heartbeatInterval = heartbeatInterval;
        // heartbeatInterval后再发
        var _heartbeatInterval = this.heartbeatInterval;
        if (this.initCount >= 2) {
            _heartbeatInterval = Math.round(Math.random() * (this.heartbeatInterval + 1));
            this.initCount = 1;
        }
        else {
            _heartbeatInterval = this.heartbeatInterval;
        }
        this.heartbeatTimer = setTimeout(function () {
            _this.start(_this.heartbeatInterval);
        }, _heartbeatInterval);
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.HEARTBEAT_START + ' call success');
    };
    /*
     *    "hhbr.0": "ZegoExpressEngine.handleHeartbeatRsp",
     */
    HeartBeatHandler.prototype.handleHeartbeatRsp = function (msg) {
        if (msg.body && msg.body.err_code && msg.body.err_code !== 0) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.HEARTBEAT_HEARTBEAT_RSP + ' disconnect, server error=', msg.body.err_code);
            // TODO
            if (msg.body.err_code == zego_entity_1.ERROR_CODES.ROOM_SESSION_ID_ERR) {
                this.hbLogout(zego_externalError_1.errorCodeList.HEARTBEAT_TIMEOUT);
                return;
            }
            // TODO room_session_id error
            this.hbLogout(client_util_1.ClientUtil.getServerError(msg.body.err_code));
            return;
        }
        else if (!msg.header || !msg.body) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.HEARTBEAT_HEARTBEAT_RSP + ' disconnect, error=', JSON.stringify(msg));
            // TODO room_session_id error
            this.hbLogout(msg);
            return;
        }
        //reset heartbeat fail count
        this.tryHeartbeatCount = 0;
        // 0 表示没有变动，继续使用登录返回的 interval
        if (msg.body.hearbeat_interval !== 0) {
            this.heartbeatInterval = msg.body.hearbeat_interval;
            if (this.heartbeatInterval < zego_entity_1.MINIUM_HEARTBEAT_INTERVAL) {
                this.heartbeatInterval = zego_entity_1.MINIUM_HEARTBEAT_INTERVAL;
            }
        }
        this.heartbeatRspNotiFy(msg);
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.HEARTBEAT_HEARTBEAT_RSP + ' call success');
    };
    // 外部覆盖,回包处理各自模块逻辑
    HeartBeatHandler.prototype.heartbeatRspNotiFy = function (msg) { };
    //空实现 外部覆盖
    HeartBeatHandler.prototype.hbLogout = function (err) { };
    HeartBeatHandler.prototype.resetHeartbeat = function () {
        clearTimeout(this.heartbeatTimer);
        this.heartbeatTimer = null;
        clearTimeout(this.loginHeartbeatTimer);
        this.loginHeartbeatTimer = null;
        this.tryHeartbeatCount = 0;
        this.initCount = 0;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.HEARTBEAT_RESET + ' call success');
    };
    return HeartBeatHandler;
}());
exports.HeartBeatHandler = HeartBeatHandler;


/***/ }),

/***/ "./sdk/src/modules/index.private.ts":
/*!******************************************!*\
  !*** ./sdk/src/modules/index.private.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_471953__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveRoomModules = void 0;
var zego_entity_1 = __nested_webpack_require_471953__(/*! ../zego.entity */ "./sdk/src/zego.entity.ts");
var heartBeatHandler_1 = __nested_webpack_require_471953__(/*! ./heartBeatHandler */ "./sdk/src/modules/heartBeatHandler.ts");
var userHandler_1 = __nested_webpack_require_471953__(/*! ./userHandler */ "./sdk/src/modules/userHandler.ts");
var LiveRoomModules = /** @class */ (function () {
    function LiveRoomModules(stateCenter, logger, dataReport, service, rtm) {
        this.stateCenter = stateCenter;
        this.logger = logger;
        this.dataReport = dataReport;
        this.service = service;
        this.rtm = rtm;
        this.roomID = '';
        this._dispatchServer = '';
        this.deviceID = '';
        this.deviceType = '';
        this.anType = 0;
        this.sessionExpire = '';
        this.pri_roomID = '';
        this.roomSid = '0';
        this.roomFlag = 1;
        this.timeStamp = 0;
        this.netType = 2;
        this.userSeq = 0;
        this.hallRunState = zego_entity_1.ENUM_RUN_STATE.logout;
        this.hallToken = '';
        this.roomSessionID = '';
        this.lastHallRunState = zego_entity_1.ENUM_RUN_STATE.logout;
        this.runRoomState = zego_entity_1.ENUM_RUN_STATE.logout;
        this.lastRunRoomState = zego_entity_1.ENUM_RUN_STATE.logout;
        this.lastHallState = 'DISCONNECTED';
        this.hallState = 'DISCONNECTED';
        this.lastRoomState = 'DISCONNECTED';
        this.roomState = 'DISCONNECTED';
        this.sessionID = '';
        this.initHandler();
        this.heartBeatHandler = new heartBeatHandler_1.HeartBeatHandler(this.logger, this.stateCenter, this.dataReport, this.service, 
        // TODO
        // @ts-ignore
        undefined, this);
        this.userHandler = new userHandler_1.UserHandler(this.logger, this.stateCenter, this.dataReport, this.service, 
        // @ts-ignore
        undefined, this);
        this.initMessageHandler();
        this.init();
    }
    //模块化 install 覆盖
    LiveRoomModules.prototype.initMessageHandler = function () { };
    LiveRoomModules.prototype.initHandler = function () { };
    LiveRoomModules.prototype.init = function () {
        this.bindSocketHandler();
        this.bindHeatBeatHandler();
        // this.bindHallHandler();
        this.bindMessageHandler();
        this.bindLiveHandler();
        // this.bindRoomHandler();
    };
    /*
     *    "zb.cm.bsh.0": "ZegoClient.base.bindSocketHandler",
     */
    LiveRoomModules.prototype.bindSocketHandler = function () {
        var _this = this;
        this.service.handlePushUserStateUpdateMsg = function (msg) {
            _this.userHandler.handlePushUserStateUpdateMsg(msg);
        };
    };
    LiveRoomModules.prototype.bindHeatBeatHandler = function () {
        var _this = this;
        this.heartBeatHandler.hbLogout = function (err) { };
        // 心跳回包 处理用户信息,可靠消息
        this.heartBeatHandler.heartbeatRspNotiFy = function (msg) {
            // this.messageHandler.loginRsp(msg);
            //this.userHandler.patchUserList(msg);
            // 留给其他sdk处理
            _this.HBResponse(msg);
        };
    };
    /*
     *    "zb.cm.brh": "ZegoClient.base.bindHallHandler",
     */
    LiveRoomModules.prototype.bindHallHandler = function () { };
    LiveRoomModules.prototype.bindUserHandler = function () { };
    LiveRoomModules.prototype.bindMessageHandler = function () { };
    LiveRoomModules.prototype.bindLiveHandler = function () { };
    LiveRoomModules.prototype.bindRoomHandler = function () { };
    LiveRoomModules.prototype.handleHbLogout = function (err) { };
    LiveRoomModules.prototype.HBResponse = function (msg) {
        this.stateCenter.actionListener('HBResponse', msg);
    };
    LiveRoomModules.prototype.roomLoginResponse = function (msg) {
        this.stateCenter.actionListener('roomLoginResponse', msg);
    };
    //是否登录
    LiveRoomModules.prototype.isLogin = function () {
        return this.hallRunState === zego_entity_1.ENUM_RUN_STATE.login;
    };
    return LiveRoomModules;
}());
exports.LiveRoomModules = LiveRoomModules;


/***/ }),

/***/ "./sdk/src/modules/index.ts":
/*!**********************************!*\
  !*** ./sdk/src/modules/index.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_476366__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveRoomModules = void 0;
var zego_entity_1 = __nested_webpack_require_476366__(/*! ../zego.entity */ "./sdk/src/zego.entity.ts");
var heartBeatHandler_1 = __nested_webpack_require_476366__(/*! ./heartBeatHandler */ "./sdk/src/modules/heartBeatHandler.ts");
// import { LiveHandler } from '../../live/liveHandler';
var roomHandler_1 = __nested_webpack_require_476366__(/*! ./roomHandler */ "./sdk/src/modules/roomHandler.ts");
var userHandler_1 = __nested_webpack_require_476366__(/*! ./userHandler */ "./sdk/src/modules/userHandler.ts");
var client_util_1 = __nested_webpack_require_476366__(/*! ../../util/client-util */ "./sdk/util/client-util.ts");
var zego_externalError_1 = __nested_webpack_require_476366__(/*! ../zego.externalError */ "./sdk/src/zego.externalError.ts");
var LiveRoomModules = /** @class */ (function () {
    function LiveRoomModules(roomID, stateCenter, logger, dataReport, service, rtm, liveRoomHandler) {
        this.roomID = roomID;
        this.stateCenter = stateCenter;
        this.logger = logger;
        this.dataReport = dataReport;
        this.service = service;
        this.rtm = rtm;
        this.liveRoomHandler = liveRoomHandler;
        this.runState = zego_entity_1.ENUM_RUN_STATE.logout;
        this.lastRunState = zego_entity_1.ENUM_RUN_STATE.logout;
        this.lastRoomState = 'DISCONNECTED';
        this.roomState = 'DISCONNECTED';
        this.roomSessionID = '0';
        this.sessionID = '0';
        this.isMulti = false;
        this.token = '';
        this.thirdToken = '';
        this.maxMemberCount = 0;
        this.lvKey = '';
        // uint64SessionID: Long = Long.fromInt(0);
        // uint64RoomSessionID: Long = Long.fromInt(0);
        this.roomName = '';
        this.roomHandler = new roomHandler_1.RoomHandler(this.logger, this.stateCenter, this.dataReport, this.service, this, liveRoomHandler);
        this.heartBeatHandler = new heartBeatHandler_1.HeartBeatHandler(this.logger, this.stateCenter, this.dataReport, this.service, this.liveRoomHandler, this);
        this.userHandler = new userHandler_1.UserHandler(this.logger, this.stateCenter, this.dataReport, this.service, this.liveRoomHandler, this);
        this.initMessageHandler();
        this.initLiveHandler();
        this.init();
    }
    //模块化 install 覆盖
    LiveRoomModules.prototype.initMessageHandler = function () { };
    LiveRoomModules.prototype.initLiveHandler = function () { };
    LiveRoomModules.prototype.init = function () {
        this.bindHeatBeatHandler();
        this.bindRoomHandler();
        this.bindMessageHandler();
        this.bindLiveHandler();
    };
    LiveRoomModules.prototype.bindHeatBeatHandler = function () {
        var _this = this;
        this.heartBeatHandler.hbLogout = function (err) {
            _this.roomHandler.handleHbLogout(err);
        };
        // 心跳回包 处理用户信息,可靠消息
        this.heartBeatHandler.heartbeatRspNotiFy = function (msg) {
            _this.messageHandler && _this.messageHandler.loginRsp(msg);
            _this.userHandler.patchUserList(msg);
            // 留给其他sdk处理
            _this.HBResponse(msg);
        };
    };
    /*
     *    "zb.cm.brh": "ZegoClient.base.bindRoomHandler",
     */
    LiveRoomModules.prototype.bindRoomHandler = function () {
        var _this = this;
        this.roomHandler.loginSuccessCallBack = function (lastRunState, msg) {
            _this.heartBeatHandler.init(msg);
            // 统一接入;
            if (_this.stateCenter.useNetAgent) {
                _this.liveRoomHandler.startCheck();
            }
            else {
                _this.service.startCheck();
            }
            _this.userHandler.loginRsp(msg, lastRunState);
            _this.messageHandler && _this.messageHandler.loginRsp(msg);
            // 第一个房间登录成功后需要 处理多房间登录
            if (!_this.isMulti) {
                _this.handleMultiRoom();
            }
            // 留给其他sdk处理
            _this.roomLoginResponse(msg);
        };
        this.roomHandler.resetRoomCallBack = function () {
            // 清除心跳计时器对象
            _this.heartBeatHandler.resetHeartbeat();
            // 清除检查消息循环
            _this.liveHandler && _this.liveHandler.resetLiveHandler();
            // 清除检查消息循环
            _this.messageHandler && _this.messageHandler.resetMessageInfo();
            // 清除用户相关状态
            _this.userHandler.resetUserHandler();
            //清除房间所有重试逻辑
            if (_this.roomTryHandler) {
                _this.roomTryHandler.invalid();
                _this.roomTryHandler.stopMaxTime();
                _this.roomTryHandler = undefined;
            }
        };
    };
    LiveRoomModules.prototype.bindUserHandler = function () { };
    LiveRoomModules.prototype.bindMessageHandler = function () { };
    LiveRoomModules.prototype.bindLiveHandler = function () { };
    LiveRoomModules.prototype.HBResponse = function (msg) {
        this.stateCenter.actionListener('HBResponse', msg);
    };
    LiveRoomModules.prototype.roomLoginResponse = function (msg) {
        this.stateCenter.actionListener('roomLoginResponse', msg);
    };
    LiveRoomModules.prototype.handleMultiRoom = function () {
        var _this = this;
        //多房间登录
        //查看是否有多房间需要重试
        this.stateCenter.roomModulesList.forEach(function (room) {
            if (room.runState !== zego_entity_1.ENUM_RUN_STATE.login && room.roomTryHandler && room.isMulti == true) {
                room.roomTryHandler.onactive = function (success, error) {
                    if (error && error.code !== 0) {
                        // 转换 liveroom 错误码
                        if (error.code !== 0) {
                            var errorKey = client_util_1.ClientUtil.getLiveRoomError(error.code, _this.stateCenter.useNetAgent);
                            // @ts-ignore
                            if (errorKey && zego_externalError_1.errorCodeList[errorKey]) {
                                // @ts-ignore
                                error = zego_externalError_1.errorCodeList[errorKey];
                            }
                        }
                        room.roomHandler.roomStateHandle('DISCONNECTED', error, error.msg);
                    }
                    else {
                        room.roomHandler.roomStateHandle('CONNECTED', error);
                    }
                };
                room.roomTryHandler.startMaxTime();
                room.roomTryHandler.active();
            }
        });
    };
    //是否登录
    LiveRoomModules.prototype.isLogin = function () {
        return this.runState === zego_entity_1.ENUM_RUN_STATE.login;
    };
    LiveRoomModules.prototype.isDisConnect = function () {
        if (this.stateCenter.useNetAgent) {
            return this.liveRoomHandler.isDisConnect();
        }
        else {
            return this.service.isDisConnect();
        }
    };
    LiveRoomModules.prototype.resetSessionInfo = function () {
        var _a;
        this.sessionID = '0';
        this.roomSessionID = '0';
        (_a = this.liveRoomHandler) === null || _a === void 0 ? void 0 : _a.reset();
    };
    return LiveRoomModules;
}());
exports.LiveRoomModules = LiveRoomModules;


/***/ }),

/***/ "./sdk/src/modules/liveroomHandler.ts":
/*!********************************************!*\
  !*** ./sdk/src/modules/liveroomHandler.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_483826__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveRoomHandler = exports.LIVEROOM_STATE = void 0;
var zego_entity_1 = __nested_webpack_require_483826__(/*! ../zego.entity */ "./sdk/src/zego.entity.ts");
var liveroom_1 = __nested_webpack_require_483826__(/*! ./proto/liveroom */ "./sdk/src/modules/proto/liveroom.js");
var liveroom_2 = __importDefault(__nested_webpack_require_483826__(/*! ./proto/liveroom */ "./sdk/src/modules/proto/liveroom.js"));
var liveroom_3 = __nested_webpack_require_483826__(/*! ./proto/liveroom */ "./sdk/src/modules/proto/liveroom.js");
var zego_externalError_1 = __nested_webpack_require_483826__(/*! ../zego.externalError */ "./sdk/src/zego.externalError.ts");
var crypto_1 = __nested_webpack_require_483826__(/*! ../../util/crypto */ "./sdk/util/crypto.ts");
var AccessHubDefine_1 = __nested_webpack_require_483826__(/*! ./net/entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var string_1 = __nested_webpack_require_483826__(/*! ../../util/string */ "./sdk/util/string.ts");
var switchCmd_1 = __nested_webpack_require_483826__(/*! ./switchCmd */ "./sdk/src/modules/switchCmd.ts");
var long_1 = __importDefault(__nested_webpack_require_483826__(/*! long */ "./node_modules/long/src/long.js"));
var client_util_1 = __nested_webpack_require_483826__(/*! ../../util/client-util */ "./sdk/util/client-util.ts");
var zego_config_1 = __nested_webpack_require_483826__(/*! ../zego.config */ "./sdk/src/zego.config.ts");
var zego_action_1 = __nested_webpack_require_483826__(/*! ../zego.action */ "./sdk/src/zego.action.ts");
// import Long from 'long';
// import * as $protobuf from 'protobufjs/minimal';
// $protobuf.util.Long = Long;
// $protobuf.configure();
var ENUM_SIGNAL_SUB_CMD = {
    none: 0,
    joinLiveRequest: 1001,
    joinLiveResult: 1002,
    joinLiveInvite: 1003,
    joinLiveStop: 1004,
};
//统一接入 LIVEROOM 状态
var LIVEROOM_STATE;
(function (LIVEROOM_STATE) {
    LIVEROOM_STATE[LIVEROOM_STATE["disconnected"] = 0] = "disconnected";
    LIVEROOM_STATE[LIVEROOM_STATE["broken"] = 1] = "broken";
    LIVEROOM_STATE[LIVEROOM_STATE["connected"] = 2] = "connected";
})(LIVEROOM_STATE = exports.LIVEROOM_STATE || (exports.LIVEROOM_STATE = {}));
var LiveRoomHandler = /** @class */ (function () {
    function LiveRoomHandler(logger, stateCenter, ua, rtm) {
        var _this = this;
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.ua = ua;
        this.rtm = rtm;
        this.seq = 0;
        this.controls = new Uint8Array(1);
        this.flags = new Uint8Array(1);
        this.sendCommandList = new zego_entity_1.LinkedList();
        this.sendCommandMap = {};
        this.isEncrypt = false;
        this.switchSessionID = long_1.default.fromInt(0);
        // 定时器最大处理消息个数
        this.sendDataCheckOnceCount = 100;
        // 超时多久后,没有处理的回调直接扔掉
        this.sendDataDropTimeout = 10 * 1000;
        // 定时器执行间隔
        this.sendDataCheckInterval = 2000;
        this.protoInstance = liveroom_2.default;
        this.swPushCmdList = ['/sw/push', '/sw/merge_push', '/sw/push_kickout', '/sw/push_redirect'];
        this.onSwitchCmdList = ['/lr/login_room_rsp', '/lr/logout_room_rsp', '/sw/push_kickout', '/sw/push', '/sw/merge_push'];
        this.unEncryptCmdList = ['/lr/login_room', '/lr/login_room_rsp'];
        this.whiteboardPushCmdList = [
            '/edu/push/set_room',
            '/edu/push/set_user',
            '/edu/push/joinlive',
            '/edu/push/set_mod',
            '/edu/push/draw_graphics',
            '/edu/push/clear_graphics',
            '/edu/push/draw_page_graphics',
            '/edu/push/clear_page_graphics',
            '/edu/push/clear_user_graphic_list',
            '/edu/push/qaa',
            '/edu/push/set_user_auth',
            '/edu/push/set_room_auth',
        ];
        this.state = LIVEROOM_STATE.disconnected;
        this.unStructCmdList = [
            '/lr/push/joinlive_request',
            '/lr/push/joinlive_result',
            '/lr/push/joinlive_invite',
            '/lr/push/joinlive_stop',
        ];
        this.joinLiveMap = {
            '/lr/push/joinlive_request': 11001,
            '/lr/push/joinlive_result': 11002,
            '/lr/push/joinlive_invite': 11003,
            '/lr/push/joinlive_stop': 11004,
        };
        this.reloginToken = '';
        this.crypto = new crypto_1.Crypto();
        this.liveroom = this.ua.getPCRequest(AccessHubDefine_1.BusinessService.SERVICE_SWITCH4LIVEROOM);
        this.liveroom.on('connected', function () {
            _this.handleConnected();
        });
        this.liveroom.on('broken', function () {
            _this.handleBroken();
        });
        this.liveroom.on('disconnected', function () {
            _this.handleDisconnected();
        });
        this.liveroom.on('downLoadMessage', function (payload) {
            _this.handlePush(payload);
        });
    }
    Object.defineProperty(LiveRoomHandler.prototype, "nickName", {
        // protoMap = {
        //     '/lr/logout_room_rsp':
        // }
        get: function () {
            return string_1.encodeString(this.stateCenter.nickName);
        },
        enumerable: false,
        configurable: true
    });
    LiveRoomHandler.prototype.isDisConnect = function () {
        return this.state !== LIVEROOM_STATE.connected;
    };
    LiveRoomHandler.prototype.getHeader = function (cmd) {
        var header = {
            cmd: cmd,
            seq: ++this.seq,
            timestamp: new Date().getTime(),
            session_id: this.switchSessionID,
            controls: this.controls,
            flags: this.flags,
        };
        console.warn('header', header);
        var headerMessage = liveroom_1.proto_switch.Header.create(header);
        var headerBuffer = liveroom_1.proto_switch.Header.encode(headerMessage).finish();
        return [header.seq, headerBuffer];
    };
    LiveRoomHandler.prototype.isUaConnect = function () {
        return this.ua.isConnect();
    };
    LiveRoomHandler.prototype.sendMessage = function (cmd, body, success, error, option, isInSendMap) {
        var _this = this;
        var _a;
        if (option === void 0) { option = { timeout: 6 * 1000 }; }
        if (isInSendMap === void 0) { isInSendMap = true; }
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_SENDMESSAGE + ' call');
        if (cmd !== '/lr/login_room' && this.state !== LIVEROOM_STATE.connected) {
            this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_SENDMESSAGE + ' state ');
            return -1;
        }
        var _header = this.getHeader(cmd);
        var header = _header[1];
        var encryptBody = body;
        if (!this.unEncryptCmdList.includes(cmd) && this.isEncrypt) {
            encryptBody = this.crypto.encrypt(body);
        }
        var head = this.getHead(header.length, encryptBody.length);
        var message = new Uint8Array(Array.from(head)
            .concat(Array.from(header))
            .concat(Array.from(encryptBody)));
        if (isInSendMap) {
            var _err = function (msg, seq) {
                var _a, _b;
                if (((_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.cmd) !== '/lr/login_room_rsp' && [1002, 105].indexOf((_b = msg === null || msg === void 0 ? void 0 : msg.body) === null || _b === void 0 ? void 0 : _b.err_code) > -1) {
                    _this.rtm.retryRoom();
                    return;
                }
                error && error(msg, seq);
            };
            var cmdData = {
                seq: this.seq,
                deleted: false,
                sendTime: Date.parse(new Date() + ''),
                timeout: option.timeout,
                success: success,
                error: _err,
            };
            var cmdDataNode = this.sendCommandList.push(cmdData);
            this.sendCommandMap[cmdData.seq] = cmdDataNode;
        }
        //this.ua.(message);
        console.warn('sendMessage', cmd);
        (_a = this.liveroom) === null || _a === void 0 ? void 0 : _a.sendRequest({ payload: message, ack: true }, function (err) {
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_SENDMESSAGE + ' fail');
        }, function () {
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_SENDMESSAGE + ' ack');
        });
        return _header[0];
    };
    LiveRoomHandler.prototype.getHead = function (headerLen, bodyLen) {
        var head = new Uint8Array(7);
        head[0] = 0x21;
        head[1] = headerLen >> 8;
        head[2] = headerLen - (head[1] << 8);
        head.set(new Uint8Array(Int32Array.from([bodyLen]).buffer).reverse(), 3);
        return head;
    };
    LiveRoomHandler.prototype.handlePush = function (data) {
        var type = data[0];
        if (type !== 0x21) {
            return;
        }
        var headerLen = (data[1] << 8) + data[2];
        var header = liveroom_1.proto_switch.Header.decode(data.slice(7, 7 + headerLen));
        var bodyData = data.slice(7 + headerLen);
        var decryptBody = bodyData;
        if (!this.unEncryptCmdList.includes(header.cmd) && this.isEncrypt) {
            decryptBody = this.crypto.decrypt(bodyData);
        }
        // @ts-ignore
        if (!switchCmd_1.LiveroomProMap[header.cmd]) {
            console.warn('cmd not rtc');
            // 白板监听
            this.onSwitchMessage(header, decryptBody);
            return;
        }
        var originBody = this.decodeResponseBody(header, decryptBody);
        if (this.swPushCmdList.includes(header.cmd)) {
            this.handleSwitchPush(header, originBody);
            return;
        }
        var msg = {
            header: this.transHeader(header),
            body: this.transRsp(originBody),
        };
        console.warn(JSON.stringify(msg));
        this.handleSendCommandMsgRsp(msg);
    };
    LiveRoomHandler.prototype.handleSwitchPush = function (header, body) {
        if (header.cmd === '/sw/push') {
            var _header = this.transRsp(body.head);
            var _body = void 0;
            if (this.unStructCmdList.includes(body.head.sub_cmd)) {
                _body = { signal_msg: string_1.decodeString(body.msg_body), sub_cmd: this.joinLiveMap[body.head.sub_cmd] };
            }
            else if (body.head.sub_cmd === '/lr/push/signal_custom') {
                _body = { custommsg: string_1.decodeString(body.msg_body) };
            }
            else {
                // @ts-ignore
                if (switchCmd_1.LiveroomProMap[body.head.sub_cmd]) {
                    // @ts-ignore
                    _body = this.transRsp(this.decode(liveroom_3.liveroom_cs[switchCmd_1.LiveroomProMap[body.head.sub_cmd]], body.msg_body));
                }
                else {
                    _body = {};
                }
            }
            var pushReq = {
                header: _header,
                body: _body,
            };
            if (this.whiteboardPushCmdList.includes(body.head.sub_cmd)) {
                console.error('onSwitchMessage push ', JSON.stringify(body));
                this.onSwitchMessage(header, body);
            }
            else {
                switch (body.head.sub_cmd) {
                    case '/lr/push/user_updated':
                        this.handlePushUserStateUpdateMsg(pushReq);
                        break;
                    case '/lr/push/user_kickout':
                        this.handlePushKickout(pushReq, false);
                        break;
                    case '/lr/push/trans':
                        this.handlePushTransMsg(pushReq);
                        break;
                    case '/lr/push/im_chat':
                        this.handlePushRoomMsg(pushReq);
                        break;
                    case '/lr/push/signal_custom':
                        this.handlePushCustomMsg(pushReq);
                        break;
                    case '/lr/push/stream_add':
                    case '/lr/push/stream_delete':
                    case '/lr/push/stream_update':
                        this.handlePushStreamMsg(pushReq);
                        break;
                    case '/lr/push/joinlive_request':
                    case '/lr/push/joinlive_result':
                    case '/lr/push/joinlive_invite':
                    case '/lr/push/joinlive_stop':
                        this.handlePushSignalMsg(pushReq);
                        break;
                }
            }
            if (body.head.qos_flag == 1) {
                var reqBody = {
                    code: 0,
                    message: '',
                    sub_cmd: body.head.sub_cmd,
                    msg_id: body.head.msg_id,
                    server_send_time: body.head.send_time,
                };
                var bodyMessage = liveroom_1.proto_switch.PushRsp.create(reqBody);
                var bodyBuffer = liveroom_1.proto_switch.PushRsp.encode(bodyMessage).finish();
                this.sendMessage('/sw/push_rsp', bodyBuffer, void 0, void 0);
            }
        }
        else if (header.cmd === '/sw/merge_push') {
            var rspInfo_1 = [];
            body.messages.forEach(function (item) {
                var _msg_body;
                rspInfo_1.push({
                    sub_cmd: item.sub_cmd,
                    sub_seq: item.sub_seq,
                    msg_id: item.msg_id,
                });
                if (item.sub_cmd === '/lr/push/bigim_chat') {
                    _msg_body = liveroom_3.liveroom_cs.PushBigImChat.decode(item.msg_body);
                    item.msg_body = _msg_body;
                }
            });
            var _body = this.transRsp(body);
            var _msg = {
                header: _body.head,
                body: _body,
            };
            delete _msg.body.head;
            console.warn(_msg);
            this.handlePushMergeMsg(_msg);
            if (body.head.qos_flag == 1) {
                var reqBody = {
                    messages: rspInfo_1,
                };
                var bodyMessage = liveroom_1.proto_switch.CmdMergePushRsp.create(reqBody);
                var bodyBuffer = liveroom_1.proto_switch.CmdMergePushRsp.encode(bodyMessage).finish();
                this.sendMessage('/sw/merge_push_rsp', bodyBuffer, void 0, void 0);
            }
        }
        else if (header.cmd === '/sw/push_kickout') {
            console.warn(header, body);
            var _body = {
                // TODO
                reason: body.reason > 900 ? body.reason - 900 : body.reason,
                msg: body.message,
                need_relogin: body.need_relogin !== undefined ? body.need_relogin : 0,
            };
            this.handlePushKickout({ header: header, body: _body }, true);
        }
    };
    LiveRoomHandler.prototype.handlePushKickout = function (msg, isSwitch) {
        var _a, _b;
        if (isSwitch) {
            __spreadArrays(this.stateCenter.roomModulesList).forEach(function (room) {
                room.roomHandler.handlePushKickout(msg, true, true);
            });
        }
        else {
            var roomID_1 = (_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id;
            var room = this.stateCenter.roomModulesList.find(function (roomModules) { return roomModules.roomID == roomID_1; });
            this.longToStringNumber(msg.body, ['session_id'], 'toString');
            // Long.isLong(msg.body.session_id) && (msg.body.session_id = msg.body.session_id.toString());
            if (!room) {
                this.logger.error(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_PUSHKICKOUT +
                    ' room no found ignore ' +
                    JSON.stringify((_b = msg.header) === null || _b === void 0 ? void 0 : _b.room_id));
                return;
            }
            room.roomHandler.handlePushKickout(msg);
        }
    };
    LiveRoomHandler.prototype.handlePushStreamMsg = function (msg) { };
    LiveRoomHandler.prototype.handlePushSignalMsg = function (msg) { };
    LiveRoomHandler.prototype.handlePushMergeMsg = function (msg) { };
    LiveRoomHandler.prototype.handlePushCustomMsg = function (pushReq) { };
    LiveRoomHandler.prototype.handlePushRoomMsg = function (msg) { };
    LiveRoomHandler.prototype.handlePushTransMsg = function (pushReq) { };
    LiveRoomHandler.prototype.onSwitchMessage = function (header, decryptBody) { };
    LiveRoomHandler.prototype.decodeResponseBody = function (header, bodyData) {
        var nameSpace = this.onSwitchCmdList.includes(header.cmd) ? 'proto_switch' : 'liveroom_cs';
        // TODO
        // @ts-ignore
        return this.decode(this.protoInstance[nameSpace][switchCmd_1.LiveroomProMap[header.cmd]], bodyData);
    };
    LiveRoomHandler.prototype.handlePushUserStateUpdateMsg = function (msg) {
        var _a;
        // console.error('handlePushUserStateUpdateMsg')
        var roomID = (_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id;
        var room = this.stateCenter.roomModulesList.find(function (roomModules) { return roomModules.roomID == roomID; });
        if (!room) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_PUSHUSERUPDATE + ' room no found ignore ' + JSON.stringify(msg));
            return;
        }
        var user_actions = msg.body.user_list.map(function (item) {
            return {
                Action: item.action,
                IdName: item.id_name,
                NickName: item.nick_name,
                Role: item.role,
                LoginTime: item.login_time.toString(),
            };
        });
        var _msg = {
            body: { user_actions: user_actions, user_list_seq: msg.body.server_user_seq.toNumber(), room_id: msg.body.room_id },
        };
        room.userHandler.handlePushUserStateUpdateMsg(_msg);
    };
    LiveRoomHandler.prototype.login = function (room, suc, err) {
        var _this = this;
        if (room.isMulti) {
            var enterBody = {
                req_head: this.getReqHead(room),
                switch_session_id: this.switchSessionID,
                nick_name: this.nickName,
                role: this.stateCenter.role,
                net_type: client_util_1.ClientUtil.getNetTypeNum(),
                config: {
                    room_create_flag: this.stateCenter.roomCreateFlag,
                    user_state_flag: this.stateCenter.userStateUpdate ? 1 : 0,
                },
                lv_key: room.lvKey,
                third_token: string_1.encodeString(room.token),
                user_count_limit: room.maxMemberCount,
                relate_service: this.stateCenter.relateService.join() || '',
                conn_type: 2,
                room_name: string_1.encodeString(room.roomName),
            };
            var bodyMessage = liveroom_3.liveroom_cs.EnterReq.create(enterBody);
            var bodyBuffer = liveroom_3.liveroom_cs.EnterReq.encode(bodyMessage).finish();
            this.sendMessage('/lr/room/enter', bodyBuffer, function (msg, seq) {
                console.warn('enter suc ', msg);
                _this.longToStringNumber(msg.body, ['liveroom_session_id', 'room_session_id', 'ret_timestamp'], 'toString');
                _this.transKeysName(msg.body, [['liveroom_session_id', 'session_id'], ['hb_interval', 'hearbeat_interval']]);
                _this.keysExist(msg.body, ['token_remain_time', 'stream_seq']);
                suc && suc(msg, seq);
            }, function (err) {
                err && err(err);
            });
        }
        else {
            var body = {
                app_id: this.stateCenter.appid,
                id_name: string_1.encodeString(this.stateCenter.idName),
                device_id: this.stateCenter.deviceID,
                term_type: this.stateCenter.ENV % 2 === 0 ? zego_entity_1.TermType.TT_WEB : zego_entity_1.TermType.TT_MINIPROGRAM,
                net_type: client_util_1.ClientUtil.getNetTypeNum(),
                // TODO
                sdk_ver: zego_entity_1.PROTO_VERSION,
                proto_ver: zego_config_1.PROTO_VER,
                nick_name: this.nickName,
                client_stamp: string_1.encodeString(new Date().getTime() + ''),
                crypt_version: zego_config_1.CRYPT_VERSION,
                k1_sign: this.crypto.generateK1Sign(),
                login_token: string_1.encodeString(room.token),
                relogin_token: this.switchSessionID.notEquals(long_1.default.fromInt(0)) ? string_1.encodeString(this.reloginToken) : '',
                role: this.stateCenter.role,
                liveroom_session_id: long_1.default.fromString(room.roomSessionID),
                room_id: string_1.encodeString(room.roomID),
                room_name: string_1.encodeString(room.roomName),
                biz_type: zego_config_1.BIZ_TYPE,
                room_create_flag: this.stateCenter.roomCreateFlag,
                user_state_flag: this.stateCenter.userStateUpdate ? 1 : 0,
                lv_key: room.lvKey,
                third_token: string_1.encodeString(room.token),
                user_count_limit: room.maxMemberCount,
                relate_service: this.stateCenter.relateService.join() || '',
                biz_version: this.stateCenter.bizVersion || '',
                login_logic: this.stateCenter.isMultiRoom ? 3 : 1,
                sdk_conn_type: zego_config_1.SDK_CONN_TYPE,
            };
            console.error('login ' + this.stateCenter.idName + ' ' + JSON.stringify(body));
            this.k1SignLogoutBuffer = this.crypto.md5Bytes(body.k1_sign);
            // @ts-ignore
            var bodyMessage = liveroom_1.proto_switch.LoginRoomReq.create(body);
            var bodyBuffer = liveroom_1.proto_switch.LoginRoomReq.encode(bodyMessage).finish();
            this.sendMessage('/lr/login_room', bodyBuffer, function (msg, seq) {
                _this.switchSessionID = msg.header.session_id;
                _this.reloginToken = msg.body.relogin_token;
                // console.error('switch', this.switchSessionID.notEquals(Long.fromInt(0)));
                _this.crypto.decryptK2Sign(msg.body.k2_sign);
                if (msg.crypt_option === 1) {
                    _this.isEncrypt = false;
                }
                else if (msg.crypt_option === undefined) {
                    _this.isEncrypt = true;
                }
                _this.longToStringNumber(msg.body, ['liveroom_session_id', 'room_session_id', 'ret_timestamp'], 'toString');
                delete msg.body.heartbeat_interval;
                delete msg.body.heartbeat_timeout;
                _this.transKeysName(msg.body, [['liveroom_session_id', 'session_id'], ['liveroom_hb_interval', 'hearbeat_interval']]);
                _this.keysExist(msg.body, ['token_remain_time', 'stream_seq']);
                console.error('login suc', JSON.stringify(msg));
                suc && suc(msg, seq);
            }, function (e, seq) {
                console.error('login fail', JSON.stringify(e));
                err && err(e, seq);
            });
        }
    };
    LiveRoomHandler.prototype.transKeysName = function (obj, keys) {
        keys.forEach(function (key) {
            obj[key[1]] = obj[key[0]];
            delete obj[key[0]];
        });
    };
    LiveRoomHandler.prototype.keysExist = function (obj, keys) {
        keys.forEach(function (key) {
            if (obj[key] === undefined) {
                obj[key] = 0;
            }
        });
    };
    LiveRoomHandler.prototype.longToStringNumber = function (obj, keys, type) {
        keys.forEach(function (key) {
            if (long_1.default.isLong(obj[key])) {
                obj[key] = obj[key][type]();
            }
        });
    };
    LiveRoomHandler.prototype.logout = function (room, suc, err) {
        if (room.isMulti) {
            var reqBody = {
                req_head: this.getReqHead(room),
                switch_session_id: this.switchSessionID,
                nick_name: this.nickName,
                role: this.stateCenter.role,
                config_list: {
                    room_create_flag: this.stateCenter.roomCreateFlag,
                    user_state_flag: this.stateCenter.userStateUpdate ? 1 : 0,
                },
            };
            var bodyMessage = liveroom_3.liveroom_cs.QuitReq.create(reqBody);
            var bodyBuffer = liveroom_3.liveroom_cs.QuitReq.encode(bodyMessage).finish();
            return this.sendMessage('/lr/room/quit', bodyBuffer, suc, err);
        }
        else {
            if (!room.token || !room.sessionID || !room.roomID) {
                console.error('empty ', room);
            }
            var reqBody = {
                logout_code: 0,
                logout_check: this.crypto.md5Bytes(string_1.encodeString(room.token)),
                liveroom_session_id: long_1.default.fromString(room.sessionID),
                room_id: string_1.encodeString(room.roomID),
                role: this.stateCenter.role,
                nickname: this.nickName,
                logout_logic: this.stateCenter.isMultiRoom ? 3 : 1,
            };
            console.error('logout', this.stateCenter.idName);
            var bodyMessage = liveroom_1.proto_switch.LogoutRoomReq.create(reqBody);
            var bodyBuffer = liveroom_1.proto_switch.LogoutRoomReq.encode(bodyMessage).finish();
            return this.sendMessage('/lr/logout_room', bodyBuffer, suc, err);
        }
    };
    // 回调所有未回包数据
    LiveRoomHandler.prototype.checkSendMessageList = function (messageList) {
        var head = messageList.getFirst();
        while (head != null) {
            messageList.remove(head);
            if (head._data && head._data.error) {
                setTimeout(function () {
                    head && head._data && head._data.error && head._data.error(zego_externalError_1.errorCodeList.TIMEOUT);
                }, 0);
            }
            head = messageList.getFirst();
        }
    };
    // 定时器轮询未回包数据,超时的调用错误回调
    LiveRoomHandler.prototype.checkMessageListTimeout = function (messageList, messageMap) {
        var head = messageList.getFirst();
        var timestamp = Date.parse(new Date() + '');
        var checkCount = 0;
        var timeoutMsgCount = 0;
        var dropMsgCount = 0;
        while (head != null) {
            // 没有超时 继续等待
            if (head._data && head._data.sendTime + head._data.timeout > timestamp) {
                break;
            }
            // 超时 删除缓存,准备调研错误回调
            head._data && delete messageMap[head._data.seq];
            messageList.remove(head);
            ++timeoutMsgCount;
            // 没有设置错误回调 或者积压太久没有来得及处理的回调,直接丢弃并计数
            if ((head._data && head._data.error == null) ||
                (head._data && head._data.sendTime + this.sendDataDropTimeout < timestamp)) {
                ++dropMsgCount;
            }
            else {
                setTimeout(function () {
                    head && head._data && head._data.error && head._data.error(zego_externalError_1.errorCodeList.TIMEOUT);
                }, 0);
            }
            ++checkCount;
            if (checkCount >= this.sendDataCheckOnceCount) {
                break;
            }
            head = messageList.getFirst();
        }
    };
    // 启动定时器,轮询
    LiveRoomHandler.prototype.startCheck = function () {
        var _this = this;
        this.checkMessageListTimeout(this.sendCommandList, this.sendCommandMap);
        this.sendDataCheckTimer = setTimeout(function () {
            _this.startCheck();
        }, this.sendDataCheckInterval);
    };
    // 关闭轮询定时器
    LiveRoomHandler.prototype.stopCheck = function () {
        this.checkSendMessageList(this.sendCommandList);
        clearTimeout(this.sendDataCheckTimer);
    };
    LiveRoomHandler.prototype.handleSendCommandMsgRsp = function (msg) {
        var _this = this;
        var sendDataNode = this.sendCommandMap[msg.header.seq];
        if (sendDataNode != null) {
            var sendData_1 = sendDataNode._data;
            delete this.sendCommandMap[msg.header.seq];
            this.sendCommandList.remove(sendDataNode);
            if (msg.body.err_code === 0) {
                setTimeout(function () {
                    sendData_1 && sendData_1.success != null && sendData_1.success(msg, _this.seq);
                }, 0);
            }
            else {
                setTimeout(function () {
                    sendData_1 && sendData_1.error != null && sendData_1.error(msg, _this.seq);
                }, 0);
            }
        }
    };
    LiveRoomHandler.prototype.getReqHead = function (room) {
        var reqHead = {
            room_id: room.roomID,
            user_session_id: long_1.default.fromString(room.sessionID),
            room_session_id: long_1.default.fromString(room.roomSessionID),
        };
        return reqHead;
    };
    LiveRoomHandler.prototype.heartBeat = function (suc, err, room) {
        var _this = this;
        var reqHead = this.getReqHead(room);
        var reqBody = {
            req_head: reqHead,
            role: this.stateCenter.role,
            lv_key: room.lvKey,
        };
        var bodyMessage = liveroom_3.liveroom_cs.HbReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.HbReq.encode(bodyMessage).finish();
        console.warn('/lr/room/hb');
        this.sendMessage('/lr/room/hb', bodyBuffer, function (msg) {
            _this.transKeysName(msg.body, [['hb_interval', 'hearbeat_interval'], ['hb_timeout', 'hearbeat_timeout']]);
            msg.body.server_user_seq = msg.body.user_seq.toNumber();
            _this.longToStringNumber(msg.body, ['dati_time_window'], 'toNumber');
            suc && suc(msg);
        }, err);
    };
    LiveRoomHandler.prototype.fetchUserList = function (body, suc, err, room) {
        var _this = this;
        var reqHead = this.getReqHead(room);
        var reqBody = __assign({ req_head: reqHead }, body);
        var bodyMessage = liveroom_3.liveroom_cs.UserlistReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.UserlistReq.encode(bodyMessage).finish();
        return this.sendMessage('/lr/userlist/userlist', bodyBuffer, function (msg, seq) {
            console.error('fetchUserList');
            _this.transKeysName(msg.body, [['user_basic_list', 'user_baseinfos']]);
            _this.longToStringNumber(msg.body, ['server_user_seq', 'server_user_index', 'ret_user_index'], 'toNumber');
            suc && suc(msg, seq);
        }, err);
    };
    LiveRoomHandler.prototype.sendRoomMsg = function (body, suc, err, room) {
        var _this = this;
        var reqHead = this.getReqHead(room);
        var reqBody = {
            req_head: reqHead,
            msg_category: body.msg_category,
            msg_priority: body.msg_priority,
            msg_type: body.msg_type,
            msg_content: string_1.encodeString(body.msg_content),
        };
        var bodyMessage = liveroom_3.liveroom_cs.ImChatReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.ImChatReq.encode(bodyMessage).finish();
        return this.sendMessage('/lr/im/chat', bodyBuffer, function (res) {
            _this.longToStringNumber(res.body, ['msg_id'], 'toNumber');
            suc && suc(res);
        }, err);
    };
    LiveRoomHandler.prototype.sendReliableMessage = function (body, suc, err, room) {
        var reqHead = this.getReqHead(room);
        var reqBody = {
            req_head: reqHead,
            role: this.stateCenter.role,
            nick_name: this.nickName,
            trans_type: string_1.encodeString(body.trans_type),
            trans_data: string_1.encodeString(body.trans_data),
            trans_local_seq: body.trans_local_seq,
            trans_channel: string_1.encodeString(body.trans_channel),
        };
        var bodyMessage = liveroom_3.liveroom_cs.TransReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.TransReq.encode(bodyMessage).finish();
        return this.sendMessage('/lr/trans/trans', bodyBuffer, suc, err);
    };
    LiveRoomHandler.prototype.fetchReliableMessage = function (body, suc, err, room) {
        var reqHead = this.getReqHead(room);
        var _fetch_array = body.fetch_array.map(function (item) {
            return { trans_type: string_1.encodeString(item.trans_type), trans_local_seq: item.trans_seq };
        });
        var reqBody = {
            req_head: reqHead,
            trans_channel: string_1.encodeString(body.trans_channel),
            fetch_array: _fetch_array,
        };
        var bodyMessage = liveroom_3.liveroom_cs.TransFetchReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.TransFetchReq.encode(bodyMessage).finish();
        return this.sendMessage('/lr/trans/transfetch', bodyBuffer, suc, err);
    };
    LiveRoomHandler.prototype.sendCustomCommand = function (body, suc, err, room) {
        var _this = this;
        var reqHead = this.getReqHead(room);
        var dstUserList = body.dest_id_name.map(function (item) {
            return { id_name: string_1.encodeString(item) };
        });
        var reqBody = __assign({ req_head: reqHead, dst_userlist: dstUserList, push_message: string_1.encodeString(body.custom_msg) }, body);
        var bodyMessage = liveroom_3.liveroom_cs.SignalLiveReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.SignalLiveReq.encode(bodyMessage).finish();
        return this.sendMessage('/lr/signal/livescustom', bodyBuffer, function (res) {
            suc && suc(_this.transRsp(res));
        }, function (e) {
            err && err(_this.transRspHead(e.rsp_head));
        });
    };
    LiveRoomHandler.prototype.sendBigRoomMessage = function (body, suc, err, room) {
        var reqHead = this.getReqHead(room);
        var _msgs = body.msgs.map(function (item) {
            return {
                msg_category: item.msg_category,
                msg_type: item.msg_type,
                msg_timestamp: long_1.default.fromNumber(Date.now()),
                msg_content: string_1.encodeString(item.msg_content),
                bigmsg_client_id: string_1.encodeString(item.bigmsg_client_id),
            };
        });
        var reqBody = {
            req_head: reqHead,
            nick_name: this.nickName,
            role: this.stateCenter.role,
            msgs: _msgs,
        };
        var bodyMessage = liveroom_3.liveroom_cs.BigimChatReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.BigimChatReq.encode(bodyMessage).finish();
        return this.sendMessage('/lr/bigim/chat', bodyBuffer, suc, err);
    };
    LiveRoomHandler.prototype.sendRelayMessage = function (body, suc, err, room) {
        var reqHead = this.getReqHead(room);
        var reqBody = {
            req_head: reqHead,
            nick_name: this.nickName,
            role: this.stateCenter.role,
            relay_type: string_1.encodeString(body.relay_type),
            relay_data: string_1.encodeString(body.relay_data),
        };
        var bodyMessage = liveroom_3.liveroom_cs.RelayReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.RelayReq.encode(bodyMessage).finish();
        return this.sendMessage('/lr/relay', bodyBuffer, suc, err);
    };
    LiveRoomHandler.prototype.sendSignalCmd = function (body, suc, err, room) {
        var cmd = '';
        var bean = '';
        switch (body.sub_cmd) {
            case ENUM_SIGNAL_SUB_CMD.joinLiveInvite:
                cmd = '/lr/signal/liveinvite';
                bean = 'SignalLiveInviteReq';
                break;
            case ENUM_SIGNAL_SUB_CMD.joinLiveRequest:
                cmd = '/lr/signal/liverequest';
                bean = 'SignalLiveReq';
                break;
            case ENUM_SIGNAL_SUB_CMD.joinLiveResult:
                cmd = '/lr/signal/liverresult';
                bean = 'SignalLiveResultReq';
                break;
            case ENUM_SIGNAL_SUB_CMD.joinLiveStop:
                cmd = '/lr/signal/livestop';
                bean = 'SignalLiveStopReq';
                break;
        }
        var reqHead = this.getReqHead(room);
        var dstUserlist = body.dest_id_name.map(function (item) {
            return { id_name: string_1.encodeString(item) };
        });
        var reqBody = {
            req_head: reqHead,
            push_message: string_1.encodeString(body.signal_msg),
            dst_userlist: dstUserlist,
        };
        // @ts-ignore
        var bodyMessage = liveroom_3.liveroom_cs[bean].create(reqBody);
        // @ts-ignore
        var bodyBuffer = liveroom_3.liveroom_cs[bean].encode(bodyMessage).finish();
        // @ts-ignore
        var decodeReq = liveroom_3.liveroom_cs[bean].decode(bodyBuffer);
        console.warn('signal', this.transRsp(decodeReq));
        return this.sendMessage(cmd, bodyBuffer, suc, err);
    };
    LiveRoomHandler.prototype.sendStreamUpdate = function (body, suc, err, room) {
        var streamInfo;
        try {
            streamInfo = JSON.parse(body.stream_msg);
        }
        catch (error) { }
        var streamCmd = '';
        var bean;
        var reqBody;
        var _room = this.stateCenter.roomModulesList.find(function (roomModules) { return roomModules.roomID == room.roomID; });
        if (!_room) {
            // TODO
            // this.logger.error(
            //     ZEGO_RTM_ACTION.LIVEROOMHANDLER_PUSHUSERUPDATE + ' room no found ignore ' + JSON.stringify(msg),
            // );
            return;
        }
        switch (body.sub_cmd) {
            case 2001:
                streamCmd = '/lr/stream/add';
                bean = 'StreamAddReq';
                reqBody = {
                    req_head: this.getReqHead(_room),
                    stream_id: string_1.encodeString(streamInfo.stream_id),
                    extra_info: string_1.encodeString(streamInfo.extra_info),
                    // TODO
                    // title: '',
                    client_req_seq: this.seq + 1,
                    login_mode: 1,
                    third_token: string_1.encodeString(body.third_token || ''),
                };
                break;
            case 2002:
                streamCmd = '/lr/stream/delete';
                bean = 'StreamDeleteReq';
                reqBody = {
                    req_head: this.getReqHead(_room),
                    stream_id: string_1.encodeString(streamInfo.stream_id),
                    stream_sid: streamInfo.stream_sid,
                    client_req_seq: this.seq + 1,
                };
                break;
            case 2003:
                streamCmd = '/lr/stream/update';
                bean = 'StreamUpdateReq';
                reqBody = {
                    req_head: this.getReqHead(_room),
                    stream_id: string_1.encodeString(streamInfo.stream_id),
                    stream_sid: streamInfo.stream_sid,
                    client_req_seq: this.seq + 1,
                };
                break;
        }
        // @ts-ignore
        var bodyMessage = liveroom_3.liveroom_cs[bean].create(reqBody);
        // @ts-ignore
        var bodyBuffer = liveroom_3.liveroom_cs[bean].encode(bodyMessage).finish();
        this.sendMessage(streamCmd, bodyBuffer, function (r) {
            console.warn('stream', r);
            r.header.room_id = _room.roomID;
            suc && suc(r);
        }, function (e) {
            console.warn('stream', e);
            err && err(e);
        });
    };
    LiveRoomHandler.prototype.getStreamList = function (body, suc, err, room) {
        var reqBody;
        var _room = this.stateCenter.roomModulesList.find(function (roomModules) { return roomModules.roomID == room.roomID; });
        if (!_room) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_GETSTREAMLIST + ' room no found ignore ' + room.roomID);
            return;
        }
        reqBody = {
            req_head: this.getReqHead(_room),
        };
        var bodyMessage = liveroom_3.liveroom_cs.StreamListReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.StreamListReq.encode(bodyMessage).finish();
        this.sendMessage('/lr/stream/list', bodyBuffer, function (r) {
            suc && suc(r);
        }, function (e) {
            err && err(e);
        });
    };
    LiveRoomHandler.prototype.transHeader = function (msg) {
        msg.timestamp = long_1.default.isLong(msg.timestamp) ? msg.timestamp.toString() : msg.timestamp;
        // msg.session_id = Long.isLong(msg.session_id) ? msg.session_id.toString() : msg.session_id;
        return msg;
    };
    LiveRoomHandler.prototype.transRsp = function (res) {
        var _this = this;
        var _head = res && res.rsp_head ? this.transRspHead(res.rsp_head) : {};
        var response = __assign(__assign({}, res), _head);
        delete response.rsp_head;
        var transResponse = {};
        Object.keys(response).forEach(function (item) {
            if (item === 'k2_sign') {
                transResponse[item] = response[item];
            }
            else {
                _this.transBytes(transResponse, response, item);
            }
        });
        return transResponse;
    };
    LiveRoomHandler.prototype.transBytes = function (transObj, obj, key) {
        var _this = this;
        if (long_1.default.isLong(obj[key])) {
            transObj[key] = obj[key];
        }
        else if (Object.prototype.toString.call(obj[key]) === '[object Object]') {
            transObj[key] = {};
            Object.keys(obj[key]).forEach(function (item) { return _this.transBytes(transObj[key], obj[key], item); });
        }
        else if (Object.prototype.toString.call(obj[key]) === '[object Array]' &&
            Object.prototype.toString.call(obj[key][0]) === '[object Object]') {
            transObj[key] = [];
            var _loop_1 = function (i) {
                var _obj = {};
                Object.keys(obj[key][i]).forEach(function (item) {
                    _this.transBytes(_obj, obj[key][i], item);
                });
                transObj[key].push(_obj);
            };
            for (var i = 0; i < obj[key].length; i++) {
                _loop_1(i);
            }
        }
        else if (Object.prototype.toString.call(obj[key]) === '[object Uint8Array]') {
            transObj[key] = string_1.decodeString(obj[key]);
        }
        else {
            transObj[key] = obj[key];
        }
    };
    LiveRoomHandler.prototype.transRspHead = function (rspHead) {
        if (rspHead) {
            return {
                err_code: rspHead.code || 0,
                err_message: rspHead.message,
            };
        }
        else {
            return {};
        }
    };
    LiveRoomHandler.prototype.decode = function (instance, buffer) {
        return __assign({}, instance.decode(buffer));
    };
    LiveRoomHandler.prototype.handleDisconnected = function () {
        var _this = this;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_HANDLEDISCONNECTED + ' call');
        this.state = LIVEROOM_STATE.disconnected;
        //房间处理
        this.stateCenter.roomModulesList.forEach(function (roomModules) {
            if (roomModules.roomTryHandler && _this.ua.isConnect()) {
                roomModules.roomTryHandler.active();
            }
        });
    };
    LiveRoomHandler.prototype.handleBroken = function () {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_HANDLEBROKEN + ' call');
        this.state = LIVEROOM_STATE.broken;
        //房间处理
        this.stateCenter.roomModulesList.forEach(function (roomModules) {
            if (roomModules.roomTryHandler) {
                //断网停止重试
                roomModules.roomTryHandler.invalid();
                roomModules.roomTryHandler.onactive = function (success, error) {
                    roomModules.roomHandler.disconnectedHandle(error);
                };
                //异常发生
                roomModules.roomTryHandler.startMaxTime();
                roomModules.roomHandler.roomStateHandle('CONNECTING', zego_externalError_1.errorCodeList.NETWORK_BROKEN);
            }
        });
    };
    LiveRoomHandler.prototype.handleConnected = function () {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_HANDLECONNECTED + ' call');
        //修改当前状态
        this.state = LIVEROOM_STATE.connected;
        this.stateCenter.roomModulesList.forEach(function (roomModules) {
            if (roomModules.roomTryHandler) {
                //停止所有重试
                //登录成功
                roomModules.roomTryHandler.stopMaxTime();
                roomModules.roomTryHandler.invalid();
            }
        });
    };
    LiveRoomHandler.prototype.renewToken = function (body, sucCallBack, failCallBack, room) {
        var reqHead = this.getReqHead(room);
        var reqBody = {
            req_head: reqHead,
            token: body.token,
        };
        var bodyMessage = liveroom_3.liveroom_cs.RenewTokenReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.RenewTokenReq.encode(bodyMessage).finish();
        this.sendMessage('/lr/token/renew_token', bodyBuffer, sucCallBack, failCallBack);
    };
    LiveRoomHandler.prototype.reset = function () {
        var _a;
        // this.seq = 0;
        // TODO
        // this.isEncrypt = false;
        this.state = LIVEROOM_STATE.disconnected;
        this.switchSessionID = long_1.default.fromInt(0);
        if (this.sendDataCheckTimer) {
            clearTimeout(this.sendDataCheckTimer);
        }
        (_a = this.liveroom) === null || _a === void 0 ? void 0 : _a.closeRequest();
    };
    LiveRoomHandler.prototype.resetSessionInfo = function () {
        this.switchSessionID = long_1.default.fromInt(0);
    };
    return LiveRoomHandler;
}());
exports.LiveRoomHandler = LiveRoomHandler;


/***/ }),

/***/ "./sdk/src/modules/net/entity/AccessHubDefine.ts":
/*!*******************************************************!*\
  !*** ./sdk/src/modules/net/entity/AccessHubDefine.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Method = exports.ConnectionClosedAction = exports.NetWorkState = exports.externalErrorList = exports.Stick = exports.PcConnectState = exports.StreamType = exports.Mode = exports.ZegoconnRunEnv = exports.BusinessService = exports.AccessHub_Error_Code = exports.AccessHubMessageType = void 0;
var AccessHubMessageType;
(function (AccessHubMessageType) {
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_STREAM_CLOSED"] = 2] = "MSG_TYPE_STREAM_CLOSED";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_CLOSE_CONNECTION"] = 3] = "MSG_TYPE_CLOSE_CONNECTION";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_HTTP_REQUEST"] = 4] = "MSG_TYPE_HTTP_REQUEST";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_HTTP_RESPONSE"] = 5] = "MSG_TYPE_HTTP_RESPONSE";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_HB_REQUEST"] = 12] = "MSG_TYPE_HB_REQUEST";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_HB_RESPONSE"] = 13] = "MSG_TYPE_HB_RESPONSE";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_GET_CONFIG_REQUEST"] = 14] = "MSG_TYPE_GET_CONFIG_REQUEST";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_GET_CONFIG_RESPONSE"] = 15] = "MSG_TYPE_GET_CONFIG_RESPONSE";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_HTTP_REQUEST_ACK"] = 16] = "MSG_TYPE_HTTP_REQUEST_ACK";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_PC_UPWARD_MESSAGE"] = 17] = "MSG_TYPE_PC_UPWARD_MESSAGE";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_PC_UPWARD_MESSAGE_ACK"] = 18] = "MSG_TYPE_PC_UPWARD_MESSAGE_ACK";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_PC_ESTABLISHED"] = 19] = "MSG_TYPE_PC_ESTABLISHED";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_PC_BROKEN"] = 20] = "MSG_TYPE_PC_BROKEN";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_PC_DOWNWARD_MESSAGE"] = 21] = "MSG_TYPE_PC_DOWNWARD_MESSAGE";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_REDIRECT"] = 22] = "MSG_TYPE_REDIRECT";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_GET_APPCONFIG_REQUEST"] = 23] = "MSG_TYPE_GET_APPCONFIG_REQUEST";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_GET_APPCONFIG_RESPONSE"] = 24] = "MSG_TYPE_GET_APPCONFIG_RESPONSE";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_PUSH_APPCONFIG"] = 25] = "MSG_TYPE_PUSH_APPCONFIG";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_ACCESSHUB_DISPATCH_REQUEST"] = 26] = "MSG_TYPE_ACCESSHUB_DISPATCH_REQUEST";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_ACCESSHUB_DISPATCH_RESPONSE"] = 27] = "MSG_TYPE_ACCESSHUB_DISPATCH_RESPONSE";
})(AccessHubMessageType = exports.AccessHubMessageType || (exports.AccessHubMessageType = {}));
var AccessHub_Error_Code;
(function (AccessHub_Error_Code) {
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_INVALID_FRAME"] = 20000] = "ACCESSHUB_INVALID_FRAME";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_NEED_ENCRYPT"] = 20001] = "ACCESSHUB_NEED_ENCRYPT";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_DECRYPT"] = 20002] = "ACCESSHUB_DECRYPT";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_MSGTYPE"] = 20003] = "ACCESSHUB_MSGTYPE";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_UNMARSHAL"] = 20004] = "ACCESSHUB_UNMARSHAL";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_TIMEOUT"] = 20005] = "ACCESSHUB_TIMEOUT";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_CONNECT"] = 20006] = "ACCESSHUB_CONNECT";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_BROKEN"] = 20007] = "ACCESSHUB_BROKEN";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_INTERNAL_ERROR"] = 20008] = "ACCESSHUB_INTERNAL_ERROR";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_MARSHAL"] = 20009] = "ACCESSHUB_MARSHAL";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_UNSUPPORTED_SERVICE"] = 20010] = "ACCESSHUB_UNSUPPORTED_SERVICE";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_TOO_FREQUENTLY"] = 20011] = "ACCESSHUB_TOO_FREQUENTLY";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_INVALID_APPID"] = 20012] = "ACCESSHUB_INVALID_APPID";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_HB_TIMEOUT"] = 20013] = "ACCESSHUB_HB_TIMEOUT";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_INVALID_SIGNATURE"] = 20014] = "ACCESSHUB_INVALID_SIGNATURE";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_AUTH_FAILED"] = 20015] = "ACCESSHUB_AUTH_FAILED";
})(AccessHub_Error_Code = exports.AccessHub_Error_Code || (exports.AccessHub_Error_Code = {}));
var BusinessService;
(function (BusinessService) {
    BusinessService[BusinessService["SERVICE_UNSET"] = 0] = "SERVICE_UNSET";
    BusinessService[BusinessService["SERVICE_MEDIAGW"] = 1] = "SERVICE_MEDIAGW";
    BusinessService[BusinessService["SERVICE_LIVEROOM"] = 2] = "SERVICE_LIVEROOM";
    BusinessService[BusinessService["SERVICE_MIX"] = 3] = "SERVICE_MIX";
    BusinessService[BusinessService["SERVICE_ZEUS"] = 4] = "SERVICE_ZEUS";
    BusinessService[BusinessService["SERVICE_ZPUSH"] = 5] = "SERVICE_ZPUSH";
    BusinessService[BusinessService["SERVICE_L3"] = 6] = "SERVICE_L3";
    BusinessService[BusinessService["SERVICE_TALKLINE"] = 7] = "SERVICE_TALKLINE";
    BusinessService[BusinessService["SERVICE_EDUSUITE"] = 8] = "SERVICE_EDUSUITE";
    BusinessService[BusinessService["SERVICE_ZIM"] = 9] = "SERVICE_ZIM";
    BusinessService[BusinessService["SERVICE_ClOUD_SETTING"] = 10] = "SERVICE_ClOUD_SETTING";
    BusinessService[BusinessService["SERVICE_ZEUSHB"] = 11] = "SERVICE_ZEUSHB";
    BusinessService[BusinessService["SERVICE_USER_LOGIC"] = 12] = "SERVICE_USER_LOGIC";
    BusinessService[BusinessService["SERVICE_UNIFYDISPATCH"] = 13] = "SERVICE_UNIFYDISPATCH";
    BusinessService[BusinessService["SERVICE_QUALITY"] = 14] = "SERVICE_QUALITY";
    BusinessService[BusinessService["SERVICE_SECURITY"] = 15] = "SERVICE_SECURITY";
    BusinessService[BusinessService["SERVICE_KTVCPR"] = 16] = "SERVICE_KTVCPR";
    BusinessService[BusinessService["SERVICE_SWITCH4LIVEROOM"] = 17] = "SERVICE_SWITCH4LIVEROOM";
    BusinessService[BusinessService["SERVICE_WEBRTC_SIGNAL"] = 18] = "SERVICE_WEBRTC_SIGNAL";
    BusinessService[BusinessService["SERVICE_L3_WEBRTC_SIGNAL"] = 19] = "SERVICE_L3_WEBRTC_SIGNAL";
})(BusinessService = exports.BusinessService || (exports.BusinessService = {}));
var ZegoconnRunEnv;
(function (ZegoconnRunEnv) {
    ZegoconnRunEnv[ZegoconnRunEnv["ZEGOCONN_RUN_ENV_UNSET"] = 0] = "ZEGOCONN_RUN_ENV_UNSET";
    ZegoconnRunEnv[ZegoconnRunEnv["ZEGOCONN_RUN_ENV_BROWSER"] = 1] = "ZEGOCONN_RUN_ENV_BROWSER";
    ZegoconnRunEnv[ZegoconnRunEnv["ZEGOCONN_RUN_ENV_APPLET"] = 2] = "ZEGOCONN_RUN_ENV_APPLET"; // web sdk使用小程序访问
})(ZegoconnRunEnv = exports.ZegoconnRunEnv || (exports.ZegoconnRunEnv = {}));
var Mode;
(function (Mode) {
    Mode[Mode["Mode_UNSET"] = 0] = "Mode_UNSET";
    Mode[Mode["MODE_ONLINE"] = 1] = "MODE_ONLINE";
    Mode[Mode["MODE_TEST"] = 2] = "MODE_TEST";
    Mode[Mode["MODE_ALPHA"] = 3] = "MODE_ALPHA";
})(Mode = exports.Mode || (exports.Mode = {}));
var StreamType;
(function (StreamType) {
    StreamType[StreamType["HTTP"] = 0] = "HTTP";
    StreamType[StreamType["PC"] = 1] = "PC";
    StreamType[StreamType["OTHER"] = 2] = "OTHER";
})(StreamType = exports.StreamType || (exports.StreamType = {}));
var PcConnectState;
(function (PcConnectState) {
    PcConnectState[PcConnectState["CONNECTED"] = 0] = "CONNECTED";
    PcConnectState[PcConnectState["DISCONNECT"] = 1] = "DISCONNECT";
})(PcConnectState = exports.PcConnectState || (exports.PcConnectState = {}));
exports.Stick = {
    DISPATCH: 'zego-action-dispatch',
    RETRY: 'zego-action-retry',
    ABORT: 'zego-action-abort',
    NEXT_GROUP: 'zego-action-next-group',
    PUSH_APP_CONFIG: 'push-app-config:',
};
exports.externalErrorList = [
    AccessHub_Error_Code.ACCESSHUB_INVALID_APPID,
    AccessHub_Error_Code.ACCESSHUB_AUTH_FAILED,
];
var NetWorkState;
(function (NetWorkState) {
    NetWorkState[NetWorkState["offline"] = 0] = "offline";
    NetWorkState[NetWorkState["online"] = 1] = "online";
})(NetWorkState = exports.NetWorkState || (exports.NetWorkState = {}));
var ConnectionClosedAction;
(function (ConnectionClosedAction) {
    ConnectionClosedAction[ConnectionClosedAction["ACTION_RESERVED"] = 0] = "ACTION_RESERVED";
    ConnectionClosedAction[ConnectionClosedAction["ACTION_DISPATCH"] = 1] = "ACTION_DISPATCH";
    ConnectionClosedAction[ConnectionClosedAction["ACTION_RETRY"] = 2] = "ACTION_RETRY";
    ConnectionClosedAction[ConnectionClosedAction["ACTION_NEXT_NODE"] = 3] = "ACTION_NEXT_NODE";
    ConnectionClosedAction[ConnectionClosedAction["ACTION_ABORT"] = 4] = "ACTION_ABORT";
    ConnectionClosedAction[ConnectionClosedAction["ACTION_NEXT_GROUP"] = 5] = "ACTION_NEXT_GROUP";
})(ConnectionClosedAction = exports.ConnectionClosedAction || (exports.ConnectionClosedAction = {}));
var Method;
(function (Method) {
    Method[Method["METHOD_UNSET"] = 0] = "METHOD_UNSET";
    Method[Method["METHOD_GET"] = 1] = "METHOD_GET";
    Method[Method["METHOD_POST"] = 2] = "METHOD_POST";
})(Method = exports.Method || (exports.Method = {}));


/***/ }),

/***/ "./sdk/src/modules/net/impl/NetAgentBusinessRequestMgr.ts":
/*!****************************************************************!*\
  !*** ./sdk/src/modules/net/impl/NetAgentBusinessRequestMgr.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_540535__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NetAgentBusinessRequestMgr = void 0;
var AccessHubDefine_1 = __nested_webpack_require_540535__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var net_config_1 = __nested_webpack_require_540535__(/*! ../net.config */ "./sdk/src/modules/net/net.config.ts");
var NetAgentBusinessRequestMgr = /** @class */ (function () {
    function NetAgentBusinessRequestMgr(streamManager, protobuf, logger) {
        this.streamManager = streamManager;
        this.protobuf = protobuf;
        this.logger = logger;
    }
    // 获取连接相关配置
    NetAgentBusinessRequestMgr.prototype.getConfig = function (suc, err) {
        this.logger.info("zm.nab.gc" /* NETAGENTBUS_GETCONFIG */ + ' call');
        var getConfigStream = this.streamManager.createStream(AccessHubDefine_1.StreamType.OTHER);
        getConfigStream.sendMessage(AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_GET_CONFIG_REQUEST, {
            // TODO access
            zegoconn_version: net_config_1.NET_ACCESS_CONFIG.connectVer,
        }, suc, err);
    };
    // 调度
    NetAgentBusinessRequestMgr.prototype.dispatchURL = function (success, fail) {
        var _this = this;
        this.logger.info("zm.nab.du" /* NETAGENTBUS_DISPATCHURL */ + ' call');
        var sucCallBack = function (msg) {
            _this.logger.info("zm.nab.du" /* NETAGENTBUS_DISPATCHURL */ + ' suc ');
            success && success(msg);
        };
        // TODO
        var failCallBack = function (err) {
            _this.logger.info("zm.nab.du" /* NETAGENTBUS_DISPATCHURL */ + ' fail');
            fail && fail(err);
        };
        var dispatchStream = this.streamManager.createStream(AccessHubDefine_1.StreamType.OTHER);
        dispatchStream.sendMessage(AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_ACCESSHUB_DISPATCH_REQUEST, {}, sucCallBack, failCallBack);
    };
    // 柔性配置
    NetAgentBusinessRequestMgr.prototype.getAppConfig = function (userID, token) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.logger.info("zm.nab.gac" /* NETAGENTBUS_GETAPPCONFIG */ + ' call');
            var reqBody = {
                id_name: userID,
                config_key: 'init',
                token: token,
                mode_no: net_config_1.NET_ACCESS_CONFIG.modeNo,
            };
            var appConfigCallback = function (msg) {
                if (msg.code === 0) {
                    _this.logger.info("zm.nab.gac" /* NETAGENTBUS_GETAPPCONFIG */ + ' suc');
                    var initConfigData = _this.decodeConfigMessage(msg.data.data);
                    // this.logger.info(
                    //     ZEGO_ACCESS_ACTION.NETAGENTBUS_GETAPPCONFIG + ' ' + JSON.stringify(initConfig.media_config),
                    // );
                    resolve({ code: 0, data: initConfigData });
                }
                else {
                    _this.logger.error("zm.nab.gac" /* NETAGENTBUS_GETAPPCONFIG */ + ' fail ' + msg.code);
                    // TODO 逻辑处理
                    reject({ code: msg.code });
                }
            };
            var getAppConfigStream = _this.streamManager.createStream(AccessHubDefine_1.StreamType.OTHER);
            getAppConfigStream.sendMessage(AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_GET_APPCONFIG_REQUEST, reqBody, appConfigCallback, appConfigCallback);
        });
    };
    NetAgentBusinessRequestMgr.prototype.decodeConfigMessage = function (data) {
        return this.protobuf.decodeConfigMessage(data);
    };
    return NetAgentBusinessRequestMgr;
}());
exports.NetAgentBusinessRequestMgr = NetAgentBusinessRequestMgr;


/***/ }),

/***/ "./sdk/src/modules/net/impl/NetAgentConnect.ts":
/*!*****************************************************!*\
  !*** ./sdk/src/modules/net/impl/NetAgentConnect.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_544569__) {

"use strict";

var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetAgentConnect = void 0;
var AccessHubDefine_1 = __nested_webpack_require_544569__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var AccessHubProtoBuf_1 = __nested_webpack_require_544569__(/*! ../protocol/AccessHubProtoBuf */ "./sdk/src/modules/net/protocol/AccessHubProtoBuf.ts");
var ZegoWssLink_1 = __nested_webpack_require_544569__(/*! ./ZegoWssLink */ "./sdk/src/modules/net/impl/ZegoWssLink.ts");
var NetAgentBusinessRequestMgr_1 = __nested_webpack_require_544569__(/*! ./NetAgentBusinessRequestMgr */ "./sdk/src/modules/net/impl/NetAgentBusinessRequestMgr.ts");
var NetHeartBeatHandler_1 = __nested_webpack_require_544569__(/*! ./NetHeartBeatHandler */ "./sdk/src/modules/net/impl/NetHeartBeatHandler.ts");
var NetAgentPCRequestMgr_1 = __nested_webpack_require_544569__(/*! ./NetAgentPCRequestMgr */ "./sdk/src/modules/net/impl/NetAgentPCRequestMgr.ts");
var StreamManager_1 = __nested_webpack_require_544569__(/*! ../impl/StreamManager */ "./sdk/src/modules/net/impl/StreamManager.ts");
var net_config_1 = __nested_webpack_require_544569__(/*! ../net.config */ "./sdk/src/modules/net/net.config.ts");
var NetAgentHttpRequestMgr_1 = __nested_webpack_require_544569__(/*! ./NetAgentHttpRequestMgr */ "./sdk/src/modules/net/impl/NetAgentHttpRequestMgr.ts");
var EventManager_1 = __nested_webpack_require_544569__(/*! ../../EventManager */ "./sdk/src/modules/EventManager.ts");
var NetRetryLinkHandler_1 = __nested_webpack_require_544569__(/*! ./NetRetryLinkHandler */ "./sdk/src/modules/net/impl/NetRetryLinkHandler.ts");
var zego_externalError_1 = __nested_webpack_require_544569__(/*! ../../../zego.externalError */ "./sdk/src/zego.externalError.ts");
var client_util_1 = __nested_webpack_require_544569__(/*! ../../../../util/client-util */ "./sdk/util/client-util.ts");
var zego_config_1 = __nested_webpack_require_544569__(/*! ../../../zego.config */ "./sdk/src/zego.config.ts");
var NetAgentConnect = /** @class */ (function () {
    function NetAgentConnect(appID, env, logger, stateCenter) {
        var _this = this;
        this.appID = appID;
        this.env = env;
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.linkCheckTimer = null;
        this.connectServers = [];
        this.onConnectedEvent = function (isReconnect) {
            // 连接成功
            _this.getConfig();
            _this.dispatch()
                .then(function (servers) { })
                .catch(function (err) { });
            // this.netAgentPCRequestMgr.updateConnectState(PcConnectState.CONNECTED);
            // this.getAppConfig();
            // this.userManager.onConnected(isReconnect);
            // wss 连接成功
            _this.eventManager.emit('connected');
        };
        // isReconnect 是否启动重试
        this.onDisConnectedEvent = function (isReconnect) {
            // this.userManager.onDisConnected(isReconnect);
            // this.onDisConnected(isReconnect);
            // wss broken
            _this.eventManager.emit('broken');
            _this.netAgentPCRequestMgr.updateConnectState(AccessHubDefine_1.PcConnectState.DISCONNECT);
        };
        this.onPushEvent = function (streamID, msgType, msg) {
            switch (msgType) {
                case AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_REDIRECT:
                    // 重定向
                    _this.redirect(msg);
                    break;
                case AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_CLOSE_CONNECTION:
                    // close
                    _this.connectClosed(msg);
                    break;
                // case AccessHubMessageType.MSG_TYPE_PC_DOWNWARD_MESSAGE:
                //     // 业务消息
                //     break;
                case AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_BROKEN:
                case AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_ESTABLISHED:
                case AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_DOWNWARD_MESSAGE:
                    _this.streamManager.onPushEvent(streamID, msgType, msg);
                    break;
                case AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PUSH_APPCONFIG:
                    var initConfig = _this.businessRequestMgr.decodeConfigMessage(msg.data);
                    console.warn(initConfig);
                    break;
                default:
                    break;
            }
        };
        this.protobuf = new AccessHubProtoBuf_1.AccessHubProtoBuf();
        this.zegoLink = new ZegoWssLink_1.ZegoWssLink(appID, env, this.protobuf, logger, stateCenter);
        this.checkLinkMsg();
        this.zegoLink.initEvent(this.onConnectedEvent, this.onDisConnectedEvent, this.onPushEvent);
        this.streamManager = new StreamManager_1.StreamManager(this.zegoLink);
        this.businessRequestMgr = new NetAgentBusinessRequestMgr_1.NetAgentBusinessRequestMgr(this.streamManager, this.protobuf, logger);
        this.netHeartBeatHandler = new NetHeartBeatHandler_1.NetHeartBeatHandler(this.streamManager, logger);
        this.netAgentPCRequestMgr = new NetAgentPCRequestMgr_1.NetAgentPCRequestMgr(this.streamManager, logger);
        this.netAgentHttpRequestMgr = new NetAgentHttpRequestMgr_1.NetAgentHttpRequestMgr(this.streamManager, logger);
        this.eventManager = new EventManager_1.EventManager();
        this.init();
    }
    NetAgentConnect.prototype.init = function () {
        var _this = this;
        this.netHeartBeatHandler.netHbLogout = function (err) {
            if (_this.retryLinkHandler) {
                if ([zego_externalError_1.errorCodeList.NET_HB_TIMEOUT.code].includes(err.code)) {
                    _this.retryLinkHandler.startMaxTime();
                    _this.retryLinkHandler.active();
                }
                else {
                    _this.retryLinkHandler.stopMaxTime();
                    _this.retryLinkHandler.invalid();
                    _this.eventManager.emit('disconnected');
                }
            }
        };
    };
    NetAgentConnect.prototype.checkLinkMsg = function () {
        var _this = this;
        var interval = Date.now() - this.zegoLink.updateMsgTime;
        // console.error('interval', interval)
        if (interval > 90 * 1000) {
            this.logger.info("zm.nac.clm" /* NETAGENTCONNECT_CHECKLINKMSG */ + ' interval: ' + interval);
            this.resetNetAgent();
            return;
        }
        this.linkCheckTimer && clearTimeout(this.linkCheckTimer);
        this.linkCheckTimer = setTimeout(function () {
            _this.checkLinkMsg();
        }, 5 * 1000);
    };
    NetAgentConnect.prototype.connect = function (servers) {
        var dispatchServers = this.getDispatchUrl();
        this.connectServers = __spreadArrays(dispatchServers, servers);
        this.zegoLink.createSocket(this.connectServers);
        if (!this.retryLinkHandler) {
            this.retryLinkHandler = new NetRetryLinkHandler_1.NetRetryLinkHandler(this.logger, this.stateCenter);
        }
        this.retryLinkHandler.initLink(this.zegoLink);
        this.retryLinkHandler.active(false, true);
    };
    NetAgentConnect.prototype.connectUa = function () {
        this.logger.info("zm.nac.cua" /* NETAGENTCONNECT_CONNECTUA */ + ' call');
        this.retryLinkHandler && this.retryLinkHandler.active(false, true);
    };
    NetAgentConnect.prototype.isConnect = function () {
        return this.zegoLink.isConnect();
    };
    NetAgentConnect.prototype.getHttpRequest = function (service) {
        // if (this.isConnect()) {
        return this.netAgentHttpRequestMgr.getRequest(service);
        // } else {
        //     this.connect(this.connectServers);
        //     return null;
        // }
    };
    NetAgentConnect.prototype.resetNetAgent = function () {
        this.netHeartBeatHandler.reset();
        this.zegoLink.destroySocket();
    };
    NetAgentConnect.prototype.getPCRequest = function (service, path, query) {
        var _this = this;
        // if (this.isConnect()) {
        var pcRequest = this.netAgentPCRequestMgr.getRequest(service, path, query);
        // 长链接超时，断开 link
        pcRequest.on('disconnected', function () {
            // this.zegoLink.destroySocket();
            // this.zegoLink.connectSocket();
            // 通知业务层 wss 连接broken
            _this.eventManager.emit('broken');
            _this.retryLinkHandler.active();
        });
        return pcRequest;
        // } else {
        //     this.connect(this.connectServers);
        //     return null;
        // }
    };
    // 外部覆盖
    // onDisConnected(isReconnect: boolean): void {}
    // onConnected(): void {}
    // emit(listener: string, ...args: Array<any>): void {
    //     this.eventManager.emit(listener, args);
    // }
    NetAgentConnect.prototype.on = function (event, callBack) {
        return this.eventManager.addEventHandler(event, callBack);
    };
    NetAgentConnect.prototype.off = function (event, callBack) {
        this.eventManager.removeEventHandler(event, callBack);
    };
    NetAgentConnect.prototype.getConfig = function () {
        var _this = this;
        var callBack = function (msg) {
            if (msg.code === 0) {
                _this.logger.info("zm.nac.gc" /* NETAGENTCONNECT_GETCONFIG */ + ' suc ' + JSON.stringify(msg));
                _this.getConfigSuccess(msg);
            }
            else {
                _this.logger.info("zm.nac.gc" /* NETAGENTCONNECT_GETCONFIG */ + ' fail');
            }
        };
        this.businessRequestMgr.getConfig(callBack, callBack);
    };
    NetAgentConnect.prototype.getConfigSuccess = function (msg) {
        this.netHeartBeatHandler.init(msg);
        this.netAgentPCRequestMgr.setEstablishTimeout(msg.data.pc_establish_timeout);
    };
    NetAgentConnect.prototype.dispatch = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.businessRequestMgr.dispatchURL(function (msg) {
                var wss_groups = msg.data.wss_groups;
                // const ws_groups = [{ host: 'ssss' }];
                _this.logger.info("zm.nab.du" /* NETAGENTBUS_DISPATCHURL */ + ' wss_groups: ' + JSON.stringify(wss_groups));
                var connectServers = _this.handleWssGroups(wss_groups);
                resolve(connectServers);
            }, function (err) {
                reject(err);
            });
        });
    };
    NetAgentConnect.prototype.handleWssGroups = function (wss_groups) {
        if (Array.isArray(wss_groups) && wss_groups.length > 0) {
            var dispatchServers = wss_groups.map(function (item) {
                return net_config_1.NET_ACCESS_CONFIG.scheme + '://' + item.host + '/' + net_config_1.NET_ACCESS_CONFIG.location;
            });
            var _serversString = client_util_1.ClientUtil.encryptStores(JSON.stringify(dispatchServers), zego_config_1.STORE_SECRET);
            localStorage.setItem(net_config_1.NET_ACCESS_SERVERS + '_' + this.appID + '_' + net_config_1.NET_ACCESS_CONFIG.modeNo, _serversString);
            return dispatchServers;
        }
        else {
            return [];
        }
    };
    NetAgentConnect.prototype.getAppConfig = function (userID, token) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (typeof userID !== 'string' || typeof token !== 'string') {
                _this.logger.error("zm.nac.gac" /* NETAGENTCONNECT_GETAPPCONFIG */ + ' userID or token must be string');
                return;
            }
            _this.businessRequestMgr
                .getAppConfig(userID, token)
                .then(function (initConfig) {
                resolve(initConfig);
            })
                .catch(function (err) {
                _this.logger.error("zm.nac.gac" /* NETAGENTCONNECT_GETAPPCONFIG */ + ' ' + JSON.stringify(err));
                if (err.code === 20008) {
                    // this.getAppConfig(userID, token)
                    //     .then(res => resolve(res))
                    //     .catch(err => reject(err));
                }
                // 抛给上层
                if (AccessHubDefine_1.externalErrorList.indexOf(err.code)) {
                    reject(err);
                }
            });
        });
    };
    NetAgentConnect.prototype.getDispatchUrl = function () {
        var serverString = localStorage.getItem(net_config_1.NET_ACCESS_SERVERS + '_' + this.appID + '_' + net_config_1.NET_ACCESS_CONFIG.modeNo);
        if (!serverString) {
            return [];
        }
        var _decryptString = client_util_1.ClientUtil.decryptStores(serverString, zego_config_1.STORE_SECRET);
        if (_decryptString) {
            try {
                var servers = JSON.parse(_decryptString);
                return servers;
            }
            catch (error) {
                return [];
            }
        }
        return [];
    };
    NetAgentConnect.prototype.redirect = function (msg) {
        this.logger.info("zm.nac.rd" /* NETAGENTCONNECT_REDIRECT */ + (" " + JSON.stringify(msg.wss_groups)));
        var servers = this.handleWssGroups(msg.wss_groups);
        // 重定向 关闭连接会
        if (servers && Array.isArray(servers) && servers.length > 0) {
            this.zegoLink.destroySocket();
            this.eventManager.emit('broken');
            this.zegoLink.createSocket(servers);
            this.retryLinkHandler.active(false, true);
        }
        else {
            this.logger.warn("zm.nac.rd" /* NETAGENTCONNECT_REDIRECT */ + " wss_groups null");
        }
    };
    NetAgentConnect.prototype.connectClosed = function (msg) {
        var _this = this;
        this.logger.info("zm.nac.cc" /* NETAGENTCONNECT_CONNECTCLOSED */ + (" " + msg.reason + " " + msg.msg + " " + msg.action));
        switch (msg.action) {
            case AccessHubDefine_1.ConnectionClosedAction.ACTION_DISPATCH:
                this.dispatch()
                    .then(function (servers) {
                    if (Array.isArray(servers) && servers.length > 0) {
                        _this.zegoLink.destroySocket();
                        _this.eventManager.emit('broken');
                        _this.zegoLink.createSocket(servers);
                        _this.retryLinkHandler.active(false, true);
                    }
                })
                    .catch(function (err) {
                    _this.logger.info("zm.nac.cc" /* NETAGENTCONNECT_CONNECTCLOSED */ + " dispatch fail");
                });
                break;
            case AccessHubDefine_1.ConnectionClosedAction.ACTION_RETRY:
                // this.zegoLink.destroySocket();
                // this.zegoLink.connectSocket();
                this.eventManager.emit('broken');
                this.retryLinkHandler.active(false);
                break;
            case AccessHubDefine_1.ConnectionClosedAction.ACTION_NEXT_GROUP:
                // this.zegoLink.destroySocket();
                // this.zegoLink.connectSocket(true);
                this.eventManager.emit('broken');
                this.retryLinkHandler.active();
                break;
            case AccessHubDefine_1.ConnectionClosedAction.ACTION_ABORT:
                // TODO 不做处理
                break;
            case AccessHubDefine_1.ConnectionClosedAction.ACTION_RESERVED:
                // TODO 不做处理
                break;
        }
    };
    NetAgentConnect.prototype.netOnLineHandler = function () {
        if (this.retryLinkHandler && this.zegoLink.isDisConnect()) {
            console.error('isDisconnect');
            this.retryLinkHandler.active();
        }
        else {
            console.error('connect');
            this.retryLinkHandler.stopMaxTime();
            // this.eventManager.emit('connected');
            // this.netAgentPCRequestMgr.updateConnectState(PcConnectState.CONNECTED);
        }
    };
    NetAgentConnect.prototype.netOffLineHandler = function () {
        if (this.retryLinkHandler) {
            console.error('disconnect');
            this.retryLinkHandler.invalid();
            this.retryLinkHandler.onactive = function (succsss, error) { };
            this.retryLinkHandler.startMaxTime();
        }
        // this.eventManager.emit('broken');
        // this.netAgentPCRequestMgr.updateConnectState(PcConnectState.DISCONNECT);
    };
    NetAgentConnect.prototype.testConnect = function () {
        var mixRequest = this.getHttpRequest(AccessHubDefine_1.BusinessService.SERVICE_MIX);
        // TODO ABORT PUSH_APP_CONFIG
        mixRequest === null || mixRequest === void 0 ? void 0 : mixRequest.sendRequest({
            headers: [],
            body: {},
            idName: '333',
            ack: true,
            stick: 'zego-action-dispatch',
            method_no: AccessHubDefine_1.Method.METHOD_POST,
            location: '',
        }, function (res) {
            console.warn('suc', res);
        }, function (e) {
            console.warn('suc', e);
        }, function (res) {
            console.warn('suc', res);
        });
        // const cloudSettingRequest = this.getHttpRequest(BusinessService.SERVICE_ClOUD_SETTING);
        // TODO ABORT PUSH_APP_CONFIG
        // cloudSettingRequest?.sendRequest(
        //     {
        //         // headers: [],
        //         body: {
        //             appid: 3104114736,
        //             biztype: 0,
        //             compress: false,
        //             deviceid: 'd2ffd8e1-a45a-4705-8897-b21bf7ad23cd',
        //             files: ['init'],
        //             id_name: '1640682082911',
        //             mode: 'test',
        //             param: {},
        //             product: 'Web_SDK',
        //             timestamp: 1640682082964,
        //             token:
        //                 'eyJ2ZXIiOjEsImhhc2giOiJmMjY5MTU2NWZiODE0ZGNiYjQxZmNlYjllYzRhNzI4YyIsIm5vbmNlIjoiYWRmOGU1MTYzM2VhMWFjMWVkMTI4YzUwNWJiMjM4ODkiLCJleHBpcmVkIjoxNjQzMjc0MDgyfQ==',
        //         },
        //         idName: '1640682082911',
        //         ack: false,
        //         // stick: Stick.DISPATCH,
        //         method_no: Method.METHOD_POST,
        //         location: '/cloud-setting/get',
        //     },
        //     null,
        //     null,
        //     null,
        // );
    };
    return NetAgentConnect;
}());
exports.NetAgentConnect = NetAgentConnect;


/***/ }),

/***/ "./sdk/src/modules/net/impl/NetAgentHttpRequest.ts":
/*!*********************************************************!*\
  !*** ./sdk/src/modules/net/impl/NetAgentHttpRequest.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_563553__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NetAgentHttpRequest = void 0;
var AccessHubDefine_1 = __nested_webpack_require_563553__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var string_1 = __nested_webpack_require_563553__(/*! ../../../../util/string */ "./sdk/util/string.ts");
var zego_externalError_1 = __nested_webpack_require_563553__(/*! ../../../zego.externalError */ "./sdk/src/zego.externalError.ts");
var NetAgentHttpRequest = /** @class */ (function () {
    function NetAgentHttpRequest(logger, service, streamManager) {
        this.logger = logger;
        this.service = service;
        this.streamManager = streamManager;
        this.netHttpStream = this.streamManager.createStream(AccessHubDefine_1.StreamType.HTTP);
    }
    NetAgentHttpRequest.prototype.sendRequest = function (params, sucFunc, errFunc, ackFunc) {
        var _this = this;
        if (this.netHttpStream.isConnect()) {
            var reqBody = {
                service_no: this.service,
                ack: params.ack,
                headers: params.headers,
                body: string_1.encodeString(JSON.stringify(params.body)),
                id_name: params.idName,
                method_no: params.method_no,
                // TODO test
                stick: params.stick,
                location: params.location,
            };
            var httpSucCallback = function (msg) {
                _this.logger.info("zm.nahr.sr" /* NETAGENTHTTPREQUEST_SENDREQUEST */ + ' suc ' + JSON.stringify(msg));
                if (msg.body) {
                    var decodeBody = string_1.decodeString(msg.body);
                    // console.error('decodeBody', this.service, decodeBody);
                    msg.body = decodeBody;
                }
                sucFunc && sucFunc(msg);
            };
            var httpFailCallback = function (e) {
                _this.logger.error("zm.nahr.sr" /* NETAGENTHTTPREQUEST_SENDREQUEST */ + ' fail');
                errFunc && errFunc(e);
            };
            var httpAckCallback = function (msg) {
                _this.logger.error("zm.nahr.sr" /* NETAGENTHTTPREQUEST_SENDREQUEST */ + ' ack');
                ackFunc && ackFunc(msg);
            };
            this.netHttpStream.sendMessage(AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HTTP_REQUEST, reqBody, httpSucCallback, httpFailCallback, httpAckCallback);
            this.netHttpStream.isFirst = false;
        }
        else {
            errFunc && errFunc(zego_externalError_1.errorCodeList.SOCKET_CLOSE);
        }
    };
    return NetAgentHttpRequest;
}());
exports.NetAgentHttpRequest = NetAgentHttpRequest;


/***/ }),

/***/ "./sdk/src/modules/net/impl/NetAgentHttpRequestMgr.ts":
/*!************************************************************!*\
  !*** ./sdk/src/modules/net/impl/NetAgentHttpRequestMgr.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_566592__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NetAgentHttpRequestMgr = void 0;
var NetAgentHttpRequest_1 = __nested_webpack_require_566592__(/*! ./NetAgentHttpRequest */ "./sdk/src/modules/net/impl/NetAgentHttpRequest.ts");
var NetAgentHttpRequestMgr = /** @class */ (function () {
    function NetAgentHttpRequestMgr(streamManager, logger) {
        this.streamManager = streamManager;
        this.logger = logger;
    }
    NetAgentHttpRequestMgr.prototype.getRequest = function (service) {
        var httpRequest = new NetAgentHttpRequest_1.NetAgentHttpRequest(this.logger, service, this.streamManager);
        // pcRequest.onPcEstablished = (streamID: number): void => {
        //     this.onConnectEvent(streamID);
        // };
        // pcRequest.onPcBroken = (streamID: number): void => {
        //     this.onDisConnectEvent(streamID);
        // };
        // pcRequest.setStream(pcLinkStream);
        // this.pcStreamRequests[pcLinkStream.StreamID] = { stream: pcLinkStream, request: pcRequest };
        return httpRequest;
    };
    return NetAgentHttpRequestMgr;
}());
exports.NetAgentHttpRequestMgr = NetAgentHttpRequestMgr;


/***/ }),

/***/ "./sdk/src/modules/net/impl/NetAgentPCRequest.ts":
/*!*******************************************************!*\
  !*** ./sdk/src/modules/net/impl/NetAgentPCRequest.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_568106__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NetAgentPCRequest = void 0;
var string_1 = __nested_webpack_require_568106__(/*! ../../../../util/string */ "./sdk/util/string.ts");
var zego_externalError_1 = __nested_webpack_require_568106__(/*! ../../../zego.externalError */ "./sdk/src/zego.externalError.ts");
var EventManager_1 = __nested_webpack_require_568106__(/*! ../../EventManager */ "./sdk/src/modules/EventManager.ts");
var AccessHubDefine_1 = __nested_webpack_require_568106__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var net_config_1 = __nested_webpack_require_568106__(/*! ../net.config */ "./sdk/src/modules/net/net.config.ts");
var encodeServiceList = [AccessHubDefine_1.BusinessService.SERVICE_WEBRTC_SIGNAL, AccessHubDefine_1.BusinessService.SERVICE_L3_WEBRTC_SIGNAL];
var NetAgentPCRequest = /** @class */ (function () {
    function NetAgentPCRequest(logger, service, streamManager, pcEstablishTimeout, path, query) {
        this.logger = logger;
        this.service = service;
        this.streamManager = streamManager;
        this.pcEstablishTimeout = pcEstablishTimeout;
        this.path = path;
        this.query = query;
        this.connectState = AccessHubDefine_1.PcConnectState.DISCONNECT;
        this.brokenTimer = null;
        this.listenerList = {
            connected: [],
            broken: [],
        };
        this.netPcStream = this.streamManager.createStream(AccessHubDefine_1.StreamType.PC);
        this.eventManager = new EventManager_1.EventManager();
        this.netPcStream.onPushEvent = this.onPushEvent.bind(this);
    }
    NetAgentPCRequest.prototype.sendRequest = function (body, failFunc, ackFunc) {
        var _this = this;
        if (this.netPcStream.isConnect()) {
            body.ack === undefined && (body.ack = true);
            var _message = body.payload;
            if (encodeServiceList.includes(this.service)) {
                _message = string_1.encodeString(body.payload);
            }
            var reqBody = {
                service_no: this.service,
                ack: body.ack,
                payload: _message,
                wss_message_type: net_config_1.NET_ACCESS_CONFIG.wssMessageType,
                wss_path: this.path,
                wss_raw_query: this.query
            };
            var pcSucCallback = function () {
                _this.logger.info("zm.napr.sr" /* NETAGENTPCREQUEST_SENDREQUEST */ + ' suc');
                ackFunc && ackFunc();
            };
            var pcFailCallback = function (err) {
                _this.logger.error("zm.napr.sr" /* NETAGENTPCREQUEST_SENDREQUEST */ + ' fail');
                failFunc && failFunc(err);
            };
            this.netPcStream.sendMessage(AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_UPWARD_MESSAGE, reqBody, pcSucCallback, pcFailCallback);
            this.netPcStream.isFirst = false;
        }
        else {
            failFunc && failFunc(zego_externalError_1.errorCodeList.SOCKET_CLOSE);
        }
    };
    NetAgentPCRequest.prototype.onPushEvent = function (msgType, msg) {
        this.logger.info("zm.napr.ope" /* NETAGENTPCREQUEST_ONPUSHEVENT */ + (" msgType: " + msgType));
        switch (msgType) {
            case AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_ESTABLISHED:
                this.pcEstablished();
                break;
            case AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_BROKEN:
                this.pcBroken();
                break;
            case AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_DOWNWARD_MESSAGE:
                // this.onDownLoadMessage(msg.payload);
                var rsp = msg.payload;
                if (encodeServiceList.includes(this.service)) {
                    rsp = string_1.decodeString(msg.payload);
                }
                this.eventManager.emit('downLoadMessage', rsp);
                break;
        }
    };
    // 外部覆盖
    // onDownLoadMessage(payload: any): void {
    //     // this.logger.info(ZEGO_ACCESS_ACTION.NETAGENTPCREQUEST_ONDOWNLOADMESSAGE + ' call');
    // }
    // 外部覆盖
    // onConnected(): void {}
    NetAgentPCRequest.prototype.on = function (event, callBack) {
        return this.eventManager.addEventHandler(event, callBack);
    };
    NetAgentPCRequest.prototype.off = function (event, callBack) {
        this.eventManager.removeEventHandler(event, callBack);
    };
    // 外部覆盖
    // onDisConnected(): void {}
    NetAgentPCRequest.prototype.pcEstablished = function () {
        this.logger.info("zm.napr.pe" /* NETAGENTPCREQUEST_PCESTABLISHED */ + ' call');
        this.connectState = AccessHubDefine_1.PcConnectState.CONNECTED;
        // this.onConnected();
        // this.actionListener('connected');
        this.eventManager.emit('connected');
        this.brokenTimer && clearTimeout(this.brokenTimer);
    };
    NetAgentPCRequest.prototype.pcBroken = function () {
        var _this = this;
        this.logger.info("zm.napr.pb" /* NETAGENTPCREQUEST_PCBROKEN */ + ' call');
        this.connectState = AccessHubDefine_1.PcConnectState.DISCONNECT;
        // this.actionListener('broken');
        this.eventManager.emit('broken');
        this.brokenTimer = setTimeout(function () {
            // 超时断开连接 如何断开？ // TODO
            // this.actionListener('disconnected');
            _this.eventManager.emit('disconnected');
        }, this.pcEstablishTimeout * 1000);
    };
    NetAgentPCRequest.prototype.closeRequest = function () {
        this.netPcStream.closeStream(0, '');
        var streamID = this.streamManager.getStreamID();
        this.netPcStream.refresh(streamID);
        this.eventManager.emit('disconnected');
    };
    return NetAgentPCRequest;
}());
exports.NetAgentPCRequest = NetAgentPCRequest;


/***/ }),

/***/ "./sdk/src/modules/net/impl/NetAgentPCRequestMgr.ts":
/*!**********************************************************!*\
  !*** ./sdk/src/modules/net/impl/NetAgentPCRequestMgr.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_574226__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NetAgentPCRequestMgr = void 0;
var AccessHubDefine_1 = __nested_webpack_require_574226__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var net_config_1 = __nested_webpack_require_574226__(/*! ../net.config */ "./sdk/src/modules/net/net.config.ts");
var NetAgentPCRequest_1 = __nested_webpack_require_574226__(/*! ./NetAgentPCRequest */ "./sdk/src/modules/net/impl/NetAgentPCRequest.ts");
var NetAgentPCRequestMgr = /** @class */ (function () {
    function NetAgentPCRequestMgr(streamManager, logger) {
        this.streamManager = streamManager;
        this.logger = logger;
        // pcStreamRequests: {
        //     [index: number]: { stream: ZegoLinkStream; request: NetAgentPCRequest; timer?: NodeJS.Timeout };
        // } = {};
        this.pcStreamRequests = [];
        this.pcEstablishTimeout = net_config_1.NET_ACCESS_CONFIG.pcEstablishTimeout;
    }
    NetAgentPCRequestMgr.prototype.getRequest = function (service, path, query) {
        var pcRequest = new NetAgentPCRequest_1.NetAgentPCRequest(this.logger, service, this.streamManager, this.pcEstablishTimeout, path || '', query || '');
        // pcRequest.onPcEstablished = (streamID: number): void => {
        //     this.onConnectEvent(streamID);
        // };
        // pcRequest.onPcBroken = (streamID: number): void => {
        //     this.onDisConnectEvent(streamID);
        // };
        // pcRequest.setStream(pcLinkStream);
        // this.pcStreamRequests[pcLinkStream.StreamID] = { stream: pcLinkStream, request: pcRequest };
        this.pcStreamRequests.push(pcRequest);
        return pcRequest;
    };
    NetAgentPCRequestMgr.prototype.updateConnectState = function (state) {
        this.pcStreamRequests.forEach(function (pcRequest) {
            if (state === AccessHubDefine_1.PcConnectState.DISCONNECT) {
                pcRequest.eventManager.emit('broken');
            }
        });
    };
    // onConnectEvent(streamID: number): void {
    //     const streamRequest = this.pcStreamRequests[streamID];
    //     streamRequest.timer && clearTimeout(streamRequest.timer);
    // }
    // onDisConnectEvent(streamID: number): void {
    //     const streamRequest = this.pcStreamRequests[streamID];
    //     if (streamRequest) {
    //         streamRequest.timer = brokenTimer;
    //     }
    // }
    NetAgentPCRequestMgr.prototype.setEstablishTimeout = function (timeout) {
        this.pcEstablishTimeout = timeout;
    };
    return NetAgentPCRequestMgr;
}());
exports.NetAgentPCRequestMgr = NetAgentPCRequestMgr;


/***/ }),

/***/ "./sdk/src/modules/net/impl/NetHeartBeatHandler.ts":
/*!*********************************************************!*\
  !*** ./sdk/src/modules/net/impl/NetHeartBeatHandler.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_577180__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NetHeartBeatHandler = void 0;
var zego_externalError_1 = __nested_webpack_require_577180__(/*! ../../../zego.externalError */ "./sdk/src/zego.externalError.ts");
var AccessHubDefine_1 = __nested_webpack_require_577180__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var NetHeartBeatHandler = /** @class */ (function () {
    function NetHeartBeatHandler(streamManager, logger) {
        this.streamManager = streamManager;
        this.logger = logger;
        this.hbTimer = null;
        this.hbInterval = 5;
        this.hbTimeout = 10;
        this.hbTimeoutMaxCount = 0;
        this.tryHbCount = 0;
    }
    NetHeartBeatHandler.prototype.init = function (msg) {
        var _this = this;
        this.logger.info("zm.nhb.ii" /* NETHEARTBEAT_INIT */ + ' call');
        if (!this.hbStream) {
            this.hbStream = this.streamManager.createStream(AccessHubDefine_1.StreamType.OTHER);
        }
        this.hbInterval = msg.data.logic_hb_interval;
        this.hbTimeout = msg.data.logic_hb_timeout;
        this.hbTimeoutMaxCount = this.hbTimeout / this.hbInterval;
        this.hbTimer && clearTimeout(this.hbTimer);
        this.hbTimer = setTimeout(function () {
            _this.start();
        }, this.hbInterval * 1000);
    };
    NetHeartBeatHandler.prototype.start = function () {
        var _this = this;
        this.logger.info("zm.nhb.s" /* NETHEARTBEAT_START */ + ' call');
        if (this.tryHbCount++ > this.hbTimeoutMaxCount) {
            this.logger.error("zm.nhb.s" /* NETHEARTBEAT_START */ + ' come to try limit');
            // 超时
            this.reset();
            //
            this.netHbLogout(zego_externalError_1.errorCodeList.NET_HB_TIMEOUT);
            return;
        }
        // start hb
        var hbCallback = function () {
            _this.logger.info("zm.nhb.s" /* NETHEARTBEAT_START */ + ' hb callback');
            _this.tryHbCount = 0;
        };
        var reqBody = {
            ts: Date.now(),
        };
        this.hbStream.sendMessage(AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HB_REQUEST, reqBody, hbCallback, hbCallback);
        this.hbTimer && clearTimeout(this.hbTimer);
        this.hbTimer = setTimeout(function () {
            _this.start();
        }, this.hbInterval * 1000);
    };
    NetHeartBeatHandler.prototype.netHbLogout = function (err) { };
    NetHeartBeatHandler.prototype.reset = function () {
        if (this.hbTimer) {
            clearTimeout(this.hbTimer);
            this.hbTimer = null;
        }
        this.tryHbCount = 0;
    };
    return NetHeartBeatHandler;
}());
exports.NetHeartBeatHandler = NetHeartBeatHandler;


/***/ }),

/***/ "./sdk/src/modules/net/impl/NetRetryLinkHandler.ts":
/*!*********************************************************!*\
  !*** ./sdk/src/modules/net/impl/NetRetryLinkHandler.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_580257__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetRetryLinkHandler = void 0;
var zego_externalError_1 = __nested_webpack_require_580257__(/*! ../../../zego.externalError */ "./sdk/src/zego.externalError.ts");
var retryHandler_1 = __nested_webpack_require_580257__(/*! ../../retryHandler */ "./sdk/src/modules/retryHandler.ts");
var NetRetryLinkHandler = /** @class */ (function (_super) {
    __extends(NetRetryLinkHandler, _super);
    function NetRetryLinkHandler(logger, stateCenter) {
        var _this = _super.call(this, logger, stateCenter) || this;
        _this.logger = logger;
        _this.stateCenter = stateCenter;
        return _this;
    }
    NetRetryLinkHandler.prototype.initLink = function (link) {
        this.link = link;
    };
    //开启最大重试时间计时
    NetRetryLinkHandler.prototype.startMaxTime = function () {
        var _this = this;
        if (this.maxTimer) {
            return;
        }
        this.maxTimer = setTimeout(function () {
            // this.logger.info(ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + ` over max time ${this.RETRY_MAX_TIME}s, stop retry`);
            _this.isOverTime = true;
            //最大重试超时时间清空房间信息
            // this.roomHandler.resetRoom();
            _this.link.resetConnect();
            _this.stopMaxTime();
            _this.invalid();
            _this.onactive(false, zego_externalError_1.errorCodeList.NET_SOCKET_TIMEOUT);
        }, this.RETRY_MAX_TIME * 1e3);
    };
    //停止最大重试时间计时
    NetRetryLinkHandler.prototype.stopMaxTime = function () {
        this.maxTimer && clearTimeout(this.maxTimer);
        this.maxTimer = null;
    };
    NetRetryLinkHandler.prototype.active = function (isNext, isFirst) {
        var _this = this;
        //已触发了重试,忽略
        if (this.retryTimer) {
            this.logger.info("zm.rlh.at" /* RETRYLINKHANDLER */ + ' has actived, ignore');
            return;
        }
        //若已经过了最大重试时间，则不进行重试
        if (this.isOverTime) {
            this.logger.info("zm.rlh.at" /* RETRYLINKHANDLER */ + ' retry over time, stop retry');
            return;
        }
        //根据重试次数来决定下次重试时间
        if (this.retryActiveCount == 1) {
            this.retryActiveInterval = Math.floor(Math.random() * (1 - this.RETRY_START_TIME_INTERVAL) + this.RETRY_START_TIME_INTERVAL);
        }
        else {
            var retryActiveInterval = Math.pow(2, Math.round(this.retryActiveCount / this.RETRY_CONTINUE_COUNT + 1));
            this.retryActiveInterval =
                retryActiveInterval > this.RETRY_MAX_TIME_INTERVAL ? this.RETRY_MAX_TIME_INTERVAL : retryActiveInterval;
        }
        // console.error('retryActiveInterval', this.retryActiveInterval, Date.now());
        this.retryTimer = setTimeout(function () {
            // console.error('connectSocket', Date.now());
            _this.link.destroySocket();
            _this.link.connectSocket(isNext, function () {
                _this.logger.info("zm.rlh.at" /* RETRYLINKHANDLER */ + ' suc');
                _this.stopMaxTime();
                _this.invalid();
                _this.onactive(true);
            }, function () {
                _this.logger.info("zm.rlh.at" /* RETRYLINKHANDLER */ + ' fail');
                !_this.maxTimer && _this.startMaxTime();
                _this.active(true);
            });
            _this.retryTimer && clearTimeout(_this.retryTimer);
            _this.retryTimer = null;
            _this.retryActiveCount++;
        }, isFirst ? 0 : this.retryActiveInterval * 1000);
    };
    NetRetryLinkHandler.prototype.onactive = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
    };
    return NetRetryLinkHandler;
}(retryHandler_1.TryHandler));
exports.NetRetryLinkHandler = NetRetryLinkHandler;


/***/ }),

/***/ "./sdk/src/modules/net/impl/NetSocketService.ts":
/*!******************************************************!*\
  !*** ./sdk/src/modules/net/impl/NetSocketService.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_585012__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NetSocketService = void 0;
var zego_entity_1 = __nested_webpack_require_585012__(/*! ../../../zego.entity */ "./sdk/src/zego.entity.ts");
var NetSocketService = /** @class */ (function () {
    function NetSocketService(ENV) {
        this.socket = null;
        this.ENV = ENV;
    }
    NetSocketService.prototype.createSocket = function (server) {
        this.socket = zego_entity_1.createZegoWebSocket(server, this.ENV % 2);
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    NetSocketService.prototype.openHandler = function (hander) {
        var _this = this;
        if (this.socket)
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.socket.onopen = function (evt) {
                _this.socket.binaryType = 'arraybuffer';
                _this.responseHandler();
                hander(evt);
            };
    };
    /*
     *    "zb.sc.ws.rph: "ZegoExpressEngine.base.SocketCenter.responseHandler"
     */
    NetSocketService.prototype.responseHandler = function () {
        var _this = this;
        if (this.socket)
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.socket.onmessage = function (e) {
                var msg = typeof e.data == 'string'
                    ? JSON.parse(e.data)
                    : //: JSON.parse(String.fromCharCode.apply(null, new Uint8Array(e.data) as any));
                        e.data;
                _this.onMessage(msg);
            };
    };
    //注册cmd回调事件
    NetSocketService.prototype.onMessage = function (msg) { };
    /*
     *    "zb.sc.ch": "ZegoExpressEngine.base.SocketCenter.closeHandler"
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    NetSocketService.prototype.closeHandler = function (handler) {
        if (this.socket)
            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
            this.socket.onclose = function (evt) {
                console.error('onclose', evt);
                handler(evt);
            };
    };
    /*
     *    "zb.sc.ws.oe": "ZegoExpressEngine.base.SocketCenter.errorHandler"
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    NetSocketService.prototype.errorHandler = function (handler) {
        this.socket && (this.socket.onerror = handler);
    };
    NetSocketService.prototype.closeSocket = function () {
        if (this.socket) {
            this.socket.onclose = null;
            this.socket.onerror = null;
            this.socket.close();
            this.socket = null;
        }
    };
    NetSocketService.prototype.isDisConnect = function () {
        return !this.socket || this.socket.readyState !== 1;
    };
    NetSocketService.prototype.sendMessage = function (msg) {
        if (this.isDisConnect())
            return;
        if (!this.socket)
            return;
        if (this.ENV % 2 === 1) {
            // TODO wx
        }
        else {
            this.socket.send(msg);
        }
    };
    return NetSocketService;
}());
exports.NetSocketService = NetSocketService;


/***/ }),

/***/ "./sdk/src/modules/net/impl/StreamManager.ts":
/*!***************************************************!*\
  !*** ./sdk/src/modules/net/impl/StreamManager.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_588527__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamManager = void 0;
var AccessHubDefine_1 = __nested_webpack_require_588527__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var ZegoLinkStream_1 = __nested_webpack_require_588527__(/*! ./ZegoLinkStream */ "./sdk/src/modules/net/impl/ZegoLinkStream.ts");
var StreamManager = /** @class */ (function () {
    function StreamManager(zegoLink) {
        this.zegoLink = zegoLink;
        this.streamID = 0;
        this.httpStreams = [];
        this.pcStreams = [];
    }
    StreamManager.prototype.createStream = function (streamType) {
        if (streamType === AccessHubDefine_1.StreamType.HTTP) {
            return this.getStream(streamType, this.httpStreams);
        }
        else if (streamType === AccessHubDefine_1.StreamType.PC) {
            var linkStream = new ZegoLinkStream_1.ZegoLinkStream(streamType, this.streamID++, this.zegoLink);
            this.pcStreams.push(linkStream);
            return linkStream;
        }
        else {
            var linkStream = new ZegoLinkStream_1.ZegoLinkStream(streamType, this.streamID++, this.zegoLink);
            return linkStream;
        }
    };
    StreamManager.prototype.getStream = function (streamType, streams) {
        var freeStream = streams.find(function (stream) { return stream.isFree === true; });
        if (freeStream) {
            freeStream.isFree = false;
            freeStream.isFirst = false;
            return freeStream;
        }
        else {
            var linkStream = new ZegoLinkStream_1.ZegoLinkStream(streamType, this.streamID++, this.zegoLink);
            return linkStream;
        }
    };
    StreamManager.prototype.onPushEvent = function (streamID, msgType, msg) {
        // console.warn('onPushEvent ', streamID, msgType, JSON.stringify(msg));
        var pcStream = this.pcStreams.find(function (stream) { return stream.StreamID === streamID; });
        pcStream && pcStream.onPushEvent(msgType, msg);
    };
    StreamManager.prototype.getStreamID = function () {
        return this.streamID++;
    };
    return StreamManager;
}());
exports.StreamManager = StreamManager;


/***/ }),

/***/ "./sdk/src/modules/net/impl/ZegoLink.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/net/impl/ZegoLink.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ZegoLink = void 0;
var ZegoLink = /** @class */ (function () {
    function ZegoLink() {
        this.txid = 0;
        this.linkRetryTime = 60;
        this.updateMsgTime = 0;
    }
    ZegoLink.prototype.createSocket = function (servers) { };
    ZegoLink.prototype.initEvent = function (onConnectedEvent, onDisConnectedEvent, onPushEvent) { };
    ZegoLink.prototype.sendMessage = function (type, streamID, body, isFirst, success, error, ackFunc) {
        if (isFirst === void 0) { isFirst = true; }
        if (success === void 0) { success = null; }
        if (error === void 0) { error = null; }
        if (ackFunc === void 0) { ackFunc = null; }
    };
    return ZegoLink;
}());
exports.ZegoLink = ZegoLink;


/***/ }),

/***/ "./sdk/src/modules/net/impl/ZegoLinkStream.ts":
/*!****************************************************!*\
  !*** ./sdk/src/modules/net/impl/ZegoLinkStream.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_592153__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ZegoLinkStream = void 0;
var AccessHubDefine_1 = __nested_webpack_require_592153__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var ZegoLinkStream = /** @class */ (function () {
    function ZegoLinkStream(type, streamID, zegoLink) {
        this.type = type;
        this.streamID = streamID;
        this.zegoLink = zegoLink;
        this.isFree = false;
        this.isFirst = true;
    }
    Object.defineProperty(ZegoLinkStream.prototype, "StreamID", {
        get: function () {
            return this.streamID;
        },
        enumerable: false,
        configurable: true
    });
    ZegoLinkStream.prototype.refresh = function (streamID) {
        this.streamID = streamID;
    };
    ZegoLinkStream.prototype.sendMessage = function (type, body, successFunc, errorFunc, ackFunc) {
        var _this = this;
        if (successFunc === void 0) { successFunc = null; }
        if (errorFunc === void 0) { errorFunc = null; }
        if (ackFunc === void 0) { ackFunc = null; }
        this.zegoLink.sendMessage(type, this.streamID, body, this.isFirst, function (msg) {
            _this.type === AccessHubDefine_1.StreamType.HTTP && (_this.isFree = true);
            successFunc && successFunc(msg);
        }, function (err) {
            _this.type === AccessHubDefine_1.StreamType.HTTP && (_this.isFree = true);
            errorFunc && errorFunc(err);
        }, ackFunc);
    };
    ZegoLinkStream.prototype.onPushEvent = function (msgType, msg) { };
    ZegoLinkStream.prototype.closeStream = function (code, msg) {
        this.zegoLink.sendMessage(AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_STREAM_CLOSED, this.streamID, {
            code: code,
            msg: msg,
        });
    };
    ZegoLinkStream.prototype.isConnect = function () {
        return this.zegoLink.isConnect();
    };
    return ZegoLinkStream;
}());
exports.ZegoLinkStream = ZegoLinkStream;


/***/ }),

/***/ "./sdk/src/modules/net/impl/ZegoWssLink.ts":
/*!*************************************************!*\
  !*** ./sdk/src/modules/net/impl/ZegoWssLink.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_594472__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZegoWssLink = void 0;
var zego_entity_1 = __nested_webpack_require_594472__(/*! ../../../zego.entity */ "./sdk/src/zego.entity.ts");
var AccessHubDefine_1 = __nested_webpack_require_594472__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var ZegoLink_1 = __nested_webpack_require_594472__(/*! ./ZegoLink */ "./sdk/src/modules/net/impl/ZegoLink.ts");
var NetSocketService_1 = __nested_webpack_require_594472__(/*! ./NetSocketService */ "./sdk/src/modules/net/impl/NetSocketService.ts");
var zego_externalError_1 = __nested_webpack_require_594472__(/*! ../../../zego.externalError */ "./sdk/src/zego.externalError.ts");
var net_config_1 = __nested_webpack_require_594472__(/*! ../net.config */ "./sdk/src/modules/net/net.config.ts");
var ZegoWssLink = /** @class */ (function (_super) {
    __extends(ZegoWssLink, _super);
    // retryLinkHandler: RetryLinkHandler;
    function ZegoWssLink(appID, env, protobuf, logger, stateCenter) {
        var _this = _super.call(this) || this;
        _this.appID = appID;
        _this.env = env;
        _this.protobuf = protobuf;
        _this.logger = logger;
        _this.stateCenter = stateCenter;
        _this.socketService = new NetSocketService_1.NetSocketService(_this.env);
        _this.urlIndex = 0;
        _this.updateMsgTime = 0;
        _this.unUpdateMsgTimeTypes = [AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HB_REQUEST, AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HB_RESPONSE, AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_GET_CONFIG_REQUEST, AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_GET_CONFIG_RESPONSE];
        _this.netLinkState = zego_entity_1.ENUM_CONNECT_STATE.disconnect;
        // 发送消息信息存储, 超时不回包执行错误回调
        _this.sendCommandList = new zego_entity_1.LinkedList();
        _this.sendCommandMap = {};
        // 定时器最大处理消息个数
        _this.sendDataCheckOnceCount = 100;
        // 超时多久后,没有处理的回调直接扔掉
        _this.sendDataDropTimeout = 10 * 1000;
        // 定时器执行间隔
        _this.sendDataCheckInterval = 2000;
        _this.timeout = 5000;
        _this.connectInterval = 10 * 1000;
        _this.connectTimer = null;
        // networkState: NetWorkState = NetWorkState.online;
        _this.connectRsp = {};
        _this.updateMsgTime = Date.now();
        return _this;
        // this.bindWindowHandler();
    }
    ZegoWssLink.prototype.initEvent = function (onConnectedEvent, onDisConnectedEvent, onPushEvent) {
        this.onConnectedEvent = onConnectedEvent;
        this.onDisConnectedEvent = onDisConnectedEvent;
        this.onPushEvent = onPushEvent;
    };
    ZegoWssLink.prototype.createSocket = function (servers) {
        this.servers = servers;
        // this.retryLinkHandler.init(this.linkRetryTime);
        // this.retryLinkHandler.initLink(this.socketService, this.servers);
        this.urlIndex = 0;
        // this.connectSocket();
    };
    ZegoWssLink.prototype.destroySocket = function () {
        this.logger.info("zm.wl.ds.0" /* WSSLINK_DESTROYSOCKET */ + ' call');
        this.socketService.closeSocket();
        this.netLinkState = zego_entity_1.ENUM_CONNECT_STATE.disconnect;
        this.resetConnect();
    };
    ZegoWssLink.prototype.refreshServers = function (servers) {
        this.servers = __spreadArrays(servers, this.servers);
    };
    ZegoWssLink.prototype.connectSocket = function (isNext, success, fail) {
        var _this = this;
        if (isNext === void 0) { isNext = true; }
        this.logger.info("zm.wl.cs.0" /* WSSLINK_CONNECTSOCKET */ + ' call');
        this.connectRsp.suc = success;
        this.connectRsp.fail = fail;
        if (this.stateCenter.networkState !== zego_entity_1.ENUM_NETWORK_STATE.online) {
            // this.urlIndex = (this.urlIndex + 1) % this.servers.length;
            return false;
        }
        if (isNext) {
            this.urlIndex = (this.urlIndex + 1) % this.servers.length;
        }
        // console.error('urlIndex', this.urlIndex);
        var server = this.servers[this.urlIndex];
        // this.retryLinkHandler.active(this.urlIndex);
        this.closeSocket();
        this.netLinkState = zego_entity_1.ENUM_CONNECT_STATE.connecting;
        this.socketService.createSocket(server);
        this.bindSocketEvent();
        this.connectTimer = setTimeout(function () {
            _this.logger.info("zm.wl.cs.0" /* WSSLINK_CONNECTSOCKET */ + ' timeout');
            // this.reconnect();
            _this.connectRsp.fail && _this.connectRsp.fail();
        }, this.connectInterval);
        return true;
    };
    ZegoWssLink.prototype.bindSocketEvent = function () {
        var _this = this;
        this.openHandler(function () {
            _this.logger.info("zm.wl.bse" /* WSSLINK_BINDSOCKETEVENT */ + ' open');
            // this.urlIndex = 0;
            _this.resetConnect();
            // this.retryLinkHandler.stopMaxTime();
            // this.retryLinkHandler.invalid();
            _this.connectRsp.suc && _this.connectRsp.suc();
            _this.onConnectedEvent && _this.onConnectedEvent(true);
            _this.netLinkState = zego_entity_1.ENUM_CONNECT_STATE.connected;
        });
        this.closeHandler(function (err) {
            _this.logger.warn("zm.wl.bse" /* WSSLINK_BINDSOCKETEVENT */ + ' close ' + JSON.stringify(err));
            _this.resetConnect();
            // this.reconnect();
            _this.connectRsp.fail && _this.connectRsp.fail();
            _this.onDisConnectedEvent && _this.onDisConnectedEvent(true);
            _this.netLinkState = zego_entity_1.ENUM_CONNECT_STATE.disconnect;
        });
        this.errorHandler(function (err) {
            _this.logger.warn("zm.wl.bse" /* WSSLINK_BINDSOCKETEVENT */ + ' error ' + JSON.stringify(err));
            _this.resetConnect();
            // this.reconnect();
            _this.connectRsp.fail && _this.connectRsp.fail();
            _this.onDisConnectedEvent && _this.onDisConnectedEvent(true);
            _this.netLinkState = zego_entity_1.ENUM_CONNECT_STATE.disconnect;
        });
        this.onMessage();
    };
    // reconnect(): void {
    //     // TODO 连接等待时长
    //     this.closeSocket();
    //     this.resetConnect();
    //     if (this.networkState === NetWorkState.online) {
    //         // this.urlIndex = (this.urlIndex + 1) % this.servers.length;
    //         this.connectSocket();
    //     }
    // }
    ZegoWssLink.prototype.closeSocket = function () {
        this.logger.info("zm.wl.cs.1" /* WSSLINK_CLOSESOCKET */ + ' call');
        this.socketService.closeSocket();
        this.netLinkState = zego_entity_1.ENUM_CONNECT_STATE.disconnect;
    };
    ZegoWssLink.prototype.resetConnect = function () {
        if (this.connectTimer) {
            clearTimeout(this.connectTimer);
            this.connectTimer = null;
        }
    };
    ZegoWssLink.prototype.isConnect = function () {
        return this.netLinkState === zego_entity_1.ENUM_CONNECT_STATE.connected;
    };
    // websocket state
    ZegoWssLink.prototype.isDisConnect = function () {
        return !this.socketService || this.socketService.isDisConnect();
    };
    ZegoWssLink.prototype.closeHandler = function (handler) {
        this.socketService.closeHandler(handler);
    };
    ZegoWssLink.prototype.openHandler = function (handler) {
        this.socketService.openHandler(handler);
    };
    ZegoWssLink.prototype.errorHandler = function (handler) {
        this.socketService.errorHandler(handler);
    };
    ZegoWssLink.prototype.sendMessage = function (type, streamID, body, isFirst, success, error, ackFunc) {
        if (isFirst === void 0) { isFirst = true; }
        if (success === void 0) { success = null; }
        if (error === void 0) { error = null; }
        if (ackFunc === void 0) { ackFunc = null; }
        this.txid++;
        var commonBody = {
            appid: this.appID,
            biz_type: 0,
            // mode: NET_ACCESS_CONFIG.mode,
            mode_no: net_config_1.NET_ACCESS_CONFIG.modeNo,
            // TODO
            id_name: this.stateCenter.idName,
            sdk_type: net_config_1.NET_ACCESS_CONFIG.sdkType,
            zegoconn_run_env: this.env === 0 ? AccessHubDefine_1.ZegoconnRunEnv.ZEGOCONN_RUN_ENV_BROWSER : AccessHubDefine_1.ZegoconnRunEnv.ZEGOCONN_RUN_ENV_APPLET
        };
        // const common = isFirst ? commonBody : {};
        var reqBody = __assign(__assign({ txid: this.txid }, commonBody), body);
        var requestData = {
            data: reqBody,
            txid: this.txid,
            sendTime: Date.now(),
            timeOut: this.timeout,
            ack: body.ack,
            success: success,
            error: error,
            ackFunc: ackFunc,
        };
        var requestNode = this.sendCommandList.push(requestData);
        this.sendCommandMap[this.txid] = requestNode;
        if (!this.unUpdateMsgTimeTypes.includes(type)) {
            this.updateMsgTime = Date.now();
        }
        this.logger.warn("zm.wl.sm" /* WSSLINK_SENDMESSAGE */ +
            ' type: ' +
            type +
            ' streamID: ' +
            streamID +
            ' txid: ' +
            this.txid);
        // console.error('reqBody', JSON.stringify(reqBody));
        var uint8 = this.protobuf.encodeRequest(type, reqBody, streamID);
        this.socketService.sendMessage(uint8);
    };
    ZegoWssLink.prototype.onMessage = function () {
        var _this = this;
        this.socketService.onMessage = function (msg) {
            var _a, _b, _c;
            var uint8 = new Uint8Array(msg);
            var _d = _this.protobuf.decodeResponse(uint8), streamID = _d[0], msgType = _d[1], body = _d[2];
            if (!_this.unUpdateMsgTimeTypes.includes(msgType)) {
                _this.updateMsgTime = Date.now();
            }
            _this.logger.warn("zm.wl.om" /* WSSLINK_ONMESSAGE */ + (" streamID: " + streamID + ", msgType: " + msgType + "}"));
            if (((body === null || body === void 0 ? void 0 : body.txid) || ((_a = body === null || body === void 0 ? void 0 : body.data) === null || _a === void 0 ? void 0 : _a.txid)) && _this.isRspMsg((body === null || body === void 0 ? void 0 : body.txid) || ((_b = body === null || body === void 0 ? void 0 : body.data) === null || _b === void 0 ? void 0 : _b.txid))) {
                _this.handleSendCommandMsgRsp(streamID, msgType, (body === null || body === void 0 ? void 0 : body.txid) || ((_c = body === null || body === void 0 ? void 0 : body.data) === null || _c === void 0 ? void 0 : _c.txid), body);
            }
            else {
                _this.onPushEvent(streamID, msgType, body);
            }
        };
    };
    ZegoWssLink.prototype.isRspMsg = function (txid) {
        return this.sendCommandMap[txid] !== undefined;
    };
    // 启动定时器,轮询
    ZegoWssLink.prototype.startCheck = function () {
        var _this = this;
        this.checkMessageListTimeout(this.sendCommandList, this.sendCommandMap);
        this.sendDataCheckTimer = setTimeout(function () {
            _this.startCheck();
        }, this.sendDataCheckInterval);
    };
    // 关闭轮询定时器
    ZegoWssLink.prototype.stopCheck = function () {
        this.checkSendMessageList(this.sendCommandList);
        clearTimeout(this.sendDataCheckTimer);
    };
    // 定时器轮询未回包数据,超时的调用错误回调
    ZegoWssLink.prototype.checkMessageListTimeout = function (messageList, messageMap) {
        var head = messageList.getFirst();
        var timestamp = Date.now();
        var checkCount = 0;
        var timeoutMsgCount = 0;
        var dropMsgCount = 0;
        while (head != null) {
            // 没有超时 继续等待
            if (head._data && head._data.sendTime + head._data.timeOut > timestamp) {
                break;
            }
            // 超时 删除缓存,准备调研错误回调
            head._data && delete messageMap[head._data.data.txid];
            messageList.remove(head);
            ++timeoutMsgCount;
            // 没有设置错误回调 或者积压太久没有来得及处理的回调,直接丢弃并计数
            if ((head._data && head._data.error == null) ||
                (head._data && head._data.sendTime + this.sendDataDropTimeout < timestamp)) {
                ++dropMsgCount;
            }
            else {
                setTimeout(function () {
                    head &&
                        head._data &&
                        head._data.error &&
                        // TODO
                        head._data.error({}, head._data.data.txid, zego_externalError_1.errorCodeList.TIMEOUT);
                }, 0);
            }
            ++checkCount;
            if (checkCount >= this.sendDataCheckOnceCount) {
                break;
            }
            head = messageList.getFirst();
        }
        // if (timeoutMsgCount != 0 || dropMsgCount != 0) {
        //     console.error('zb.hb.cmt call success, stat: timeout=', timeoutMsgCount + '', 'drop=', dropMsgCount + '');
        // }
    };
    // 回调所有未回包数据
    ZegoWssLink.prototype.checkSendMessageList = function (messageList) {
        var head = messageList.getFirst();
        while (head != null) {
            messageList.remove(head);
            if (head._data && head._data.error) {
                setTimeout(function () {
                    head &&
                        head._data &&
                        head._data.error &&
                        head._data.error({}, head._data.data.txid, zego_externalError_1.errorCodeList.TIMEOUT);
                }, 0);
            }
            head = messageList.getFirst();
        }
    };
    ZegoWssLink.prototype.handleSendCommandMsgRsp = function (streamID, msgType, txid, body) {
        var sendDataNode = this.sendCommandMap[txid];
        if (sendDataNode != null) {
            var sendData = sendDataNode._data;
            if (!(sendData === null || sendData === void 0 ? void 0 : sendData.ack)) {
                delete this.sendCommandMap[txid];
                this.sendCommandList.remove(sendDataNode);
            }
            // TODO 协议不同
            if (body.code && body.code !== 0) {
                sendData && sendData.error != null && sendData.error(body, txid);
            }
            else {
                if (msgType === AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HTTP_REQUEST_ACK) {
                    sendData && sendData.ackFunc != null && sendData.ackFunc(body, txid);
                }
                else {
                    sendData && sendData.success != null && sendData.success(body, txid);
                }
            }
        }
    };
    return ZegoWssLink;
}(ZegoLink_1.ZegoLink));
exports.ZegoWssLink = ZegoWssLink;


/***/ }),

/***/ "./sdk/src/modules/net/index.ts":
/*!**************************************!*\
  !*** ./sdk/src/modules/net/index.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_610633__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NET_ACCESS_CONFIG = exports.BusinessService = exports.NetAgentHttpRequest = exports.NetAgentPCRequest = exports.NetAgentConnect = void 0;
var AccessHubDefine_1 = __nested_webpack_require_610633__(/*! ./entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
Object.defineProperty(exports, "BusinessService", { enumerable: true, get: function () { return AccessHubDefine_1.BusinessService; } });
var NetAgentConnect_1 = __nested_webpack_require_610633__(/*! ./impl/NetAgentConnect */ "./sdk/src/modules/net/impl/NetAgentConnect.ts");
Object.defineProperty(exports, "NetAgentConnect", { enumerable: true, get: function () { return NetAgentConnect_1.NetAgentConnect; } });
var NetAgentHttpRequest_1 = __nested_webpack_require_610633__(/*! ./impl/NetAgentHttpRequest */ "./sdk/src/modules/net/impl/NetAgentHttpRequest.ts");
Object.defineProperty(exports, "NetAgentHttpRequest", { enumerable: true, get: function () { return NetAgentHttpRequest_1.NetAgentHttpRequest; } });
var NetAgentPCRequest_1 = __nested_webpack_require_610633__(/*! ./impl/NetAgentPCRequest */ "./sdk/src/modules/net/impl/NetAgentPCRequest.ts");
Object.defineProperty(exports, "NetAgentPCRequest", { enumerable: true, get: function () { return NetAgentPCRequest_1.NetAgentPCRequest; } });
var net_config_1 = __nested_webpack_require_610633__(/*! ./net.config */ "./sdk/src/modules/net/net.config.ts");
Object.defineProperty(exports, "NET_ACCESS_CONFIG", { enumerable: true, get: function () { return net_config_1.NET_ACCESS_CONFIG; } });


/***/ }),

/***/ "./sdk/src/modules/net/net.config.ts":
/*!*******************************************!*\
  !*** ./sdk/src/modules/net/net.config.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_612468__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.APP_CONFIG_KEY = exports.NET_ACCESS_SERVERS = exports.NET_ACCESS_CONFIG = void 0;
var AccessHubDefine_1 = __nested_webpack_require_612468__(/*! ./entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
exports.NET_ACCESS_CONFIG = {
    // serverUrls: ['wss://access-wss-alpha.zego.im/accesshub'],
    domains: ['access-wss-alpha.zego.im'],
    mode: 'online',
    modeNo: AccessHubDefine_1.Mode.MODE_ONLINE,
    sdkType: 3,
    connectVer: 1,
    pcEstablishTimeout: 15,
    scheme: 'wss',
    location: 'accesshub',
    wssMessageType: 1,
};
exports.NET_ACCESS_SERVERS = 'z_net_access_servers';
exports.APP_CONFIG_KEY = 'z_appconfig';


/***/ }),

/***/ "./sdk/src/modules/net/protocol/AccessHubProtoBuf.ts":
/*!***********************************************************!*\
  !*** ./sdk/src/modules/net/protocol/AccessHubProtoBuf.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_613554__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccessHubProtoBuf = void 0;
var long_1 = __importDefault(__nested_webpack_require_613554__(/*! long */ "./node_modules/long/src/long.js"));
var $protobuf = __importStar(__nested_webpack_require_613554__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js"));
var AccessHubDefine_1 = __nested_webpack_require_613554__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
// @ts-ignore
var protocol_js_1 = __importDefault(__nested_webpack_require_613554__(/*! ./protocol.js */ "./sdk/src/modules/net/protocol/protocol.js"));
$protobuf.util.Long = long_1.default;
$protobuf.configure();
var AccessHubProtoBuf = /** @class */ (function () {
    function AccessHubProtoBuf() {
        var _a;
        this.protoInstance = protocol_js_1.default;
        this.protoMap = (_a = {},
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_STREAM_CLOSED] = ['proto_accesshub', 'ConnectionClosed'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_CLOSE_CONNECTION] = ['proto_accesshub', 'CloseConnection'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HTTP_REQUEST] = ['proto_accesshub', 'HTTPRequest'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HTTP_RESPONSE] = ['proto_accesshub', 'HTTPResponse'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HB_REQUEST] = ['proto_accesshub', 'HBRequest'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HB_RESPONSE] = ['proto_accesshub', 'HBResponse'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_GET_CONFIG_REQUEST] = ['proto_accesshub', 'GetConfigRequest'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_GET_CONFIG_RESPONSE] = ['proto_accesshub', 'GetConfigResponse'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HTTP_REQUEST_ACK] = ['proto_accesshub', 'HBResponse'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_UPWARD_MESSAGE] = ['proto_accesshub', 'PCUpwardMessage'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_UPWARD_MESSAGE_ACK] = ['proto_accesshub', 'PCUpwardMessageAck'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_ESTABLISHED] = ['proto_accesshub', 'PCEstablished'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_BROKEN] = ['proto_accesshub', 'PCBroken'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_DOWNWARD_MESSAGE] = ['proto_accesshub', 'PCDownwardMessage'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_REDIRECT] = ['proto_accesshub', 'Redirect'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_GET_APPCONFIG_REQUEST] = ['proto_accesshub', 'GetAppConfigRequest'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_GET_APPCONFIG_RESPONSE] = ['proto_accesshub', 'GetAppConfigResponse'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PUSH_APPCONFIG] = ['proto_accesshub', 'PushAppConfig'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_ACCESSHUB_DISPATCH_REQUEST] = ['proto_accesshub', 'AccesshubDispatchRequest'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_ACCESSHUB_DISPATCH_RESPONSE] = ['proto_accesshub', 'AccesshubDispatchResponse'],
            _a);
    }
    AccessHubProtoBuf.prototype.encodeRequest = function (msgType, body, streamID) {
        var _a = this.protoMap[msgType], nameSpace = _a[0], bean = _a[1];
        var uint8_body = this.encode(this.protoInstance[nameSpace][bean], body);
        var len_body = uint8_body.length;
        // 构造通信协议：0xAF(1字节)+ ver(1字节)+type(2字节)+bodyLen(4字节)+streamID(4字节)+flags(1字节)+body
        var uint8 = new Uint8Array(1 + 1 + 2 + 4 + 4 + 1 + len_body);
        uint8[0] = 0xaf;
        uint8[1] = 0;
        uint8[2] = msgType >> 8;
        uint8[3] = msgType - (uint8[2] << 8);
        uint8.set(new Uint8Array(Int32Array.from([len_body]).buffer).reverse(), 4); // bodyLen
        uint8.set(new Uint8Array(Int32Array.from([streamID]).buffer).reverse(), 8); // streamID
        uint8[12] = 0;
        uint8.set(uint8_body, 13);
        return uint8;
    };
    AccessHubProtoBuf.prototype.decodeResponse = function (uint8) {
        var msgType = (uint8[2] << 8) + uint8[3];
        var dataView = new DataView(uint8.buffer);
        // const len_body = dataView.getUint32(4);
        var streamID = dataView.getUint32(8);
        var uint8_body = uint8.slice(13);
        try {
            var _a = this.protoMap[msgType], namespace = _a[0], bean = _a[1];
            var body = this.decode(this.protoInstance[namespace][bean], uint8_body);
            return [streamID, msgType, body];
        }
        catch (error) {
            // TODO
            return [streamID, msgType, { code: 1 }];
        }
    };
    AccessHubProtoBuf.prototype.decodeConfigMessage = function (buffer) {
        var config = this.decode(this.protoInstance.proto_initconfig.InitConfig, buffer);
        return config;
    };
    AccessHubProtoBuf.prototype.encode = function (instance, payload) {
        return instance.encode(new instance(payload)).finish();
    };
    AccessHubProtoBuf.prototype.decode = function (instance, buffer) {
        return __assign({}, instance.decode(buffer));
    };
    return AccessHubProtoBuf;
}());
exports.AccessHubProtoBuf = AccessHubProtoBuf;


/***/ }),

/***/ "./sdk/src/modules/net/protocol/protocol.js":
/*!**************************************************!*\
  !*** ./sdk/src/modules/net/protocol/protocol.js ***!
  \**************************************************/
/*! exports provided: proto_accesshub, proto_initconfig, default */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_620691__) {

"use strict";
__nested_webpack_require_620691__.r(__webpack_exports__);
/* harmony export (binding) */ __nested_webpack_require_620691__.d(__webpack_exports__, "proto_accesshub", function() { return proto_accesshub; });
/* harmony export (binding) */ __nested_webpack_require_620691__.d(__webpack_exports__, "proto_initconfig", function() { return proto_initconfig; });
/* harmony export (binding) */ __nested_webpack_require_620691__.d(__webpack_exports__, "default", function() { return $root; });
/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_620691__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");
/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_620691__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/


const $Reader = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__["Reader"], $Writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__["Writer"], $util = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__["util"];

const $root = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__["roots"]["default"] || (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__["roots"]["default"] = {});

const proto_accesshub = $root.proto_accesshub = (() => {

    const proto_accesshub = {};

    proto_accesshub.MessageType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MSG_TYPE_EMPTY"] = 0;
        values[valuesById[1] = "MSG_TYPE_CONNECTION_CLOSED"] = 1;
        values[valuesById[2] = "MSG_TYPE_STREAM_CLOSED"] = 2;
        values[valuesById[3] = "MSG_TYPE_CLOSE_CONNECTION"] = 3;
        values[valuesById[4] = "MSG_TYPE_HTTP_REQUEST"] = 4;
        values[valuesById[5] = "MSG_TYPE_HTTP_RESPONSE"] = 5;
        values[valuesById[6] = "MSG_TYPE_HTTP_REQUEST_DROPED"] = 6;
        values[valuesById[7] = "MSG_TYPE_PROXY_CONNECT"] = 7;
        values[valuesById[8] = "MSG_TYPE_PROXY_CONNECTED"] = 8;
        values[valuesById[9] = "MSG_TYPE_PROXY_CONNECTION_CLOSED"] = 9;
        values[valuesById[10] = "MSG_TYPE_PROXY_SEND_DATA"] = 10;
        values[valuesById[11] = "MSG_TYPE_PROXY_RECV_DATA"] = 11;
        values[valuesById[12] = "MSG_TYPE_HB_REQUEST"] = 12;
        values[valuesById[13] = "MSG_TYPE_HB_RESPONSE"] = 13;
        values[valuesById[14] = "MSG_TYPE_GET_CONFIG_REQUEST"] = 14;
        values[valuesById[15] = "MSG_TYPE_GET_CONFIG_RESPONSE"] = 15;
        values[valuesById[16] = "MSG_TYPE_HTTP_REQUEST_ACK"] = 16;
        values[valuesById[17] = "MSG_TYPE_PC_UPWARD_MESSAGE"] = 17;
        values[valuesById[18] = "MSG_TYPE_PC_UPWARD_MESSAGE_ACK"] = 18;
        values[valuesById[19] = "MSG_TYPE_PC_ESTABLISHED"] = 19;
        values[valuesById[20] = "MSG_TYPE_PC_BROKEN"] = 20;
        values[valuesById[21] = "MSG_TYPE_PC_DOWNWARD_MESSAGE"] = 21;
        values[valuesById[22] = "MSG_TYPE_REDIRECT"] = 22;
        values[valuesById[23] = "MSG_TYPE_GET_APPCONFIG_REQUEST"] = 23;
        values[valuesById[24] = "MSG_TYPE_GET_APPCONFIG_RESPONSE"] = 24;
        values[valuesById[25] = "MSG_TYPE_PUSH_APPCONFIG"] = 25;
        values[valuesById[26] = "MSG_TYPE_ACCESSHUB_DISPATCH_REQUEST"] = 26;
        values[valuesById[27] = "MSG_TYPE_ACCESSHUB_DISPATCH_RESPONSE"] = 27;
        values[valuesById[28] = "MSG_TYPE_GET_IM_CONFIG_REQUEST"] = 28;
        values[valuesById[29] = "MSG_TYPE_GET_IM_CONFIG_RESPONSE"] = 29;
        values[valuesById[50] = "MSG_TYPE_UA_DISPATCH_REQUEST"] = 50;
        values[valuesById[51] = "MSG_TYPE_UA_DISPATCH_RESPONSE"] = 51;
        values[valuesById[52] = "MSG_TYPE_UA_ECHO_REQUEST"] = 52;
        values[valuesById[53] = "MSG_TYPE_UA_ECHO_RESPONSE"] = 53;
        values[valuesById[100] = "MSG_TYPE_NODE_REGISTER_REQUEST"] = 100;
        values[valuesById[101] = "MSG_TYPE_NODE_REGISTER_RESPONSE"] = 101;
        values[valuesById[102] = "MSG_TYPE_NODE_HB_REQUEST"] = 102;
        values[valuesById[103] = "MSG_TYPE_NODE_HB_RESPONSE"] = 103;
        return values;
    })();

    proto_accesshub.ErrorCode = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OK"] = 0;
        values[valuesById[10000] = "DISPATCH_NO_AVAILABLE_NODE"] = 10000;
        values[valuesById[10001] = "DISPATCH_INTERNAL_ERROR"] = 10001;
        values[valuesById[10002] = "DISPATCH_INVALID_FRAME"] = 10002;
        values[valuesById[10003] = "DISPATCH_UNMARSHAL"] = 10003;
        values[valuesById[10004] = "DISPATCH_MSGTYPE"] = 10004;
        values[valuesById[10005] = "DISPATCH_MARSHAL"] = 10005;
        values[valuesById[10006] = "DISPATCH_TOO_FREQUENTLY"] = 10006;
        values[valuesById[20000] = "ACCESSHUB_INVALID_FRAME"] = 20000;
        values[valuesById[20001] = "ACCESSHUB_NEED_ENCRYPT"] = 20001;
        values[valuesById[20002] = "ACCESSHUB_DECRYPT"] = 20002;
        values[valuesById[20003] = "ACCESSHUB_MSGTYPE"] = 20003;
        values[valuesById[20004] = "ACCESSHUB_UNMARSHAL"] = 20004;
        values[valuesById[20005] = "ACCESSHUB_TIMEOUT"] = 20005;
        values[valuesById[20006] = "ACCESSHUB_CONNECT"] = 20006;
        values[valuesById[20007] = "ACCESSHUB_BROKEN"] = 20007;
        values[valuesById[20008] = "ACCESSHUB_INTERNAL_ERROR"] = 20008;
        values[valuesById[20009] = "ACCESSHUB_MARSHAL"] = 20009;
        values[valuesById[20010] = "ACCESSHUB_UNSUPPORTED_SERVICE"] = 20010;
        values[valuesById[20011] = "ACCESSHUB_TOO_FREQUENTLY"] = 20011;
        values[valuesById[20012] = "ACCESSHUB_INVALID_APPID"] = 20012;
        values[valuesById[20013] = "ACCESSHUB_HB_TIMEOUT"] = 20013;
        values[valuesById[20014] = "ACCESSHUB_INVALID_SIGNATURE"] = 20014;
        values[valuesById[20015] = "ACCESSHUB_AUTH_FAILED"] = 20015;
        values[valuesById[30000] = "ACCESSHUB_GET_STREAM_FAILED"] = 30000;
        values[valuesById[30001] = "ACCESSHUB_GET_CONN_FAILED"] = 30001;
        values[valuesById[30002] = "ACCESSHUB_DO_HTTP_REQUEST_FAILED"] = 30002;
        values[valuesById[30003] = "ACCESSHUB_UNMARSHAL_HB_FAILED"] = 30003;
        values[valuesById[30004] = "ACCESSHUB_DO_BACKEND_DISPATCH_FAILED"] = 30004;
        return values;
    })();

    proto_accesshub.Mode = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Mode_UNSET"] = 0;
        values[valuesById[1] = "MODE_ONLINE"] = 1;
        values[valuesById[2] = "MODE_TEST"] = 2;
        values[valuesById[3] = "MODE_ALPHA"] = 3;
        return values;
    })();

    proto_accesshub.Service = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SERVICE_UNSET"] = 0;
        values[valuesById[1] = "SERVICE_MEDIAGW"] = 1;
        values[valuesById[2] = "SERVICE_LIVEROOM"] = 2;
        values[valuesById[3] = "SERVICE_MIX"] = 3;
        values[valuesById[4] = "SERVICE_ZEUS"] = 4;
        values[valuesById[5] = "SERVICE_ZPUSH"] = 5;
        values[valuesById[6] = "SERVICE_L3"] = 6;
        values[valuesById[7] = "SERVICE_TALKLINE"] = 7;
        values[valuesById[8] = "SERVICE_EDUSUITE"] = 8;
        values[valuesById[9] = "SERVICE_ZIM"] = 9;
        values[valuesById[10] = "SERVICE_ClOUD_SETTING"] = 10;
        values[valuesById[11] = "SERVICE_ZEUSHB"] = 11;
        values[valuesById[12] = "SERVICE_USER_LOGIC"] = 12;
        values[valuesById[13] = "SERVICE_UNIFYDISPATCH"] = 13;
        values[valuesById[14] = "SERVICE_QUALITY"] = 14;
        values[valuesById[15] = "SERVICE_SECURITY"] = 15;
        values[valuesById[16] = "SERVICE_KTVCPR"] = 16;
        values[valuesById[17] = "SERVICE_SWITCH4LIVEROOM"] = 17;
        values[valuesById[18] = "SERVICE_WEBRTC_SIGNAL"] = 18;
        values[valuesById[19] = "SERVICE_L3_WEBRTC_SIGNAL"] = 19;
        return values;
    })();

    proto_accesshub.Method = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "METHOD_UNSET"] = 0;
        values[valuesById[1] = "METHOD_GET"] = 1;
        values[valuesById[2] = "METHOD_POST"] = 2;
        return values;
    })();

    proto_accesshub.SdkType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SDK_TYPE_UNSET"] = 0;
        values[valuesById[1] = "SDK_TYPE_QUIC_MTCP_NATIVE"] = 1;
        values[valuesById[2] = "SDK_TYPE_WSS_NATIVE"] = 2;
        values[valuesById[3] = "SDK_TYPE_WSS_WEB"] = 3;
        return values;
    })();

    proto_accesshub.ZegoconnRunEnv = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ZEGOCONN_RUN_ENV_UNSET"] = 0;
        values[valuesById[1] = "ZEGOCONN_RUN_ENV_BROWSER"] = 1;
        values[valuesById[2] = "ZEGOCONN_RUN_ENV_APPLET"] = 2;
        return values;
    })();

    proto_accesshub.ConnectionClosed = (function() {

        function ConnectionClosed(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        ConnectionClosed.prototype.code = 0;
        ConnectionClosed.prototype.msg = "";

        ConnectionClosed.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(8).int32(message.code);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(18).string(message.msg);
            return writer;
        };

        ConnectionClosed.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.ConnectionClosed();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.int32();
                    break;
                case 2:
                    message.msg = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ConnectionClosed;
    })();

    proto_accesshub.StreamClosed = (function() {

        function StreamClosed(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        StreamClosed.prototype.code = 0;
        StreamClosed.prototype.msg = "";

        StreamClosed.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(8).int32(message.code);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(18).string(message.msg);
            return writer;
        };

        StreamClosed.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.StreamClosed();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.int32();
                    break;
                case 2:
                    message.msg = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StreamClosed;
    })();

    proto_accesshub.CloseConnection = (function() {

        function CloseConnection(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        CloseConnection.prototype.reason = 0;
        CloseConnection.prototype.msg = "";
        CloseConnection.prototype.action = 0;

        CloseConnection.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(8).int32(message.reason);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(18).string(message.msg);
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(24).int32(message.action);
            return writer;
        };

        CloseConnection.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.CloseConnection();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reason = reader.int32();
                    break;
                case 2:
                    message.msg = reader.string();
                    break;
                case 3:
                    message.action = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        CloseConnection.Action = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ACTION_RESERVED"] = 0;
            values[valuesById[1] = "ACTION_DISPATCH"] = 1;
            values[valuesById[2] = "ACTION_RETRY"] = 2;
            values[valuesById[3] = "ACTION_NEXT_NODE"] = 3;
            values[valuesById[4] = "ACTION_ABORT"] = 4;
            values[valuesById[5] = "ACTION_NEXT_GROUP"] = 5;
            return values;
        })();

        return CloseConnection;
    })();

    proto_accesshub.HTTPRequest = (function() {

        function HTTPRequest(properties) {
            this.headers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        HTTPRequest.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        HTTPRequest.prototype.appid = 0;
        HTTPRequest.prototype.biz_type = 0;
        HTTPRequest.prototype.mode = "";
        HTTPRequest.prototype.id_name = "";
        HTTPRequest.prototype.reqid = "";
        HTTPRequest.prototype.stick = "";
        HTTPRequest.prototype.service = "";
        HTTPRequest.prototype.location = "";
        HTTPRequest.prototype.method = "";
        HTTPRequest.prototype.headers = $util.emptyArray;
        HTTPRequest.prototype.body = $util.newBuffer([]);
        HTTPRequest.prototype.ack = false;
        HTTPRequest.prototype.mode_no = 0;
        HTTPRequest.prototype.service_no = 0;
        HTTPRequest.prototype.method_no = 0;
        HTTPRequest.prototype.sdk_type = 0;
        HTTPRequest.prototype.zegoconn_run_env = 0;

        HTTPRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.appid != null && Object.hasOwnProperty.call(message, "appid"))
                writer.uint32(16).uint32(message.appid);
            if (message.biz_type != null && Object.hasOwnProperty.call(message, "biz_type"))
                writer.uint32(24).uint32(message.biz_type);
            if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                writer.uint32(34).string(message.mode);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(42).string(message.id_name);
            if (message.reqid != null && Object.hasOwnProperty.call(message, "reqid"))
                writer.uint32(50).string(message.reqid);
            if (message.stick != null && Object.hasOwnProperty.call(message, "stick"))
                writer.uint32(58).string(message.stick);
            if (message.service != null && Object.hasOwnProperty.call(message, "service"))
                writer.uint32(66).string(message.service);
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                writer.uint32(74).string(message.location);
            if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                writer.uint32(82).string(message.method);
            if (message.headers != null && message.headers.length)
                for (let i = 0; i < message.headers.length; ++i)
                    $root.proto_accesshub.HTTPRequest.HTTPHeader.encode(message.headers[i], writer.uint32(90).fork()).ldelim();
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(98).bytes(message.body);
            if (message.ack != null && Object.hasOwnProperty.call(message, "ack"))
                writer.uint32(104).bool(message.ack);
            if (message.mode_no != null && Object.hasOwnProperty.call(message, "mode_no"))
                writer.uint32(112).int32(message.mode_no);
            if (message.service_no != null && Object.hasOwnProperty.call(message, "service_no"))
                writer.uint32(120).int32(message.service_no);
            if (message.method_no != null && Object.hasOwnProperty.call(message, "method_no"))
                writer.uint32(128).int32(message.method_no);
            if (message.sdk_type != null && Object.hasOwnProperty.call(message, "sdk_type"))
                writer.uint32(136).int32(message.sdk_type);
            if (message.zegoconn_run_env != null && Object.hasOwnProperty.call(message, "zegoconn_run_env"))
                writer.uint32(144).int32(message.zegoconn_run_env);
            return writer;
        };

        HTTPRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.HTTPRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.appid = reader.uint32();
                    break;
                case 3:
                    message.biz_type = reader.uint32();
                    break;
                case 4:
                    message.mode = reader.string();
                    break;
                case 5:
                    message.id_name = reader.string();
                    break;
                case 6:
                    message.reqid = reader.string();
                    break;
                case 7:
                    message.stick = reader.string();
                    break;
                case 8:
                    message.service = reader.string();
                    break;
                case 9:
                    message.location = reader.string();
                    break;
                case 10:
                    message.method = reader.string();
                    break;
                case 11:
                    if (!(message.headers && message.headers.length))
                        message.headers = [];
                    message.headers.push($root.proto_accesshub.HTTPRequest.HTTPHeader.decode(reader, reader.uint32()));
                    break;
                case 12:
                    message.body = reader.bytes();
                    break;
                case 13:
                    message.ack = reader.bool();
                    break;
                case 14:
                    message.mode_no = reader.int32();
                    break;
                case 15:
                    message.service_no = reader.int32();
                    break;
                case 16:
                    message.method_no = reader.int32();
                    break;
                case 17:
                    message.sdk_type = reader.int32();
                    break;
                case 18:
                    message.zegoconn_run_env = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        HTTPRequest.HTTPHeader = (function() {

            function HTTPHeader(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            HTTPHeader.prototype.name = "";
            HTTPHeader.prototype.val = "";

            HTTPHeader.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(10).string(message.name);
                if (message.val != null && Object.hasOwnProperty.call(message, "val"))
                    writer.uint32(18).string(message.val);
                return writer;
            };

            HTTPHeader.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.HTTPRequest.HTTPHeader();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.val = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return HTTPHeader;
        })();

        return HTTPRequest;
    })();

    proto_accesshub.HTTPResponse = (function() {

        function HTTPResponse(properties) {
            this.headers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        HTTPResponse.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        HTTPResponse.prototype.headers = $util.emptyArray;
        HTTPResponse.prototype.status_code = 0;
        HTTPResponse.prototype.body = $util.newBuffer([]);

        HTTPResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.headers != null && message.headers.length)
                for (let i = 0; i < message.headers.length; ++i)
                    $root.proto_accesshub.HTTPRequest.HTTPHeader.encode(message.headers[i], writer.uint32(18).fork()).ldelim();
            if (message.status_code != null && Object.hasOwnProperty.call(message, "status_code"))
                writer.uint32(24).int32(message.status_code);
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(34).bytes(message.body);
            return writer;
        };

        HTTPResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.HTTPResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    if (!(message.headers && message.headers.length))
                        message.headers = [];
                    message.headers.push($root.proto_accesshub.HTTPRequest.HTTPHeader.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.status_code = reader.int32();
                    break;
                case 4:
                    message.body = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return HTTPResponse;
    })();

    proto_accesshub.HTTPRequestAck = (function() {

        function HTTPRequestAck(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        HTTPRequestAck.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        HTTPRequestAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            return writer;
        };

        HTTPRequestAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.HTTPRequestAck();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return HTTPRequestAck;
    })();

    proto_accesshub.HTTPRequestDroped = (function() {

        function HTTPRequestDroped(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        HTTPRequestDroped.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        HTTPRequestDroped.prototype.reason = 0;
        HTTPRequestDroped.prototype.msg = "";

        HTTPRequestDroped.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(16).int32(message.reason);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(26).string(message.msg);
            return writer;
        };

        HTTPRequestDroped.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.HTTPRequestDroped();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                case 3:
                    message.msg = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return HTTPRequestDroped;
    })();

    proto_accesshub.ProxyConnect = (function() {

        function ProxyConnect(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        ProxyConnect.prototype.appid = 0;
        ProxyConnect.prototype.biz_type = 0;
        ProxyConnect.prototype.mode = "";
        ProxyConnect.prototype.id_name = "";
        ProxyConnect.prototype.reqid = "";
        ProxyConnect.prototype.stick = "";
        ProxyConnect.prototype.service = "";
        ProxyConnect.prototype.dest = "";

        ProxyConnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.appid != null && Object.hasOwnProperty.call(message, "appid"))
                writer.uint32(8).uint32(message.appid);
            if (message.biz_type != null && Object.hasOwnProperty.call(message, "biz_type"))
                writer.uint32(16).uint32(message.biz_type);
            if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                writer.uint32(26).string(message.mode);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(34).string(message.id_name);
            if (message.reqid != null && Object.hasOwnProperty.call(message, "reqid"))
                writer.uint32(42).string(message.reqid);
            if (message.stick != null && Object.hasOwnProperty.call(message, "stick"))
                writer.uint32(50).string(message.stick);
            if (message.service != null && Object.hasOwnProperty.call(message, "service"))
                writer.uint32(58).string(message.service);
            if (message.dest != null && Object.hasOwnProperty.call(message, "dest"))
                writer.uint32(66).string(message.dest);
            return writer;
        };

        ProxyConnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.ProxyConnect();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.appid = reader.uint32();
                    break;
                case 2:
                    message.biz_type = reader.uint32();
                    break;
                case 3:
                    message.mode = reader.string();
                    break;
                case 4:
                    message.id_name = reader.string();
                    break;
                case 5:
                    message.reqid = reader.string();
                    break;
                case 6:
                    message.stick = reader.string();
                    break;
                case 7:
                    message.service = reader.string();
                    break;
                case 8:
                    message.dest = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ProxyConnect;
    })();

    proto_accesshub.ProxyConnected = (function() {

        function ProxyConnected(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        ProxyConnected.prototype.trycount = 0;
        ProxyConnected.prototype.elapse = 0;

        ProxyConnected.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trycount != null && Object.hasOwnProperty.call(message, "trycount"))
                writer.uint32(8).uint32(message.trycount);
            if (message.elapse != null && Object.hasOwnProperty.call(message, "elapse"))
                writer.uint32(16).uint32(message.elapse);
            return writer;
        };

        ProxyConnected.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.ProxyConnected();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trycount = reader.uint32();
                    break;
                case 2:
                    message.elapse = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ProxyConnected;
    })();

    proto_accesshub.ProxyConnectionClosed = (function() {

        function ProxyConnectionClosed(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        ProxyConnectionClosed.prototype.code = 0;
        ProxyConnectionClosed.prototype.msg = "";
        ProxyConnectionClosed.prototype.connected = 0;

        ProxyConnectionClosed.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(8).int32(message.code);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(18).string(message.msg);
            if (message.connected != null && Object.hasOwnProperty.call(message, "connected"))
                writer.uint32(24).int32(message.connected);
            return writer;
        };

        ProxyConnectionClosed.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.ProxyConnectionClosed();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.int32();
                    break;
                case 2:
                    message.msg = reader.string();
                    break;
                case 3:
                    message.connected = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ProxyConnectionClosed;
    })();

    proto_accesshub.ProxySendData = (function() {

        function ProxySendData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        ProxySendData.prototype.data = $util.newBuffer([]);

        ProxySendData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(10).bytes(message.data);
            return writer;
        };

        ProxySendData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.ProxySendData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ProxySendData;
    })();

    proto_accesshub.ProxyRecvData = (function() {

        function ProxyRecvData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        ProxyRecvData.prototype.data = $util.newBuffer([]);

        ProxyRecvData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(10).bytes(message.data);
            return writer;
        };

        ProxyRecvData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.ProxyRecvData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ProxyRecvData;
    })();

    proto_accesshub.HBRequest = (function() {

        function HBRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        HBRequest.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        HBRequest.prototype.ts = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        HBRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.ts != null && Object.hasOwnProperty.call(message, "ts"))
                writer.uint32(16).int64(message.ts);
            return writer;
        };

        HBRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.HBRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.ts = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return HBRequest;
    })();

    proto_accesshub.HBResponse = (function() {

        function HBResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        HBResponse.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        HBResponse.prototype.ts = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        HBResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.ts != null && Object.hasOwnProperty.call(message, "ts"))
                writer.uint32(16).int64(message.ts);
            return writer;
        };

        HBResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.HBResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.ts = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return HBResponse;
    })();

    proto_accesshub.GetConfigRequest = (function() {

        function GetConfigRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        GetConfigRequest.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        GetConfigRequest.prototype.appid = 0;
        GetConfigRequest.prototype.biz_type = 0;
        GetConfigRequest.prototype.mode = "";
        GetConfigRequest.prototype.id_name = "";
        GetConfigRequest.prototype.reqid = "";
        GetConfigRequest.prototype.zegoconn_version = 0;
        GetConfigRequest.prototype.sdk_type = 0;
        GetConfigRequest.prototype.zegoconn_run_env = 0;

        GetConfigRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.appid != null && Object.hasOwnProperty.call(message, "appid"))
                writer.uint32(16).uint32(message.appid);
            if (message.biz_type != null && Object.hasOwnProperty.call(message, "biz_type"))
                writer.uint32(24).uint32(message.biz_type);
            if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                writer.uint32(34).string(message.mode);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(42).string(message.id_name);
            if (message.reqid != null && Object.hasOwnProperty.call(message, "reqid"))
                writer.uint32(50).string(message.reqid);
            if (message.zegoconn_version != null && Object.hasOwnProperty.call(message, "zegoconn_version"))
                writer.uint32(56).uint32(message.zegoconn_version);
            if (message.sdk_type != null && Object.hasOwnProperty.call(message, "sdk_type"))
                writer.uint32(64).int32(message.sdk_type);
            if (message.zegoconn_run_env != null && Object.hasOwnProperty.call(message, "zegoconn_run_env"))
                writer.uint32(72).int32(message.zegoconn_run_env);
            return writer;
        };

        GetConfigRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.GetConfigRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.appid = reader.uint32();
                    break;
                case 3:
                    message.biz_type = reader.uint32();
                    break;
                case 4:
                    message.mode = reader.string();
                    break;
                case 5:
                    message.id_name = reader.string();
                    break;
                case 6:
                    message.reqid = reader.string();
                    break;
                case 7:
                    message.zegoconn_version = reader.uint32();
                    break;
                case 8:
                    message.sdk_type = reader.int32();
                    break;
                case 9:
                    message.zegoconn_run_env = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return GetConfigRequest;
    })();

    proto_accesshub.GetConfigResponseData = (function() {

        function GetConfigResponseData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        GetConfigResponseData.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        GetConfigResponseData.prototype.quic_hb_interval = 0;
        GetConfigResponseData.prototype.quic_hb_timeout = 0;
        GetConfigResponseData.prototype.logic_hb_interval = 0;
        GetConfigResponseData.prototype.logic_hb_timeout = 0;
        GetConfigResponseData.prototype.pc_establish_timeout = 0;
        GetConfigResponseData.prototype.sdk_link_detect_interval = 0;
        GetConfigResponseData.prototype.sdk_link_detect_duration = 0;

        GetConfigResponseData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.quic_hb_interval != null && Object.hasOwnProperty.call(message, "quic_hb_interval"))
                writer.uint32(16).uint32(message.quic_hb_interval);
            if (message.quic_hb_timeout != null && Object.hasOwnProperty.call(message, "quic_hb_timeout"))
                writer.uint32(24).uint32(message.quic_hb_timeout);
            if (message.logic_hb_interval != null && Object.hasOwnProperty.call(message, "logic_hb_interval"))
                writer.uint32(32).uint32(message.logic_hb_interval);
            if (message.logic_hb_timeout != null && Object.hasOwnProperty.call(message, "logic_hb_timeout"))
                writer.uint32(40).uint32(message.logic_hb_timeout);
            if (message.pc_establish_timeout != null && Object.hasOwnProperty.call(message, "pc_establish_timeout"))
                writer.uint32(48).uint32(message.pc_establish_timeout);
            if (message.sdk_link_detect_interval != null && Object.hasOwnProperty.call(message, "sdk_link_detect_interval"))
                writer.uint32(56).uint32(message.sdk_link_detect_interval);
            if (message.sdk_link_detect_duration != null && Object.hasOwnProperty.call(message, "sdk_link_detect_duration"))
                writer.uint32(64).uint32(message.sdk_link_detect_duration);
            return writer;
        };

        GetConfigResponseData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.GetConfigResponseData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.quic_hb_interval = reader.uint32();
                    break;
                case 3:
                    message.quic_hb_timeout = reader.uint32();
                    break;
                case 4:
                    message.logic_hb_interval = reader.uint32();
                    break;
                case 5:
                    message.logic_hb_timeout = reader.uint32();
                    break;
                case 6:
                    message.pc_establish_timeout = reader.uint32();
                    break;
                case 7:
                    message.sdk_link_detect_interval = reader.uint32();
                    break;
                case 8:
                    message.sdk_link_detect_duration = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return GetConfigResponseData;
    })();

    proto_accesshub.GetConfigResponse = (function() {

        function GetConfigResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        GetConfigResponse.prototype.code = 0;
        GetConfigResponse.prototype.message = "";
        GetConfigResponse.prototype.data = null;

        GetConfigResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(8).int32(message.code);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(18).string(message.message);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                $root.proto_accesshub.GetConfigResponseData.encode(message.data, writer.uint32(26).fork()).ldelim();
            return writer;
        };

        GetConfigResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.GetConfigResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.int32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.data = $root.proto_accesshub.GetConfigResponseData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return GetConfigResponse;
    })();

    proto_accesshub.PCUpwardMessage = (function() {

        function PCUpwardMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        PCUpwardMessage.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        PCUpwardMessage.prototype.appid = 0;
        PCUpwardMessage.prototype.biz_type = 0;
        PCUpwardMessage.prototype.mode_no = 0;
        PCUpwardMessage.prototype.id_name = "";
        PCUpwardMessage.prototype.service_no = 0;
        PCUpwardMessage.prototype.ack = false;
        PCUpwardMessage.prototype.payload = $util.newBuffer([]);
        PCUpwardMessage.prototype.sdk_type = 0;
        PCUpwardMessage.prototype.wss_message_type = 0;
        PCUpwardMessage.prototype.wss_path = "";
        PCUpwardMessage.prototype.wss_raw_query = "";
        PCUpwardMessage.prototype.zegoconn_version = 0;
        PCUpwardMessage.prototype.zegoconn_run_env = 0;

        PCUpwardMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.appid != null && Object.hasOwnProperty.call(message, "appid"))
                writer.uint32(16).uint32(message.appid);
            if (message.biz_type != null && Object.hasOwnProperty.call(message, "biz_type"))
                writer.uint32(24).uint32(message.biz_type);
            if (message.mode_no != null && Object.hasOwnProperty.call(message, "mode_no"))
                writer.uint32(32).int32(message.mode_no);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(42).string(message.id_name);
            if (message.service_no != null && Object.hasOwnProperty.call(message, "service_no"))
                writer.uint32(48).int32(message.service_no);
            if (message.ack != null && Object.hasOwnProperty.call(message, "ack"))
                writer.uint32(56).bool(message.ack);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(66).bytes(message.payload);
            if (message.sdk_type != null && Object.hasOwnProperty.call(message, "sdk_type"))
                writer.uint32(72).int32(message.sdk_type);
            if (message.wss_message_type != null && Object.hasOwnProperty.call(message, "wss_message_type"))
                writer.uint32(80).uint32(message.wss_message_type);
            if (message.wss_path != null && Object.hasOwnProperty.call(message, "wss_path"))
                writer.uint32(90).string(message.wss_path);
            if (message.wss_raw_query != null && Object.hasOwnProperty.call(message, "wss_raw_query"))
                writer.uint32(98).string(message.wss_raw_query);
            if (message.zegoconn_version != null && Object.hasOwnProperty.call(message, "zegoconn_version"))
                writer.uint32(104).uint32(message.zegoconn_version);
            if (message.zegoconn_run_env != null && Object.hasOwnProperty.call(message, "zegoconn_run_env"))
                writer.uint32(112).int32(message.zegoconn_run_env);
            return writer;
        };

        PCUpwardMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.PCUpwardMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.appid = reader.uint32();
                    break;
                case 3:
                    message.biz_type = reader.uint32();
                    break;
                case 4:
                    message.mode_no = reader.int32();
                    break;
                case 5:
                    message.id_name = reader.string();
                    break;
                case 6:
                    message.service_no = reader.int32();
                    break;
                case 7:
                    message.ack = reader.bool();
                    break;
                case 8:
                    message.payload = reader.bytes();
                    break;
                case 9:
                    message.sdk_type = reader.int32();
                    break;
                case 10:
                    message.wss_message_type = reader.uint32();
                    break;
                case 11:
                    message.wss_path = reader.string();
                    break;
                case 12:
                    message.wss_raw_query = reader.string();
                    break;
                case 13:
                    message.zegoconn_version = reader.uint32();
                    break;
                case 14:
                    message.zegoconn_run_env = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PCUpwardMessage;
    })();

    proto_accesshub.PCUpwardMessageAck = (function() {

        function PCUpwardMessageAck(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        PCUpwardMessageAck.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        PCUpwardMessageAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            return writer;
        };

        PCUpwardMessageAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.PCUpwardMessageAck();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PCUpwardMessageAck;
    })();

    proto_accesshub.PCEstablished = (function() {

        function PCEstablished(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        PCEstablished.prototype.elapse = 0;
        PCEstablished.prototype.from = 0;

        PCEstablished.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.elapse != null && Object.hasOwnProperty.call(message, "elapse"))
                writer.uint32(8).uint32(message.elapse);
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                writer.uint32(16).uint32(message.from);
            return writer;
        };

        PCEstablished.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.PCEstablished();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.elapse = reader.uint32();
                    break;
                case 2:
                    message.from = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PCEstablished;
    })();

    proto_accesshub.PCBroken = (function() {

        function PCBroken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        PCBroken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        PCBroken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.PCBroken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PCBroken;
    })();

    proto_accesshub.PCDownwardMessage = (function() {

        function PCDownwardMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        PCDownwardMessage.prototype.payload = $util.newBuffer([]);
        PCDownwardMessage.prototype.wss_message_type = 0;

        PCDownwardMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(10).bytes(message.payload);
            if (message.wss_message_type != null && Object.hasOwnProperty.call(message, "wss_message_type"))
                writer.uint32(16).uint32(message.wss_message_type);
            return writer;
        };

        PCDownwardMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.PCDownwardMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.payload = reader.bytes();
                    break;
                case 2:
                    message.wss_message_type = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PCDownwardMessage;
    })();

    proto_accesshub.Redirect = (function() {

        function Redirect(properties) {
            this.groups = [];
            this.opt_ports = [];
            this.wss_groups = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        Redirect.prototype.rand = "";
        Redirect.prototype.secret = "";
        Redirect.prototype.groups = $util.emptyArray;
        Redirect.prototype.opt_ports = $util.emptyArray;
        Redirect.prototype.wss_groups = $util.emptyArray;

        Redirect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rand != null && Object.hasOwnProperty.call(message, "rand"))
                writer.uint32(10).string(message.rand);
            if (message.secret != null && Object.hasOwnProperty.call(message, "secret"))
                writer.uint32(18).string(message.secret);
            if (message.groups != null && message.groups.length)
                for (let i = 0; i < message.groups.length; ++i)
                    $root.proto_accesshub.AccesshubDispatchGroup.encode(message.groups[i], writer.uint32(26).fork()).ldelim();
            if (message.opt_ports != null && message.opt_ports.length)
                for (let i = 0; i < message.opt_ports.length; ++i)
                    writer.uint32(32).uint32(message.opt_ports[i]);
            if (message.wss_groups != null && message.wss_groups.length)
                for (let i = 0; i < message.wss_groups.length; ++i)
                    $root.proto_accesshub.WssAccesshubDispatchGroup.encode(message.wss_groups[i], writer.uint32(42).fork()).ldelim();
            return writer;
        };

        Redirect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.Redirect();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rand = reader.string();
                    break;
                case 2:
                    message.secret = reader.string();
                    break;
                case 3:
                    if (!(message.groups && message.groups.length))
                        message.groups = [];
                    message.groups.push($root.proto_accesshub.AccesshubDispatchGroup.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.opt_ports && message.opt_ports.length))
                        message.opt_ports = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.opt_ports.push(reader.uint32());
                    } else
                        message.opt_ports.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.wss_groups && message.wss_groups.length))
                        message.wss_groups = [];
                    message.wss_groups.push($root.proto_accesshub.WssAccesshubDispatchGroup.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Redirect;
    })();

    proto_accesshub.GetAppConfigRequest = (function() {

        function GetAppConfigRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        GetAppConfigRequest.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        GetAppConfigRequest.prototype.appid = 0;
        GetAppConfigRequest.prototype.biz_type = 0;
        GetAppConfigRequest.prototype.mode_no = 0;
        GetAppConfigRequest.prototype.id_name = "";
        GetAppConfigRequest.prototype.config_key = "";
        GetAppConfigRequest.prototype.ts = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        GetAppConfigRequest.prototype.signature = $util.newBuffer([]);
        GetAppConfigRequest.prototype.lite_sign = "";
        GetAppConfigRequest.prototype.token = "";
        GetAppConfigRequest.prototype.sdk_type = 0;
        GetAppConfigRequest.prototype.zegoconn_version = 0;
        GetAppConfigRequest.prototype.zegoconn_run_env = 0;

        GetAppConfigRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.appid != null && Object.hasOwnProperty.call(message, "appid"))
                writer.uint32(16).uint32(message.appid);
            if (message.biz_type != null && Object.hasOwnProperty.call(message, "biz_type"))
                writer.uint32(24).uint32(message.biz_type);
            if (message.mode_no != null && Object.hasOwnProperty.call(message, "mode_no"))
                writer.uint32(32).int32(message.mode_no);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(42).string(message.id_name);
            if (message.config_key != null && Object.hasOwnProperty.call(message, "config_key"))
                writer.uint32(50).string(message.config_key);
            if (message.ts != null && Object.hasOwnProperty.call(message, "ts"))
                writer.uint32(56).uint64(message.ts);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(66).bytes(message.signature);
            if (message.lite_sign != null && Object.hasOwnProperty.call(message, "lite_sign"))
                writer.uint32(74).string(message.lite_sign);
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(82).string(message.token);
            if (message.sdk_type != null && Object.hasOwnProperty.call(message, "sdk_type"))
                writer.uint32(88).int32(message.sdk_type);
            if (message.zegoconn_version != null && Object.hasOwnProperty.call(message, "zegoconn_version"))
                writer.uint32(96).uint32(message.zegoconn_version);
            if (message.zegoconn_run_env != null && Object.hasOwnProperty.call(message, "zegoconn_run_env"))
                writer.uint32(104).int32(message.zegoconn_run_env);
            return writer;
        };

        GetAppConfigRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.GetAppConfigRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.appid = reader.uint32();
                    break;
                case 3:
                    message.biz_type = reader.uint32();
                    break;
                case 4:
                    message.mode_no = reader.int32();
                    break;
                case 5:
                    message.id_name = reader.string();
                    break;
                case 6:
                    message.config_key = reader.string();
                    break;
                case 7:
                    message.ts = reader.uint64();
                    break;
                case 8:
                    message.signature = reader.bytes();
                    break;
                case 9:
                    message.lite_sign = reader.string();
                    break;
                case 10:
                    message.token = reader.string();
                    break;
                case 11:
                    message.sdk_type = reader.int32();
                    break;
                case 12:
                    message.zegoconn_version = reader.uint32();
                    break;
                case 13:
                    message.zegoconn_run_env = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return GetAppConfigRequest;
    })();

    proto_accesshub.GetAppConfigResponseData = (function() {

        function GetAppConfigResponseData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        GetAppConfigResponseData.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        GetAppConfigResponseData.prototype.data = $util.newBuffer([]);
        GetAppConfigResponseData.prototype.ts = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        GetAppConfigResponseData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(18).bytes(message.data);
            if (message.ts != null && Object.hasOwnProperty.call(message, "ts"))
                writer.uint32(24).uint64(message.ts);
            return writer;
        };

        GetAppConfigResponseData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.GetAppConfigResponseData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                case 3:
                    message.ts = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return GetAppConfigResponseData;
    })();

    proto_accesshub.GetAppConfigResponse = (function() {

        function GetAppConfigResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        GetAppConfigResponse.prototype.code = 0;
        GetAppConfigResponse.prototype.message = "";
        GetAppConfigResponse.prototype.data = null;

        GetAppConfigResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(8).int32(message.code);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(18).string(message.message);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                $root.proto_accesshub.GetAppConfigResponseData.encode(message.data, writer.uint32(26).fork()).ldelim();
            return writer;
        };

        GetAppConfigResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.GetAppConfigResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.int32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.data = $root.proto_accesshub.GetAppConfigResponseData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return GetAppConfigResponse;
    })();

    proto_accesshub.PushAppConfig = (function() {

        function PushAppConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        PushAppConfig.prototype.config_key = "";
        PushAppConfig.prototype.data = $util.newBuffer([]);

        PushAppConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.config_key != null && Object.hasOwnProperty.call(message, "config_key"))
                writer.uint32(10).string(message.config_key);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(18).bytes(message.data);
            return writer;
        };

        PushAppConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.PushAppConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.config_key = reader.string();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushAppConfig;
    })();

    proto_accesshub.AccesshubDispatchRequest = (function() {

        function AccesshubDispatchRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        AccesshubDispatchRequest.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        AccesshubDispatchRequest.prototype.appid = 0;
        AccesshubDispatchRequest.prototype.biz_type = 0;
        AccesshubDispatchRequest.prototype.mode_no = 0;
        AccesshubDispatchRequest.prototype.id_name = "";
        AccesshubDispatchRequest.prototype.sdk_type = 0;
        AccesshubDispatchRequest.prototype.zegoconn_version = 0;
        AccesshubDispatchRequest.prototype.zegoconn_run_env = 0;

        AccesshubDispatchRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.appid != null && Object.hasOwnProperty.call(message, "appid"))
                writer.uint32(16).uint32(message.appid);
            if (message.biz_type != null && Object.hasOwnProperty.call(message, "biz_type"))
                writer.uint32(24).uint32(message.biz_type);
            if (message.mode_no != null && Object.hasOwnProperty.call(message, "mode_no"))
                writer.uint32(32).int32(message.mode_no);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(42).string(message.id_name);
            if (message.sdk_type != null && Object.hasOwnProperty.call(message, "sdk_type"))
                writer.uint32(48).int32(message.sdk_type);
            if (message.zegoconn_version != null && Object.hasOwnProperty.call(message, "zegoconn_version"))
                writer.uint32(56).uint32(message.zegoconn_version);
            if (message.zegoconn_run_env != null && Object.hasOwnProperty.call(message, "zegoconn_run_env"))
                writer.uint32(64).int32(message.zegoconn_run_env);
            return writer;
        };

        AccesshubDispatchRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.AccesshubDispatchRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.appid = reader.uint32();
                    break;
                case 3:
                    message.biz_type = reader.uint32();
                    break;
                case 4:
                    message.mode_no = reader.int32();
                    break;
                case 5:
                    message.id_name = reader.string();
                    break;
                case 6:
                    message.sdk_type = reader.int32();
                    break;
                case 7:
                    message.zegoconn_version = reader.uint32();
                    break;
                case 8:
                    message.zegoconn_run_env = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return AccesshubDispatchRequest;
    })();

    proto_accesshub.AccesshubDispatchGroup = (function() {

        function AccesshubDispatchGroup(properties) {
            this.quic_nodes = [];
            this.mtcp_nodes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        AccesshubDispatchGroup.prototype.group = "";
        AccesshubDispatchGroup.prototype.quic_nodes = $util.emptyArray;
        AccesshubDispatchGroup.prototype.mtcp_nodes = $util.emptyArray;

        AccesshubDispatchGroup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.group != null && Object.hasOwnProperty.call(message, "group"))
                writer.uint32(10).string(message.group);
            if (message.quic_nodes != null && message.quic_nodes.length)
                for (let i = 0; i < message.quic_nodes.length; ++i)
                    writer.uint32(18).string(message.quic_nodes[i]);
            if (message.mtcp_nodes != null && message.mtcp_nodes.length)
                for (let i = 0; i < message.mtcp_nodes.length; ++i)
                    writer.uint32(26).string(message.mtcp_nodes[i]);
            return writer;
        };

        AccesshubDispatchGroup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.AccesshubDispatchGroup();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.group = reader.string();
                    break;
                case 2:
                    if (!(message.quic_nodes && message.quic_nodes.length))
                        message.quic_nodes = [];
                    message.quic_nodes.push(reader.string());
                    break;
                case 3:
                    if (!(message.mtcp_nodes && message.mtcp_nodes.length))
                        message.mtcp_nodes = [];
                    message.mtcp_nodes.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return AccesshubDispatchGroup;
    })();

    proto_accesshub.WssAccesshubDispatchGroup = (function() {

        function WssAccesshubDispatchGroup(properties) {
            this.nodes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        WssAccesshubDispatchGroup.prototype.group = "";
        WssAccesshubDispatchGroup.prototype.host = "";
        WssAccesshubDispatchGroup.prototype.nodes = $util.emptyArray;

        WssAccesshubDispatchGroup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.group != null && Object.hasOwnProperty.call(message, "group"))
                writer.uint32(10).string(message.group);
            if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                writer.uint32(18).string(message.host);
            if (message.nodes != null && message.nodes.length)
                for (let i = 0; i < message.nodes.length; ++i)
                    writer.uint32(26).string(message.nodes[i]);
            return writer;
        };

        WssAccesshubDispatchGroup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.WssAccesshubDispatchGroup();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.group = reader.string();
                    break;
                case 2:
                    message.host = reader.string();
                    break;
                case 3:
                    if (!(message.nodes && message.nodes.length))
                        message.nodes = [];
                    message.nodes.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return WssAccesshubDispatchGroup;
    })();

    proto_accesshub.AccesshubDispatchResponseData = (function() {

        function AccesshubDispatchResponseData(properties) {
            this.groups = [];
            this.opt_ports = [];
            this.wss_groups = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        AccesshubDispatchResponseData.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        AccesshubDispatchResponseData.prototype.rand = "";
        AccesshubDispatchResponseData.prototype.secret = "";
        AccesshubDispatchResponseData.prototype.groups = $util.emptyArray;
        AccesshubDispatchResponseData.prototype.opt_ports = $util.emptyArray;
        AccesshubDispatchResponseData.prototype.wss_groups = $util.emptyArray;

        AccesshubDispatchResponseData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.rand != null && Object.hasOwnProperty.call(message, "rand"))
                writer.uint32(18).string(message.rand);
            if (message.secret != null && Object.hasOwnProperty.call(message, "secret"))
                writer.uint32(26).string(message.secret);
            if (message.groups != null && message.groups.length)
                for (let i = 0; i < message.groups.length; ++i)
                    $root.proto_accesshub.AccesshubDispatchGroup.encode(message.groups[i], writer.uint32(34).fork()).ldelim();
            if (message.opt_ports != null && message.opt_ports.length)
                for (let i = 0; i < message.opt_ports.length; ++i)
                    writer.uint32(40).uint32(message.opt_ports[i]);
            if (message.wss_groups != null && message.wss_groups.length)
                for (let i = 0; i < message.wss_groups.length; ++i)
                    $root.proto_accesshub.WssAccesshubDispatchGroup.encode(message.wss_groups[i], writer.uint32(50).fork()).ldelim();
            return writer;
        };

        AccesshubDispatchResponseData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.AccesshubDispatchResponseData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.rand = reader.string();
                    break;
                case 3:
                    message.secret = reader.string();
                    break;
                case 4:
                    if (!(message.groups && message.groups.length))
                        message.groups = [];
                    message.groups.push($root.proto_accesshub.AccesshubDispatchGroup.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.opt_ports && message.opt_ports.length))
                        message.opt_ports = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.opt_ports.push(reader.uint32());
                    } else
                        message.opt_ports.push(reader.uint32());
                    break;
                case 6:
                    if (!(message.wss_groups && message.wss_groups.length))
                        message.wss_groups = [];
                    message.wss_groups.push($root.proto_accesshub.WssAccesshubDispatchGroup.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return AccesshubDispatchResponseData;
    })();

    proto_accesshub.AccesshubDispatchResponse = (function() {

        function AccesshubDispatchResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        AccesshubDispatchResponse.prototype.code = 0;
        AccesshubDispatchResponse.prototype.message = "";
        AccesshubDispatchResponse.prototype.data = null;

        AccesshubDispatchResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(8).int32(message.code);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(18).string(message.message);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                $root.proto_accesshub.AccesshubDispatchResponseData.encode(message.data, writer.uint32(26).fork()).ldelim();
            return writer;
        };

        AccesshubDispatchResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.AccesshubDispatchResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.int32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.data = $root.proto_accesshub.AccesshubDispatchResponseData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return AccesshubDispatchResponse;
    })();

    proto_accesshub.GetIMConfigRequest = (function() {

        function GetIMConfigRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        GetIMConfigRequest.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        GetIMConfigRequest.prototype.appid = 0;
        GetIMConfigRequest.prototype.mode_no = 0;
        GetIMConfigRequest.prototype.user_id = "";
        GetIMConfigRequest.prototype.config_key = "";
        GetIMConfigRequest.prototype.token = "";
        GetIMConfigRequest.prototype.lite_sign = "";
        GetIMConfigRequest.prototype.sdk_type = 0;
        GetIMConfigRequest.prototype.zegoconn_version = 0;
        GetIMConfigRequest.prototype.zegoconn_run_env = 0;

        GetIMConfigRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.appid != null && Object.hasOwnProperty.call(message, "appid"))
                writer.uint32(16).uint32(message.appid);
            if (message.mode_no != null && Object.hasOwnProperty.call(message, "mode_no"))
                writer.uint32(24).int32(message.mode_no);
            if (message.user_id != null && Object.hasOwnProperty.call(message, "user_id"))
                writer.uint32(34).string(message.user_id);
            if (message.config_key != null && Object.hasOwnProperty.call(message, "config_key"))
                writer.uint32(42).string(message.config_key);
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(50).string(message.token);
            if (message.lite_sign != null && Object.hasOwnProperty.call(message, "lite_sign"))
                writer.uint32(58).string(message.lite_sign);
            if (message.sdk_type != null && Object.hasOwnProperty.call(message, "sdk_type"))
                writer.uint32(64).int32(message.sdk_type);
            if (message.zegoconn_version != null && Object.hasOwnProperty.call(message, "zegoconn_version"))
                writer.uint32(72).uint32(message.zegoconn_version);
            if (message.zegoconn_run_env != null && Object.hasOwnProperty.call(message, "zegoconn_run_env"))
                writer.uint32(80).int32(message.zegoconn_run_env);
            return writer;
        };

        GetIMConfigRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.GetIMConfigRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.appid = reader.uint32();
                    break;
                case 3:
                    message.mode_no = reader.int32();
                    break;
                case 4:
                    message.user_id = reader.string();
                    break;
                case 5:
                    message.config_key = reader.string();
                    break;
                case 6:
                    message.token = reader.string();
                    break;
                case 7:
                    message.lite_sign = reader.string();
                    break;
                case 8:
                    message.sdk_type = reader.int32();
                    break;
                case 9:
                    message.zegoconn_version = reader.uint32();
                    break;
                case 10:
                    message.zegoconn_run_env = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return GetIMConfigRequest;
    })();

    proto_accesshub.GetIMConfigResponseData = (function() {

        function GetIMConfigResponseData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        GetIMConfigResponseData.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        GetIMConfigResponseData.prototype.data = $util.newBuffer([]);

        GetIMConfigResponseData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(18).bytes(message.data);
            return writer;
        };

        GetIMConfigResponseData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.GetIMConfigResponseData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return GetIMConfigResponseData;
    })();

    proto_accesshub.GetIMConfigResponse = (function() {

        function GetIMConfigResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        GetIMConfigResponse.prototype.code = 0;
        GetIMConfigResponse.prototype.message = "";
        GetIMConfigResponse.prototype.data = null;

        GetIMConfigResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(8).int32(message.code);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(18).string(message.message);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                $root.proto_accesshub.GetIMConfigResponseData.encode(message.data, writer.uint32(26).fork()).ldelim();
            return writer;
        };

        GetIMConfigResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.GetIMConfigResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.int32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.data = $root.proto_accesshub.GetIMConfigResponseData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return GetIMConfigResponse;
    })();

    return proto_accesshub;
})();

const proto_initconfig = $root.proto_initconfig = (() => {

    const proto_initconfig = {};

    proto_initconfig.ProtoVersion = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RPOTO_V000000"] = 0;
        values[valuesById[65536] = "RPOTO_V010000"] = 65536;
        return values;
    })();

    proto_initconfig.ResourceType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CDN"] = 0;
        values[valuesById[1] = "RTC"] = 1;
        values[valuesById[2] = "L3"] = 2;
        return values;
    })();

    proto_initconfig.ProtocolType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UDP"] = 0;
        values[valuesById[1] = "RTMP"] = 1;
        values[valuesById[2] = "FLV"] = 2;
        values[valuesById[3] = "HLS"] = 3;
        values[valuesById[4] = "WEBRTC"] = 4;
        return values;
    })();

    proto_initconfig.ResolveType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LOCAL_DNS"] = 0;
        values[valuesById[1] = "DISPATCH"] = 1;
        return values;
    })();

    proto_initconfig.AppConfig = (function() {

        function AppConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        AppConfig.prototype.test_id = null;
        AppConfig.prototype.domain = null;
        AppConfig.prototype.flexible_domain = null;
        AppConfig.prototype.replace_flexible_domain = null;

        let $oneOfFields;

        Object.defineProperty(AppConfig.prototype, "_test_id", {
            get: $util.oneOfGetter($oneOfFields = ["test_id"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(AppConfig.prototype, "_domain", {
            get: $util.oneOfGetter($oneOfFields = ["domain"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(AppConfig.prototype, "_flexible_domain", {
            get: $util.oneOfGetter($oneOfFields = ["flexible_domain"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(AppConfig.prototype, "_replace_flexible_domain", {
            get: $util.oneOfGetter($oneOfFields = ["replace_flexible_domain"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        AppConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.test_id != null && Object.hasOwnProperty.call(message, "test_id"))
                writer.uint32(8).int32(message.test_id);
            if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
                writer.uint32(18).string(message.domain);
            if (message.flexible_domain != null && Object.hasOwnProperty.call(message, "flexible_domain"))
                writer.uint32(26).string(message.flexible_domain);
            if (message.replace_flexible_domain != null && Object.hasOwnProperty.call(message, "replace_flexible_domain"))
                writer.uint32(34).string(message.replace_flexible_domain);
            return writer;
        };

        AppConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.AppConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.test_id = reader.int32();
                    break;
                case 2:
                    message.domain = reader.string();
                    break;
                case 3:
                    message.flexible_domain = reader.string();
                    break;
                case 4:
                    message.replace_flexible_domain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return AppConfig;
    })();

    proto_initconfig.RoomConfig = (function() {

        function RoomConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        RoomConfig.prototype.license_url = null;

        let $oneOfFields;

        Object.defineProperty(RoomConfig.prototype, "_license_url", {
            get: $util.oneOfGetter($oneOfFields = ["license_url"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        RoomConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.license_url != null && Object.hasOwnProperty.call(message, "license_url"))
                writer.uint32(10).string(message.license_url);
            return writer;
        };

        RoomConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.RoomConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.license_url = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RoomConfig;
    })();

    proto_initconfig.VEConfig = (function() {

        function VEConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        VEConfig.prototype.audio_session_protect = null;

        let $oneOfFields;

        Object.defineProperty(VEConfig.prototype, "_audio_session_protect", {
            get: $util.oneOfGetter($oneOfFields = ["audio_session_protect"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        VEConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audio_session_protect != null && Object.hasOwnProperty.call(message, "audio_session_protect"))
                writer.uint32(8).int32(message.audio_session_protect);
            return writer;
        };

        VEConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.VEConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.audio_session_protect = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return VEConfig;
    })();

    proto_initconfig.SpeedlogConfig = (function() {

        function SpeedlogConfig(properties) {
            this.disable_report_pull = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        SpeedlogConfig.prototype.report_count = null;
        SpeedlogConfig.prototype.report_retry_interval = null;
        SpeedlogConfig.prototype.push_quality_sample_count = null;
        SpeedlogConfig.prototype.pull_quality_sample_count = null;
        SpeedlogConfig.prototype.hardware_report_cycle = null;
        SpeedlogConfig.prototype.room_user_max_count = null;
        SpeedlogConfig.prototype.room_stream_max_count = null;
        SpeedlogConfig.prototype.charge_info_report_cycle = null;
        SpeedlogConfig.prototype.charge_info_report_mode = null;
        SpeedlogConfig.prototype.disable_report_pull = $util.emptyArray;
        SpeedlogConfig.prototype.report_max_bytes = null;

        let $oneOfFields;

        Object.defineProperty(SpeedlogConfig.prototype, "_report_count", {
            get: $util.oneOfGetter($oneOfFields = ["report_count"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SpeedlogConfig.prototype, "_report_retry_interval", {
            get: $util.oneOfGetter($oneOfFields = ["report_retry_interval"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SpeedlogConfig.prototype, "_push_quality_sample_count", {
            get: $util.oneOfGetter($oneOfFields = ["push_quality_sample_count"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SpeedlogConfig.prototype, "_pull_quality_sample_count", {
            get: $util.oneOfGetter($oneOfFields = ["pull_quality_sample_count"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SpeedlogConfig.prototype, "_hardware_report_cycle", {
            get: $util.oneOfGetter($oneOfFields = ["hardware_report_cycle"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SpeedlogConfig.prototype, "_room_user_max_count", {
            get: $util.oneOfGetter($oneOfFields = ["room_user_max_count"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SpeedlogConfig.prototype, "_room_stream_max_count", {
            get: $util.oneOfGetter($oneOfFields = ["room_stream_max_count"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SpeedlogConfig.prototype, "_charge_info_report_cycle", {
            get: $util.oneOfGetter($oneOfFields = ["charge_info_report_cycle"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SpeedlogConfig.prototype, "_charge_info_report_mode", {
            get: $util.oneOfGetter($oneOfFields = ["charge_info_report_mode"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SpeedlogConfig.prototype, "_report_max_bytes", {
            get: $util.oneOfGetter($oneOfFields = ["report_max_bytes"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        SpeedlogConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.report_count != null && Object.hasOwnProperty.call(message, "report_count"))
                writer.uint32(8).int32(message.report_count);
            if (message.report_retry_interval != null && Object.hasOwnProperty.call(message, "report_retry_interval"))
                writer.uint32(16).int32(message.report_retry_interval);
            if (message.push_quality_sample_count != null && Object.hasOwnProperty.call(message, "push_quality_sample_count"))
                writer.uint32(24).int32(message.push_quality_sample_count);
            if (message.pull_quality_sample_count != null && Object.hasOwnProperty.call(message, "pull_quality_sample_count"))
                writer.uint32(32).int32(message.pull_quality_sample_count);
            if (message.hardware_report_cycle != null && Object.hasOwnProperty.call(message, "hardware_report_cycle"))
                writer.uint32(40).int32(message.hardware_report_cycle);
            if (message.room_user_max_count != null && Object.hasOwnProperty.call(message, "room_user_max_count"))
                writer.uint32(48).int32(message.room_user_max_count);
            if (message.room_stream_max_count != null && Object.hasOwnProperty.call(message, "room_stream_max_count"))
                writer.uint32(56).int32(message.room_stream_max_count);
            if (message.charge_info_report_cycle != null && Object.hasOwnProperty.call(message, "charge_info_report_cycle"))
                writer.uint32(64).int32(message.charge_info_report_cycle);
            if (message.charge_info_report_mode != null && Object.hasOwnProperty.call(message, "charge_info_report_mode"))
                writer.uint32(72).int32(message.charge_info_report_mode);
            if (message.disable_report_pull != null && message.disable_report_pull.length) {
                writer.uint32(82).fork();
                for (let i = 0; i < message.disable_report_pull.length; ++i)
                    writer.int32(message.disable_report_pull[i]);
                writer.ldelim();
            }
            if (message.report_max_bytes != null && Object.hasOwnProperty.call(message, "report_max_bytes"))
                writer.uint32(88).int32(message.report_max_bytes);
            return writer;
        };

        SpeedlogConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.SpeedlogConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.report_count = reader.int32();
                    break;
                case 2:
                    message.report_retry_interval = reader.int32();
                    break;
                case 3:
                    message.push_quality_sample_count = reader.int32();
                    break;
                case 4:
                    message.pull_quality_sample_count = reader.int32();
                    break;
                case 5:
                    message.hardware_report_cycle = reader.int32();
                    break;
                case 6:
                    message.room_user_max_count = reader.int32();
                    break;
                case 7:
                    message.room_stream_max_count = reader.int32();
                    break;
                case 8:
                    message.charge_info_report_cycle = reader.int32();
                    break;
                case 9:
                    message.charge_info_report_mode = reader.int32();
                    break;
                case 10:
                    if (!(message.disable_report_pull && message.disable_report_pull.length))
                        message.disable_report_pull = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.disable_report_pull.push(reader.int32());
                    } else
                        message.disable_report_pull.push(reader.int32());
                    break;
                case 11:
                    message.report_max_bytes = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SpeedlogConfig;
    })();

    proto_initconfig.MediaServiceProtocolInfo = (function() {

        function MediaServiceProtocolInfo(properties) {
            this.cdn_quic_version = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        MediaServiceProtocolInfo.prototype.config_id = null;
        MediaServiceProtocolInfo.prototype.protocol = null;
        MediaServiceProtocolInfo.prototype.url_template = null;
        MediaServiceProtocolInfo.prototype.resolve_type = null;
        MediaServiceProtocolInfo.prototype.push_cdn_authentication = null;
        MediaServiceProtocolInfo.prototype.cdn_quic_version = $util.emptyArray;

        let $oneOfFields;

        Object.defineProperty(MediaServiceProtocolInfo.prototype, "_config_id", {
            get: $util.oneOfGetter($oneOfFields = ["config_id"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaServiceProtocolInfo.prototype, "_protocol", {
            get: $util.oneOfGetter($oneOfFields = ["protocol"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaServiceProtocolInfo.prototype, "_url_template", {
            get: $util.oneOfGetter($oneOfFields = ["url_template"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaServiceProtocolInfo.prototype, "_resolve_type", {
            get: $util.oneOfGetter($oneOfFields = ["resolve_type"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaServiceProtocolInfo.prototype, "_push_cdn_authentication", {
            get: $util.oneOfGetter($oneOfFields = ["push_cdn_authentication"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        MediaServiceProtocolInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.config_id != null && Object.hasOwnProperty.call(message, "config_id"))
                writer.uint32(10).string(message.config_id);
            if (message.protocol != null && Object.hasOwnProperty.call(message, "protocol"))
                writer.uint32(16).int32(message.protocol);
            if (message.url_template != null && Object.hasOwnProperty.call(message, "url_template"))
                writer.uint32(26).string(message.url_template);
            if (message.resolve_type != null && Object.hasOwnProperty.call(message, "resolve_type"))
                writer.uint32(32).int32(message.resolve_type);
            if (message.push_cdn_authentication != null && Object.hasOwnProperty.call(message, "push_cdn_authentication"))
                writer.uint32(40).int32(message.push_cdn_authentication);
            if (message.cdn_quic_version != null && message.cdn_quic_version.length) {
                writer.uint32(50).fork();
                for (let i = 0; i < message.cdn_quic_version.length; ++i)
                    writer.int32(message.cdn_quic_version[i]);
                writer.ldelim();
            }
            return writer;
        };

        MediaServiceProtocolInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.MediaServiceProtocolInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.config_id = reader.string();
                    break;
                case 2:
                    message.protocol = reader.int32();
                    break;
                case 3:
                    message.url_template = reader.string();
                    break;
                case 4:
                    message.resolve_type = reader.int32();
                    break;
                case 5:
                    message.push_cdn_authentication = reader.int32();
                    break;
                case 6:
                    if (!(message.cdn_quic_version && message.cdn_quic_version.length))
                        message.cdn_quic_version = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.cdn_quic_version.push(reader.int32());
                    } else
                        message.cdn_quic_version.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MediaServiceProtocolInfo;
    })();

    proto_initconfig.MediaResourceInfo = (function() {

        function MediaResourceInfo(properties) {
            this.service_info = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        MediaResourceInfo.prototype.resource_type = null;
        MediaResourceInfo.prototype.service_info = $util.emptyArray;

        let $oneOfFields;

        Object.defineProperty(MediaResourceInfo.prototype, "_resource_type", {
            get: $util.oneOfGetter($oneOfFields = ["resource_type"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        MediaResourceInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resource_type != null && Object.hasOwnProperty.call(message, "resource_type"))
                writer.uint32(8).int32(message.resource_type);
            if (message.service_info != null && message.service_info.length)
                for (let i = 0; i < message.service_info.length; ++i)
                    $root.proto_initconfig.MediaServiceProtocolInfo.encode(message.service_info[i], writer.uint32(18).fork()).ldelim();
            return writer;
        };

        MediaResourceInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.MediaResourceInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resource_type = reader.int32();
                    break;
                case 2:
                    if (!(message.service_info && message.service_info.length))
                        message.service_info = [];
                    message.service_info.push($root.proto_initconfig.MediaServiceProtocolInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MediaResourceInfo;
    })();

    proto_initconfig.TrafficControl = (function() {

        function TrafficControl(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        TrafficControl.prototype.enable_traffic_control = null;
        TrafficControl.prototype.traffic_properties = null;

        let $oneOfFields;

        Object.defineProperty(TrafficControl.prototype, "_enable_traffic_control", {
            get: $util.oneOfGetter($oneOfFields = ["enable_traffic_control"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(TrafficControl.prototype, "_traffic_properties", {
            get: $util.oneOfGetter($oneOfFields = ["traffic_properties"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        TrafficControl.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enable_traffic_control != null && Object.hasOwnProperty.call(message, "enable_traffic_control"))
                writer.uint32(8).int32(message.enable_traffic_control);
            if (message.traffic_properties != null && Object.hasOwnProperty.call(message, "traffic_properties"))
                writer.uint32(16).int32(message.traffic_properties);
            return writer;
        };

        TrafficControl.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.TrafficControl();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enable_traffic_control = reader.int32();
                    break;
                case 2:
                    message.traffic_properties = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return TrafficControl;
    })();

    proto_initconfig.SupplementFrameControl = (function() {

        function SupplementFrameControl(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        SupplementFrameControl.prototype.enable = null;
        SupplementFrameControl.prototype.threshold = null;
        SupplementFrameControl.prototype.probability = null;

        let $oneOfFields;

        Object.defineProperty(SupplementFrameControl.prototype, "_enable", {
            get: $util.oneOfGetter($oneOfFields = ["enable"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SupplementFrameControl.prototype, "_threshold", {
            get: $util.oneOfGetter($oneOfFields = ["threshold"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SupplementFrameControl.prototype, "_probability", {
            get: $util.oneOfGetter($oneOfFields = ["probability"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        SupplementFrameControl.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enable != null && Object.hasOwnProperty.call(message, "enable"))
                writer.uint32(8).int32(message.enable);
            if (message.threshold != null && Object.hasOwnProperty.call(message, "threshold"))
                writer.uint32(16).int32(message.threshold);
            if (message.probability != null && Object.hasOwnProperty.call(message, "probability"))
                writer.uint32(24).int32(message.probability);
            return writer;
        };

        SupplementFrameControl.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.SupplementFrameControl();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enable = reader.int32();
                    break;
                case 2:
                    message.threshold = reader.int32();
                    break;
                case 3:
                    message.probability = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SupplementFrameControl;
    })();

    proto_initconfig.VideoParam = (function() {

        function VideoParam(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        VideoParam.prototype.video_width = null;
        VideoParam.prototype.video_height = null;
        VideoParam.prototype.video_codec_id = null;
        VideoParam.prototype.video_bitrate = null;

        let $oneOfFields;

        Object.defineProperty(VideoParam.prototype, "_video_width", {
            get: $util.oneOfGetter($oneOfFields = ["video_width"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(VideoParam.prototype, "_video_height", {
            get: $util.oneOfGetter($oneOfFields = ["video_height"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(VideoParam.prototype, "_video_codec_id", {
            get: $util.oneOfGetter($oneOfFields = ["video_codec_id"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(VideoParam.prototype, "_video_bitrate", {
            get: $util.oneOfGetter($oneOfFields = ["video_bitrate"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        VideoParam.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.video_width != null && Object.hasOwnProperty.call(message, "video_width"))
                writer.uint32(8).int32(message.video_width);
            if (message.video_height != null && Object.hasOwnProperty.call(message, "video_height"))
                writer.uint32(16).int32(message.video_height);
            if (message.video_codec_id != null && Object.hasOwnProperty.call(message, "video_codec_id"))
                writer.uint32(24).int32(message.video_codec_id);
            if (message.video_bitrate != null && Object.hasOwnProperty.call(message, "video_bitrate"))
                writer.uint32(32).int32(message.video_bitrate);
            return writer;
        };

        VideoParam.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.VideoParam();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.video_width = reader.int32();
                    break;
                case 2:
                    message.video_height = reader.int32();
                    break;
                case 3:
                    message.video_codec_id = reader.int32();
                    break;
                case 4:
                    message.video_bitrate = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return VideoParam;
    })();

    proto_initconfig.PushConfig = (function() {

        function PushConfig(properties) {
            this.video_param = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        PushConfig.prototype.channel_idx = null;
        PushConfig.prototype.mode = null;
        PushConfig.prototype.traffic_control = null;
        PushConfig.prototype.resolution_rate = null;
        PushConfig.prototype.video_param = $util.emptyArray;

        let $oneOfFields;

        Object.defineProperty(PushConfig.prototype, "_channel_idx", {
            get: $util.oneOfGetter($oneOfFields = ["channel_idx"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(PushConfig.prototype, "_mode", {
            get: $util.oneOfGetter($oneOfFields = ["mode"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(PushConfig.prototype, "_traffic_control", {
            get: $util.oneOfGetter($oneOfFields = ["traffic_control"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(PushConfig.prototype, "_resolution_rate", {
            get: $util.oneOfGetter($oneOfFields = ["resolution_rate"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        PushConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channel_idx != null && Object.hasOwnProperty.call(message, "channel_idx"))
                writer.uint32(8).int32(message.channel_idx);
            if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                writer.uint32(16).int32(message.mode);
            if (message.traffic_control != null && Object.hasOwnProperty.call(message, "traffic_control"))
                $root.proto_initconfig.TrafficControl.encode(message.traffic_control, writer.uint32(42).fork()).ldelim();
            if (message.resolution_rate != null && Object.hasOwnProperty.call(message, "resolution_rate"))
                writer.uint32(48).int32(message.resolution_rate);
            if (message.video_param != null && message.video_param.length)
                for (let i = 0; i < message.video_param.length; ++i)
                    $root.proto_initconfig.VideoParam.encode(message.video_param[i], writer.uint32(58).fork()).ldelim();
            return writer;
        };

        PushConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.PushConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channel_idx = reader.int32();
                    break;
                case 2:
                    message.mode = reader.int32();
                    break;
                case 5:
                    message.traffic_control = $root.proto_initconfig.TrafficControl.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.resolution_rate = reader.int32();
                    break;
                case 7:
                    if (!(message.video_param && message.video_param.length))
                        message.video_param = [];
                    message.video_param.push($root.proto_initconfig.VideoParam.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushConfig;
    })();

    proto_initconfig.MediaPublishConfig = (function() {

        function MediaPublishConfig(properties) {
            this.resource_info = [];
            this.push_config = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        MediaPublishConfig.prototype.push_type = null;
        MediaPublishConfig.prototype.resource_info = $util.emptyArray;
        MediaPublishConfig.prototype.push_config = $util.emptyArray;

        let $oneOfFields;

        Object.defineProperty(MediaPublishConfig.prototype, "_push_type", {
            get: $util.oneOfGetter($oneOfFields = ["push_type"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        MediaPublishConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.push_type != null && Object.hasOwnProperty.call(message, "push_type"))
                writer.uint32(8).int32(message.push_type);
            if (message.resource_info != null && message.resource_info.length)
                for (let i = 0; i < message.resource_info.length; ++i)
                    $root.proto_initconfig.MediaResourceInfo.encode(message.resource_info[i], writer.uint32(18).fork()).ldelim();
            if (message.push_config != null && message.push_config.length)
                for (let i = 0; i < message.push_config.length; ++i)
                    $root.proto_initconfig.PushConfig.encode(message.push_config[i], writer.uint32(26).fork()).ldelim();
            return writer;
        };

        MediaPublishConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.MediaPublishConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.push_type = reader.int32();
                    break;
                case 2:
                    if (!(message.resource_info && message.resource_info.length))
                        message.resource_info = [];
                    message.resource_info.push($root.proto_initconfig.MediaResourceInfo.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.push_config && message.push_config.length))
                        message.push_config = [];
                    message.push_config.push($root.proto_initconfig.PushConfig.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MediaPublishConfig;
    })();

    proto_initconfig.TranscodingConfig = (function() {

        function TranscodingConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        TranscodingConfig.prototype.video_codec_h264 = null;

        let $oneOfFields;

        Object.defineProperty(TranscodingConfig.prototype, "_video_codec_h264", {
            get: $util.oneOfGetter($oneOfFields = ["video_codec_h264"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        TranscodingConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.video_codec_h264 != null && Object.hasOwnProperty.call(message, "video_codec_h264"))
                writer.uint32(10).string(message.video_codec_h264);
            return writer;
        };

        TranscodingConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.TranscodingConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.video_codec_h264 = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return TranscodingConfig;
    })();

    proto_initconfig.MediaPlayConfig = (function() {

        function MediaPlayConfig(properties) {
            this.resource_order = [];
            this.resource_info = [];
            this.play_order_protocol_type = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        MediaPlayConfig.prototype.pull_type = null;
        MediaPlayConfig.prototype.l3_play_buffer_ms = null;
        MediaPlayConfig.prototype.allow_playing_specific_url = null;
        MediaPlayConfig.prototype.resource_order = $util.emptyArray;
        MediaPlayConfig.prototype.resource_info = $util.emptyArray;
        MediaPlayConfig.prototype.play_order_protocol_type = $util.emptyArray;
        MediaPlayConfig.prototype.jitter_buffer_flag = null;
        MediaPlayConfig.prototype.min_jitter_buffer = null;
        MediaPlayConfig.prototype.max_jitter_buffer = null;
        MediaPlayConfig.prototype.supplement_frame_control = null;
        MediaPlayConfig.prototype.open_l3_play_resource_prefer = null;
        MediaPlayConfig.prototype.switch_to_l3_after_online = null;
        MediaPlayConfig.prototype.transcoding = null;

        let $oneOfFields;

        Object.defineProperty(MediaPlayConfig.prototype, "_pull_type", {
            get: $util.oneOfGetter($oneOfFields = ["pull_type"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaPlayConfig.prototype, "_l3_play_buffer_ms", {
            get: $util.oneOfGetter($oneOfFields = ["l3_play_buffer_ms"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaPlayConfig.prototype, "_allow_playing_specific_url", {
            get: $util.oneOfGetter($oneOfFields = ["allow_playing_specific_url"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaPlayConfig.prototype, "_jitter_buffer_flag", {
            get: $util.oneOfGetter($oneOfFields = ["jitter_buffer_flag"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaPlayConfig.prototype, "_min_jitter_buffer", {
            get: $util.oneOfGetter($oneOfFields = ["min_jitter_buffer"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaPlayConfig.prototype, "_max_jitter_buffer", {
            get: $util.oneOfGetter($oneOfFields = ["max_jitter_buffer"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaPlayConfig.prototype, "_supplement_frame_control", {
            get: $util.oneOfGetter($oneOfFields = ["supplement_frame_control"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaPlayConfig.prototype, "_open_l3_play_resource_prefer", {
            get: $util.oneOfGetter($oneOfFields = ["open_l3_play_resource_prefer"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaPlayConfig.prototype, "_switch_to_l3_after_online", {
            get: $util.oneOfGetter($oneOfFields = ["switch_to_l3_after_online"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaPlayConfig.prototype, "_transcoding", {
            get: $util.oneOfGetter($oneOfFields = ["transcoding"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        MediaPlayConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pull_type != null && Object.hasOwnProperty.call(message, "pull_type"))
                writer.uint32(8).int32(message.pull_type);
            if (message.l3_play_buffer_ms != null && Object.hasOwnProperty.call(message, "l3_play_buffer_ms"))
                writer.uint32(16).int32(message.l3_play_buffer_ms);
            if (message.allow_playing_specific_url != null && Object.hasOwnProperty.call(message, "allow_playing_specific_url"))
                writer.uint32(24).int32(message.allow_playing_specific_url);
            if (message.resource_order != null && message.resource_order.length) {
                writer.uint32(34).fork();
                for (let i = 0; i < message.resource_order.length; ++i)
                    writer.int32(message.resource_order[i]);
                writer.ldelim();
            }
            if (message.resource_info != null && message.resource_info.length)
                for (let i = 0; i < message.resource_info.length; ++i)
                    $root.proto_initconfig.MediaResourceInfo.encode(message.resource_info[i], writer.uint32(42).fork()).ldelim();
            if (message.play_order_protocol_type != null && message.play_order_protocol_type.length) {
                writer.uint32(50).fork();
                for (let i = 0; i < message.play_order_protocol_type.length; ++i)
                    writer.int32(message.play_order_protocol_type[i]);
                writer.ldelim();
            }
            if (message.jitter_buffer_flag != null && Object.hasOwnProperty.call(message, "jitter_buffer_flag"))
                writer.uint32(80).int32(message.jitter_buffer_flag);
            if (message.min_jitter_buffer != null && Object.hasOwnProperty.call(message, "min_jitter_buffer"))
                writer.uint32(88).int32(message.min_jitter_buffer);
            if (message.max_jitter_buffer != null && Object.hasOwnProperty.call(message, "max_jitter_buffer"))
                writer.uint32(96).int32(message.max_jitter_buffer);
            if (message.supplement_frame_control != null && Object.hasOwnProperty.call(message, "supplement_frame_control"))
                $root.proto_initconfig.SupplementFrameControl.encode(message.supplement_frame_control, writer.uint32(106).fork()).ldelim();
            if (message.open_l3_play_resource_prefer != null && Object.hasOwnProperty.call(message, "open_l3_play_resource_prefer"))
                writer.uint32(112).int32(message.open_l3_play_resource_prefer);
            if (message.switch_to_l3_after_online != null && Object.hasOwnProperty.call(message, "switch_to_l3_after_online"))
                writer.uint32(120).int32(message.switch_to_l3_after_online);
            if (message.transcoding != null && Object.hasOwnProperty.call(message, "transcoding"))
                $root.proto_initconfig.TranscodingConfig.encode(message.transcoding, writer.uint32(130).fork()).ldelim();
            return writer;
        };

        MediaPlayConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.MediaPlayConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pull_type = reader.int32();
                    break;
                case 2:
                    message.l3_play_buffer_ms = reader.int32();
                    break;
                case 3:
                    message.allow_playing_specific_url = reader.int32();
                    break;
                case 4:
                    if (!(message.resource_order && message.resource_order.length))
                        message.resource_order = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.resource_order.push(reader.int32());
                    } else
                        message.resource_order.push(reader.int32());
                    break;
                case 5:
                    if (!(message.resource_info && message.resource_info.length))
                        message.resource_info = [];
                    message.resource_info.push($root.proto_initconfig.MediaResourceInfo.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.play_order_protocol_type && message.play_order_protocol_type.length))
                        message.play_order_protocol_type = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.play_order_protocol_type.push(reader.int32());
                    } else
                        message.play_order_protocol_type.push(reader.int32());
                    break;
                case 10:
                    message.jitter_buffer_flag = reader.int32();
                    break;
                case 11:
                    message.min_jitter_buffer = reader.int32();
                    break;
                case 12:
                    message.max_jitter_buffer = reader.int32();
                    break;
                case 13:
                    message.supplement_frame_control = $root.proto_initconfig.SupplementFrameControl.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.open_l3_play_resource_prefer = reader.int32();
                    break;
                case 15:
                    message.switch_to_l3_after_online = reader.int32();
                    break;
                case 16:
                    message.transcoding = $root.proto_initconfig.TranscodingConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MediaPlayConfig;
    })();

    proto_initconfig.MediaDispatchProtocolInfo = (function() {

        function MediaDispatchProtocolInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        MediaDispatchProtocolInfo.prototype.protocol = null;
        MediaDispatchProtocolInfo.prototype.url_template = null;
        MediaDispatchProtocolInfo.prototype.reusable = null;

        let $oneOfFields;

        Object.defineProperty(MediaDispatchProtocolInfo.prototype, "_protocol", {
            get: $util.oneOfGetter($oneOfFields = ["protocol"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaDispatchProtocolInfo.prototype, "_url_template", {
            get: $util.oneOfGetter($oneOfFields = ["url_template"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaDispatchProtocolInfo.prototype, "_reusable", {
            get: $util.oneOfGetter($oneOfFields = ["reusable"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        MediaDispatchProtocolInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.protocol != null && Object.hasOwnProperty.call(message, "protocol"))
                writer.uint32(8).int32(message.protocol);
            if (message.url_template != null && Object.hasOwnProperty.call(message, "url_template"))
                writer.uint32(18).string(message.url_template);
            if (message.reusable != null && Object.hasOwnProperty.call(message, "reusable"))
                writer.uint32(24).int32(message.reusable);
            return writer;
        };

        MediaDispatchProtocolInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.MediaDispatchProtocolInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.protocol = reader.int32();
                    break;
                case 2:
                    message.url_template = reader.string();
                    break;
                case 3:
                    message.reusable = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MediaDispatchProtocolInfo;
    })();

    proto_initconfig.MediaDispatchResourceInfo = (function() {

        function MediaDispatchResourceInfo(properties) {
            this.dispatch_protocol_info = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        MediaDispatchResourceInfo.prototype.resource_type = null;
        MediaDispatchResourceInfo.prototype.dispatch_protocol_info = $util.emptyArray;

        let $oneOfFields;

        Object.defineProperty(MediaDispatchResourceInfo.prototype, "_resource_type", {
            get: $util.oneOfGetter($oneOfFields = ["resource_type"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        MediaDispatchResourceInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resource_type != null && Object.hasOwnProperty.call(message, "resource_type"))
                writer.uint32(8).int32(message.resource_type);
            if (message.dispatch_protocol_info != null && message.dispatch_protocol_info.length)
                for (let i = 0; i < message.dispatch_protocol_info.length; ++i)
                    $root.proto_initconfig.MediaDispatchProtocolInfo.encode(message.dispatch_protocol_info[i], writer.uint32(18).fork()).ldelim();
            return writer;
        };

        MediaDispatchResourceInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.MediaDispatchResourceInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resource_type = reader.int32();
                    break;
                case 2:
                    if (!(message.dispatch_protocol_info && message.dispatch_protocol_info.length))
                        message.dispatch_protocol_info = [];
                    message.dispatch_protocol_info.push($root.proto_initconfig.MediaDispatchProtocolInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MediaDispatchResourceInfo;
    })();

    proto_initconfig.MediaDispatchConfig = (function() {

        function MediaDispatchConfig(properties) {
            this.dispatch_resource_info = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        MediaDispatchConfig.prototype.dispatch_resource_info = $util.emptyArray;

        MediaDispatchConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dispatch_resource_info != null && message.dispatch_resource_info.length)
                for (let i = 0; i < message.dispatch_resource_info.length; ++i)
                    $root.proto_initconfig.MediaDispatchResourceInfo.encode(message.dispatch_resource_info[i], writer.uint32(10).fork()).ldelim();
            return writer;
        };

        MediaDispatchConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.MediaDispatchConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.dispatch_resource_info && message.dispatch_resource_info.length))
                        message.dispatch_resource_info = [];
                    message.dispatch_resource_info.push($root.proto_initconfig.MediaDispatchResourceInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MediaDispatchConfig;
    })();

    proto_initconfig.MediaServiceUrlList = (function() {

        function MediaServiceUrlList(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        MediaServiceUrlList.prototype.base_url = null;
        MediaServiceUrlList.prototype.push_status_url = null;

        let $oneOfFields;

        Object.defineProperty(MediaServiceUrlList.prototype, "_base_url", {
            get: $util.oneOfGetter($oneOfFields = ["base_url"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaServiceUrlList.prototype, "_push_status_url", {
            get: $util.oneOfGetter($oneOfFields = ["push_status_url"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        MediaServiceUrlList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.base_url != null && Object.hasOwnProperty.call(message, "base_url"))
                writer.uint32(10).string(message.base_url);
            if (message.push_status_url != null && Object.hasOwnProperty.call(message, "push_status_url"))
                writer.uint32(18).string(message.push_status_url);
            return writer;
        };

        MediaServiceUrlList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.MediaServiceUrlList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.base_url = reader.string();
                    break;
                case 2:
                    message.push_status_url = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MediaServiceUrlList;
    })();

    proto_initconfig.ZeusMediaConfig = (function() {

        function ZeusMediaConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        ZeusMediaConfig.prototype.push_dispatch_type = null;
        ZeusMediaConfig.prototype.pull_dispatch_type = null;
        ZeusMediaConfig.prototype.open_auth = null;
        ZeusMediaConfig.prototype.send_anchor_login_after_push_cdn = null;

        let $oneOfFields;

        Object.defineProperty(ZeusMediaConfig.prototype, "_push_dispatch_type", {
            get: $util.oneOfGetter($oneOfFields = ["push_dispatch_type"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(ZeusMediaConfig.prototype, "_pull_dispatch_type", {
            get: $util.oneOfGetter($oneOfFields = ["pull_dispatch_type"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(ZeusMediaConfig.prototype, "_open_auth", {
            get: $util.oneOfGetter($oneOfFields = ["open_auth"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(ZeusMediaConfig.prototype, "_send_anchor_login_after_push_cdn", {
            get: $util.oneOfGetter($oneOfFields = ["send_anchor_login_after_push_cdn"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        ZeusMediaConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.push_dispatch_type != null && Object.hasOwnProperty.call(message, "push_dispatch_type"))
                writer.uint32(8).int32(message.push_dispatch_type);
            if (message.pull_dispatch_type != null && Object.hasOwnProperty.call(message, "pull_dispatch_type"))
                writer.uint32(16).int32(message.pull_dispatch_type);
            if (message.open_auth != null && Object.hasOwnProperty.call(message, "open_auth"))
                writer.uint32(24).int32(message.open_auth);
            if (message.send_anchor_login_after_push_cdn != null && Object.hasOwnProperty.call(message, "send_anchor_login_after_push_cdn"))
                writer.uint32(32).int32(message.send_anchor_login_after_push_cdn);
            return writer;
        };

        ZeusMediaConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.ZeusMediaConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.push_dispatch_type = reader.int32();
                    break;
                case 2:
                    message.pull_dispatch_type = reader.int32();
                    break;
                case 3:
                    message.open_auth = reader.int32();
                    break;
                case 4:
                    message.send_anchor_login_after_push_cdn = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ZeusMediaConfig;
    })();

    proto_initconfig.MediaConfig = (function() {

        function MediaConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        MediaConfig.prototype.play_config = null;
        MediaConfig.prototype.publish_config = null;
        MediaConfig.prototype.dispatch_config = null;
        MediaConfig.prototype.service_url_list = null;
        MediaConfig.prototype.zeus_config = null;

        let $oneOfFields;

        Object.defineProperty(MediaConfig.prototype, "_play_config", {
            get: $util.oneOfGetter($oneOfFields = ["play_config"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaConfig.prototype, "_publish_config", {
            get: $util.oneOfGetter($oneOfFields = ["publish_config"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaConfig.prototype, "_dispatch_config", {
            get: $util.oneOfGetter($oneOfFields = ["dispatch_config"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaConfig.prototype, "_service_url_list", {
            get: $util.oneOfGetter($oneOfFields = ["service_url_list"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaConfig.prototype, "_zeus_config", {
            get: $util.oneOfGetter($oneOfFields = ["zeus_config"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        MediaConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.play_config != null && Object.hasOwnProperty.call(message, "play_config"))
                $root.proto_initconfig.MediaPlayConfig.encode(message.play_config, writer.uint32(10).fork()).ldelim();
            if (message.publish_config != null && Object.hasOwnProperty.call(message, "publish_config"))
                $root.proto_initconfig.MediaPublishConfig.encode(message.publish_config, writer.uint32(18).fork()).ldelim();
            if (message.dispatch_config != null && Object.hasOwnProperty.call(message, "dispatch_config"))
                $root.proto_initconfig.MediaDispatchConfig.encode(message.dispatch_config, writer.uint32(26).fork()).ldelim();
            if (message.service_url_list != null && Object.hasOwnProperty.call(message, "service_url_list"))
                $root.proto_initconfig.MediaServiceUrlList.encode(message.service_url_list, writer.uint32(34).fork()).ldelim();
            if (message.zeus_config != null && Object.hasOwnProperty.call(message, "zeus_config"))
                $root.proto_initconfig.ZeusMediaConfig.encode(message.zeus_config, writer.uint32(42).fork()).ldelim();
            return writer;
        };

        MediaConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.MediaConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.play_config = $root.proto_initconfig.MediaPlayConfig.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.publish_config = $root.proto_initconfig.MediaPublishConfig.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.dispatch_config = $root.proto_initconfig.MediaDispatchConfig.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.service_url_list = $root.proto_initconfig.MediaServiceUrlList.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.zeus_config = $root.proto_initconfig.ZeusMediaConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MediaConfig;
    })();

    proto_initconfig.InitConfig = (function() {

        function InitConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        InitConfig.prototype.app_config = null;
        InitConfig.prototype.room_config = null;
        InitConfig.prototype.ve_config = null;
        InitConfig.prototype.speedlog_config = null;
        InitConfig.prototype.media_config = null;
        InitConfig.prototype.proto_version = null;

        let $oneOfFields;

        Object.defineProperty(InitConfig.prototype, "_app_config", {
            get: $util.oneOfGetter($oneOfFields = ["app_config"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(InitConfig.prototype, "_room_config", {
            get: $util.oneOfGetter($oneOfFields = ["room_config"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(InitConfig.prototype, "_ve_config", {
            get: $util.oneOfGetter($oneOfFields = ["ve_config"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(InitConfig.prototype, "_speedlog_config", {
            get: $util.oneOfGetter($oneOfFields = ["speedlog_config"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(InitConfig.prototype, "_media_config", {
            get: $util.oneOfGetter($oneOfFields = ["media_config"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(InitConfig.prototype, "_proto_version", {
            get: $util.oneOfGetter($oneOfFields = ["proto_version"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        InitConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.app_config != null && Object.hasOwnProperty.call(message, "app_config"))
                $root.proto_initconfig.AppConfig.encode(message.app_config, writer.uint32(10).fork()).ldelim();
            if (message.room_config != null && Object.hasOwnProperty.call(message, "room_config"))
                $root.proto_initconfig.RoomConfig.encode(message.room_config, writer.uint32(18).fork()).ldelim();
            if (message.ve_config != null && Object.hasOwnProperty.call(message, "ve_config"))
                $root.proto_initconfig.VEConfig.encode(message.ve_config, writer.uint32(26).fork()).ldelim();
            if (message.speedlog_config != null && Object.hasOwnProperty.call(message, "speedlog_config"))
                $root.proto_initconfig.SpeedlogConfig.encode(message.speedlog_config, writer.uint32(34).fork()).ldelim();
            if (message.media_config != null && Object.hasOwnProperty.call(message, "media_config"))
                $root.proto_initconfig.MediaConfig.encode(message.media_config, writer.uint32(42).fork()).ldelim();
            if (message.proto_version != null && Object.hasOwnProperty.call(message, "proto_version"))
                writer.uint32(48).int32(message.proto_version);
            return writer;
        };

        InitConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.InitConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.app_config = $root.proto_initconfig.AppConfig.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.room_config = $root.proto_initconfig.RoomConfig.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.ve_config = $root.proto_initconfig.VEConfig.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.speedlog_config = $root.proto_initconfig.SpeedlogConfig.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.media_config = $root.proto_initconfig.MediaConfig.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.proto_version = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return InitConfig;
    })();

    return proto_initconfig;
})();




/***/ }),

/***/ "./sdk/src/modules/proto/liveroom.js":
/*!*******************************************!*\
  !*** ./sdk/src/modules/proto/liveroom.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_798406__) {

"use strict";
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/


var $protobuf = __nested_webpack_require_798406__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.proto_switch = (function() {

    /**
     * Namespace proto_switch.
     * @exports proto_switch
     * @namespace
     */
    var proto_switch = {};

    proto_switch.CommonRsp = (function() {

        /**
         * Properties of a CommonRsp.
         * @memberof proto_switch
         * @interface ICommonRsp
         * @property {proto_switch.IRspHead|null} [rsp_head] CommonRsp rsp_head
         */

        /**
         * Constructs a new CommonRsp.
         * @memberof proto_switch
         * @classdesc Represents a CommonRsp.
         * @implements ICommonRsp
         * @constructor
         * @param {proto_switch.ICommonRsp=} [properties] Properties to set
         */
        function CommonRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommonRsp rsp_head.
         * @member {proto_switch.IRspHead|null|undefined} rsp_head
         * @memberof proto_switch.CommonRsp
         * @instance
         */
        CommonRsp.prototype.rsp_head = null;

        /**
         * Creates a new CommonRsp instance using the specified properties.
         * @function create
         * @memberof proto_switch.CommonRsp
         * @static
         * @param {proto_switch.ICommonRsp=} [properties] Properties to set
         * @returns {proto_switch.CommonRsp} CommonRsp instance
         */
        CommonRsp.create = function create(properties) {
            return new CommonRsp(properties);
        };

        /**
         * Encodes the specified CommonRsp message. Does not implicitly {@link proto_switch.CommonRsp.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.CommonRsp
         * @static
         * @param {proto_switch.ICommonRsp} message CommonRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.proto_switch.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a CommonRsp message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.CommonRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.CommonRsp} CommonRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.CommonRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.proto_switch.RspHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return CommonRsp;
    })();

    proto_switch.RspHead = (function() {

        /**
         * Properties of a RspHead.
         * @memberof proto_switch
         * @interface IRspHead
         * @property {number|null} [code] RspHead code
         * @property {string|null} [message] RspHead message
         */

        /**
         * Constructs a new RspHead.
         * @memberof proto_switch
         * @classdesc -title:业务协议应答包头
         * 如liveroom
         * @implements IRspHead
         * @constructor
         * @param {proto_switch.IRspHead=} [properties] Properties to set
         */
        function RspHead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RspHead code.
         * @member {number} code
         * @memberof proto_switch.RspHead
         * @instance
         */
        RspHead.prototype.code = 0;

        /**
         * RspHead message.
         * @member {string} message
         * @memberof proto_switch.RspHead
         * @instance
         */
        RspHead.prototype.message = "";

        /**
         * Creates a new RspHead instance using the specified properties.
         * @function create
         * @memberof proto_switch.RspHead
         * @static
         * @param {proto_switch.IRspHead=} [properties] Properties to set
         * @returns {proto_switch.RspHead} RspHead instance
         */
        RspHead.create = function create(properties) {
            return new RspHead(properties);
        };

        /**
         * Encodes the specified RspHead message. Does not implicitly {@link proto_switch.RspHead.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.RspHead
         * @static
         * @param {proto_switch.IRspHead} message RspHead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RspHead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.code);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            return writer;
        };

        /**
         * Decodes a RspHead message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.RspHead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.RspHead} RspHead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RspHead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.RspHead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.uint32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RspHead;
    })();

    proto_switch.LoginRoomReq = (function() {

        /**
         * Properties of a LoginRoomReq.
         * @memberof proto_switch
         * @interface ILoginRoomReq
         * @property {number|null} [app_id] LoginRoomReq app_id
         * @property {Uint8Array|null} [id_name] LoginRoomReq id_name
         * @property {string|null} [device_id] LoginRoomReq device_id
         * @property {proto_switch.TermType|null} [term_type] LoginRoomReq term_type
         * @property {proto_switch.NetType|null} [net_type] LoginRoomReq net_type
         * @property {number|null} [sdk_ver] LoginRoomReq sdk_ver
         * @property {proto_switch.LiveroomProtoVersion|null} [proto_ver] LoginRoomReq proto_ver
         * @property {Uint8Array|null} [nick_name] LoginRoomReq nick_name
         * @property {Uint8Array|null} [client_stamp] LoginRoomReq client_stamp
         * @property {number|null} [crypt_version] LoginRoomReq crypt_version
         * @property {Uint8Array|null} [k1_sign] LoginRoomReq k1_sign
         * @property {Uint8Array|null} [login_token] LoginRoomReq login_token
         * @property {Uint8Array|null} [relogin_token] LoginRoomReq relogin_token
         * @property {number|null} [role] LoginRoomReq role
         * @property {number|Long|null} [liveroom_session_id] LoginRoomReq liveroom_session_id
         * @property {Uint8Array|null} [room_id] LoginRoomReq room_id
         * @property {Uint8Array|null} [room_name] LoginRoomReq room_name
         * @property {number|null} [biz_type] LoginRoomReq biz_type
         * @property {number|null} [room_create_flag] LoginRoomReq room_create_flag
         * @property {number|null} [user_state_flag] LoginRoomReq user_state_flag
         * @property {string|null} [lv_key] LoginRoomReq lv_key
         * @property {Uint8Array|null} [third_token] LoginRoomReq third_token
         * @property {number|null} [cluster_req] LoginRoomReq cluster_req
         * @property {number|null} [user_count_limit] LoginRoomReq user_count_limit
         * @property {string|null} [relate_service] LoginRoomReq relate_service
         * @property {string|null} [biz_version] LoginRoomReq biz_version
         * @property {number|null} [login_logic] LoginRoomReq login_logic
         * @property {proto_switch.SdkConnType|null} [sdk_conn_type] sdk连接类型, 区分native sdk和web sdk; 0和1: native sdk; 2: web sdk
         */

        /**
         * Constructs a new LoginRoomReq.
         * @memberof proto_switch
         * @classdesc Represents a LoginRoomReq.
         * @implements ILoginRoomReq
         * @constructor
         * @param {proto_switch.ILoginRoomReq=} [properties] Properties to set
         */
        function LoginRoomReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginRoomReq app_id.
         * @member {number} app_id
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.app_id = 0;

        /**
         * LoginRoomReq id_name.
         * @member {Uint8Array} id_name
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.id_name = $util.newBuffer([]);

        /**
         * LoginRoomReq device_id.
         * @member {string} device_id
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.device_id = "";

        /**
         * LoginRoomReq term_type.
         * @member {proto_switch.TermType} term_type
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.term_type = 0;

        /**
         * LoginRoomReq net_type.
         * @member {proto_switch.NetType} net_type
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.net_type = 0;

        /**
         * LoginRoomReq sdk_ver.
         * @member {number} sdk_ver
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.sdk_ver = 0;

        /**
         * LoginRoomReq proto_ver.
         * @member {proto_switch.LiveroomProtoVersion} proto_ver
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.proto_ver = 0;

        /**
         * LoginRoomReq nick_name.
         * @member {Uint8Array} nick_name
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.nick_name = $util.newBuffer([]);

        /**
         * LoginRoomReq client_stamp.
         * @member {Uint8Array} client_stamp
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.client_stamp = $util.newBuffer([]);

        /**
         * LoginRoomReq crypt_version.
         * @member {number} crypt_version
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.crypt_version = 0;

        /**
         * LoginRoomReq k1_sign.
         * @member {Uint8Array} k1_sign
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.k1_sign = $util.newBuffer([]);

        /**
         * LoginRoomReq login_token.
         * @member {Uint8Array} login_token
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.login_token = $util.newBuffer([]);

        /**
         * LoginRoomReq relogin_token.
         * @member {Uint8Array} relogin_token
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.relogin_token = $util.newBuffer([]);

        /**
         * LoginRoomReq role.
         * @member {number} role
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.role = 0;

        /**
         * LoginRoomReq liveroom_session_id.
         * @member {number|Long} liveroom_session_id
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.liveroom_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * LoginRoomReq room_id.
         * @member {Uint8Array} room_id
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.room_id = $util.newBuffer([]);

        /**
         * LoginRoomReq room_name.
         * @member {Uint8Array} room_name
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.room_name = $util.newBuffer([]);

        /**
         * LoginRoomReq biz_type.
         * @member {number} biz_type
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.biz_type = 0;

        /**
         * LoginRoomReq room_create_flag.
         * @member {number} room_create_flag
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.room_create_flag = 0;

        /**
         * LoginRoomReq user_state_flag.
         * @member {number} user_state_flag
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.user_state_flag = 0;

        /**
         * LoginRoomReq lv_key.
         * @member {string} lv_key
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.lv_key = "";

        /**
         * LoginRoomReq third_token.
         * @member {Uint8Array} third_token
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.third_token = $util.newBuffer([]);

        /**
         * LoginRoomReq cluster_req.
         * @member {number} cluster_req
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.cluster_req = 0;

        /**
         * LoginRoomReq user_count_limit.
         * @member {number} user_count_limit
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.user_count_limit = 0;

        /**
         * LoginRoomReq relate_service.
         * @member {string} relate_service
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.relate_service = "";

        /**
         * LoginRoomReq biz_version.
         * @member {string} biz_version
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.biz_version = "";

        /**
         * LoginRoomReq login_logic.
         * @member {number} login_logic
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.login_logic = 0;

        /**
         * sdk连接类型, 区分native sdk和web sdk; 0和1: native sdk; 2: web sdk
         * @member {proto_switch.SdkConnType} sdk_conn_type
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.sdk_conn_type = 0;

        /**
         * Creates a new LoginRoomReq instance using the specified properties.
         * @function create
         * @memberof proto_switch.LoginRoomReq
         * @static
         * @param {proto_switch.ILoginRoomReq=} [properties] Properties to set
         * @returns {proto_switch.LoginRoomReq} LoginRoomReq instance
         */
        LoginRoomReq.create = function create(properties) {
            return new LoginRoomReq(properties);
        };

        /**
         * Encodes the specified LoginRoomReq message. Does not implicitly {@link proto_switch.LoginRoomReq.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.LoginRoomReq
         * @static
         * @param {proto_switch.ILoginRoomReq} message LoginRoomReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginRoomReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.app_id != null && Object.hasOwnProperty.call(message, "app_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.app_id);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.id_name);
            if (message.device_id != null && Object.hasOwnProperty.call(message, "device_id"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.device_id);
            if (message.term_type != null && Object.hasOwnProperty.call(message, "term_type"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.term_type);
            if (message.net_type != null && Object.hasOwnProperty.call(message, "net_type"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.net_type);
            if (message.sdk_ver != null && Object.hasOwnProperty.call(message, "sdk_ver"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.sdk_ver);
            if (message.proto_ver != null && Object.hasOwnProperty.call(message, "proto_ver"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.proto_ver);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.nick_name);
            if (message.client_stamp != null && Object.hasOwnProperty.call(message, "client_stamp"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.client_stamp);
            if (message.crypt_version != null && Object.hasOwnProperty.call(message, "crypt_version"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.crypt_version);
            if (message.k1_sign != null && Object.hasOwnProperty.call(message, "k1_sign"))
                writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.k1_sign);
            if (message.login_token != null && Object.hasOwnProperty.call(message, "login_token"))
                writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.login_token);
            if (message.relogin_token != null && Object.hasOwnProperty.call(message, "relogin_token"))
                writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.relogin_token);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.role);
            if (message.liveroom_session_id != null && Object.hasOwnProperty.call(message, "liveroom_session_id"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint64(message.liveroom_session_id);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.room_id);
            if (message.room_name != null && Object.hasOwnProperty.call(message, "room_name"))
                writer.uint32(/* id 17, wireType 2 =*/138).bytes(message.room_name);
            if (message.biz_type != null && Object.hasOwnProperty.call(message, "biz_type"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.biz_type);
            if (message.room_create_flag != null && Object.hasOwnProperty.call(message, "room_create_flag"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.room_create_flag);
            if (message.user_state_flag != null && Object.hasOwnProperty.call(message, "user_state_flag"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.user_state_flag);
            if (message.lv_key != null && Object.hasOwnProperty.call(message, "lv_key"))
                writer.uint32(/* id 21, wireType 2 =*/170).string(message.lv_key);
            if (message.third_token != null && Object.hasOwnProperty.call(message, "third_token"))
                writer.uint32(/* id 22, wireType 2 =*/178).bytes(message.third_token);
            if (message.cluster_req != null && Object.hasOwnProperty.call(message, "cluster_req"))
                writer.uint32(/* id 23, wireType 0 =*/184).uint32(message.cluster_req);
            if (message.user_count_limit != null && Object.hasOwnProperty.call(message, "user_count_limit"))
                writer.uint32(/* id 24, wireType 0 =*/192).uint32(message.user_count_limit);
            if (message.relate_service != null && Object.hasOwnProperty.call(message, "relate_service"))
                writer.uint32(/* id 25, wireType 2 =*/202).string(message.relate_service);
            if (message.biz_version != null && Object.hasOwnProperty.call(message, "biz_version"))
                writer.uint32(/* id 26, wireType 2 =*/210).string(message.biz_version);
            if (message.login_logic != null && Object.hasOwnProperty.call(message, "login_logic"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint32(message.login_logic);
            if (message.sdk_conn_type != null && Object.hasOwnProperty.call(message, "sdk_conn_type"))
                writer.uint32(/* id 28, wireType 0 =*/224).int32(message.sdk_conn_type);
            return writer;
        };

        /**
         * Decodes a LoginRoomReq message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.LoginRoomReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.LoginRoomReq} LoginRoomReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginRoomReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.LoginRoomReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.app_id = reader.uint32();
                    break;
                case 2:
                    message.id_name = reader.bytes();
                    break;
                case 3:
                    message.device_id = reader.string();
                    break;
                case 4:
                    message.term_type = reader.int32();
                    break;
                case 5:
                    message.net_type = reader.int32();
                    break;
                case 6:
                    message.sdk_ver = reader.uint32();
                    break;
                case 7:
                    message.proto_ver = reader.int32();
                    break;
                case 8:
                    message.nick_name = reader.bytes();
                    break;
                case 9:
                    message.client_stamp = reader.bytes();
                    break;
                case 10:
                    message.crypt_version = reader.uint32();
                    break;
                case 11:
                    message.k1_sign = reader.bytes();
                    break;
                case 12:
                    message.login_token = reader.bytes();
                    break;
                case 13:
                    message.relogin_token = reader.bytes();
                    break;
                case 14:
                    message.role = reader.uint32();
                    break;
                case 15:
                    message.liveroom_session_id = reader.uint64();
                    break;
                case 16:
                    message.room_id = reader.bytes();
                    break;
                case 17:
                    message.room_name = reader.bytes();
                    break;
                case 18:
                    message.biz_type = reader.uint32();
                    break;
                case 19:
                    message.room_create_flag = reader.uint32();
                    break;
                case 20:
                    message.user_state_flag = reader.uint32();
                    break;
                case 21:
                    message.lv_key = reader.string();
                    break;
                case 22:
                    message.third_token = reader.bytes();
                    break;
                case 23:
                    message.cluster_req = reader.uint32();
                    break;
                case 24:
                    message.user_count_limit = reader.uint32();
                    break;
                case 25:
                    message.relate_service = reader.string();
                    break;
                case 26:
                    message.biz_version = reader.string();
                    break;
                case 27:
                    message.login_logic = reader.uint32();
                    break;
                case 28:
                    message.sdk_conn_type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return LoginRoomReq;
    })();

    proto_switch.LoginRoomRsp = (function() {

        /**
         * Properties of a LoginRoomRsp.
         * @memberof proto_switch
         * @interface ILoginRoomRsp
         * @property {proto_switch.IRspHead|null} [rsp_head] LoginRoomRsp rsp_head
         * @property {Uint8Array|null} [room_id] LoginRoomRsp room_id
         * @property {number|null} [heartbeat_interval] LoginRoomRsp heartbeat_interval
         * @property {number|null} [heartbeat_timeout] LoginRoomRsp heartbeat_timeout
         * @property {number|Long|null} [ret_timestamp] LoginRoomRsp ret_timestamp
         * @property {number|null} [crypt_option] LoginRoomRsp crypt_option
         * @property {Uint8Array|null} [k2_sign] LoginRoomRsp k2_sign
         * @property {number|Long|null} [liveroom_session_id] LoginRoomRsp liveroom_session_id
         * @property {number|null} [liveroom_hb_interval] LoginRoomRsp liveroom_hb_interval
         * @property {number|null} [liveroom_hb_timeout] LoginRoomRsp liveroom_hb_timeout
         * @property {proto_switch.IStAnchorInfo|null} [anchor_info] LoginRoomRsp anchor_info
         * @property {number|null} [stream_seq] LoginRoomRsp stream_seq
         * @property {Array.<proto_switch.IStStreamInfo>|null} [stream_info] LoginRoomRsp stream_info
         * @property {number|null} [stream_fetch_flag] LoginRoomRsp stream_fetch_flag
         * @property {string|null} [lv_key] LoginRoomRsp lv_key
         * @property {string|null} [zp_key] LoginRoomRsp zp_key
         * @property {number|null} [online_count] LoginRoomRsp online_count
         * @property {number|null} [bigim_time_window] LoginRoomRsp bigim_time_window
         * @property {number|null} [dati_time_window] LoginRoomRsp dati_time_window
         * @property {string|null} [cluster_name] LoginRoomRsp cluster_name
         * @property {Uint8Array|null} [relogin_token] LoginRoomRsp relogin_token
         * @property {Array.<proto_switch.IStStreamInfo>|null} [stream_mix_info] LoginRoomRsp stream_mix_info
         * @property {number|null} [userlist_merge_timeout] LoginRoomRsp userlist_merge_timeout
         * @property {number|null} [userlist_interval] LoginRoomRsp userlist_interval
         * @property {number|Long|null} [room_session_id] LoginRoomRsp room_session_id
         * @property {Array.<proto_switch.IStTransInfo>|null} [trans_seqs] LoginRoomRsp trans_seqs
         * @property {number|null} [stream_list_push_merge_timeout] LoginRoomRsp stream_list_push_merge_timeout
         * @property {number|null} [stream_list_hb_wait_merge_time] LoginRoomRsp stream_list_hb_wait_merge_time
         * @property {number|null} [trans_list_seq] LoginRoomRsp trans_list_seq
         * @property {number|null} [token_remain_time] LoginRoomRsp token_remain_time
         */

        /**
         * Constructs a new LoginRoomRsp.
         * @memberof proto_switch
         * @classdesc Represents a LoginRoomRsp.
         * @implements ILoginRoomRsp
         * @constructor
         * @param {proto_switch.ILoginRoomRsp=} [properties] Properties to set
         */
        function LoginRoomRsp(properties) {
            this.stream_info = [];
            this.stream_mix_info = [];
            this.trans_seqs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginRoomRsp rsp_head.
         * @member {proto_switch.IRspHead|null|undefined} rsp_head
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.rsp_head = null;

        /**
         * LoginRoomRsp room_id.
         * @member {Uint8Array} room_id
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.room_id = $util.newBuffer([]);

        /**
         * LoginRoomRsp heartbeat_interval.
         * @member {number} heartbeat_interval
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.heartbeat_interval = 0;

        /**
         * LoginRoomRsp heartbeat_timeout.
         * @member {number} heartbeat_timeout
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.heartbeat_timeout = 0;

        /**
         * LoginRoomRsp ret_timestamp.
         * @member {number|Long} ret_timestamp
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.ret_timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LoginRoomRsp crypt_option.
         * @member {number} crypt_option
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.crypt_option = 0;

        /**
         * LoginRoomRsp k2_sign.
         * @member {Uint8Array} k2_sign
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.k2_sign = $util.newBuffer([]);

        /**
         * LoginRoomRsp liveroom_session_id.
         * @member {number|Long} liveroom_session_id
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.liveroom_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * LoginRoomRsp liveroom_hb_interval.
         * @member {number} liveroom_hb_interval
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.liveroom_hb_interval = 0;

        /**
         * LoginRoomRsp liveroom_hb_timeout.
         * @member {number} liveroom_hb_timeout
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.liveroom_hb_timeout = 0;

        /**
         * LoginRoomRsp anchor_info.
         * @member {proto_switch.IStAnchorInfo|null|undefined} anchor_info
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.anchor_info = null;

        /**
         * LoginRoomRsp stream_seq.
         * @member {number} stream_seq
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.stream_seq = 0;

        /**
         * LoginRoomRsp stream_info.
         * @member {Array.<proto_switch.IStStreamInfo>} stream_info
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.stream_info = $util.emptyArray;

        /**
         * LoginRoomRsp stream_fetch_flag.
         * @member {number} stream_fetch_flag
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.stream_fetch_flag = 0;

        /**
         * LoginRoomRsp lv_key.
         * @member {string} lv_key
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.lv_key = "";

        /**
         * LoginRoomRsp zp_key.
         * @member {string} zp_key
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.zp_key = "";

        /**
         * LoginRoomRsp online_count.
         * @member {number} online_count
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.online_count = 0;

        /**
         * LoginRoomRsp bigim_time_window.
         * @member {number} bigim_time_window
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.bigim_time_window = 0;

        /**
         * LoginRoomRsp dati_time_window.
         * @member {number} dati_time_window
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.dati_time_window = 0;

        /**
         * LoginRoomRsp cluster_name.
         * @member {string} cluster_name
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.cluster_name = "";

        /**
         * LoginRoomRsp relogin_token.
         * @member {Uint8Array} relogin_token
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.relogin_token = $util.newBuffer([]);

        /**
         * LoginRoomRsp stream_mix_info.
         * @member {Array.<proto_switch.IStStreamInfo>} stream_mix_info
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.stream_mix_info = $util.emptyArray;

        /**
         * LoginRoomRsp userlist_merge_timeout.
         * @member {number} userlist_merge_timeout
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.userlist_merge_timeout = 0;

        /**
         * LoginRoomRsp userlist_interval.
         * @member {number} userlist_interval
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.userlist_interval = 0;

        /**
         * LoginRoomRsp room_session_id.
         * @member {number|Long} room_session_id
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.room_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * LoginRoomRsp trans_seqs.
         * @member {Array.<proto_switch.IStTransInfo>} trans_seqs
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.trans_seqs = $util.emptyArray;

        /**
         * LoginRoomRsp stream_list_push_merge_timeout.
         * @member {number} stream_list_push_merge_timeout
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.stream_list_push_merge_timeout = 0;

        /**
         * LoginRoomRsp stream_list_hb_wait_merge_time.
         * @member {number} stream_list_hb_wait_merge_time
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.stream_list_hb_wait_merge_time = 0;

        /**
         * LoginRoomRsp trans_list_seq.
         * @member {number} trans_list_seq
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.trans_list_seq = 0;

        /**
         * LoginRoomRsp token_remain_time.
         * @member {number} token_remain_time
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.token_remain_time = 0;

        /**
         * Creates a new LoginRoomRsp instance using the specified properties.
         * @function create
         * @memberof proto_switch.LoginRoomRsp
         * @static
         * @param {proto_switch.ILoginRoomRsp=} [properties] Properties to set
         * @returns {proto_switch.LoginRoomRsp} LoginRoomRsp instance
         */
        LoginRoomRsp.create = function create(properties) {
            return new LoginRoomRsp(properties);
        };

        /**
         * Encodes the specified LoginRoomRsp message. Does not implicitly {@link proto_switch.LoginRoomRsp.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.LoginRoomRsp
         * @static
         * @param {proto_switch.ILoginRoomRsp} message LoginRoomRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginRoomRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.proto_switch.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.room_id);
            if (message.heartbeat_interval != null && Object.hasOwnProperty.call(message, "heartbeat_interval"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.heartbeat_interval);
            if (message.heartbeat_timeout != null && Object.hasOwnProperty.call(message, "heartbeat_timeout"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.heartbeat_timeout);
            if (message.ret_timestamp != null && Object.hasOwnProperty.call(message, "ret_timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.ret_timestamp);
            if (message.crypt_option != null && Object.hasOwnProperty.call(message, "crypt_option"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.crypt_option);
            if (message.k2_sign != null && Object.hasOwnProperty.call(message, "k2_sign"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.k2_sign);
            if (message.liveroom_session_id != null && Object.hasOwnProperty.call(message, "liveroom_session_id"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.liveroom_session_id);
            if (message.liveroom_hb_interval != null && Object.hasOwnProperty.call(message, "liveroom_hb_interval"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.liveroom_hb_interval);
            if (message.liveroom_hb_timeout != null && Object.hasOwnProperty.call(message, "liveroom_hb_timeout"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.liveroom_hb_timeout);
            if (message.anchor_info != null && Object.hasOwnProperty.call(message, "anchor_info"))
                $root.proto_switch.StAnchorInfo.encode(message.anchor_info, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.stream_seq != null && Object.hasOwnProperty.call(message, "stream_seq"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.stream_seq);
            if (message.stream_info != null && message.stream_info.length)
                for (var i = 0; i < message.stream_info.length; ++i)
                    $root.proto_switch.StStreamInfo.encode(message.stream_info[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.stream_fetch_flag != null && Object.hasOwnProperty.call(message, "stream_fetch_flag"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.stream_fetch_flag);
            if (message.lv_key != null && Object.hasOwnProperty.call(message, "lv_key"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.lv_key);
            if (message.zp_key != null && Object.hasOwnProperty.call(message, "zp_key"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.zp_key);
            if (message.online_count != null && Object.hasOwnProperty.call(message, "online_count"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint32(message.online_count);
            if (message.bigim_time_window != null && Object.hasOwnProperty.call(message, "bigim_time_window"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.bigim_time_window);
            if (message.dati_time_window != null && Object.hasOwnProperty.call(message, "dati_time_window"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.dati_time_window);
            if (message.cluster_name != null && Object.hasOwnProperty.call(message, "cluster_name"))
                writer.uint32(/* id 20, wireType 2 =*/162).string(message.cluster_name);
            if (message.relogin_token != null && Object.hasOwnProperty.call(message, "relogin_token"))
                writer.uint32(/* id 21, wireType 2 =*/170).bytes(message.relogin_token);
            if (message.stream_mix_info != null && message.stream_mix_info.length)
                for (var i = 0; i < message.stream_mix_info.length; ++i)
                    $root.proto_switch.StStreamInfo.encode(message.stream_mix_info[i], writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.userlist_merge_timeout != null && Object.hasOwnProperty.call(message, "userlist_merge_timeout"))
                writer.uint32(/* id 23, wireType 0 =*/184).uint32(message.userlist_merge_timeout);
            if (message.userlist_interval != null && Object.hasOwnProperty.call(message, "userlist_interval"))
                writer.uint32(/* id 24, wireType 0 =*/192).uint32(message.userlist_interval);
            if (message.room_session_id != null && Object.hasOwnProperty.call(message, "room_session_id"))
                writer.uint32(/* id 25, wireType 0 =*/200).uint64(message.room_session_id);
            if (message.trans_seqs != null && message.trans_seqs.length)
                for (var i = 0; i < message.trans_seqs.length; ++i)
                    $root.proto_switch.StTransInfo.encode(message.trans_seqs[i], writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
            if (message.stream_list_push_merge_timeout != null && Object.hasOwnProperty.call(message, "stream_list_push_merge_timeout"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint32(message.stream_list_push_merge_timeout);
            if (message.stream_list_hb_wait_merge_time != null && Object.hasOwnProperty.call(message, "stream_list_hb_wait_merge_time"))
                writer.uint32(/* id 28, wireType 0 =*/224).uint32(message.stream_list_hb_wait_merge_time);
            if (message.trans_list_seq != null && Object.hasOwnProperty.call(message, "trans_list_seq"))
                writer.uint32(/* id 29, wireType 0 =*/232).uint32(message.trans_list_seq);
            if (message.token_remain_time != null && Object.hasOwnProperty.call(message, "token_remain_time"))
                writer.uint32(/* id 30, wireType 0 =*/240).uint32(message.token_remain_time);
            return writer;
        };

        /**
         * Decodes a LoginRoomRsp message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.LoginRoomRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.LoginRoomRsp} LoginRoomRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginRoomRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.LoginRoomRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.proto_switch.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.room_id = reader.bytes();
                    break;
                case 3:
                    message.heartbeat_interval = reader.uint32();
                    break;
                case 4:
                    message.heartbeat_timeout = reader.uint32();
                    break;
                case 5:
                    message.ret_timestamp = reader.int64();
                    break;
                case 6:
                    message.crypt_option = reader.uint32();
                    break;
                case 7:
                    message.k2_sign = reader.bytes();
                    break;
                case 8:
                    message.liveroom_session_id = reader.uint64();
                    break;
                case 9:
                    message.liveroom_hb_interval = reader.uint32();
                    break;
                case 10:
                    message.liveroom_hb_timeout = reader.uint32();
                    break;
                case 11:
                    message.anchor_info = $root.proto_switch.StAnchorInfo.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.stream_seq = reader.uint32();
                    break;
                case 13:
                    if (!(message.stream_info && message.stream_info.length))
                        message.stream_info = [];
                    message.stream_info.push($root.proto_switch.StStreamInfo.decode(reader, reader.uint32()));
                    break;
                case 14:
                    message.stream_fetch_flag = reader.uint32();
                    break;
                case 15:
                    message.lv_key = reader.string();
                    break;
                case 16:
                    message.zp_key = reader.string();
                    break;
                case 17:
                    message.online_count = reader.uint32();
                    break;
                case 18:
                    message.bigim_time_window = reader.uint32();
                    break;
                case 19:
                    message.dati_time_window = reader.uint32();
                    break;
                case 20:
                    message.cluster_name = reader.string();
                    break;
                case 21:
                    message.relogin_token = reader.bytes();
                    break;
                case 22:
                    if (!(message.stream_mix_info && message.stream_mix_info.length))
                        message.stream_mix_info = [];
                    message.stream_mix_info.push($root.proto_switch.StStreamInfo.decode(reader, reader.uint32()));
                    break;
                case 23:
                    message.userlist_merge_timeout = reader.uint32();
                    break;
                case 24:
                    message.userlist_interval = reader.uint32();
                    break;
                case 25:
                    message.room_session_id = reader.uint64();
                    break;
                case 26:
                    if (!(message.trans_seqs && message.trans_seqs.length))
                        message.trans_seqs = [];
                    message.trans_seqs.push($root.proto_switch.StTransInfo.decode(reader, reader.uint32()));
                    break;
                case 27:
                    message.stream_list_push_merge_timeout = reader.uint32();
                    break;
                case 28:
                    message.stream_list_hb_wait_merge_time = reader.uint32();
                    break;
                case 29:
                    message.trans_list_seq = reader.uint32();
                    break;
                case 30:
                    message.token_remain_time = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return LoginRoomRsp;
    })();

    proto_switch.StAnchorInfo = (function() {

        /**
         * Properties of a StAnchorInfo.
         * @memberof proto_switch
         * @interface IStAnchorInfo
         * @property {Uint8Array|null} [anchor_id_name] StAnchorInfo anchor_id_name
         * @property {number|Long|null} [anchor_id] StAnchorInfo anchor_id
         * @property {Uint8Array|null} [anchor_nick_name] StAnchorInfo anchor_nick_name
         */

        /**
         * Constructs a new StAnchorInfo.
         * @memberof proto_switch
         * @classdesc Represents a StAnchorInfo.
         * @implements IStAnchorInfo
         * @constructor
         * @param {proto_switch.IStAnchorInfo=} [properties] Properties to set
         */
        function StAnchorInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StAnchorInfo anchor_id_name.
         * @member {Uint8Array} anchor_id_name
         * @memberof proto_switch.StAnchorInfo
         * @instance
         */
        StAnchorInfo.prototype.anchor_id_name = $util.newBuffer([]);

        /**
         * StAnchorInfo anchor_id.
         * @member {number|Long} anchor_id
         * @memberof proto_switch.StAnchorInfo
         * @instance
         */
        StAnchorInfo.prototype.anchor_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StAnchorInfo anchor_nick_name.
         * @member {Uint8Array} anchor_nick_name
         * @memberof proto_switch.StAnchorInfo
         * @instance
         */
        StAnchorInfo.prototype.anchor_nick_name = $util.newBuffer([]);

        /**
         * Creates a new StAnchorInfo instance using the specified properties.
         * @function create
         * @memberof proto_switch.StAnchorInfo
         * @static
         * @param {proto_switch.IStAnchorInfo=} [properties] Properties to set
         * @returns {proto_switch.StAnchorInfo} StAnchorInfo instance
         */
        StAnchorInfo.create = function create(properties) {
            return new StAnchorInfo(properties);
        };

        /**
         * Encodes the specified StAnchorInfo message. Does not implicitly {@link proto_switch.StAnchorInfo.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.StAnchorInfo
         * @static
         * @param {proto_switch.IStAnchorInfo} message StAnchorInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StAnchorInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.anchor_id_name != null && Object.hasOwnProperty.call(message, "anchor_id_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.anchor_id_name);
            if (message.anchor_id != null && Object.hasOwnProperty.call(message, "anchor_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.anchor_id);
            if (message.anchor_nick_name != null && Object.hasOwnProperty.call(message, "anchor_nick_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.anchor_nick_name);
            return writer;
        };

        /**
         * Decodes a StAnchorInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.StAnchorInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.StAnchorInfo} StAnchorInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StAnchorInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.StAnchorInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.anchor_id_name = reader.bytes();
                    break;
                case 2:
                    message.anchor_id = reader.uint64();
                    break;
                case 3:
                    message.anchor_nick_name = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StAnchorInfo;
    })();

    proto_switch.StStreamInfo = (function() {

        /**
         * Properties of a StStreamInfo.
         * @memberof proto_switch
         * @interface IStStreamInfo
         * @property {Uint8Array|null} [stream_id] StStreamInfo stream_id
         * @property {string|null} [stream_sid] StStreamInfo stream_sid
         * @property {Uint8Array|null} [id_name] StStreamInfo id_name
         * @property {Uint8Array|null} [nick_name] StStreamInfo nick_name
         * @property {number|Long|null} [create_time] StStreamInfo create_time
         * @property {Uint8Array|null} [extra_info] StStreamInfo extra_info
         * @property {Uint8Array|null} [title] StStreamInfo title
         * @property {number|null} [stream_ver] StStreamInfo stream_ver
         * @property {Uint8Array|null} [stream_attr] StStreamInfo stream_attr
         * @property {number|null} [stream_src] StStreamInfo stream_src
         * @property {number|null} [stream_state] StStreamInfo stream_state
         * @property {number|null} [stream_type] StStreamInfo stream_type
         * @property {number|null} [stream_nid] StStreamInfo stream_nid
         */

        /**
         * Constructs a new StStreamInfo.
         * @memberof proto_switch
         * @classdesc Represents a StStreamInfo.
         * @implements IStStreamInfo
         * @constructor
         * @param {proto_switch.IStStreamInfo=} [properties] Properties to set
         */
        function StStreamInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StStreamInfo stream_id.
         * @member {Uint8Array} stream_id
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_id = $util.newBuffer([]);

        /**
         * StStreamInfo stream_sid.
         * @member {string} stream_sid
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_sid = "";

        /**
         * StStreamInfo id_name.
         * @member {Uint8Array} id_name
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.id_name = $util.newBuffer([]);

        /**
         * StStreamInfo nick_name.
         * @member {Uint8Array} nick_name
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.nick_name = $util.newBuffer([]);

        /**
         * StStreamInfo create_time.
         * @member {number|Long} create_time
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.create_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StStreamInfo extra_info.
         * @member {Uint8Array} extra_info
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.extra_info = $util.newBuffer([]);

        /**
         * StStreamInfo title.
         * @member {Uint8Array} title
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.title = $util.newBuffer([]);

        /**
         * StStreamInfo stream_ver.
         * @member {number} stream_ver
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_ver = 0;

        /**
         * StStreamInfo stream_attr.
         * @member {Uint8Array} stream_attr
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_attr = $util.newBuffer([]);

        /**
         * StStreamInfo stream_src.
         * @member {number} stream_src
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_src = 0;

        /**
         * StStreamInfo stream_state.
         * @member {number} stream_state
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_state = 0;

        /**
         * StStreamInfo stream_type.
         * @member {number} stream_type
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_type = 0;

        /**
         * StStreamInfo stream_nid.
         * @member {number} stream_nid
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_nid = 0;

        /**
         * Creates a new StStreamInfo instance using the specified properties.
         * @function create
         * @memberof proto_switch.StStreamInfo
         * @static
         * @param {proto_switch.IStStreamInfo=} [properties] Properties to set
         * @returns {proto_switch.StStreamInfo} StStreamInfo instance
         */
        StStreamInfo.create = function create(properties) {
            return new StStreamInfo(properties);
        };

        /**
         * Encodes the specified StStreamInfo message. Does not implicitly {@link proto_switch.StStreamInfo.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.StStreamInfo
         * @static
         * @param {proto_switch.IStStreamInfo} message StStreamInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StStreamInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.stream_id);
            if (message.stream_sid != null && Object.hasOwnProperty.call(message, "stream_sid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.stream_sid);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.id_name);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.nick_name);
            if (message.create_time != null && Object.hasOwnProperty.call(message, "create_time"))
                writer.uint32(/* id 5, wireType 1 =*/41).fixed64(message.create_time);
            if (message.extra_info != null && Object.hasOwnProperty.call(message, "extra_info"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.extra_info);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.title);
            if (message.stream_ver != null && Object.hasOwnProperty.call(message, "stream_ver"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.stream_ver);
            if (message.stream_attr != null && Object.hasOwnProperty.call(message, "stream_attr"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.stream_attr);
            if (message.stream_src != null && Object.hasOwnProperty.call(message, "stream_src"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.stream_src);
            if (message.stream_state != null && Object.hasOwnProperty.call(message, "stream_state"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.stream_state);
            if (message.stream_type != null && Object.hasOwnProperty.call(message, "stream_type"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.stream_type);
            if (message.stream_nid != null && Object.hasOwnProperty.call(message, "stream_nid"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.stream_nid);
            return writer;
        };

        /**
         * Decodes a StStreamInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.StStreamInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.StStreamInfo} StStreamInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StStreamInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.StStreamInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stream_id = reader.bytes();
                    break;
                case 2:
                    message.stream_sid = reader.string();
                    break;
                case 3:
                    message.id_name = reader.bytes();
                    break;
                case 4:
                    message.nick_name = reader.bytes();
                    break;
                case 5:
                    message.create_time = reader.fixed64();
                    break;
                case 6:
                    message.extra_info = reader.bytes();
                    break;
                case 7:
                    message.title = reader.bytes();
                    break;
                case 8:
                    message.stream_ver = reader.uint32();
                    break;
                case 9:
                    message.stream_attr = reader.bytes();
                    break;
                case 10:
                    message.stream_src = reader.uint32();
                    break;
                case 11:
                    message.stream_state = reader.uint32();
                    break;
                case 12:
                    message.stream_type = reader.uint32();
                    break;
                case 13:
                    message.stream_nid = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StStreamInfo;
    })();

    proto_switch.StTransSeqInfo = (function() {

        /**
         * Properties of a StTransSeqInfo.
         * @memberof proto_switch
         * @interface IStTransSeqInfo
         * @property {Uint8Array|null} [trans_type] StTransSeqInfo trans_type
         * @property {number|null} [trans_seq] StTransSeqInfo trans_seq
         */

        /**
         * Constructs a new StTransSeqInfo.
         * @memberof proto_switch
         * @classdesc Represents a StTransSeqInfo.
         * @implements IStTransSeqInfo
         * @constructor
         * @param {proto_switch.IStTransSeqInfo=} [properties] Properties to set
         */
        function StTransSeqInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StTransSeqInfo trans_type.
         * @member {Uint8Array} trans_type
         * @memberof proto_switch.StTransSeqInfo
         * @instance
         */
        StTransSeqInfo.prototype.trans_type = $util.newBuffer([]);

        /**
         * StTransSeqInfo trans_seq.
         * @member {number} trans_seq
         * @memberof proto_switch.StTransSeqInfo
         * @instance
         */
        StTransSeqInfo.prototype.trans_seq = 0;

        /**
         * Creates a new StTransSeqInfo instance using the specified properties.
         * @function create
         * @memberof proto_switch.StTransSeqInfo
         * @static
         * @param {proto_switch.IStTransSeqInfo=} [properties] Properties to set
         * @returns {proto_switch.StTransSeqInfo} StTransSeqInfo instance
         */
        StTransSeqInfo.create = function create(properties) {
            return new StTransSeqInfo(properties);
        };

        /**
         * Encodes the specified StTransSeqInfo message. Does not implicitly {@link proto_switch.StTransSeqInfo.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.StTransSeqInfo
         * @static
         * @param {proto_switch.IStTransSeqInfo} message StTransSeqInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StTransSeqInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_type);
            if (message.trans_seq != null && Object.hasOwnProperty.call(message, "trans_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.trans_seq);
            return writer;
        };

        /**
         * Decodes a StTransSeqInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.StTransSeqInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.StTransSeqInfo} StTransSeqInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StTransSeqInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.StTransSeqInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_type = reader.bytes();
                    break;
                case 2:
                    message.trans_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StTransSeqInfo;
    })();

    proto_switch.StTransInfo = (function() {

        /**
         * Properties of a StTransInfo.
         * @memberof proto_switch
         * @interface IStTransInfo
         * @property {Uint8Array|null} [trans_channel] StTransInfo trans_channel
         * @property {Array.<proto_switch.IStTransSeqInfo>|null} [trans_seq_array] StTransInfo trans_seq_array
         */

        /**
         * Constructs a new StTransInfo.
         * @memberof proto_switch
         * @classdesc Represents a StTransInfo.
         * @implements IStTransInfo
         * @constructor
         * @param {proto_switch.IStTransInfo=} [properties] Properties to set
         */
        function StTransInfo(properties) {
            this.trans_seq_array = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StTransInfo trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof proto_switch.StTransInfo
         * @instance
         */
        StTransInfo.prototype.trans_channel = $util.newBuffer([]);

        /**
         * StTransInfo trans_seq_array.
         * @member {Array.<proto_switch.IStTransSeqInfo>} trans_seq_array
         * @memberof proto_switch.StTransInfo
         * @instance
         */
        StTransInfo.prototype.trans_seq_array = $util.emptyArray;

        /**
         * Creates a new StTransInfo instance using the specified properties.
         * @function create
         * @memberof proto_switch.StTransInfo
         * @static
         * @param {proto_switch.IStTransInfo=} [properties] Properties to set
         * @returns {proto_switch.StTransInfo} StTransInfo instance
         */
        StTransInfo.create = function create(properties) {
            return new StTransInfo(properties);
        };

        /**
         * Encodes the specified StTransInfo message. Does not implicitly {@link proto_switch.StTransInfo.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.StTransInfo
         * @static
         * @param {proto_switch.IStTransInfo} message StTransInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StTransInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_channel);
            if (message.trans_seq_array != null && message.trans_seq_array.length)
                for (var i = 0; i < message.trans_seq_array.length; ++i)
                    $root.proto_switch.StTransSeqInfo.encode(message.trans_seq_array[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a StTransInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.StTransInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.StTransInfo} StTransInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StTransInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.StTransInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_channel = reader.bytes();
                    break;
                case 2:
                    if (!(message.trans_seq_array && message.trans_seq_array.length))
                        message.trans_seq_array = [];
                    message.trans_seq_array.push($root.proto_switch.StTransSeqInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StTransInfo;
    })();

    proto_switch.LogoutRoomReq = (function() {

        /**
         * Properties of a LogoutRoomReq.
         * @memberof proto_switch
         * @interface ILogoutRoomReq
         * @property {number|null} [logout_code] LogoutRoomReq logout_code
         * @property {Uint8Array|null} [logout_check] LogoutRoomReq logout_check
         * @property {number|Long|null} [liveroom_session_id] LogoutRoomReq liveroom_session_id
         * @property {Uint8Array|null} [room_id] LogoutRoomReq room_id
         * @property {number|null} [role] LogoutRoomReq role
         * @property {Uint8Array|null} [nickname] LogoutRoomReq nickname
         * @property {number|null} [logout_logic] LogoutRoomReq logout_logic
         */

        /**
         * Constructs a new LogoutRoomReq.
         * @memberof proto_switch
         * @classdesc Represents a LogoutRoomReq.
         * @implements ILogoutRoomReq
         * @constructor
         * @param {proto_switch.ILogoutRoomReq=} [properties] Properties to set
         */
        function LogoutRoomReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LogoutRoomReq logout_code.
         * @member {number} logout_code
         * @memberof proto_switch.LogoutRoomReq
         * @instance
         */
        LogoutRoomReq.prototype.logout_code = 0;

        /**
         * LogoutRoomReq logout_check.
         * @member {Uint8Array} logout_check
         * @memberof proto_switch.LogoutRoomReq
         * @instance
         */
        LogoutRoomReq.prototype.logout_check = $util.newBuffer([]);

        /**
         * LogoutRoomReq liveroom_session_id.
         * @member {number|Long} liveroom_session_id
         * @memberof proto_switch.LogoutRoomReq
         * @instance
         */
        LogoutRoomReq.prototype.liveroom_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * LogoutRoomReq room_id.
         * @member {Uint8Array} room_id
         * @memberof proto_switch.LogoutRoomReq
         * @instance
         */
        LogoutRoomReq.prototype.room_id = $util.newBuffer([]);

        /**
         * LogoutRoomReq role.
         * @member {number} role
         * @memberof proto_switch.LogoutRoomReq
         * @instance
         */
        LogoutRoomReq.prototype.role = 0;

        /**
         * LogoutRoomReq nickname.
         * @member {Uint8Array} nickname
         * @memberof proto_switch.LogoutRoomReq
         * @instance
         */
        LogoutRoomReq.prototype.nickname = $util.newBuffer([]);

        /**
         * LogoutRoomReq logout_logic.
         * @member {number} logout_logic
         * @memberof proto_switch.LogoutRoomReq
         * @instance
         */
        LogoutRoomReq.prototype.logout_logic = 0;

        /**
         * Creates a new LogoutRoomReq instance using the specified properties.
         * @function create
         * @memberof proto_switch.LogoutRoomReq
         * @static
         * @param {proto_switch.ILogoutRoomReq=} [properties] Properties to set
         * @returns {proto_switch.LogoutRoomReq} LogoutRoomReq instance
         */
        LogoutRoomReq.create = function create(properties) {
            return new LogoutRoomReq(properties);
        };

        /**
         * Encodes the specified LogoutRoomReq message. Does not implicitly {@link proto_switch.LogoutRoomReq.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.LogoutRoomReq
         * @static
         * @param {proto_switch.ILogoutRoomReq} message LogoutRoomReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogoutRoomReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.logout_code != null && Object.hasOwnProperty.call(message, "logout_code"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.logout_code);
            if (message.logout_check != null && Object.hasOwnProperty.call(message, "logout_check"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.logout_check);
            if (message.liveroom_session_id != null && Object.hasOwnProperty.call(message, "liveroom_session_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.liveroom_session_id);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.room_id);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.role);
            if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.nickname);
            if (message.logout_logic != null && Object.hasOwnProperty.call(message, "logout_logic"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.logout_logic);
            return writer;
        };

        /**
         * Decodes a LogoutRoomReq message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.LogoutRoomReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.LogoutRoomReq} LogoutRoomReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogoutRoomReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.LogoutRoomReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.logout_code = reader.uint32();
                    break;
                case 2:
                    message.logout_check = reader.bytes();
                    break;
                case 3:
                    message.liveroom_session_id = reader.uint64();
                    break;
                case 4:
                    message.room_id = reader.bytes();
                    break;
                case 5:
                    message.role = reader.uint32();
                    break;
                case 6:
                    message.nickname = reader.bytes();
                    break;
                case 7:
                    message.logout_logic = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return LogoutRoomReq;
    })();

    proto_switch.LogoutRoomRsp = (function() {

        /**
         * Properties of a LogoutRoomRsp.
         * @memberof proto_switch
         * @interface ILogoutRoomRsp
         * @property {proto_switch.IRspHead|null} [rsp_head] LogoutRoomRsp rsp_head
         */

        /**
         * Constructs a new LogoutRoomRsp.
         * @memberof proto_switch
         * @classdesc Represents a LogoutRoomRsp.
         * @implements ILogoutRoomRsp
         * @constructor
         * @param {proto_switch.ILogoutRoomRsp=} [properties] Properties to set
         */
        function LogoutRoomRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LogoutRoomRsp rsp_head.
         * @member {proto_switch.IRspHead|null|undefined} rsp_head
         * @memberof proto_switch.LogoutRoomRsp
         * @instance
         */
        LogoutRoomRsp.prototype.rsp_head = null;

        /**
         * Creates a new LogoutRoomRsp instance using the specified properties.
         * @function create
         * @memberof proto_switch.LogoutRoomRsp
         * @static
         * @param {proto_switch.ILogoutRoomRsp=} [properties] Properties to set
         * @returns {proto_switch.LogoutRoomRsp} LogoutRoomRsp instance
         */
        LogoutRoomRsp.create = function create(properties) {
            return new LogoutRoomRsp(properties);
        };

        /**
         * Encodes the specified LogoutRoomRsp message. Does not implicitly {@link proto_switch.LogoutRoomRsp.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.LogoutRoomRsp
         * @static
         * @param {proto_switch.ILogoutRoomRsp} message LogoutRoomRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogoutRoomRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.proto_switch.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a LogoutRoomRsp message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.LogoutRoomRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.LogoutRoomRsp} LogoutRoomRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogoutRoomRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.LogoutRoomRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.proto_switch.RspHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return LogoutRoomRsp;
    })();

    proto_switch.TcpHbReq = (function() {

        /**
         * Properties of a TcpHbReq.
         * @memberof proto_switch
         * @interface ITcpHbReq
         * @property {Uint8Array|null} [id_name] TcpHbReq id_name
         */

        /**
         * Constructs a new TcpHbReq.
         * @memberof proto_switch
         * @classdesc Represents a TcpHbReq.
         * @implements ITcpHbReq
         * @constructor
         * @param {proto_switch.ITcpHbReq=} [properties] Properties to set
         */
        function TcpHbReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TcpHbReq id_name.
         * @member {Uint8Array} id_name
         * @memberof proto_switch.TcpHbReq
         * @instance
         */
        TcpHbReq.prototype.id_name = $util.newBuffer([]);

        /**
         * Creates a new TcpHbReq instance using the specified properties.
         * @function create
         * @memberof proto_switch.TcpHbReq
         * @static
         * @param {proto_switch.ITcpHbReq=} [properties] Properties to set
         * @returns {proto_switch.TcpHbReq} TcpHbReq instance
         */
        TcpHbReq.create = function create(properties) {
            return new TcpHbReq(properties);
        };

        /**
         * Encodes the specified TcpHbReq message. Does not implicitly {@link proto_switch.TcpHbReq.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.TcpHbReq
         * @static
         * @param {proto_switch.ITcpHbReq} message TcpHbReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TcpHbReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id_name);
            return writer;
        };

        /**
         * Decodes a TcpHbReq message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.TcpHbReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.TcpHbReq} TcpHbReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TcpHbReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.TcpHbReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id_name = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return TcpHbReq;
    })();

    proto_switch.TcpHbRsp = (function() {

        /**
         * Properties of a TcpHbRsp.
         * @memberof proto_switch
         * @interface ITcpHbRsp
         * @property {proto_switch.IRspHead|null} [rsp_head] TcpHbRsp rsp_head
         * @property {number|null} [heartbeat_interval] TcpHbRsp heartbeat_interval
         * @property {number|null} [heartbeat_timeout] TcpHbRsp heartbeat_timeout
         * @property {number|Long|null} [server_timestamp] TcpHbRsp server_timestamp
         */

        /**
         * Constructs a new TcpHbRsp.
         * @memberof proto_switch
         * @classdesc Represents a TcpHbRsp.
         * @implements ITcpHbRsp
         * @constructor
         * @param {proto_switch.ITcpHbRsp=} [properties] Properties to set
         */
        function TcpHbRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TcpHbRsp rsp_head.
         * @member {proto_switch.IRspHead|null|undefined} rsp_head
         * @memberof proto_switch.TcpHbRsp
         * @instance
         */
        TcpHbRsp.prototype.rsp_head = null;

        /**
         * TcpHbRsp heartbeat_interval.
         * @member {number} heartbeat_interval
         * @memberof proto_switch.TcpHbRsp
         * @instance
         */
        TcpHbRsp.prototype.heartbeat_interval = 0;

        /**
         * TcpHbRsp heartbeat_timeout.
         * @member {number} heartbeat_timeout
         * @memberof proto_switch.TcpHbRsp
         * @instance
         */
        TcpHbRsp.prototype.heartbeat_timeout = 0;

        /**
         * TcpHbRsp server_timestamp.
         * @member {number|Long} server_timestamp
         * @memberof proto_switch.TcpHbRsp
         * @instance
         */
        TcpHbRsp.prototype.server_timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TcpHbRsp instance using the specified properties.
         * @function create
         * @memberof proto_switch.TcpHbRsp
         * @static
         * @param {proto_switch.ITcpHbRsp=} [properties] Properties to set
         * @returns {proto_switch.TcpHbRsp} TcpHbRsp instance
         */
        TcpHbRsp.create = function create(properties) {
            return new TcpHbRsp(properties);
        };

        /**
         * Encodes the specified TcpHbRsp message. Does not implicitly {@link proto_switch.TcpHbRsp.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.TcpHbRsp
         * @static
         * @param {proto_switch.ITcpHbRsp} message TcpHbRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TcpHbRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.proto_switch.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.heartbeat_interval != null && Object.hasOwnProperty.call(message, "heartbeat_interval"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.heartbeat_interval);
            if (message.heartbeat_timeout != null && Object.hasOwnProperty.call(message, "heartbeat_timeout"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.heartbeat_timeout);
            if (message.server_timestamp != null && Object.hasOwnProperty.call(message, "server_timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.server_timestamp);
            return writer;
        };

        /**
         * Decodes a TcpHbRsp message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.TcpHbRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.TcpHbRsp} TcpHbRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TcpHbRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.TcpHbRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.proto_switch.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.heartbeat_interval = reader.uint32();
                    break;
                case 3:
                    message.heartbeat_timeout = reader.uint32();
                    break;
                case 4:
                    message.server_timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return TcpHbRsp;
    })();

    /**
     * TermType enum.
     * @name proto_switch.TermType
     * @enum {number}
     * @property {number} TT_NONE=0 TT_NONE value
     * @property {number} TT_PC=1 TT_PC value
     * @property {number} TT_IOS=2 TT_IOS value
     * @property {number} TT_ANDROID=3 TT_ANDROID value
     * @property {number} TT_MAC=4 TT_MAC value
     * @property {number} TT_LINUX=5 TT_LINUX value
     * @property {number} TT_WEB=6 TT_WEB value
     * @property {number} TT_MINIPROGRAM=7 TT_MINIPROGRAM value
     * @property {number} TT_UNKNOWN=32 TT_UNKNOWN value
     */
    proto_switch.TermType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TT_NONE"] = 0;
        values[valuesById[1] = "TT_PC"] = 1;
        values[valuesById[2] = "TT_IOS"] = 2;
        values[valuesById[3] = "TT_ANDROID"] = 3;
        values[valuesById[4] = "TT_MAC"] = 4;
        values[valuesById[5] = "TT_LINUX"] = 5;
        values[valuesById[6] = "TT_WEB"] = 6;
        values[valuesById[7] = "TT_MINIPROGRAM"] = 7;
        values[valuesById[32] = "TT_UNKNOWN"] = 32;
        return values;
    })();

    /**
     * NetType enum.
     * @name proto_switch.NetType
     * @enum {number}
     * @property {number} NT_NONE=0 NT_NONE value
     * @property {number} NT_LINE=1 NT_LINE value
     * @property {number} NT_WIFI=2 NT_WIFI value
     * @property {number} NT_2G=3 NT_2G value
     * @property {number} NT_3G=4 NT_3G value
     * @property {number} NT_4G=5 NT_4G value
     * @property {number} NT_UNKNOWN=32 NT_UNKNOWN value
     */
    proto_switch.NetType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NT_NONE"] = 0;
        values[valuesById[1] = "NT_LINE"] = 1;
        values[valuesById[2] = "NT_WIFI"] = 2;
        values[valuesById[3] = "NT_2G"] = 3;
        values[valuesById[4] = "NT_3G"] = 4;
        values[valuesById[5] = "NT_4G"] = 5;
        values[valuesById[32] = "NT_UNKNOWN"] = 32;
        return values;
    })();

    /**
     * ProductType enum.
     * @name proto_switch.ProductType
     * @enum {number}
     * @property {number} PRODUCT_TYPE_NONE=0 PRODUCT_TYPE_NONE value
     * @property {number} PRODUCT_TYPE_LIVEROOM=1 PRODUCT_TYPE_LIVEROOM value
     * @property {number} PRODUCT_TYPE_IM=2 PRODUCT_TYPE_IM value
     */
    proto_switch.ProductType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PRODUCT_TYPE_NONE"] = 0;
        values[valuesById[1] = "PRODUCT_TYPE_LIVEROOM"] = 1;
        values[valuesById[2] = "PRODUCT_TYPE_IM"] = 2;
        return values;
    })();

    /**
     * LiveroomProtoVersion enum.
     * @name proto_switch.LiveroomProtoVersion
     * @enum {number}
     * @property {number} PROTO_VERSION_NONE=0 PROTO_VERSION_NONE value
     * @property {number} RPOTO_V020000=131072 RPOTO_V020000 value
     */
    proto_switch.LiveroomProtoVersion = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PROTO_VERSION_NONE"] = 0;
        values[valuesById[131072] = "RPOTO_V020000"] = 131072;
        return values;
    })();

    /**
     * SdkConnType enum.
     * @name proto_switch.SdkConnType
     * @enum {number}
     * @property {number} SdkConnType_None=0 SdkConnType_None value
     * @property {number} SdkConnType_Tcp=1 SdkConnType_Tcp value
     * @property {number} SdkConnType_Websocket=2 SdkConnType_Websocket value
     */
    proto_switch.SdkConnType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SdkConnType_None"] = 0;
        values[valuesById[1] = "SdkConnType_Tcp"] = 1;
        values[valuesById[2] = "SdkConnType_Websocket"] = 2;
        return values;
    })();

    proto_switch.Header = (function() {

        /**
         * Properties of a Header.
         * @memberof proto_switch
         * @interface IHeader
         * @property {string|null} [cmd] Header cmd
         * @property {number|null} [seq] Header seq
         * @property {number|Long|null} [timestamp] Header timestamp
         * @property {number|null} [app_id] Header app_id
         * @property {string|null} [user_id] Header user_id
         * @property {number|Long|null} [session_id] Header session_id
         * @property {number|Long|null} [user_nid] Header user_nid
         * @property {Uint8Array|null} [controls] Header controls
         * @property {proto_switch.ProductType|null} [product] Header product
         * @property {Uint8Array|null} [flags] Header flags
         */

        /**
         * Constructs a new Header.
         * @memberof proto_switch
         * @classdesc Represents a Header.
         * @implements IHeader
         * @constructor
         * @param {proto_switch.IHeader=} [properties] Properties to set
         */
        function Header(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Header cmd.
         * @member {string} cmd
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.cmd = "";

        /**
         * Header seq.
         * @member {number} seq
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.seq = 0;

        /**
         * Header timestamp.
         * @member {number|Long} timestamp
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Header app_id.
         * @member {number} app_id
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.app_id = 0;

        /**
         * Header user_id.
         * @member {string} user_id
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.user_id = "";

        /**
         * Header session_id.
         * @member {number|Long} session_id
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.session_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Header user_nid.
         * @member {number|Long} user_nid
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.user_nid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Header controls.
         * @member {Uint8Array} controls
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.controls = $util.newBuffer([]);

        /**
         * Header product.
         * @member {proto_switch.ProductType} product
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.product = 0;

        /**
         * Header flags.
         * @member {Uint8Array} flags
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.flags = $util.newBuffer([]);

        /**
         * Creates a new Header instance using the specified properties.
         * @function create
         * @memberof proto_switch.Header
         * @static
         * @param {proto_switch.IHeader=} [properties] Properties to set
         * @returns {proto_switch.Header} Header instance
         */
        Header.create = function create(properties) {
            return new Header(properties);
        };

        /**
         * Encodes the specified Header message. Does not implicitly {@link proto_switch.Header.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.Header
         * @static
         * @param {proto_switch.IHeader} message Header message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Header.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cmd != null && Object.hasOwnProperty.call(message, "cmd"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cmd);
            if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.seq);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            if (message.app_id != null && Object.hasOwnProperty.call(message, "app_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.app_id);
            if (message.user_id != null && Object.hasOwnProperty.call(message, "user_id"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.user_id);
            if (message.session_id != null && Object.hasOwnProperty.call(message, "session_id"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.session_id);
            if (message.user_nid != null && Object.hasOwnProperty.call(message, "user_nid"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.user_nid);
            if (message.controls != null && Object.hasOwnProperty.call(message, "controls"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.controls);
            if (message.product != null && Object.hasOwnProperty.call(message, "product"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.product);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.flags);
            return writer;
        };

        /**
         * Decodes a Header message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.Header
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.Header} Header
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Header.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.Header();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cmd = reader.string();
                    break;
                case 2:
                    message.seq = reader.uint32();
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                case 4:
                    message.app_id = reader.uint32();
                    break;
                case 5:
                    message.user_id = reader.string();
                    break;
                case 6:
                    message.session_id = reader.int64();
                    break;
                case 7:
                    message.user_nid = reader.int64();
                    break;
                case 8:
                    message.controls = reader.bytes();
                    break;
                case 9:
                    message.product = reader.int32();
                    break;
                case 10:
                    message.flags = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Header;
    })();

    proto_switch.PushKickout = (function() {

        /**
         * Properties of a PushKickout.
         * @memberof proto_switch
         * @interface IPushKickout
         * @property {number|null} [reason] PushKickout reason
         * @property {string|null} [message] PushKickout message
         * @property {number|null} [need_relogin] PushKickout need_relogin
         */

        /**
         * Constructs a new PushKickout.
         * @memberof proto_switch
         * @classdesc Represents a PushKickout.
         * @implements IPushKickout
         * @constructor
         * @param {proto_switch.IPushKickout=} [properties] Properties to set
         */
        function PushKickout(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushKickout reason.
         * @member {number} reason
         * @memberof proto_switch.PushKickout
         * @instance
         */
        PushKickout.prototype.reason = 0;

        /**
         * PushKickout message.
         * @member {string} message
         * @memberof proto_switch.PushKickout
         * @instance
         */
        PushKickout.prototype.message = "";

        /**
         * PushKickout need_relogin.
         * @member {number} need_relogin
         * @memberof proto_switch.PushKickout
         * @instance
         */
        PushKickout.prototype.need_relogin = 0;

        /**
         * Creates a new PushKickout instance using the specified properties.
         * @function create
         * @memberof proto_switch.PushKickout
         * @static
         * @param {proto_switch.IPushKickout=} [properties] Properties to set
         * @returns {proto_switch.PushKickout} PushKickout instance
         */
        PushKickout.create = function create(properties) {
            return new PushKickout(properties);
        };

        /**
         * Encodes the specified PushKickout message. Does not implicitly {@link proto_switch.PushKickout.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.PushKickout
         * @static
         * @param {proto_switch.IPushKickout} message PushKickout message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushKickout.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.reason);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            if (message.need_relogin != null && Object.hasOwnProperty.call(message, "need_relogin"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.need_relogin);
            return writer;
        };

        /**
         * Decodes a PushKickout message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.PushKickout
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.PushKickout} PushKickout
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushKickout.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.PushKickout();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reason = reader.uint32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.need_relogin = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushKickout;
    })();

    proto_switch.PushRedirect2Sdk = (function() {

        /**
         * Properties of a PushRedirect2Sdk.
         * @memberof proto_switch
         * @interface IPushRedirect2Sdk
         * @property {Array.<string>|null} [redirect_server] PushRedirect2Sdk redirect_server
         */

        /**
         * Constructs a new PushRedirect2Sdk.
         * @memberof proto_switch
         * @classdesc Represents a PushRedirect2Sdk.
         * @implements IPushRedirect2Sdk
         * @constructor
         * @param {proto_switch.IPushRedirect2Sdk=} [properties] Properties to set
         */
        function PushRedirect2Sdk(properties) {
            this.redirect_server = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushRedirect2Sdk redirect_server.
         * @member {Array.<string>} redirect_server
         * @memberof proto_switch.PushRedirect2Sdk
         * @instance
         */
        PushRedirect2Sdk.prototype.redirect_server = $util.emptyArray;

        /**
         * Creates a new PushRedirect2Sdk instance using the specified properties.
         * @function create
         * @memberof proto_switch.PushRedirect2Sdk
         * @static
         * @param {proto_switch.IPushRedirect2Sdk=} [properties] Properties to set
         * @returns {proto_switch.PushRedirect2Sdk} PushRedirect2Sdk instance
         */
        PushRedirect2Sdk.create = function create(properties) {
            return new PushRedirect2Sdk(properties);
        };

        /**
         * Encodes the specified PushRedirect2Sdk message. Does not implicitly {@link proto_switch.PushRedirect2Sdk.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.PushRedirect2Sdk
         * @static
         * @param {proto_switch.IPushRedirect2Sdk} message PushRedirect2Sdk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushRedirect2Sdk.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.redirect_server != null && message.redirect_server.length)
                for (var i = 0; i < message.redirect_server.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.redirect_server[i]);
            return writer;
        };

        /**
         * Decodes a PushRedirect2Sdk message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.PushRedirect2Sdk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.PushRedirect2Sdk} PushRedirect2Sdk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushRedirect2Sdk.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.PushRedirect2Sdk();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.redirect_server && message.redirect_server.length))
                        message.redirect_server = [];
                    message.redirect_server.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushRedirect2Sdk;
    })();

    proto_switch.PushReq = (function() {

        /**
         * Properties of a PushReq.
         * @memberof proto_switch
         * @interface IPushReq
         * @property {proto_switch.IPushReqHead|null} [head] PushReq head
         * @property {Uint8Array|null} [msg_body] PushReq msg_body
         */

        /**
         * Constructs a new PushReq.
         * @memberof proto_switch
         * @classdesc Represents a PushReq.
         * @implements IPushReq
         * @constructor
         * @param {proto_switch.IPushReq=} [properties] Properties to set
         */
        function PushReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushReq head.
         * @member {proto_switch.IPushReqHead|null|undefined} head
         * @memberof proto_switch.PushReq
         * @instance
         */
        PushReq.prototype.head = null;

        /**
         * PushReq msg_body.
         * @member {Uint8Array} msg_body
         * @memberof proto_switch.PushReq
         * @instance
         */
        PushReq.prototype.msg_body = $util.newBuffer([]);

        /**
         * Creates a new PushReq instance using the specified properties.
         * @function create
         * @memberof proto_switch.PushReq
         * @static
         * @param {proto_switch.IPushReq=} [properties] Properties to set
         * @returns {proto_switch.PushReq} PushReq instance
         */
        PushReq.create = function create(properties) {
            return new PushReq(properties);
        };

        /**
         * Encodes the specified PushReq message. Does not implicitly {@link proto_switch.PushReq.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.PushReq
         * @static
         * @param {proto_switch.IPushReq} message PushReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.head != null && Object.hasOwnProperty.call(message, "head"))
                $root.proto_switch.PushReqHead.encode(message.head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.msg_body != null && Object.hasOwnProperty.call(message, "msg_body"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.msg_body);
            return writer;
        };

        /**
         * Decodes a PushReq message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.PushReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.PushReq} PushReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.PushReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.head = $root.proto_switch.PushReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.msg_body = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushReq;
    })();

    proto_switch.PushReqHead = (function() {

        /**
         * Properties of a PushReqHead.
         * @memberof proto_switch
         * @interface IPushReqHead
         * @property {string|null} [sub_cmd] PushReqHead sub_cmd
         * @property {string|null} [sender_user_id] PushReqHead sender_user_id
         * @property {number|null} [qos_flag] PushReqHead qos_flag
         * @property {string|null} [msg_id] PushReqHead msg_id
         * @property {number|Long|null} [send_time] PushReqHead send_time
         * @property {Uint8Array|null} [room_id] PushReqHead room_id
         * @property {number|Long|null} [sender_user_nid] PushReqHead sender_user_nid
         */

        /**
         * Constructs a new PushReqHead.
         * @memberof proto_switch
         * @classdesc Represents a PushReqHead.
         * @implements IPushReqHead
         * @constructor
         * @param {proto_switch.IPushReqHead=} [properties] Properties to set
         */
        function PushReqHead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushReqHead sub_cmd.
         * @member {string} sub_cmd
         * @memberof proto_switch.PushReqHead
         * @instance
         */
        PushReqHead.prototype.sub_cmd = "";

        /**
         * PushReqHead sender_user_id.
         * @member {string} sender_user_id
         * @memberof proto_switch.PushReqHead
         * @instance
         */
        PushReqHead.prototype.sender_user_id = "";

        /**
         * PushReqHead qos_flag.
         * @member {number} qos_flag
         * @memberof proto_switch.PushReqHead
         * @instance
         */
        PushReqHead.prototype.qos_flag = 0;

        /**
         * PushReqHead msg_id.
         * @member {string} msg_id
         * @memberof proto_switch.PushReqHead
         * @instance
         */
        PushReqHead.prototype.msg_id = "";

        /**
         * PushReqHead send_time.
         * @member {number|Long} send_time
         * @memberof proto_switch.PushReqHead
         * @instance
         */
        PushReqHead.prototype.send_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PushReqHead room_id.
         * @member {Uint8Array} room_id
         * @memberof proto_switch.PushReqHead
         * @instance
         */
        PushReqHead.prototype.room_id = $util.newBuffer([]);

        /**
         * PushReqHead sender_user_nid.
         * @member {number|Long} sender_user_nid
         * @memberof proto_switch.PushReqHead
         * @instance
         */
        PushReqHead.prototype.sender_user_nid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new PushReqHead instance using the specified properties.
         * @function create
         * @memberof proto_switch.PushReqHead
         * @static
         * @param {proto_switch.IPushReqHead=} [properties] Properties to set
         * @returns {proto_switch.PushReqHead} PushReqHead instance
         */
        PushReqHead.create = function create(properties) {
            return new PushReqHead(properties);
        };

        /**
         * Encodes the specified PushReqHead message. Does not implicitly {@link proto_switch.PushReqHead.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.PushReqHead
         * @static
         * @param {proto_switch.IPushReqHead} message PushReqHead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushReqHead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sub_cmd != null && Object.hasOwnProperty.call(message, "sub_cmd"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sub_cmd);
            if (message.sender_user_id != null && Object.hasOwnProperty.call(message, "sender_user_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.sender_user_id);
            if (message.qos_flag != null && Object.hasOwnProperty.call(message, "qos_flag"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.qos_flag);
            if (message.msg_id != null && Object.hasOwnProperty.call(message, "msg_id"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.msg_id);
            if (message.send_time != null && Object.hasOwnProperty.call(message, "send_time"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.send_time);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.room_id);
            if (message.sender_user_nid != null && Object.hasOwnProperty.call(message, "sender_user_nid"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.sender_user_nid);
            return writer;
        };

        /**
         * Decodes a PushReqHead message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.PushReqHead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.PushReqHead} PushReqHead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushReqHead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.PushReqHead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sub_cmd = reader.string();
                    break;
                case 2:
                    message.sender_user_id = reader.string();
                    break;
                case 3:
                    message.qos_flag = reader.uint32();
                    break;
                case 4:
                    message.msg_id = reader.string();
                    break;
                case 5:
                    message.send_time = reader.int64();
                    break;
                case 6:
                    message.room_id = reader.bytes();
                    break;
                case 7:
                    message.sender_user_nid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushReqHead;
    })();

    proto_switch.PushRsp = (function() {

        /**
         * Properties of a PushRsp.
         * @memberof proto_switch
         * @interface IPushRsp
         * @property {number|null} [code] PushRsp code
         * @property {string|null} [message] PushRsp message
         * @property {string|null} [sub_cmd] PushRsp sub_cmd
         * @property {string|null} [msg_id] PushRsp msg_id
         * @property {number|Long|null} [server_send_time] PushRsp server_send_time
         */

        /**
         * Constructs a new PushRsp.
         * @memberof proto_switch
         * @classdesc Represents a PushRsp.
         * @implements IPushRsp
         * @constructor
         * @param {proto_switch.IPushRsp=} [properties] Properties to set
         */
        function PushRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushRsp code.
         * @member {number} code
         * @memberof proto_switch.PushRsp
         * @instance
         */
        PushRsp.prototype.code = 0;

        /**
         * PushRsp message.
         * @member {string} message
         * @memberof proto_switch.PushRsp
         * @instance
         */
        PushRsp.prototype.message = "";

        /**
         * PushRsp sub_cmd.
         * @member {string} sub_cmd
         * @memberof proto_switch.PushRsp
         * @instance
         */
        PushRsp.prototype.sub_cmd = "";

        /**
         * PushRsp msg_id.
         * @member {string} msg_id
         * @memberof proto_switch.PushRsp
         * @instance
         */
        PushRsp.prototype.msg_id = "";

        /**
         * PushRsp server_send_time.
         * @member {number|Long} server_send_time
         * @memberof proto_switch.PushRsp
         * @instance
         */
        PushRsp.prototype.server_send_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PushRsp instance using the specified properties.
         * @function create
         * @memberof proto_switch.PushRsp
         * @static
         * @param {proto_switch.IPushRsp=} [properties] Properties to set
         * @returns {proto_switch.PushRsp} PushRsp instance
         */
        PushRsp.create = function create(properties) {
            return new PushRsp(properties);
        };

        /**
         * Encodes the specified PushRsp message. Does not implicitly {@link proto_switch.PushRsp.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.PushRsp
         * @static
         * @param {proto_switch.IPushRsp} message PushRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.code);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            if (message.sub_cmd != null && Object.hasOwnProperty.call(message, "sub_cmd"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.sub_cmd);
            if (message.msg_id != null && Object.hasOwnProperty.call(message, "msg_id"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.msg_id);
            if (message.server_send_time != null && Object.hasOwnProperty.call(message, "server_send_time"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.server_send_time);
            return writer;
        };

        /**
         * Decodes a PushRsp message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.PushRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.PushRsp} PushRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.PushRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.uint32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.sub_cmd = reader.string();
                    break;
                case 4:
                    message.msg_id = reader.string();
                    break;
                case 5:
                    message.server_send_time = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushRsp;
    })();

    proto_switch.MergePushHead = (function() {

        /**
         * Properties of a MergePushHead.
         * @memberof proto_switch
         * @interface IMergePushHead
         * @property {number|null} [qos_flag] MergePushHead qos_flag
         * @property {number|Long|null} [send_time] MergePushHead send_time
         * @property {Uint8Array|null} [room_id] MergePushHead room_id
         */

        /**
         * Constructs a new MergePushHead.
         * @memberof proto_switch
         * @classdesc Represents a MergePushHead.
         * @implements IMergePushHead
         * @constructor
         * @param {proto_switch.IMergePushHead=} [properties] Properties to set
         */
        function MergePushHead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MergePushHead qos_flag.
         * @member {number} qos_flag
         * @memberof proto_switch.MergePushHead
         * @instance
         */
        MergePushHead.prototype.qos_flag = 0;

        /**
         * MergePushHead send_time.
         * @member {number|Long} send_time
         * @memberof proto_switch.MergePushHead
         * @instance
         */
        MergePushHead.prototype.send_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MergePushHead room_id.
         * @member {Uint8Array} room_id
         * @memberof proto_switch.MergePushHead
         * @instance
         */
        MergePushHead.prototype.room_id = $util.newBuffer([]);

        /**
         * Creates a new MergePushHead instance using the specified properties.
         * @function create
         * @memberof proto_switch.MergePushHead
         * @static
         * @param {proto_switch.IMergePushHead=} [properties] Properties to set
         * @returns {proto_switch.MergePushHead} MergePushHead instance
         */
        MergePushHead.create = function create(properties) {
            return new MergePushHead(properties);
        };

        /**
         * Encodes the specified MergePushHead message. Does not implicitly {@link proto_switch.MergePushHead.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.MergePushHead
         * @static
         * @param {proto_switch.IMergePushHead} message MergePushHead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MergePushHead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.qos_flag != null && Object.hasOwnProperty.call(message, "qos_flag"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.qos_flag);
            if (message.send_time != null && Object.hasOwnProperty.call(message, "send_time"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.send_time);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.room_id);
            return writer;
        };

        /**
         * Decodes a MergePushHead message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.MergePushHead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.MergePushHead} MergePushHead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MergePushHead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.MergePushHead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.qos_flag = reader.uint32();
                    break;
                case 2:
                    message.send_time = reader.int64();
                    break;
                case 3:
                    message.room_id = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MergePushHead;
    })();

    proto_switch.MergePushInfo = (function() {

        /**
         * Properties of a MergePushInfo.
         * @memberof proto_switch
         * @interface IMergePushInfo
         * @property {string|null} [sub_cmd] MergePushInfo sub_cmd
         * @property {number|null} [sub_seq] MergePushInfo sub_seq
         * @property {number|Long|null} [sender_nid] MergePushInfo sender_nid
         * @property {Uint8Array|null} [msg_id] MergePushInfo msg_id
         * @property {Uint8Array|null} [msg_body] MergePushInfo msg_body
         * @property {number|Long|null} [msg_timestamp] MergePushInfo msg_timestamp
         */

        /**
         * Constructs a new MergePushInfo.
         * @memberof proto_switch
         * @classdesc Represents a MergePushInfo.
         * @implements IMergePushInfo
         * @constructor
         * @param {proto_switch.IMergePushInfo=} [properties] Properties to set
         */
        function MergePushInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MergePushInfo sub_cmd.
         * @member {string} sub_cmd
         * @memberof proto_switch.MergePushInfo
         * @instance
         */
        MergePushInfo.prototype.sub_cmd = "";

        /**
         * MergePushInfo sub_seq.
         * @member {number} sub_seq
         * @memberof proto_switch.MergePushInfo
         * @instance
         */
        MergePushInfo.prototype.sub_seq = 0;

        /**
         * MergePushInfo sender_nid.
         * @member {number|Long} sender_nid
         * @memberof proto_switch.MergePushInfo
         * @instance
         */
        MergePushInfo.prototype.sender_nid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * MergePushInfo msg_id.
         * @member {Uint8Array} msg_id
         * @memberof proto_switch.MergePushInfo
         * @instance
         */
        MergePushInfo.prototype.msg_id = $util.newBuffer([]);

        /**
         * MergePushInfo msg_body.
         * @member {Uint8Array} msg_body
         * @memberof proto_switch.MergePushInfo
         * @instance
         */
        MergePushInfo.prototype.msg_body = $util.newBuffer([]);

        /**
         * MergePushInfo msg_timestamp.
         * @member {number|Long} msg_timestamp
         * @memberof proto_switch.MergePushInfo
         * @instance
         */
        MergePushInfo.prototype.msg_timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new MergePushInfo instance using the specified properties.
         * @function create
         * @memberof proto_switch.MergePushInfo
         * @static
         * @param {proto_switch.IMergePushInfo=} [properties] Properties to set
         * @returns {proto_switch.MergePushInfo} MergePushInfo instance
         */
        MergePushInfo.create = function create(properties) {
            return new MergePushInfo(properties);
        };

        /**
         * Encodes the specified MergePushInfo message. Does not implicitly {@link proto_switch.MergePushInfo.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.MergePushInfo
         * @static
         * @param {proto_switch.IMergePushInfo} message MergePushInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MergePushInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sub_cmd != null && Object.hasOwnProperty.call(message, "sub_cmd"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sub_cmd);
            if (message.sub_seq != null && Object.hasOwnProperty.call(message, "sub_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sub_seq);
            if (message.sender_nid != null && Object.hasOwnProperty.call(message, "sender_nid"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.sender_nid);
            if (message.msg_id != null && Object.hasOwnProperty.call(message, "msg_id"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.msg_id);
            if (message.msg_body != null && Object.hasOwnProperty.call(message, "msg_body"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.msg_body);
            if (message.msg_timestamp != null && Object.hasOwnProperty.call(message, "msg_timestamp"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.msg_timestamp);
            return writer;
        };

        /**
         * Decodes a MergePushInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.MergePushInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.MergePushInfo} MergePushInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MergePushInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.MergePushInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sub_cmd = reader.string();
                    break;
                case 2:
                    message.sub_seq = reader.uint32();
                    break;
                case 3:
                    message.sender_nid = reader.uint64();
                    break;
                case 4:
                    message.msg_id = reader.bytes();
                    break;
                case 5:
                    message.msg_body = reader.bytes();
                    break;
                case 6:
                    message.msg_timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MergePushInfo;
    })();

    proto_switch.CmdMergePushReq = (function() {

        /**
         * Properties of a CmdMergePushReq.
         * @memberof proto_switch
         * @interface ICmdMergePushReq
         * @property {proto_switch.IMergePushHead|null} [head] CmdMergePushReq head
         * @property {Array.<proto_switch.IMergePushInfo>|null} [messages] CmdMergePushReq messages
         */

        /**
         * Constructs a new CmdMergePushReq.
         * @memberof proto_switch
         * @classdesc Represents a CmdMergePushReq.
         * @implements ICmdMergePushReq
         * @constructor
         * @param {proto_switch.ICmdMergePushReq=} [properties] Properties to set
         */
        function CmdMergePushReq(properties) {
            this.messages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CmdMergePushReq head.
         * @member {proto_switch.IMergePushHead|null|undefined} head
         * @memberof proto_switch.CmdMergePushReq
         * @instance
         */
        CmdMergePushReq.prototype.head = null;

        /**
         * CmdMergePushReq messages.
         * @member {Array.<proto_switch.IMergePushInfo>} messages
         * @memberof proto_switch.CmdMergePushReq
         * @instance
         */
        CmdMergePushReq.prototype.messages = $util.emptyArray;

        /**
         * Creates a new CmdMergePushReq instance using the specified properties.
         * @function create
         * @memberof proto_switch.CmdMergePushReq
         * @static
         * @param {proto_switch.ICmdMergePushReq=} [properties] Properties to set
         * @returns {proto_switch.CmdMergePushReq} CmdMergePushReq instance
         */
        CmdMergePushReq.create = function create(properties) {
            return new CmdMergePushReq(properties);
        };

        /**
         * Encodes the specified CmdMergePushReq message. Does not implicitly {@link proto_switch.CmdMergePushReq.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.CmdMergePushReq
         * @static
         * @param {proto_switch.ICmdMergePushReq} message CmdMergePushReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CmdMergePushReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.head != null && Object.hasOwnProperty.call(message, "head"))
                $root.proto_switch.MergePushHead.encode(message.head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.proto_switch.MergePushInfo.encode(message.messages[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a CmdMergePushReq message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.CmdMergePushReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.CmdMergePushReq} CmdMergePushReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CmdMergePushReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.CmdMergePushReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.head = $root.proto_switch.MergePushHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push($root.proto_switch.MergePushInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return CmdMergePushReq;
    })();

    proto_switch.CmdMergePushRspInfo = (function() {

        /**
         * Properties of a CmdMergePushRspInfo.
         * @memberof proto_switch
         * @interface ICmdMergePushRspInfo
         * @property {string|null} [sub_cmd] CmdMergePushRspInfo sub_cmd
         * @property {number|null} [sub_seq] CmdMergePushRspInfo sub_seq
         * @property {Uint8Array|null} [msg_id] CmdMergePushRspInfo msg_id
         */

        /**
         * Constructs a new CmdMergePushRspInfo.
         * @memberof proto_switch
         * @classdesc Represents a CmdMergePushRspInfo.
         * @implements ICmdMergePushRspInfo
         * @constructor
         * @param {proto_switch.ICmdMergePushRspInfo=} [properties] Properties to set
         */
        function CmdMergePushRspInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CmdMergePushRspInfo sub_cmd.
         * @member {string} sub_cmd
         * @memberof proto_switch.CmdMergePushRspInfo
         * @instance
         */
        CmdMergePushRspInfo.prototype.sub_cmd = "";

        /**
         * CmdMergePushRspInfo sub_seq.
         * @member {number} sub_seq
         * @memberof proto_switch.CmdMergePushRspInfo
         * @instance
         */
        CmdMergePushRspInfo.prototype.sub_seq = 0;

        /**
         * CmdMergePushRspInfo msg_id.
         * @member {Uint8Array} msg_id
         * @memberof proto_switch.CmdMergePushRspInfo
         * @instance
         */
        CmdMergePushRspInfo.prototype.msg_id = $util.newBuffer([]);

        /**
         * Creates a new CmdMergePushRspInfo instance using the specified properties.
         * @function create
         * @memberof proto_switch.CmdMergePushRspInfo
         * @static
         * @param {proto_switch.ICmdMergePushRspInfo=} [properties] Properties to set
         * @returns {proto_switch.CmdMergePushRspInfo} CmdMergePushRspInfo instance
         */
        CmdMergePushRspInfo.create = function create(properties) {
            return new CmdMergePushRspInfo(properties);
        };

        /**
         * Encodes the specified CmdMergePushRspInfo message. Does not implicitly {@link proto_switch.CmdMergePushRspInfo.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.CmdMergePushRspInfo
         * @static
         * @param {proto_switch.ICmdMergePushRspInfo} message CmdMergePushRspInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CmdMergePushRspInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sub_cmd != null && Object.hasOwnProperty.call(message, "sub_cmd"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sub_cmd);
            if (message.sub_seq != null && Object.hasOwnProperty.call(message, "sub_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sub_seq);
            if (message.msg_id != null && Object.hasOwnProperty.call(message, "msg_id"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.msg_id);
            return writer;
        };

        /**
         * Decodes a CmdMergePushRspInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.CmdMergePushRspInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.CmdMergePushRspInfo} CmdMergePushRspInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CmdMergePushRspInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.CmdMergePushRspInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sub_cmd = reader.string();
                    break;
                case 2:
                    message.sub_seq = reader.uint32();
                    break;
                case 3:
                    message.msg_id = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return CmdMergePushRspInfo;
    })();

    proto_switch.CmdMergePushRsp = (function() {

        /**
         * Properties of a CmdMergePushRsp.
         * @memberof proto_switch
         * @interface ICmdMergePushRsp
         * @property {Array.<proto_switch.ICmdMergePushRspInfo>|null} [messages] CmdMergePushRsp messages
         */

        /**
         * Constructs a new CmdMergePushRsp.
         * @memberof proto_switch
         * @classdesc Represents a CmdMergePushRsp.
         * @implements ICmdMergePushRsp
         * @constructor
         * @param {proto_switch.ICmdMergePushRsp=} [properties] Properties to set
         */
        function CmdMergePushRsp(properties) {
            this.messages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CmdMergePushRsp messages.
         * @member {Array.<proto_switch.ICmdMergePushRspInfo>} messages
         * @memberof proto_switch.CmdMergePushRsp
         * @instance
         */
        CmdMergePushRsp.prototype.messages = $util.emptyArray;

        /**
         * Creates a new CmdMergePushRsp instance using the specified properties.
         * @function create
         * @memberof proto_switch.CmdMergePushRsp
         * @static
         * @param {proto_switch.ICmdMergePushRsp=} [properties] Properties to set
         * @returns {proto_switch.CmdMergePushRsp} CmdMergePushRsp instance
         */
        CmdMergePushRsp.create = function create(properties) {
            return new CmdMergePushRsp(properties);
        };

        /**
         * Encodes the specified CmdMergePushRsp message. Does not implicitly {@link proto_switch.CmdMergePushRsp.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.CmdMergePushRsp
         * @static
         * @param {proto_switch.ICmdMergePushRsp} message CmdMergePushRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CmdMergePushRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.proto_switch.CmdMergePushRspInfo.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a CmdMergePushRsp message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.CmdMergePushRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.CmdMergePushRsp} CmdMergePushRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CmdMergePushRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.CmdMergePushRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push($root.proto_switch.CmdMergePushRspInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return CmdMergePushRsp;
    })();

    return proto_switch;
})();

$root.liveroom_cs = (function() {

    /**
     * Namespace liveroom_cs.
     * @exports liveroom_cs
     * @namespace
     */
    var liveroom_cs = {};

    liveroom_cs.ReqHead = (function() {

        /**
         * Properties of a ReqHead.
         * @memberof liveroom_cs
         * @interface IReqHead
         * @property {string|null} [room_id] ReqHead room_id
         * @property {number|Long|null} [user_session_id] ReqHead user_session_id
         * @property {number|Long|null} [room_session_id] ReqHead room_session_id
         */

        /**
         * Constructs a new ReqHead.
         * @memberof liveroom_cs
         * @classdesc -title:liveroom_pb协议请求包头
         * @implements IReqHead
         * @constructor
         * @param {liveroom_cs.IReqHead=} [properties] Properties to set
         */
        function ReqHead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReqHead room_id.
         * @member {string} room_id
         * @memberof liveroom_cs.ReqHead
         * @instance
         */
        ReqHead.prototype.room_id = "";

        /**
         * ReqHead user_session_id.
         * @member {number|Long} user_session_id
         * @memberof liveroom_cs.ReqHead
         * @instance
         */
        ReqHead.prototype.user_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ReqHead room_session_id.
         * @member {number|Long} room_session_id
         * @memberof liveroom_cs.ReqHead
         * @instance
         */
        ReqHead.prototype.room_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ReqHead instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.ReqHead
         * @static
         * @param {liveroom_cs.IReqHead=} [properties] Properties to set
         * @returns {liveroom_cs.ReqHead} ReqHead instance
         */
        ReqHead.create = function create(properties) {
            return new ReqHead(properties);
        };

        /**
         * Encodes the specified ReqHead message. Does not implicitly {@link liveroom_cs.ReqHead.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.ReqHead
         * @static
         * @param {liveroom_cs.IReqHead} message ReqHead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReqHead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.room_id);
            if (message.user_session_id != null && Object.hasOwnProperty.call(message, "user_session_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.user_session_id);
            if (message.room_session_id != null && Object.hasOwnProperty.call(message, "room_session_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.room_session_id);
            return writer;
        };

        /**
         * Decodes a ReqHead message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.ReqHead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.ReqHead} ReqHead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReqHead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.ReqHead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.room_id = reader.string();
                    break;
                case 2:
                    message.user_session_id = reader.uint64();
                    break;
                case 3:
                    message.room_session_id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ReqHead;
    })();

    liveroom_cs.RspHead = (function() {

        /**
         * Properties of a RspHead.
         * @memberof liveroom_cs
         * @interface IRspHead
         * @property {number|null} [code] RspHead code
         * @property {string|null} [message] RspHead message
         */

        /**
         * Constructs a new RspHead.
         * @memberof liveroom_cs
         * @classdesc -title:liveroom_pb协议应答包头
         * @implements IRspHead
         * @constructor
         * @param {liveroom_cs.IRspHead=} [properties] Properties to set
         */
        function RspHead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RspHead code.
         * @member {number} code
         * @memberof liveroom_cs.RspHead
         * @instance
         */
        RspHead.prototype.code = 0;

        /**
         * RspHead message.
         * @member {string} message
         * @memberof liveroom_cs.RspHead
         * @instance
         */
        RspHead.prototype.message = "";

        /**
         * Creates a new RspHead instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.RspHead
         * @static
         * @param {liveroom_cs.IRspHead=} [properties] Properties to set
         * @returns {liveroom_cs.RspHead} RspHead instance
         */
        RspHead.create = function create(properties) {
            return new RspHead(properties);
        };

        /**
         * Encodes the specified RspHead message. Does not implicitly {@link liveroom_cs.RspHead.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.RspHead
         * @static
         * @param {liveroom_cs.IRspHead} message RspHead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RspHead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.code);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            return writer;
        };

        /**
         * Decodes a RspHead message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.RspHead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.RspHead} RspHead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RspHead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.RspHead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.uint32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RspHead;
    })();

    liveroom_cs.CommonRsp = (function() {

        /**
         * Properties of a CommonRsp.
         * @memberof liveroom_cs
         * @interface ICommonRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] CommonRsp rsp_head
         */

        /**
         * Constructs a new CommonRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a CommonRsp.
         * @implements ICommonRsp
         * @constructor
         * @param {liveroom_cs.ICommonRsp=} [properties] Properties to set
         */
        function CommonRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommonRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.CommonRsp
         * @instance
         */
        CommonRsp.prototype.rsp_head = null;

        /**
         * Creates a new CommonRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.CommonRsp
         * @static
         * @param {liveroom_cs.ICommonRsp=} [properties] Properties to set
         * @returns {liveroom_cs.CommonRsp} CommonRsp instance
         */
        CommonRsp.create = function create(properties) {
            return new CommonRsp(properties);
        };

        /**
         * Encodes the specified CommonRsp message. Does not implicitly {@link liveroom_cs.CommonRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.CommonRsp
         * @static
         * @param {liveroom_cs.ICommonRsp} message CommonRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a CommonRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.CommonRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.CommonRsp} CommonRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.CommonRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return CommonRsp;
    })();

    liveroom_cs.HbReq = (function() {

        /**
         * Properties of a HbReq.
         * @memberof liveroom_cs
         * @interface IHbReq
         * @property {liveroom_cs.IReqHead|null} [req_head] HbReq req_head
         * @property {number|null} [role] HbReq role
         * @property {string|null} [lv_key] HbReq lv_key
         */

        /**
         * Constructs a new HbReq.
         * @memberof liveroom_cs
         * @classdesc -title:liveroom 心跳请求(/liveroompb/hb)
         * cmd: /lr/room/hb
         * @implements IHbReq
         * @constructor
         * @param {liveroom_cs.IHbReq=} [properties] Properties to set
         */
        function HbReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HbReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.HbReq
         * @instance
         */
        HbReq.prototype.req_head = null;

        /**
         * HbReq role.
         * @member {number} role
         * @memberof liveroom_cs.HbReq
         * @instance
         */
        HbReq.prototype.role = 0;

        /**
         * HbReq lv_key.
         * @member {string} lv_key
         * @memberof liveroom_cs.HbReq
         * @instance
         */
        HbReq.prototype.lv_key = "";

        /**
         * Creates a new HbReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.HbReq
         * @static
         * @param {liveroom_cs.IHbReq=} [properties] Properties to set
         * @returns {liveroom_cs.HbReq} HbReq instance
         */
        HbReq.create = function create(properties) {
            return new HbReq(properties);
        };

        /**
         * Encodes the specified HbReq message. Does not implicitly {@link liveroom_cs.HbReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.HbReq
         * @static
         * @param {liveroom_cs.IHbReq} message HbReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HbReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.role);
            if (message.lv_key != null && Object.hasOwnProperty.call(message, "lv_key"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.lv_key);
            return writer;
        };

        /**
         * Decodes a HbReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.HbReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.HbReq} HbReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HbReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.HbReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.role = reader.uint32();
                    break;
                case 3:
                    message.lv_key = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return HbReq;
    })();

    liveroom_cs.HbRsp = (function() {

        /**
         * Properties of a HbRsp.
         * @memberof liveroom_cs
         * @interface IHbRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] HbRsp rsp_head
         * @property {number|Long|null} [ret_timestamp] HbRsp ret_timestamp
         * @property {number|null} [hb_interval] HbRsp hb_interval
         * @property {number|null} [hb_timeout] HbRsp hb_timeout
         * @property {number|null} [stream_seq] HbRsp stream_seq
         * @property {number|Long|null} [user_seq] HbRsp user_seq
         * @property {number|null} [online_count] HbRsp online_count
         * @property {number|null} [bigim_time_window] HbRsp bigim_time_window
         * @property {number|Long|null} [dati_time_window] HbRsp dati_time_window
         * @property {Array.<liveroom_cs.IStTransChannelSeq>|null} [trans_seqs] HbRsp trans_seqs
         * @property {Array.<liveroom_cs.IStTransChannelSeq>|null} [user_trans_seqs] HbRsp user_trans_seqs
         * @property {number|null} [StreamRefresh] HbRsp StreamRefresh
         * @property {number|null} [trans_list_seq] HbRsp trans_list_seq
         */

        /**
         * Constructs a new HbRsp.
         * @memberof liveroom_cs
         * @classdesc -title:liveroom 心跳应答
         * cmd: /lr/room/hb_rsp
         * @implements IHbRsp
         * @constructor
         * @param {liveroom_cs.IHbRsp=} [properties] Properties to set
         */
        function HbRsp(properties) {
            this.trans_seqs = [];
            this.user_trans_seqs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HbRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.rsp_head = null;

        /**
         * HbRsp ret_timestamp.
         * @member {number|Long} ret_timestamp
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.ret_timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * HbRsp hb_interval.
         * @member {number} hb_interval
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.hb_interval = 0;

        /**
         * HbRsp hb_timeout.
         * @member {number} hb_timeout
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.hb_timeout = 0;

        /**
         * HbRsp stream_seq.
         * @member {number} stream_seq
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.stream_seq = 0;

        /**
         * HbRsp user_seq.
         * @member {number|Long} user_seq
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.user_seq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * HbRsp online_count.
         * @member {number} online_count
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.online_count = 0;

        /**
         * HbRsp bigim_time_window.
         * @member {number} bigim_time_window
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.bigim_time_window = 0;

        /**
         * HbRsp dati_time_window.
         * @member {number|Long} dati_time_window
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.dati_time_window = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * HbRsp trans_seqs.
         * @member {Array.<liveroom_cs.IStTransChannelSeq>} trans_seqs
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.trans_seqs = $util.emptyArray;

        /**
         * HbRsp user_trans_seqs.
         * @member {Array.<liveroom_cs.IStTransChannelSeq>} user_trans_seqs
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.user_trans_seqs = $util.emptyArray;

        /**
         * HbRsp StreamRefresh.
         * @member {number} StreamRefresh
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.StreamRefresh = 0;

        /**
         * HbRsp trans_list_seq.
         * @member {number} trans_list_seq
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.trans_list_seq = 0;

        /**
         * Creates a new HbRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.HbRsp
         * @static
         * @param {liveroom_cs.IHbRsp=} [properties] Properties to set
         * @returns {liveroom_cs.HbRsp} HbRsp instance
         */
        HbRsp.create = function create(properties) {
            return new HbRsp(properties);
        };

        /**
         * Encodes the specified HbRsp message. Does not implicitly {@link liveroom_cs.HbRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.HbRsp
         * @static
         * @param {liveroom_cs.IHbRsp} message HbRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HbRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.ret_timestamp != null && Object.hasOwnProperty.call(message, "ret_timestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.ret_timestamp);
            if (message.hb_interval != null && Object.hasOwnProperty.call(message, "hb_interval"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.hb_interval);
            if (message.hb_timeout != null && Object.hasOwnProperty.call(message, "hb_timeout"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.hb_timeout);
            if (message.stream_seq != null && Object.hasOwnProperty.call(message, "stream_seq"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.stream_seq);
            if (message.user_seq != null && Object.hasOwnProperty.call(message, "user_seq"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.user_seq);
            if (message.online_count != null && Object.hasOwnProperty.call(message, "online_count"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.online_count);
            if (message.bigim_time_window != null && Object.hasOwnProperty.call(message, "bigim_time_window"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.bigim_time_window);
            if (message.dati_time_window != null && Object.hasOwnProperty.call(message, "dati_time_window"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.dati_time_window);
            if (message.trans_seqs != null && message.trans_seqs.length)
                for (var i = 0; i < message.trans_seqs.length; ++i)
                    $root.liveroom_cs.StTransChannelSeq.encode(message.trans_seqs[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.user_trans_seqs != null && message.user_trans_seqs.length)
                for (var i = 0; i < message.user_trans_seqs.length; ++i)
                    $root.liveroom_cs.StTransChannelSeq.encode(message.user_trans_seqs[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.StreamRefresh != null && Object.hasOwnProperty.call(message, "StreamRefresh"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.StreamRefresh);
            if (message.trans_list_seq != null && Object.hasOwnProperty.call(message, "trans_list_seq"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.trans_list_seq);
            return writer;
        };

        /**
         * Decodes a HbRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.HbRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.HbRsp} HbRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HbRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.HbRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.ret_timestamp = reader.int64();
                    break;
                case 3:
                    message.hb_interval = reader.uint32();
                    break;
                case 4:
                    message.hb_timeout = reader.uint32();
                    break;
                case 5:
                    message.stream_seq = reader.uint32();
                    break;
                case 6:
                    message.user_seq = reader.int64();
                    break;
                case 7:
                    message.online_count = reader.uint32();
                    break;
                case 8:
                    message.bigim_time_window = reader.uint32();
                    break;
                case 9:
                    message.dati_time_window = reader.int64();
                    break;
                case 10:
                    if (!(message.trans_seqs && message.trans_seqs.length))
                        message.trans_seqs = [];
                    message.trans_seqs.push($root.liveroom_cs.StTransChannelSeq.decode(reader, reader.uint32()));
                    break;
                case 11:
                    if (!(message.user_trans_seqs && message.user_trans_seqs.length))
                        message.user_trans_seqs = [];
                    message.user_trans_seqs.push($root.liveroom_cs.StTransChannelSeq.decode(reader, reader.uint32()));
                    break;
                case 12:
                    message.StreamRefresh = reader.uint32();
                    break;
                case 13:
                    message.trans_list_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return HbRsp;
    })();

    liveroom_cs.StTransSeq = (function() {

        /**
         * Properties of a StTransSeq.
         * @memberof liveroom_cs
         * @interface IStTransSeq
         * @property {Uint8Array|null} [trans_type] StTransSeq trans_type
         * @property {number|null} [trans_seq] StTransSeq trans_seq
         */

        /**
         * Constructs a new StTransSeq.
         * @memberof liveroom_cs
         * @classdesc Represents a StTransSeq.
         * @implements IStTransSeq
         * @constructor
         * @param {liveroom_cs.IStTransSeq=} [properties] Properties to set
         */
        function StTransSeq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StTransSeq trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.StTransSeq
         * @instance
         */
        StTransSeq.prototype.trans_type = $util.newBuffer([]);

        /**
         * StTransSeq trans_seq.
         * @member {number} trans_seq
         * @memberof liveroom_cs.StTransSeq
         * @instance
         */
        StTransSeq.prototype.trans_seq = 0;

        /**
         * Creates a new StTransSeq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StTransSeq
         * @static
         * @param {liveroom_cs.IStTransSeq=} [properties] Properties to set
         * @returns {liveroom_cs.StTransSeq} StTransSeq instance
         */
        StTransSeq.create = function create(properties) {
            return new StTransSeq(properties);
        };

        /**
         * Encodes the specified StTransSeq message. Does not implicitly {@link liveroom_cs.StTransSeq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StTransSeq
         * @static
         * @param {liveroom_cs.IStTransSeq} message StTransSeq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StTransSeq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_type);
            if (message.trans_seq != null && Object.hasOwnProperty.call(message, "trans_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.trans_seq);
            return writer;
        };

        /**
         * Decodes a StTransSeq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StTransSeq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StTransSeq} StTransSeq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StTransSeq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StTransSeq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_type = reader.bytes();
                    break;
                case 2:
                    message.trans_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StTransSeq;
    })();

    liveroom_cs.StTransChannelSeq = (function() {

        /**
         * Properties of a StTransChannelSeq.
         * @memberof liveroom_cs
         * @interface IStTransChannelSeq
         * @property {Uint8Array|null} [trans_channel] StTransChannelSeq trans_channel
         * @property {Array.<liveroom_cs.IStTransSeq>|null} [trans_seq_array] StTransChannelSeq trans_seq_array
         */

        /**
         * Constructs a new StTransChannelSeq.
         * @memberof liveroom_cs
         * @classdesc Represents a StTransChannelSeq.
         * @implements IStTransChannelSeq
         * @constructor
         * @param {liveroom_cs.IStTransChannelSeq=} [properties] Properties to set
         */
        function StTransChannelSeq(properties) {
            this.trans_seq_array = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StTransChannelSeq trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.StTransChannelSeq
         * @instance
         */
        StTransChannelSeq.prototype.trans_channel = $util.newBuffer([]);

        /**
         * StTransChannelSeq trans_seq_array.
         * @member {Array.<liveroom_cs.IStTransSeq>} trans_seq_array
         * @memberof liveroom_cs.StTransChannelSeq
         * @instance
         */
        StTransChannelSeq.prototype.trans_seq_array = $util.emptyArray;

        /**
         * Creates a new StTransChannelSeq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StTransChannelSeq
         * @static
         * @param {liveroom_cs.IStTransChannelSeq=} [properties] Properties to set
         * @returns {liveroom_cs.StTransChannelSeq} StTransChannelSeq instance
         */
        StTransChannelSeq.create = function create(properties) {
            return new StTransChannelSeq(properties);
        };

        /**
         * Encodes the specified StTransChannelSeq message. Does not implicitly {@link liveroom_cs.StTransChannelSeq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StTransChannelSeq
         * @static
         * @param {liveroom_cs.IStTransChannelSeq} message StTransChannelSeq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StTransChannelSeq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_channel);
            if (message.trans_seq_array != null && message.trans_seq_array.length)
                for (var i = 0; i < message.trans_seq_array.length; ++i)
                    $root.liveroom_cs.StTransSeq.encode(message.trans_seq_array[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a StTransChannelSeq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StTransChannelSeq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StTransChannelSeq} StTransChannelSeq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StTransChannelSeq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StTransChannelSeq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_channel = reader.bytes();
                    break;
                case 2:
                    if (!(message.trans_seq_array && message.trans_seq_array.length))
                        message.trans_seq_array = [];
                    message.trans_seq_array.push($root.liveroom_cs.StTransSeq.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StTransChannelSeq;
    })();

    liveroom_cs.UserlistReq = (function() {

        /**
         * Properties of a UserlistReq.
         * @memberof liveroom_cs
         * @interface IUserlistReq
         * @property {liveroom_cs.IReqHead|null} [req_head] UserlistReq req_head
         * @property {number|null} [sort_type] UserlistReq sort_type
         * @property {number|null} [user_index] UserlistReq user_index
         */

        /**
         * Constructs a new UserlistReq.
         * @memberof liveroom_cs
         * @classdesc Represents a UserlistReq.
         * @implements IUserlistReq
         * @constructor
         * @param {liveroom_cs.IUserlistReq=} [properties] Properties to set
         */
        function UserlistReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserlistReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.UserlistReq
         * @instance
         */
        UserlistReq.prototype.req_head = null;

        /**
         * UserlistReq sort_type.
         * @member {number} sort_type
         * @memberof liveroom_cs.UserlistReq
         * @instance
         */
        UserlistReq.prototype.sort_type = 0;

        /**
         * UserlistReq user_index.
         * @member {number} user_index
         * @memberof liveroom_cs.UserlistReq
         * @instance
         */
        UserlistReq.prototype.user_index = 0;

        /**
         * Creates a new UserlistReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.UserlistReq
         * @static
         * @param {liveroom_cs.IUserlistReq=} [properties] Properties to set
         * @returns {liveroom_cs.UserlistReq} UserlistReq instance
         */
        UserlistReq.create = function create(properties) {
            return new UserlistReq(properties);
        };

        /**
         * Encodes the specified UserlistReq message. Does not implicitly {@link liveroom_cs.UserlistReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.UserlistReq
         * @static
         * @param {liveroom_cs.IUserlistReq} message UserlistReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserlistReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sort_type != null && Object.hasOwnProperty.call(message, "sort_type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sort_type);
            if (message.user_index != null && Object.hasOwnProperty.call(message, "user_index"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.user_index);
            return writer;
        };

        /**
         * Decodes a UserlistReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.UserlistReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.UserlistReq} UserlistReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserlistReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.UserlistReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.sort_type = reader.uint32();
                    break;
                case 3:
                    message.user_index = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return UserlistReq;
    })();

    liveroom_cs.UserlistRsp = (function() {

        /**
         * Properties of a UserlistRsp.
         * @memberof liveroom_cs
         * @interface IUserlistRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] UserlistRsp rsp_head
         * @property {number|Long|null} [server_user_seq] UserlistRsp server_user_seq
         * @property {number|Long|null} [server_user_index] UserlistRsp server_user_index
         * @property {number|Long|null} [ret_user_index] UserlistRsp ret_user_index
         * @property {Array.<liveroom_cs.IStUserBasicDef>|null} [user_basic_list] UserlistRsp user_basic_list
         */

        /**
         * Constructs a new UserlistRsp.
         * @memberof liveroom_cs
         * @classdesc -title:liveroom userlist应答
         * cmd: /lr/userlist/userlist_rsp
         * @implements IUserlistRsp
         * @constructor
         * @param {liveroom_cs.IUserlistRsp=} [properties] Properties to set
         */
        function UserlistRsp(properties) {
            this.user_basic_list = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserlistRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.UserlistRsp
         * @instance
         */
        UserlistRsp.prototype.rsp_head = null;

        /**
         * UserlistRsp server_user_seq.
         * @member {number|Long} server_user_seq
         * @memberof liveroom_cs.UserlistRsp
         * @instance
         */
        UserlistRsp.prototype.server_user_seq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * UserlistRsp server_user_index.
         * @member {number|Long} server_user_index
         * @memberof liveroom_cs.UserlistRsp
         * @instance
         */
        UserlistRsp.prototype.server_user_index = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UserlistRsp ret_user_index.
         * @member {number|Long} ret_user_index
         * @memberof liveroom_cs.UserlistRsp
         * @instance
         */
        UserlistRsp.prototype.ret_user_index = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UserlistRsp user_basic_list.
         * @member {Array.<liveroom_cs.IStUserBasicDef>} user_basic_list
         * @memberof liveroom_cs.UserlistRsp
         * @instance
         */
        UserlistRsp.prototype.user_basic_list = $util.emptyArray;

        /**
         * Creates a new UserlistRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.UserlistRsp
         * @static
         * @param {liveroom_cs.IUserlistRsp=} [properties] Properties to set
         * @returns {liveroom_cs.UserlistRsp} UserlistRsp instance
         */
        UserlistRsp.create = function create(properties) {
            return new UserlistRsp(properties);
        };

        /**
         * Encodes the specified UserlistRsp message. Does not implicitly {@link liveroom_cs.UserlistRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.UserlistRsp
         * @static
         * @param {liveroom_cs.IUserlistRsp} message UserlistRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserlistRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.server_user_seq != null && Object.hasOwnProperty.call(message, "server_user_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.server_user_seq);
            if (message.server_user_index != null && Object.hasOwnProperty.call(message, "server_user_index"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.server_user_index);
            if (message.ret_user_index != null && Object.hasOwnProperty.call(message, "ret_user_index"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.ret_user_index);
            if (message.user_basic_list != null && message.user_basic_list.length)
                for (var i = 0; i < message.user_basic_list.length; ++i)
                    $root.liveroom_cs.StUserBasicDef.encode(message.user_basic_list[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a UserlistRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.UserlistRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.UserlistRsp} UserlistRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserlistRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.UserlistRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.server_user_seq = reader.uint64();
                    break;
                case 3:
                    message.server_user_index = reader.int64();
                    break;
                case 4:
                    message.ret_user_index = reader.int64();
                    break;
                case 5:
                    if (!(message.user_basic_list && message.user_basic_list.length))
                        message.user_basic_list = [];
                    message.user_basic_list.push($root.liveroom_cs.StUserBasicDef.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return UserlistRsp;
    })();

    liveroom_cs.StUserBasicDef = (function() {

        /**
         * Properties of a StUserBasicDef.
         * @memberof liveroom_cs
         * @interface IStUserBasicDef
         * @property {Uint8Array|null} [id_name] StUserBasicDef id_name
         * @property {Uint8Array|null} [nick_name] StUserBasicDef nick_name
         * @property {number|null} [role] StUserBasicDef role
         */

        /**
         * Constructs a new StUserBasicDef.
         * @memberof liveroom_cs
         * @classdesc Represents a StUserBasicDef.
         * @implements IStUserBasicDef
         * @constructor
         * @param {liveroom_cs.IStUserBasicDef=} [properties] Properties to set
         */
        function StUserBasicDef(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StUserBasicDef id_name.
         * @member {Uint8Array} id_name
         * @memberof liveroom_cs.StUserBasicDef
         * @instance
         */
        StUserBasicDef.prototype.id_name = $util.newBuffer([]);

        /**
         * StUserBasicDef nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.StUserBasicDef
         * @instance
         */
        StUserBasicDef.prototype.nick_name = $util.newBuffer([]);

        /**
         * StUserBasicDef role.
         * @member {number} role
         * @memberof liveroom_cs.StUserBasicDef
         * @instance
         */
        StUserBasicDef.prototype.role = 0;

        /**
         * Creates a new StUserBasicDef instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StUserBasicDef
         * @static
         * @param {liveroom_cs.IStUserBasicDef=} [properties] Properties to set
         * @returns {liveroom_cs.StUserBasicDef} StUserBasicDef instance
         */
        StUserBasicDef.create = function create(properties) {
            return new StUserBasicDef(properties);
        };

        /**
         * Encodes the specified StUserBasicDef message. Does not implicitly {@link liveroom_cs.StUserBasicDef.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StUserBasicDef
         * @static
         * @param {liveroom_cs.IStUserBasicDef} message StUserBasicDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StUserBasicDef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id_name);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.role);
            return writer;
        };

        /**
         * Decodes a StUserBasicDef message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StUserBasicDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StUserBasicDef} StUserBasicDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StUserBasicDef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StUserBasicDef();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id_name = reader.bytes();
                    break;
                case 2:
                    message.nick_name = reader.bytes();
                    break;
                case 3:
                    message.role = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StUserBasicDef;
    })();

    liveroom_cs.StreamAddReq = (function() {

        /**
         * Properties of a StreamAddReq.
         * @memberof liveroom_cs
         * @interface IStreamAddReq
         * @property {liveroom_cs.IReqHead|null} [req_head] StreamAddReq req_head
         * @property {Uint8Array|null} [stream_id] StreamAddReq stream_id
         * @property {Uint8Array|null} [title] StreamAddReq title
         * @property {Uint8Array|null} [stream_attr] StreamAddReq stream_attr
         * @property {Uint8Array|null} [extra_info] StreamAddReq extra_info
         * @property {number|null} [client_req_seq] StreamAddReq client_req_seq
         * @property {Uint8Array|null} [nickname] StreamAddReq nickname
         * @property {number|null} [login_mode] StreamAddReq login_mode
         * @property {number|null} [stream_type] StreamAddReq stream_type
         * @property {Uint8Array|null} [third_token] StreamAddReq third_token
         */

        /**
         * Constructs a new StreamAddReq.
         * @memberof liveroom_cs
         * @classdesc Represents a StreamAddReq.
         * @implements IStreamAddReq
         * @constructor
         * @param {liveroom_cs.IStreamAddReq=} [properties] Properties to set
         */
        function StreamAddReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamAddReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.req_head = null;

        /**
         * StreamAddReq stream_id.
         * @member {Uint8Array} stream_id
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.stream_id = $util.newBuffer([]);

        /**
         * StreamAddReq title.
         * @member {Uint8Array} title
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.title = $util.newBuffer([]);

        /**
         * StreamAddReq stream_attr.
         * @member {Uint8Array} stream_attr
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.stream_attr = $util.newBuffer([]);

        /**
         * StreamAddReq extra_info.
         * @member {Uint8Array} extra_info
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.extra_info = $util.newBuffer([]);

        /**
         * StreamAddReq client_req_seq.
         * @member {number} client_req_seq
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.client_req_seq = 0;

        /**
         * StreamAddReq nickname.
         * @member {Uint8Array} nickname
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.nickname = $util.newBuffer([]);

        /**
         * StreamAddReq login_mode.
         * @member {number} login_mode
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.login_mode = 0;

        /**
         * StreamAddReq stream_type.
         * @member {number} stream_type
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.stream_type = 0;

        /**
         * StreamAddReq third_token.
         * @member {Uint8Array} third_token
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.third_token = $util.newBuffer([]);

        /**
         * Creates a new StreamAddReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StreamAddReq
         * @static
         * @param {liveroom_cs.IStreamAddReq=} [properties] Properties to set
         * @returns {liveroom_cs.StreamAddReq} StreamAddReq instance
         */
        StreamAddReq.create = function create(properties) {
            return new StreamAddReq(properties);
        };

        /**
         * Encodes the specified StreamAddReq message. Does not implicitly {@link liveroom_cs.StreamAddReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StreamAddReq
         * @static
         * @param {liveroom_cs.IStreamAddReq} message StreamAddReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamAddReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.stream_id);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.title);
            if (message.stream_attr != null && Object.hasOwnProperty.call(message, "stream_attr"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.stream_attr);
            if (message.extra_info != null && Object.hasOwnProperty.call(message, "extra_info"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.extra_info);
            if (message.client_req_seq != null && Object.hasOwnProperty.call(message, "client_req_seq"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.client_req_seq);
            if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.nickname);
            if (message.login_mode != null && Object.hasOwnProperty.call(message, "login_mode"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.login_mode);
            if (message.stream_type != null && Object.hasOwnProperty.call(message, "stream_type"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.stream_type);
            if (message.third_token != null && Object.hasOwnProperty.call(message, "third_token"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.third_token);
            return writer;
        };

        /**
         * Decodes a StreamAddReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StreamAddReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StreamAddReq} StreamAddReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamAddReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StreamAddReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.stream_id = reader.bytes();
                    break;
                case 3:
                    message.title = reader.bytes();
                    break;
                case 4:
                    message.stream_attr = reader.bytes();
                    break;
                case 5:
                    message.extra_info = reader.bytes();
                    break;
                case 6:
                    message.client_req_seq = reader.uint32();
                    break;
                case 7:
                    message.nickname = reader.bytes();
                    break;
                case 8:
                    message.login_mode = reader.uint32();
                    break;
                case 9:
                    message.stream_type = reader.uint32();
                    break;
                case 10:
                    message.third_token = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StreamAddReq;
    })();

    liveroom_cs.StreamAddRsp = (function() {

        /**
         * Properties of a StreamAddRsp.
         * @memberof liveroom_cs
         * @interface IStreamAddRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] StreamAddRsp rsp_head
         * @property {number|null} [stream_seq] StreamAddRsp stream_seq
         * @property {string|null} [stream_sid] StreamAddRsp stream_sid
         * @property {number|null} [stream_ver] StreamAddRsp stream_ver
         * @property {number|null} [stream_nid] StreamAddRsp stream_nid
         * @property {number|null} [token_remain_time] StreamAddRsp token_remain_time
         */

        /**
         * Constructs a new StreamAddRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a StreamAddRsp.
         * @implements IStreamAddRsp
         * @constructor
         * @param {liveroom_cs.IStreamAddRsp=} [properties] Properties to set
         */
        function StreamAddRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamAddRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.StreamAddRsp
         * @instance
         */
        StreamAddRsp.prototype.rsp_head = null;

        /**
         * StreamAddRsp stream_seq.
         * @member {number} stream_seq
         * @memberof liveroom_cs.StreamAddRsp
         * @instance
         */
        StreamAddRsp.prototype.stream_seq = 0;

        /**
         * StreamAddRsp stream_sid.
         * @member {string} stream_sid
         * @memberof liveroom_cs.StreamAddRsp
         * @instance
         */
        StreamAddRsp.prototype.stream_sid = "";

        /**
         * StreamAddRsp stream_ver.
         * @member {number} stream_ver
         * @memberof liveroom_cs.StreamAddRsp
         * @instance
         */
        StreamAddRsp.prototype.stream_ver = 0;

        /**
         * StreamAddRsp stream_nid.
         * @member {number} stream_nid
         * @memberof liveroom_cs.StreamAddRsp
         * @instance
         */
        StreamAddRsp.prototype.stream_nid = 0;

        /**
         * StreamAddRsp token_remain_time.
         * @member {number} token_remain_time
         * @memberof liveroom_cs.StreamAddRsp
         * @instance
         */
        StreamAddRsp.prototype.token_remain_time = 0;

        /**
         * Creates a new StreamAddRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StreamAddRsp
         * @static
         * @param {liveroom_cs.IStreamAddRsp=} [properties] Properties to set
         * @returns {liveroom_cs.StreamAddRsp} StreamAddRsp instance
         */
        StreamAddRsp.create = function create(properties) {
            return new StreamAddRsp(properties);
        };

        /**
         * Encodes the specified StreamAddRsp message. Does not implicitly {@link liveroom_cs.StreamAddRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StreamAddRsp
         * @static
         * @param {liveroom_cs.IStreamAddRsp} message StreamAddRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamAddRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.stream_seq != null && Object.hasOwnProperty.call(message, "stream_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stream_seq);
            if (message.stream_sid != null && Object.hasOwnProperty.call(message, "stream_sid"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.stream_sid);
            if (message.stream_ver != null && Object.hasOwnProperty.call(message, "stream_ver"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.stream_ver);
            if (message.stream_nid != null && Object.hasOwnProperty.call(message, "stream_nid"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.stream_nid);
            if (message.token_remain_time != null && Object.hasOwnProperty.call(message, "token_remain_time"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.token_remain_time);
            return writer;
        };

        /**
         * Decodes a StreamAddRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StreamAddRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StreamAddRsp} StreamAddRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamAddRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StreamAddRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.stream_seq = reader.uint32();
                    break;
                case 3:
                    message.stream_sid = reader.string();
                    break;
                case 4:
                    message.stream_ver = reader.uint32();
                    break;
                case 5:
                    message.stream_nid = reader.uint32();
                    break;
                case 6:
                    message.token_remain_time = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StreamAddRsp;
    })();

    liveroom_cs.StreamDeleteReq = (function() {

        /**
         * Properties of a StreamDeleteReq.
         * @memberof liveroom_cs
         * @interface IStreamDeleteReq
         * @property {liveroom_cs.IReqHead|null} [req_head] StreamDeleteReq req_head
         * @property {string|null} [stream_sid] StreamDeleteReq stream_sid
         * @property {Uint8Array|null} [stream_id] StreamDeleteReq stream_id
         * @property {number|null} [client_req_seq] StreamDeleteReq client_req_seq
         */

        /**
         * Constructs a new StreamDeleteReq.
         * @memberof liveroom_cs
         * @classdesc Represents a StreamDeleteReq.
         * @implements IStreamDeleteReq
         * @constructor
         * @param {liveroom_cs.IStreamDeleteReq=} [properties] Properties to set
         */
        function StreamDeleteReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamDeleteReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.StreamDeleteReq
         * @instance
         */
        StreamDeleteReq.prototype.req_head = null;

        /**
         * StreamDeleteReq stream_sid.
         * @member {string} stream_sid
         * @memberof liveroom_cs.StreamDeleteReq
         * @instance
         */
        StreamDeleteReq.prototype.stream_sid = "";

        /**
         * StreamDeleteReq stream_id.
         * @member {Uint8Array} stream_id
         * @memberof liveroom_cs.StreamDeleteReq
         * @instance
         */
        StreamDeleteReq.prototype.stream_id = $util.newBuffer([]);

        /**
         * StreamDeleteReq client_req_seq.
         * @member {number} client_req_seq
         * @memberof liveroom_cs.StreamDeleteReq
         * @instance
         */
        StreamDeleteReq.prototype.client_req_seq = 0;

        /**
         * Creates a new StreamDeleteReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StreamDeleteReq
         * @static
         * @param {liveroom_cs.IStreamDeleteReq=} [properties] Properties to set
         * @returns {liveroom_cs.StreamDeleteReq} StreamDeleteReq instance
         */
        StreamDeleteReq.create = function create(properties) {
            return new StreamDeleteReq(properties);
        };

        /**
         * Encodes the specified StreamDeleteReq message. Does not implicitly {@link liveroom_cs.StreamDeleteReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StreamDeleteReq
         * @static
         * @param {liveroom_cs.IStreamDeleteReq} message StreamDeleteReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamDeleteReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.stream_sid != null && Object.hasOwnProperty.call(message, "stream_sid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.stream_sid);
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.stream_id);
            if (message.client_req_seq != null && Object.hasOwnProperty.call(message, "client_req_seq"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.client_req_seq);
            return writer;
        };

        /**
         * Decodes a StreamDeleteReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StreamDeleteReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StreamDeleteReq} StreamDeleteReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamDeleteReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StreamDeleteReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.stream_sid = reader.string();
                    break;
                case 3:
                    message.stream_id = reader.bytes();
                    break;
                case 4:
                    message.client_req_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StreamDeleteReq;
    })();

    liveroom_cs.StreamDeleteRsp = (function() {

        /**
         * Properties of a StreamDeleteRsp.
         * @memberof liveroom_cs
         * @interface IStreamDeleteRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] StreamDeleteRsp rsp_head
         * @property {number|null} [stream_seq] StreamDeleteRsp stream_seq
         * @property {number|null} [stream_ver] StreamDeleteRsp stream_ver
         */

        /**
         * Constructs a new StreamDeleteRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a StreamDeleteRsp.
         * @implements IStreamDeleteRsp
         * @constructor
         * @param {liveroom_cs.IStreamDeleteRsp=} [properties] Properties to set
         */
        function StreamDeleteRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamDeleteRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.StreamDeleteRsp
         * @instance
         */
        StreamDeleteRsp.prototype.rsp_head = null;

        /**
         * StreamDeleteRsp stream_seq.
         * @member {number} stream_seq
         * @memberof liveroom_cs.StreamDeleteRsp
         * @instance
         */
        StreamDeleteRsp.prototype.stream_seq = 0;

        /**
         * StreamDeleteRsp stream_ver.
         * @member {number} stream_ver
         * @memberof liveroom_cs.StreamDeleteRsp
         * @instance
         */
        StreamDeleteRsp.prototype.stream_ver = 0;

        /**
         * Creates a new StreamDeleteRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StreamDeleteRsp
         * @static
         * @param {liveroom_cs.IStreamDeleteRsp=} [properties] Properties to set
         * @returns {liveroom_cs.StreamDeleteRsp} StreamDeleteRsp instance
         */
        StreamDeleteRsp.create = function create(properties) {
            return new StreamDeleteRsp(properties);
        };

        /**
         * Encodes the specified StreamDeleteRsp message. Does not implicitly {@link liveroom_cs.StreamDeleteRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StreamDeleteRsp
         * @static
         * @param {liveroom_cs.IStreamDeleteRsp} message StreamDeleteRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamDeleteRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.stream_seq != null && Object.hasOwnProperty.call(message, "stream_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stream_seq);
            if (message.stream_ver != null && Object.hasOwnProperty.call(message, "stream_ver"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.stream_ver);
            return writer;
        };

        /**
         * Decodes a StreamDeleteRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StreamDeleteRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StreamDeleteRsp} StreamDeleteRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamDeleteRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StreamDeleteRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.stream_seq = reader.uint32();
                    break;
                case 3:
                    message.stream_ver = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StreamDeleteRsp;
    })();

    liveroom_cs.StreamUpdateReq = (function() {

        /**
         * Properties of a StreamUpdateReq.
         * @memberof liveroom_cs
         * @interface IStreamUpdateReq
         * @property {liveroom_cs.IReqHead|null} [req_head] StreamUpdateReq req_head
         * @property {string|null} [stream_sid] StreamUpdateReq stream_sid
         * @property {Uint8Array|null} [stream_id] StreamUpdateReq stream_id
         * @property {Uint8Array|null} [title] StreamUpdateReq title
         * @property {Uint8Array|null} [stream_attr] StreamUpdateReq stream_attr
         * @property {Uint8Array|null} [extra_info] StreamUpdateReq extra_info
         * @property {number|null} [client_req_seq] StreamUpdateReq client_req_seq
         * @property {Uint8Array|null} [nickname] StreamUpdateReq nickname
         */

        /**
         * Constructs a new StreamUpdateReq.
         * @memberof liveroom_cs
         * @classdesc Represents a StreamUpdateReq.
         * @implements IStreamUpdateReq
         * @constructor
         * @param {liveroom_cs.IStreamUpdateReq=} [properties] Properties to set
         */
        function StreamUpdateReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamUpdateReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.StreamUpdateReq
         * @instance
         */
        StreamUpdateReq.prototype.req_head = null;

        /**
         * StreamUpdateReq stream_sid.
         * @member {string} stream_sid
         * @memberof liveroom_cs.StreamUpdateReq
         * @instance
         */
        StreamUpdateReq.prototype.stream_sid = "";

        /**
         * StreamUpdateReq stream_id.
         * @member {Uint8Array} stream_id
         * @memberof liveroom_cs.StreamUpdateReq
         * @instance
         */
        StreamUpdateReq.prototype.stream_id = $util.newBuffer([]);

        /**
         * StreamUpdateReq title.
         * @member {Uint8Array} title
         * @memberof liveroom_cs.StreamUpdateReq
         * @instance
         */
        StreamUpdateReq.prototype.title = $util.newBuffer([]);

        /**
         * StreamUpdateReq stream_attr.
         * @member {Uint8Array} stream_attr
         * @memberof liveroom_cs.StreamUpdateReq
         * @instance
         */
        StreamUpdateReq.prototype.stream_attr = $util.newBuffer([]);

        /**
         * StreamUpdateReq extra_info.
         * @member {Uint8Array} extra_info
         * @memberof liveroom_cs.StreamUpdateReq
         * @instance
         */
        StreamUpdateReq.prototype.extra_info = $util.newBuffer([]);

        /**
         * StreamUpdateReq client_req_seq.
         * @member {number} client_req_seq
         * @memberof liveroom_cs.StreamUpdateReq
         * @instance
         */
        StreamUpdateReq.prototype.client_req_seq = 0;

        /**
         * StreamUpdateReq nickname.
         * @member {Uint8Array} nickname
         * @memberof liveroom_cs.StreamUpdateReq
         * @instance
         */
        StreamUpdateReq.prototype.nickname = $util.newBuffer([]);

        /**
         * Creates a new StreamUpdateReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StreamUpdateReq
         * @static
         * @param {liveroom_cs.IStreamUpdateReq=} [properties] Properties to set
         * @returns {liveroom_cs.StreamUpdateReq} StreamUpdateReq instance
         */
        StreamUpdateReq.create = function create(properties) {
            return new StreamUpdateReq(properties);
        };

        /**
         * Encodes the specified StreamUpdateReq message. Does not implicitly {@link liveroom_cs.StreamUpdateReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StreamUpdateReq
         * @static
         * @param {liveroom_cs.IStreamUpdateReq} message StreamUpdateReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamUpdateReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.stream_sid != null && Object.hasOwnProperty.call(message, "stream_sid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.stream_sid);
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.stream_id);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.title);
            if (message.stream_attr != null && Object.hasOwnProperty.call(message, "stream_attr"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.stream_attr);
            if (message.extra_info != null && Object.hasOwnProperty.call(message, "extra_info"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.extra_info);
            if (message.client_req_seq != null && Object.hasOwnProperty.call(message, "client_req_seq"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.client_req_seq);
            if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.nickname);
            return writer;
        };

        /**
         * Decodes a StreamUpdateReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StreamUpdateReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StreamUpdateReq} StreamUpdateReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamUpdateReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StreamUpdateReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.stream_sid = reader.string();
                    break;
                case 3:
                    message.stream_id = reader.bytes();
                    break;
                case 4:
                    message.title = reader.bytes();
                    break;
                case 5:
                    message.stream_attr = reader.bytes();
                    break;
                case 6:
                    message.extra_info = reader.bytes();
                    break;
                case 7:
                    message.client_req_seq = reader.uint32();
                    break;
                case 8:
                    message.nickname = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StreamUpdateReq;
    })();

    liveroom_cs.StreamUpdateRsp = (function() {

        /**
         * Properties of a StreamUpdateRsp.
         * @memberof liveroom_cs
         * @interface IStreamUpdateRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] StreamUpdateRsp rsp_head
         * @property {number|null} [stream_seq] StreamUpdateRsp stream_seq
         * @property {number|null} [stream_ver] StreamUpdateRsp stream_ver
         */

        /**
         * Constructs a new StreamUpdateRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a StreamUpdateRsp.
         * @implements IStreamUpdateRsp
         * @constructor
         * @param {liveroom_cs.IStreamUpdateRsp=} [properties] Properties to set
         */
        function StreamUpdateRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamUpdateRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.StreamUpdateRsp
         * @instance
         */
        StreamUpdateRsp.prototype.rsp_head = null;

        /**
         * StreamUpdateRsp stream_seq.
         * @member {number} stream_seq
         * @memberof liveroom_cs.StreamUpdateRsp
         * @instance
         */
        StreamUpdateRsp.prototype.stream_seq = 0;

        /**
         * StreamUpdateRsp stream_ver.
         * @member {number} stream_ver
         * @memberof liveroom_cs.StreamUpdateRsp
         * @instance
         */
        StreamUpdateRsp.prototype.stream_ver = 0;

        /**
         * Creates a new StreamUpdateRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StreamUpdateRsp
         * @static
         * @param {liveroom_cs.IStreamUpdateRsp=} [properties] Properties to set
         * @returns {liveroom_cs.StreamUpdateRsp} StreamUpdateRsp instance
         */
        StreamUpdateRsp.create = function create(properties) {
            return new StreamUpdateRsp(properties);
        };

        /**
         * Encodes the specified StreamUpdateRsp message. Does not implicitly {@link liveroom_cs.StreamUpdateRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StreamUpdateRsp
         * @static
         * @param {liveroom_cs.IStreamUpdateRsp} message StreamUpdateRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamUpdateRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.stream_seq != null && Object.hasOwnProperty.call(message, "stream_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stream_seq);
            if (message.stream_ver != null && Object.hasOwnProperty.call(message, "stream_ver"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.stream_ver);
            return writer;
        };

        /**
         * Decodes a StreamUpdateRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StreamUpdateRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StreamUpdateRsp} StreamUpdateRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamUpdateRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StreamUpdateRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.stream_seq = reader.uint32();
                    break;
                case 3:
                    message.stream_ver = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StreamUpdateRsp;
    })();

    liveroom_cs.StreamListReq = (function() {

        /**
         * Properties of a StreamListReq.
         * @memberof liveroom_cs
         * @interface IStreamListReq
         * @property {liveroom_cs.IReqHead|null} [req_head] StreamListReq req_head
         */

        /**
         * Constructs a new StreamListReq.
         * @memberof liveroom_cs
         * @classdesc Represents a StreamListReq.
         * @implements IStreamListReq
         * @constructor
         * @param {liveroom_cs.IStreamListReq=} [properties] Properties to set
         */
        function StreamListReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamListReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.StreamListReq
         * @instance
         */
        StreamListReq.prototype.req_head = null;

        /**
         * Creates a new StreamListReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StreamListReq
         * @static
         * @param {liveroom_cs.IStreamListReq=} [properties] Properties to set
         * @returns {liveroom_cs.StreamListReq} StreamListReq instance
         */
        StreamListReq.create = function create(properties) {
            return new StreamListReq(properties);
        };

        /**
         * Encodes the specified StreamListReq message. Does not implicitly {@link liveroom_cs.StreamListReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StreamListReq
         * @static
         * @param {liveroom_cs.IStreamListReq} message StreamListReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamListReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a StreamListReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StreamListReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StreamListReq} StreamListReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamListReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StreamListReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StreamListReq;
    })();

    liveroom_cs.StreamListRsp = (function() {

        /**
         * Properties of a StreamListRsp.
         * @memberof liveroom_cs
         * @interface IStreamListRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] StreamListRsp rsp_head
         * @property {number|null} [stream_seq] StreamListRsp stream_seq
         * @property {Array.<liveroom_cs.IStStreamInfo>|null} [stream_info] StreamListRsp stream_info
         * @property {number|null} [stream_refresh] StreamListRsp stream_refresh
         * @property {Array.<liveroom_cs.IStStreamInfo>|null} [stream_mix_info] StreamListRsp stream_mix_info
         */

        /**
         * Constructs a new StreamListRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a StreamListRsp.
         * @implements IStreamListRsp
         * @constructor
         * @param {liveroom_cs.IStreamListRsp=} [properties] Properties to set
         */
        function StreamListRsp(properties) {
            this.stream_info = [];
            this.stream_mix_info = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamListRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.StreamListRsp
         * @instance
         */
        StreamListRsp.prototype.rsp_head = null;

        /**
         * StreamListRsp stream_seq.
         * @member {number} stream_seq
         * @memberof liveroom_cs.StreamListRsp
         * @instance
         */
        StreamListRsp.prototype.stream_seq = 0;

        /**
         * StreamListRsp stream_info.
         * @member {Array.<liveroom_cs.IStStreamInfo>} stream_info
         * @memberof liveroom_cs.StreamListRsp
         * @instance
         */
        StreamListRsp.prototype.stream_info = $util.emptyArray;

        /**
         * StreamListRsp stream_refresh.
         * @member {number} stream_refresh
         * @memberof liveroom_cs.StreamListRsp
         * @instance
         */
        StreamListRsp.prototype.stream_refresh = 0;

        /**
         * StreamListRsp stream_mix_info.
         * @member {Array.<liveroom_cs.IStStreamInfo>} stream_mix_info
         * @memberof liveroom_cs.StreamListRsp
         * @instance
         */
        StreamListRsp.prototype.stream_mix_info = $util.emptyArray;

        /**
         * Creates a new StreamListRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StreamListRsp
         * @static
         * @param {liveroom_cs.IStreamListRsp=} [properties] Properties to set
         * @returns {liveroom_cs.StreamListRsp} StreamListRsp instance
         */
        StreamListRsp.create = function create(properties) {
            return new StreamListRsp(properties);
        };

        /**
         * Encodes the specified StreamListRsp message. Does not implicitly {@link liveroom_cs.StreamListRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StreamListRsp
         * @static
         * @param {liveroom_cs.IStreamListRsp} message StreamListRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamListRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.stream_seq != null && Object.hasOwnProperty.call(message, "stream_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stream_seq);
            if (message.stream_info != null && message.stream_info.length)
                for (var i = 0; i < message.stream_info.length; ++i)
                    $root.liveroom_cs.StStreamInfo.encode(message.stream_info[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.stream_refresh != null && Object.hasOwnProperty.call(message, "stream_refresh"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.stream_refresh);
            if (message.stream_mix_info != null && message.stream_mix_info.length)
                for (var i = 0; i < message.stream_mix_info.length; ++i)
                    $root.liveroom_cs.StStreamInfo.encode(message.stream_mix_info[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a StreamListRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StreamListRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StreamListRsp} StreamListRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamListRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StreamListRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.stream_seq = reader.uint32();
                    break;
                case 3:
                    if (!(message.stream_info && message.stream_info.length))
                        message.stream_info = [];
                    message.stream_info.push($root.liveroom_cs.StStreamInfo.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.stream_refresh = reader.uint32();
                    break;
                case 5:
                    if (!(message.stream_mix_info && message.stream_mix_info.length))
                        message.stream_mix_info = [];
                    message.stream_mix_info.push($root.liveroom_cs.StStreamInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StreamListRsp;
    })();

    liveroom_cs.StStreamInfo = (function() {

        /**
         * Properties of a StStreamInfo.
         * @memberof liveroom_cs
         * @interface IStStreamInfo
         * @property {string|null} [stream_sid] StStreamInfo stream_sid
         * @property {Uint8Array|null} [stream_id] StStreamInfo stream_id
         * @property {Uint8Array|null} [id_name] StStreamInfo id_name
         * @property {Uint8Array|null} [nick_name] StStreamInfo nick_name
         * @property {Uint8Array|null} [extra_info] StStreamInfo extra_info
         * @property {Uint8Array|null} [title] StStreamInfo title
         * @property {number|null} [stream_ver] StStreamInfo stream_ver
         * @property {Uint8Array|null} [stream_attr] StStreamInfo stream_attr
         * @property {number|Long|null} [create_time] StStreamInfo create_time
         * @property {number|null} [stream_src] StStreamInfo stream_src
         * @property {number|null} [state] StStreamInfo state
         * @property {number|null} [stream_type] StStreamInfo stream_type
         * @property {number|null} [stream_nid] StStreamInfo stream_nid
         */

        /**
         * Constructs a new StStreamInfo.
         * @memberof liveroom_cs
         * @classdesc Represents a StStreamInfo.
         * @implements IStStreamInfo
         * @constructor
         * @param {liveroom_cs.IStStreamInfo=} [properties] Properties to set
         */
        function StStreamInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StStreamInfo stream_sid.
         * @member {string} stream_sid
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_sid = "";

        /**
         * StStreamInfo stream_id.
         * @member {Uint8Array} stream_id
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_id = $util.newBuffer([]);

        /**
         * StStreamInfo id_name.
         * @member {Uint8Array} id_name
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.id_name = $util.newBuffer([]);

        /**
         * StStreamInfo nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.nick_name = $util.newBuffer([]);

        /**
         * StStreamInfo extra_info.
         * @member {Uint8Array} extra_info
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.extra_info = $util.newBuffer([]);

        /**
         * StStreamInfo title.
         * @member {Uint8Array} title
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.title = $util.newBuffer([]);

        /**
         * StStreamInfo stream_ver.
         * @member {number} stream_ver
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_ver = 0;

        /**
         * StStreamInfo stream_attr.
         * @member {Uint8Array} stream_attr
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_attr = $util.newBuffer([]);

        /**
         * StStreamInfo create_time.
         * @member {number|Long} create_time
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.create_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StStreamInfo stream_src.
         * @member {number} stream_src
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_src = 0;

        /**
         * StStreamInfo state.
         * @member {number} state
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.state = 0;

        /**
         * StStreamInfo stream_type.
         * @member {number} stream_type
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_type = 0;

        /**
         * StStreamInfo stream_nid.
         * @member {number} stream_nid
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_nid = 0;

        /**
         * Creates a new StStreamInfo instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StStreamInfo
         * @static
         * @param {liveroom_cs.IStStreamInfo=} [properties] Properties to set
         * @returns {liveroom_cs.StStreamInfo} StStreamInfo instance
         */
        StStreamInfo.create = function create(properties) {
            return new StStreamInfo(properties);
        };

        /**
         * Encodes the specified StStreamInfo message. Does not implicitly {@link liveroom_cs.StStreamInfo.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StStreamInfo
         * @static
         * @param {liveroom_cs.IStStreamInfo} message StStreamInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StStreamInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stream_sid != null && Object.hasOwnProperty.call(message, "stream_sid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.stream_sid);
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.stream_id);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.id_name);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.nick_name);
            if (message.extra_info != null && Object.hasOwnProperty.call(message, "extra_info"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.extra_info);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.title);
            if (message.stream_ver != null && Object.hasOwnProperty.call(message, "stream_ver"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.stream_ver);
            if (message.stream_attr != null && Object.hasOwnProperty.call(message, "stream_attr"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.stream_attr);
            if (message.create_time != null && Object.hasOwnProperty.call(message, "create_time"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.create_time);
            if (message.stream_src != null && Object.hasOwnProperty.call(message, "stream_src"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.stream_src);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.state);
            if (message.stream_type != null && Object.hasOwnProperty.call(message, "stream_type"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.stream_type);
            if (message.stream_nid != null && Object.hasOwnProperty.call(message, "stream_nid"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.stream_nid);
            return writer;
        };

        /**
         * Decodes a StStreamInfo message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StStreamInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StStreamInfo} StStreamInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StStreamInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StStreamInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stream_sid = reader.string();
                    break;
                case 2:
                    message.stream_id = reader.bytes();
                    break;
                case 3:
                    message.id_name = reader.bytes();
                    break;
                case 4:
                    message.nick_name = reader.bytes();
                    break;
                case 5:
                    message.extra_info = reader.bytes();
                    break;
                case 6:
                    message.title = reader.bytes();
                    break;
                case 7:
                    message.stream_ver = reader.uint32();
                    break;
                case 8:
                    message.stream_attr = reader.bytes();
                    break;
                case 9:
                    message.create_time = reader.int64();
                    break;
                case 10:
                    message.stream_src = reader.uint32();
                    break;
                case 11:
                    message.state = reader.uint32();
                    break;
                case 12:
                    message.stream_type = reader.uint32();
                    break;
                case 13:
                    message.stream_nid = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StStreamInfo;
    })();

    liveroom_cs.StDstUser = (function() {

        /**
         * Properties of a StDstUser.
         * @memberof liveroom_cs
         * @interface IStDstUser
         * @property {Uint8Array|null} [id_name] StDstUser id_name
         * @property {number|Long|null} [id] StDstUser id
         */

        /**
         * Constructs a new StDstUser.
         * @memberof liveroom_cs
         * @classdesc Represents a StDstUser.
         * @implements IStDstUser
         * @constructor
         * @param {liveroom_cs.IStDstUser=} [properties] Properties to set
         */
        function StDstUser(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StDstUser id_name.
         * @member {Uint8Array} id_name
         * @memberof liveroom_cs.StDstUser
         * @instance
         */
        StDstUser.prototype.id_name = $util.newBuffer([]);

        /**
         * StDstUser id.
         * @member {number|Long} id
         * @memberof liveroom_cs.StDstUser
         * @instance
         */
        StDstUser.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new StDstUser instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StDstUser
         * @static
         * @param {liveroom_cs.IStDstUser=} [properties] Properties to set
         * @returns {liveroom_cs.StDstUser} StDstUser instance
         */
        StDstUser.create = function create(properties) {
            return new StDstUser(properties);
        };

        /**
         * Encodes the specified StDstUser message. Does not implicitly {@link liveroom_cs.StDstUser.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StDstUser
         * @static
         * @param {liveroom_cs.IStDstUser} message StDstUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StDstUser.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id_name);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.id);
            return writer;
        };

        /**
         * Decodes a StDstUser message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StDstUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StDstUser} StDstUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StDstUser.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StDstUser();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id_name = reader.bytes();
                    break;
                case 2:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StDstUser;
    })();

    liveroom_cs.SignalLiveReq = (function() {

        /**
         * Properties of a SignalLiveReq.
         * @memberof liveroom_cs
         * @interface ISignalLiveReq
         * @property {liveroom_cs.IReqHead|null} [req_head] SignalLiveReq req_head
         * @property {Uint8Array|null} [push_message] SignalLiveReq push_message
         * @property {Array.<liveroom_cs.IStDstUser>|null} [dst_userlist] SignalLiveReq dst_userlist
         */

        /**
         * Constructs a new SignalLiveReq.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveReq.
         * @implements ISignalLiveReq
         * @constructor
         * @param {liveroom_cs.ISignalLiveReq=} [properties] Properties to set
         */
        function SignalLiveReq(properties) {
            this.dst_userlist = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.SignalLiveReq
         * @instance
         */
        SignalLiveReq.prototype.req_head = null;

        /**
         * SignalLiveReq push_message.
         * @member {Uint8Array} push_message
         * @memberof liveroom_cs.SignalLiveReq
         * @instance
         */
        SignalLiveReq.prototype.push_message = $util.newBuffer([]);

        /**
         * SignalLiveReq dst_userlist.
         * @member {Array.<liveroom_cs.IStDstUser>} dst_userlist
         * @memberof liveroom_cs.SignalLiveReq
         * @instance
         */
        SignalLiveReq.prototype.dst_userlist = $util.emptyArray;

        /**
         * Creates a new SignalLiveReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveReq
         * @static
         * @param {liveroom_cs.ISignalLiveReq=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveReq} SignalLiveReq instance
         */
        SignalLiveReq.create = function create(properties) {
            return new SignalLiveReq(properties);
        };

        /**
         * Encodes the specified SignalLiveReq message. Does not implicitly {@link liveroom_cs.SignalLiveReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveReq
         * @static
         * @param {liveroom_cs.ISignalLiveReq} message SignalLiveReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.push_message != null && Object.hasOwnProperty.call(message, "push_message"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.push_message);
            if (message.dst_userlist != null && message.dst_userlist.length)
                for (var i = 0; i < message.dst_userlist.length; ++i)
                    $root.liveroom_cs.StDstUser.encode(message.dst_userlist[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveReq} SignalLiveReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.push_message = reader.bytes();
                    break;
                case 3:
                    if (!(message.dst_userlist && message.dst_userlist.length))
                        message.dst_userlist = [];
                    message.dst_userlist.push($root.liveroom_cs.StDstUser.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveReq;
    })();

    liveroom_cs.SignalLiveRsp = (function() {

        /**
         * Properties of a SignalLiveRsp.
         * @memberof liveroom_cs
         * @interface ISignalLiveRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] SignalLiveRsp rsp_head
         */

        /**
         * Constructs a new SignalLiveRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveRsp.
         * @implements ISignalLiveRsp
         * @constructor
         * @param {liveroom_cs.ISignalLiveRsp=} [properties] Properties to set
         */
        function SignalLiveRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.SignalLiveRsp
         * @instance
         */
        SignalLiveRsp.prototype.rsp_head = null;

        /**
         * Creates a new SignalLiveRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveRsp
         * @static
         * @param {liveroom_cs.ISignalLiveRsp=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveRsp} SignalLiveRsp instance
         */
        SignalLiveRsp.create = function create(properties) {
            return new SignalLiveRsp(properties);
        };

        /**
         * Encodes the specified SignalLiveRsp message. Does not implicitly {@link liveroom_cs.SignalLiveRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveRsp
         * @static
         * @param {liveroom_cs.ISignalLiveRsp} message SignalLiveRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveRsp} SignalLiveRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveRsp;
    })();

    liveroom_cs.SignalLiveResultReq = (function() {

        /**
         * Properties of a SignalLiveResultReq.
         * @memberof liveroom_cs
         * @interface ISignalLiveResultReq
         * @property {liveroom_cs.IReqHead|null} [req_head] SignalLiveResultReq req_head
         * @property {Uint8Array|null} [push_message] SignalLiveResultReq push_message
         * @property {Array.<liveroom_cs.IStDstUser>|null} [dst_userlist] SignalLiveResultReq dst_userlist
         */

        /**
         * Constructs a new SignalLiveResultReq.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveResultReq.
         * @implements ISignalLiveResultReq
         * @constructor
         * @param {liveroom_cs.ISignalLiveResultReq=} [properties] Properties to set
         */
        function SignalLiveResultReq(properties) {
            this.dst_userlist = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveResultReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.SignalLiveResultReq
         * @instance
         */
        SignalLiveResultReq.prototype.req_head = null;

        /**
         * SignalLiveResultReq push_message.
         * @member {Uint8Array} push_message
         * @memberof liveroom_cs.SignalLiveResultReq
         * @instance
         */
        SignalLiveResultReq.prototype.push_message = $util.newBuffer([]);

        /**
         * SignalLiveResultReq dst_userlist.
         * @member {Array.<liveroom_cs.IStDstUser>} dst_userlist
         * @memberof liveroom_cs.SignalLiveResultReq
         * @instance
         */
        SignalLiveResultReq.prototype.dst_userlist = $util.emptyArray;

        /**
         * Creates a new SignalLiveResultReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveResultReq
         * @static
         * @param {liveroom_cs.ISignalLiveResultReq=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveResultReq} SignalLiveResultReq instance
         */
        SignalLiveResultReq.create = function create(properties) {
            return new SignalLiveResultReq(properties);
        };

        /**
         * Encodes the specified SignalLiveResultReq message. Does not implicitly {@link liveroom_cs.SignalLiveResultReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveResultReq
         * @static
         * @param {liveroom_cs.ISignalLiveResultReq} message SignalLiveResultReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveResultReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.push_message != null && Object.hasOwnProperty.call(message, "push_message"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.push_message);
            if (message.dst_userlist != null && message.dst_userlist.length)
                for (var i = 0; i < message.dst_userlist.length; ++i)
                    $root.liveroom_cs.StDstUser.encode(message.dst_userlist[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveResultReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveResultReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveResultReq} SignalLiveResultReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveResultReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveResultReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.push_message = reader.bytes();
                    break;
                case 3:
                    if (!(message.dst_userlist && message.dst_userlist.length))
                        message.dst_userlist = [];
                    message.dst_userlist.push($root.liveroom_cs.StDstUser.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveResultReq;
    })();

    liveroom_cs.SignalLiveResulRsp = (function() {

        /**
         * Properties of a SignalLiveResulRsp.
         * @memberof liveroom_cs
         * @interface ISignalLiveResulRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] SignalLiveResulRsp rsp_head
         */

        /**
         * Constructs a new SignalLiveResulRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveResulRsp.
         * @implements ISignalLiveResulRsp
         * @constructor
         * @param {liveroom_cs.ISignalLiveResulRsp=} [properties] Properties to set
         */
        function SignalLiveResulRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveResulRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.SignalLiveResulRsp
         * @instance
         */
        SignalLiveResulRsp.prototype.rsp_head = null;

        /**
         * Creates a new SignalLiveResulRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveResulRsp
         * @static
         * @param {liveroom_cs.ISignalLiveResulRsp=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveResulRsp} SignalLiveResulRsp instance
         */
        SignalLiveResulRsp.create = function create(properties) {
            return new SignalLiveResulRsp(properties);
        };

        /**
         * Encodes the specified SignalLiveResulRsp message. Does not implicitly {@link liveroom_cs.SignalLiveResulRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveResulRsp
         * @static
         * @param {liveroom_cs.ISignalLiveResulRsp} message SignalLiveResulRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveResulRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveResulRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveResulRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveResulRsp} SignalLiveResulRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveResulRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveResulRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveResulRsp;
    })();

    liveroom_cs.SignalLiveInviteReq = (function() {

        /**
         * Properties of a SignalLiveInviteReq.
         * @memberof liveroom_cs
         * @interface ISignalLiveInviteReq
         * @property {liveroom_cs.IReqHead|null} [req_head] SignalLiveInviteReq req_head
         * @property {Uint8Array|null} [push_message] SignalLiveInviteReq push_message
         * @property {Array.<liveroom_cs.IStDstUser>|null} [dst_userlist] SignalLiveInviteReq dst_userlist
         */

        /**
         * Constructs a new SignalLiveInviteReq.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveInviteReq.
         * @implements ISignalLiveInviteReq
         * @constructor
         * @param {liveroom_cs.ISignalLiveInviteReq=} [properties] Properties to set
         */
        function SignalLiveInviteReq(properties) {
            this.dst_userlist = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveInviteReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.SignalLiveInviteReq
         * @instance
         */
        SignalLiveInviteReq.prototype.req_head = null;

        /**
         * SignalLiveInviteReq push_message.
         * @member {Uint8Array} push_message
         * @memberof liveroom_cs.SignalLiveInviteReq
         * @instance
         */
        SignalLiveInviteReq.prototype.push_message = $util.newBuffer([]);

        /**
         * SignalLiveInviteReq dst_userlist.
         * @member {Array.<liveroom_cs.IStDstUser>} dst_userlist
         * @memberof liveroom_cs.SignalLiveInviteReq
         * @instance
         */
        SignalLiveInviteReq.prototype.dst_userlist = $util.emptyArray;

        /**
         * Creates a new SignalLiveInviteReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveInviteReq
         * @static
         * @param {liveroom_cs.ISignalLiveInviteReq=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveInviteReq} SignalLiveInviteReq instance
         */
        SignalLiveInviteReq.create = function create(properties) {
            return new SignalLiveInviteReq(properties);
        };

        /**
         * Encodes the specified SignalLiveInviteReq message. Does not implicitly {@link liveroom_cs.SignalLiveInviteReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveInviteReq
         * @static
         * @param {liveroom_cs.ISignalLiveInviteReq} message SignalLiveInviteReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveInviteReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.push_message != null && Object.hasOwnProperty.call(message, "push_message"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.push_message);
            if (message.dst_userlist != null && message.dst_userlist.length)
                for (var i = 0; i < message.dst_userlist.length; ++i)
                    $root.liveroom_cs.StDstUser.encode(message.dst_userlist[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveInviteReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveInviteReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveInviteReq} SignalLiveInviteReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveInviteReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveInviteReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.push_message = reader.bytes();
                    break;
                case 3:
                    if (!(message.dst_userlist && message.dst_userlist.length))
                        message.dst_userlist = [];
                    message.dst_userlist.push($root.liveroom_cs.StDstUser.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveInviteReq;
    })();

    liveroom_cs.SignalLiveInviteRsp = (function() {

        /**
         * Properties of a SignalLiveInviteRsp.
         * @memberof liveroom_cs
         * @interface ISignalLiveInviteRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] SignalLiveInviteRsp rsp_head
         */

        /**
         * Constructs a new SignalLiveInviteRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveInviteRsp.
         * @implements ISignalLiveInviteRsp
         * @constructor
         * @param {liveroom_cs.ISignalLiveInviteRsp=} [properties] Properties to set
         */
        function SignalLiveInviteRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveInviteRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.SignalLiveInviteRsp
         * @instance
         */
        SignalLiveInviteRsp.prototype.rsp_head = null;

        /**
         * Creates a new SignalLiveInviteRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveInviteRsp
         * @static
         * @param {liveroom_cs.ISignalLiveInviteRsp=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveInviteRsp} SignalLiveInviteRsp instance
         */
        SignalLiveInviteRsp.create = function create(properties) {
            return new SignalLiveInviteRsp(properties);
        };

        /**
         * Encodes the specified SignalLiveInviteRsp message. Does not implicitly {@link liveroom_cs.SignalLiveInviteRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveInviteRsp
         * @static
         * @param {liveroom_cs.ISignalLiveInviteRsp} message SignalLiveInviteRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveInviteRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveInviteRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveInviteRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveInviteRsp} SignalLiveInviteRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveInviteRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveInviteRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveInviteRsp;
    })();

    liveroom_cs.SignalLiveStopReq = (function() {

        /**
         * Properties of a SignalLiveStopReq.
         * @memberof liveroom_cs
         * @interface ISignalLiveStopReq
         * @property {liveroom_cs.IReqHead|null} [req_head] SignalLiveStopReq req_head
         * @property {Uint8Array|null} [push_message] SignalLiveStopReq push_message
         * @property {Array.<liveroom_cs.IStDstUser>|null} [dst_userlist] SignalLiveStopReq dst_userlist
         */

        /**
         * Constructs a new SignalLiveStopReq.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveStopReq.
         * @implements ISignalLiveStopReq
         * @constructor
         * @param {liveroom_cs.ISignalLiveStopReq=} [properties] Properties to set
         */
        function SignalLiveStopReq(properties) {
            this.dst_userlist = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveStopReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.SignalLiveStopReq
         * @instance
         */
        SignalLiveStopReq.prototype.req_head = null;

        /**
         * SignalLiveStopReq push_message.
         * @member {Uint8Array} push_message
         * @memberof liveroom_cs.SignalLiveStopReq
         * @instance
         */
        SignalLiveStopReq.prototype.push_message = $util.newBuffer([]);

        /**
         * SignalLiveStopReq dst_userlist.
         * @member {Array.<liveroom_cs.IStDstUser>} dst_userlist
         * @memberof liveroom_cs.SignalLiveStopReq
         * @instance
         */
        SignalLiveStopReq.prototype.dst_userlist = $util.emptyArray;

        /**
         * Creates a new SignalLiveStopReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveStopReq
         * @static
         * @param {liveroom_cs.ISignalLiveStopReq=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveStopReq} SignalLiveStopReq instance
         */
        SignalLiveStopReq.create = function create(properties) {
            return new SignalLiveStopReq(properties);
        };

        /**
         * Encodes the specified SignalLiveStopReq message. Does not implicitly {@link liveroom_cs.SignalLiveStopReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveStopReq
         * @static
         * @param {liveroom_cs.ISignalLiveStopReq} message SignalLiveStopReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveStopReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.push_message != null && Object.hasOwnProperty.call(message, "push_message"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.push_message);
            if (message.dst_userlist != null && message.dst_userlist.length)
                for (var i = 0; i < message.dst_userlist.length; ++i)
                    $root.liveroom_cs.StDstUser.encode(message.dst_userlist[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveStopReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveStopReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveStopReq} SignalLiveStopReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveStopReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveStopReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.push_message = reader.bytes();
                    break;
                case 3:
                    if (!(message.dst_userlist && message.dst_userlist.length))
                        message.dst_userlist = [];
                    message.dst_userlist.push($root.liveroom_cs.StDstUser.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveStopReq;
    })();

    liveroom_cs.SignalLiveStopRsp = (function() {

        /**
         * Properties of a SignalLiveStopRsp.
         * @memberof liveroom_cs
         * @interface ISignalLiveStopRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] SignalLiveStopRsp rsp_head
         */

        /**
         * Constructs a new SignalLiveStopRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveStopRsp.
         * @implements ISignalLiveStopRsp
         * @constructor
         * @param {liveroom_cs.ISignalLiveStopRsp=} [properties] Properties to set
         */
        function SignalLiveStopRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveStopRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.SignalLiveStopRsp
         * @instance
         */
        SignalLiveStopRsp.prototype.rsp_head = null;

        /**
         * Creates a new SignalLiveStopRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveStopRsp
         * @static
         * @param {liveroom_cs.ISignalLiveStopRsp=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveStopRsp} SignalLiveStopRsp instance
         */
        SignalLiveStopRsp.create = function create(properties) {
            return new SignalLiveStopRsp(properties);
        };

        /**
         * Encodes the specified SignalLiveStopRsp message. Does not implicitly {@link liveroom_cs.SignalLiveStopRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveStopRsp
         * @static
         * @param {liveroom_cs.ISignalLiveStopRsp} message SignalLiveStopRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveStopRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveStopRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveStopRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveStopRsp} SignalLiveStopRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveStopRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveStopRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveStopRsp;
    })();

    liveroom_cs.SignalLiveCustomReq = (function() {

        /**
         * Properties of a SignalLiveCustomReq.
         * @memberof liveroom_cs
         * @interface ISignalLiveCustomReq
         * @property {liveroom_cs.IReqHead|null} [req_head] SignalLiveCustomReq req_head
         * @property {Uint8Array|null} [push_message] SignalLiveCustomReq push_message
         * @property {Array.<liveroom_cs.IStDstUser>|null} [dst_userlist] SignalLiveCustomReq dst_userlist
         */

        /**
         * Constructs a new SignalLiveCustomReq.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveCustomReq.
         * @implements ISignalLiveCustomReq
         * @constructor
         * @param {liveroom_cs.ISignalLiveCustomReq=} [properties] Properties to set
         */
        function SignalLiveCustomReq(properties) {
            this.dst_userlist = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveCustomReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.SignalLiveCustomReq
         * @instance
         */
        SignalLiveCustomReq.prototype.req_head = null;

        /**
         * SignalLiveCustomReq push_message.
         * @member {Uint8Array} push_message
         * @memberof liveroom_cs.SignalLiveCustomReq
         * @instance
         */
        SignalLiveCustomReq.prototype.push_message = $util.newBuffer([]);

        /**
         * SignalLiveCustomReq dst_userlist.
         * @member {Array.<liveroom_cs.IStDstUser>} dst_userlist
         * @memberof liveroom_cs.SignalLiveCustomReq
         * @instance
         */
        SignalLiveCustomReq.prototype.dst_userlist = $util.emptyArray;

        /**
         * Creates a new SignalLiveCustomReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveCustomReq
         * @static
         * @param {liveroom_cs.ISignalLiveCustomReq=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveCustomReq} SignalLiveCustomReq instance
         */
        SignalLiveCustomReq.create = function create(properties) {
            return new SignalLiveCustomReq(properties);
        };

        /**
         * Encodes the specified SignalLiveCustomReq message. Does not implicitly {@link liveroom_cs.SignalLiveCustomReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveCustomReq
         * @static
         * @param {liveroom_cs.ISignalLiveCustomReq} message SignalLiveCustomReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveCustomReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.push_message != null && Object.hasOwnProperty.call(message, "push_message"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.push_message);
            if (message.dst_userlist != null && message.dst_userlist.length)
                for (var i = 0; i < message.dst_userlist.length; ++i)
                    $root.liveroom_cs.StDstUser.encode(message.dst_userlist[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveCustomReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveCustomReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveCustomReq} SignalLiveCustomReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveCustomReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveCustomReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.push_message = reader.bytes();
                    break;
                case 3:
                    if (!(message.dst_userlist && message.dst_userlist.length))
                        message.dst_userlist = [];
                    message.dst_userlist.push($root.liveroom_cs.StDstUser.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveCustomReq;
    })();

    liveroom_cs.SignalLiveCustomRsp = (function() {

        /**
         * Properties of a SignalLiveCustomRsp.
         * @memberof liveroom_cs
         * @interface ISignalLiveCustomRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] SignalLiveCustomRsp rsp_head
         */

        /**
         * Constructs a new SignalLiveCustomRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveCustomRsp.
         * @implements ISignalLiveCustomRsp
         * @constructor
         * @param {liveroom_cs.ISignalLiveCustomRsp=} [properties] Properties to set
         */
        function SignalLiveCustomRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveCustomRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.SignalLiveCustomRsp
         * @instance
         */
        SignalLiveCustomRsp.prototype.rsp_head = null;

        /**
         * Creates a new SignalLiveCustomRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveCustomRsp
         * @static
         * @param {liveroom_cs.ISignalLiveCustomRsp=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveCustomRsp} SignalLiveCustomRsp instance
         */
        SignalLiveCustomRsp.create = function create(properties) {
            return new SignalLiveCustomRsp(properties);
        };

        /**
         * Encodes the specified SignalLiveCustomRsp message. Does not implicitly {@link liveroom_cs.SignalLiveCustomRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveCustomRsp
         * @static
         * @param {liveroom_cs.ISignalLiveCustomRsp} message SignalLiveCustomRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveCustomRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveCustomRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveCustomRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveCustomRsp} SignalLiveCustomRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveCustomRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveCustomRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveCustomRsp;
    })();

    liveroom_cs.ImChatReq = (function() {

        /**
         * Properties of an ImChatReq.
         * @memberof liveroom_cs
         * @interface IImChatReq
         * @property {liveroom_cs.IReqHead|null} [req_head] ImChatReq req_head
         * @property {number|null} [msg_category] ImChatReq msg_category
         * @property {number|null} [msg_type] ImChatReq msg_type
         * @property {number|null} [msg_priority] ImChatReq msg_priority
         * @property {Uint8Array|null} [msg_content] ImChatReq msg_content
         * @property {Array.<liveroom_cs.IStDstUser>|null} [dst_userlist] ImChatReq dst_userlist
         */

        /**
         * Constructs a new ImChatReq.
         * @memberof liveroom_cs
         * @classdesc Represents an ImChatReq.
         * @implements IImChatReq
         * @constructor
         * @param {liveroom_cs.IImChatReq=} [properties] Properties to set
         */
        function ImChatReq(properties) {
            this.dst_userlist = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImChatReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.ImChatReq
         * @instance
         */
        ImChatReq.prototype.req_head = null;

        /**
         * ImChatReq msg_category.
         * @member {number} msg_category
         * @memberof liveroom_cs.ImChatReq
         * @instance
         */
        ImChatReq.prototype.msg_category = 0;

        /**
         * ImChatReq msg_type.
         * @member {number} msg_type
         * @memberof liveroom_cs.ImChatReq
         * @instance
         */
        ImChatReq.prototype.msg_type = 0;

        /**
         * ImChatReq msg_priority.
         * @member {number} msg_priority
         * @memberof liveroom_cs.ImChatReq
         * @instance
         */
        ImChatReq.prototype.msg_priority = 0;

        /**
         * ImChatReq msg_content.
         * @member {Uint8Array} msg_content
         * @memberof liveroom_cs.ImChatReq
         * @instance
         */
        ImChatReq.prototype.msg_content = $util.newBuffer([]);

        /**
         * ImChatReq dst_userlist.
         * @member {Array.<liveroom_cs.IStDstUser>} dst_userlist
         * @memberof liveroom_cs.ImChatReq
         * @instance
         */
        ImChatReq.prototype.dst_userlist = $util.emptyArray;

        /**
         * Creates a new ImChatReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.ImChatReq
         * @static
         * @param {liveroom_cs.IImChatReq=} [properties] Properties to set
         * @returns {liveroom_cs.ImChatReq} ImChatReq instance
         */
        ImChatReq.create = function create(properties) {
            return new ImChatReq(properties);
        };

        /**
         * Encodes the specified ImChatReq message. Does not implicitly {@link liveroom_cs.ImChatReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.ImChatReq
         * @static
         * @param {liveroom_cs.IImChatReq} message ImChatReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImChatReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.msg_category != null && Object.hasOwnProperty.call(message, "msg_category"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.msg_category);
            if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.msg_type);
            if (message.msg_priority != null && Object.hasOwnProperty.call(message, "msg_priority"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.msg_priority);
            if (message.msg_content != null && Object.hasOwnProperty.call(message, "msg_content"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.msg_content);
            if (message.dst_userlist != null && message.dst_userlist.length)
                for (var i = 0; i < message.dst_userlist.length; ++i)
                    $root.liveroom_cs.StDstUser.encode(message.dst_userlist[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes an ImChatReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.ImChatReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.ImChatReq} ImChatReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImChatReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.ImChatReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.msg_category = reader.uint32();
                    break;
                case 3:
                    message.msg_type = reader.uint32();
                    break;
                case 4:
                    message.msg_priority = reader.uint32();
                    break;
                case 5:
                    message.msg_content = reader.bytes();
                    break;
                case 6:
                    if (!(message.dst_userlist && message.dst_userlist.length))
                        message.dst_userlist = [];
                    message.dst_userlist.push($root.liveroom_cs.StDstUser.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ImChatReq;
    })();

    liveroom_cs.ImChatRsp = (function() {

        /**
         * Properties of an ImChatRsp.
         * @memberof liveroom_cs
         * @interface IImChatRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] ImChatRsp rsp_head
         * @property {number|Long|null} [msg_id] ImChatRsp msg_id
         */

        /**
         * Constructs a new ImChatRsp.
         * @memberof liveroom_cs
         * @classdesc Represents an ImChatRsp.
         * @implements IImChatRsp
         * @constructor
         * @param {liveroom_cs.IImChatRsp=} [properties] Properties to set
         */
        function ImChatRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImChatRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.ImChatRsp
         * @instance
         */
        ImChatRsp.prototype.rsp_head = null;

        /**
         * ImChatRsp msg_id.
         * @member {number|Long} msg_id
         * @memberof liveroom_cs.ImChatRsp
         * @instance
         */
        ImChatRsp.prototype.msg_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ImChatRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.ImChatRsp
         * @static
         * @param {liveroom_cs.IImChatRsp=} [properties] Properties to set
         * @returns {liveroom_cs.ImChatRsp} ImChatRsp instance
         */
        ImChatRsp.create = function create(properties) {
            return new ImChatRsp(properties);
        };

        /**
         * Encodes the specified ImChatRsp message. Does not implicitly {@link liveroom_cs.ImChatRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.ImChatRsp
         * @static
         * @param {liveroom_cs.IImChatRsp} message ImChatRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImChatRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.msg_id != null && Object.hasOwnProperty.call(message, "msg_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.msg_id);
            return writer;
        };

        /**
         * Decodes an ImChatRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.ImChatRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.ImChatRsp} ImChatRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImChatRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.ImChatRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.msg_id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ImChatRsp;
    })();

    liveroom_cs.ImGethatReq = (function() {

        /**
         * Properties of an ImGethatReq.
         * @memberof liveroom_cs
         * @interface IImGethatReq
         * @property {liveroom_cs.IReqHead|null} [req_head] ImGethatReq req_head
         * @property {number|null} [msg_priority] ImGethatReq msg_priority
         * @property {number|Long|null} [msg_id] ImGethatReq msg_id
         * @property {number|null} [sort_type] ImGethatReq sort_type
         * @property {number|null} [msg_count] ImGethatReq msg_count
         */

        /**
         * Constructs a new ImGethatReq.
         * @memberof liveroom_cs
         * @classdesc Represents an ImGethatReq.
         * @implements IImGethatReq
         * @constructor
         * @param {liveroom_cs.IImGethatReq=} [properties] Properties to set
         */
        function ImGethatReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImGethatReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.ImGethatReq
         * @instance
         */
        ImGethatReq.prototype.req_head = null;

        /**
         * ImGethatReq msg_priority.
         * @member {number} msg_priority
         * @memberof liveroom_cs.ImGethatReq
         * @instance
         */
        ImGethatReq.prototype.msg_priority = 0;

        /**
         * ImGethatReq msg_id.
         * @member {number|Long} msg_id
         * @memberof liveroom_cs.ImGethatReq
         * @instance
         */
        ImGethatReq.prototype.msg_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ImGethatReq sort_type.
         * @member {number} sort_type
         * @memberof liveroom_cs.ImGethatReq
         * @instance
         */
        ImGethatReq.prototype.sort_type = 0;

        /**
         * ImGethatReq msg_count.
         * @member {number} msg_count
         * @memberof liveroom_cs.ImGethatReq
         * @instance
         */
        ImGethatReq.prototype.msg_count = 0;

        /**
         * Creates a new ImGethatReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.ImGethatReq
         * @static
         * @param {liveroom_cs.IImGethatReq=} [properties] Properties to set
         * @returns {liveroom_cs.ImGethatReq} ImGethatReq instance
         */
        ImGethatReq.create = function create(properties) {
            return new ImGethatReq(properties);
        };

        /**
         * Encodes the specified ImGethatReq message. Does not implicitly {@link liveroom_cs.ImGethatReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.ImGethatReq
         * @static
         * @param {liveroom_cs.IImGethatReq} message ImGethatReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImGethatReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.msg_priority != null && Object.hasOwnProperty.call(message, "msg_priority"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.msg_priority);
            if (message.msg_id != null && Object.hasOwnProperty.call(message, "msg_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.msg_id);
            if (message.sort_type != null && Object.hasOwnProperty.call(message, "sort_type"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.sort_type);
            if (message.msg_count != null && Object.hasOwnProperty.call(message, "msg_count"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.msg_count);
            return writer;
        };

        /**
         * Decodes an ImGethatReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.ImGethatReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.ImGethatReq} ImGethatReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImGethatReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.ImGethatReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.msg_priority = reader.uint32();
                    break;
                case 3:
                    message.msg_id = reader.uint64();
                    break;
                case 4:
                    message.sort_type = reader.uint32();
                    break;
                case 5:
                    message.msg_count = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ImGethatReq;
    })();

    liveroom_cs.ImGetChatRsp = (function() {

        /**
         * Properties of an ImGetChatRsp.
         * @memberof liveroom_cs
         * @interface IImGetChatRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] ImGetChatRsp rsp_head
         * @property {number|Long|null} [server_msg_id] ImGetChatRsp server_msg_id
         * @property {number|Long|null} [ret_msg_id] ImGetChatRsp ret_msg_id
         * @property {Array.<liveroom_cs.IStMsgData>|null} [msg_data] ImGetChatRsp msg_data
         */

        /**
         * Constructs a new ImGetChatRsp.
         * @memberof liveroom_cs
         * @classdesc Represents an ImGetChatRsp.
         * @implements IImGetChatRsp
         * @constructor
         * @param {liveroom_cs.IImGetChatRsp=} [properties] Properties to set
         */
        function ImGetChatRsp(properties) {
            this.msg_data = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImGetChatRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.ImGetChatRsp
         * @instance
         */
        ImGetChatRsp.prototype.rsp_head = null;

        /**
         * ImGetChatRsp server_msg_id.
         * @member {number|Long} server_msg_id
         * @memberof liveroom_cs.ImGetChatRsp
         * @instance
         */
        ImGetChatRsp.prototype.server_msg_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ImGetChatRsp ret_msg_id.
         * @member {number|Long} ret_msg_id
         * @memberof liveroom_cs.ImGetChatRsp
         * @instance
         */
        ImGetChatRsp.prototype.ret_msg_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ImGetChatRsp msg_data.
         * @member {Array.<liveroom_cs.IStMsgData>} msg_data
         * @memberof liveroom_cs.ImGetChatRsp
         * @instance
         */
        ImGetChatRsp.prototype.msg_data = $util.emptyArray;

        /**
         * Creates a new ImGetChatRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.ImGetChatRsp
         * @static
         * @param {liveroom_cs.IImGetChatRsp=} [properties] Properties to set
         * @returns {liveroom_cs.ImGetChatRsp} ImGetChatRsp instance
         */
        ImGetChatRsp.create = function create(properties) {
            return new ImGetChatRsp(properties);
        };

        /**
         * Encodes the specified ImGetChatRsp message. Does not implicitly {@link liveroom_cs.ImGetChatRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.ImGetChatRsp
         * @static
         * @param {liveroom_cs.IImGetChatRsp} message ImGetChatRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImGetChatRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.server_msg_id != null && Object.hasOwnProperty.call(message, "server_msg_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.server_msg_id);
            if (message.ret_msg_id != null && Object.hasOwnProperty.call(message, "ret_msg_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.ret_msg_id);
            if (message.msg_data != null && message.msg_data.length)
                for (var i = 0; i < message.msg_data.length; ++i)
                    $root.liveroom_cs.StMsgData.encode(message.msg_data[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes an ImGetChatRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.ImGetChatRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.ImGetChatRsp} ImGetChatRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImGetChatRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.ImGetChatRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.server_msg_id = reader.uint64();
                    break;
                case 3:
                    message.ret_msg_id = reader.uint64();
                    break;
                case 4:
                    if (!(message.msg_data && message.msg_data.length))
                        message.msg_data = [];
                    message.msg_data.push($root.liveroom_cs.StMsgData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ImGetChatRsp;
    })();

    liveroom_cs.StMsgData = (function() {

        /**
         * Properties of a StMsgData.
         * @memberof liveroom_cs
         * @interface IStMsgData
         * @property {Uint8Array|null} [id_name] StMsgData id_name
         * @property {Uint8Array|null} [nick_name] StMsgData nick_name
         * @property {number|null} [role] StMsgData role
         * @property {number|Long|null} [msg_id] StMsgData msg_id
         * @property {number|null} [msg_category] StMsgData msg_category
         * @property {number|null} [msg_type] StMsgData msg_type
         * @property {number|null} [msg_priority] StMsgData msg_priority
         * @property {Uint8Array|null} [msg_content] StMsgData msg_content
         * @property {number|Long|null} [send_time] StMsgData send_time
         */

        /**
         * Constructs a new StMsgData.
         * @memberof liveroom_cs
         * @classdesc Represents a StMsgData.
         * @implements IStMsgData
         * @constructor
         * @param {liveroom_cs.IStMsgData=} [properties] Properties to set
         */
        function StMsgData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StMsgData id_name.
         * @member {Uint8Array} id_name
         * @memberof liveroom_cs.StMsgData
         * @instance
         */
        StMsgData.prototype.id_name = $util.newBuffer([]);

        /**
         * StMsgData nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.StMsgData
         * @instance
         */
        StMsgData.prototype.nick_name = $util.newBuffer([]);

        /**
         * StMsgData role.
         * @member {number} role
         * @memberof liveroom_cs.StMsgData
         * @instance
         */
        StMsgData.prototype.role = 0;

        /**
         * StMsgData msg_id.
         * @member {number|Long} msg_id
         * @memberof liveroom_cs.StMsgData
         * @instance
         */
        StMsgData.prototype.msg_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StMsgData msg_category.
         * @member {number} msg_category
         * @memberof liveroom_cs.StMsgData
         * @instance
         */
        StMsgData.prototype.msg_category = 0;

        /**
         * StMsgData msg_type.
         * @member {number} msg_type
         * @memberof liveroom_cs.StMsgData
         * @instance
         */
        StMsgData.prototype.msg_type = 0;

        /**
         * StMsgData msg_priority.
         * @member {number} msg_priority
         * @memberof liveroom_cs.StMsgData
         * @instance
         */
        StMsgData.prototype.msg_priority = 0;

        /**
         * StMsgData msg_content.
         * @member {Uint8Array} msg_content
         * @memberof liveroom_cs.StMsgData
         * @instance
         */
        StMsgData.prototype.msg_content = $util.newBuffer([]);

        /**
         * StMsgData send_time.
         * @member {number|Long} send_time
         * @memberof liveroom_cs.StMsgData
         * @instance
         */
        StMsgData.prototype.send_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new StMsgData instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StMsgData
         * @static
         * @param {liveroom_cs.IStMsgData=} [properties] Properties to set
         * @returns {liveroom_cs.StMsgData} StMsgData instance
         */
        StMsgData.create = function create(properties) {
            return new StMsgData(properties);
        };

        /**
         * Encodes the specified StMsgData message. Does not implicitly {@link liveroom_cs.StMsgData.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StMsgData
         * @static
         * @param {liveroom_cs.IStMsgData} message StMsgData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StMsgData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id_name);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.role);
            if (message.msg_id != null && Object.hasOwnProperty.call(message, "msg_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.msg_id);
            if (message.msg_category != null && Object.hasOwnProperty.call(message, "msg_category"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.msg_category);
            if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.msg_type);
            if (message.msg_priority != null && Object.hasOwnProperty.call(message, "msg_priority"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.msg_priority);
            if (message.msg_content != null && Object.hasOwnProperty.call(message, "msg_content"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.msg_content);
            if (message.send_time != null && Object.hasOwnProperty.call(message, "send_time"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.send_time);
            return writer;
        };

        /**
         * Decodes a StMsgData message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StMsgData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StMsgData} StMsgData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StMsgData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StMsgData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id_name = reader.bytes();
                    break;
                case 2:
                    message.nick_name = reader.bytes();
                    break;
                case 3:
                    message.role = reader.uint32();
                    break;
                case 4:
                    message.msg_id = reader.uint64();
                    break;
                case 5:
                    message.msg_category = reader.uint32();
                    break;
                case 6:
                    message.msg_type = reader.uint32();
                    break;
                case 7:
                    message.msg_priority = reader.uint32();
                    break;
                case 8:
                    message.msg_content = reader.bytes();
                    break;
                case 9:
                    message.send_time = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StMsgData;
    })();

    liveroom_cs.EnterReq = (function() {

        /**
         * Properties of an EnterReq.
         * @memberof liveroom_cs
         * @interface IEnterReq
         * @property {liveroom_cs.IReqHead|null} [req_head] EnterReq req_head
         * @property {number|Long|null} [switch_session_id] EnterReq switch_session_id
         * @property {Uint8Array|null} [nick_name] EnterReq nick_name
         * @property {number|null} [role] EnterReq role
         * @property {number|null} [net_type] EnterReq net_type
         * @property {liveroom_cs.IStConfigList|null} [config] EnterReq config
         * @property {string|null} [lv_key] EnterReq lv_key
         * @property {Uint8Array|null} [third_token] EnterReq third_token
         * @property {number|Long|null} [cluster_req] EnterReq cluster_req
         * @property {number|null} [user_count_limit] EnterReq user_count_limit
         * @property {string|null} [relate_service] EnterReq relate_service
         * @property {number|null} [conn_type] EnterReq conn_type
         * @property {Uint8Array|null} [room_name] EnterReq room_name
         */

        /**
         * Constructs a new EnterReq.
         * @memberof liveroom_cs
         * @classdesc Represents an EnterReq.
         * @implements IEnterReq
         * @constructor
         * @param {liveroom_cs.IEnterReq=} [properties] Properties to set
         */
        function EnterReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.req_head = null;

        /**
         * EnterReq switch_session_id.
         * @member {number|Long} switch_session_id
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.switch_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EnterReq nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.nick_name = $util.newBuffer([]);

        /**
         * EnterReq role.
         * @member {number} role
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.role = 0;

        /**
         * EnterReq net_type.
         * @member {number} net_type
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.net_type = 0;

        /**
         * EnterReq config.
         * @member {liveroom_cs.IStConfigList|null|undefined} config
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.config = null;

        /**
         * EnterReq lv_key.
         * @member {string} lv_key
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.lv_key = "";

        /**
         * EnterReq third_token.
         * @member {Uint8Array} third_token
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.third_token = $util.newBuffer([]);

        /**
         * EnterReq cluster_req.
         * @member {number|Long} cluster_req
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.cluster_req = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EnterReq user_count_limit.
         * @member {number} user_count_limit
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.user_count_limit = 0;

        /**
         * EnterReq relate_service.
         * @member {string} relate_service
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.relate_service = "";

        /**
         * EnterReq conn_type.
         * @member {number} conn_type
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.conn_type = 0;

        /**
         * EnterReq room_name.
         * @member {Uint8Array} room_name
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.room_name = $util.newBuffer([]);

        /**
         * Creates a new EnterReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.EnterReq
         * @static
         * @param {liveroom_cs.IEnterReq=} [properties] Properties to set
         * @returns {liveroom_cs.EnterReq} EnterReq instance
         */
        EnterReq.create = function create(properties) {
            return new EnterReq(properties);
        };

        /**
         * Encodes the specified EnterReq message. Does not implicitly {@link liveroom_cs.EnterReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.EnterReq
         * @static
         * @param {liveroom_cs.IEnterReq} message EnterReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.switch_session_id != null && Object.hasOwnProperty.call(message, "switch_session_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.switch_session_id);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.role);
            if (message.net_type != null && Object.hasOwnProperty.call(message, "net_type"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.net_type);
            if (message.config != null && Object.hasOwnProperty.call(message, "config"))
                $root.liveroom_cs.StConfigList.encode(message.config, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.lv_key != null && Object.hasOwnProperty.call(message, "lv_key"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.lv_key);
            if (message.third_token != null && Object.hasOwnProperty.call(message, "third_token"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.third_token);
            if (message.cluster_req != null && Object.hasOwnProperty.call(message, "cluster_req"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.cluster_req);
            if (message.user_count_limit != null && Object.hasOwnProperty.call(message, "user_count_limit"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.user_count_limit);
            if (message.relate_service != null && Object.hasOwnProperty.call(message, "relate_service"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.relate_service);
            if (message.conn_type != null && Object.hasOwnProperty.call(message, "conn_type"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.conn_type);
            if (message.room_name != null && Object.hasOwnProperty.call(message, "room_name"))
                writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.room_name);
            return writer;
        };

        /**
         * Decodes an EnterReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.EnterReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.EnterReq} EnterReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.EnterReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.switch_session_id = reader.uint64();
                    break;
                case 3:
                    message.nick_name = reader.bytes();
                    break;
                case 4:
                    message.role = reader.uint32();
                    break;
                case 5:
                    message.net_type = reader.uint32();
                    break;
                case 6:
                    message.config = $root.liveroom_cs.StConfigList.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.lv_key = reader.string();
                    break;
                case 8:
                    message.third_token = reader.bytes();
                    break;
                case 9:
                    message.cluster_req = reader.uint64();
                    break;
                case 10:
                    message.user_count_limit = reader.uint32();
                    break;
                case 11:
                    message.relate_service = reader.string();
                    break;
                case 12:
                    message.conn_type = reader.uint32();
                    break;
                case 13:
                    message.room_name = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return EnterReq;
    })();

    liveroom_cs.EnterRsp = (function() {

        /**
         * Properties of an EnterRsp.
         * @memberof liveroom_cs
         * @interface IEnterRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] EnterRsp rsp_head
         * @property {Uint8Array|null} [room_id] EnterRsp room_id
         * @property {number|Long|null} [user_session_id] EnterRsp user_session_id
         * @property {number|Long|null} [room_session_id] EnterRsp room_session_id
         * @property {number|Long|null} [user_id] EnterRsp user_id
         * @property {number|Long|null} [ret_timestamp] EnterRsp ret_timestamp
         * @property {number|null} [bigim_time_window] EnterRsp bigim_time_window
         * @property {number|Long|null} [dati_time_window] EnterRsp dati_time_window
         * @property {number|null} [room_id32] EnterRsp room_id32
         * @property {number|null} [hb_interval] EnterRsp hb_interval
         * @property {number|null} [hb_timeout] EnterRsp hb_timeout
         * @property {string|null} [lv_key] EnterRsp lv_key
         * @property {string|null} [zp_key] EnterRsp zp_key
         * @property {number|null} [online_count] EnterRsp online_count
         * @property {liveroom_cs.IStAnchorInfo|null} [anchor_info] EnterRsp anchor_info
         * @property {number|null} [stream_seq] EnterRsp stream_seq
         * @property {Array.<liveroom_cs.IStStreamInfo>|null} [stream_info] EnterRsp stream_info
         * @property {Array.<liveroom_cs.IStStreamInfo>|null} [stream_mix_info] EnterRsp stream_mix_info
         * @property {number|null} [userlist_merge_timeout] EnterRsp userlist_merge_timeout
         * @property {number|null} [userlist_interval] EnterRsp userlist_interval
         * @property {number|null} [stream_list_push_merge_timeout] EnterRsp stream_list_push_merge_timeout
         * @property {number|null} [stream_list_hb_wait_merge_time] EnterRsp stream_list_hb_wait_merge_time
         * @property {number|null} [trans_list_seq] EnterRsp trans_list_seq
         * @property {Array.<liveroom_cs.IStTransInfo>|null} [trans_seqs] EnterRsp trans_seqs
         * @property {string|null} [cluster_name] EnterRsp cluster_name
         * @property {number|null} [token_remain_time] EnterRsp token_remain_time
         * @property {number|null} [stream_fetch_flag] EnterRsp stream_fetch_flag
         */

        /**
         * Constructs a new EnterRsp.
         * @memberof liveroom_cs
         * @classdesc Represents an EnterRsp.
         * @implements IEnterRsp
         * @constructor
         * @param {liveroom_cs.IEnterRsp=} [properties] Properties to set
         */
        function EnterRsp(properties) {
            this.stream_info = [];
            this.stream_mix_info = [];
            this.trans_seqs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.rsp_head = null;

        /**
         * EnterRsp room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.room_id = $util.newBuffer([]);

        /**
         * EnterRsp user_session_id.
         * @member {number|Long} user_session_id
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.user_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EnterRsp room_session_id.
         * @member {number|Long} room_session_id
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.room_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EnterRsp user_id.
         * @member {number|Long} user_id
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.user_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EnterRsp ret_timestamp.
         * @member {number|Long} ret_timestamp
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.ret_timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EnterRsp bigim_time_window.
         * @member {number} bigim_time_window
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.bigim_time_window = 0;

        /**
         * EnterRsp dati_time_window.
         * @member {number|Long} dati_time_window
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.dati_time_window = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EnterRsp room_id32.
         * @member {number} room_id32
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.room_id32 = 0;

        /**
         * EnterRsp hb_interval.
         * @member {number} hb_interval
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.hb_interval = 0;

        /**
         * EnterRsp hb_timeout.
         * @member {number} hb_timeout
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.hb_timeout = 0;

        /**
         * EnterRsp lv_key.
         * @member {string} lv_key
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.lv_key = "";

        /**
         * EnterRsp zp_key.
         * @member {string} zp_key
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.zp_key = "";

        /**
         * EnterRsp online_count.
         * @member {number} online_count
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.online_count = 0;

        /**
         * EnterRsp anchor_info.
         * @member {liveroom_cs.IStAnchorInfo|null|undefined} anchor_info
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.anchor_info = null;

        /**
         * EnterRsp stream_seq.
         * @member {number} stream_seq
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.stream_seq = 0;

        /**
         * EnterRsp stream_info.
         * @member {Array.<liveroom_cs.IStStreamInfo>} stream_info
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.stream_info = $util.emptyArray;

        /**
         * EnterRsp stream_mix_info.
         * @member {Array.<liveroom_cs.IStStreamInfo>} stream_mix_info
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.stream_mix_info = $util.emptyArray;

        /**
         * EnterRsp userlist_merge_timeout.
         * @member {number} userlist_merge_timeout
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.userlist_merge_timeout = 0;

        /**
         * EnterRsp userlist_interval.
         * @member {number} userlist_interval
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.userlist_interval = 0;

        /**
         * EnterRsp stream_list_push_merge_timeout.
         * @member {number} stream_list_push_merge_timeout
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.stream_list_push_merge_timeout = 0;

        /**
         * EnterRsp stream_list_hb_wait_merge_time.
         * @member {number} stream_list_hb_wait_merge_time
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.stream_list_hb_wait_merge_time = 0;

        /**
         * EnterRsp trans_list_seq.
         * @member {number} trans_list_seq
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.trans_list_seq = 0;

        /**
         * EnterRsp trans_seqs.
         * @member {Array.<liveroom_cs.IStTransInfo>} trans_seqs
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.trans_seqs = $util.emptyArray;

        /**
         * EnterRsp cluster_name.
         * @member {string} cluster_name
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.cluster_name = "";

        /**
         * EnterRsp token_remain_time.
         * @member {number} token_remain_time
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.token_remain_time = 0;

        /**
         * EnterRsp stream_fetch_flag.
         * @member {number} stream_fetch_flag
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.stream_fetch_flag = 0;

        /**
         * Creates a new EnterRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.EnterRsp
         * @static
         * @param {liveroom_cs.IEnterRsp=} [properties] Properties to set
         * @returns {liveroom_cs.EnterRsp} EnterRsp instance
         */
        EnterRsp.create = function create(properties) {
            return new EnterRsp(properties);
        };

        /**
         * Encodes the specified EnterRsp message. Does not implicitly {@link liveroom_cs.EnterRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.EnterRsp
         * @static
         * @param {liveroom_cs.IEnterRsp} message EnterRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.room_id);
            if (message.user_session_id != null && Object.hasOwnProperty.call(message, "user_session_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.user_session_id);
            if (message.room_session_id != null && Object.hasOwnProperty.call(message, "room_session_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.room_session_id);
            if (message.user_id != null && Object.hasOwnProperty.call(message, "user_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.user_id);
            if (message.ret_timestamp != null && Object.hasOwnProperty.call(message, "ret_timestamp"))
                writer.uint32(/* id 6, wireType 1 =*/49).fixed64(message.ret_timestamp);
            if (message.bigim_time_window != null && Object.hasOwnProperty.call(message, "bigim_time_window"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.bigim_time_window);
            if (message.dati_time_window != null && Object.hasOwnProperty.call(message, "dati_time_window"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.dati_time_window);
            if (message.room_id32 != null && Object.hasOwnProperty.call(message, "room_id32"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.room_id32);
            if (message.hb_interval != null && Object.hasOwnProperty.call(message, "hb_interval"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.hb_interval);
            if (message.hb_timeout != null && Object.hasOwnProperty.call(message, "hb_timeout"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.hb_timeout);
            if (message.lv_key != null && Object.hasOwnProperty.call(message, "lv_key"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.lv_key);
            if (message.zp_key != null && Object.hasOwnProperty.call(message, "zp_key"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.zp_key);
            if (message.online_count != null && Object.hasOwnProperty.call(message, "online_count"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.online_count);
            if (message.anchor_info != null && Object.hasOwnProperty.call(message, "anchor_info"))
                $root.liveroom_cs.StAnchorInfo.encode(message.anchor_info, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.stream_seq != null && Object.hasOwnProperty.call(message, "stream_seq"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.stream_seq);
            if (message.stream_info != null && message.stream_info.length)
                for (var i = 0; i < message.stream_info.length; ++i)
                    $root.liveroom_cs.StStreamInfo.encode(message.stream_info[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.stream_mix_info != null && message.stream_mix_info.length)
                for (var i = 0; i < message.stream_mix_info.length; ++i)
                    $root.liveroom_cs.StStreamInfo.encode(message.stream_mix_info[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.userlist_merge_timeout != null && Object.hasOwnProperty.call(message, "userlist_merge_timeout"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.userlist_merge_timeout);
            if (message.userlist_interval != null && Object.hasOwnProperty.call(message, "userlist_interval"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.userlist_interval);
            if (message.stream_list_push_merge_timeout != null && Object.hasOwnProperty.call(message, "stream_list_push_merge_timeout"))
                writer.uint32(/* id 21, wireType 0 =*/168).uint32(message.stream_list_push_merge_timeout);
            if (message.stream_list_hb_wait_merge_time != null && Object.hasOwnProperty.call(message, "stream_list_hb_wait_merge_time"))
                writer.uint32(/* id 22, wireType 0 =*/176).uint32(message.stream_list_hb_wait_merge_time);
            if (message.trans_list_seq != null && Object.hasOwnProperty.call(message, "trans_list_seq"))
                writer.uint32(/* id 23, wireType 0 =*/184).uint32(message.trans_list_seq);
            if (message.trans_seqs != null && message.trans_seqs.length)
                for (var i = 0; i < message.trans_seqs.length; ++i)
                    $root.liveroom_cs.StTransInfo.encode(message.trans_seqs[i], writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.cluster_name != null && Object.hasOwnProperty.call(message, "cluster_name"))
                writer.uint32(/* id 25, wireType 2 =*/202).string(message.cluster_name);
            if (message.token_remain_time != null && Object.hasOwnProperty.call(message, "token_remain_time"))
                writer.uint32(/* id 26, wireType 0 =*/208).uint32(message.token_remain_time);
            if (message.stream_fetch_flag != null && Object.hasOwnProperty.call(message, "stream_fetch_flag"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint32(message.stream_fetch_flag);
            return writer;
        };

        /**
         * Decodes an EnterRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.EnterRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.EnterRsp} EnterRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.EnterRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.room_id = reader.bytes();
                    break;
                case 3:
                    message.user_session_id = reader.uint64();
                    break;
                case 4:
                    message.room_session_id = reader.uint64();
                    break;
                case 5:
                    message.user_id = reader.uint64();
                    break;
                case 6:
                    message.ret_timestamp = reader.fixed64();
                    break;
                case 7:
                    message.bigim_time_window = reader.uint32();
                    break;
                case 8:
                    message.dati_time_window = reader.int64();
                    break;
                case 9:
                    message.room_id32 = reader.uint32();
                    break;
                case 10:
                    message.hb_interval = reader.uint32();
                    break;
                case 11:
                    message.hb_timeout = reader.uint32();
                    break;
                case 12:
                    message.lv_key = reader.string();
                    break;
                case 13:
                    message.zp_key = reader.string();
                    break;
                case 14:
                    message.online_count = reader.uint32();
                    break;
                case 15:
                    message.anchor_info = $root.liveroom_cs.StAnchorInfo.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.stream_seq = reader.uint32();
                    break;
                case 17:
                    if (!(message.stream_info && message.stream_info.length))
                        message.stream_info = [];
                    message.stream_info.push($root.liveroom_cs.StStreamInfo.decode(reader, reader.uint32()));
                    break;
                case 18:
                    if (!(message.stream_mix_info && message.stream_mix_info.length))
                        message.stream_mix_info = [];
                    message.stream_mix_info.push($root.liveroom_cs.StStreamInfo.decode(reader, reader.uint32()));
                    break;
                case 19:
                    message.userlist_merge_timeout = reader.uint32();
                    break;
                case 20:
                    message.userlist_interval = reader.uint32();
                    break;
                case 21:
                    message.stream_list_push_merge_timeout = reader.uint32();
                    break;
                case 22:
                    message.stream_list_hb_wait_merge_time = reader.uint32();
                    break;
                case 23:
                    message.trans_list_seq = reader.uint32();
                    break;
                case 24:
                    if (!(message.trans_seqs && message.trans_seqs.length))
                        message.trans_seqs = [];
                    message.trans_seqs.push($root.liveroom_cs.StTransInfo.decode(reader, reader.uint32()));
                    break;
                case 25:
                    message.cluster_name = reader.string();
                    break;
                case 26:
                    message.token_remain_time = reader.uint32();
                    break;
                case 27:
                    message.stream_fetch_flag = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return EnterRsp;
    })();

    liveroom_cs.StAnchorInfo = (function() {

        /**
         * Properties of a StAnchorInfo.
         * @memberof liveroom_cs
         * @interface IStAnchorInfo
         * @property {Uint8Array|null} [anchor_id_name] StAnchorInfo anchor_id_name
         * @property {number|Long|null} [anchor_id] StAnchorInfo anchor_id
         * @property {Uint8Array|null} [anchor_nick_name] StAnchorInfo anchor_nick_name
         */

        /**
         * Constructs a new StAnchorInfo.
         * @memberof liveroom_cs
         * @classdesc Represents a StAnchorInfo.
         * @implements IStAnchorInfo
         * @constructor
         * @param {liveroom_cs.IStAnchorInfo=} [properties] Properties to set
         */
        function StAnchorInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StAnchorInfo anchor_id_name.
         * @member {Uint8Array} anchor_id_name
         * @memberof liveroom_cs.StAnchorInfo
         * @instance
         */
        StAnchorInfo.prototype.anchor_id_name = $util.newBuffer([]);

        /**
         * StAnchorInfo anchor_id.
         * @member {number|Long} anchor_id
         * @memberof liveroom_cs.StAnchorInfo
         * @instance
         */
        StAnchorInfo.prototype.anchor_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StAnchorInfo anchor_nick_name.
         * @member {Uint8Array} anchor_nick_name
         * @memberof liveroom_cs.StAnchorInfo
         * @instance
         */
        StAnchorInfo.prototype.anchor_nick_name = $util.newBuffer([]);

        /**
         * Creates a new StAnchorInfo instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StAnchorInfo
         * @static
         * @param {liveroom_cs.IStAnchorInfo=} [properties] Properties to set
         * @returns {liveroom_cs.StAnchorInfo} StAnchorInfo instance
         */
        StAnchorInfo.create = function create(properties) {
            return new StAnchorInfo(properties);
        };

        /**
         * Encodes the specified StAnchorInfo message. Does not implicitly {@link liveroom_cs.StAnchorInfo.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StAnchorInfo
         * @static
         * @param {liveroom_cs.IStAnchorInfo} message StAnchorInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StAnchorInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.anchor_id_name != null && Object.hasOwnProperty.call(message, "anchor_id_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.anchor_id_name);
            if (message.anchor_id != null && Object.hasOwnProperty.call(message, "anchor_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.anchor_id);
            if (message.anchor_nick_name != null && Object.hasOwnProperty.call(message, "anchor_nick_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.anchor_nick_name);
            return writer;
        };

        /**
         * Decodes a StAnchorInfo message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StAnchorInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StAnchorInfo} StAnchorInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StAnchorInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StAnchorInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.anchor_id_name = reader.bytes();
                    break;
                case 2:
                    message.anchor_id = reader.uint64();
                    break;
                case 3:
                    message.anchor_nick_name = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StAnchorInfo;
    })();

    liveroom_cs.QuitReq = (function() {

        /**
         * Properties of a QuitReq.
         * @memberof liveroom_cs
         * @interface IQuitReq
         * @property {liveroom_cs.IReqHead|null} [req_head] QuitReq req_head
         * @property {number|Long|null} [switch_session_id] QuitReq switch_session_id
         * @property {number|null} [room_id32] QuitReq room_id32
         * @property {Uint8Array|null} [nick_name] QuitReq nick_name
         * @property {number|null} [role] QuitReq role
         * @property {number|null} [net_type] QuitReq net_type
         * @property {liveroom_cs.IStConfigList|null} [config_list] QuitReq config_list
         */

        /**
         * Constructs a new QuitReq.
         * @memberof liveroom_cs
         * @classdesc Represents a QuitReq.
         * @implements IQuitReq
         * @constructor
         * @param {liveroom_cs.IQuitReq=} [properties] Properties to set
         */
        function QuitReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QuitReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.QuitReq
         * @instance
         */
        QuitReq.prototype.req_head = null;

        /**
         * QuitReq switch_session_id.
         * @member {number|Long} switch_session_id
         * @memberof liveroom_cs.QuitReq
         * @instance
         */
        QuitReq.prototype.switch_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * QuitReq room_id32.
         * @member {number} room_id32
         * @memberof liveroom_cs.QuitReq
         * @instance
         */
        QuitReq.prototype.room_id32 = 0;

        /**
         * QuitReq nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.QuitReq
         * @instance
         */
        QuitReq.prototype.nick_name = $util.newBuffer([]);

        /**
         * QuitReq role.
         * @member {number} role
         * @memberof liveroom_cs.QuitReq
         * @instance
         */
        QuitReq.prototype.role = 0;

        /**
         * QuitReq net_type.
         * @member {number} net_type
         * @memberof liveroom_cs.QuitReq
         * @instance
         */
        QuitReq.prototype.net_type = 0;

        /**
         * QuitReq config_list.
         * @member {liveroom_cs.IStConfigList|null|undefined} config_list
         * @memberof liveroom_cs.QuitReq
         * @instance
         */
        QuitReq.prototype.config_list = null;

        /**
         * Creates a new QuitReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.QuitReq
         * @static
         * @param {liveroom_cs.IQuitReq=} [properties] Properties to set
         * @returns {liveroom_cs.QuitReq} QuitReq instance
         */
        QuitReq.create = function create(properties) {
            return new QuitReq(properties);
        };

        /**
         * Encodes the specified QuitReq message. Does not implicitly {@link liveroom_cs.QuitReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.QuitReq
         * @static
         * @param {liveroom_cs.IQuitReq} message QuitReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QuitReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.switch_session_id != null && Object.hasOwnProperty.call(message, "switch_session_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.switch_session_id);
            if (message.room_id32 != null && Object.hasOwnProperty.call(message, "room_id32"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.room_id32);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.role);
            if (message.net_type != null && Object.hasOwnProperty.call(message, "net_type"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.net_type);
            if (message.config_list != null && Object.hasOwnProperty.call(message, "config_list"))
                $root.liveroom_cs.StConfigList.encode(message.config_list, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a QuitReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.QuitReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.QuitReq} QuitReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QuitReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.QuitReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.switch_session_id = reader.uint64();
                    break;
                case 3:
                    message.room_id32 = reader.uint32();
                    break;
                case 4:
                    message.nick_name = reader.bytes();
                    break;
                case 5:
                    message.role = reader.uint32();
                    break;
                case 6:
                    message.net_type = reader.uint32();
                    break;
                case 7:
                    message.config_list = $root.liveroom_cs.StConfigList.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return QuitReq;
    })();

    liveroom_cs.StConfigList = (function() {

        /**
         * Properties of a StConfigList.
         * @memberof liveroom_cs
         * @interface IStConfigList
         * @property {number|null} [room_create_flag] StConfigList room_create_flag
         * @property {number|null} [user_state_flag] StConfigList user_state_flag
         */

        /**
         * Constructs a new StConfigList.
         * @memberof liveroom_cs
         * @classdesc Represents a StConfigList.
         * @implements IStConfigList
         * @constructor
         * @param {liveroom_cs.IStConfigList=} [properties] Properties to set
         */
        function StConfigList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StConfigList room_create_flag.
         * @member {number} room_create_flag
         * @memberof liveroom_cs.StConfigList
         * @instance
         */
        StConfigList.prototype.room_create_flag = 0;

        /**
         * StConfigList user_state_flag.
         * @member {number} user_state_flag
         * @memberof liveroom_cs.StConfigList
         * @instance
         */
        StConfigList.prototype.user_state_flag = 0;

        /**
         * Creates a new StConfigList instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StConfigList
         * @static
         * @param {liveroom_cs.IStConfigList=} [properties] Properties to set
         * @returns {liveroom_cs.StConfigList} StConfigList instance
         */
        StConfigList.create = function create(properties) {
            return new StConfigList(properties);
        };

        /**
         * Encodes the specified StConfigList message. Does not implicitly {@link liveroom_cs.StConfigList.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StConfigList
         * @static
         * @param {liveroom_cs.IStConfigList} message StConfigList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StConfigList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.room_create_flag != null && Object.hasOwnProperty.call(message, "room_create_flag"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.room_create_flag);
            if (message.user_state_flag != null && Object.hasOwnProperty.call(message, "user_state_flag"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.user_state_flag);
            return writer;
        };

        /**
         * Decodes a StConfigList message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StConfigList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StConfigList} StConfigList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StConfigList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StConfigList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.room_create_flag = reader.uint32();
                    break;
                case 2:
                    message.user_state_flag = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StConfigList;
    })();

    liveroom_cs.QuitRsp = (function() {

        /**
         * Properties of a QuitRsp.
         * @memberof liveroom_cs
         * @interface IQuitRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] QuitRsp rsp_head
         * @property {Uint8Array|null} [room_id] QuitRsp room_id
         * @property {number|null} [room_id32] QuitRsp room_id32
         */

        /**
         * Constructs a new QuitRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a QuitRsp.
         * @implements IQuitRsp
         * @constructor
         * @param {liveroom_cs.IQuitRsp=} [properties] Properties to set
         */
        function QuitRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QuitRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.QuitRsp
         * @instance
         */
        QuitRsp.prototype.rsp_head = null;

        /**
         * QuitRsp room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.QuitRsp
         * @instance
         */
        QuitRsp.prototype.room_id = $util.newBuffer([]);

        /**
         * QuitRsp room_id32.
         * @member {number} room_id32
         * @memberof liveroom_cs.QuitRsp
         * @instance
         */
        QuitRsp.prototype.room_id32 = 0;

        /**
         * Creates a new QuitRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.QuitRsp
         * @static
         * @param {liveroom_cs.IQuitRsp=} [properties] Properties to set
         * @returns {liveroom_cs.QuitRsp} QuitRsp instance
         */
        QuitRsp.create = function create(properties) {
            return new QuitRsp(properties);
        };

        /**
         * Encodes the specified QuitRsp message. Does not implicitly {@link liveroom_cs.QuitRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.QuitRsp
         * @static
         * @param {liveroom_cs.IQuitRsp} message QuitRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QuitRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.room_id);
            if (message.room_id32 != null && Object.hasOwnProperty.call(message, "room_id32"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.room_id32);
            return writer;
        };

        /**
         * Decodes a QuitRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.QuitRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.QuitRsp} QuitRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QuitRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.QuitRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.room_id = reader.bytes();
                    break;
                case 3:
                    message.room_id32 = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return QuitRsp;
    })();

    liveroom_cs.RoomListReq = (function() {

        /**
         * Properties of a RoomListReq.
         * @memberof liveroom_cs
         * @interface IRoomListReq
         * @property {liveroom_cs.IReqHead|null} [req_head] RoomListReq req_head
         */

        /**
         * Constructs a new RoomListReq.
         * @memberof liveroom_cs
         * @classdesc Represents a RoomListReq.
         * @implements IRoomListReq
         * @constructor
         * @param {liveroom_cs.IRoomListReq=} [properties] Properties to set
         */
        function RoomListReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomListReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.RoomListReq
         * @instance
         */
        RoomListReq.prototype.req_head = null;

        /**
         * Creates a new RoomListReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.RoomListReq
         * @static
         * @param {liveroom_cs.IRoomListReq=} [properties] Properties to set
         * @returns {liveroom_cs.RoomListReq} RoomListReq instance
         */
        RoomListReq.create = function create(properties) {
            return new RoomListReq(properties);
        };

        /**
         * Encodes the specified RoomListReq message. Does not implicitly {@link liveroom_cs.RoomListReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.RoomListReq
         * @static
         * @param {liveroom_cs.IRoomListReq} message RoomListReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoomListReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a RoomListReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.RoomListReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.RoomListReq} RoomListReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomListReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.RoomListReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RoomListReq;
    })();

    liveroom_cs.RoomListRsp = (function() {

        /**
         * Properties of a RoomListRsp.
         * @memberof liveroom_cs
         * @interface IRoomListRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] RoomListRsp rsp_head
         * @property {Array.<liveroom_cs.IStRoomListRoom>|null} [room_list] RoomListRsp room_list
         */

        /**
         * Constructs a new RoomListRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a RoomListRsp.
         * @implements IRoomListRsp
         * @constructor
         * @param {liveroom_cs.IRoomListRsp=} [properties] Properties to set
         */
        function RoomListRsp(properties) {
            this.room_list = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomListRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.RoomListRsp
         * @instance
         */
        RoomListRsp.prototype.rsp_head = null;

        /**
         * RoomListRsp room_list.
         * @member {Array.<liveroom_cs.IStRoomListRoom>} room_list
         * @memberof liveroom_cs.RoomListRsp
         * @instance
         */
        RoomListRsp.prototype.room_list = $util.emptyArray;

        /**
         * Creates a new RoomListRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.RoomListRsp
         * @static
         * @param {liveroom_cs.IRoomListRsp=} [properties] Properties to set
         * @returns {liveroom_cs.RoomListRsp} RoomListRsp instance
         */
        RoomListRsp.create = function create(properties) {
            return new RoomListRsp(properties);
        };

        /**
         * Encodes the specified RoomListRsp message. Does not implicitly {@link liveroom_cs.RoomListRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.RoomListRsp
         * @static
         * @param {liveroom_cs.IRoomListRsp} message RoomListRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoomListRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.room_list != null && message.room_list.length)
                for (var i = 0; i < message.room_list.length; ++i)
                    $root.liveroom_cs.StRoomListRoom.encode(message.room_list[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a RoomListRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.RoomListRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.RoomListRsp} RoomListRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomListRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.RoomListRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.room_list && message.room_list.length))
                        message.room_list = [];
                    message.room_list.push($root.liveroom_cs.StRoomListRoom.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RoomListRsp;
    })();

    liveroom_cs.StRoomListStream = (function() {

        /**
         * Properties of a StRoomListStream.
         * @memberof liveroom_cs
         * @interface IStRoomListStream
         * @property {Uint8Array|null} [stream_id] StRoomListStream stream_id
         */

        /**
         * Constructs a new StRoomListStream.
         * @memberof liveroom_cs
         * @classdesc Represents a StRoomListStream.
         * @implements IStRoomListStream
         * @constructor
         * @param {liveroom_cs.IStRoomListStream=} [properties] Properties to set
         */
        function StRoomListStream(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StRoomListStream stream_id.
         * @member {Uint8Array} stream_id
         * @memberof liveroom_cs.StRoomListStream
         * @instance
         */
        StRoomListStream.prototype.stream_id = $util.newBuffer([]);

        /**
         * Creates a new StRoomListStream instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StRoomListStream
         * @static
         * @param {liveroom_cs.IStRoomListStream=} [properties] Properties to set
         * @returns {liveroom_cs.StRoomListStream} StRoomListStream instance
         */
        StRoomListStream.create = function create(properties) {
            return new StRoomListStream(properties);
        };

        /**
         * Encodes the specified StRoomListStream message. Does not implicitly {@link liveroom_cs.StRoomListStream.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StRoomListStream
         * @static
         * @param {liveroom_cs.IStRoomListStream} message StRoomListStream message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StRoomListStream.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.stream_id);
            return writer;
        };

        /**
         * Decodes a StRoomListStream message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StRoomListStream
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StRoomListStream} StRoomListStream
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StRoomListStream.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StRoomListStream();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stream_id = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StRoomListStream;
    })();

    liveroom_cs.StRoomListRoom = (function() {

        /**
         * Properties of a StRoomListRoom.
         * @memberof liveroom_cs
         * @interface IStRoomListRoom
         * @property {Uint8Array|null} [room_id] StRoomListRoom room_id
         * @property {Uint8Array|null} [room_name] StRoomListRoom room_name
         * @property {Uint8Array|null} [anchor_id_name] StRoomListRoom anchor_id_name
         * @property {Uint8Array|null} [anchor_nick_name] StRoomListRoom anchor_nick_name
         * @property {Array.<liveroom_cs.IStRoomListStream>|null} [stream_list] StRoomListRoom stream_list
         */

        /**
         * Constructs a new StRoomListRoom.
         * @memberof liveroom_cs
         * @classdesc Represents a StRoomListRoom.
         * @implements IStRoomListRoom
         * @constructor
         * @param {liveroom_cs.IStRoomListRoom=} [properties] Properties to set
         */
        function StRoomListRoom(properties) {
            this.stream_list = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StRoomListRoom room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.StRoomListRoom
         * @instance
         */
        StRoomListRoom.prototype.room_id = $util.newBuffer([]);

        /**
         * StRoomListRoom room_name.
         * @member {Uint8Array} room_name
         * @memberof liveroom_cs.StRoomListRoom
         * @instance
         */
        StRoomListRoom.prototype.room_name = $util.newBuffer([]);

        /**
         * StRoomListRoom anchor_id_name.
         * @member {Uint8Array} anchor_id_name
         * @memberof liveroom_cs.StRoomListRoom
         * @instance
         */
        StRoomListRoom.prototype.anchor_id_name = $util.newBuffer([]);

        /**
         * StRoomListRoom anchor_nick_name.
         * @member {Uint8Array} anchor_nick_name
         * @memberof liveroom_cs.StRoomListRoom
         * @instance
         */
        StRoomListRoom.prototype.anchor_nick_name = $util.newBuffer([]);

        /**
         * StRoomListRoom stream_list.
         * @member {Array.<liveroom_cs.IStRoomListStream>} stream_list
         * @memberof liveroom_cs.StRoomListRoom
         * @instance
         */
        StRoomListRoom.prototype.stream_list = $util.emptyArray;

        /**
         * Creates a new StRoomListRoom instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StRoomListRoom
         * @static
         * @param {liveroom_cs.IStRoomListRoom=} [properties] Properties to set
         * @returns {liveroom_cs.StRoomListRoom} StRoomListRoom instance
         */
        StRoomListRoom.create = function create(properties) {
            return new StRoomListRoom(properties);
        };

        /**
         * Encodes the specified StRoomListRoom message. Does not implicitly {@link liveroom_cs.StRoomListRoom.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StRoomListRoom
         * @static
         * @param {liveroom_cs.IStRoomListRoom} message StRoomListRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StRoomListRoom.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.room_id);
            if (message.room_name != null && Object.hasOwnProperty.call(message, "room_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.room_name);
            if (message.anchor_id_name != null && Object.hasOwnProperty.call(message, "anchor_id_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.anchor_id_name);
            if (message.anchor_nick_name != null && Object.hasOwnProperty.call(message, "anchor_nick_name"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.anchor_nick_name);
            if (message.stream_list != null && message.stream_list.length)
                for (var i = 0; i < message.stream_list.length; ++i)
                    $root.liveroom_cs.StRoomListStream.encode(message.stream_list[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a StRoomListRoom message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StRoomListRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StRoomListRoom} StRoomListRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StRoomListRoom.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StRoomListRoom();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.room_id = reader.bytes();
                    break;
                case 2:
                    message.room_name = reader.bytes();
                    break;
                case 3:
                    message.anchor_id_name = reader.bytes();
                    break;
                case 4:
                    message.anchor_nick_name = reader.bytes();
                    break;
                case 5:
                    if (!(message.stream_list && message.stream_list.length))
                        message.stream_list = [];
                    message.stream_list.push($root.liveroom_cs.StRoomListStream.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StRoomListRoom;
    })();

    liveroom_cs.StTransSeqInfo = (function() {

        /**
         * Properties of a StTransSeqInfo.
         * @memberof liveroom_cs
         * @interface IStTransSeqInfo
         * @property {Uint8Array|null} [trans_type] StTransSeqInfo trans_type
         * @property {number|null} [trans_seq] StTransSeqInfo trans_seq
         */

        /**
         * Constructs a new StTransSeqInfo.
         * @memberof liveroom_cs
         * @classdesc Represents a StTransSeqInfo.
         * @implements IStTransSeqInfo
         * @constructor
         * @param {liveroom_cs.IStTransSeqInfo=} [properties] Properties to set
         */
        function StTransSeqInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StTransSeqInfo trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.StTransSeqInfo
         * @instance
         */
        StTransSeqInfo.prototype.trans_type = $util.newBuffer([]);

        /**
         * StTransSeqInfo trans_seq.
         * @member {number} trans_seq
         * @memberof liveroom_cs.StTransSeqInfo
         * @instance
         */
        StTransSeqInfo.prototype.trans_seq = 0;

        /**
         * Creates a new StTransSeqInfo instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StTransSeqInfo
         * @static
         * @param {liveroom_cs.IStTransSeqInfo=} [properties] Properties to set
         * @returns {liveroom_cs.StTransSeqInfo} StTransSeqInfo instance
         */
        StTransSeqInfo.create = function create(properties) {
            return new StTransSeqInfo(properties);
        };

        /**
         * Encodes the specified StTransSeqInfo message. Does not implicitly {@link liveroom_cs.StTransSeqInfo.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StTransSeqInfo
         * @static
         * @param {liveroom_cs.IStTransSeqInfo} message StTransSeqInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StTransSeqInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_type);
            if (message.trans_seq != null && Object.hasOwnProperty.call(message, "trans_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.trans_seq);
            return writer;
        };

        /**
         * Decodes a StTransSeqInfo message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StTransSeqInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StTransSeqInfo} StTransSeqInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StTransSeqInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StTransSeqInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_type = reader.bytes();
                    break;
                case 2:
                    message.trans_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StTransSeqInfo;
    })();

    liveroom_cs.StTransInfo = (function() {

        /**
         * Properties of a StTransInfo.
         * @memberof liveroom_cs
         * @interface IStTransInfo
         * @property {Uint8Array|null} [trans_channel] StTransInfo trans_channel
         * @property {Array.<liveroom_cs.IStTransSeqInfo>|null} [trans_seq_array] StTransInfo trans_seq_array
         */

        /**
         * Constructs a new StTransInfo.
         * @memberof liveroom_cs
         * @classdesc Represents a StTransInfo.
         * @implements IStTransInfo
         * @constructor
         * @param {liveroom_cs.IStTransInfo=} [properties] Properties to set
         */
        function StTransInfo(properties) {
            this.trans_seq_array = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StTransInfo trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.StTransInfo
         * @instance
         */
        StTransInfo.prototype.trans_channel = $util.newBuffer([]);

        /**
         * StTransInfo trans_seq_array.
         * @member {Array.<liveroom_cs.IStTransSeqInfo>} trans_seq_array
         * @memberof liveroom_cs.StTransInfo
         * @instance
         */
        StTransInfo.prototype.trans_seq_array = $util.emptyArray;

        /**
         * Creates a new StTransInfo instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StTransInfo
         * @static
         * @param {liveroom_cs.IStTransInfo=} [properties] Properties to set
         * @returns {liveroom_cs.StTransInfo} StTransInfo instance
         */
        StTransInfo.create = function create(properties) {
            return new StTransInfo(properties);
        };

        /**
         * Encodes the specified StTransInfo message. Does not implicitly {@link liveroom_cs.StTransInfo.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StTransInfo
         * @static
         * @param {liveroom_cs.IStTransInfo} message StTransInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StTransInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_channel);
            if (message.trans_seq_array != null && message.trans_seq_array.length)
                for (var i = 0; i < message.trans_seq_array.length; ++i)
                    $root.liveroom_cs.StTransSeqInfo.encode(message.trans_seq_array[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a StTransInfo message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StTransInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StTransInfo} StTransInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StTransInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StTransInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_channel = reader.bytes();
                    break;
                case 2:
                    if (!(message.trans_seq_array && message.trans_seq_array.length))
                        message.trans_seq_array = [];
                    message.trans_seq_array.push($root.liveroom_cs.StTransSeqInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StTransInfo;
    })();

    liveroom_cs.TransReq = (function() {

        /**
         * Properties of a TransReq.
         * @memberof liveroom_cs
         * @interface ITransReq
         * @property {liveroom_cs.IReqHead|null} [req_head] TransReq req_head
         * @property {Uint8Array|null} [nick_name] TransReq nick_name
         * @property {number|null} [role] TransReq role
         * @property {Uint8Array|null} [trans_type] TransReq trans_type
         * @property {Uint8Array|null} [trans_data] TransReq trans_data
         * @property {number|null} [trans_local_seq] TransReq trans_local_seq
         * @property {Uint8Array|null} [trans_channel] TransReq trans_channel
         */

        /**
         * Constructs a new TransReq.
         * @memberof liveroom_cs
         * @classdesc Represents a TransReq.
         * @implements ITransReq
         * @constructor
         * @param {liveroom_cs.ITransReq=} [properties] Properties to set
         */
        function TransReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.TransReq
         * @instance
         */
        TransReq.prototype.req_head = null;

        /**
         * TransReq nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.TransReq
         * @instance
         */
        TransReq.prototype.nick_name = $util.newBuffer([]);

        /**
         * TransReq role.
         * @member {number} role
         * @memberof liveroom_cs.TransReq
         * @instance
         */
        TransReq.prototype.role = 0;

        /**
         * TransReq trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.TransReq
         * @instance
         */
        TransReq.prototype.trans_type = $util.newBuffer([]);

        /**
         * TransReq trans_data.
         * @member {Uint8Array} trans_data
         * @memberof liveroom_cs.TransReq
         * @instance
         */
        TransReq.prototype.trans_data = $util.newBuffer([]);

        /**
         * TransReq trans_local_seq.
         * @member {number} trans_local_seq
         * @memberof liveroom_cs.TransReq
         * @instance
         */
        TransReq.prototype.trans_local_seq = 0;

        /**
         * TransReq trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.TransReq
         * @instance
         */
        TransReq.prototype.trans_channel = $util.newBuffer([]);

        /**
         * Creates a new TransReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.TransReq
         * @static
         * @param {liveroom_cs.ITransReq=} [properties] Properties to set
         * @returns {liveroom_cs.TransReq} TransReq instance
         */
        TransReq.create = function create(properties) {
            return new TransReq(properties);
        };

        /**
         * Encodes the specified TransReq message. Does not implicitly {@link liveroom_cs.TransReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.TransReq
         * @static
         * @param {liveroom_cs.ITransReq} message TransReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.role);
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.trans_type);
            if (message.trans_data != null && Object.hasOwnProperty.call(message, "trans_data"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.trans_data);
            if (message.trans_local_seq != null && Object.hasOwnProperty.call(message, "trans_local_seq"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.trans_local_seq);
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.trans_channel);
            return writer;
        };

        /**
         * Decodes a TransReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.TransReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.TransReq} TransReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.TransReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.nick_name = reader.bytes();
                    break;
                case 3:
                    message.role = reader.uint32();
                    break;
                case 4:
                    message.trans_type = reader.bytes();
                    break;
                case 5:
                    message.trans_data = reader.bytes();
                    break;
                case 6:
                    message.trans_local_seq = reader.uint32();
                    break;
                case 7:
                    message.trans_channel = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return TransReq;
    })();

    liveroom_cs.TransRsp = (function() {

        /**
         * Properties of a TransRsp.
         * @memberof liveroom_cs
         * @interface ITransRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] TransRsp rsp_head
         * @property {Uint8Array|null} [trans_type] TransRsp trans_type
         * @property {number|null} [trans_seq] TransRsp trans_seq
         * @property {number|null} [trans_list_seq] TransRsp trans_list_seq
         * @property {Uint8Array|null} [trans_channel] TransRsp trans_channel
         */

        /**
         * Constructs a new TransRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a TransRsp.
         * @implements ITransRsp
         * @constructor
         * @param {liveroom_cs.ITransRsp=} [properties] Properties to set
         */
        function TransRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.TransRsp
         * @instance
         */
        TransRsp.prototype.rsp_head = null;

        /**
         * TransRsp trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.TransRsp
         * @instance
         */
        TransRsp.prototype.trans_type = $util.newBuffer([]);

        /**
         * TransRsp trans_seq.
         * @member {number} trans_seq
         * @memberof liveroom_cs.TransRsp
         * @instance
         */
        TransRsp.prototype.trans_seq = 0;

        /**
         * TransRsp trans_list_seq.
         * @member {number} trans_list_seq
         * @memberof liveroom_cs.TransRsp
         * @instance
         */
        TransRsp.prototype.trans_list_seq = 0;

        /**
         * TransRsp trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.TransRsp
         * @instance
         */
        TransRsp.prototype.trans_channel = $util.newBuffer([]);

        /**
         * Creates a new TransRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.TransRsp
         * @static
         * @param {liveroom_cs.ITransRsp=} [properties] Properties to set
         * @returns {liveroom_cs.TransRsp} TransRsp instance
         */
        TransRsp.create = function create(properties) {
            return new TransRsp(properties);
        };

        /**
         * Encodes the specified TransRsp message. Does not implicitly {@link liveroom_cs.TransRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.TransRsp
         * @static
         * @param {liveroom_cs.ITransRsp} message TransRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.trans_type);
            if (message.trans_seq != null && Object.hasOwnProperty.call(message, "trans_seq"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.trans_seq);
            if (message.trans_list_seq != null && Object.hasOwnProperty.call(message, "trans_list_seq"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.trans_list_seq);
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.trans_channel);
            return writer;
        };

        /**
         * Decodes a TransRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.TransRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.TransRsp} TransRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.TransRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.trans_type = reader.bytes();
                    break;
                case 3:
                    message.trans_seq = reader.uint32();
                    break;
                case 4:
                    message.trans_list_seq = reader.uint32();
                    break;
                case 5:
                    message.trans_channel = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return TransRsp;
    })();

    liveroom_cs.TransFetchReq = (function() {

        /**
         * Properties of a TransFetchReq.
         * @memberof liveroom_cs
         * @interface ITransFetchReq
         * @property {liveroom_cs.IReqHead|null} [req_head] TransFetchReq req_head
         * @property {Uint8Array|null} [trans_channel] TransFetchReq trans_channel
         * @property {Array.<liveroom_cs.IStTransFetch>|null} [fetch_array] TransFetchReq fetch_array
         */

        /**
         * Constructs a new TransFetchReq.
         * @memberof liveroom_cs
         * @classdesc Represents a TransFetchReq.
         * @implements ITransFetchReq
         * @constructor
         * @param {liveroom_cs.ITransFetchReq=} [properties] Properties to set
         */
        function TransFetchReq(properties) {
            this.fetch_array = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransFetchReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.TransFetchReq
         * @instance
         */
        TransFetchReq.prototype.req_head = null;

        /**
         * TransFetchReq trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.TransFetchReq
         * @instance
         */
        TransFetchReq.prototype.trans_channel = $util.newBuffer([]);

        /**
         * TransFetchReq fetch_array.
         * @member {Array.<liveroom_cs.IStTransFetch>} fetch_array
         * @memberof liveroom_cs.TransFetchReq
         * @instance
         */
        TransFetchReq.prototype.fetch_array = $util.emptyArray;

        /**
         * Creates a new TransFetchReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.TransFetchReq
         * @static
         * @param {liveroom_cs.ITransFetchReq=} [properties] Properties to set
         * @returns {liveroom_cs.TransFetchReq} TransFetchReq instance
         */
        TransFetchReq.create = function create(properties) {
            return new TransFetchReq(properties);
        };

        /**
         * Encodes the specified TransFetchReq message. Does not implicitly {@link liveroom_cs.TransFetchReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.TransFetchReq
         * @static
         * @param {liveroom_cs.ITransFetchReq} message TransFetchReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransFetchReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.trans_channel);
            if (message.fetch_array != null && message.fetch_array.length)
                for (var i = 0; i < message.fetch_array.length; ++i)
                    $root.liveroom_cs.StTransFetch.encode(message.fetch_array[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a TransFetchReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.TransFetchReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.TransFetchReq} TransFetchReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransFetchReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.TransFetchReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.trans_channel = reader.bytes();
                    break;
                case 3:
                    if (!(message.fetch_array && message.fetch_array.length))
                        message.fetch_array = [];
                    message.fetch_array.push($root.liveroom_cs.StTransFetch.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return TransFetchReq;
    })();

    liveroom_cs.StTransFetch = (function() {

        /**
         * Properties of a StTransFetch.
         * @memberof liveroom_cs
         * @interface IStTransFetch
         * @property {Uint8Array|null} [trans_type] StTransFetch trans_type
         * @property {number|null} [trans_local_seq] StTransFetch trans_local_seq
         */

        /**
         * Constructs a new StTransFetch.
         * @memberof liveroom_cs
         * @classdesc Represents a StTransFetch.
         * @implements IStTransFetch
         * @constructor
         * @param {liveroom_cs.IStTransFetch=} [properties] Properties to set
         */
        function StTransFetch(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StTransFetch trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.StTransFetch
         * @instance
         */
        StTransFetch.prototype.trans_type = $util.newBuffer([]);

        /**
         * StTransFetch trans_local_seq.
         * @member {number} trans_local_seq
         * @memberof liveroom_cs.StTransFetch
         * @instance
         */
        StTransFetch.prototype.trans_local_seq = 0;

        /**
         * Creates a new StTransFetch instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StTransFetch
         * @static
         * @param {liveroom_cs.IStTransFetch=} [properties] Properties to set
         * @returns {liveroom_cs.StTransFetch} StTransFetch instance
         */
        StTransFetch.create = function create(properties) {
            return new StTransFetch(properties);
        };

        /**
         * Encodes the specified StTransFetch message. Does not implicitly {@link liveroom_cs.StTransFetch.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StTransFetch
         * @static
         * @param {liveroom_cs.IStTransFetch} message StTransFetch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StTransFetch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_type);
            if (message.trans_local_seq != null && Object.hasOwnProperty.call(message, "trans_local_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.trans_local_seq);
            return writer;
        };

        /**
         * Decodes a StTransFetch message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StTransFetch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StTransFetch} StTransFetch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StTransFetch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StTransFetch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_type = reader.bytes();
                    break;
                case 2:
                    message.trans_local_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StTransFetch;
    })();

    liveroom_cs.TransFetchRsp = (function() {

        /**
         * Properties of a TransFetchRsp.
         * @memberof liveroom_cs
         * @interface ITransFetchRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] TransFetchRsp rsp_head
         * @property {Uint8Array|null} [trans_channel] TransFetchRsp trans_channel
         * @property {Array.<liveroom_cs.ITransFetchResult>|null} [trans_fetch_results] TransFetchRsp trans_fetch_results
         * @property {number|null} [trans_list_seq] TransFetchRsp trans_list_seq
         */

        /**
         * Constructs a new TransFetchRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a TransFetchRsp.
         * @implements ITransFetchRsp
         * @constructor
         * @param {liveroom_cs.ITransFetchRsp=} [properties] Properties to set
         */
        function TransFetchRsp(properties) {
            this.trans_fetch_results = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransFetchRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.TransFetchRsp
         * @instance
         */
        TransFetchRsp.prototype.rsp_head = null;

        /**
         * TransFetchRsp trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.TransFetchRsp
         * @instance
         */
        TransFetchRsp.prototype.trans_channel = $util.newBuffer([]);

        /**
         * TransFetchRsp trans_fetch_results.
         * @member {Array.<liveroom_cs.ITransFetchResult>} trans_fetch_results
         * @memberof liveroom_cs.TransFetchRsp
         * @instance
         */
        TransFetchRsp.prototype.trans_fetch_results = $util.emptyArray;

        /**
         * TransFetchRsp trans_list_seq.
         * @member {number} trans_list_seq
         * @memberof liveroom_cs.TransFetchRsp
         * @instance
         */
        TransFetchRsp.prototype.trans_list_seq = 0;

        /**
         * Creates a new TransFetchRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.TransFetchRsp
         * @static
         * @param {liveroom_cs.ITransFetchRsp=} [properties] Properties to set
         * @returns {liveroom_cs.TransFetchRsp} TransFetchRsp instance
         */
        TransFetchRsp.create = function create(properties) {
            return new TransFetchRsp(properties);
        };

        /**
         * Encodes the specified TransFetchRsp message. Does not implicitly {@link liveroom_cs.TransFetchRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.TransFetchRsp
         * @static
         * @param {liveroom_cs.ITransFetchRsp} message TransFetchRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransFetchRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.trans_channel);
            if (message.trans_fetch_results != null && message.trans_fetch_results.length)
                for (var i = 0; i < message.trans_fetch_results.length; ++i)
                    $root.liveroom_cs.TransFetchResult.encode(message.trans_fetch_results[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.trans_list_seq != null && Object.hasOwnProperty.call(message, "trans_list_seq"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.trans_list_seq);
            return writer;
        };

        /**
         * Decodes a TransFetchRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.TransFetchRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.TransFetchRsp} TransFetchRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransFetchRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.TransFetchRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.trans_channel = reader.bytes();
                    break;
                case 3:
                    if (!(message.trans_fetch_results && message.trans_fetch_results.length))
                        message.trans_fetch_results = [];
                    message.trans_fetch_results.push($root.liveroom_cs.TransFetchResult.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.trans_list_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return TransFetchRsp;
    })();

    liveroom_cs.TransFetchResult = (function() {

        /**
         * Properties of a TransFetchResult.
         * @memberof liveroom_cs
         * @interface ITransFetchResult
         * @property {Uint8Array|null} [trans_type] TransFetchResult trans_type
         * @property {Uint8Array|null} [trans_data] TransFetchResult trans_data
         * @property {Uint8Array|null} [trans_idname] TransFetchResult trans_idname
         * @property {Uint8Array|null} [trans_nickname] TransFetchResult trans_nickname
         * @property {number|null} [trans_role] TransFetchResult trans_role
         * @property {number|Long|null} [trans_send_time] TransFetchResult trans_send_time
         * @property {number|null} [trans_seq] TransFetchResult trans_seq
         * @property {number|null} [err_code] TransFetchResult err_code
         */

        /**
         * Constructs a new TransFetchResult.
         * @memberof liveroom_cs
         * @classdesc Represents a TransFetchResult.
         * @implements ITransFetchResult
         * @constructor
         * @param {liveroom_cs.ITransFetchResult=} [properties] Properties to set
         */
        function TransFetchResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransFetchResult trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.TransFetchResult
         * @instance
         */
        TransFetchResult.prototype.trans_type = $util.newBuffer([]);

        /**
         * TransFetchResult trans_data.
         * @member {Uint8Array} trans_data
         * @memberof liveroom_cs.TransFetchResult
         * @instance
         */
        TransFetchResult.prototype.trans_data = $util.newBuffer([]);

        /**
         * TransFetchResult trans_idname.
         * @member {Uint8Array} trans_idname
         * @memberof liveroom_cs.TransFetchResult
         * @instance
         */
        TransFetchResult.prototype.trans_idname = $util.newBuffer([]);

        /**
         * TransFetchResult trans_nickname.
         * @member {Uint8Array} trans_nickname
         * @memberof liveroom_cs.TransFetchResult
         * @instance
         */
        TransFetchResult.prototype.trans_nickname = $util.newBuffer([]);

        /**
         * TransFetchResult trans_role.
         * @member {number} trans_role
         * @memberof liveroom_cs.TransFetchResult
         * @instance
         */
        TransFetchResult.prototype.trans_role = 0;

        /**
         * TransFetchResult trans_send_time.
         * @member {number|Long} trans_send_time
         * @memberof liveroom_cs.TransFetchResult
         * @instance
         */
        TransFetchResult.prototype.trans_send_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransFetchResult trans_seq.
         * @member {number} trans_seq
         * @memberof liveroom_cs.TransFetchResult
         * @instance
         */
        TransFetchResult.prototype.trans_seq = 0;

        /**
         * TransFetchResult err_code.
         * @member {number} err_code
         * @memberof liveroom_cs.TransFetchResult
         * @instance
         */
        TransFetchResult.prototype.err_code = 0;

        /**
         * Creates a new TransFetchResult instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.TransFetchResult
         * @static
         * @param {liveroom_cs.ITransFetchResult=} [properties] Properties to set
         * @returns {liveroom_cs.TransFetchResult} TransFetchResult instance
         */
        TransFetchResult.create = function create(properties) {
            return new TransFetchResult(properties);
        };

        /**
         * Encodes the specified TransFetchResult message. Does not implicitly {@link liveroom_cs.TransFetchResult.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.TransFetchResult
         * @static
         * @param {liveroom_cs.ITransFetchResult} message TransFetchResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransFetchResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_type);
            if (message.trans_data != null && Object.hasOwnProperty.call(message, "trans_data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.trans_data);
            if (message.trans_idname != null && Object.hasOwnProperty.call(message, "trans_idname"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.trans_idname);
            if (message.trans_nickname != null && Object.hasOwnProperty.call(message, "trans_nickname"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.trans_nickname);
            if (message.trans_role != null && Object.hasOwnProperty.call(message, "trans_role"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.trans_role);
            if (message.trans_send_time != null && Object.hasOwnProperty.call(message, "trans_send_time"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.trans_send_time);
            if (message.trans_seq != null && Object.hasOwnProperty.call(message, "trans_seq"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.trans_seq);
            if (message.err_code != null && Object.hasOwnProperty.call(message, "err_code"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.err_code);
            return writer;
        };

        /**
         * Decodes a TransFetchResult message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.TransFetchResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.TransFetchResult} TransFetchResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransFetchResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.TransFetchResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_type = reader.bytes();
                    break;
                case 2:
                    message.trans_data = reader.bytes();
                    break;
                case 3:
                    message.trans_idname = reader.bytes();
                    break;
                case 4:
                    message.trans_nickname = reader.bytes();
                    break;
                case 5:
                    message.trans_role = reader.uint32();
                    break;
                case 6:
                    message.trans_send_time = reader.int64();
                    break;
                case 7:
                    message.trans_seq = reader.uint32();
                    break;
                case 8:
                    message.err_code = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return TransFetchResult;
    })();

    liveroom_cs.UserTransFetchReq = (function() {

        /**
         * Properties of a UserTransFetchReq.
         * @memberof liveroom_cs
         * @interface IUserTransFetchReq
         * @property {liveroom_cs.IReqHead|null} [req_head] UserTransFetchReq req_head
         * @property {Uint8Array|null} [nick_name] UserTransFetchReq nick_name
         * @property {number|null} [role] UserTransFetchReq role
         * @property {Uint8Array|null} [trans_channel] UserTransFetchReq trans_channel
         * @property {Array.<liveroom_cs.IStUserTransFetch>|null} [fetch_array] UserTransFetchReq fetch_array
         */

        /**
         * Constructs a new UserTransFetchReq.
         * @memberof liveroom_cs
         * @classdesc Represents a UserTransFetchReq.
         * @implements IUserTransFetchReq
         * @constructor
         * @param {liveroom_cs.IUserTransFetchReq=} [properties] Properties to set
         */
        function UserTransFetchReq(properties) {
            this.fetch_array = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserTransFetchReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.UserTransFetchReq
         * @instance
         */
        UserTransFetchReq.prototype.req_head = null;

        /**
         * UserTransFetchReq nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.UserTransFetchReq
         * @instance
         */
        UserTransFetchReq.prototype.nick_name = $util.newBuffer([]);

        /**
         * UserTransFetchReq role.
         * @member {number} role
         * @memberof liveroom_cs.UserTransFetchReq
         * @instance
         */
        UserTransFetchReq.prototype.role = 0;

        /**
         * UserTransFetchReq trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.UserTransFetchReq
         * @instance
         */
        UserTransFetchReq.prototype.trans_channel = $util.newBuffer([]);

        /**
         * UserTransFetchReq fetch_array.
         * @member {Array.<liveroom_cs.IStUserTransFetch>} fetch_array
         * @memberof liveroom_cs.UserTransFetchReq
         * @instance
         */
        UserTransFetchReq.prototype.fetch_array = $util.emptyArray;

        /**
         * Creates a new UserTransFetchReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.UserTransFetchReq
         * @static
         * @param {liveroom_cs.IUserTransFetchReq=} [properties] Properties to set
         * @returns {liveroom_cs.UserTransFetchReq} UserTransFetchReq instance
         */
        UserTransFetchReq.create = function create(properties) {
            return new UserTransFetchReq(properties);
        };

        /**
         * Encodes the specified UserTransFetchReq message. Does not implicitly {@link liveroom_cs.UserTransFetchReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.UserTransFetchReq
         * @static
         * @param {liveroom_cs.IUserTransFetchReq} message UserTransFetchReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserTransFetchReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.role);
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.trans_channel);
            if (message.fetch_array != null && message.fetch_array.length)
                for (var i = 0; i < message.fetch_array.length; ++i)
                    $root.liveroom_cs.StUserTransFetch.encode(message.fetch_array[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a UserTransFetchReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.UserTransFetchReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.UserTransFetchReq} UserTransFetchReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserTransFetchReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.UserTransFetchReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.nick_name = reader.bytes();
                    break;
                case 3:
                    message.role = reader.uint32();
                    break;
                case 4:
                    message.trans_channel = reader.bytes();
                    break;
                case 5:
                    if (!(message.fetch_array && message.fetch_array.length))
                        message.fetch_array = [];
                    message.fetch_array.push($root.liveroom_cs.StUserTransFetch.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return UserTransFetchReq;
    })();

    liveroom_cs.StUserTransFetch = (function() {

        /**
         * Properties of a StUserTransFetch.
         * @memberof liveroom_cs
         * @interface IStUserTransFetch
         * @property {Uint8Array|null} [trans_type] StUserTransFetch trans_type
         * @property {number|null} [trans_local_seq] StUserTransFetch trans_local_seq
         */

        /**
         * Constructs a new StUserTransFetch.
         * @memberof liveroom_cs
         * @classdesc Represents a StUserTransFetch.
         * @implements IStUserTransFetch
         * @constructor
         * @param {liveroom_cs.IStUserTransFetch=} [properties] Properties to set
         */
        function StUserTransFetch(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StUserTransFetch trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.StUserTransFetch
         * @instance
         */
        StUserTransFetch.prototype.trans_type = $util.newBuffer([]);

        /**
         * StUserTransFetch trans_local_seq.
         * @member {number} trans_local_seq
         * @memberof liveroom_cs.StUserTransFetch
         * @instance
         */
        StUserTransFetch.prototype.trans_local_seq = 0;

        /**
         * Creates a new StUserTransFetch instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StUserTransFetch
         * @static
         * @param {liveroom_cs.IStUserTransFetch=} [properties] Properties to set
         * @returns {liveroom_cs.StUserTransFetch} StUserTransFetch instance
         */
        StUserTransFetch.create = function create(properties) {
            return new StUserTransFetch(properties);
        };

        /**
         * Encodes the specified StUserTransFetch message. Does not implicitly {@link liveroom_cs.StUserTransFetch.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StUserTransFetch
         * @static
         * @param {liveroom_cs.IStUserTransFetch} message StUserTransFetch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StUserTransFetch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_type);
            if (message.trans_local_seq != null && Object.hasOwnProperty.call(message, "trans_local_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.trans_local_seq);
            return writer;
        };

        /**
         * Decodes a StUserTransFetch message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StUserTransFetch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StUserTransFetch} StUserTransFetch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StUserTransFetch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StUserTransFetch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_type = reader.bytes();
                    break;
                case 2:
                    message.trans_local_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StUserTransFetch;
    })();

    liveroom_cs.UserTransFetchRsp = (function() {

        /**
         * Properties of a UserTransFetchRsp.
         * @memberof liveroom_cs
         * @interface IUserTransFetchRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] UserTransFetchRsp rsp_head
         * @property {Uint8Array|null} [trans_channel] UserTransFetchRsp trans_channel
         * @property {Array.<liveroom_cs.IStUserTransFetchResult>|null} [trans_fetch_results] UserTransFetchRsp trans_fetch_results
         */

        /**
         * Constructs a new UserTransFetchRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a UserTransFetchRsp.
         * @implements IUserTransFetchRsp
         * @constructor
         * @param {liveroom_cs.IUserTransFetchRsp=} [properties] Properties to set
         */
        function UserTransFetchRsp(properties) {
            this.trans_fetch_results = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserTransFetchRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.UserTransFetchRsp
         * @instance
         */
        UserTransFetchRsp.prototype.rsp_head = null;

        /**
         * UserTransFetchRsp trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.UserTransFetchRsp
         * @instance
         */
        UserTransFetchRsp.prototype.trans_channel = $util.newBuffer([]);

        /**
         * UserTransFetchRsp trans_fetch_results.
         * @member {Array.<liveroom_cs.IStUserTransFetchResult>} trans_fetch_results
         * @memberof liveroom_cs.UserTransFetchRsp
         * @instance
         */
        UserTransFetchRsp.prototype.trans_fetch_results = $util.emptyArray;

        /**
         * Creates a new UserTransFetchRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.UserTransFetchRsp
         * @static
         * @param {liveroom_cs.IUserTransFetchRsp=} [properties] Properties to set
         * @returns {liveroom_cs.UserTransFetchRsp} UserTransFetchRsp instance
         */
        UserTransFetchRsp.create = function create(properties) {
            return new UserTransFetchRsp(properties);
        };

        /**
         * Encodes the specified UserTransFetchRsp message. Does not implicitly {@link liveroom_cs.UserTransFetchRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.UserTransFetchRsp
         * @static
         * @param {liveroom_cs.IUserTransFetchRsp} message UserTransFetchRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserTransFetchRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.trans_channel);
            if (message.trans_fetch_results != null && message.trans_fetch_results.length)
                for (var i = 0; i < message.trans_fetch_results.length; ++i)
                    $root.liveroom_cs.StUserTransFetchResult.encode(message.trans_fetch_results[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a UserTransFetchRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.UserTransFetchRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.UserTransFetchRsp} UserTransFetchRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserTransFetchRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.UserTransFetchRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.trans_channel = reader.bytes();
                    break;
                case 3:
                    if (!(message.trans_fetch_results && message.trans_fetch_results.length))
                        message.trans_fetch_results = [];
                    message.trans_fetch_results.push($root.liveroom_cs.StUserTransFetchResult.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return UserTransFetchRsp;
    })();

    liveroom_cs.StUserTransFetchResult = (function() {

        /**
         * Properties of a StUserTransFetchResult.
         * @memberof liveroom_cs
         * @interface IStUserTransFetchResult
         * @property {Uint8Array|null} [trans_type] StUserTransFetchResult trans_type
         * @property {Uint8Array|null} [trans_data] StUserTransFetchResult trans_data
         * @property {Uint8Array|null} [trans_idname] StUserTransFetchResult trans_idname
         * @property {Uint8Array|null} [trans_nickname] StUserTransFetchResult trans_nickname
         * @property {number|null} [trans_role] StUserTransFetchResult trans_role
         * @property {number|Long|null} [trans_send_time] StUserTransFetchResult trans_send_time
         * @property {number|null} [trans_seq] StUserTransFetchResult trans_seq
         * @property {number|null} [err_code] StUserTransFetchResult err_code
         */

        /**
         * Constructs a new StUserTransFetchResult.
         * @memberof liveroom_cs
         * @classdesc Represents a StUserTransFetchResult.
         * @implements IStUserTransFetchResult
         * @constructor
         * @param {liveroom_cs.IStUserTransFetchResult=} [properties] Properties to set
         */
        function StUserTransFetchResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StUserTransFetchResult trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.StUserTransFetchResult
         * @instance
         */
        StUserTransFetchResult.prototype.trans_type = $util.newBuffer([]);

        /**
         * StUserTransFetchResult trans_data.
         * @member {Uint8Array} trans_data
         * @memberof liveroom_cs.StUserTransFetchResult
         * @instance
         */
        StUserTransFetchResult.prototype.trans_data = $util.newBuffer([]);

        /**
         * StUserTransFetchResult trans_idname.
         * @member {Uint8Array} trans_idname
         * @memberof liveroom_cs.StUserTransFetchResult
         * @instance
         */
        StUserTransFetchResult.prototype.trans_idname = $util.newBuffer([]);

        /**
         * StUserTransFetchResult trans_nickname.
         * @member {Uint8Array} trans_nickname
         * @memberof liveroom_cs.StUserTransFetchResult
         * @instance
         */
        StUserTransFetchResult.prototype.trans_nickname = $util.newBuffer([]);

        /**
         * StUserTransFetchResult trans_role.
         * @member {number} trans_role
         * @memberof liveroom_cs.StUserTransFetchResult
         * @instance
         */
        StUserTransFetchResult.prototype.trans_role = 0;

        /**
         * StUserTransFetchResult trans_send_time.
         * @member {number|Long} trans_send_time
         * @memberof liveroom_cs.StUserTransFetchResult
         * @instance
         */
        StUserTransFetchResult.prototype.trans_send_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StUserTransFetchResult trans_seq.
         * @member {number} trans_seq
         * @memberof liveroom_cs.StUserTransFetchResult
         * @instance
         */
        StUserTransFetchResult.prototype.trans_seq = 0;

        /**
         * StUserTransFetchResult err_code.
         * @member {number} err_code
         * @memberof liveroom_cs.StUserTransFetchResult
         * @instance
         */
        StUserTransFetchResult.prototype.err_code = 0;

        /**
         * Creates a new StUserTransFetchResult instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StUserTransFetchResult
         * @static
         * @param {liveroom_cs.IStUserTransFetchResult=} [properties] Properties to set
         * @returns {liveroom_cs.StUserTransFetchResult} StUserTransFetchResult instance
         */
        StUserTransFetchResult.create = function create(properties) {
            return new StUserTransFetchResult(properties);
        };

        /**
         * Encodes the specified StUserTransFetchResult message. Does not implicitly {@link liveroom_cs.StUserTransFetchResult.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StUserTransFetchResult
         * @static
         * @param {liveroom_cs.IStUserTransFetchResult} message StUserTransFetchResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StUserTransFetchResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_type);
            if (message.trans_data != null && Object.hasOwnProperty.call(message, "trans_data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.trans_data);
            if (message.trans_idname != null && Object.hasOwnProperty.call(message, "trans_idname"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.trans_idname);
            if (message.trans_nickname != null && Object.hasOwnProperty.call(message, "trans_nickname"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.trans_nickname);
            if (message.trans_role != null && Object.hasOwnProperty.call(message, "trans_role"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.trans_role);
            if (message.trans_send_time != null && Object.hasOwnProperty.call(message, "trans_send_time"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.trans_send_time);
            if (message.trans_seq != null && Object.hasOwnProperty.call(message, "trans_seq"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.trans_seq);
            if (message.err_code != null && Object.hasOwnProperty.call(message, "err_code"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.err_code);
            return writer;
        };

        /**
         * Decodes a StUserTransFetchResult message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StUserTransFetchResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StUserTransFetchResult} StUserTransFetchResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StUserTransFetchResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StUserTransFetchResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_type = reader.bytes();
                    break;
                case 2:
                    message.trans_data = reader.bytes();
                    break;
                case 3:
                    message.trans_idname = reader.bytes();
                    break;
                case 4:
                    message.trans_nickname = reader.bytes();
                    break;
                case 5:
                    message.trans_role = reader.uint32();
                    break;
                case 6:
                    message.trans_send_time = reader.int64();
                    break;
                case 7:
                    message.trans_seq = reader.uint32();
                    break;
                case 8:
                    message.err_code = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StUserTransFetchResult;
    })();

    liveroom_cs.BigimChatReq = (function() {

        /**
         * Properties of a BigimChatReq.
         * @memberof liveroom_cs
         * @interface IBigimChatReq
         * @property {liveroom_cs.IReqHead|null} [req_head] BigimChatReq req_head
         * @property {Uint8Array|null} [nick_name] BigimChatReq nick_name
         * @property {number|null} [role] BigimChatReq role
         * @property {Array.<liveroom_cs.IStBigimChatData>|null} [msgs] BigimChatReq msgs
         */

        /**
         * Constructs a new BigimChatReq.
         * @memberof liveroom_cs
         * @classdesc Represents a BigimChatReq.
         * @implements IBigimChatReq
         * @constructor
         * @param {liveroom_cs.IBigimChatReq=} [properties] Properties to set
         */
        function BigimChatReq(properties) {
            this.msgs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BigimChatReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.BigimChatReq
         * @instance
         */
        BigimChatReq.prototype.req_head = null;

        /**
         * BigimChatReq nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.BigimChatReq
         * @instance
         */
        BigimChatReq.prototype.nick_name = $util.newBuffer([]);

        /**
         * BigimChatReq role.
         * @member {number} role
         * @memberof liveroom_cs.BigimChatReq
         * @instance
         */
        BigimChatReq.prototype.role = 0;

        /**
         * BigimChatReq msgs.
         * @member {Array.<liveroom_cs.IStBigimChatData>} msgs
         * @memberof liveroom_cs.BigimChatReq
         * @instance
         */
        BigimChatReq.prototype.msgs = $util.emptyArray;

        /**
         * Creates a new BigimChatReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.BigimChatReq
         * @static
         * @param {liveroom_cs.IBigimChatReq=} [properties] Properties to set
         * @returns {liveroom_cs.BigimChatReq} BigimChatReq instance
         */
        BigimChatReq.create = function create(properties) {
            return new BigimChatReq(properties);
        };

        /**
         * Encodes the specified BigimChatReq message. Does not implicitly {@link liveroom_cs.BigimChatReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.BigimChatReq
         * @static
         * @param {liveroom_cs.IBigimChatReq} message BigimChatReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigimChatReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.role);
            if (message.msgs != null && message.msgs.length)
                for (var i = 0; i < message.msgs.length; ++i)
                    $root.liveroom_cs.StBigimChatData.encode(message.msgs[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a BigimChatReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.BigimChatReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.BigimChatReq} BigimChatReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigimChatReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.BigimChatReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.nick_name = reader.bytes();
                    break;
                case 3:
                    message.role = reader.uint32();
                    break;
                case 4:
                    if (!(message.msgs && message.msgs.length))
                        message.msgs = [];
                    message.msgs.push($root.liveroom_cs.StBigimChatData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return BigimChatReq;
    })();

    liveroom_cs.StBigimChatData = (function() {

        /**
         * Properties of a StBigimChatData.
         * @memberof liveroom_cs
         * @interface IStBigimChatData
         * @property {number|null} [msg_category] StBigimChatData msg_category
         * @property {number|null} [msg_type] StBigimChatData msg_type
         * @property {Uint8Array|null} [msg_content] StBigimChatData msg_content
         * @property {number|Long|null} [msg_timestamp] StBigimChatData msg_timestamp
         * @property {Uint8Array|null} [bigmsg_client_id] StBigimChatData bigmsg_client_id
         */

        /**
         * Constructs a new StBigimChatData.
         * @memberof liveroom_cs
         * @classdesc Represents a StBigimChatData.
         * @implements IStBigimChatData
         * @constructor
         * @param {liveroom_cs.IStBigimChatData=} [properties] Properties to set
         */
        function StBigimChatData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StBigimChatData msg_category.
         * @member {number} msg_category
         * @memberof liveroom_cs.StBigimChatData
         * @instance
         */
        StBigimChatData.prototype.msg_category = 0;

        /**
         * StBigimChatData msg_type.
         * @member {number} msg_type
         * @memberof liveroom_cs.StBigimChatData
         * @instance
         */
        StBigimChatData.prototype.msg_type = 0;

        /**
         * StBigimChatData msg_content.
         * @member {Uint8Array} msg_content
         * @memberof liveroom_cs.StBigimChatData
         * @instance
         */
        StBigimChatData.prototype.msg_content = $util.newBuffer([]);

        /**
         * StBigimChatData msg_timestamp.
         * @member {number|Long} msg_timestamp
         * @memberof liveroom_cs.StBigimChatData
         * @instance
         */
        StBigimChatData.prototype.msg_timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StBigimChatData bigmsg_client_id.
         * @member {Uint8Array} bigmsg_client_id
         * @memberof liveroom_cs.StBigimChatData
         * @instance
         */
        StBigimChatData.prototype.bigmsg_client_id = $util.newBuffer([]);

        /**
         * Creates a new StBigimChatData instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StBigimChatData
         * @static
         * @param {liveroom_cs.IStBigimChatData=} [properties] Properties to set
         * @returns {liveroom_cs.StBigimChatData} StBigimChatData instance
         */
        StBigimChatData.create = function create(properties) {
            return new StBigimChatData(properties);
        };

        /**
         * Encodes the specified StBigimChatData message. Does not implicitly {@link liveroom_cs.StBigimChatData.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StBigimChatData
         * @static
         * @param {liveroom_cs.IStBigimChatData} message StBigimChatData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StBigimChatData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg_category != null && Object.hasOwnProperty.call(message, "msg_category"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.msg_category);
            if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.msg_type);
            if (message.msg_content != null && Object.hasOwnProperty.call(message, "msg_content"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.msg_content);
            if (message.msg_timestamp != null && Object.hasOwnProperty.call(message, "msg_timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.msg_timestamp);
            if (message.bigmsg_client_id != null && Object.hasOwnProperty.call(message, "bigmsg_client_id"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.bigmsg_client_id);
            return writer;
        };

        /**
         * Decodes a StBigimChatData message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StBigimChatData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StBigimChatData} StBigimChatData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StBigimChatData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StBigimChatData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg_category = reader.uint32();
                    break;
                case 2:
                    message.msg_type = reader.uint32();
                    break;
                case 3:
                    message.msg_content = reader.bytes();
                    break;
                case 4:
                    message.msg_timestamp = reader.int64();
                    break;
                case 5:
                    message.bigmsg_client_id = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StBigimChatData;
    })();

    liveroom_cs.BigimChatRsp = (function() {

        /**
         * Properties of a BigimChatRsp.
         * @memberof liveroom_cs
         * @interface IBigimChatRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] BigimChatRsp rsp_head
         * @property {number|null} [bigim_time_window] BigimChatRsp bigim_time_window
         * @property {Array.<liveroom_cs.IStBigimChatRspData>|null} [msgs] BigimChatRsp msgs
         */

        /**
         * Constructs a new BigimChatRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a BigimChatRsp.
         * @implements IBigimChatRsp
         * @constructor
         * @param {liveroom_cs.IBigimChatRsp=} [properties] Properties to set
         */
        function BigimChatRsp(properties) {
            this.msgs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BigimChatRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.BigimChatRsp
         * @instance
         */
        BigimChatRsp.prototype.rsp_head = null;

        /**
         * BigimChatRsp bigim_time_window.
         * @member {number} bigim_time_window
         * @memberof liveroom_cs.BigimChatRsp
         * @instance
         */
        BigimChatRsp.prototype.bigim_time_window = 0;

        /**
         * BigimChatRsp msgs.
         * @member {Array.<liveroom_cs.IStBigimChatRspData>} msgs
         * @memberof liveroom_cs.BigimChatRsp
         * @instance
         */
        BigimChatRsp.prototype.msgs = $util.emptyArray;

        /**
         * Creates a new BigimChatRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.BigimChatRsp
         * @static
         * @param {liveroom_cs.IBigimChatRsp=} [properties] Properties to set
         * @returns {liveroom_cs.BigimChatRsp} BigimChatRsp instance
         */
        BigimChatRsp.create = function create(properties) {
            return new BigimChatRsp(properties);
        };

        /**
         * Encodes the specified BigimChatRsp message. Does not implicitly {@link liveroom_cs.BigimChatRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.BigimChatRsp
         * @static
         * @param {liveroom_cs.IBigimChatRsp} message BigimChatRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigimChatRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.bigim_time_window != null && Object.hasOwnProperty.call(message, "bigim_time_window"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.bigim_time_window);
            if (message.msgs != null && message.msgs.length)
                for (var i = 0; i < message.msgs.length; ++i)
                    $root.liveroom_cs.StBigimChatRspData.encode(message.msgs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a BigimChatRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.BigimChatRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.BigimChatRsp} BigimChatRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigimChatRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.BigimChatRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.bigim_time_window = reader.uint32();
                    break;
                case 3:
                    if (!(message.msgs && message.msgs.length))
                        message.msgs = [];
                    message.msgs.push($root.liveroom_cs.StBigimChatRspData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return BigimChatRsp;
    })();

    liveroom_cs.StBigimChatRspData = (function() {

        /**
         * Properties of a StBigimChatRspData.
         * @memberof liveroom_cs
         * @interface IStBigimChatRspData
         * @property {Uint8Array|null} [bigmsg_id] StBigimChatRspData bigmsg_id
         * @property {Uint8Array|null} [bigmsg_client_id] StBigimChatRspData bigmsg_client_id
         */

        /**
         * Constructs a new StBigimChatRspData.
         * @memberof liveroom_cs
         * @classdesc Represents a StBigimChatRspData.
         * @implements IStBigimChatRspData
         * @constructor
         * @param {liveroom_cs.IStBigimChatRspData=} [properties] Properties to set
         */
        function StBigimChatRspData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StBigimChatRspData bigmsg_id.
         * @member {Uint8Array} bigmsg_id
         * @memberof liveroom_cs.StBigimChatRspData
         * @instance
         */
        StBigimChatRspData.prototype.bigmsg_id = $util.newBuffer([]);

        /**
         * StBigimChatRspData bigmsg_client_id.
         * @member {Uint8Array} bigmsg_client_id
         * @memberof liveroom_cs.StBigimChatRspData
         * @instance
         */
        StBigimChatRspData.prototype.bigmsg_client_id = $util.newBuffer([]);

        /**
         * Creates a new StBigimChatRspData instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StBigimChatRspData
         * @static
         * @param {liveroom_cs.IStBigimChatRspData=} [properties] Properties to set
         * @returns {liveroom_cs.StBigimChatRspData} StBigimChatRspData instance
         */
        StBigimChatRspData.create = function create(properties) {
            return new StBigimChatRspData(properties);
        };

        /**
         * Encodes the specified StBigimChatRspData message. Does not implicitly {@link liveroom_cs.StBigimChatRspData.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StBigimChatRspData
         * @static
         * @param {liveroom_cs.IStBigimChatRspData} message StBigimChatRspData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StBigimChatRspData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bigmsg_id != null && Object.hasOwnProperty.call(message, "bigmsg_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.bigmsg_id);
            if (message.bigmsg_client_id != null && Object.hasOwnProperty.call(message, "bigmsg_client_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bigmsg_client_id);
            return writer;
        };

        /**
         * Decodes a StBigimChatRspData message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StBigimChatRspData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StBigimChatRspData} StBigimChatRspData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StBigimChatRspData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StBigimChatRspData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bigmsg_id = reader.bytes();
                    break;
                case 2:
                    message.bigmsg_client_id = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StBigimChatRspData;
    })();

    liveroom_cs.RelayReq = (function() {

        /**
         * Properties of a RelayReq.
         * @memberof liveroom_cs
         * @interface IRelayReq
         * @property {liveroom_cs.IReqHead|null} [req_head] RelayReq req_head
         * @property {Uint8Array|null} [nick_name] RelayReq nick_name
         * @property {number|null} [role] RelayReq role
         * @property {Uint8Array|null} [relay_type] RelayReq relay_type
         * @property {Uint8Array|null} [relay_data] RelayReq relay_data
         */

        /**
         * Constructs a new RelayReq.
         * @memberof liveroom_cs
         * @classdesc Represents a RelayReq.
         * @implements IRelayReq
         * @constructor
         * @param {liveroom_cs.IRelayReq=} [properties] Properties to set
         */
        function RelayReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RelayReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.RelayReq
         * @instance
         */
        RelayReq.prototype.req_head = null;

        /**
         * RelayReq nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.RelayReq
         * @instance
         */
        RelayReq.prototype.nick_name = $util.newBuffer([]);

        /**
         * RelayReq role.
         * @member {number} role
         * @memberof liveroom_cs.RelayReq
         * @instance
         */
        RelayReq.prototype.role = 0;

        /**
         * RelayReq relay_type.
         * @member {Uint8Array} relay_type
         * @memberof liveroom_cs.RelayReq
         * @instance
         */
        RelayReq.prototype.relay_type = $util.newBuffer([]);

        /**
         * RelayReq relay_data.
         * @member {Uint8Array} relay_data
         * @memberof liveroom_cs.RelayReq
         * @instance
         */
        RelayReq.prototype.relay_data = $util.newBuffer([]);

        /**
         * Creates a new RelayReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.RelayReq
         * @static
         * @param {liveroom_cs.IRelayReq=} [properties] Properties to set
         * @returns {liveroom_cs.RelayReq} RelayReq instance
         */
        RelayReq.create = function create(properties) {
            return new RelayReq(properties);
        };

        /**
         * Encodes the specified RelayReq message. Does not implicitly {@link liveroom_cs.RelayReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.RelayReq
         * @static
         * @param {liveroom_cs.IRelayReq} message RelayReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RelayReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.role);
            if (message.relay_type != null && Object.hasOwnProperty.call(message, "relay_type"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.relay_type);
            if (message.relay_data != null && Object.hasOwnProperty.call(message, "relay_data"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.relay_data);
            return writer;
        };

        /**
         * Decodes a RelayReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.RelayReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.RelayReq} RelayReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RelayReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.RelayReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.nick_name = reader.bytes();
                    break;
                case 3:
                    message.role = reader.uint32();
                    break;
                case 4:
                    message.relay_type = reader.bytes();
                    break;
                case 5:
                    message.relay_data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RelayReq;
    })();

    liveroom_cs.RelayRsp = (function() {

        /**
         * Properties of a RelayRsp.
         * @memberof liveroom_cs
         * @interface IRelayRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] RelayRsp rsp_head
         * @property {Uint8Array|null} [reley_type] RelayRsp reley_type
         * @property {Uint8Array|null} [relay_result] RelayRsp relay_result
         */

        /**
         * Constructs a new RelayRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a RelayRsp.
         * @implements IRelayRsp
         * @constructor
         * @param {liveroom_cs.IRelayRsp=} [properties] Properties to set
         */
        function RelayRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RelayRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.RelayRsp
         * @instance
         */
        RelayRsp.prototype.rsp_head = null;

        /**
         * RelayRsp reley_type.
         * @member {Uint8Array} reley_type
         * @memberof liveroom_cs.RelayRsp
         * @instance
         */
        RelayRsp.prototype.reley_type = $util.newBuffer([]);

        /**
         * RelayRsp relay_result.
         * @member {Uint8Array} relay_result
         * @memberof liveroom_cs.RelayRsp
         * @instance
         */
        RelayRsp.prototype.relay_result = $util.newBuffer([]);

        /**
         * Creates a new RelayRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.RelayRsp
         * @static
         * @param {liveroom_cs.IRelayRsp=} [properties] Properties to set
         * @returns {liveroom_cs.RelayRsp} RelayRsp instance
         */
        RelayRsp.create = function create(properties) {
            return new RelayRsp(properties);
        };

        /**
         * Encodes the specified RelayRsp message. Does not implicitly {@link liveroom_cs.RelayRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.RelayRsp
         * @static
         * @param {liveroom_cs.IRelayRsp} message RelayRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RelayRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.reley_type != null && Object.hasOwnProperty.call(message, "reley_type"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.reley_type);
            if (message.relay_result != null && Object.hasOwnProperty.call(message, "relay_result"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.relay_result);
            return writer;
        };

        /**
         * Decodes a RelayRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.RelayRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.RelayRsp} RelayRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RelayRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.RelayRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.reley_type = reader.bytes();
                    break;
                case 3:
                    message.relay_result = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RelayRsp;
    })();

    liveroom_cs.RenewTokenReq = (function() {

        /**
         * Properties of a RenewTokenReq.
         * @memberof liveroom_cs
         * @interface IRenewTokenReq
         * @property {liveroom_cs.IReqHead|null} [req_head] RenewTokenReq req_head
         * @property {string|null} [token] RenewTokenReq token
         */

        /**
         * Constructs a new RenewTokenReq.
         * @memberof liveroom_cs
         * @classdesc Represents a RenewTokenReq.
         * @implements IRenewTokenReq
         * @constructor
         * @param {liveroom_cs.IRenewTokenReq=} [properties] Properties to set
         */
        function RenewTokenReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RenewTokenReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.RenewTokenReq
         * @instance
         */
        RenewTokenReq.prototype.req_head = null;

        /**
         * RenewTokenReq token.
         * @member {string} token
         * @memberof liveroom_cs.RenewTokenReq
         * @instance
         */
        RenewTokenReq.prototype.token = "";

        /**
         * Creates a new RenewTokenReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.RenewTokenReq
         * @static
         * @param {liveroom_cs.IRenewTokenReq=} [properties] Properties to set
         * @returns {liveroom_cs.RenewTokenReq} RenewTokenReq instance
         */
        RenewTokenReq.create = function create(properties) {
            return new RenewTokenReq(properties);
        };

        /**
         * Encodes the specified RenewTokenReq message. Does not implicitly {@link liveroom_cs.RenewTokenReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.RenewTokenReq
         * @static
         * @param {liveroom_cs.IRenewTokenReq} message RenewTokenReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenewTokenReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
            return writer;
        };

        /**
         * Decodes a RenewTokenReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.RenewTokenReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.RenewTokenReq} RenewTokenReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenewTokenReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.RenewTokenReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.token = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RenewTokenReq;
    })();

    liveroom_cs.RenewTokenRsp = (function() {

        /**
         * Properties of a RenewTokenRsp.
         * @memberof liveroom_cs
         * @interface IRenewTokenRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] RenewTokenRsp rsp_head
         * @property {number|null} [token_remain_time] RenewTokenRsp token_remain_time
         */

        /**
         * Constructs a new RenewTokenRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a RenewTokenRsp.
         * @implements IRenewTokenRsp
         * @constructor
         * @param {liveroom_cs.IRenewTokenRsp=} [properties] Properties to set
         */
        function RenewTokenRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RenewTokenRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.RenewTokenRsp
         * @instance
         */
        RenewTokenRsp.prototype.rsp_head = null;

        /**
         * RenewTokenRsp token_remain_time.
         * @member {number} token_remain_time
         * @memberof liveroom_cs.RenewTokenRsp
         * @instance
         */
        RenewTokenRsp.prototype.token_remain_time = 0;

        /**
         * Creates a new RenewTokenRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.RenewTokenRsp
         * @static
         * @param {liveroom_cs.IRenewTokenRsp=} [properties] Properties to set
         * @returns {liveroom_cs.RenewTokenRsp} RenewTokenRsp instance
         */
        RenewTokenRsp.create = function create(properties) {
            return new RenewTokenRsp(properties);
        };

        /**
         * Encodes the specified RenewTokenRsp message. Does not implicitly {@link liveroom_cs.RenewTokenRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.RenewTokenRsp
         * @static
         * @param {liveroom_cs.IRenewTokenRsp} message RenewTokenRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenewTokenRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.token_remain_time != null && Object.hasOwnProperty.call(message, "token_remain_time"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.token_remain_time);
            return writer;
        };

        /**
         * Decodes a RenewTokenRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.RenewTokenRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.RenewTokenRsp} RenewTokenRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenewTokenRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.RenewTokenRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.token_remain_time = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RenewTokenRsp;
    })();

    liveroom_cs.UserAction = (function() {

        /**
         * Properties of a UserAction.
         * @memberof liveroom_cs
         * @interface IUserAction
         * @property {number|null} [action] UserAction action
         * @property {Uint8Array|null} [id_name] UserAction id_name
         * @property {Uint8Array|null} [nick_name] UserAction nick_name
         * @property {number|null} [role] UserAction role
         * @property {number|Long|null} [login_time] UserAction login_time
         */

        /**
         * Constructs a new UserAction.
         * @memberof liveroom_cs
         * @classdesc Represents a UserAction.
         * @implements IUserAction
         * @constructor
         * @param {liveroom_cs.IUserAction=} [properties] Properties to set
         */
        function UserAction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserAction action.
         * @member {number} action
         * @memberof liveroom_cs.UserAction
         * @instance
         */
        UserAction.prototype.action = 0;

        /**
         * UserAction id_name.
         * @member {Uint8Array} id_name
         * @memberof liveroom_cs.UserAction
         * @instance
         */
        UserAction.prototype.id_name = $util.newBuffer([]);

        /**
         * UserAction nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.UserAction
         * @instance
         */
        UserAction.prototype.nick_name = $util.newBuffer([]);

        /**
         * UserAction role.
         * @member {number} role
         * @memberof liveroom_cs.UserAction
         * @instance
         */
        UserAction.prototype.role = 0;

        /**
         * UserAction login_time.
         * @member {number|Long} login_time
         * @memberof liveroom_cs.UserAction
         * @instance
         */
        UserAction.prototype.login_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UserAction instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.UserAction
         * @static
         * @param {liveroom_cs.IUserAction=} [properties] Properties to set
         * @returns {liveroom_cs.UserAction} UserAction instance
         */
        UserAction.create = function create(properties) {
            return new UserAction(properties);
        };

        /**
         * Encodes the specified UserAction message. Does not implicitly {@link liveroom_cs.UserAction.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.UserAction
         * @static
         * @param {liveroom_cs.IUserAction} message UserAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.action);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.id_name);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.role);
            if (message.login_time != null && Object.hasOwnProperty.call(message, "login_time"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.login_time);
            return writer;
        };

        /**
         * Decodes a UserAction message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.UserAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.UserAction} UserAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.UserAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.uint32();
                    break;
                case 2:
                    message.id_name = reader.bytes();
                    break;
                case 3:
                    message.nick_name = reader.bytes();
                    break;
                case 4:
                    message.role = reader.uint32();
                    break;
                case 5:
                    message.login_time = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return UserAction;
    })();

    liveroom_cs.PushUserInfoUpdated = (function() {

        /**
         * Properties of a PushUserInfoUpdated.
         * @memberof liveroom_cs
         * @interface IPushUserInfoUpdated
         * @property {Uint8Array|null} [room_id] PushUserInfoUpdated room_id
         * @property {number|Long|null} [server_user_seq] PushUserInfoUpdated server_user_seq
         * @property {Array.<liveroom_cs.IUserAction>|null} [user_list] PushUserInfoUpdated user_list
         */

        /**
         * Constructs a new PushUserInfoUpdated.
         * @memberof liveroom_cs
         * @classdesc Represents a PushUserInfoUpdated.
         * @implements IPushUserInfoUpdated
         * @constructor
         * @param {liveroom_cs.IPushUserInfoUpdated=} [properties] Properties to set
         */
        function PushUserInfoUpdated(properties) {
            this.user_list = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushUserInfoUpdated room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.PushUserInfoUpdated
         * @instance
         */
        PushUserInfoUpdated.prototype.room_id = $util.newBuffer([]);

        /**
         * PushUserInfoUpdated server_user_seq.
         * @member {number|Long} server_user_seq
         * @memberof liveroom_cs.PushUserInfoUpdated
         * @instance
         */
        PushUserInfoUpdated.prototype.server_user_seq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PushUserInfoUpdated user_list.
         * @member {Array.<liveroom_cs.IUserAction>} user_list
         * @memberof liveroom_cs.PushUserInfoUpdated
         * @instance
         */
        PushUserInfoUpdated.prototype.user_list = $util.emptyArray;

        /**
         * Creates a new PushUserInfoUpdated instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.PushUserInfoUpdated
         * @static
         * @param {liveroom_cs.IPushUserInfoUpdated=} [properties] Properties to set
         * @returns {liveroom_cs.PushUserInfoUpdated} PushUserInfoUpdated instance
         */
        PushUserInfoUpdated.create = function create(properties) {
            return new PushUserInfoUpdated(properties);
        };

        /**
         * Encodes the specified PushUserInfoUpdated message. Does not implicitly {@link liveroom_cs.PushUserInfoUpdated.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.PushUserInfoUpdated
         * @static
         * @param {liveroom_cs.IPushUserInfoUpdated} message PushUserInfoUpdated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushUserInfoUpdated.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.room_id);
            if (message.server_user_seq != null && Object.hasOwnProperty.call(message, "server_user_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.server_user_seq);
            if (message.user_list != null && message.user_list.length)
                for (var i = 0; i < message.user_list.length; ++i)
                    $root.liveroom_cs.UserAction.encode(message.user_list[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a PushUserInfoUpdated message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.PushUserInfoUpdated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.PushUserInfoUpdated} PushUserInfoUpdated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushUserInfoUpdated.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.PushUserInfoUpdated();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.room_id = reader.bytes();
                    break;
                case 2:
                    message.server_user_seq = reader.int64();
                    break;
                case 3:
                    if (!(message.user_list && message.user_list.length))
                        message.user_list = [];
                    message.user_list.push($root.liveroom_cs.UserAction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushUserInfoUpdated;
    })();

    liveroom_cs.PushUserKickout = (function() {

        /**
         * Properties of a PushUserKickout.
         * @memberof liveroom_cs
         * @interface IPushUserKickout
         * @property {Uint8Array|null} [id_name] PushUserKickout id_name
         * @property {Uint8Array|null} [room_id] PushUserKickout room_id
         * @property {number|Long|null} [session_id] PushUserKickout session_id
         * @property {number|null} [kickout_reason] PushUserKickout kickout_reason
         * @property {Uint8Array|null} [custom_reason] PushUserKickout custom_reason
         */

        /**
         * Constructs a new PushUserKickout.
         * @memberof liveroom_cs
         * @classdesc lr/push/user_kickout
         * @implements IPushUserKickout
         * @constructor
         * @param {liveroom_cs.IPushUserKickout=} [properties] Properties to set
         */
        function PushUserKickout(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushUserKickout id_name.
         * @member {Uint8Array} id_name
         * @memberof liveroom_cs.PushUserKickout
         * @instance
         */
        PushUserKickout.prototype.id_name = $util.newBuffer([]);

        /**
         * PushUserKickout room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.PushUserKickout
         * @instance
         */
        PushUserKickout.prototype.room_id = $util.newBuffer([]);

        /**
         * PushUserKickout session_id.
         * @member {number|Long} session_id
         * @memberof liveroom_cs.PushUserKickout
         * @instance
         */
        PushUserKickout.prototype.session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PushUserKickout kickout_reason.
         * @member {number} kickout_reason
         * @memberof liveroom_cs.PushUserKickout
         * @instance
         */
        PushUserKickout.prototype.kickout_reason = 0;

        /**
         * PushUserKickout custom_reason.
         * @member {Uint8Array} custom_reason
         * @memberof liveroom_cs.PushUserKickout
         * @instance
         */
        PushUserKickout.prototype.custom_reason = $util.newBuffer([]);

        /**
         * Creates a new PushUserKickout instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.PushUserKickout
         * @static
         * @param {liveroom_cs.IPushUserKickout=} [properties] Properties to set
         * @returns {liveroom_cs.PushUserKickout} PushUserKickout instance
         */
        PushUserKickout.create = function create(properties) {
            return new PushUserKickout(properties);
        };

        /**
         * Encodes the specified PushUserKickout message. Does not implicitly {@link liveroom_cs.PushUserKickout.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.PushUserKickout
         * @static
         * @param {liveroom_cs.IPushUserKickout} message PushUserKickout message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushUserKickout.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id_name);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.room_id);
            if (message.session_id != null && Object.hasOwnProperty.call(message, "session_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.session_id);
            if (message.kickout_reason != null && Object.hasOwnProperty.call(message, "kickout_reason"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.kickout_reason);
            if (message.custom_reason != null && Object.hasOwnProperty.call(message, "custom_reason"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.custom_reason);
            return writer;
        };

        /**
         * Decodes a PushUserKickout message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.PushUserKickout
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.PushUserKickout} PushUserKickout
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushUserKickout.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.PushUserKickout();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id_name = reader.bytes();
                    break;
                case 2:
                    message.room_id = reader.bytes();
                    break;
                case 3:
                    message.session_id = reader.uint64();
                    break;
                case 4:
                    message.kickout_reason = reader.int32();
                    break;
                case 5:
                    message.custom_reason = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushUserKickout;
    })();

    liveroom_cs.PushUserLogReport = (function() {

        /**
         * Properties of a PushUserLogReport.
         * @memberof liveroom_cs
         * @interface IPushUserLogReport
         */

        /**
         * Constructs a new PushUserLogReport.
         * @memberof liveroom_cs
         * @classdesc Represents a PushUserLogReport.
         * @implements IPushUserLogReport
         * @constructor
         * @param {liveroom_cs.IPushUserLogReport=} [properties] Properties to set
         */
        function PushUserLogReport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PushUserLogReport instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.PushUserLogReport
         * @static
         * @param {liveroom_cs.IPushUserLogReport=} [properties] Properties to set
         * @returns {liveroom_cs.PushUserLogReport} PushUserLogReport instance
         */
        PushUserLogReport.create = function create(properties) {
            return new PushUserLogReport(properties);
        };

        /**
         * Encodes the specified PushUserLogReport message. Does not implicitly {@link liveroom_cs.PushUserLogReport.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.PushUserLogReport
         * @static
         * @param {liveroom_cs.IPushUserLogReport} message PushUserLogReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushUserLogReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PushUserLogReport message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.PushUserLogReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.PushUserLogReport} PushUserLogReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushUserLogReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.PushUserLogReport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushUserLogReport;
    })();

    liveroom_cs.PushUserTokenExpire = (function() {

        /**
         * Properties of a PushUserTokenExpire.
         * @memberof liveroom_cs
         * @interface IPushUserTokenExpire
         * @property {Uint8Array|null} [room_id] PushUserTokenExpire room_id
         * @property {string|null} [token] PushUserTokenExpire token
         * @property {liveroom_cs.IStopStream|null} [stop_stream] PushUserTokenExpire stop_stream
         */

        /**
         * Constructs a new PushUserTokenExpire.
         * @memberof liveroom_cs
         * @classdesc Represents a PushUserTokenExpire.
         * @implements IPushUserTokenExpire
         * @constructor
         * @param {liveroom_cs.IPushUserTokenExpire=} [properties] Properties to set
         */
        function PushUserTokenExpire(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushUserTokenExpire room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.PushUserTokenExpire
         * @instance
         */
        PushUserTokenExpire.prototype.room_id = $util.newBuffer([]);

        /**
         * PushUserTokenExpire token.
         * @member {string} token
         * @memberof liveroom_cs.PushUserTokenExpire
         * @instance
         */
        PushUserTokenExpire.prototype.token = "";

        /**
         * PushUserTokenExpire stop_stream.
         * @member {liveroom_cs.IStopStream|null|undefined} stop_stream
         * @memberof liveroom_cs.PushUserTokenExpire
         * @instance
         */
        PushUserTokenExpire.prototype.stop_stream = null;

        /**
         * Creates a new PushUserTokenExpire instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.PushUserTokenExpire
         * @static
         * @param {liveroom_cs.IPushUserTokenExpire=} [properties] Properties to set
         * @returns {liveroom_cs.PushUserTokenExpire} PushUserTokenExpire instance
         */
        PushUserTokenExpire.create = function create(properties) {
            return new PushUserTokenExpire(properties);
        };

        /**
         * Encodes the specified PushUserTokenExpire message. Does not implicitly {@link liveroom_cs.PushUserTokenExpire.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.PushUserTokenExpire
         * @static
         * @param {liveroom_cs.IPushUserTokenExpire} message PushUserTokenExpire message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushUserTokenExpire.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.room_id);
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
            if (message.stop_stream != null && Object.hasOwnProperty.call(message, "stop_stream"))
                $root.liveroom_cs.StopStream.encode(message.stop_stream, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a PushUserTokenExpire message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.PushUserTokenExpire
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.PushUserTokenExpire} PushUserTokenExpire
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushUserTokenExpire.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.PushUserTokenExpire();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.room_id = reader.bytes();
                    break;
                case 2:
                    message.token = reader.string();
                    break;
                case 3:
                    message.stop_stream = $root.liveroom_cs.StopStream.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushUserTokenExpire;
    })();

    liveroom_cs.StopStream = (function() {

        /**
         * Properties of a StopStream.
         * @memberof liveroom_cs
         * @interface IStopStream
         * @property {Array.<Uint8Array>|null} [stream_id_list] StopStream stream_id_list
         */

        /**
         * Constructs a new StopStream.
         * @memberof liveroom_cs
         * @classdesc Represents a StopStream.
         * @implements IStopStream
         * @constructor
         * @param {liveroom_cs.IStopStream=} [properties] Properties to set
         */
        function StopStream(properties) {
            this.stream_id_list = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopStream stream_id_list.
         * @member {Array.<Uint8Array>} stream_id_list
         * @memberof liveroom_cs.StopStream
         * @instance
         */
        StopStream.prototype.stream_id_list = $util.emptyArray;

        /**
         * Creates a new StopStream instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StopStream
         * @static
         * @param {liveroom_cs.IStopStream=} [properties] Properties to set
         * @returns {liveroom_cs.StopStream} StopStream instance
         */
        StopStream.create = function create(properties) {
            return new StopStream(properties);
        };

        /**
         * Encodes the specified StopStream message. Does not implicitly {@link liveroom_cs.StopStream.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StopStream
         * @static
         * @param {liveroom_cs.IStopStream} message StopStream message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopStream.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stream_id_list != null && message.stream_id_list.length)
                for (var i = 0; i < message.stream_id_list.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.stream_id_list[i]);
            return writer;
        };

        /**
         * Decodes a StopStream message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StopStream
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StopStream} StopStream
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopStream.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StopStream();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.stream_id_list && message.stream_id_list.length))
                        message.stream_id_list = [];
                    message.stream_id_list.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StopStream;
    })();

    liveroom_cs.PushStream = (function() {

        /**
         * Properties of a PushStream.
         * @memberof liveroom_cs
         * @interface IPushStream
         * @property {Uint8Array|null} [room_id] PushStream room_id
         * @property {number|null} [stream_seq] PushStream stream_seq
         * @property {Array.<liveroom_cs.IStPushStreamInfo>|null} [stream_info] PushStream stream_info
         */

        /**
         * Constructs a new PushStream.
         * @memberof liveroom_cs
         * @classdesc Represents a PushStream.
         * @implements IPushStream
         * @constructor
         * @param {liveroom_cs.IPushStream=} [properties] Properties to set
         */
        function PushStream(properties) {
            this.stream_info = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushStream room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.PushStream
         * @instance
         */
        PushStream.prototype.room_id = $util.newBuffer([]);

        /**
         * PushStream stream_seq.
         * @member {number} stream_seq
         * @memberof liveroom_cs.PushStream
         * @instance
         */
        PushStream.prototype.stream_seq = 0;

        /**
         * PushStream stream_info.
         * @member {Array.<liveroom_cs.IStPushStreamInfo>} stream_info
         * @memberof liveroom_cs.PushStream
         * @instance
         */
        PushStream.prototype.stream_info = $util.emptyArray;

        /**
         * Creates a new PushStream instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.PushStream
         * @static
         * @param {liveroom_cs.IPushStream=} [properties] Properties to set
         * @returns {liveroom_cs.PushStream} PushStream instance
         */
        PushStream.create = function create(properties) {
            return new PushStream(properties);
        };

        /**
         * Encodes the specified PushStream message. Does not implicitly {@link liveroom_cs.PushStream.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.PushStream
         * @static
         * @param {liveroom_cs.IPushStream} message PushStream message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushStream.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.room_id);
            if (message.stream_seq != null && Object.hasOwnProperty.call(message, "stream_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stream_seq);
            if (message.stream_info != null && message.stream_info.length)
                for (var i = 0; i < message.stream_info.length; ++i)
                    $root.liveroom_cs.StPushStreamInfo.encode(message.stream_info[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a PushStream message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.PushStream
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.PushStream} PushStream
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushStream.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.PushStream();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.room_id = reader.bytes();
                    break;
                case 2:
                    message.stream_seq = reader.uint32();
                    break;
                case 3:
                    if (!(message.stream_info && message.stream_info.length))
                        message.stream_info = [];
                    message.stream_info.push($root.liveroom_cs.StPushStreamInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushStream;
    })();

    liveroom_cs.StPushStreamInfo = (function() {

        /**
         * Properties of a StPushStreamInfo.
         * @memberof liveroom_cs
         * @interface IStPushStreamInfo
         * @property {Uint8Array|null} [stream_id] StPushStreamInfo stream_id
         * @property {string|null} [stream_sid] StPushStreamInfo stream_sid
         * @property {Uint8Array|null} [id_name] StPushStreamInfo id_name
         * @property {Uint8Array|null} [nick_name] StPushStreamInfo nick_name
         * @property {Uint8Array|null} [extra_info] StPushStreamInfo extra_info
         * @property {Uint8Array|null} [title] StPushStreamInfo title
         * @property {Uint8Array|null} [third_define_data] StPushStreamInfo third_define_data
         * @property {number|Long|null} [create_time] StPushStreamInfo create_time
         * @property {number|null} [req_seq] StPushStreamInfo req_seq
         * @property {number|null} [stream_ver] StPushStreamInfo stream_ver
         * @property {Uint8Array|null} [stream_attr] StPushStreamInfo stream_attr
         * @property {number|null} [stream_src] StPushStreamInfo stream_src
         * @property {number|null} [stream_state] StPushStreamInfo stream_state
         * @property {number|null} [stream_type] StPushStreamInfo stream_type
         * @property {number|null} [stream_nid] StPushStreamInfo stream_nid
         * @property {number|null} [close_type] StPushStreamInfo close_type
         */

        /**
         * Constructs a new StPushStreamInfo.
         * @memberof liveroom_cs
         * @classdesc Represents a StPushStreamInfo.
         * @implements IStPushStreamInfo
         * @constructor
         * @param {liveroom_cs.IStPushStreamInfo=} [properties] Properties to set
         */
        function StPushStreamInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StPushStreamInfo stream_id.
         * @member {Uint8Array} stream_id
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.stream_id = $util.newBuffer([]);

        /**
         * StPushStreamInfo stream_sid.
         * @member {string} stream_sid
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.stream_sid = "";

        /**
         * StPushStreamInfo id_name.
         * @member {Uint8Array} id_name
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.id_name = $util.newBuffer([]);

        /**
         * StPushStreamInfo nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.nick_name = $util.newBuffer([]);

        /**
         * StPushStreamInfo extra_info.
         * @member {Uint8Array} extra_info
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.extra_info = $util.newBuffer([]);

        /**
         * StPushStreamInfo title.
         * @member {Uint8Array} title
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.title = $util.newBuffer([]);

        /**
         * StPushStreamInfo third_define_data.
         * @member {Uint8Array} third_define_data
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.third_define_data = $util.newBuffer([]);

        /**
         * StPushStreamInfo create_time.
         * @member {number|Long} create_time
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.create_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StPushStreamInfo req_seq.
         * @member {number} req_seq
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.req_seq = 0;

        /**
         * StPushStreamInfo stream_ver.
         * @member {number} stream_ver
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.stream_ver = 0;

        /**
         * StPushStreamInfo stream_attr.
         * @member {Uint8Array} stream_attr
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.stream_attr = $util.newBuffer([]);

        /**
         * StPushStreamInfo stream_src.
         * @member {number} stream_src
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.stream_src = 0;

        /**
         * StPushStreamInfo stream_state.
         * @member {number} stream_state
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.stream_state = 0;

        /**
         * StPushStreamInfo stream_type.
         * @member {number} stream_type
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.stream_type = 0;

        /**
         * StPushStreamInfo stream_nid.
         * @member {number} stream_nid
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.stream_nid = 0;

        /**
         * StPushStreamInfo close_type.
         * @member {number} close_type
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.close_type = 0;

        /**
         * Creates a new StPushStreamInfo instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StPushStreamInfo
         * @static
         * @param {liveroom_cs.IStPushStreamInfo=} [properties] Properties to set
         * @returns {liveroom_cs.StPushStreamInfo} StPushStreamInfo instance
         */
        StPushStreamInfo.create = function create(properties) {
            return new StPushStreamInfo(properties);
        };

        /**
         * Encodes the specified StPushStreamInfo message. Does not implicitly {@link liveroom_cs.StPushStreamInfo.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StPushStreamInfo
         * @static
         * @param {liveroom_cs.IStPushStreamInfo} message StPushStreamInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StPushStreamInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.stream_id);
            if (message.stream_sid != null && Object.hasOwnProperty.call(message, "stream_sid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.stream_sid);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.id_name);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.nick_name);
            if (message.extra_info != null && Object.hasOwnProperty.call(message, "extra_info"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.extra_info);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.title);
            if (message.third_define_data != null && Object.hasOwnProperty.call(message, "third_define_data"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.third_define_data);
            if (message.create_time != null && Object.hasOwnProperty.call(message, "create_time"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.create_time);
            if (message.req_seq != null && Object.hasOwnProperty.call(message, "req_seq"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.req_seq);
            if (message.stream_ver != null && Object.hasOwnProperty.call(message, "stream_ver"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.stream_ver);
            if (message.stream_attr != null && Object.hasOwnProperty.call(message, "stream_attr"))
                writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.stream_attr);
            if (message.stream_src != null && Object.hasOwnProperty.call(message, "stream_src"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.stream_src);
            if (message.stream_state != null && Object.hasOwnProperty.call(message, "stream_state"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.stream_state);
            if (message.stream_type != null && Object.hasOwnProperty.call(message, "stream_type"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.stream_type);
            if (message.stream_nid != null && Object.hasOwnProperty.call(message, "stream_nid"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.stream_nid);
            if (message.close_type != null && Object.hasOwnProperty.call(message, "close_type"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.close_type);
            return writer;
        };

        /**
         * Decodes a StPushStreamInfo message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StPushStreamInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StPushStreamInfo} StPushStreamInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StPushStreamInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StPushStreamInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stream_id = reader.bytes();
                    break;
                case 2:
                    message.stream_sid = reader.string();
                    break;
                case 3:
                    message.id_name = reader.bytes();
                    break;
                case 4:
                    message.nick_name = reader.bytes();
                    break;
                case 5:
                    message.extra_info = reader.bytes();
                    break;
                case 6:
                    message.title = reader.bytes();
                    break;
                case 7:
                    message.third_define_data = reader.bytes();
                    break;
                case 8:
                    message.create_time = reader.int64();
                    break;
                case 9:
                    message.req_seq = reader.uint32();
                    break;
                case 10:
                    message.stream_ver = reader.uint32();
                    break;
                case 11:
                    message.stream_attr = reader.bytes();
                    break;
                case 12:
                    message.stream_src = reader.uint32();
                    break;
                case 13:
                    message.stream_state = reader.uint32();
                    break;
                case 14:
                    message.stream_type = reader.uint32();
                    break;
                case 15:
                    message.stream_nid = reader.uint32();
                    break;
                case 16:
                    message.close_type = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StPushStreamInfo;
    })();

    liveroom_cs.PushImChat = (function() {

        /**
         * Properties of a PushImChat.
         * @memberof liveroom_cs
         * @interface IPushImChat
         * @property {Uint8Array|null} [room_id] PushImChat room_id
         * @property {number|Long|null} [server_msg_id] PushImChat server_msg_id
         * @property {number|Long|null} [ret_msg_id] PushImChat ret_msg_id
         * @property {Array.<liveroom_cs.IStImChatData>|null} [msg_data] PushImChat msg_data
         */

        /**
         * Constructs a new PushImChat.
         * @memberof liveroom_cs
         * @classdesc Represents a PushImChat.
         * @implements IPushImChat
         * @constructor
         * @param {liveroom_cs.IPushImChat=} [properties] Properties to set
         */
        function PushImChat(properties) {
            this.msg_data = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushImChat room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.PushImChat
         * @instance
         */
        PushImChat.prototype.room_id = $util.newBuffer([]);

        /**
         * PushImChat server_msg_id.
         * @member {number|Long} server_msg_id
         * @memberof liveroom_cs.PushImChat
         * @instance
         */
        PushImChat.prototype.server_msg_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PushImChat ret_msg_id.
         * @member {number|Long} ret_msg_id
         * @memberof liveroom_cs.PushImChat
         * @instance
         */
        PushImChat.prototype.ret_msg_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PushImChat msg_data.
         * @member {Array.<liveroom_cs.IStImChatData>} msg_data
         * @memberof liveroom_cs.PushImChat
         * @instance
         */
        PushImChat.prototype.msg_data = $util.emptyArray;

        /**
         * Creates a new PushImChat instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.PushImChat
         * @static
         * @param {liveroom_cs.IPushImChat=} [properties] Properties to set
         * @returns {liveroom_cs.PushImChat} PushImChat instance
         */
        PushImChat.create = function create(properties) {
            return new PushImChat(properties);
        };

        /**
         * Encodes the specified PushImChat message. Does not implicitly {@link liveroom_cs.PushImChat.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.PushImChat
         * @static
         * @param {liveroom_cs.IPushImChat} message PushImChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushImChat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.room_id);
            if (message.server_msg_id != null && Object.hasOwnProperty.call(message, "server_msg_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.server_msg_id);
            if (message.ret_msg_id != null && Object.hasOwnProperty.call(message, "ret_msg_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.ret_msg_id);
            if (message.msg_data != null && message.msg_data.length)
                for (var i = 0; i < message.msg_data.length; ++i)
                    $root.liveroom_cs.StImChatData.encode(message.msg_data[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a PushImChat message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.PushImChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.PushImChat} PushImChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushImChat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.PushImChat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.room_id = reader.bytes();
                    break;
                case 2:
                    message.server_msg_id = reader.uint64();
                    break;
                case 3:
                    message.ret_msg_id = reader.uint64();
                    break;
                case 4:
                    if (!(message.msg_data && message.msg_data.length))
                        message.msg_data = [];
                    message.msg_data.push($root.liveroom_cs.StImChatData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushImChat;
    })();

    liveroom_cs.StImChatData = (function() {

        /**
         * Properties of a StImChatData.
         * @memberof liveroom_cs
         * @interface IStImChatData
         * @property {Uint8Array|null} [id_name] StImChatData id_name
         * @property {Uint8Array|null} [nick_name] StImChatData nick_name
         * @property {number|null} [role] StImChatData role
         * @property {number|Long|null} [msg_id] StImChatData msg_id
         * @property {number|null} [msg_category] StImChatData msg_category
         * @property {number|null} [msg_type] StImChatData msg_type
         * @property {number|null} [msg_priority] StImChatData msg_priority
         * @property {Uint8Array|null} [msg_content] StImChatData msg_content
         * @property {number|Long|null} [send_time] StImChatData send_time
         */

        /**
         * Constructs a new StImChatData.
         * @memberof liveroom_cs
         * @classdesc Represents a StImChatData.
         * @implements IStImChatData
         * @constructor
         * @param {liveroom_cs.IStImChatData=} [properties] Properties to set
         */
        function StImChatData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StImChatData id_name.
         * @member {Uint8Array} id_name
         * @memberof liveroom_cs.StImChatData
         * @instance
         */
        StImChatData.prototype.id_name = $util.newBuffer([]);

        /**
         * StImChatData nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.StImChatData
         * @instance
         */
        StImChatData.prototype.nick_name = $util.newBuffer([]);

        /**
         * StImChatData role.
         * @member {number} role
         * @memberof liveroom_cs.StImChatData
         * @instance
         */
        StImChatData.prototype.role = 0;

        /**
         * StImChatData msg_id.
         * @member {number|Long} msg_id
         * @memberof liveroom_cs.StImChatData
         * @instance
         */
        StImChatData.prototype.msg_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StImChatData msg_category.
         * @member {number} msg_category
         * @memberof liveroom_cs.StImChatData
         * @instance
         */
        StImChatData.prototype.msg_category = 0;

        /**
         * StImChatData msg_type.
         * @member {number} msg_type
         * @memberof liveroom_cs.StImChatData
         * @instance
         */
        StImChatData.prototype.msg_type = 0;

        /**
         * StImChatData msg_priority.
         * @member {number} msg_priority
         * @memberof liveroom_cs.StImChatData
         * @instance
         */
        StImChatData.prototype.msg_priority = 0;

        /**
         * StImChatData msg_content.
         * @member {Uint8Array} msg_content
         * @memberof liveroom_cs.StImChatData
         * @instance
         */
        StImChatData.prototype.msg_content = $util.newBuffer([]);

        /**
         * StImChatData send_time.
         * @member {number|Long} send_time
         * @memberof liveroom_cs.StImChatData
         * @instance
         */
        StImChatData.prototype.send_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new StImChatData instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StImChatData
         * @static
         * @param {liveroom_cs.IStImChatData=} [properties] Properties to set
         * @returns {liveroom_cs.StImChatData} StImChatData instance
         */
        StImChatData.create = function create(properties) {
            return new StImChatData(properties);
        };

        /**
         * Encodes the specified StImChatData message. Does not implicitly {@link liveroom_cs.StImChatData.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StImChatData
         * @static
         * @param {liveroom_cs.IStImChatData} message StImChatData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StImChatData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id_name);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.role);
            if (message.msg_id != null && Object.hasOwnProperty.call(message, "msg_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.msg_id);
            if (message.msg_category != null && Object.hasOwnProperty.call(message, "msg_category"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.msg_category);
            if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.msg_type);
            if (message.msg_priority != null && Object.hasOwnProperty.call(message, "msg_priority"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.msg_priority);
            if (message.msg_content != null && Object.hasOwnProperty.call(message, "msg_content"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.msg_content);
            if (message.send_time != null && Object.hasOwnProperty.call(message, "send_time"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.send_time);
            return writer;
        };

        /**
         * Decodes a StImChatData message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StImChatData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StImChatData} StImChatData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StImChatData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StImChatData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id_name = reader.bytes();
                    break;
                case 2:
                    message.nick_name = reader.bytes();
                    break;
                case 3:
                    message.role = reader.uint32();
                    break;
                case 4:
                    message.msg_id = reader.uint64();
                    break;
                case 5:
                    message.msg_category = reader.uint32();
                    break;
                case 6:
                    message.msg_type = reader.uint32();
                    break;
                case 7:
                    message.msg_priority = reader.uint32();
                    break;
                case 8:
                    message.msg_content = reader.bytes();
                    break;
                case 9:
                    message.send_time = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StImChatData;
    })();

    liveroom_cs.PushBigImChat = (function() {

        /**
         * Properties of a PushBigImChat.
         * @memberof liveroom_cs
         * @interface IPushBigImChat
         * @property {number|null} [app_id] PushBigImChat app_id
         * @property {Uint8Array|null} [room_id] PushBigImChat room_id
         * @property {number|Long|null} [timestamp] PushBigImChat timestamp
         * @property {Array.<liveroom_cs.IStBigImChatData>|null} [msg_data] PushBigImChat msg_data
         */

        /**
         * Constructs a new PushBigImChat.
         * @memberof liveroom_cs
         * @classdesc Represents a PushBigImChat.
         * @implements IPushBigImChat
         * @constructor
         * @param {liveroom_cs.IPushBigImChat=} [properties] Properties to set
         */
        function PushBigImChat(properties) {
            this.msg_data = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushBigImChat app_id.
         * @member {number} app_id
         * @memberof liveroom_cs.PushBigImChat
         * @instance
         */
        PushBigImChat.prototype.app_id = 0;

        /**
         * PushBigImChat room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.PushBigImChat
         * @instance
         */
        PushBigImChat.prototype.room_id = $util.newBuffer([]);

        /**
         * PushBigImChat timestamp.
         * @member {number|Long} timestamp
         * @memberof liveroom_cs.PushBigImChat
         * @instance
         */
        PushBigImChat.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PushBigImChat msg_data.
         * @member {Array.<liveroom_cs.IStBigImChatData>} msg_data
         * @memberof liveroom_cs.PushBigImChat
         * @instance
         */
        PushBigImChat.prototype.msg_data = $util.emptyArray;

        /**
         * Creates a new PushBigImChat instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.PushBigImChat
         * @static
         * @param {liveroom_cs.IPushBigImChat=} [properties] Properties to set
         * @returns {liveroom_cs.PushBigImChat} PushBigImChat instance
         */
        PushBigImChat.create = function create(properties) {
            return new PushBigImChat(properties);
        };

        /**
         * Encodes the specified PushBigImChat message. Does not implicitly {@link liveroom_cs.PushBigImChat.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.PushBigImChat
         * @static
         * @param {liveroom_cs.IPushBigImChat} message PushBigImChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushBigImChat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.app_id != null && Object.hasOwnProperty.call(message, "app_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.app_id);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.room_id);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            if (message.msg_data != null && message.msg_data.length)
                for (var i = 0; i < message.msg_data.length; ++i)
                    $root.liveroom_cs.StBigImChatData.encode(message.msg_data[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a PushBigImChat message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.PushBigImChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.PushBigImChat} PushBigImChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushBigImChat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.PushBigImChat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.app_id = reader.uint32();
                    break;
                case 2:
                    message.room_id = reader.bytes();
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                case 4:
                    if (!(message.msg_data && message.msg_data.length))
                        message.msg_data = [];
                    message.msg_data.push($root.liveroom_cs.StBigImChatData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushBigImChat;
    })();

    liveroom_cs.StBigImChatData = (function() {

        /**
         * Properties of a StBigImChatData.
         * @memberof liveroom_cs
         * @interface IStBigImChatData
         * @property {Uint8Array|null} [id_name] StBigImChatData id_name
         * @property {Uint8Array|null} [nick_name] StBigImChatData nick_name
         * @property {number|null} [role] StBigImChatData role
         * @property {Uint8Array|null} [bigmsg_id] StBigImChatData bigmsg_id
         * @property {number|null} [msg_category] StBigImChatData msg_category
         * @property {number|null} [msg_type] StBigImChatData msg_type
         * @property {Uint8Array|null} [msg_content] StBigImChatData msg_content
         * @property {number|Long|null} [msg_timestamp] StBigImChatData msg_timestamp
         */

        /**
         * Constructs a new StBigImChatData.
         * @memberof liveroom_cs
         * @classdesc Represents a StBigImChatData.
         * @implements IStBigImChatData
         * @constructor
         * @param {liveroom_cs.IStBigImChatData=} [properties] Properties to set
         */
        function StBigImChatData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StBigImChatData id_name.
         * @member {Uint8Array} id_name
         * @memberof liveroom_cs.StBigImChatData
         * @instance
         */
        StBigImChatData.prototype.id_name = $util.newBuffer([]);

        /**
         * StBigImChatData nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.StBigImChatData
         * @instance
         */
        StBigImChatData.prototype.nick_name = $util.newBuffer([]);

        /**
         * StBigImChatData role.
         * @member {number} role
         * @memberof liveroom_cs.StBigImChatData
         * @instance
         */
        StBigImChatData.prototype.role = 0;

        /**
         * StBigImChatData bigmsg_id.
         * @member {Uint8Array} bigmsg_id
         * @memberof liveroom_cs.StBigImChatData
         * @instance
         */
        StBigImChatData.prototype.bigmsg_id = $util.newBuffer([]);

        /**
         * StBigImChatData msg_category.
         * @member {number} msg_category
         * @memberof liveroom_cs.StBigImChatData
         * @instance
         */
        StBigImChatData.prototype.msg_category = 0;

        /**
         * StBigImChatData msg_type.
         * @member {number} msg_type
         * @memberof liveroom_cs.StBigImChatData
         * @instance
         */
        StBigImChatData.prototype.msg_type = 0;

        /**
         * StBigImChatData msg_content.
         * @member {Uint8Array} msg_content
         * @memberof liveroom_cs.StBigImChatData
         * @instance
         */
        StBigImChatData.prototype.msg_content = $util.newBuffer([]);

        /**
         * StBigImChatData msg_timestamp.
         * @member {number|Long} msg_timestamp
         * @memberof liveroom_cs.StBigImChatData
         * @instance
         */
        StBigImChatData.prototype.msg_timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new StBigImChatData instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StBigImChatData
         * @static
         * @param {liveroom_cs.IStBigImChatData=} [properties] Properties to set
         * @returns {liveroom_cs.StBigImChatData} StBigImChatData instance
         */
        StBigImChatData.create = function create(properties) {
            return new StBigImChatData(properties);
        };

        /**
         * Encodes the specified StBigImChatData message. Does not implicitly {@link liveroom_cs.StBigImChatData.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StBigImChatData
         * @static
         * @param {liveroom_cs.IStBigImChatData} message StBigImChatData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StBigImChatData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id_name);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.role);
            if (message.bigmsg_id != null && Object.hasOwnProperty.call(message, "bigmsg_id"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.bigmsg_id);
            if (message.msg_category != null && Object.hasOwnProperty.call(message, "msg_category"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.msg_category);
            if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.msg_type);
            if (message.msg_content != null && Object.hasOwnProperty.call(message, "msg_content"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.msg_content);
            if (message.msg_timestamp != null && Object.hasOwnProperty.call(message, "msg_timestamp"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.msg_timestamp);
            return writer;
        };

        /**
         * Decodes a StBigImChatData message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StBigImChatData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StBigImChatData} StBigImChatData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StBigImChatData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StBigImChatData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id_name = reader.bytes();
                    break;
                case 2:
                    message.nick_name = reader.bytes();
                    break;
                case 3:
                    message.role = reader.uint32();
                    break;
                case 4:
                    message.bigmsg_id = reader.bytes();
                    break;
                case 5:
                    message.msg_category = reader.uint32();
                    break;
                case 6:
                    message.msg_type = reader.uint32();
                    break;
                case 7:
                    message.msg_content = reader.bytes();
                    break;
                case 8:
                    message.msg_timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StBigImChatData;
    })();

    liveroom_cs.PushTrans = (function() {

        /**
         * Properties of a PushTrans.
         * @memberof liveroom_cs
         * @interface IPushTrans
         * @property {number|null} [app_id] PushTrans app_id
         * @property {Uint8Array|null} [room_id] PushTrans room_id
         * @property {Uint8Array|null} [trans_idname] PushTrans trans_idname
         * @property {Uint8Array|null} [trans_nickname] PushTrans trans_nickname
         * @property {number|null} [trans_role] PushTrans trans_role
         * @property {Uint8Array|null} [trans_type] PushTrans trans_type
         * @property {Uint8Array|null} [trans_data] PushTrans trans_data
         * @property {number|null} [trans_seq] PushTrans trans_seq
         * @property {number|Long|null} [trans_send_time] PushTrans trans_send_time
         * @property {Uint8Array|null} [trans_channel] PushTrans trans_channel
         * @property {number|null} [trans_list_seq] PushTrans trans_list_seq
         */

        /**
         * Constructs a new PushTrans.
         * @memberof liveroom_cs
         * @classdesc Represents a PushTrans.
         * @implements IPushTrans
         * @constructor
         * @param {liveroom_cs.IPushTrans=} [properties] Properties to set
         */
        function PushTrans(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushTrans app_id.
         * @member {number} app_id
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.app_id = 0;

        /**
         * PushTrans room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.room_id = $util.newBuffer([]);

        /**
         * PushTrans trans_idname.
         * @member {Uint8Array} trans_idname
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.trans_idname = $util.newBuffer([]);

        /**
         * PushTrans trans_nickname.
         * @member {Uint8Array} trans_nickname
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.trans_nickname = $util.newBuffer([]);

        /**
         * PushTrans trans_role.
         * @member {number} trans_role
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.trans_role = 0;

        /**
         * PushTrans trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.trans_type = $util.newBuffer([]);

        /**
         * PushTrans trans_data.
         * @member {Uint8Array} trans_data
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.trans_data = $util.newBuffer([]);

        /**
         * PushTrans trans_seq.
         * @member {number} trans_seq
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.trans_seq = 0;

        /**
         * PushTrans trans_send_time.
         * @member {number|Long} trans_send_time
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.trans_send_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PushTrans trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.trans_channel = $util.newBuffer([]);

        /**
         * PushTrans trans_list_seq.
         * @member {number} trans_list_seq
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.trans_list_seq = 0;

        /**
         * Creates a new PushTrans instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.PushTrans
         * @static
         * @param {liveroom_cs.IPushTrans=} [properties] Properties to set
         * @returns {liveroom_cs.PushTrans} PushTrans instance
         */
        PushTrans.create = function create(properties) {
            return new PushTrans(properties);
        };

        /**
         * Encodes the specified PushTrans message. Does not implicitly {@link liveroom_cs.PushTrans.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.PushTrans
         * @static
         * @param {liveroom_cs.IPushTrans} message PushTrans message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushTrans.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.app_id != null && Object.hasOwnProperty.call(message, "app_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.app_id);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.room_id);
            if (message.trans_idname != null && Object.hasOwnProperty.call(message, "trans_idname"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.trans_idname);
            if (message.trans_nickname != null && Object.hasOwnProperty.call(message, "trans_nickname"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.trans_nickname);
            if (message.trans_role != null && Object.hasOwnProperty.call(message, "trans_role"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.trans_role);
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.trans_type);
            if (message.trans_data != null && Object.hasOwnProperty.call(message, "trans_data"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.trans_data);
            if (message.trans_seq != null && Object.hasOwnProperty.call(message, "trans_seq"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.trans_seq);
            if (message.trans_send_time != null && Object.hasOwnProperty.call(message, "trans_send_time"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.trans_send_time);
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.trans_channel);
            if (message.trans_list_seq != null && Object.hasOwnProperty.call(message, "trans_list_seq"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.trans_list_seq);
            return writer;
        };

        /**
         * Decodes a PushTrans message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.PushTrans
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.PushTrans} PushTrans
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushTrans.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.PushTrans();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.app_id = reader.uint32();
                    break;
                case 2:
                    message.room_id = reader.bytes();
                    break;
                case 3:
                    message.trans_idname = reader.bytes();
                    break;
                case 4:
                    message.trans_nickname = reader.bytes();
                    break;
                case 5:
                    message.trans_role = reader.uint32();
                    break;
                case 6:
                    message.trans_type = reader.bytes();
                    break;
                case 7:
                    message.trans_data = reader.bytes();
                    break;
                case 8:
                    message.trans_seq = reader.uint32();
                    break;
                case 9:
                    message.trans_send_time = reader.int64();
                    break;
                case 10:
                    message.trans_channel = reader.bytes();
                    break;
                case 11:
                    message.trans_list_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushTrans;
    })();

    liveroom_cs.PushUserTrans = (function() {

        /**
         * Properties of a PushUserTrans.
         * @memberof liveroom_cs
         * @interface IPushUserTrans
         * @property {number|null} [app_id] PushUserTrans app_id
         * @property {Uint8Array|null} [room_id] PushUserTrans room_id
         * @property {Uint8Array|null} [trans_idname] PushUserTrans trans_idname
         * @property {Uint8Array|null} [trans_nickname] PushUserTrans trans_nickname
         * @property {number|null} [trans_role] PushUserTrans trans_role
         * @property {number|Long|null} [trans_send_time] PushUserTrans trans_send_time
         * @property {Uint8Array|null} [trans_channel] PushUserTrans trans_channel
         * @property {Array.<liveroom_cs.IStTransSimple>|null} [trans_array] PushUserTrans trans_array
         */

        /**
         * Constructs a new PushUserTrans.
         * @memberof liveroom_cs
         * @classdesc Represents a PushUserTrans.
         * @implements IPushUserTrans
         * @constructor
         * @param {liveroom_cs.IPushUserTrans=} [properties] Properties to set
         */
        function PushUserTrans(properties) {
            this.trans_array = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushUserTrans app_id.
         * @member {number} app_id
         * @memberof liveroom_cs.PushUserTrans
         * @instance
         */
        PushUserTrans.prototype.app_id = 0;

        /**
         * PushUserTrans room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.PushUserTrans
         * @instance
         */
        PushUserTrans.prototype.room_id = $util.newBuffer([]);

        /**
         * PushUserTrans trans_idname.
         * @member {Uint8Array} trans_idname
         * @memberof liveroom_cs.PushUserTrans
         * @instance
         */
        PushUserTrans.prototype.trans_idname = $util.newBuffer([]);

        /**
         * PushUserTrans trans_nickname.
         * @member {Uint8Array} trans_nickname
         * @memberof liveroom_cs.PushUserTrans
         * @instance
         */
        PushUserTrans.prototype.trans_nickname = $util.newBuffer([]);

        /**
         * PushUserTrans trans_role.
         * @member {number} trans_role
         * @memberof liveroom_cs.PushUserTrans
         * @instance
         */
        PushUserTrans.prototype.trans_role = 0;

        /**
         * PushUserTrans trans_send_time.
         * @member {number|Long} trans_send_time
         * @memberof liveroom_cs.PushUserTrans
         * @instance
         */
        PushUserTrans.prototype.trans_send_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PushUserTrans trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.PushUserTrans
         * @instance
         */
        PushUserTrans.prototype.trans_channel = $util.newBuffer([]);

        /**
         * PushUserTrans trans_array.
         * @member {Array.<liveroom_cs.IStTransSimple>} trans_array
         * @memberof liveroom_cs.PushUserTrans
         * @instance
         */
        PushUserTrans.prototype.trans_array = $util.emptyArray;

        /**
         * Creates a new PushUserTrans instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.PushUserTrans
         * @static
         * @param {liveroom_cs.IPushUserTrans=} [properties] Properties to set
         * @returns {liveroom_cs.PushUserTrans} PushUserTrans instance
         */
        PushUserTrans.create = function create(properties) {
            return new PushUserTrans(properties);
        };

        /**
         * Encodes the specified PushUserTrans message. Does not implicitly {@link liveroom_cs.PushUserTrans.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.PushUserTrans
         * @static
         * @param {liveroom_cs.IPushUserTrans} message PushUserTrans message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushUserTrans.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.app_id != null && Object.hasOwnProperty.call(message, "app_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.app_id);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.room_id);
            if (message.trans_idname != null && Object.hasOwnProperty.call(message, "trans_idname"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.trans_idname);
            if (message.trans_nickname != null && Object.hasOwnProperty.call(message, "trans_nickname"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.trans_nickname);
            if (message.trans_role != null && Object.hasOwnProperty.call(message, "trans_role"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.trans_role);
            if (message.trans_send_time != null && Object.hasOwnProperty.call(message, "trans_send_time"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.trans_send_time);
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.trans_channel);
            if (message.trans_array != null && message.trans_array.length)
                for (var i = 0; i < message.trans_array.length; ++i)
                    $root.liveroom_cs.StTransSimple.encode(message.trans_array[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a PushUserTrans message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.PushUserTrans
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.PushUserTrans} PushUserTrans
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushUserTrans.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.PushUserTrans();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.app_id = reader.uint32();
                    break;
                case 2:
                    message.room_id = reader.bytes();
                    break;
                case 3:
                    message.trans_idname = reader.bytes();
                    break;
                case 4:
                    message.trans_nickname = reader.bytes();
                    break;
                case 5:
                    message.trans_role = reader.uint32();
                    break;
                case 9:
                    message.trans_send_time = reader.int64();
                    break;
                case 10:
                    message.trans_channel = reader.bytes();
                    break;
                case 11:
                    if (!(message.trans_array && message.trans_array.length))
                        message.trans_array = [];
                    message.trans_array.push($root.liveroom_cs.StTransSimple.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushUserTrans;
    })();

    liveroom_cs.StTransSimple = (function() {

        /**
         * Properties of a StTransSimple.
         * @memberof liveroom_cs
         * @interface IStTransSimple
         * @property {Uint8Array|null} [trans_type] StTransSimple trans_type
         * @property {Uint8Array|null} [trans_data] StTransSimple trans_data
         * @property {number|null} [trans_seq] StTransSimple trans_seq
         */

        /**
         * Constructs a new StTransSimple.
         * @memberof liveroom_cs
         * @classdesc Represents a StTransSimple.
         * @implements IStTransSimple
         * @constructor
         * @param {liveroom_cs.IStTransSimple=} [properties] Properties to set
         */
        function StTransSimple(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StTransSimple trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.StTransSimple
         * @instance
         */
        StTransSimple.prototype.trans_type = $util.newBuffer([]);

        /**
         * StTransSimple trans_data.
         * @member {Uint8Array} trans_data
         * @memberof liveroom_cs.StTransSimple
         * @instance
         */
        StTransSimple.prototype.trans_data = $util.newBuffer([]);

        /**
         * StTransSimple trans_seq.
         * @member {number} trans_seq
         * @memberof liveroom_cs.StTransSimple
         * @instance
         */
        StTransSimple.prototype.trans_seq = 0;

        /**
         * Creates a new StTransSimple instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StTransSimple
         * @static
         * @param {liveroom_cs.IStTransSimple=} [properties] Properties to set
         * @returns {liveroom_cs.StTransSimple} StTransSimple instance
         */
        StTransSimple.create = function create(properties) {
            return new StTransSimple(properties);
        };

        /**
         * Encodes the specified StTransSimple message. Does not implicitly {@link liveroom_cs.StTransSimple.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StTransSimple
         * @static
         * @param {liveroom_cs.IStTransSimple} message StTransSimple message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StTransSimple.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_type);
            if (message.trans_data != null && Object.hasOwnProperty.call(message, "trans_data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.trans_data);
            if (message.trans_seq != null && Object.hasOwnProperty.call(message, "trans_seq"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.trans_seq);
            return writer;
        };

        /**
         * Decodes a StTransSimple message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StTransSimple
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StTransSimple} StTransSimple
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StTransSimple.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StTransSimple();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_type = reader.bytes();
                    break;
                case 2:
                    message.trans_data = reader.bytes();
                    break;
                case 3:
                    message.trans_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StTransSimple;
    })();

    return liveroom_cs;
})();

module.exports = $root;


/***/ }),

/***/ "./sdk/src/modules/retryHandler.ts":
/*!*****************************************!*\
  !*** ./sdk/src/modules/retryHandler.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TryHandler = void 0;
var TryHandler = /** @class */ (function () {
    function TryHandler(logger, stateCenter) {
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.RETRY_MAX_TIME = 300;
        this.RETRY_START_TIME_INTERVAL = 4;
        this.RETRY_CONTINUE_COUNT = 2;
        this.RETRY_MAX_TIME_INTERVAL = 32;
        this.retryTimer = null;
        this.maxTimer = null;
        this.retryStartTime = 0;
        this.retryActiveCount = 1;
        this.isOverTime = false;
    }
    //初始化重试
    TryHandler.prototype.init = function (retryMaxTime, startTimeInterval, retryContinuteCount, maxTimeInterval) {
        this.invalid();
        this.stopMaxTime();
        this.isOverTime = false;
        if (typeof retryMaxTime == 'number' && retryMaxTime < 3600) {
            this.RETRY_MAX_TIME = retryMaxTime;
        }
        if (typeof startTimeInterval == 'number') {
            this.RETRY_START_TIME_INTERVAL = startTimeInterval;
        }
        if (typeof retryContinuteCount == 'number') {
            this.RETRY_CONTINUE_COUNT = retryContinuteCount;
        }
        if (typeof maxTimeInterval == 'number') {
            this.RETRY_MAX_TIME_INTERVAL = maxTimeInterval;
        }
    };
    //暂停重试
    TryHandler.prototype.invalid = function () {
        this.retryTimer && clearTimeout(this.retryTimer);
        this.retryTimer = null;
        this.retryStartTime = 0;
        this.retryActiveCount = 1;
    };
    return TryHandler;
}());
exports.TryHandler = TryHandler;


/***/ }),

/***/ "./sdk/src/modules/retryRoomHandler.ts":
/*!*********************************************!*\
  !*** ./sdk/src/modules/retryRoomHandler.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1438104__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.RetryRoomHandler = void 0;
var retryHandler_1 = __nested_webpack_require_1438104__(/*! ./retryHandler */ "./sdk/src/modules/retryHandler.ts");
var zego_entity_1 = __nested_webpack_require_1438104__(/*! ../zego.entity */ "./sdk/src/zego.entity.ts");
var zego_action_1 = __nested_webpack_require_1438104__(/*! ../zego.action */ "./sdk/src/zego.action.ts");
var zego_externalError_1 = __nested_webpack_require_1438104__(/*! ../zego.externalError */ "./sdk/src/zego.externalError.ts");
var client_util_1 = __nested_webpack_require_1438104__(/*! ../../util/client-util */ "./sdk/util/client-util.ts");
var RetryRoomHandler = /** @class */ (function (_super) {
    __extends(RetryRoomHandler, _super);
    function RetryRoomHandler(logger, stateCenter, room) {
        var _this = _super.call(this, logger, stateCenter) || this;
        _this.logger = logger;
        _this.stateCenter = stateCenter;
        _this.room = room;
        // loginRoom 登录房间接口回调函数
        _this.loginRoomCallback = {};
        return _this;
    }
    RetryRoomHandler.prototype.renewLocalToken = function (token, remainTime) {
        this.token = token;
        this.room.token = this.token;
        var currentTime = new Date().getTime();
        var remainTimeResult = undefined;
        if (remainTime && typeof remainTime === 'number') {
            remainTimeResult = remainTime * 1000;
        }
        else if (token.substr(0, 2) === '03') {
            remainTimeResult = client_util_1.ClientUtil.decodeTokenExpire(token.substr(2)) * 1000 - currentTime;
        }
        remainTimeResult && this.roomHandler.resetTokenTimer(remainTimeResult - this.stateCenter.local_time_deviation);
        this.stateCenter.actionListener('_tokenRenewed', token, this.room.roomID);
    };
    //初始化房间信息
    RetryRoomHandler.prototype.initRoom = function (roomHandler, roomID, token, user, server, serverBak, config) {
        this.roomHandler = roomHandler;
        this.roomID = roomID;
        this.renewLocalToken(token);
        this.user = user;
        this.server = server;
        this.serverBak = serverBak ? serverBak : server;
        this.config = config;
    };
    //激活房间重试
    RetryRoomHandler.prototype.active = function (isFirst) {
        var _this = this;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + ' retry call');
        this.roomHandler.setRunState(zego_entity_1.ENUM_RUN_STATE.trylogin);
        //service 断开且为多房间则不触发
        if (this.room.isMulti && this.room.isDisConnect()) {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + ' service is disconnected, multi room stop retry');
            return;
        }
        //网络中断不进行重试
        if (this.stateCenter.networkState == zego_entity_1.ENUM_NETWORK_STATE.offline) {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + ' network is broken, stop retry');
            return;
        }
        //已触发了重试,忽略
        if (this.retryTimer) {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + ' has actived, ignore');
            return;
        }
        //若已经过了最大重试时间，则不进行重试
        if (this.isOverTime) {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + ' retry over time, stop retry');
            return;
        }
        //根据重试次数来决定下次重试时间
        if (this.retryActiveCount == 1) {
            this.retryActiveInterval = Math.floor(Math.random() * (1 - this.RETRY_START_TIME_INTERVAL) + this.RETRY_START_TIME_INTERVAL);
        }
        else {
            var retryActiveInterval = Math.pow(2, Math.round(this.retryActiveCount / this.RETRY_CONTINUE_COUNT + 1));
            this.retryActiveInterval =
                retryActiveInterval > this.RETRY_MAX_TIME_INTERVAL ? this.RETRY_MAX_TIME_INTERVAL : retryActiveInterval;
        }
        this.retryTimer = setTimeout(function () {
            _this.roomHandler.login(_this.retryActiveCount % 2 == 1 ? _this.server : _this.serverBak, _this.roomID, _this.token, _this.user, _this.config, function (success) {
                _this.handleLoginFinish(success);
            }, function (err, isServerError) {
                _this.handleLoginFinish(false, err, isServerError);
            });
            _this.retryTimer && clearTimeout(_this.retryTimer);
            _this.retryTimer = null;
            _this.retryActiveCount++;
        }, isFirst ? 0 : this.retryActiveInterval * 1000);
    };
    //开启最大重试时间计时
    RetryRoomHandler.prototype.startMaxTime = function () {
        var _this = this;
        if (this.maxTimer) {
            return;
        }
        this.maxTimer = setTimeout(function () {
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + (" over max time " + _this.RETRY_MAX_TIME + "s, stop retry"));
            _this.isOverTime = true;
            //最大重试超时时间清空房间信息
            _this.roomHandler.resetRoom();
            _this.stopMaxTime();
            _this.invalid();
            _this.onactive(false, zego_externalError_1.errorCodeList.LOGIN_TIMEOUT);
            if (_this.loginRoomCallback.fail) {
                _this.loginRoomCallback.fail(zego_externalError_1.errorCodeList.LOGIN_TIMEOUT);
                _this.roomHandler.disconnectedHandle(zego_externalError_1.errorCodeList.LOGIN_TIMEOUT);
                _this.loginRoomCallback.fail = undefined;
            }
        }, this.RETRY_MAX_TIME * 1e3);
    };
    //停止最大重试时间计时
    RetryRoomHandler.prototype.stopMaxTime = function () {
        this.maxTimer && clearTimeout(this.maxTimer);
        this.maxTimer = null;
    };
    //重试完成触发
    RetryRoomHandler.prototype.onactive = function (success, error) { };
    //处理登录返回错误码，根据错误码判断哪些需要重试或中止重试
    RetryRoomHandler.prototype.handleError = function (error, isServerError) {
        //最大重试时间小于3s则认为不重试
        if (this.RETRY_MAX_TIME < 3) {
            return false;
        }
        if (isServerError) {
            var stopErrorList = void 0, retryErrorList = void 0, resetErrorList = void 0;
            if (this.stateCenter.useNetAgent) {
                stopErrorList = ['202002', '205030', '205035', '50116', '50117', '50118'];
                retryErrorList = ['40001', '40100'];
                resetErrorList = ['201002', '30019'];
            }
            else {
                /*
                  强制终⽌的错误码，sdk收到后会⽴即终⽌
                  const unsigned int kLiveRoomThirdTokenAuthError = 1000002002; //third token auth error
                  const unsigned int kLiveRoomBlackListErrcode = 1000005030; //禁⽌⿊名单⽤户，登录段被暂⽤， 被迫添加在这⾥
                  const unsigned int kLiveRoomTokenBlackListErrcode = 1000005035; //禁⽌token⿊名单⽤户
                  */
                stopErrorList = [
                    '1000002002',
                    '1000005030',
                    '1000005035',
                    '1010',
                    '1011',
                    '1013',
                    '1014',
                    '1015',
                    '1016',
                    '1017',
                    '1018',
                    '1019',
                    '1020',
                    '1021',
                    '1023',
                ];
                retryErrorList = ['1100040001', '1100040100'];
            }
            var code = error.code + '';
            console.error('code ', code);
            if (this.stateCenter.useNetAgent) {
                if ((error.code >= 40001 && error.code <= 40100) || (error.code >= 50200 && error.code <= 50299) || (resetErrorList === null || resetErrorList === void 0 ? void 0 : resetErrorList.includes(code))) {
                    console.error('重登录');
                    this.room.resetSessionInfo();
                    return true;
                }
            }
            if (stopErrorList.includes(code)) {
                return false;
            }
            else if (retryErrorList.includes(code)) {
                return true;
            }
            else if (this.room.lastRunState == zego_entity_1.ENUM_RUN_STATE.login) {
                //成功登录过房间需要重登录并重置登录策略
                this.room.sessionID = '0';
                this.invalid();
                return true;
            }
            else {
                return false;
            }
        }
        else {
            return true;
        }
    };
    RetryRoomHandler.prototype.setLoginRoomCallback = function (success, fail) {
        this.loginRoomCallback.success = success;
        this.loginRoomCallback.fail = fail;
    };
    //登录完成后处理，是否继续重试或中止重试
    RetryRoomHandler.prototype.handleLoginFinish = function (success, error, isServerError) {
        if (error) {
            //需要重试的错误码
            if (this.handleError(error, isServerError)) {
                !this.maxTimer && this.startMaxTime();
                this.active();
            }
            else {
                //终止重试
                this.roomHandler.resetRoom();
                this.stopMaxTime();
                this.invalid();
                this.onactive(success, error);
                if (this.loginRoomCallback.fail) {
                    this.loginRoomCallback.fail(error);
                    this.roomHandler.disconnectedHandle(error);
                    this.loginRoomCallback.fail = undefined;
                }
            }
        }
        else {
            //登录成功
            this.stopMaxTime();
            this.invalid();
            this.onactive(success, { code: 0, msg: '' });
            if (this.loginRoomCallback.success) {
                this.loginRoomCallback.success(success);
                this.loginRoomCallback.fail = undefined;
            }
        }
    };
    return RetryRoomHandler;
}(retryHandler_1.TryHandler));
exports.RetryRoomHandler = RetryRoomHandler;


/***/ }),

/***/ "./sdk/src/modules/roomHandler.ts":
/*!****************************************!*\
  !*** ./sdk/src/modules/roomHandler.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1448717__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RoomHandler = void 0;
var zego_entity_1 = __nested_webpack_require_1448717__(/*! ../zego.entity */ "./sdk/src/zego.entity.ts");
var client_util_1 = __nested_webpack_require_1448717__(/*! ../../util/client-util */ "./sdk/util/client-util.ts");
var zego_action_1 = __nested_webpack_require_1448717__(/*! ../zego.action */ "./sdk/src/zego.action.ts");
var zego_externalError_1 = __nested_webpack_require_1448717__(/*! ../zego.externalError */ "./sdk/src/zego.externalError.ts");
var zego_log_event_1 = __nested_webpack_require_1448717__(/*! ../zego.log.event */ "./sdk/src/zego.log.event.ts");
var RoomHandler = /** @class */ (function () {
    function RoomHandler(logger, stateCenter, dataReport, service, 
    // TODO: 与上层LiveRoomModules类相互依赖，需要避免下层依赖上层的属性方法
    room, liveRoomHandler) {
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.dataReport = dataReport;
        this.service = service;
        this.room = room;
        this.liveRoomHandler = liveRoomHandler;
        this.tryLoginTimer = null;
        this.tryLoginCount = 0;
        this.tryLoginInterval = 10000;
        this.tokenTimer = null;
        this.beforeExpire = 30; // 单位是s
        /*
         *    "zb.rh.hlf": "ZegoClient.base.ROOM.handleLoginFail",
         */
        // 登录结果回调函数
        this.loginCallback = {};
    }
    RoomHandler.prototype.resetTokenTimer = function (interval) {
        var _this = this;
        interval = interval - 30 * 1000; // 三十秒前就提示将要过期时间
        interval = interval < 0 ? 0 : interval;
        interval = interval > 2147483648 ? 2147483648 : interval; // 2147483648是超时时间最大值,超过该值立刻执行回调
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_RESETTOKEN_TIMER + '  call: ' + interval);
        if (this.tokenTimer) {
            clearTimeout(this.tokenTimer);
        }
        this.tokenTimer = setTimeout(function () {
            _this.stateCenter.actionListener('tokenWillExpire', _this.room.roomID);
            _this.stateCenter.actionListener('roomTokenWillExpire', _this.room.roomID);
        }, interval);
    };
    RoomHandler.prototype.stopTokenTimer = function () {
        this.tokenTimer && clearTimeout(this.tokenTimer);
        this.tokenTimer = null;
    };
    RoomHandler.prototype.setRunState = function (newRunState) {
        if (this.room.runState !== newRunState) {
            this.room.lastRunState = this.room.runState;
            this.room.runState = newRunState;
        }
    };
    RoomHandler.prototype.resetTryLogin = function () {
        this.tryLoginTimer && clearTimeout(this.tryLoginTimer);
        this.tryLoginTimer = null;
    };
    RoomHandler.prototype.resetRoom = function (isAll) {
        var _this = this;
        var _a;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_RESET_ROOM + ' call');
        if (this.stateCenter.roomModulesList.length > 1 && !isAll) {
            this.room.isMulti = true;
        }
        // 清除尝试登录计时器对象
        this.resetTryLogin();
        // 防止多次重置时，发送多次消息
        if (this.room.sessionID !== '0' &&
            this.room.runState !== zego_entity_1.ENUM_RUN_STATE.logout &&
            !this.room.isDisConnect()) {
            var callBack = function (msg) {
                _this.handleLogoutRsp(msg);
            };
            var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
            serviceHandler.logout(this.room, callBack, callBack);
        }
        // 清除客户端状态
        this.setRunState(zego_entity_1.ENUM_RUN_STATE.logout);
        this.room.sessionID = '0';
        this.room.roomSessionID = '0';
        if (!this.room.isMulti) {
            this.stateCenter.userid = '';
            this.logger.setSessionInfo(this.stateCenter.appid, this.room.roomID, this.room.sessionID, this.stateCenter.idName, this.stateCenter.nickName, this.stateCenter.sdKVersion);
            this.stateCenter.useNetAgent ? (_a = this.liveRoomHandler) === null || _a === void 0 ? void 0 : _a.reset() : this.service.closeSocket();
        }
        this.resetRoomCallBack();
        this.stateCenter.roomModulesList = this.stateCenter.roomModulesList.filter(function (_room) { return _room !== _this.room; });
        var _room = this.stateCenter.roomModulesList[0];
        if (_room) {
            _room.isMulti = false;
            if (_room.runState !== zego_entity_1.ENUM_RUN_STATE.login && _room.roomTryHandler) {
                _room.roomTryHandler.startMaxTime();
                _room.roomTryHandler.active();
            }
        }
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_RESET_ROOM + ' call success');
    };
    //空接口，被覆盖; 退出,被踢,网络断开都会回调
    RoomHandler.prototype.resetRoomCallBack = function () { };
    //空实现，被覆盖
    RoomHandler.prototype.loginSuccessCallBack = function (lastRunState, msg) { };
    RoomHandler.prototype.handlePushKickout = function (msg, isAll, isSwitch) {
        var _this = this;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_KICK_OUT + '  call ' + JSON.stringify(msg));
        if (!isSwitch && this.room.sessionID !== msg.header.session_id && this.room.sessionID !== msg.body.session_id) {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_KICK_OUT + ' session id wrong, ignore');
            return;
        }
        // logger start
        var reportSeq = zego_entity_1.getReportSeq();
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskKickout.event);
        this.dataReport.addMsgInfo(reportSeq, {
            user_id: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskKickout.user_id(this.stateCenter.idName),
        });
        var _kickoutErr = client_util_1.ClientUtil.getKickoutError(msg.body.reason || msg.body.kickout_reason, this.stateCenter.useNetAgent);
        this.dataReport.addMsgInfo(reportSeq, {
            error: _kickoutErr.code,
            message: _kickoutErr.message,
        });
        this.dataReport.uploadReport(reportSeq);
        // logger end
        var roomTryHandler = this.room.roomTryHandler;
        if (roomTryHandler) {
            roomTryHandler.onactive = function (success, err) {
                _this.disconnectedHandle(err);
                _this.stateCenter.actionListener('_kickout', err);
            };
            if (msg.body.need_relogin && msg.body.need_relogin == 1) {
                //重新登录
                this.room.sessionID = '0';
                roomTryHandler.startMaxTime();
                roomTryHandler.active();
            }
            else {
                // 被kickout时将登录状态改为登出
                this.setRunState(zego_entity_1.ENUM_RUN_STATE.logout);
                this.resetRoom(isAll);
                var extendedData = {};
                if (msg && msg.body.custom_reason) {
                    extendedData['custom_kickout_message'] = msg.body.custom_reason;
                    //@ts-ignore
                }
                else if (_kickoutErr.name && zego_externalError_1.errorCodeList[_kickoutErr.name]) {
                    //@ts-ignore
                    extendedData['custom_kickout_message'] =
                        //@ts-ignore
                        zego_externalError_1.errorCodeList[_kickoutErr.name].msg + '; kickout reason: ' + msg.body.reason || msg.body.kickout_reason;
                }
                // @ts-ignore
                if (_kickoutErr.name && zego_externalError_1.errorCodeList[_kickoutErr.name]) {
                    //@ts-ignore
                    this.disconnectedHandle(zego_externalError_1.errorCodeList[_kickoutErr.name], JSON.stringify(extendedData));
                }
                else {
                    this.disconnectedHandle(zego_externalError_1.errorCodeList.ROOM_INNER_ERROR, JSON.stringify(extendedData));
                }
                this.stateCenter.actionListener('_kickout', {
                    code: zego_externalError_1.errorCodeList.MANUAL_KICKOUT.code,
                    msg: zego_externalError_1.errorCodeList.MANUAL_KICKOUT.msg + msg.body.reason || msg.body.kickout_reason,
                });
            }
        }
        else {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_KICK_OUT + ' try handler no found');
        }
    };
    RoomHandler.prototype.handleHbLogout = function (err) {
        var _this = this;
        //异常发生
        var roomTryHandler = this.room.roomTryHandler;
        if (roomTryHandler) {
            roomTryHandler.onactive = function (success, error) {
                _this.disconnectedHandle(error);
            };
            //kLiveRoomRequiredReloginError = 1000002001;  kLiveRoomSessionIdError = 1000000152 需要重试
            if ([zego_externalError_1.errorCodeList.HEARTBEAT_TIMEOUT, zego_externalError_1.errorCodeList.SOCKET_CLOSE, zego_externalError_1.errorCodeList.TIMEOUT].includes(err) ||
                [105, 152, 2001].includes(err.code) ||
                err.msg.endsWith('1000002001') ||
                err.msg.endsWith('1000000152') ||
                err.msg.endsWith('1000000105')) {
                roomTryHandler.startMaxTime();
                roomTryHandler.active();
            }
            else {
                //终止重试
                roomTryHandler.stopMaxTime();
                roomTryHandler.invalid();
                //清空房间信息并抛出
                this.resetRoom();
                this.disconnectedHandle(err);
            }
        }
    };
    RoomHandler.prototype.onDisconnect = function (err) {
        var _this = this;
        this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_DISCONNECT + ' ' + err.msg);
        //logger start
        if (typeof err.code == 'string' && err.code === 'Error.Network') {
            this.dataReport.addMsgInfo(this.stateCenter.reportSeqList.relogin, {
                error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReLoginRoom.error.ROOM_DISCONNECT.code,
                message: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReLoginRoom.error.ROOM_DISCONNECT.msg,
            });
        }
        else if (typeof err.code == 'number') {
            var serverErr = void 0;
            if ((err.code < 2000000000 && err.code > 1000000000) || err.code < 1000000) {
                serverErr = client_util_1.ClientUtil.decodeServerError(err.code, err.msg);
            }
            else {
                serverErr = { code: err.code, message: err.msg };
            }
            serverErr &&
                this.dataReport.addMsgInfo(this.stateCenter.reportSeqList.relogin, {
                    error: serverErr.code,
                    message: serverErr.message,
                });
        }
        this.dataReport.uploadReport(this.stateCenter.reportSeqList.relogin);
        this.stateCenter.reportSeqList.relogin = 0;
        client_util_1.ClientUtil.unregisterCallback(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReLoginRoom.event, this.stateCenter.reportList);
        //logger end;
        //异常发生
        var roomTryHandler = this.room.roomTryHandler;
        if (roomTryHandler) {
            roomTryHandler.onactive = function (success, error) {
                if (error && error.code !== 0) {
                    _this.roomStateHandle('DISCONNECTED', error);
                }
                else {
                    _this.roomStateHandle('CONNECTED', error);
                }
            };
            roomTryHandler.startMaxTime();
            roomTryHandler.active();
        }
        else {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_DISCONNECT + ' try handler no found');
        }
    };
    RoomHandler.prototype.onConnecting = function (err) {
        this.roomStateHandle('CONNECTING', err);
    };
    RoomHandler.prototype.disconnectedHandle = function (error, extendedData) {
        if (error && error.code !== 0) {
            // 异常断开, 清除token定时器
            this.stopTokenTimer();
            this.roomStateHandle('DISCONNECTED', error, extendedData);
        }
        else {
            this.roomStateHandle('CONNECTED', error, extendedData);
        }
    };
    RoomHandler.prototype.roomStateHandle = function (state, error, extendedData) {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_STATUS_CALLBACK + ' ' + state + ' ' + JSON.stringify(error));
        this.room.lastRoomState = this.room.roomState;
        this.room.roomState = state;
        if (this.room.roomState !== this.room.lastRoomState) {
            this.stateCenter.actionListener('_roomStateUpdate', this.room.roomID, state, error ? error.code : 0, extendedData);
            this.stateCenter.actionListener('roomStateUpdate', this.room.roomID, state, error ? error.code : 0, extendedData);
        }
    };
    //登录房间
    RoomHandler.prototype.login = function (server, roomid, token, user, config, success, error) {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + ' call:', roomid, token);
        !this.room.isMulti &&
            this.logger.setSessionInfo(this.stateCenter.appid, roomid, '', user.userID, '', this.stateCenter.sdKVersion);
        if (config) {
            config.userUpdate &&
                typeof config.userUpdate == 'boolean' &&
                (this.stateCenter.userStateUpdate = config.userUpdate);
            config.maxMemberCount &&
                typeof config.maxMemberCount == 'number' &&
                // (this.stateCenter.maxMemberCount = config.maxMemberCount);
                // 改为房间级别
                (this.room.maxMemberCount = config.maxMemberCount);
        }
        if (!this.stateCenter.configOK) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + ' init sdk wrong');
            error(zego_externalError_1.errorCodeList.INIT);
            return;
        }
        this.room.runState !== zego_entity_1.ENUM_RUN_STATE.trylogin && this.setRunState(zego_entity_1.ENUM_RUN_STATE.trylogin);
        this.room.roomID = roomid;
        this.room.token = token;
        this.room.thirdToken = token;
        this.stateCenter.idName = user.userID;
        this.stateCenter.nickName = user.userName || user.userID;
        // 注册成功回调
        this.loginCallback.success = success;
        this.loginCallback.fail = error;
        if (this.stateCenter.reportSeqList.login === 0) {
            var reportSeq = zego_entity_1.getReportSeq();
            this.stateCenter.reportSeqList.relogin = reportSeq;
            this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReLoginRoom.event);
            this.dataReport.addMsgInfo(reportSeq, {
                server: server,
            });
            client_util_1.ClientUtil.logReportCallback(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReLoginRoom.event, this.dataReport, reportSeq, this.stateCenter.reportList);
        }
        this.resetTryLogin();
        this.onConnecting({ code: 0, msg: '' });
        this.tryLogin(server);
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + ' call success');
    };
    /*
     *    "zb.rh.tl": "ZegoClient.base.ROOM.tryLogin",
     */
    RoomHandler.prototype.tryLogin = function (server) {
        var _this = this;
        var _a;
        if (this.room.runState !== zego_entity_1.ENUM_RUN_STATE.trylogin) {
            this.logger.error('zb.rh.tl state error');
            return;
        }
        var logAction = this.stateCenter.reportSeqList.login !== 0
            ? zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.event
            : zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReLoginRoom.event;
        //统一接入
        if (this.stateCenter.useNetAgent) {
            if (this.room.isMulti && this.room.isDisConnect()) {
                this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + ' liveroom is not connected');
                return;
            }
            var callBack = function (msg, cmdSeq) {
                _this.handleLoginRsp(msg, cmdSeq);
            };
            if ((_a = this.liveRoomHandler) === null || _a === void 0 ? void 0 : _a.isUaConnect()) {
                this.liveRoomHandler.login(this.room, callBack, callBack);
            }
            else {
                // TODO
                this.tryLoginTimer = setTimeout(function () {
                    //no response,login fail
                    _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + ' over time no response, login timeout');
                    _this.loginCallback.fail && _this.loginCallback.fail(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.LOGIN_TIMEOUT);
                }, this.tryLoginInterval);
                this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + ' ua is not connected');
            }
            return;
        }
        // 如果websocket还未初始化或者还不是处于连接状态
        if (this.service.isDisConnect()) {
            try {
                // 若已经初始化，但是还不是连接状态，先清除置为null
                this.service.closeSocket();
                // 建立websocket连接
                this.logger.debug(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + ' new websocket');
                if (client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)) {
                    this.tryLoginCount > 1 &&
                        client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)(zego_entity_1.REPORT_ACTION.eventEnd, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.create_socket.event);
                    client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)(zego_entity_1.REPORT_ACTION.eventStart, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.create_socket.event);
                    client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)(zego_entity_1.REPORT_ACTION.addEventMsg, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.create_socket.event, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.create_socket.server('server'), server);
                }
                this.service.createSocket(server);
                this.service.openHandler(function () {
                    _this.openHandler();
                });
                this.service.closeHandler(function (err) {
                    _this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + ' close ' + JSON.stringify(err.code ? err.code : err));
                    _this.service.closeSocket();
                    _this.closeHandler(err);
                });
                this.service.errorHandler(function (err) {
                    _this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + ' error ' + JSON.stringify(err.code ? err.code : err));
                    _this.service.closeSocket();
                    _this.closeHandler(err);
                });
            }
            catch (e) {
                this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + '  websocket err:' + JSON.stringify(e));
            }
        }
        else {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + ' use current websocket and sent login');
            client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList) &&
                client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)(zego_entity_1.REPORT_ACTION.eventStart, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.liveroom_login.event);
            var callBack = function (msg, cmdSeq) {
                _this.handleLoginRsp(msg, cmdSeq);
            };
            this.service.login(this.room, callBack, callBack);
        }
        //set timeout
        this.tryLoginTimer = setTimeout(function () {
            //no response,login fail
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + ' over time no response, login timeout');
            _this.loginCallback.fail && _this.loginCallback.fail(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.LOGIN_TIMEOUT);
        }, this.tryLoginInterval);
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + ' call success');
    };
    /*
     *    "zb.rh.oh": "ZegoClient.base.ROOM.openHandler",
     */
    RoomHandler.prototype.openHandler = function () {
        var _this = this;
        // websocket连接已经打开
        // 注册onmessage函数，处理服务的发过来的消息，该函数只调用一次
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_OPEN_HANDLER + ' websocket.onpen call');
        var logAction = this.stateCenter.reportSeqList.login !== 0
            ? zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.event
            : zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReLoginRoom.event;
        client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList) &&
            client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)(zego_entity_1.REPORT_ACTION.eventEndWithMsgInfo, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.create_socket.event, { try_cnt: this.tryLoginCount });
        this.service.onPush();
        client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList) &&
            client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)(zego_entity_1.REPORT_ACTION.eventStart, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.liveroom_login.event);
        var callBack = function (msg, cmdSeq) {
            _this.handleLoginRsp(msg, cmdSeq);
        };
        this.service.login(this.room, callBack, callBack);
    };
    /*
     *    "zb.rh.hlr": "ZegoClient.base.ROOM.handleLoginRsp",
     */
    RoomHandler.prototype.handleLoginRsp = function (msg, cmdSeq) {
        var logAction = this.stateCenter.reportSeqList.login !== 0
            ? zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.event
            : zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReLoginRoom.event;
        client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList) &&
            client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)(zego_entity_1.REPORT_ACTION.eventEndWithMsgInfo, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.liveroom_login.event);
        if (this.room.runState !== zego_entity_1.ENUM_RUN_STATE.trylogin) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_HANDLE_LOGINRSP + ' state error');
            return;
        }
        else if (!msg.header || !msg.body) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_HANDLE_LOGINRSP + ' ' + JSON.stringify(msg));
            this.handleLoginFail(msg);
        }
        else if (msg.header.seq !== cmdSeq && this.room.isMulti == false) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_HANDLE_LOGINRSP + ' in wrong seq, local=', cmdSeq + '', ',recv=', msg.header.seq);
            return;
        }
        else if (msg.body.err_code !== 0) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_HANDLE_LOGINRSP + ' server error=', msg.body.err_code);
            this.handleLoginFail(msg);
        }
        else {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_HANDLE_LOGINRSP + ' call success.');
            this.handleLoginSuccess(msg);
        }
    };
    // 触发登录失败回调
    RoomHandler.prototype.handleLoginFail = function (msg) {
        this.resetTryLogin();
        // const logAction =
        //     this.stateCenter.reportSeqList.login !== 0
        //         ? ZegoRTMLogEvent.kZegoTaskLoginRoom.event
        //         : ZegoRTMLogEvent.kZegoTaskReLoginRoom.event;
        // ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList) &&
        //     ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)(
        //         REPORT_ACTION.addEventMsg,
        //         ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.liveroom_login.event,
        //         ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.liveroom_login.respond_info('respond_info'),
        //         msg,
        //     );
        var err = zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.INNER_ERROR;
        if (!msg.header || !msg.body) {
            msg.code && msg.msg && (err = msg);
        }
        else {
            err = client_util_1.ClientUtil.getServerError(msg.body.err_code);
        }
        this.loginCallback.fail && this.loginCallback.fail(err, true);
    };
    // 触发成功回调
    RoomHandler.prototype.handleLoginSuccess = function (msg) {
        var _a;
        var loginInfo = {};
        //enter login
        var lastRunState = this.room.lastRunState;
        this.setRunState(zego_entity_1.ENUM_RUN_STATE.login);
        this.stateCenter.userid = msg.body.user_id;
        this.room.sessionID = msg.body.session_id;
        this.room.roomSessionID = msg.body.room_session_id;
        this.room.lvKey = msg.body.lv_key;
        if (msg.body.ret_timestamp && this.room.token.substr(0, 2) === '03') {
            var currentTime = new Date().getTime();
            var local_time_deviation = currentTime - msg.body.ret_timestamp;
            this.stateCenter.local_time_deviation = local_time_deviation < 5000 ? 0 : local_time_deviation;
            var remainTime = ((_a = msg === null || msg === void 0 ? void 0 : msg.body) === null || _a === void 0 ? void 0 : _a.token_remain_time) ? msg.body.token_remain_time * 1000
                : client_util_1.ClientUtil.decodeTokenExpire(this.room.token.substr(2)) * 1000 - currentTime;
            this.resetTokenTimer(remainTime - this.stateCenter.local_time_deviation);
        }
        //set log
        !this.room.isMulti &&
            this.logger.setSessionInfo(this.stateCenter.appid, this.room.roomID, this.room.sessionID, this.stateCenter.idName, this.stateCenter.nickName, this.stateCenter.sdKVersion);
        if (!this.stateCenter.useNetAgent) {
            if (msg.body.config_info) {
                var logLevel = this.stateCenter.settingConfig.getSetting('remote_log_level', true) || msg.body.config_info.log_level;
                this.logger.setRemoteLogLevel(logLevel);
                loginInfo['log_level'] = logLevel;
                if (msg.body.config_info.log_url != '' && !this.logger.url) {
                    this.logger.setLogServer(msg.body.config_info.log_url);
                    loginInfo['log_url'] = msg.body.config_info.log_url;
                }
            }
            //get if testEnvironment
            if (msg.body.cluster_env && msg.body.cluster_env === 1) {
                this.stateCenter.testEnvironment = true;
                loginInfo['test_environment'] = 'true';
                !this.stateCenter.debugCustom && (this.stateCenter.debug = true);
            }
        }
        var logAction = this.stateCenter.reportSeqList.login !== 0
            ? zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.event
            : zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReLoginRoom.event;
        client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList) &&
            client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)(zego_entity_1.REPORT_ACTION.addEventMsg, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.liveroom_login.event, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.liveroom_login.respond_info('respond_info'), loginInfo);
        //stop trylogin
        this.resetTryLogin();
        this.loginSuccessCallBack(lastRunState, msg);
        this.loginCallback.success && this.loginCallback.success(true);
        this.roomStateHandle('CONNECTED', { code: 0, msg: '' });
    };
    RoomHandler.prototype.closeHandler = function (e) {
        this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_CLOSEHANDLER + ' room websocket close ' + JSON.stringify(e.code ? e.code : e));
        if (this.room.runState !== zego_entity_1.ENUM_RUN_STATE.logout) {
            if (this.room.runState === zego_entity_1.ENUM_RUN_STATE.trylogin) {
                //trylogin --> trylogin
                this.resetTryLogin();
                this.loginCallback.fail &&
                    this.loginCallback.fail(e.code == 1006 ? zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.LOGIN_TIMEOUT : e);
            }
            else if (this.room.runState === zego_entity_1.ENUM_RUN_STATE.login) {
                //login --> trylogin
                this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_CLOSEHANDLER + ' is called because of network broken');
                //this.setRunState (ENUM_RUN_STATE.trylogin);
                this.resetTryLogin();
                this.onDisconnect(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.NETWORK_BROKEN);
            }
        }
        else {
            //* --> logout
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_CLOSEHANDLER + ' onclose logout flow call websocket.close');
        }
    };
    RoomHandler.prototype.logout = function (isAll) {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGOUT + ' call');
        if (this.room.runState === zego_entity_1.ENUM_RUN_STATE.logout) {
            this.logger.warn('zb.rh.lo at logout');
            return;
        }
        this.resetRoom(isAll);
        this.roomStateHandle('DISCONNECTED', { code: 0, msg: '' });
        // 主动退出,清除token定时器
        this.stopTokenTimer();
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGOUT + ' call success');
    };
    RoomHandler.prototype.handleLogoutRsp = function (msg) {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGOUT + ' result=', msg.body && msg.body.err_code ? msg.body.err_code : '-1');
    };
    return RoomHandler;
}());
exports.RoomHandler = RoomHandler;


/***/ }),

/***/ "./sdk/src/modules/switchCmd.ts":
/*!**************************************!*\
  !*** ./sdk/src/modules/switchCmd.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveroomProMap = void 0;
exports.LiveroomProMap = {
    '/lr/login_room_rsp': 'LoginRoomRsp',
    '/lr/logout_room_rsp': 'LogoutRoomRsp',
    '/sw/push_kickout': 'PushKickout',
    '/sw/push': 'PushReq',
    '/sw/merge_push': 'CmdMergePushReq',
    '/lr/room/hb_rsp': 'HbRsp',
    '/lr/userlist/userlist_rsp': 'UserlistRsp',
    '/lr/stream/add_rsp': 'StreamAddRsp',
    '/lr/stream/delete_rsp': 'StreamDeleteRsp',
    '/lr/stream/update_rsp': 'StreamUpdateRsp',
    '/lr/stream/list_rsp': 'StreamListRsp',
    '/lr/push/stream_add': 'PushStream',
    '/lr/push/stream_delete': 'PushStream',
    '/lr/push/stream_update': 'PushStream',
    '/lr/signal/liverequest_rsp': 'SignalLiveRsp',
    '/lr/signal/liverresult_rsp': 'SignalLiveResulRsp',
    '/lr/signal/liveinvite_rsp': 'SignalLiveInviteRsp',
    '/lr/signal/livestop_rsp': 'SignalLiveStopRsp',
    '/lr/signal/livescustom_rsp': 'SignalLiveCustomRsp',
    '/lr/im/chat_rsp': 'ImChatRsp',
    '/lr/room/enter_rsp': 'EnterRsp',
    '/lr/room/quit_rsp': 'QuitRsp',
    '/lr/trans/trans_rsp': 'TransRsp',
    '/lr/trans/transfetch_rsp': 'TransFetchRsp',
    '/lr/bigim/chat_rsp': 'BigimChatRsp',
    '/lr/relay_rsp': 'RelayRsp',
    '/lr/token/renew_token_rsp': 'RenewTokenRsp',
    '/lr/push/user_updated': 'PushUserInfoUpdated',
    '/lr/push/user_token_expire': 'PushUserTokenExpire',
    '/lr/push/im_chat': 'PushImChat',
    '/lr/push/bigim_chat': 'PushBigImChat',
    '/lr/push/trans': 'PushTrans',
    '/lr/push/user_kickout': 'PushUserKickout',
    '/lr/push/user_logreport': 'PushUserLogReport',
    '/lr/push/usertrans': 'PushUserTrans'
};


/***/ }),

/***/ "./sdk/src/modules/userHandler.ts":
/*!****************************************!*\
  !*** ./sdk/src/modules/userHandler.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1480682__) {

"use strict";

var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserHandler = void 0;
var zego_entity_1 = __nested_webpack_require_1480682__(/*! ../zego.entity */ "./sdk/src/zego.entity.ts");
var client_util_1 = __nested_webpack_require_1480682__(/*! ../../util/client-util */ "./sdk/util/client-util.ts");
var zego_action_1 = __nested_webpack_require_1480682__(/*! ../zego.action */ "./sdk/src/zego.action.ts");
var zego_log_event_1 = __nested_webpack_require_1480682__(/*! ../zego.log.event */ "./sdk/src/zego.log.event.ts");
var UserHandler = /** @class */ (function () {
    function UserHandler(logger, stateCenter, dataReport, service, liveRoomHandler, room) {
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.dataReport = dataReport;
        this.service = service;
        this.liveRoomHandler = liveRoomHandler;
        this.room = room;
        this.userQuerying = false;
        this.userTempList = [];
        this.userSeq = 0;
        this.minUserSeq = 0;
        this.userList = [];
        this.userSeqMergeMap = null;
        this.userListInterval = 30000;
        this.userListMergeInterval = 5000;
        this.anchor_info = {
            anchor_id: '',
            anchor_id_name: '',
            anchor_nick_name: '',
        };
    }
    // 登录返回处理, 登录带有用户信息
    UserHandler.prototype.loginRsp = function (msg, lastRunState) {
        this.anchor_info = msg.body.anchor_info || this.anchor_info;
        this.userListInterval = msg.body.userlist_interval || this.userListInterval;
        this.userListMergeInterval = msg.body.userlist_merge_timeout || this.userListMergeInterval;
        //房间成员变化
        //handle anchor info
        if (msg.body.anchor_info) {
            this.stateCenter.actionListener('getAnchorInfo', msg.body.anchor_info.anchor_id_name, msg.body.anchor_info.anchor_nick_name);
            this.stateCenter.actionListener('_getAnchorInfo', msg.body.anchor_info.anchor_id_name, msg.body.anchor_info.anchor_nick_name);
        }
        if (msg.body.online_count) {
            this.stateCenter.actionListener('roomOnlineUserCountUpdate', this.room.roomID, msg.body.online_count);
        }
        //handle userStateUpdate
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_LOGIN_RSP + '  userStateUpdate ' + this.stateCenter.userStateUpdate);
        if (this.stateCenter.userStateUpdate) {
            this.fetchUserList(lastRunState);
        }
    };
    UserHandler.prototype.patchUserList = function (msg) {
        var _this = this;
        if (msg.body.server_user_seq !== this.userSeq && this.stateCenter.userStateUpdate && !this.userSeqMergeMap) {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_HB_PATCH +
                ' call update user ' +
                this.userSeq +
                ' server ' +
                msg.body.server_user_seq);
            // TODO
            if (!this.userSeqMergeMap) {
                this.userSeqMergeMap = {};
            }
            this.userSeqMergeTimer && clearTimeout(this.userSeqMergeTimer);
            this.userSeqMergeTimer = setTimeout(function () {
                _this.handleMergeTimeout();
            }, this.userListMergeInterval);
        }
        this.minUserSeq = msg.body.server_user_seq;
        //get online count
        if (msg.body.online_count != undefined && msg.body.online_count != 0) {
            this.stateCenter.actionListener('roomOnlineUserCountUpdate', this.room.roomID, msg.body.online_count);
        }
    };
    UserHandler.prototype.resetUserHandler = function () {
        this.userQuerying = false;
        this.lastUserQueryTime = 0;
        this.userTempList = [];
        this.userSeq = 0;
        this.minUserSeq = 0;
        this.userList = undefined;
        this.userSeqMergeMap = {};
        this.userSeqMergeTimer = undefined;
        this.userQueryTimer = undefined;
        this.userListInterval = 30000;
        this.userListMergeInterval = 5000;
        this.anchor_info = {
            anchor_id: '',
            anchor_id_name: '',
            anchor_nick_name: '',
        };
    };
    // 拉取服务端user信息
    UserHandler.prototype.fetchUserList = function (lastRunState) {
        if (this.userQuerying) {
            this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.USER_FETCH_USER + ' is already querying');
            return;
        }
        this.userQuerying = true;
        this.userTempList = [];
        this.fetchUserListWithPage(0, lastRunState ? lastRunState : 0);
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_FETCH_USER + ' the first time call');
    };
    //分页拉取user list
    UserHandler.prototype.fetchUserListWithPage = function (userIndex, lastRunState) {
        var _this = this;
        var callBack = function (msg) {
            _this.handleFetchUserListRsp(msg, lastRunState);
        };
        var body = {
            user_index: userIndex,
            sort_type: 0,
        };
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.fetchUserList(body, callBack, callBack, this.room);
    };
    UserHandler.prototype.handleFetchUserListRsp = function (msg, lastRunState) {
        var _this = this;
        if (msg.body && msg.body.err_code != 0) {
            this.userQuerying = false;
            this.lastUserQueryTime = Date.now() + this.userListInterval;
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_FETCH_USER_RSP + ' fetch error ' + msg.body.err_code);
            return;
        }
        if (!msg.header || !msg.body) {
            this.userQuerying = false;
            this.lastUserQueryTime = Date.now() + this.userListInterval;
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_FETCH_USER_RSP + ' fetch error ' + msg);
            return;
        }
        if (!this.stateCenter.userStateUpdate) {
            return;
        }
        this.userTempList = __spreadArrays(this.userTempList, msg.body.user_baseinfos);
        var currentIndex = msg.body.ret_user_index;
        var serverIndex = msg.body.server_user_index;
        if (currentIndex != serverIndex && currentIndex.ne(serverIndex)) {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_FETCH_USER_RSP + ' fetch another page');
            this.fetchUserListWithPage(currentIndex + 1, lastRunState);
            return;
        }
        this.userSeq = msg.body.server_user_seq;
        var user_list = [];
        var _user_list = [];
        for (var i = 0; i < this.userTempList.length; i++) {
            var user_info = {
                userID: this.userTempList[i].id_name,
                userName: this.userTempList[i].nick_name,
                role: this.userTempList[i].role,
            };
            user_list.push(user_info);
            _user_list.push({
                idName: this.userTempList[i].id_name,
                nickName: this.userTempList[i].nick_name,
                role: this.userTempList[i].role,
            });
        }
        this.stateCenter.actionListener('_getTotalUserList', this.room.roomID, _user_list);
        if (lastRunState == zego_entity_1.ENUM_RUN_STATE.login) {
            this.userList &&
                client_util_1.ClientUtil.mergeUserList(this.logger, this.userList, user_list, function (addUserList, delUserList) {
                    addUserList.length !== 0 && _this.onUserStateUpdate(_this.room.roomID, 'ADD', addUserList);
                    delUserList.length !== 0 && _this.onUserStateUpdate(_this.room.roomID, 'DELETE', delUserList);
                });
            this.userList = user_list;
        }
        else {
            this.userList = user_list;
            user_list.length !== 0 && this.onUserStateUpdate(this.room.roomID, 'ADD', user_list);
        }
        this.userQuerying = false;
        this.lastUserQueryTime = Date.now() + this.userListInterval;
        this.userTempList = [];
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_FETCH_USER_RSP + ' call success user_list ' + user_list + ' count ' + user_list.length);
    };
    UserHandler.prototype.handlePushUserStateUpdateMsg = function (msg) {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_USER_PUSH + ' call');
        if (!this.stateCenter.userStateUpdate) {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_USER_PUSH + ' userStateUpdate is false');
            return;
        }
        if (this.userSeq === msg.body.user_list_seq) {
            this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.USER_USER_PUSH + ' user_list_seq is the same with local seq');
            return;
        }
        // merge user or fetchUserList
        console.error('handlePushUserStateUpdateMsg', this.userSeq, msg.body.user_actions.length, msg.body.user_list_seq);
        if (this.userSeq + msg.body.user_actions.length !== msg.body.user_list_seq) {
            this.mergeUserByUserSeq(msg.body.user_list_seq, msg.body.user_actions);
            return;
        }
        this.userSeq = msg.body.user_list_seq;
        var user_list = [];
        var addAction, delAction;
        if (this.stateCenter.type == 'PRIVATE') {
            addAction = 0;
            delAction = 1;
            for (var i = 0; i < msg.body.user_actions.length; i++) {
                var user_info = {
                    action: msg.body.user_actions[i].action,
                    idName: msg.body.user_actions[i].user_id,
                    nickName: msg.body.user_actions[i].user_name,
                    role: msg.body.user_actions[i].role,
                    loginTime: msg.body.user_actions[i].login_time,
                };
                user_list.push(user_info);
            }
        }
        else {
            addAction = 1;
            delAction = 2;
            for (var i = 0; i < msg.body.user_actions.length; i++) {
                var user_info = {
                    action: msg.body.user_actions[i].Action,
                    idName: msg.body.user_actions[i].IdName,
                    nickName: msg.body.user_actions[i].NickName,
                    role: msg.body.user_actions[i].Role,
                    loginTime: msg.body.user_actions[i].LoginTime,
                };
                user_list.push(user_info);
            }
            this.stateCenter.actionListener('_userStateUpdate', msg.body.room_id, user_list);
        }
        var addUserList = [];
        var delUserList = [];
        user_list.forEach(function (user) {
            if (user.action == addAction) {
                addUserList.push({ userID: user.idName, userName: user.nickName, role: user.role });
            }
            else if (user.action == delAction) {
                delUserList.push({ userID: user.idName, userName: user.nickName, role: user.role });
            }
        });
        this.userList &&
            (this.userList = this.userList
                .concat(addUserList)
                .filter(function (user) { return !delUserList.some(function (delUser) { return delUser.userID == user.userID; }); }));
        addUserList.length !== 0 &&
            this.onUserStateUpdate(msg.body.room_id || msg.body.room_pushheader.room_id, 'ADD', addUserList);
        delUserList.length !== 0 &&
            this.onUserStateUpdate(msg.body.room_id || msg.body.room_pushheader.room_id, 'DELETE', delUserList);
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_USER_PUSH + ' call success');
    };
    UserHandler.prototype.onUserStateUpdate = function (roomID, updateType, userList) {
        var _this = this;
        var reportSeq = zego_entity_1.getReportSeq();
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomGetUserUpdateInfo.event);
        var callUserList = userList.filter(function (val) { return val.userID !== _this.stateCenter.idName; });
        if (callUserList.length == 0)
            return;
        if (this.stateCenter.type !== 'PRIVATE') {
            callUserList = callUserList.map(function (item) { return ({
                userID: item.userID,
                userName: item.userName,
            }); });
        }
        this.stateCenter.actionListener('roomUserUpdate', roomID, updateType, callUserList);
        this.dataReport.addMsgInfo(reportSeq, {
            user_update_type: updateType == 'ADD'
                ? zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomGetUserUpdateInfo.user_update_type('added')
                : zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomGetUserUpdateInfo.user_update_type('deleted'),
        });
        this.dataReport.uploadReport(reportSeq);
    };
    UserHandler.prototype.mergeUserByUserSeq = function (userSeq, userList) {
        var _this = this;
        if (!this.userSeqMergeMap) {
            this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.USER_MERGE_SEQ + ' new merge userlist ' + this.userSeq + ' server ' + userSeq);
            this.userSeqMergeMap = {};
            // 添加定时器，检查 userSeq 连续性
            this.userSeqMergeTimer && clearTimeout(this.userSeqMergeTimer);
            this.userSeqMergeTimer = setTimeout(function () {
                _this.handleMergeTimeout();
            }, this.userListMergeInterval);
        }
        this.userSeqMergeMap[userSeq] = userList;
        this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.USER_MERGE_SEQ +
            '  merge userlist ' +
            this.userSeq +
            ' server ' +
            userSeq +
            ' userlist ' +
            userList.length);
    };
    UserHandler.prototype.mergeUser = function (userSeqList) {
        var _this = this;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_MERGE + ' merge userlist ' + this.userSeq + ' userSeqList ' + userSeqList.join(','));
        this.userSeq = userSeqList[userSeqList.length - 1];
        this.lastUserQueryTime = Date.now() + this.userListInterval;
        // 一段时间内同一个用户多次进出房间，以最后一次为准（因为合并了推送消息，userSeq升序）
        var userMap = {};
        userSeqList.forEach(function (seq) {
            _this.userSeqMergeMap &&
                _this.userSeqMergeMap[seq].forEach(function (item) {
                    userMap[item.IdName] = item;
                });
        });
        this.userSeqMergeMap = null;
        var userList = Object.values(userMap).map(function (item) {
            var user = {
                action: item.Action,
                idName: item.IdName,
                nickName: item.NickName,
                role: item.Role,
                loginTime: item.LoginTime ? String(item.LoginTime) : '',
            };
            return user;
        });
        // loginTime 升序
        userList.sort(function (a, b) { return a.loginTime.localeCompare(b.loginTime); });
        var addUserList = [];
        var delUserList = [];
        userList.forEach(function (user) {
            if (user.action == 1) {
                addUserList.push({ userID: user.idName, userName: user.nickName, role: user.role });
            }
            else if (user.action == 2) {
                delUserList.push({ userID: user.idName, userName: user.nickName, role: user.role });
            }
        });
        this.userList =
            this.userList &&
                this.userList
                    .concat(addUserList)
                    .filter(function (user) { return !delUserList.some(function (delUser) { return delUser.userID == user.userID; }); });
        addUserList.length !== 0 && this.onUserStateUpdate(this.room.roomID, 'ADD', addUserList);
        delUserList.length !== 0 && this.onUserStateUpdate(this.room.roomID, 'DELETE', delUserList);
        this.stateCenter.actionListener('_userStateUpdate', this.room.roomID, userList);
    };
    UserHandler.prototype.handleMergeTimeout = function () {
        var _this = this;
        var userSeqList = Object.keys(this.userSeqMergeMap)
            .map(function (key) { return +key; })
            .sort(function (a, b) { return a - b; });
        // userSeq 连续
        if (userSeqList[userSeqList.length - 1] - userSeqList[0] + 1 === userSeqList.length ||
            userSeqList[userSeqList.length - 1] >= this.minUserSeq) {
            this.mergeUser(userSeqList);
        }
        else {
            this.userSeqMergeMap = null;
            // 如果超过上次全量同步用户的等待时间则立即同步，否则等待差值后再同步
            var wait = this.lastUserQueryTime - Date.now();
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_MERGE_TIMEOUT +
                '  fetch merge userlist ' +
                this.userSeq +
                ' userSeqList ' +
                userSeqList.join(',') +
                ' wait ' +
                wait);
            if (wait > 0) {
                this.userQueryTimer && clearTimeout(this.userQueryTimer);
                this.userQueryTimer = setTimeout(function () {
                    _this.fetchUserList();
                }, wait);
            }
            else {
                this.fetchUserList();
            }
        }
    };
    UserHandler.prototype.loginPrivateRsp = function (msg) {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_FETCH_USER, ' userStateUpdate ' + this.stateCenter.userStateUpdate);
        if (this.stateCenter.userStateUpdate) {
            this.fetchUserList();
        }
    };
    return UserHandler;
}());
exports.UserHandler = UserHandler;


/***/ }),

/***/ "./sdk/src/service.private.ts":
/*!************************************!*\
  !*** ./sdk/src/service.private.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1498526__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveRoomPrivateService = void 0;
var socket_util_1 = __nested_webpack_require_1498526__(/*! ../util/socket-util */ "./sdk/util/socket-util.ts");
var zego_entity_1 = __nested_webpack_require_1498526__(/*! ./zego.entity */ "./sdk/src/zego.entity.ts");
var service_1 = __nested_webpack_require_1498526__(/*! ./service */ "./sdk/src/service.ts");
var LiveRoomPrivateService = /** @class */ (function (_super) {
    __extends(LiveRoomPrivateService, _super);
    function LiveRoomPrivateService(stateCenter, logger, rtm) {
        var _this = _super.call(this, stateCenter, logger, rtm) || this;
        _this.stateCenter = stateCenter;
        _this.logger = logger;
        _this.service = new socket_util_1.ZegoSocketService(_this.stateCenter.ENV);
        _this.cmdSeq = 0;
        _this.responseRouters = {};
        return _this;
    }
    LiveRoomPrivateService.prototype.checkResponse = function (msg) {
        if (msg.header.app_id !== this.stateCenter.appid ||
            msg.header.user_uid !== this.stateCenter.userid ||
            this.stateCenter.priModules.hallRunState !== zego_entity_1.ENUM_RUN_STATE.login) {
            return true;
        }
        else {
            return false;
        }
    };
    // 以下方法都需要被覆盖 start
    LiveRoomPrivateService.prototype.handleHallKickout = function (msg) { };
    LiveRoomPrivateService.prototype.handlePushKickout = function (msg) { };
    LiveRoomPrivateService.prototype.handlePushCustomMsg = function (msg) { };
    LiveRoomPrivateService.prototype.handlePushRoomMsg = function (msg) { };
    LiveRoomPrivateService.prototype.handlePushUserStateUpdateMsg = function (msg) { };
    LiveRoomPrivateService.prototype.handlePushMergeMsg = function (msg) { };
    LiveRoomPrivateService.prototype.handlePushTransMsg = function (msg) { };
    LiveRoomPrivateService.prototype.handleBigImMsgRsp = function (msg) { };
    LiveRoomPrivateService.prototype.handlePushSignalMsg = function (msg) { };
    // 以上方法都需要被覆盖 end
    /*
     *    "zb.sc.htr": "ZegoExpressEngine.base.SocketCenter.handleTransRsp",
     *
     */
    LiveRoomPrivateService.prototype.closeHandler = function (handler) {
        this.service.closeHandler(handler);
    };
    LiveRoomPrivateService.prototype.openHandler = function (handler) {
        this.service.openHandler(handler);
    };
    LiveRoomPrivateService.prototype.errorHandler = function (handler) {
        this.service.errorHandler(handler);
    };
    LiveRoomPrivateService.prototype.getHeader = function (cmd) {
        return {
            cmd: cmd,
            seq: ++this.cmdSeq,
            timestamp: Math.ceil(new Date().getTime() / 1000) + '',
            app_id: this.stateCenter.appid,
            user_uid: this.stateCenter.userid || '0',
            session_id: this.stateCenter.priModules.sessionID || '0',
        };
    };
    LiveRoomPrivateService.prototype.startCheck = function () {
        this.service.startCheck();
    };
    LiveRoomPrivateService.prototype.stopCheck = function () {
        this.service.stopCheck();
    };
    LiveRoomPrivateService.prototype.isDisConnect = function () {
        return !this.service || this.service.isDisConnect();
    };
    LiveRoomPrivateService.prototype.closeSocket = function () {
        this.service.closeSocket();
    };
    LiveRoomPrivateService.prototype.on = function (cmd, callBack) {
        this.responseRouters[cmd] = callBack;
    };
    return LiveRoomPrivateService;
}(service_1.LiveRoomService));
exports.LiveRoomPrivateService = LiveRoomPrivateService;


/***/ }),

/***/ "./sdk/src/service.ts":
/*!****************************!*\
  !*** ./sdk/src/service.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1502939__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveRoomService = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
var zego_entity_1 = __nested_webpack_require_1502939__(/*! ./zego.entity */ "./sdk/src/zego.entity.ts");
var socket_util_1 = __nested_webpack_require_1502939__(/*! ../util/socket-util */ "./sdk/util/socket-util.ts");
var zego_action_1 = __nested_webpack_require_1502939__(/*! ./zego.action */ "./sdk/src/zego.action.ts");
var zego_externalError_1 = __nested_webpack_require_1502939__(/*! ./zego.externalError */ "./sdk/src/zego.externalError.ts");
var LiveRoomService = /** @class */ (function () {
    function LiveRoomService(stateCenter, logger, rtm) {
        this.stateCenter = stateCenter;
        this.logger = logger;
        this.rtm = rtm;
        this.service = new socket_util_1.ZegoSocketService(this.stateCenter.ENV);
        this.cmdSeq = 0;
        this.responseRouters = {};
    }
    LiveRoomService.prototype.checkResponse = function (msg) {
        if (msg.header.appid !== this.stateCenter.appid || msg.header.user_id !== this.stateCenter.userid) {
            return true;
        }
        else {
            return false;
        }
    };
    /*
     *    "zb.sc.hscmr: "ZegoExpressEngine.base.SocketCenter.handleSendCommandMsgRsp"
     */
    LiveRoomService.prototype.handleSendCommandMsgRsp = function (msg) {
        var _this = this;
        var sendDataNode = this.service.sendCommandMap[msg.header.seq];
        if (sendDataNode != null) {
            var sendData_1 = sendDataNode._data;
            delete this.service.sendCommandMap[msg.header.seq];
            this.service.sendCommandList.remove(sendDataNode);
            if (msg.body.err_code === 0) {
                setTimeout(function () {
                    sendData_1 && sendData_1.success != null && sendData_1.success(msg, _this.cmdSeq);
                }, 0);
            }
            else {
                setTimeout(function () {
                    sendData_1 && sendData_1.error != null && sendData_1.error(msg, _this.cmdSeq);
                }, 0);
            }
        }
    };
    // 接受server push过来的数据
    LiveRoomService.prototype.onPush = function () {
        var _this = this;
        this.service.onMessage = function (msg) {
            if (msg instanceof ArrayBuffer) {
                _this.stateCenter.actionListener('_protobufResponse', msg);
                return;
            }
            if (!msg.header) {
                _this.logger.error(zego_action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + " msg type error ");
                return;
            }
            if (msg.body.err_code !== 0) {
                msg.body.err_message &&
                    _this.logger.error(zego_action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + " cmd=" + msg.header.cmd + ", err_code=" + msg.body.err_code + ", err_message=" + msg.body.err_message + " ");
            }
            else {
                _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + " cmd=" + msg.header.cmd + ", msg=" + JSON.stringify(msg) + " ");
            }
            if (['login', 'logout'].indexOf(msg.header.cmd) > -1) {
                // 执行消息回包回调
                _this.handleSendCommandMsgRsp(msg);
                return;
            }
            if (_this.checkResponse(msg)) {
                _this.logger.error(zego_action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + '  check session fail.');
                return;
            }
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + " cmd=" + msg.header.cmd + ",function=" + !!_this.responseRouters[msg.header.cmd]);
            // 执行消息回包回调
            _this.handleSendCommandMsgRsp(msg);
            // 执行被动push回调
            if (_this.responseRouters[msg.header.cmd]) {
                _this.responseRouters[msg.header.cmd](msg, _this.cmdSeq);
            }
        };
    };
    // 以下方法都需要被覆盖 start
    LiveRoomService.prototype.handlePushKickout = function (msg) {
        var _a, _b, _c, _d;
        if (((_a = msg === null || msg === void 0 ? void 0 : msg.body) === null || _a === void 0 ? void 0 : _a.protocol) === undefined || ((_b = msg === null || msg === void 0 ? void 0 : msg.body) === null || _b === void 0 ? void 0 : _b.protocol) === 1) {
            __spreadArrays(this.stateCenter.roomModulesList).forEach(function (room) { return room.roomHandler.handlePushKickout(msg, true); });
        }
        else {
            var roomID_1 = (_c = msg === null || msg === void 0 ? void 0 : msg.header) === null || _c === void 0 ? void 0 : _c.room_id;
            var room = this.stateCenter.roomModulesList.find(function (roomModules) { return roomModules.roomID == roomID_1; });
            if (!room) {
                this.logger.error(zego_action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + ' room no found ignore ' + JSON.stringify((_d = msg.header) === null || _d === void 0 ? void 0 : _d.room_id));
                return;
            }
            room.roomHandler.handlePushKickout(msg);
        }
    };
    LiveRoomService.prototype.handlePushCustomMsg = function (msg) { };
    LiveRoomService.prototype.handlePushRoomMsg = function (msg) { };
    LiveRoomService.prototype.handlePushUserStateUpdateMsg = function (msg) {
        var _a;
        var roomID = (_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id;
        var room = this.stateCenter.roomModulesList.find(function (roomModules) { return roomModules.roomID == roomID; });
        if (!room) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + ' room no found ignore ' + JSON.stringify(msg));
            return;
        }
        room.userHandler.handlePushUserStateUpdateMsg(msg);
    };
    LiveRoomService.prototype.handlePushMergeMsg = function (msg) { };
    LiveRoomService.prototype.handlePushTransMsg = function (msg) { };
    LiveRoomService.prototype.handleBigImMsgRsp = function (msg) { };
    LiveRoomService.prototype.handlePushSignalMsg = function (msg) { };
    LiveRoomService.prototype.handlePushTokenExpire = function (msg) {
        // TODO: 日志
        this.stateCenter.actionListener('_tokenExpired', msg);
    };
    // 以上方法都需要被覆盖 end
    /*
     *    "zb.sc.htr": "ZegoExpressEngine.base.SocketCenter.handleTransRsp",
     *
     */
    LiveRoomService.prototype.closeHandler = function (handler) {
        this.service.closeHandler(handler);
    };
    LiveRoomService.prototype.openHandler = function (handler) {
        this.service.openHandler(handler);
    };
    LiveRoomService.prototype.errorHandler = function (handler) {
        this.service.errorHandler(handler);
    };
    LiveRoomService.prototype.getHeader = function (cmd, sessionID, roomID, roomSessionID) {
        return {
            Protocol: zego_entity_1.ROOMVERSION === 'V1' ? 'req' : 'req_v2',
            cmd: cmd,
            appid: this.stateCenter.appid,
            seq: ++this.cmdSeq,
            user_id: this.stateCenter.userid,
            session_id: sessionID || '',
            room_id: roomID || '',
            room_session_id: roomSessionID || '',
            biz_version: this.stateCenter.bizVersion || '',
        };
    };
    LiveRoomService.prototype.startCheck = function () {
        this.service.startCheck();
    };
    LiveRoomService.prototype.stopCheck = function () {
        this.service.stopCheck();
    };
    LiveRoomService.prototype.isDisConnect = function () {
        return !this.service || this.service.isDisConnect();
    };
    LiveRoomService.prototype.createSocket = function (server) {
        var _this = this;
        this.service.createSocket(server);
        this.responseRouters = __assign(__assign({}, this.responseRouters), { push_kickout: function (msg) {
                _this.handlePushKickout(msg);
            }, push_custommsg: function (msg) {
                _this.handlePushCustomMsg(msg);
            }, push_im_chat: function (msg) {
                _this.handlePushRoomMsg(msg);
            }, push_userlist_update: function (msg) {
                _this.handlePushUserStateUpdateMsg(msg);
            }, push_merge_message: function (msg) {
                _this.handlePushMergeMsg(msg);
            }, push_trans: function (msg) {
                _this.handlePushTransMsg(msg);
            }, push_signal: function (msg) {
                _this.handlePushSignalMsg(msg);
            }, push_token_expire: function (msg) {
                _this.handlePushTokenExpire(msg);
            } });
    };
    LiveRoomService.prototype.closeSocket = function () {
        this.service.closeSocket();
    };
    LiveRoomService.prototype.sendMessage = function (cmd, body, suc, err, theHeader, customRoom) {
        var _a, _b, _c;
        if (!this.service.isDisConnect()) {
            var roomID = (customRoom === null || customRoom === void 0 ? void 0 : customRoom.roomID) ? customRoom.roomID : (_a = this.stateCenter.roomModulesList[0]) === null || _a === void 0 ? void 0 : _a.roomID;
            var roomSessionID = (customRoom === null || customRoom === void 0 ? void 0 : customRoom.roomSessionID) ? customRoom.roomSessionID
                : (_b = this.stateCenter.roomModulesList[0]) === null || _b === void 0 ? void 0 : _b.roomSessionID;
            var sessionID = (customRoom === null || customRoom === void 0 ? void 0 : customRoom.sessionID) ? customRoom.sessionID
                : (_c = this.stateCenter.roomModulesList[0]) === null || _c === void 0 ? void 0 : _c.sessionID;
            var header = theHeader || this.getHeader(cmd, sessionID, roomID, roomSessionID);
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.SERVICE_SEND +
                ' sendMsg:' +
                JSON.stringify({
                    header: header,
                    body: body,
                }));
            return this.service.sendMessage(header, body, suc, err);
        }
        else {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.SERVICE_SEND + ' socket is disconnect');
            err(zego_externalError_1.errorCodeList.SOCKET_CLOSE);
            return 0;
        }
    };
    LiveRoomService.prototype.on = function (cmd, callBack) {
        this.responseRouters[cmd] = callBack;
    };
    LiveRoomService.prototype.login = function (room, suc, err) {
        var header = this.getHeader(room.isMulti ? 'enter' : 'login', room.sessionID, room.roomID, room.roomSessionID);
        var body = {
            id_name: this.stateCenter.idName,
            nick_name: this.stateCenter.nickName,
            role: this.stateCenter.role,
            token: room.token,
            version: this.stateCenter.sdKVersion,
            room_name: room.roomID,
            user_state_flag: this.stateCenter.userStateUpdate ? 1 : 0,
            room_create_flag: this.stateCenter.roomCreateFlag,
            client_type: this.stateCenter.ENV === 0 ? zego_entity_1.E_CLIENT_TYPE.ClientType_Webrtc : zego_entity_1.E_CLIENT_TYPE.ClientType_SmallProgram,
            third_token: room.thirdToken,
            user_count_limit: room.maxMemberCount,
            relate_service: this.stateCenter.relateService.join() || '',
            login_logic: this.stateCenter.isMultiRoom ? 3 : 1,
            proto_format: this.stateCenter.protoFormat,
        };
        return this.sendMessage('', body, suc, err, header);
    };
    LiveRoomService.prototype.logout = function (room, suc, err) {
        var cmd = room.isMulti ? 'quit' : 'logout';
        var body = {
            reserve: 0,
        };
        if (cmd == 'logout') {
            body.login_logic = this.stateCenter.isMultiRoom ? 3 : 1;
        }
        return this.sendMessage(cmd, body, suc, err, undefined, {
            sessionID: room.sessionID,
            roomID: room.roomID,
            roomSessionID: room.roomSessionID,
        });
    };
    LiveRoomService.prototype.heartBeat = function (suc, err, room) {
        var body = {
            reserve: 0,
        };
        return this.sendMessage('hb', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.fetchUserList = function (body, suc, err, room) {
        return this.sendMessage('user_list', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.fetchUserListV2 = function (body, suc, err, room) {
        return this.sendMessage('user_list_v2', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.fetchReliableMessage = function (body, suc, err, room) {
        return this.sendMessage('trans_fetch', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.sendReliableMessage = function (body, suc, err, room) {
        return this.sendMessage('trans', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.sendRoomMsg = function (body, suc, err, room) {
        return this.sendMessage('im_chat', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.sendCustomCommand = function (body, suc, err, room) {
        return this.sendMessage('custommsg', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.sendBigRoomMessage = function (body, suc, err, room) {
        return this.sendMessage('bigim_chat', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.sendRelayMessage = function (body, suc, err, room) {
        return this.sendMessage('relay', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.sendSignalCmd = function (body, suc, err, room) {
        return this.sendMessage('signal', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.sendPB = function (msg) {
        if (this.service.isDisConnect() || this.stateCenter.networkState == zego_entity_1.ENUM_NETWORK_STATE.offline) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_PB + ' socket is disconnected');
            return false;
        }
        return this.service.sendPB(msg);
    };
    return LiveRoomService;
}());
exports.LiveRoomService = LiveRoomService;


/***/ }),

/***/ "./sdk/src/setting.config.ts":
/*!***********************************!*\
  !*** ./sdk/src/setting.config.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ZegoSettingConfig = void 0;
var ZegoSettingConfig = /** @class */ (function () {
    function ZegoSettingConfig() {
        this.defaultSetting = {
            remote_log_level: 'info',
        };
        this.requestList = {};
        this.setting = JSON.parse(JSON.stringify(this.defaultSetting));
    }
    ZegoSettingConfig.getInstance = function () {
        if (!ZegoSettingConfig.instance) {
            ZegoSettingConfig.instance = new ZegoSettingConfig();
        }
        return ZegoSettingConfig.instance;
    };
    ZegoSettingConfig.prototype.setSetting = function (settingFile, changeItems) {
        var isDynamic = Array.isArray(changeItems) && changeItems.length > 0;
        for (var settingGroup in settingFile) {
            if (typeof settingFile[settingGroup]['ctrlmode'] === 'number' && [1, 2].includes(settingFile[settingGroup]['ctrlmode'])) {
                this.setting[settingGroup] = settingFile[settingGroup];
                this.setting[settingGroup + '_ctrlmode'] = settingFile[settingGroup]['ctrlmode'];
            }
            else {
                for (var settingItem in settingFile[settingGroup]) {
                    // 配置项不以 _ctrlmode 结尾，控制项固定以 _ctrlmode 结尾，0 关闭配置，1 使用默认配置逻辑（客户传值优先），2 使用云控配置
                    if (!settingItem.endsWith('_ctrlmode')) {
                        if (isDynamic && changeItems.indexOf(settingItem) == -1) {
                            continue;
                        }
                        var _mode = settingFile[settingGroup][settingItem + '_ctrlmode'];
                        if (_mode === 1 || _mode === 2) {
                            this.setting[settingItem] = settingFile[settingGroup][settingItem];
                        }
                        else {
                            this.defaultSetting[settingItem] &&
                                (this.setting[settingItem] = this.defaultSetting[settingItem]);
                        }
                        typeof _mode === 'number' &&
                            (this.setting[settingItem + '_ctrlmode'] =
                                settingFile[settingGroup][settingItem + '_ctrlmode']);
                    }
                }
            }
        }
    };
    ZegoSettingConfig.prototype.getSetting = function (key, force) {
        if (force === void 0) { force = false; }
        if (force) {
            if (this.setting[key + '_ctrlmode'] == 2) {
                return this.setting[key];
            }
            else {
                return undefined;
            }
        }
        return this.setting[key];
    };
    return ZegoSettingConfig;
}());
exports.ZegoSettingConfig = ZegoSettingConfig;


/***/ }),

/***/ "./sdk/src/stateCenter.ts":
/*!********************************!*\
  !*** ./sdk/src/stateCenter.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1520876__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StateCenter = void 0;
var zego_entity_1 = __nested_webpack_require_1520876__(/*! ./zego.entity */ "./sdk/src/zego.entity.ts");
var zego_action_1 = __nested_webpack_require_1520876__(/*! ./zego.action */ "./sdk/src/zego.action.ts");
var zego_log_event_1 = __nested_webpack_require_1520876__(/*! ./zego.log.event */ "./sdk/src/zego.log.event.ts");
var StateCenter = /** @class */ (function () {
    function StateCenter(logger, dataReport) {
        this.logger = logger;
        this.dataReport = dataReport;
        this._debug = false;
        this.appConfigFetched = false;
        this._testEnvironment = false;
        this._env = 0;
        //区分公有私有
        this.type = 'PUBLIC';
        this.debugCustom = false;
        this.configOK = false;
        this.role = 2;
        this.relateService = [];
        this.maxMemberCount = 0;
        this.roomCreateFlag = 1;
        this.local_time_deviation = 0;
        this.callbackList = {};
        //回调相关
        this.listenerList = {
            roomUserUpdate: [],
            roomOnlineUserCountUpdate: [],
            getAnchorInfo: [],
            _getAnchorInfo: [],
            IMRecvCustomCommand: [],
            IMRecvBroadcastMessage: [],
            recvReliableMessage: [],
            roomExtraInfoUpdate: [],
            IMRecvBarrageMessage: [],
            recvJoinLiveRequest: [],
            recvInviteJoinLiveRequest: [],
            recvEndJoinLiveCommand: [],
            roomLoginResponse: [],
            _roomLogin: [],
            _appConfigRsp: [],
            HBResponse: [],
            roomStateUpdate: [],
            _roomStateUpdate: [],
            _getTotalUserList: [],
            _userStateUpdate: [],
            _recvBigRoomMessage: [],
            _recvRoomMsg: [],
            _kickout: [],
            tokenWillExpire: [],
            _tokenExpired: [],
            // private
            hallStateUpdate: [],
            _hallStateUpdate: [],
            roomTokenWillExpire: [],
            _tokenRenewed: [],
            _protobufResponse: [],
            _cloudSettingNotify: [],
            _settingCanFetch: [],
        };
        // log event
        this.reportList = {};
        this.reportSeqList = {
            login: 0,
            relogin: 0,
        };
        //房间重试相关
        this.networkState = zego_entity_1.ENUM_NETWORK_STATE.offline;
        this.roomRetryTime = 300;
        this.roomModulesList = [];
        this.isMultiRoom = false;
        this.setMultiRoom = false;
        // 协议格式
        this.protoFormat = 'json';
        this.settingFetched = false;
        this.useNetAgent = true;
        this._sdkVersion = 'unknown';
    }
    Object.defineProperty(StateCenter.prototype, "debug", {
        get: function () {
            return this._debug;
        },
        set: function (enable) {
            this._debug = enable;
            zego_entity_1.LoggerStateCenter.getInstance().debug = enable;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StateCenter.prototype, "testEnvironment", {
        get: function () {
            return this._testEnvironment;
        },
        set: function (env) {
            this._testEnvironment = env;
            zego_entity_1.LoggerStateCenter.getInstance().testEnvironment = env;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StateCenter.prototype, "ENV", {
        get: function () {
            return this._env;
        },
        set: function (env) {
            this._env = env;
            zego_entity_1.LoggerStateCenter.getInstance().ENV = env;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StateCenter.prototype, "roomid", {
        // idName、roomid 和 serverTimeOffset 兼容白板SDK
        get: function () {
            if (this.roomModulesList[0]) {
                return this.roomModulesList[0].roomID;
            }
            return '';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StateCenter.prototype, "serverTimeOffset", {
        get: function () {
            if (this.roomModulesList[0]) {
                return this.roomModulesList[0].messageHandler.serverTimeOffset;
            }
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    //requestId
    StateCenter.prototype.getRequestId = function () {
        return this.idName + '-' + zego_entity_1.getSeq();
    };
    StateCenter.prototype.actionListener = function (listener) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.listenerList[listener]) {
            var reportSeq = zego_entity_1.getReportSeq();
            this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoListener.event);
            this.dataReport.addMsgInfo(reportSeq, {
                listener: listener,
                params: args,
            });
            this.dataReport.uploadReport(reportSeq);
        }
        this.listenerList[listener] &&
            this.listenerList[listener].forEach(function (func) {
                try {
                    // setTimeout(() => {
                    func.apply(void 0, args);
                    // }, 0);
                }
                catch (error) {
                    _this.logger.error(zego_action_1.ZEGO_RTM_ACTION.STATE_ACTION + ' ', listener, ' ', JSON.stringify(error));
                }
            });
    };
    StateCenter.prototype.onListener = function (event, callBack) {
        if (!this.listenerList[event]) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ON_LISTENER + ' event ' + event + ' no found');
            return false;
        }
        if (typeof callBack !== 'function') {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ON_LISTENER + ' listener callBack must be funciton');
            return false;
        }
        this.listenerList[event].indexOf(callBack) == -1 && this.listenerList[event].push(callBack);
        return true;
    };
    Object.defineProperty(StateCenter.prototype, "sdKVersion", {
        get: function () {
            return this._sdkVersion;
        },
        set: function (version) {
            this._sdkVersion = version;
        },
        enumerable: false,
        configurable: true
    });
    return StateCenter;
}());
exports.StateCenter = StateCenter;


/***/ }),

/***/ "./sdk/src/zego.action.ts":
/*!********************************!*\
  !*** ./sdk/src/zego.action.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ZEGO_RTM_ACTION = void 0;
// import * as fs from 'fs';
// import * as path from 'path';
//****** sdk函数映射************//
var ZEGO_RTM_ACTION;
(function (ZEGO_RTM_ACTION) {
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_CONSTRUCTOR"] = "zm.0";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_BIND_WINDOW_LISTENER"] = "zm.wl";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_SET_LOG_CONFIG"] = "zm.slf";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_SET_DEBUG_VERBOSE"] = "zm.sdv";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_LOGIN_ROOM"] = "zm.lg";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_LOGOUT_ROOM"] = "zm.lo";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_FETCH_APP_CONFIG"] = "zm.fac";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_CREATENETAGENT"] = "zm.cna";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_GETSTOREAPPCONFIG"] = "zm.gsac";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_SET_CLOUD_SETTING_URLS"] = "zm.scsu";
    // ZEGOEXPRESSWEBRTM_SEND_CUSTOM = 'zm.scc', // 发送自定义消息
    // ZEGOEXPRESSWEBRTM_SEND_BCM = 'zm.sbcm', // 发送房间消息
    // ZEGOEXPRESSWEBRTM_SEND_RLM = 'zm.srlm', // 发送可靠消息
    // ZEGOEXPRESSWEBRTM_SEND_BRM = 'zm.sbrm', // 发送大房间消息
    // ZEGOEXPRESSWEBRTM_SEND_RAM = 'zm.sram', // 发送relay消息
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_ON"] = "zm.on";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_OFF"] = "zm.off";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_RENEWTOKEN"] = "zm.rntk";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_RESETTOKENTIMER"] = "zm.rstt";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_ENABLE_MULTI_ROOM"] = "zm.emr";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_SEND_PB"] = "zm.spb";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_GET_HEADER"] = "zm.gh";
    ZEGO_RTM_ACTION["ROOM_LOGIN_ROOM"] = "zm.rm.lg";
    ZEGO_RTM_ACTION["ROOM_TRY_LOGIN"] = "zm.rm.tl";
    ZEGO_RTM_ACTION["ROOM_OPEN_HANDLER"] = "zm.rm.op";
    ZEGO_RTM_ACTION["ROOM_HANDLE_LOGINRSP"] = "zm.rm.lgr";
    ZEGO_RTM_ACTION["ROOM_CLOSEHANDLER"] = "zm.rm.clh";
    ZEGO_RTM_ACTION["ROOM_LOGOUT"] = "zm.rm.lo";
    ZEGO_RTM_ACTION["ROOM_RESET_ROOM"] = "zm.rm.rr";
    ZEGO_RTM_ACTION["ROOM_DISCONNECT"] = "zm.rm.dcn";
    ZEGO_RTM_ACTION["ROOM_KICK_OUT"] = "zm.rm.kco";
    ZEGO_RTM_ACTION["ROOM_STATUS_CALLBACK"] = "zm.rm.scb";
    ZEGO_RTM_ACTION["ROOM_RESETTOKEN_TIMER"] = "zm.rm.rst";
    ZEGO_RTM_ACTION["HEARTBEAT_START"] = "zm.hb.st";
    ZEGO_RTM_ACTION["HEARTBEAT_HEARTBEAT_RSP"] = "zm.hb.rsp";
    ZEGO_RTM_ACTION["HEARTBEAT_RESET"] = "zm.hb.rst";
    ZEGO_RTM_ACTION["SERVICE_PUSH"] = "zm.sv.ps";
    ZEGO_RTM_ACTION["SERVICE_SEND"] = "zm.sv.sd";
    ZEGO_RTM_ACTION["USER_LOGIN_RSP"] = "zm.us.lgr";
    ZEGO_RTM_ACTION["USER_FETCH_USER"] = "zm.us.ftu";
    ZEGO_RTM_ACTION["USER_FETCH_USER_RSP"] = "zm.us.urp";
    ZEGO_RTM_ACTION["USER_USER_PUSH"] = "zm.us.uph";
    ZEGO_RTM_ACTION["USER_MERGE_SEQ"] = "zm.us.mg";
    ZEGO_RTM_ACTION["USER_MERGE_TIMEOUT"] = "zm.us.mto";
    ZEGO_RTM_ACTION["USER_MERGE"] = "zm.us.mg";
    ZEGO_RTM_ACTION["USER_HB_PATCH"] = "zm.us.pt";
    // MESSAGE_SEND_RELIABLE = 'zm.msg.sdr', // 发送可靠消息
    // MESSAGE_FETCH_RELIABLE = 'zm.msg.frm', // 拉取可靠消息
    // MESSAGE_RELIABLE_RSP = 'zm.msg.rlr', // 拉取可靠消息回包
    // MESSAGE_RELIABLE_PUSH = 'zm.msg.rps', // 收到可靠消息push
    // MESSAGE_SEND_ROOM_MSG = 'zm.msg.srm', // 发送房间消息
    // MESSAGE_SEND_CUSTOM_MSG = 'zm.msg.scm', // 发送自定义消息
    // MESSAGE_SEND_BIG_MSG = 'zm.msg.sbm', // 发送自定义消息
    // MESSAGE_BIG_MSG_PUSH = 'zm.msg.bps', // 收到自定义消息
    // MESSAGE_SEND_RELAY_MSG = 'zm.msg.slm', // 发送relay消息
    // LIVE_SEND_SIGNAL = 'zm.lv.ssg', // 发送signal消息
    // LIVE_RESPOND_JOIN_LIVE = 'zm.lv.rjl', // 回答邀请连麦
    // LIVE_PUSH_SIGNAL = 'zm.lv.pss', // 收到连麦push
    ZEGO_RTM_ACTION["STATE_ACTION"] = "zm.st.at";
    ZEGO_RTM_ACTION["ON_LISTENER"] = "ON_LISTENER";
    ZEGO_RTM_ACTION["LIVEROOMHANDLER_SENDMESSAGE"] = "zm.lrh.sm";
    ZEGO_RTM_ACTION["LIVEROOMHANDLER_PUSHUSERUPDATE"] = "zm.lrh.puu";
    ZEGO_RTM_ACTION["LIVEROOMHANDLER_PUSHKICKOUT"] = "zm.lrh.pk";
    ZEGO_RTM_ACTION["LIVEROOMHANDLER_GETSTREAMLIST"] = "zm.lrh.gs";
    ZEGO_RTM_ACTION["LIVEROOMHANDLER_HANDLEDISCONNECTED"] = "zm.lrh.hd";
    ZEGO_RTM_ACTION["LIVEROOMHANDLER_HANDLEBROKEN"] = "zm.lrh.hb";
    ZEGO_RTM_ACTION["LIVEROOMHANDLER_HANDLECONNECTED"] = "zm.lrh.hc";
})(ZEGO_RTM_ACTION = exports.ZEGO_RTM_ACTION || (exports.ZEGO_RTM_ACTION = {}));
// const _path = path.resolve(__dirname, 'zego.action.ts');
// fs.readFile(_path, 'utf8', (err, data) => {
//     if (err) {
//         console.error(err);
//     } else {
//         const actionArr: Array<string> = [];
//         const reg = /([A-Z])\w+ = '(.*)'.*\/\/([\u4e00-\u9fa5_a-zA-Z0-9]+)/g;
//         data.replace(reg, (target, p, key, value, _content): any => {
//             console;
//             actionArr.push(`${key} : ${value}`);
//         });
//         fs.writeFile(path.resolve(__dirname, '../../doc/action.log'), actionArr.join('\r'), 'utf8', err => {
//             console.log(err);
//         });
//     }
// });


/***/ }),

/***/ "./sdk/src/zego.config.ts":
/*!********************************!*\
  !*** ./sdk/src/zego.config.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.STORE_SECRET = exports.BIZ_TYPE = exports.PROTO_VER = exports.CRYPT_VERSION = exports.SDK_CONN_TYPE = exports.ROOM_BASIC = exports.INIT = exports.CLOUD_SETTING = void 0;
exports.CLOUD_SETTING = {
    product: 'Web_SDK',
    URL: [
        'https://cloud-setting-api.zego.im/cloud-setting/get',
        'https://cloud-setting-api.zegocloud.com/cloud-setting/get',
    ],
    POLLING_FREQ: 60 * 5,
    ONLINE: false,
};
exports.INIT = 'init';
exports.ROOM_BASIC = 'room';
var SDK_CONN_TYPE = 2;
exports.SDK_CONN_TYPE = SDK_CONN_TYPE;
var CRYPT_VERSION = 1;
exports.CRYPT_VERSION = CRYPT_VERSION;
var PROTO_VER = 0x00020000;
exports.PROTO_VER = PROTO_VER;
var BIZ_TYPE = 0;
exports.BIZ_TYPE = BIZ_TYPE;
var STORE_SECRET = '0c9e6e0f8c0a8f4e';
exports.STORE_SECRET = STORE_SECRET;


/***/ }),

/***/ "./sdk/src/zego.entity.ts":
/*!********************************!*\
  !*** ./sdk/src/zego.entity.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1534003__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.createZegoWebSocket = exports.LoggerStateCenter = exports.ZegoDataReport = exports.ZegoLogger = exports.MODULE_TIPS = exports.LinkedList = exports.ListNode = exports.getReportSeq = exports.getSeq = exports.REPORT_ACTION = exports.E_CLIENT_TYPE = exports.SERVER_ERROR_CODE = exports.ENUM_STREAM_UPDATE_CMD = exports.MINIUM_HEARTBEAT_INTERVAL = exports.NetType = exports.ENUM_NETWORK_STATE = exports.ENUM_RUN_STATE = exports.MAX_MIX_TASK_ID_LENGTH = exports.MAX_ROOM_ID_LENGTH = exports.MAX_USER_NAME_LENGTH = exports.MAX_USER_ID_LENGTH = exports.MAX_STREAM_ID_LENGTH = exports.MAX_TRY_HEARTBEAT_COUNT = exports.SEND_MSG_TIMEOUT = exports.SEND_MSG_RESET = exports.MAX_TRY_CONNECT_COUNT = exports.ENUM_CONNECT_STATE = exports.ENUM_SCREEM_RESOLUTION_TYPE = exports.ENUM_RESOLUTION_TYPE = exports.ENUM_SIGNAL_STATE = exports.TermType = exports.ERROR_CODES = exports.ENUM_REMOTE_TYPE = exports.LOG_LEVEL = exports.ENUM_LOG_LEVEL = exports.ROOMVERSION = exports.PROTO_VERSION = void 0;
exports.PROTO_VERSION = "1.12.0";
exports.ROOMVERSION = "V1";
var ENUM_LOG_LEVEL;
(function (ENUM_LOG_LEVEL) {
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["debug"] = 0] = "debug";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["info"] = 1] = "info";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["warn"] = 2] = "warn";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["error"] = 3] = "error";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["report"] = 99] = "report";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["disable"] = 100] = "disable";
})(ENUM_LOG_LEVEL = exports.ENUM_LOG_LEVEL || (exports.ENUM_LOG_LEVEL = {}));
exports.LOG_LEVEL = {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3,
    report: 99,
    disable: 100,
};
var ENUM_REMOTE_TYPE;
(function (ENUM_REMOTE_TYPE) {
    ENUM_REMOTE_TYPE[ENUM_REMOTE_TYPE["disable"] = 0] = "disable";
    ENUM_REMOTE_TYPE[ENUM_REMOTE_TYPE["websocket"] = 1] = "websocket";
    ENUM_REMOTE_TYPE[ENUM_REMOTE_TYPE["https"] = 2] = "https";
})(ENUM_REMOTE_TYPE = exports.ENUM_REMOTE_TYPE || (exports.ENUM_REMOTE_TYPE = {}));
exports.ERROR_CODES = {
    ROOM_SESSION_ID_ERR: 1000000152,
};
var TermType;
(function (TermType) {
    TermType[TermType["TT_NONE"] = 0] = "TT_NONE";
    TermType[TermType["TT_PC"] = 1] = "TT_PC";
    TermType[TermType["TT_IOS"] = 2] = "TT_IOS";
    TermType[TermType["TT_ANDROID"] = 3] = "TT_ANDROID";
    TermType[TermType["TT_MAC"] = 4] = "TT_MAC";
    TermType[TermType["TT_LINUX"] = 5] = "TT_LINUX";
    TermType[TermType["TT_WEB"] = 6] = "TT_WEB";
    TermType[TermType["TT_MINIPROGRAM"] = 7] = "TT_MINIPROGRAM";
    TermType[TermType["TT_UNKNOWN"] = 32] = "TT_UNKNOWN";
})(TermType = exports.TermType || (exports.TermType = {}));
var ENUM_SIGNAL_STATE;
(function (ENUM_SIGNAL_STATE) {
    ENUM_SIGNAL_STATE[ENUM_SIGNAL_STATE["disconnected"] = 0] = "disconnected";
    ENUM_SIGNAL_STATE[ENUM_SIGNAL_STATE["connecting"] = 1] = "connecting";
    ENUM_SIGNAL_STATE[ENUM_SIGNAL_STATE["connected"] = 2] = "connected";
})(ENUM_SIGNAL_STATE = exports.ENUM_SIGNAL_STATE || (exports.ENUM_SIGNAL_STATE = {}));
exports.ENUM_RESOLUTION_TYPE = {
    LOW: {
        width: 320,
        height: 240,
        frameRate: 15,
        bitRate: 300,
    },
    MEDIUM: {
        width: 640,
        height: 480,
        frameRate: 15,
        bitRate: 800,
    },
    HIGH: {
        width: 1280,
        height: 720,
        frameRate: 20,
        bitRate: 1500,
    },
};
exports.ENUM_SCREEM_RESOLUTION_TYPE = {
    LOW: {
        frameRate: 20,
        bitRate: 800,
    },
    MEDIUM: {
        frameRate: 15,
        bitRate: 1200,
    },
    HIGH: {
        frameRate: 5,
        bitRate: 2000,
    },
};
exports.ENUM_CONNECT_STATE = { disconnect: 0, connecting: 1, connected: 2 };
exports.MAX_TRY_CONNECT_COUNT = 1;
exports.SEND_MSG_RESET = 2;
exports.SEND_MSG_TIMEOUT = 1;
exports.MAX_TRY_HEARTBEAT_COUNT = 5;
exports.MAX_STREAM_ID_LENGTH = 256;
exports.MAX_USER_ID_LENGTH = 64;
exports.MAX_USER_NAME_LENGTH = 256;
exports.MAX_ROOM_ID_LENGTH = 128;
exports.MAX_MIX_TASK_ID_LENGTH = 256;
//运行状态
var ENUM_RUN_STATE;
(function (ENUM_RUN_STATE) {
    ENUM_RUN_STATE[ENUM_RUN_STATE["logout"] = 0] = "logout";
    ENUM_RUN_STATE[ENUM_RUN_STATE["trylogin"] = 1] = "trylogin";
    ENUM_RUN_STATE[ENUM_RUN_STATE["login"] = 2] = "login";
})(ENUM_RUN_STATE = exports.ENUM_RUN_STATE || (exports.ENUM_RUN_STATE = {}));
var ENUM_NETWORK_STATE;
(function (ENUM_NETWORK_STATE) {
    ENUM_NETWORK_STATE[ENUM_NETWORK_STATE["offline"] = 0] = "offline";
    ENUM_NETWORK_STATE[ENUM_NETWORK_STATE["online"] = 1] = "online";
})(ENUM_NETWORK_STATE = exports.ENUM_NETWORK_STATE || (exports.ENUM_NETWORK_STATE = {}));
var NetType;
(function (NetType) {
    NetType[NetType["NT_NONE"] = 0] = "NT_NONE";
    NetType[NetType["NT_LINE"] = 1] = "NT_LINE";
    NetType[NetType["NT_WIFI"] = 2] = "NT_WIFI";
    NetType[NetType["NT_2G"] = 3] = "NT_2G";
    NetType[NetType["NT_3G"] = 4] = "NT_3G";
    NetType[NetType["NT_4G"] = 5] = "NT_4G";
    NetType[NetType["NT_UNKNOWN"] = 32] = "NT_UNKNOWN";
})(NetType = exports.NetType || (exports.NetType = {}));
exports.MINIUM_HEARTBEAT_INTERVAL = 3000; //最小心跳尝试间隔
exports.ENUM_STREAM_UPDATE_CMD = {
    added: 12001,
    deleted: 12002,
    updated: 12003,
};
exports.SERVER_ERROR_CODE = 10000;
// export interface MessageInfo {
//     idName: string; //	用户ID	字符串
//     nickName: string; //	用户昵称	字符串
//     messageId: string; //	消息ID	字符串
//     category: number; //	消息分类	数值
//     type: number; //	消息类型	数值
//     content: string; //	消息内容	字符串
//     time: number; //	发送消息时间	数值
// }
var E_CLIENT_TYPE;
(function (E_CLIENT_TYPE) {
    E_CLIENT_TYPE[E_CLIENT_TYPE["ClientType_None"] = 0] = "ClientType_None";
    E_CLIENT_TYPE[E_CLIENT_TYPE["ClientType_H5"] = 1] = "ClientType_H5";
    E_CLIENT_TYPE[E_CLIENT_TYPE["ClientType_SmallProgram"] = 2] = "ClientType_SmallProgram";
    E_CLIENT_TYPE[E_CLIENT_TYPE["ClientType_Webrtc"] = 3] = "ClientType_Webrtc";
})(E_CLIENT_TYPE = exports.E_CLIENT_TYPE || (exports.E_CLIENT_TYPE = {}));
exports.REPORT_ACTION = {
    eventStart: 'eventStart',
    eventEndWithMsgInfo: 'eventEndWithMsgInfo',
    addEventMsg: 'addEventMsg',
    addEvent: 'addEvent',
    eventEnd: 'eventEnd',
    addMsgInfo: 'addMsgInfo',
};
exports.getSeq = (function () {
    var seq = 1;
    return function () {
        return seq++;
    };
})();
exports.getReportSeq = (function () {
    var seq = 1;
    return function () {
        return seq++;
    };
})();
var ListNode = /** @class */ (function () {
    function ListNode(id, data) {
        if (id === void 0) { id = null; }
        if (data === void 0) { data = null; }
        this.next = null;
        this.prev = null;
        this._id = id;
        this._data = data;
    }
    Object.defineProperty(ListNode.prototype, "id", {
        get: function () {
            if (this._id) {
                return this._id;
            }
            else {
                return null;
            }
        },
        set: function (id) {
            this._id = id;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ListNode.prototype, "data", {
        get: function () {
            return this._data;
        },
        set: function (data) {
            this._data = data;
        },
        enumerable: false,
        configurable: true
    });
    ListNode.prototype.hasNext = function () {
        return this.next && this.next.id;
    };
    ListNode.prototype.hasPrev = function () {
        return this.prev && this.prev.id;
    };
    return ListNode;
}());
exports.ListNode = ListNode;
var LinkedList = /** @class */ (function () {
    function LinkedList() {
        //initialize end buffer nodes
        this.start = new ListNode();
        this.end = new ListNode();
        //initialize counters
        this._idCounter = 0;
        this._numNodes = 0;
        //initialize node pointers
        this.start.next = this.end;
        this.start.prev = null;
        this.end.prev = this.start;
        this.end.next = null;
    }
    /**
     *   Inserts a node before another node in the linked list
     *   @param {Node} toInsertBefore
     *   @param {Node} node
     */
    LinkedList.prototype.insertBefore = function (toInsertBefore, data) {
        var newNode = new ListNode(this._idCounter, data);
        newNode.next = toInsertBefore;
        newNode.prev = toInsertBefore.prev;
        if (toInsertBefore.prev)
            toInsertBefore.prev.next = newNode;
        toInsertBefore.prev = newNode;
        ++this._idCounter;
        ++this._numNodes;
        return newNode;
    };
    /**
     *   Adds data wrapped in a Node object to the end of the linked list
     *   @param {object} data
     */
    LinkedList.prototype.addLast = function (data) {
        return this.insertBefore(this.end, data);
    };
    /**
     *   Alias for addLast
     *   @param {object} data
     */
    LinkedList.prototype.add = function (data) {
        return this.addLast(data);
    };
    /**
     *   Gets and returns the first node in the linked list or null
     *   @return {Node/null}
     */
    LinkedList.prototype.getFirst = function () {
        if (this._numNodes === 0) {
            return null;
        }
        else {
            return this.start.next;
        }
    };
    /**
     *   Gets and returns the last node in the linked list or null
     *   @return {Node/null}
     */
    LinkedList.prototype.getLast = function () {
        if (this._numNodes === 0) {
            return null;
        }
        else {
            return this.end.prev;
        }
    };
    /**
     *   Gets and returns the size of the linked list
     *   @return {number}
     */
    LinkedList.prototype.size = function () {
        return this._numNodes;
    };
    /**
     *   (Internal) Gets and returns the node at the specified index starting from the first in the linked list
     *   Use getAt instead of this function
     *   @param {number} index
     */
    LinkedList.prototype.getFromFirst = function (index) {
        var count = 0, temp = this.start.next;
        if (index >= 0) {
            while (count < index && temp !== null) {
                temp = temp.next;
                ++count;
            }
        }
        else {
            temp = null;
        }
        if (temp === null) {
            throw 'Index out of bounds.';
        }
        return temp;
    };
    /**
     *   Gets and returns the Node at the specified index in the linked list
     *   @param {number} index
     */
    LinkedList.prototype.get = function (index) {
        var temp = null;
        if (index === 0) {
            temp = this.getFirst();
        }
        else if (index === this._numNodes - 1) {
            temp = this.getLast();
        }
        else {
            temp = this.getFromFirst(index);
        }
        return temp;
    };
    /**
     *   Removes and returns node from the linked list by rearranging pointers
     *   @param {Node} node
     *   @return {Node}
     */
    LinkedList.prototype.remove = function (node) {
        if (node.prev)
            node.prev.next = node.next;
        if (node.next)
            node.next.prev = node.prev;
        --this._numNodes;
        return node;
    };
    /**
     *   Removes and returns the first node in the linked list if it exists, otherwise returns null
     *   @return {Node/null}
     */
    LinkedList.prototype.removeFirst = function () {
        var temp = null;
        if (this._numNodes > 0 && this.start.next) {
            temp = this.remove(this.start.next);
        }
        return temp;
    };
    /**
     *   Removes and returns the last node in the linked list if it exists, otherwise returns null
     *   @return {Node/null}
     */
    LinkedList.prototype.removeLast = function () {
        var temp = null;
        if (this._numNodes > 0 && this.end.prev) {
            temp = this.remove(this.end.prev);
        }
        return temp;
    };
    /**
     *   Removes all nodes from the list
     */
    LinkedList.prototype.removeAll = function () {
        this.start.next = this.end;
        this.end.prev = this.start;
        this._numNodes = 0;
        this._idCounter = 0;
    };
    /**
     *    Iterates the list calling the given fn for each node
     *    @param {function} fn
     */
    LinkedList.prototype.each = function (iterator) {
        var temp = this.start;
        while (temp.hasNext()) {
            temp = temp.next;
            iterator(temp);
        }
    };
    LinkedList.prototype.find = function (iterator) {
        var temp = this.start, found = false, result = null;
        while (temp.hasNext() && !found) {
            temp = temp.next;
            if (iterator(temp)) {
                result = temp;
                found = true;
            }
        }
        return result;
    };
    LinkedList.prototype.map = function (iterator) {
        var temp = this.start;
        var results = [];
        while (temp.hasNext()) {
            temp = temp.next;
            if (iterator(temp)) {
                results.push(temp);
            }
        }
        return results;
    };
    /**
     *    Alias for addLast
     *    @param {object} data
     */
    LinkedList.prototype.push = function (data) {
        return this.addLast(data);
    };
    /**
     *    Performs insertBefore on the first node
     *    @param {object} data
     */
    LinkedList.prototype.unshift = function (data) {
        if (this._numNodes > 0) {
            this.insertBefore(this.start.next, data);
        }
        else {
            this.insertBefore(this.end, data);
        }
    };
    /**
     *    Alias for removeLast
     */
    LinkedList.prototype.pop = function () {
        return this.removeLast();
    };
    /**
     *    Alias for removeFirst()
     */
    LinkedList.prototype.shift = function () {
        return this.removeFirst();
    };
    return LinkedList;
}());
exports.LinkedList = LinkedList;
exports.MODULE_TIPS = {
    MESSAGE: '未引入消息模块',
};
var zego_express_logger_1 = __nested_webpack_require_1534003__(/*! zego-express-logger */ "../node_modules/zego-express-logger/ZegoExpressLogger.js");
Object.defineProperty(exports, "ZegoLogger", { enumerable: true, get: function () { return zego_express_logger_1.ZegoLogger; } });
Object.defineProperty(exports, "ZegoDataReport", { enumerable: true, get: function () { return zego_express_logger_1.ZegoDataReport; } });
Object.defineProperty(exports, "LoggerStateCenter", { enumerable: true, get: function () { return zego_express_logger_1.LoggerStateCenter; } });
Object.defineProperty(exports, "createZegoWebSocket", { enumerable: true, get: function () { return zego_express_logger_1.createZegoWebSocket; } });


/***/ }),

/***/ "./sdk/src/zego.externalError.ts":
/*!***************************************!*\
  !*** ./sdk/src/zego.externalError.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.errorCodeList = void 0;
exports.errorCodeList = {
    SERVER: {
        code: 0,
        msg: 'liverooom cmd error',
    },
    SUCCESS: {
        code: 0,
        msg: 'success.',
    },
    INIT: {
        code: 2000000001,
        msg: 'init sdk wrong',
    },
    // commonErr
    NOT_LOGIN: {
        code: 1000002,
        msg: 'not login',
    },
    NETWORK_BROKEN: {
        code: 1000017,
        msg: 'network is broken',
    },
    // 通用错误码
    INPUT_PARAM: {
        code: 1100001,
        msg: 'input parm error.',
    },
    TIMEOUT: {
        code: 1100002,
        msg: 'network timeout.',
    },
    SOCKET_CLOSE: {
        code: 1100003,
        msg: 'socket close',
    },
    NET_SOCKET_TIMEOUT: {
        code: 1100004,
        msg: 'net agent timeout',
    },
    NET_HB_TIMEOUT: {
        code: 1100005,
        msg: 'net hb timeout',
    },
    // rtc 码
    INIT_SDK_WRONG: {
        code: 1101000,
        msg: 'init sdk wrong',
    },
    // roomErr
    // NONE_APP_ID: {
    //     code: 1001000,
    //     msg: 'app id can not be 0',
    // },
    // ROOM_COUNT_EXCEED: {
    //     code: 1002001,
    //     msg: 'login rooms exceeds the upper limit',
    // },
    USER_ID_NULL: {
        code: 1002005,
        msg: 'user ID is empty',
    },
    USER_ID_INVALID_CHARACTER: {
        code: 1002006,
        msg: 'user ID contains illegal characters',
    },
    USER_ID_TOO_LONG: {
        code: 1002007,
        msg: 'user ID is too long',
    },
    USER_NAME_NULL: {
        code: 1002008,
        msg: 'username is empty',
    },
    // USER_NAME_INVALID_CHARACTER: {
    //     code: 1002009,
    //     msg: 'username contains illegal characters',
    // },
    USER_NAME_TOO_LONG: {
        code: 1002010,
        msg: 'username is too long',
    },
    ROOM_ID_NULL: {
        code: 1002011,
        msg: 'room ID is empty',
    },
    ROOM_ID_INVALID_CHARACTER: {
        code: 1002012,
        msg: 'room ID contains illegal characters',
    },
    ROOM_ID_TOO_LONG: {
        code: 1002013,
        msg: 'room ID is too long',
    },
    ROOM_NOT_EXIST: {
        code: 1002014,
        msg: 'room not exist',
    },
    LOGIN_TIMEOUT: {
        code: 1002031,
        msg: 'login timeout',
    },
    ROOM_MAX_USER_COUNT: {
        code: 1002034,
        msg: 'users logging into the room exceeds the maximum number',
    },
    MULTI_ROOM_UNABLE: {
        code: 1002036,
        msg: 'multi room unable',
    },
    MULTIPLE_LOGIN_KICKOUT: {
        code: 1002050,
        msg: 'kickout may be the same user ID login other',
    },
    NETWORK_RECOVERY: {
        code: 1002051,
        msg: 'network recovery',
    },
    ROOM_RETRY_TIMEOUT: {
        code: 1002053,
        msg: 'network is broken and login fail.',
    },
    MANUAL_KICKOUT: {
        code: 1002055,
        msg: 'server has sent a signal to kick out',
    },
    REPEATEDLY_LOGIN: {
        code: 1002056,
        msg: 'user repeatedly login',
    },
    REPEATEDLY_ENTER_ROOM: {
        code: 1002057,
        msg: 'user repeatedly enter room',
    },
    ALREADY_LOGIN: {
        code: 1002058,
        msg: 'user already logged in',
    },
    ROOM_INNER_ERROR: {
        code: 1002099,
        msg: 'room inner error',
    },
    // web
    HEARTBEAT_TIMEOUT: {
        code: 1102001,
        msg: 'heartbeat timeout.',
    },
    // access_svr
    PARSE_JSON_ERROR: {
        code: 1102011,
        msg: 'parse json error.',
    },
    LOGIN_PROCESSING: {
        code: 1102012,
        msg: 'login is processing.',
    },
    LIVEROMM_REQUEST_ERROR: {
        code: 1102013,
        msg: 'liveroom request error.',
    },
    ZPUSH_REQUEST_FAIL: {
        code: 1102014,
        msg: 'zpush request fail.',
    },
    LOGIN_STATE_WRONG: {
        code: 1102015,
        msg: 'user login state is wrong.',
    },
    TOKEN_ERROR: {
        code: 1102016,
        msg: 'token error',
    },
    DIAPATCH_ERROR: {
        code: 1102017,
        msg: 'dispatch error',
    },
    TOKEN_EXPIRED: {
        code: 1102018,
        msg: 'token expired',
    },
    SUBCMD_ERROR: {
        code: 1102019,
        msg: 'subcmd error.',
    },
    ZEGO_AUTH_ERROR: {
        code: 1102020,
        msg: 'zego auth error.',
    },
    BIZ_CHANNEL_ERROR: {
        code: 1102021,
        msg: 'biz channel error.',
    },
};


/***/ }),

/***/ "./sdk/src/zego.log.event.ts":
/*!***********************************!*\
  !*** ./sdk/src/zego.log.event.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1553685__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ZegoRTMLogEvent = void 0;
var zego_externalError_1 = __nested_webpack_require_1553685__(/*! ./zego.externalError */ "./sdk/src/zego.externalError.ts");
var getItem = function (item) { return item; };
// 不包括服务端的错误返回
exports.ZegoRTMLogEvent = {
    kZegoTaskInitSetting: {
        ///< 初始化配置
        event: '/sdk/init',
        error: {
            kInvalidParamError: zego_externalError_1.errorCodeList.INPUT_PARAM,
        },
        system_info: navigator ? navigator.appVersion : '',
    },
    kZegoTaskSetDebug: {
        event: '/sdk/set_debug',
        debug: getItem,
    },
    kZegoTaskSetLog: {
        event: '/sdk/set_log_config',
        error: {
            kInvalidParamError: zego_externalError_1.errorCodeList.INPUT_PARAM,
        },
        log_level: function (level) { return level; },
        remote_log_level: getItem,
        log_url: getItem,
    },
    kZegoTaskLoginRoom: {
        ///< sdk/login 对应用户调用login--到收到一次onlogin 回调
        event: '/sdk/login',
        user_update: getItem,
        max_member_count: getItem,
        message: getItem,
        token: getItem,
        error: {
            ROOM_ID_NULL: zego_externalError_1.errorCodeList.ROOM_ID_NULL,
            INPUT_PARAM: zego_externalError_1.errorCodeList.INPUT_PARAM,
            ROOM_ID_TOO_LONG: zego_externalError_1.errorCodeList.ROOM_ID_TOO_LONG,
            ROOM_ID_INVALID_CHARACTER: zego_externalError_1.errorCodeList.ROOM_ID_INVALID_CHARACTER,
            USER_ID_NULL: zego_externalError_1.errorCodeList.USER_ID_NULL,
            USER_ID_TOO_LONG: zego_externalError_1.errorCodeList.USER_ID_TOO_LONG,
            USER_ID_INVALID_CHARACTER: zego_externalError_1.errorCodeList.USER_ID_INVALID_CHARACTER,
            USER_NAME_NULL: zego_externalError_1.errorCodeList.USER_NAME_NULL,
            USER_NAME_TOO_LONG: zego_externalError_1.errorCodeList.USER_NAME_TOO_LONG,
            REPEATEDLY_LOGIN: zego_externalError_1.errorCodeList.REPEATEDLY_LOGIN,
            LOGIN_TIMEOUT: zego_externalError_1.errorCodeList.LOGIN_TIMEOUT,
            INNER_ERROR: zego_externalError_1.errorCodeList.ROOM_INNER_ERROR,
            NETWORK_BROKEN: zego_externalError_1.errorCodeList.NETWORK_BROKEN,
        },
        subEvent: {
            create_socket: {
                event: 'create_socket',
                server: getItem,
                try_cnt: getItem,
            },
            liveroom_login: {
                event: 'liveroom_login',
                server: getItem,
                respond_info: getItem,
            },
        },
    },
    kZegoTaskReNewToken: {
        event: '/sdk/reNewToken',
        error: {
            INPUT_PARAM: zego_externalError_1.errorCodeList.INPUT_PARAM,
            NOT_LOGIN: zego_externalError_1.errorCodeList.NOT_LOGIN,
        },
    },
    kZegoTaskLogoutRoom: {
        event: '/sdk/logout',
        error: {
            INPUT_PARAM: zego_externalError_1.errorCodeList.INPUT_PARAM,
            ROOM_NOT_EXIST: zego_externalError_1.errorCodeList.ROOM_NOT_EXIST,
        },
    },
    kZegoTaskReLoginRoom: {
        //在sessionid 等参数有效期间内 重连
        event: '/sdk/relogin',
        error: {
            ROOM_ID_NULL: zego_externalError_1.errorCodeList.ROOM_ID_NULL,
            ROOM_DISCONNECT: zego_externalError_1.errorCodeList.NETWORK_BROKEN,
        },
        subEvent: {
            create_socket: {
                event: 'create_socket',
                server: getItem,
                try_cnt: getItem,
            },
            liveroom_login: {
                event: 'liveroom_login',
                server: getItem,
                respond_info: getItem,
            },
        },
    },
    // kZegoTaskSdkDisconnect: {
    //     ///< Zpush断开
    //     event: '/sdk/disconnect',
    // },
    kZegoTaskKickout: {
        ///< Kickout Room
        event: '/sdk/kickout',
        user_id: getItem,
        error: {},
    },
    kZegoTaskRoomKickout: {
        event: '/sdk/room_kickout',
        user_id: getItem,
        room_id: getItem,
        message: getItem,
    },
    kZegoTaskLiveRoomHB: {
        ///< liveroom心跳
        event: '/liveroom/hb',
        room_sid: getItem,
        error: {
            NOT_LOGIN: zego_externalError_1.errorCodeList.NOT_LOGIN,
            HB_TIMEOUT: zego_externalError_1.errorCodeList.TIMEOUT,
        },
    },
    // kZegoTaskLiveSendRoomBigIM: {
    //     event: '/liveroom/send_big_room_message',
    //     room_sid: getItem,
    //     error: {
    //         INPUT_PARAM: errorCodeList.INPUT_PARAM,
    //         IM_CONTENT_NULL: errorCodeList.IM_CONTENT_NULL,
    //         IM_CONTENT_TOO_LONG: errorCodeList.IM_CONTENT_TOO_LONG,
    //         ROOM_NOT_EXIST: errorCodeList.ROOM_NOT_EXIST,
    //     },
    // },
    // kZegoTaskLiveRoomSendCustomCommand: {
    //     event: '/liveroom/send_custom_command',
    //     room_sid: getItem,
    //     error: {
    //         INPUT_PARAM: errorCodeList.INPUT_PARAM,
    //         IM_CONTENT_NULL: errorCodeList.IM_CONTENT_NULL,
    //         IM_CONTENT_TOO_LONG: errorCodeList.IM_CONTENT_TOO_LONG,
    //         ROOM_NOT_EXIST: errorCodeList.ROOM_NOT_EXIST,
    //     },
    // },
    // kZegoTaskLiveRoomSendRoomMessage: {
    //     event: '/liveroom/send_room_message',
    //     room_sid: getItem,
    //     error: {
    //         INPUT_PARAM: errorCodeList.INPUT_PARAM,
    //         IM_CONTENT_NULL: errorCodeList.IM_CONTENT_NULL,
    //         IM_CONTENT_TOO_LONG: errorCodeList.IM_CONTENT_TOO_LONG,
    //         ROOM_NOT_EXIST: errorCodeList.ROOM_NOT_EXIST,
    //     },
    // },
    // kZegoTaskLiveRoomSendReliableMessage: {
    //     event: '/liveroom/send_reliable_message',
    //     room_sid: getItem,
    //     error: {
    //         INPUT_PARAM: errorCodeList.INPUT_PARAM,
    //         TRANS_FREQUENTLY: errorCodeList.TRANS_FREQUENTLY,
    //         ROOM_NOT_EXIST: errorCodeList.ROOM_NOT_EXIST,
    //     },
    // },
    // kZegoTaskLiveGetRoomBigIM: {
    //     event: '/liveroom/get_big_room_message',
    // },
    // kZegoTaskLiveRoomGetRoomMessage: {
    //     event: '/liveroom/get_room_message',
    //     room_sid: getItem,
    // },
    // kZegoTaskLiveRoomGetCustomCommand: {
    //     event: '/liveroom/get_custom_command',
    // },
    kZegoTaskLiveRoomGetUserUpdateInfo: {
        event: '/liveroom/get_user_update_info',
        user_update_type: getItem,
    },
    kZegoListener: {
        event: '/sdk/listener',
    },
    kZegoEnableMultiRoom: {
        event: 'sdk/enable_multi_room',
        error: {
            kInvalidParamError: zego_externalError_1.errorCodeList.INPUT_PARAM,
            kAlreadyLoginError: zego_externalError_1.errorCodeList.ALREADY_LOGIN,
        },
    },
    // kZegoTaskLiveRoomGetCurrentUserList: {
    //     event: '/liveroom/get_current_user_list',
    // },
    // kZegoTaskLiveRoomSendEndJoinLive: {
    //     event: '/liveroom/send_end_join_live',
    // },
    // kZegoTaskLiveRoomSendInviteJoinLive: {
    //     event: '/liveroom/send_invite_join_live',
    // },
    // kZegoTaskLiveRoomSendJoinLiveResult: {
    //     event: '/liveroom/send_join_live_result',
    // },
    // kZegoTaskLiveRoomSendRequestJoinLive: {
    //     event: '/liveroom/send_request_join_live',
    // },
    kZegoTaskCloudSettingCache: {
        event: '/cloud_setting/cache',
    },
    kZegoTaskCloudSettingRefresh: {
        event: '/cloud_setting/refresh',
    },
    kZegoTaskCloudSettingRequest: {
        event: '/cloud_setting/request',
    },
};


/***/ }),

/***/ "./sdk/util/base64.ts":
/*!****************************!*\
  !*** ./sdk/util/base64.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Base64 = void 0;
/* eslint-disable prefer-const */
var Base64 = /** @class */ (function () {
    function Base64() {
    }
    Base64.base64encode = function (str) {
        var out, i, len;
        var c1, c2, c3;
        len = str.length;
        i = 0;
        out = '';
        while (i < len) {
            c1 = str.charCodeAt(i++) & 0xff;
            if (i == len) {
                out += Base64.base64EncodeChars.charAt(c1 >> 2);
                out += Base64.base64EncodeChars.charAt((c1 & 0x3) << 4);
                out += '==';
                break;
            }
            c2 = str.charCodeAt(i++);
            if (i == len) {
                out += Base64.base64EncodeChars.charAt(c1 >> 2);
                out += Base64.base64EncodeChars.charAt(((c1 & 0x3) << 4) | ((c2 & 0xf0) >> 4));
                out += Base64.base64EncodeChars.charAt((c2 & 0xf) << 2);
                out += '=';
                break;
            }
            c3 = str.charCodeAt(i++);
            out += Base64.base64EncodeChars.charAt(c1 >> 2);
            out += Base64.base64EncodeChars.charAt(((c1 & 0x3) << 4) | ((c2 & 0xf0) >> 4));
            out += Base64.base64EncodeChars.charAt(((c2 & 0xf) << 2) | ((c3 & 0xc0) >> 6));
            out += Base64.base64EncodeChars.charAt(c3 & 0x3f);
        }
        return out;
    };
    Base64.base64decode = function (str) {
        var c1, c2, c3, c4;
        var i, len, out;
        len = str.length;
        i = 0;
        out = '';
        while (i < len) {
            /* c1 */
            do {
                c1 = Base64.base64DecodeChars[str.charCodeAt(i++) & 0xff];
            } while (i < len && c1 == -1);
            if (c1 == -1)
                break;
            /* c2 */
            do {
                c2 = Base64.base64DecodeChars[str.charCodeAt(i++) & 0xff];
            } while (i < len && c2 == -1);
            if (c2 == -1)
                break;
            out += String.fromCharCode((c1 << 2) | ((c2 & 0x30) >> 4));
            /* c3 */
            do {
                c3 = str.charCodeAt(i++) & 0xff;
                if (c3 == 61)
                    return out;
                c3 = Base64.base64DecodeChars[c3];
            } while (i < len && c3 == -1);
            if (c3 == -1)
                break;
            out += String.fromCharCode(((c2 & 0xf) << 4) | ((c3 & 0x3c) >> 2));
            /* c4 */
            do {
                c4 = str.charCodeAt(i++) & 0xff;
                if (c4 == 61)
                    return out;
                c4 = Base64.base64DecodeChars[c4];
            } while (i < len && c4 == -1);
            if (c4 == -1)
                break;
            out += String.fromCharCode(((c3 & 0x03) << 6) | c4);
        }
        return out;
    };
    Base64.utf16to8 = function (str) {
        var out, i, len, c;
        out = '';
        len = str.length;
        for (i = 0; i < len; i++) {
            c = str.charCodeAt(i);
            if (c >= 0x0001 && c <= 0x007f) {
                out += str.charAt(i);
            }
            else if (c > 0x07ff) {
                out += String.fromCharCode(0xe0 | ((c >> 12) & 0x0f));
                out += String.fromCharCode(0x80 | ((c >> 6) & 0x3f));
                out += String.fromCharCode(0x80 | ((c >> 0) & 0x3f));
            }
            else {
                out += String.fromCharCode(0xc0 | ((c >> 6) & 0x1f));
                out += String.fromCharCode(0x80 | ((c >> 0) & 0x3f));
            }
        }
        return out;
    };
    Base64.utf8to16 = function (str) {
        var out, i, len, c;
        var char2, char3;
        out = '';
        len = str.length;
        i = 0;
        while (i < len) {
            c = str.charCodeAt(i++);
            switch (c >> 4) {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    // 0xxxxxxx
                    out += str.charAt(i - 1);
                    break;
                case 12:
                case 13:
                    // 110x xxxx　 10xx xxxx
                    char2 = str.charCodeAt(i++);
                    out += String.fromCharCode(((c & 0x1f) << 6) | (char2 & 0x3f));
                    break;
                case 14:
                    // 1110 xxxx　10xx xxxx　10xx xxxx
                    char2 = str.charCodeAt(i++);
                    char3 = str.charCodeAt(i++);
                    out += String.fromCharCode(((c & 0x0f) << 12) | ((char2 & 0x3f) << 6) | ((char3 & 0x3f) << 0));
                    break;
            }
        }
        return out;
    };
    Base64.base64EncodeChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    Base64.base64DecodeChars = [
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        62,
        -1,
        -1,
        -1,
        63,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        -1,
        -1,
        -1,
        -1,
        -1,
    ];
    return Base64;
}());
exports.Base64 = Base64;


/***/ }),

/***/ "./sdk/util/client-util.ts":
/*!*********************************!*\
  !*** ./sdk/util/client-util.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1568214__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientUtil = void 0;
var base64_1 = __nested_webpack_require_1568214__(/*! ./base64 */ "./sdk/util/base64.ts");
var zego_entity_1 = __nested_webpack_require_1568214__(/*! ../src/zego.entity */ "./sdk/src/zego.entity.ts");
var aes_1 = __importDefault(__nested_webpack_require_1568214__(/*! crypto-js/aes */ "./node_modules/crypto-js/aes.js"));
var enc_utf8_1 = __importDefault(__nested_webpack_require_1568214__(/*! crypto-js/enc-utf8 */ "./node_modules/crypto-js/enc-utf8.js"));
var zego_externalError_1 = __nested_webpack_require_1568214__(/*! ../src/zego.externalError */ "./sdk/src/zego.externalError.ts");
var ClientUtil = /** @class */ (function () {
    function ClientUtil() {
    }
    ClientUtil.checkConfigParam = function (appid, server, logger) {
        if (!appid || typeof appid !== 'number' || !this.checkInteger(appid)) {
            logger.error('ccp.0 appid must be positive integer number and not empty');
            return false;
        }
        if (!server || (typeof server !== 'string' && !Array.isArray(server)) || server == '') {
            logger.error('ccp.0 server must be string or string array and not empty');
            return false;
        }
        return true;
    };
    ClientUtil.checkPriConfigParam = function (appid, dispatchServer, deviceInfo, anType, logger) {
        if (!appid || typeof appid !== 'number' || !this.checkInteger(appid)) {
            logger.error('ccp.0 appid must be positive integer number and not empty');
            return false;
        }
        if (!dispatchServer || typeof dispatchServer !== 'string') {
            logger.error('ccp.0 dispatchServer must be string and not empty');
            return false;
        }
        if (typeof deviceInfo !== 'object' || typeof deviceInfo.deviceID !== 'string') {
            logger.error('ccp.0 deviceID must be string and not empty');
            return false;
        }
        if (anType !== 1 && anType !== 0) {
            logger.error('ccp.0 anType must be 0 or 1');
            return false;
        }
        return true;
    };
    ClientUtil.checkIllegalCharacters = function (str) {
        // const reg = /^(?=.*[a-zA-Z\d~!@#$%^&amp;*()_+`\-={}:";'&lt;&gt;?,.\/]).{1,256}$/;
        var reg = /^([0-9a-zA-Z#!$%&()`'+-;<=.>@^_~,\\*])+$/;
        var reg2 = /^[^:/]*$/g;
        return reg.test(str) && reg2.test(str);
    };
    ClientUtil.isUrl = function (str) {
        if (str.startsWith('rtmp://') ||
            (str.startsWith('https://') && str.endsWith('.flv')) ||
            (str.startsWith('https://') && str.endsWith('.m3u8'))) {
            return true;
        }
        return false;
    };
    ClientUtil.registerCallback = function (fName, option, callbackList) {
        var sf, ef;
        if (option.success) {
            sf = option.success;
            callbackList[fName + 'SuccessCallback'] = sf;
        }
        if (option.error) {
            ef = option.error;
            callbackList[fName + 'ErrorCallback'] = ef;
        }
    };
    ClientUtil.actionErrorCallback = function (fName, callbackList) {
        return callbackList[fName + 'ErrorCallback'];
    };
    // 执行成功回调函数
    ClientUtil.actionSuccessCallback = function (fName, callbackList) {
        return callbackList[fName + 'SuccessCallback'];
    };
    ClientUtil.logReportCallback = function (logEvent, dataReport, reportSeq, callbackList) {
        ClientUtil.registerCallback(logEvent, {
            success: function (reportName, eventName) {
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    args[_i - 2] = arguments[_i];
                }
                ClientUtil.dataReportEvent(dataReport, reportSeq, reportName, eventName, args);
            },
        }, callbackList);
    };
    ClientUtil.proxyRes = function (dataReport, reportSeq, resolve, reject) {
        var interResolve = function (res) {
            dataReport.uploadReport(reportSeq);
            resolve(res);
        };
        var interReject = function (err, externMsg) {
            if (externMsg === void 0) { externMsg = ''; }
            var reportErr;
            if (err.code < 2000000000 && err.code > 1000000000) {
                reportErr = ClientUtil.decodeServerError(err.code, err.msg);
            }
            else {
                reportErr = {
                    code: err.code,
                    message: err.msg,
                };
            }
            reportErr &&
                dataReport.addMsgInfo(reportSeq, {
                    error: reportErr.code,
                    message: reportErr.message + externMsg,
                });
            dataReport.uploadReport(reportSeq);
            reject({ errorCode: err.code });
        };
        return { interResolve: interResolve, interReject: interReject };
    };
    /**
         错误管理
         */
    ClientUtil.getServerError = function (code) {
        var serverErrorList = {
            1: 'parse json error.',
            1001: 'login is processing.',
            1002: 'liveroom request error.',
            1003: 'zpush connect fail.',
            1004: 'zpush handshake fail.',
            1005: 'zpush login fail.',
            1006: 'user login state is wrong.',
            1007: 'got no zpush addr',
            1008: 'token error',
            1009: 'dispatch error',
            1010: 'token expired',
            1011: 'token format error',
            2002: 'biz channel error',
            1000000000: 'liveroom cmd error, code:',
            1000002001: 'need relogin',
            1000002002: 'third token auth error',
            1000002003: 'token nonce type should be int64',
            1000002004: 'token appid type  should be uint32',
            1000002005: 'token timeout type should be int64',
            1000002006: 'token user_id type should be string',
            1000002007: 'token room_id type should be string',
            1000002008: 'token format error',
            1000002009: 'token privilege type should be map',
            1000002010: 'token expire_time type should be int64',
            1000002011: 'token user_id type should be string',
            1000002012: 'token not exist',
            1000002013: 'token update error',
            1000002014: 'token not need to check',
        };
        if (code === 0) {
            return zego_externalError_1.errorCodeList.SUCCESS;
        }
        var err = __assign({}, zego_externalError_1.errorCodeList.ROOM_INNER_ERROR);
        err.code = code;
        if (code > 1000000000) {
            var errMsg = serverErrorList[code];
            if (errMsg) {
                err.msg = 'liveroom cmd error, code: ' + code + ', message: ' + errMsg;
            }
            else {
                err.msg = serverErrorList[1000000000] + code;
            }
        }
        else if (serverErrorList[code]) {
            err.msg = serverErrorList[code] + ' code:' + code;
        }
        else {
            err.msg = 'unknown error code:' + code;
        }
        return err;
    };
    ClientUtil.unregisterCallback = function (fName, callbackList) {
        delete callbackList[fName + 'SuccessCallback'];
        delete callbackList[fName + 'ErrorCallback'];
    };
    ClientUtil.decodeServerError = function (code, msg) {
        var err = { code: -1, message: 'server error' };
        if (code > 1000000000) {
            err.code = code - 1000000000 + 52000000;
        }
        else {
            err.code = code + 2002000000;
        }
        msg && (err.message = msg);
        return err;
    };
    ClientUtil.getLiveRoomError = function (code, useNetAgent) {
        var liveRoomErrMap = {
            1016: 'MULTI_ROOM_UNABLE',
            1105: 'ROOM_MAX_USER_COUNT',
            1012: 'PUBLISHER_ERROR_REPETITIVE_PUBLISH_STREAM',
            // 2002: 'ROOM_ERROR_AUTHENTICATION_FAILED',
            2002: 'TOKEN_ERROR',
            2003: 'ROOM_ERROR_LOGIN_TIMEOUT',
            2010: 'TOKEN_ERROR',
        };
        var switchErrMap = {
            50116: "TOKEN_ERROR",
            50117: "TOKEN_EXPIRED",
            50118: 'TOKEN_ERROR'
        };
        if (useNetAgent) {
            if (code > 200000 && code < 300000) {
                return liveRoomErrMap[code - 200000];
            }
            else if (code < 200000) {
                return switchErrMap[code] || 'ROOM_INNER_ERROR';
            }
            return liveRoomErrMap[code] || 'ROOM_INNER_ERROR';
        }
        else {
            var prefix = 1000000000;
            var accessSvrErrMap = {
                1: 'PARSE_JSON_ERROR',
                1001: 'LOGIN_PROCESSING',
                1002: 'LIVEROMM_REQUEST_ERROR',
                1003: 'ZPUSH_REQUEST_FAIL',
                1004: 'ZPUSH_REQUEST_FAIL',
                1005: 'ZPUSH_REQUEST_FAIL',
                1006: 'LOGIN_STATE_WRONG',
                1007: 'ZPUSH_REQUEST_FAIL',
                1008: 'TOKEN_ERROR',
                1009: 'DIAPATCH_ERROR',
                1010: 'TOKEN_EXPIRED',
                1011: 'TOKEN_ERROR',
                1012: 'SUBCMD_ERROR',
                1101: 'ZEGO_AUTH_ERROR',
                2001: 'BIZ_CHANNEL_ERROR',
                2002: 'BIZ_CHANNEL_ERROR',
            };
            if (code > 1000000000) {
                return liveRoomErrMap[code - prefix] || '';
            }
            else {
                return accessSvrErrMap[code] || 'ROOM_INNER_ERROR';
            }
        }
    };
    ClientUtil.getKickoutError = function (code, useNetAgent) {
        var err = { code: code, message: 'kickout reason = ' + code };
        if (useNetAgent) {
            switch (code) {
                case 1:
                    err.code = 63000001;
                    err.message = 'zpush multiple login kickout';
                    err.name = 'MULTIPLE_LOGIN_KICKOUT';
                    break;
                case 2:
                    err.code = 63000002;
                    err.message = 'zpush manual kickout';
                    err.name = 'MANUAL_KICKOUT';
                    break;
                case 4:
                    err.code = 63000005;
                    err.message = 'zpush token expired';
                    err.name = 'TOKEN_EXPIRED';
                    break;
                default:
                    err.code = code;
                    err.message = 'kickout reason = ' + code;
                    break;
            }
        }
        else {
            switch (code) {
                case 1:
                    err.code = 63000001;
                    err.message = 'zpush multiple login kickout';
                    err.name = 'MULTIPLE_LOGIN_KICKOUT';
                    break;
                case 2:
                    err.code = 63000002;
                    err.message = 'zpush manual kickout';
                    err.name = 'MANUAL_KICKOUT';
                    break;
                case 3:
                    err.code = 63000003;
                    err.message = 'kickout reason = ' + code;
                    break;
                case 4:
                    err.code = 63000004;
                    err.message = 'zpush multiple login kickout';
                    err.name = 'MULTIPLE_LOGIN_KICKOUT';
                    break;
                case 5:
                    err.code = 63000005;
                    err.message = 'zpush token expired';
                    err.name = 'TOKEN_EXPIRED';
                    break;
                default:
                    err.code = code;
                    err.message = 'kickout reason = ' + code;
                    break;
            }
        }
        return err;
    };
    ClientUtil.dataReportEvent = function (dataReport, reportSeq, reportName, eventName, args) {
        switch (reportName) {
            case 'eventStart':
                dataReport.eventStart(reportSeq, eventName);
                break;
            case 'eventEndWithMsgInfo':
                dataReport.eventEndWithMsgInfo(reportSeq, eventName, args[0]);
                break;
            case 'addEventMsg':
                dataReport.addEventMsg(reportSeq, eventName, args[0], args[1]);
                break;
            case 'addEvent':
                dataReport.addEvent(reportSeq, eventName);
                break;
            case 'eventEnd':
                dataReport.eventEnd(reportSeq, eventName);
                break;
            case 'addMsgInfo':
                dataReport.addMsgInfo(reportSeq, args[0]);
                break;
            default:
                break;
        }
    };
    ClientUtil.isKeepTryLogin = function (code) {
        switch (code) {
            case 1002: //liveroom connect error
            case 1003: //zpush connect error
                return true;
            default:
                return false;
        }
    };
    ClientUtil.mergeUserList = function (logger, oldUserList, newUserList, callbackResult) {
        logger.debug('msl.0 call');
        var addUserList = [];
        var delUserList = [];
        var flag;
        if (!newUserList) {
            newUserList = [];
        }
        for (var i = 0; i < newUserList.length; i++) {
            flag = false;
            for (var j = 0; j < oldUserList.length; j++) {
                if (newUserList[i].userID === oldUserList[j].userID) {
                    flag = true;
                    break;
                }
            }
            if (!flag) {
                addUserList.push(newUserList[i]);
            }
        }
        for (var k = 0; k < oldUserList.length; k++) {
            flag = false;
            for (var n = 0; n < newUserList.length; n++) {
                if (oldUserList[k].userID === newUserList[n].userID) {
                    flag = true;
                    break;
                }
            }
            if (!flag) {
                delUserList.push(oldUserList[k]);
            }
        }
        oldUserList.splice(0);
        for (var i = 0; i < newUserList.length; i++) {
            oldUserList.push(oldUserList[i]);
        }
        callbackResult(addUserList, delUserList);
        logger.debug('msl.0 call success');
    };
    ClientUtil.checkInteger = function (num, positive) {
        if (positive == false)
            return typeof num === 'number' && num % 1 === 0 && num >= 0;
        return typeof num === 'number' && num % 1 === 0 && num > 0;
    };
    ClientUtil.checkValidNumber = function (param, min, max) {
        min = min || 1;
        max = max || 1 * 1e4;
        return typeof param === 'number' && param % 1 == 0 && param >= min && param <= max;
    };
    //生成随机数
    ClientUtil.generateRandumNumber = function (maxNum) {
        return parseInt(Math.random() * (maxNum + 1) + '', 10);
    };
    //生成随机数
    ClientUtil.uuid = function (len, radix) {
        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
        var uuid = [];
        var i;
        radix = radix || chars.length;
        if (len) {
            // Compact form
            for (i = 0; i < len; i++)
                uuid[i] = chars[0 | (Math.random() * radix)];
        }
        else {
            // rfc4122, version 4 form
            var r = void 0;
            // rfc4122 requires these characters
            uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
            uuid[14] = '4';
            // Fill in random data. At i==19 set the high bits of clock sequence as
            // per rfc4122, sec. 4.1.5
            for (i = 0; i < 36; i++) {
                if (!uuid[i]) {
                    r = 0 | (Math.random() * 16);
                    uuid[i] = chars[i == 19 ? (r & 0x3) | 0x8 : r];
                }
            }
        }
        return uuid.join('');
    };
    ClientUtil.compareVersion = function (v1, v2) {
        v1 = v1.split('.');
        v2 = v2.split('.');
        var len = Math.max(v1.length, v2.length);
        while (v1.length < len) {
            v1.push('0');
        }
        while (v2.length < len) {
            v2.push('0');
        }
        for (var i = 0; i < len; i++) {
            var num1 = parseInt(v1[i]);
            var num2 = parseInt(v2[i]);
            if (num1 > num2) {
                return 1;
            }
            else if (num1 < num2) {
                return -1;
            }
        }
        return 0;
    };
    ClientUtil.getBrowser = function () {
        var ua = window.navigator.userAgent;
        var isIE = window.ActiveXObject != undefined && ua.indexOf('MSIE') != -1;
        var isFirefox = ua.indexOf('Firefox') != -1;
        var isOpera = window.opr != undefined;
        var isChrome = ua.indexOf('Chrome') && window.chrome;
        var isSafari = ua.indexOf('Safari') != -1 && ua.indexOf('Version') != -1;
        if (isIE) {
            return 'IE';
        }
        else if (isFirefox) {
            return 'Firefox';
        }
        else if (isOpera) {
            return 'Opera';
        }
        else if (isChrome) {
            return 'Chrome';
        }
        else if (isSafari) {
            return 'Safari';
        }
        else {
            return 'Unkown';
        }
    };
    ClientUtil.isTestEnv = function (server) {
        if (server.indexOf('wss://wssliveroom-test.zego.im/ws') != -1 ||
            server.indexOf('wss://test2-wsliveroom-api.zego.im/ws') != -1 ||
            server.indexOf('wss://wsliveroom-test.zegocloud.com/ws') != -1 ||
            server.indexOf('wss://wsliveroom-test.zego.im/ws') != -1 ||
            server.indexOf('wss://webliveroom-test.zego.im/ws') != -1 ||
            server.indexOf('wss://webliveroom-test-bak.zego.im/ws') != -1 ||
            server.indexOf('wss://webliveroom-hk-test.zegocloud.com/ws') != -1 ||
            server.indexOf('wss://webliveroom-hk-test-bak.zegocloud.com/ws') != -1) {
            return true;
        }
        return false;
    };
    ClientUtil.getLogLevel = function (level) {
        return zego_entity_1.LOG_LEVEL[level];
    };
    ClientUtil.getUint64 = function (byteOffset, littleEndian, dv) {
        // split 64-bit number into two 32-bit parts
        var left = dv.getUint32(byteOffset, littleEndian);
        var right = dv.getUint32(byteOffset + 4, littleEndian);
        // combine the two 32-bit values
        var combined = littleEndian ? left + Math.pow(2, 32) * right : Math.pow(2, 32) * left + right;
        if (!Number.isSafeInteger(combined))
            console.warn(combined, 'exceeds MAX_SAFE_INTEGER. Precision may be lost');
        return combined;
    };
    /**
     *  返回 token 过期时间点，单位 s
     */
    ClientUtil.decodeTokenExpire = function (token) {
        try {
            var u8 = Uint8Array.from(base64_1.Base64.base64decode(token), function (c) { return c.charCodeAt(0); });
            var dv = new DataView(u8.buffer);
            var expire = void 0;
            if (typeof dv.getBigInt64 === 'function') {
                expire = dv.getBigUint64(0);
            }
            else {
                expire = ClientUtil.getUint64(0, false, dv);
            }
            if (expire > 0) {
                return Number(expire);
            }
            else {
                return Number(dv.getBigUint64(0, true));
            }
        }
        catch (err) {
            console.error('token error');
        }
        return -1;
    };
    ClientUtil.bin2hex = function (s) {
        var i, l, o = '', n;
        s += '';
        for (i = 0, l = s.length; i < l; i++) {
            n = s.charCodeAt(i).toString(16);
            o += n.length < 2 ? '0' + n : n;
        }
        return o;
    };
    ClientUtil.getCanvasFingerprint = function (domain) {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        var txt = domain;
        ctx.textBaseline = 'top';
        ctx.font = "14px 'Arial'";
        ctx.fillStyle = '#f60';
        ctx.fillRect(125, 1, 62, 20);
        ctx.fillStyle = '#069';
        ctx.fillText(txt, 2, 15);
        ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
        ctx.fillText(txt, 4, 17);
        var b64 = canvas.toDataURL().replace('data:image/png;base64,', '');
        var bin = atob(b64);
        var crc = this.bin2hex(bin.slice(-16, -12));
        return crc;
    };
    ClientUtil.generateUUID = function (env) {
        if (env === void 0) { env = 0; }
        var deviceID;
        if (env === 0) {
            deviceID = localStorage.getItem('z_deviceID');
        }
        else {
            wx.getStorageSync('z_deviceID');
        }
        if (deviceID) {
            return deviceID;
        }
        else {
            var d_1 = new Date().getTime();
            var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = (d_1 + Math.random() * 16) % 16 | 0;
                d_1 = Math.floor(d_1 / 16);
                return (c == 'x' ? r : (r & 0x3) | 0x8).toString(36);
            });
            if (env === 0) {
                var canvas = this.getCanvasFingerprint('hello, zego');
                var _uuid = canvas + uuid.slice(8);
                localStorage.setItem('z_deviceID', _uuid);
            }
            else {
                wx.setStorageSync('z_deviceID', uuid);
            }
            return uuid;
        }
    };
    ClientUtil.getNetType = function () {
        // @ts-ignore
        var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        // @ts-ignore
        return ((connection === null || connection === void 0 ? void 0 : connection.effectiveType) || (connection === null || connection === void 0 ? void 0 : connection.type) || 'unknwon').toUpperCase();
    };
    ClientUtil.getNetTypeNum = function () {
        // @ts-ignore
        var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        // @ts-ignore
        var type = ((connection === null || connection === void 0 ? void 0 : connection.effectiveType) || (connection === null || connection === void 0 ? void 0 : connection.type) || 'unknwon').toUpperCase();
        var netType;
        if (type.indexOf('4G') > -1) {
            netType = zego_entity_1.NetType.NT_4G;
        }
        else if (type.indexOf('2G') > -1) {
            netType = zego_entity_1.NetType.NT_2G;
        }
        else if (type.indexOf('3G') > -1) {
            netType = zego_entity_1.NetType.NT_3G;
        }
        else if (type.indexOf('WIFI') > -1) {
            netType = zego_entity_1.NetType.NT_WIFI;
        }
        else if (type.indexOf('LINE') > -1) {
            netType = zego_entity_1.NetType.NT_LINE;
        }
        else if (type.indexOf('NONE') > -1) {
            netType = zego_entity_1.NetType.NT_NONE;
        }
        else {
            netType = zego_entity_1.NetType.NT_UNKNOWN;
        }
        return netType;
    };
    ClientUtil.encryptStores = function (originString, secret) {
        var ciphertext = aes_1.default.encrypt(originString, secret).toString();
        return ciphertext;
    };
    ClientUtil.decryptStores = function (ciphertext, secret) {
        try {
            var bytes = aes_1.default.decrypt(ciphertext, secret);
            var originalText = bytes.toString(enc_utf8_1.default);
            return originalText;
        }
        catch (error) {
            return '';
        }
    };
    return ClientUtil;
}());
exports.ClientUtil = ClientUtil;


/***/ }),

/***/ "./sdk/util/crypto.ts":
/*!****************************!*\
  !*** ./sdk/util/crypto.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1592409__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Crypto = void 0;
var js_base64_1 = __nested_webpack_require_1592409__(/*! js-base64 */ "./node_modules/js-base64/base64.mjs");
var aes_1 = __importDefault(__nested_webpack_require_1592409__(/*! crypto-js/aes */ "./node_modules/crypto-js/aes.js"));
var enc_hex_1 = __importDefault(__nested_webpack_require_1592409__(/*! crypto-js/enc-hex */ "./node_modules/crypto-js/enc-hex.js"));
var enc_utf8_1 = __importDefault(__nested_webpack_require_1592409__(/*! crypto-js/enc-utf8 */ "./node_modules/crypto-js/enc-utf8.js"));
var lib_typedarrays_1 = __importDefault(__nested_webpack_require_1592409__(/*! crypto-js/lib-typedarrays */ "./node_modules/crypto-js/lib-typedarrays.js"));
var md5_1 = __importDefault(__nested_webpack_require_1592409__(/*! crypto-js/md5 */ "./node_modules/crypto-js/md5.js"));
// @ts-ignore
var jsencrypt_js_1 = __importDefault(__nested_webpack_require_1592409__(/*! ./jsencrypt.js */ "./sdk/util/jsencrypt.js"));
var Crypto = /** @class */ (function () {
    function Crypto() {
    }
    Object.defineProperty(Crypto.prototype, "publicKey", {
        get: function () {
            return "-----BEGIN PUBLIC KEY-----\n        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxtEM51skf+Bg29Mdb+WN\n        IkgbGDZ/wOP4MTntlut65WpPpXOkg2m9EKscmzfE6kUNLYnYV77fZGFSjr+Wkmoz\n        VK1lJ3seswBNyP6X5LUszkf1WoeEyBbfegTf3XkHEeWJ5BlD9syurlA2Fh+cTaNO\n        RNlAGBZO7SdgTHPYAcHu0fAnJZwCZ9+ZZkVnjyTBqQckovMttKqvtoUKcp7NgGve\n        w0OJxFKwIITu1keGdZ+yN9wBul4qJfTy8otOcwGL4bnoABMhCNvJc3xA70BuaaF0\n        fvhxA8diV/2W+qg+LAzdqajLaNciuDHIY5Y+z5kZI1eBa3J3aqUASse4YzzTYv48\n        7wIDAQAB\n        -----END PUBLIC KEY-----";
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 加密 ArrayBuffer
     *
     * @param body 需要加密的 ArrayBuffer
     */
    Crypto.prototype.encrypt = function (body) {
        var base64 = aes_1.default.encrypt(this.uint8Array2WordArray(body), this.key2, { iv: this.iv2 }).toString();
        return js_base64_1.Base64.toUint8Array(base64);
    };
    /**
     * 解密 ArrayBuffer
     *
     * @param body 需要解密的 ArrayBuffer
     */
    Crypto.prototype.decrypt = function (body) {
        return this.wordArray2Uint8Array(aes_1.default.decrypt(js_base64_1.Base64.fromUint8Array(body), this.key2, { iv: this.iv2 }));
    };
    /**
     * 生成 K1 签名，使用内置的公钥进行 RSA 签名
     *
     * 登录时发送给服务器
     */
    Crypto.prototype.generateK1Sign = function () {
        var k1 = this.generateNonce();
        this.key1 = enc_utf8_1.default.parse(k1);
        this.iv1 = enc_hex_1.default.parse(md5_1.default(k1)
            .toString()
            .toLowerCase());
        var encrypt = new jsencrypt_js_1.default();
        encrypt.setPublicKey(this.publicKey);
        var hex = encrypt.getKey().encrypt(k1);
        var bytes = this.wordArray2Uint8Array(enc_hex_1.default.parse(hex));
        return bytes;
    };
    /**
     * AES 用密钥 k1 解密服务器的 k2Sign
     *
     * 登录后的请求 body，用 k2 加密
     */
    Crypto.prototype.decryptK2Sign = function (k2Sign) {
        try {
            this.key2 = aes_1.default.decrypt(js_base64_1.Base64.fromUint8Array(k2Sign), this.key1, { iv: this.iv1 });
            this.iv2 = md5_1.default(this.key2);
        }
        catch (error) { }
    };
    /**
     * 生成 16 位随机字符串
     */
    Crypto.prototype.generateNonce = function () {
        var str = Math.random()
            .toString()
            .substr(2, 16);
        if (str.length < 16)
            str += str.substr(0, 16 - str.length);
        return str;
    };
    Crypto.prototype.md5 = function (str) {
        return md5_1.default(str).toString();
    };
    Crypto.prototype.md5Bytes = function (bytes) {
        return this.wordArray2Uint8Array(md5_1.default(this.uint8Array2WordArray(bytes)));
    };
    Crypto.prototype.wordArray2Uint8Array = function (wordArray) {
        var words = wordArray.words;
        var sigBytes = wordArray.sigBytes;
        var u8arr = new Uint8Array(sigBytes);
        for (var i = 0; i < sigBytes; i++) {
            var byte = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
            u8arr[i] = byte;
        }
        return u8arr;
    };
    Crypto.prototype.uint8Array2WordArray = function (u8arr) {
        var sigBytes = u8arr.length;
        var words = [];
        for (var i = 0; i < sigBytes; i++) {
            words[i >>> 2] |= (u8arr[i] & 0xff) << (24 - (i % 4) * 8);
        }
        return lib_typedarrays_1.default.create(words, sigBytes);
    };
    return Crypto;
}());
exports.Crypto = Crypto;


/***/ }),

/***/ "./sdk/util/jsencrypt.js":
/*!*******************************!*\
  !*** ./sdk/util/jsencrypt.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_1597297__) {

"use strict";
__nested_webpack_require_1597297__.r(__webpack_exports__);
var t = [
        ,
        (t, e, i) => {
            function r(t) {
                return '0123456789abcdefghijklmnopqrstuvwxyz'.charAt(t);
            }
            function n(t, e) {
                return t & e;
            }
            function s(t, e) {
                return t | e;
            }
            function o(t, e) {
                return t ^ e;
            }
            function h(t, e) {
                return t & ~e;
            }
            function a(t) {
                if (0 == t) return -1;
                var e = 0;
                return (
                    0 == (65535 & t) && ((t >>= 16), (e += 16)),
                    0 == (255 & t) && ((t >>= 8), (e += 8)),
                    0 == (15 & t) && ((t >>= 4), (e += 4)),
                    0 == (3 & t) && ((t >>= 2), (e += 2)),
                    0 == (1 & t) && ++e,
                    e
                );
            }
            function u(t) {
                for (var e = 0; 0 != t; ) (t &= t - 1), ++e;
                return e;
            }
            i.d(e, { default: () => nt });
            var c,
                f = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
            function l(t) {
                var e,
                    i,
                    r = '';
                for (e = 0; e + 3 <= t.length; e += 3)
                    (i = parseInt(t.substring(e, e + 3), 16)), (r += f.charAt(i >> 6) + f.charAt(63 & i));
                for (
                    e + 1 == t.length
                        ? ((i = parseInt(t.substring(e, e + 1), 16)), (r += f.charAt(i << 2)))
                        : e + 2 == t.length &&
                          ((i = parseInt(t.substring(e, e + 2), 16)), (r += f.charAt(i >> 2) + f.charAt((3 & i) << 4)));
                    (3 & r.length) > 0;

                )
                    r += '=';
                return r;
            }
            function p(t) {
                var e,
                    i = '',
                    n = 0,
                    s = 0;
                for (e = 0; e < t.length && '=' != t.charAt(e); ++e) {
                    var o = f.indexOf(t.charAt(e));
                    o < 0 ||
                        (0 == n
                            ? ((i += r(o >> 2)), (s = 3 & o), (n = 1))
                            : 1 == n
                            ? ((i += r((s << 2) | (o >> 4))), (s = 15 & o), (n = 2))
                            : 2 == n
                            ? ((i += r(s)), (i += r(o >> 2)), (s = 3 & o), (n = 3))
                            : ((i += r((s << 2) | (o >> 4))), (i += r(15 & o)), (n = 0)));
                }
                return 1 == n && (i += r(s << 2)), i;
            }
            var g,
                d = {
                    decode: function (t) {
                        var e;
                        if (void 0 === g) {
                            var i = '= \f\n\r\t \u2028\u2029';
                            for (g = Object.create(null), e = 0; e < 64; ++e)
                                g['ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.charAt(e)] = e;
                            for (g['-'] = 62, g._ = 63, e = 0; e < i.length; ++e) g[i.charAt(e)] = -1;
                        }
                        var r = [],
                            n = 0,
                            s = 0;
                        for (e = 0; e < t.length; ++e) {
                            var o = t.charAt(e);
                            if ('=' == o) break;
                            if (-1 != (o = g[o])) {
                                if (void 0 === o) throw new Error('Illegal character at offset ' + e);
                                (n |= o),
                                    ++s >= 4
                                        ? ((r[r.length] = n >> 16),
                                          (r[r.length] = (n >> 8) & 255),
                                          (r[r.length] = 255 & n),
                                          (n = 0),
                                          (s = 0))
                                        : (n <<= 6);
                            }
                        }
                        switch (s) {
                            case 1:
                                throw new Error('Base64 encoding incomplete: at least 2 bits missing');
                            case 2:
                                r[r.length] = n >> 10;
                                break;
                            case 3:
                                (r[r.length] = n >> 16), (r[r.length] = (n >> 8) & 255);
                        }
                        return r;
                    },
                    re: /-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/,
                    unarmor: function (t) {
                        var e = d.re.exec(t);
                        if (e)
                            if (e[1]) t = e[1];
                            else {
                                if (!e[2]) throw new Error('RegExp out of sync');
                                t = e[2];
                            }
                        return d.decode(t);
                    },
                },
                v = 1e13,
                m = (function () {
                    function t(t) {
                        this.buf = [+t || 0];
                    }
                    return (
                        (t.prototype.mulAdd = function (t, e) {
                            var i,
                                r,
                                n = this.buf,
                                s = n.length;
                            for (i = 0; i < s; ++i)
                                (r = n[i] * t + e) < v ? (e = 0) : (r -= (e = 0 | (r / v)) * v), (n[i] = r);
                            e > 0 && (n[i] = e);
                        }),
                        (t.prototype.sub = function (t) {
                            var e,
                                i,
                                r = this.buf,
                                n = r.length;
                            for (e = 0; e < n; ++e) (i = r[e] - t) < 0 ? ((i += v), (t = 1)) : (t = 0), (r[e] = i);
                            for (; 0 === r[r.length - 1]; ) r.pop();
                        }),
                        (t.prototype.toString = function (t) {
                            if (10 != (t || 10)) throw new Error('only base 10 is supported');
                            for (var e = this.buf, i = e[e.length - 1].toString(), r = e.length - 2; r >= 0; --r)
                                i += (v + e[r]).toString().substring(1);
                            return i;
                        }),
                        (t.prototype.valueOf = function () {
                            for (var t = this.buf, e = 0, i = t.length - 1; i >= 0; --i) e = e * v + t[i];
                            return e;
                        }),
                        (t.prototype.simplify = function () {
                            var t = this.buf;
                            return 1 == t.length ? t[0] : this;
                        }),
                        t
                    );
                })(),
                y = /^(\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/,
                b = /^(\d\d\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
            function T(t, e) {
                return t.length > e && (t = t.substring(0, e) + '…'), t;
            }
            var S,
                E = (function () {
                    function t(e, i) {
                        (this.hexDigits = '0123456789ABCDEF'),
                            e instanceof t
                                ? ((this.enc = e.enc), (this.pos = e.pos))
                                : ((this.enc = e), (this.pos = i));
                    }
                    return (
                        (t.prototype.get = function (t) {
                            if ((void 0 === t && (t = this.pos++), t >= this.enc.length))
                                throw new Error(
                                    'Requesting byte offset ' + t + ' on a stream of length ' + this.enc.length,
                                );
                            return 'string' == typeof this.enc ? this.enc.charCodeAt(t) : this.enc[t];
                        }),
                        (t.prototype.hexByte = function (t) {
                            return this.hexDigits.charAt((t >> 4) & 15) + this.hexDigits.charAt(15 & t);
                        }),
                        (t.prototype.hexDump = function (t, e, i) {
                            for (var r = '', n = t; n < e; ++n)
                                if (((r += this.hexByte(this.get(n))), !0 !== i))
                                    switch (15 & n) {
                                        case 7:
                                            r += '  ';
                                            break;
                                        case 15:
                                            r += '\n';
                                            break;
                                        default:
                                            r += ' ';
                                    }
                            return r;
                        }),
                        (t.prototype.isASCII = function (t, e) {
                            for (var i = t; i < e; ++i) {
                                var r = this.get(i);
                                if (r < 32 || r > 176) return !1;
                            }
                            return !0;
                        }),
                        (t.prototype.parseStringISO = function (t, e) {
                            for (var i = '', r = t; r < e; ++r) i += String.fromCharCode(this.get(r));
                            return i;
                        }),
                        (t.prototype.parseStringUTF = function (t, e) {
                            for (var i = '', r = t; r < e; ) {
                                var n = this.get(r++);
                                i +=
                                    n < 128
                                        ? String.fromCharCode(n)
                                        : n > 191 && n < 224
                                        ? String.fromCharCode(((31 & n) << 6) | (63 & this.get(r++)))
                                        : String.fromCharCode(
                                              ((15 & n) << 12) | ((63 & this.get(r++)) << 6) | (63 & this.get(r++)),
                                          );
                            }
                            return i;
                        }),
                        (t.prototype.parseStringBMP = function (t, e) {
                            for (var i, r, n = '', s = t; s < e; )
                                (i = this.get(s++)), (r = this.get(s++)), (n += String.fromCharCode((i << 8) | r));
                            return n;
                        }),
                        (t.prototype.parseTime = function (t, e, i) {
                            var r = this.parseStringISO(t, e),
                                n = (i ? y : b).exec(r);
                            return n
                                ? (i && ((n[1] = +n[1]), (n[1] += +n[1] < 70 ? 2e3 : 1900)),
                                  (r = n[1] + '-' + n[2] + '-' + n[3] + ' ' + n[4]),
                                  n[5] && ((r += ':' + n[5]), n[6] && ((r += ':' + n[6]), n[7] && (r += '.' + n[7]))),
                                  n[8] && ((r += ' UTC'), 'Z' != n[8] && ((r += n[8]), n[9] && (r += ':' + n[9]))),
                                  r)
                                : 'Unrecognized time: ' + r;
                        }),
                        (t.prototype.parseInteger = function (t, e) {
                            for (var i, r = this.get(t), n = r > 127, s = n ? 255 : 0, o = ''; r == s && ++t < e; )
                                r = this.get(t);
                            if (0 == (i = e - t)) return n ? -1 : 0;
                            if (i > 4) {
                                for (o = r, i <<= 3; 0 == (128 & (+o ^ s)); ) (o = +o << 1), --i;
                                o = '(' + i + ' bit)\n';
                            }
                            n && (r -= 256);
                            for (var h = new m(r), a = t + 1; a < e; ++a) h.mulAdd(256, this.get(a));
                            return o + h.toString();
                        }),
                        (t.prototype.parseBitString = function (t, e, i) {
                            for (
                                var r = this.get(t), n = '(' + (((e - t - 1) << 3) - r) + ' bit)\n', s = '', o = t + 1;
                                o < e;
                                ++o
                            ) {
                                for (var h = this.get(o), a = o == e - 1 ? r : 0, u = 7; u >= a; --u)
                                    s += (h >> u) & 1 ? '1' : '0';
                                if (s.length > i) return n + T(s, i);
                            }
                            return n + s;
                        }),
                        (t.prototype.parseOctetString = function (t, e, i) {
                            if (this.isASCII(t, e)) return T(this.parseStringISO(t, e), i);
                            var r = e - t,
                                n = '(' + r + ' byte)\n';
                            r > (i /= 2) && (e = t + i);
                            for (var s = t; s < e; ++s) n += this.hexByte(this.get(s));
                            return r > i && (n += '…'), n;
                        }),
                        (t.prototype.parseOID = function (t, e, i) {
                            for (var r = '', n = new m(), s = 0, o = t; o < e; ++o) {
                                var h = this.get(o);
                                if ((n.mulAdd(128, 127 & h), (s += 7), !(128 & h))) {
                                    if ('' === r)
                                        if ((n = n.simplify()) instanceof m) n.sub(80), (r = '2.' + n.toString());
                                        else {
                                            var a = n < 80 ? (n < 40 ? 0 : 1) : 2;
                                            r = a + '.' + (n - 40 * a);
                                        }
                                    else r += '.' + n.toString();
                                    if (r.length > i) return T(r, i);
                                    (n = new m()), (s = 0);
                                }
                            }
                            return s > 0 && (r += '.incomplete'), r;
                        }),
                        t
                    );
                })(),
                w = (function () {
                    function t(t, e, i, r, n) {
                        if (!(r instanceof D)) throw new Error('Invalid tag value.');
                        (this.stream = t), (this.header = e), (this.length = i), (this.tag = r), (this.sub = n);
                    }
                    return (
                        (t.prototype.typeName = function () {
                            switch (this.tag.tagClass) {
                                case 0:
                                    switch (this.tag.tagNumber) {
                                        case 0:
                                            return 'EOC';
                                        case 1:
                                            return 'BOOLEAN';
                                        case 2:
                                            return 'INTEGER';
                                        case 3:
                                            return 'BIT_STRING';
                                        case 4:
                                            return 'OCTET_STRING';
                                        case 5:
                                            return 'NULL';
                                        case 6:
                                            return 'OBJECT_IDENTIFIER';
                                        case 7:
                                            return 'ObjectDescriptor';
                                        case 8:
                                            return 'EXTERNAL';
                                        case 9:
                                            return 'REAL';
                                        case 10:
                                            return 'ENUMERATED';
                                        case 11:
                                            return 'EMBEDDED_PDV';
                                        case 12:
                                            return 'UTF8String';
                                        case 16:
                                            return 'SEQUENCE';
                                        case 17:
                                            return 'SET';
                                        case 18:
                                            return 'NumericString';
                                        case 19:
                                            return 'PrintableString';
                                        case 20:
                                            return 'TeletexString';
                                        case 21:
                                            return 'VideotexString';
                                        case 22:
                                            return 'IA5String';
                                        case 23:
                                            return 'UTCTime';
                                        case 24:
                                            return 'GeneralizedTime';
                                        case 25:
                                            return 'GraphicString';
                                        case 26:
                                            return 'VisibleString';
                                        case 27:
                                            return 'GeneralString';
                                        case 28:
                                            return 'UniversalString';
                                        case 30:
                                            return 'BMPString';
                                    }
                                    return 'Universal_' + this.tag.tagNumber.toString();
                                case 1:
                                    return 'Application_' + this.tag.tagNumber.toString();
                                case 2:
                                    return '[' + this.tag.tagNumber.toString() + ']';
                                case 3:
                                    return 'Private_' + this.tag.tagNumber.toString();
                            }
                        }),
                        (t.prototype.content = function (t) {
                            if (void 0 === this.tag) return null;
                            void 0 === t && (t = 1 / 0);
                            var e = this.posContent(),
                                i = Math.abs(this.length);
                            if (!this.tag.isUniversal())
                                return null !== this.sub
                                    ? '(' + this.sub.length + ' elem)'
                                    : this.stream.parseOctetString(e, e + i, t);
                            switch (this.tag.tagNumber) {
                                case 1:
                                    return 0 === this.stream.get(e) ? 'false' : 'true';
                                case 2:
                                    return this.stream.parseInteger(e, e + i);
                                case 3:
                                    return this.sub
                                        ? '(' + this.sub.length + ' elem)'
                                        : this.stream.parseBitString(e, e + i, t);
                                case 4:
                                    return this.sub
                                        ? '(' + this.sub.length + ' elem)'
                                        : this.stream.parseOctetString(e, e + i, t);
                                case 6:
                                    return this.stream.parseOID(e, e + i, t);
                                case 16:
                                case 17:
                                    return null !== this.sub ? '(' + this.sub.length + ' elem)' : '(no elem)';
                                case 12:
                                    return T(this.stream.parseStringUTF(e, e + i), t);
                                case 18:
                                case 19:
                                case 20:
                                case 21:
                                case 22:
                                case 26:
                                    return T(this.stream.parseStringISO(e, e + i), t);
                                case 30:
                                    return T(this.stream.parseStringBMP(e, e + i), t);
                                case 23:
                                case 24:
                                    return this.stream.parseTime(e, e + i, 23 == this.tag.tagNumber);
                            }
                            return null;
                        }),
                        (t.prototype.toString = function () {
                            return (
                                this.typeName() +
                                '@' +
                                this.stream.pos +
                                '[header:' +
                                this.header +
                                ',length:' +
                                this.length +
                                ',sub:' +
                                (null === this.sub ? 'null' : this.sub.length) +
                                ']'
                            );
                        }),
                        (t.prototype.toPrettyString = function (t) {
                            void 0 === t && (t = '');
                            var e = t + this.typeName() + ' @' + this.stream.pos;
                            if (
                                (this.length >= 0 && (e += '+'),
                                (e += this.length),
                                this.tag.tagConstructed
                                    ? (e += ' (constructed)')
                                    : !this.tag.isUniversal() ||
                                      (3 != this.tag.tagNumber && 4 != this.tag.tagNumber) ||
                                      null === this.sub ||
                                      (e += ' (encapsulates)'),
                                (e += '\n'),
                                null !== this.sub)
                            ) {
                                t += '  ';
                                for (var i = 0, r = this.sub.length; i < r; ++i) e += this.sub[i].toPrettyString(t);
                            }
                            return e;
                        }),
                        (t.prototype.posStart = function () {
                            return this.stream.pos;
                        }),
                        (t.prototype.posContent = function () {
                            return this.stream.pos + this.header;
                        }),
                        (t.prototype.posEnd = function () {
                            return this.stream.pos + this.header + Math.abs(this.length);
                        }),
                        (t.prototype.toHexString = function () {
                            return this.stream.hexDump(this.posStart(), this.posEnd(), !0);
                        }),
                        (t.decodeLength = function (t) {
                            var e = t.get(),
                                i = 127 & e;
                            if (i == e) return i;
                            if (i > 6) throw new Error('Length over 48 bits not supported at position ' + (t.pos - 1));
                            if (0 === i) return null;
                            e = 0;
                            for (var r = 0; r < i; ++r) e = 256 * e + t.get();
                            return e;
                        }),
                        (t.prototype.getHexStringValue = function () {
                            var t = this.toHexString(),
                                e = 2 * this.header,
                                i = 2 * this.length;
                            return t.substr(e, i);
                        }),
                        (t.decode = function (e) {
                            var i;
                            i = e instanceof E ? e : new E(e, 0);
                            var r = new E(i),
                                n = new D(i),
                                s = t.decodeLength(i),
                                o = i.pos,
                                h = o - r.pos,
                                a = null,
                                u = function () {
                                    var e = [];
                                    if (null !== s) {
                                        for (var r = o + s; i.pos < r; ) e[e.length] = t.decode(i);
                                        if (i.pos != r)
                                            throw new Error(
                                                'Content size is not correct for container starting at offset ' + o,
                                            );
                                    } else
                                        try {
                                            for (;;) {
                                                var n = t.decode(i);
                                                if (n.tag.isEOC()) break;
                                                e[e.length] = n;
                                            }
                                            s = o - i.pos;
                                        } catch (t) {
                                            throw new Error('Exception while decoding undefined length content: ' + t);
                                        }
                                    return e;
                                };
                            if (n.tagConstructed) a = u();
                            else if (n.isUniversal() && (3 == n.tagNumber || 4 == n.tagNumber))
                                try {
                                    if (3 == n.tagNumber && 0 != i.get())
                                        throw new Error('BIT STRINGs with unused bits cannot encapsulate.');
                                    a = u();
                                    for (var c = 0; c < a.length; ++c)
                                        if (a[c].tag.isEOC())
                                            throw new Error('EOC is not supposed to be actual content.');
                                } catch (t) {
                                    a = null;
                                }
                            if (null === a) {
                                if (null === s)
                                    throw new Error(
                                        "We can't skip over an invalid tag with undefined length at offset " + o,
                                    );
                                i.pos = o + Math.abs(s);
                            }
                            return new t(r, h, s, n, a);
                        }),
                        t
                    );
                })(),
                D = (function () {
                    function t(t) {
                        var e = t.get();
                        if (
                            ((this.tagClass = e >> 6),
                            (this.tagConstructed = 0 != (32 & e)),
                            (this.tagNumber = 31 & e),
                            31 == this.tagNumber)
                        ) {
                            var i = new m();
                            do {
                                (e = t.get()), i.mulAdd(128, 127 & e);
                            } while (128 & e);
                            this.tagNumber = i.simplify();
                        }
                    }
                    return (
                        (t.prototype.isUniversal = function () {
                            return 0 === this.tagClass;
                        }),
                        (t.prototype.isEOC = function () {
                            return 0 === this.tagClass && 0 === this.tagNumber;
                        }),
                        t
                    );
                })(),
                x = [
                    2,
                    3,
                    5,
                    7,
                    11,
                    13,
                    17,
                    19,
                    23,
                    29,
                    31,
                    37,
                    41,
                    43,
                    47,
                    53,
                    59,
                    61,
                    67,
                    71,
                    73,
                    79,
                    83,
                    89,
                    97,
                    101,
                    103,
                    107,
                    109,
                    113,
                    127,
                    131,
                    137,
                    139,
                    149,
                    151,
                    157,
                    163,
                    167,
                    173,
                    179,
                    181,
                    191,
                    193,
                    197,
                    199,
                    211,
                    223,
                    227,
                    229,
                    233,
                    239,
                    241,
                    251,
                    257,
                    263,
                    269,
                    271,
                    277,
                    281,
                    283,
                    293,
                    307,
                    311,
                    313,
                    317,
                    331,
                    337,
                    347,
                    349,
                    353,
                    359,
                    367,
                    373,
                    379,
                    383,
                    389,
                    397,
                    401,
                    409,
                    419,
                    421,
                    431,
                    433,
                    439,
                    443,
                    449,
                    457,
                    461,
                    463,
                    467,
                    479,
                    487,
                    491,
                    499,
                    503,
                    509,
                    521,
                    523,
                    541,
                    547,
                    557,
                    563,
                    569,
                    571,
                    577,
                    587,
                    593,
                    599,
                    601,
                    607,
                    613,
                    617,
                    619,
                    631,
                    641,
                    643,
                    647,
                    653,
                    659,
                    661,
                    673,
                    677,
                    683,
                    691,
                    701,
                    709,
                    719,
                    727,
                    733,
                    739,
                    743,
                    751,
                    757,
                    761,
                    769,
                    773,
                    787,
                    797,
                    809,
                    811,
                    821,
                    823,
                    827,
                    829,
                    839,
                    853,
                    857,
                    859,
                    863,
                    877,
                    881,
                    883,
                    887,
                    907,
                    911,
                    919,
                    929,
                    937,
                    941,
                    947,
                    953,
                    967,
                    971,
                    977,
                    983,
                    991,
                    997,
                ],
                R = (1 << 26) / x[x.length - 1],
                B = (function () {
                    function t(t, e, i) {
                        null != t &&
                            ('number' == typeof t
                                ? this.fromNumber(t, e, i)
                                : null == e && 'string' != typeof t
                                ? this.fromString(t, 256)
                                : this.fromString(t, e));
                    }
                    return (
                        (t.prototype.toString = function (t) {
                            if (this.s < 0) return '-' + this.negate().toString(t);
                            var e;
                            if (16 == t) e = 4;
                            else if (8 == t) e = 3;
                            else if (2 == t) e = 1;
                            else if (32 == t) e = 5;
                            else {
                                if (4 != t) return this.toRadix(t);
                                e = 2;
                            }
                            var i,
                                n = (1 << e) - 1,
                                s = !1,
                                o = '',
                                h = this.t,
                                a = this.DB - ((h * this.DB) % e);
                            if (h-- > 0)
                                for (a < this.DB && (i = this[h] >> a) > 0 && ((s = !0), (o = r(i))); h >= 0; )
                                    a < e
                                        ? ((i = (this[h] & ((1 << a) - 1)) << (e - a)),
                                          (i |= this[--h] >> (a += this.DB - e)))
                                        : ((i = (this[h] >> (a -= e)) & n), a <= 0 && ((a += this.DB), --h)),
                                        i > 0 && (s = !0),
                                        s && (o += r(i));
                            return s ? o : '0';
                        }),
                        (t.prototype.negate = function () {
                            var e = N();
                            return t.ZERO.subTo(this, e), e;
                        }),
                        (t.prototype.abs = function () {
                            return this.s < 0 ? this.negate() : this;
                        }),
                        (t.prototype.compareTo = function (t) {
                            var e = this.s - t.s;
                            if (0 != e) return e;
                            var i = this.t;
                            if (0 != (e = i - t.t)) return this.s < 0 ? -e : e;
                            for (; --i >= 0; ) if (0 != (e = this[i] - t[i])) return e;
                            return 0;
                        }),
                        (t.prototype.bitLength = function () {
                            return this.t <= 0 ? 0 : this.DB * (this.t - 1) + F(this[this.t - 1] ^ (this.s & this.DM));
                        }),
                        (t.prototype.mod = function (e) {
                            var i = N();
                            return (
                                this.abs().divRemTo(e, null, i),
                                this.s < 0 && i.compareTo(t.ZERO) > 0 && e.subTo(i, i),
                                i
                            );
                        }),
                        (t.prototype.modPowInt = function (t, e) {
                            var i;
                            return (i = t < 256 || e.isEven() ? new A(e) : new V(e)), this.exp(t, i);
                        }),
                        (t.prototype.clone = function () {
                            var t = N();
                            return this.copyTo(t), t;
                        }),
                        (t.prototype.intValue = function () {
                            if (this.s < 0) {
                                if (1 == this.t) return this[0] - this.DV;
                                if (0 == this.t) return -1;
                            } else {
                                if (1 == this.t) return this[0];
                                if (0 == this.t) return 0;
                            }
                            return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
                        }),
                        (t.prototype.byteValue = function () {
                            return 0 == this.t ? this.s : (this[0] << 24) >> 24;
                        }),
                        (t.prototype.shortValue = function () {
                            return 0 == this.t ? this.s : (this[0] << 16) >> 16;
                        }),
                        (t.prototype.signum = function () {
                            return this.s < 0 ? -1 : this.t <= 0 || (1 == this.t && this[0] <= 0) ? 0 : 1;
                        }),
                        (t.prototype.toByteArray = function () {
                            var t = this.t,
                                e = [];
                            e[0] = this.s;
                            var i,
                                r = this.DB - ((t * this.DB) % 8),
                                n = 0;
                            if (t-- > 0)
                                for (
                                    r < this.DB &&
                                    (i = this[t] >> r) != (this.s & this.DM) >> r &&
                                    (e[n++] = i | (this.s << (this.DB - r)));
                                    t >= 0;

                                )
                                    r < 8
                                        ? ((i = (this[t] & ((1 << r) - 1)) << (8 - r)),
                                          (i |= this[--t] >> (r += this.DB - 8)))
                                        : ((i = (this[t] >> (r -= 8)) & 255), r <= 0 && ((r += this.DB), --t)),
                                        0 != (128 & i) && (i |= -256),
                                        0 == n && (128 & this.s) != (128 & i) && ++n,
                                        (n > 0 || i != this.s) && (e[n++] = i);
                            return e;
                        }),
                        (t.prototype.equals = function (t) {
                            return 0 == this.compareTo(t);
                        }),
                        (t.prototype.min = function (t) {
                            return this.compareTo(t) < 0 ? this : t;
                        }),
                        (t.prototype.max = function (t) {
                            return this.compareTo(t) > 0 ? this : t;
                        }),
                        (t.prototype.and = function (t) {
                            var e = N();
                            return this.bitwiseTo(t, n, e), e;
                        }),
                        (t.prototype.or = function (t) {
                            var e = N();
                            return this.bitwiseTo(t, s, e), e;
                        }),
                        (t.prototype.xor = function (t) {
                            var e = N();
                            return this.bitwiseTo(t, o, e), e;
                        }),
                        (t.prototype.andNot = function (t) {
                            var e = N();
                            return this.bitwiseTo(t, h, e), e;
                        }),
                        (t.prototype.not = function () {
                            for (var t = N(), e = 0; e < this.t; ++e) t[e] = this.DM & ~this[e];
                            return (t.t = this.t), (t.s = ~this.s), t;
                        }),
                        (t.prototype.shiftLeft = function (t) {
                            var e = N();
                            return t < 0 ? this.rShiftTo(-t, e) : this.lShiftTo(t, e), e;
                        }),
                        (t.prototype.shiftRight = function (t) {
                            var e = N();
                            return t < 0 ? this.lShiftTo(-t, e) : this.rShiftTo(t, e), e;
                        }),
                        (t.prototype.getLowestSetBit = function () {
                            for (var t = 0; t < this.t; ++t) if (0 != this[t]) return t * this.DB + a(this[t]);
                            return this.s < 0 ? this.t * this.DB : -1;
                        }),
                        (t.prototype.bitCount = function () {
                            for (var t = 0, e = this.s & this.DM, i = 0; i < this.t; ++i) t += u(this[i] ^ e);
                            return t;
                        }),
                        (t.prototype.testBit = function (t) {
                            var e = Math.floor(t / this.DB);
                            return e >= this.t ? 0 != this.s : 0 != (this[e] & (1 << t % this.DB));
                        }),
                        (t.prototype.setBit = function (t) {
                            return this.changeBit(t, s);
                        }),
                        (t.prototype.clearBit = function (t) {
                            return this.changeBit(t, h);
                        }),
                        (t.prototype.flipBit = function (t) {
                            return this.changeBit(t, o);
                        }),
                        (t.prototype.add = function (t) {
                            var e = N();
                            return this.addTo(t, e), e;
                        }),
                        (t.prototype.subtract = function (t) {
                            var e = N();
                            return this.subTo(t, e), e;
                        }),
                        (t.prototype.multiply = function (t) {
                            var e = N();
                            return this.multiplyTo(t, e), e;
                        }),
                        (t.prototype.divide = function (t) {
                            var e = N();
                            return this.divRemTo(t, e, null), e;
                        }),
                        (t.prototype.remainder = function (t) {
                            var e = N();
                            return this.divRemTo(t, null, e), e;
                        }),
                        (t.prototype.divideAndRemainder = function (t) {
                            var e = N(),
                                i = N();
                            return this.divRemTo(t, e, i), [e, i];
                        }),
                        (t.prototype.modPow = function (t, e) {
                            var i,
                                r,
                                n = t.bitLength(),
                                s = C(1);
                            if (n <= 0) return s;
                            (i = n < 18 ? 1 : n < 48 ? 3 : n < 144 ? 4 : n < 768 ? 5 : 6),
                                (r = n < 8 ? new A(e) : e.isEven() ? new I(e) : new V(e));
                            var o = [],
                                h = 3,
                                a = i - 1,
                                u = (1 << i) - 1;
                            if (((o[1] = r.convert(this)), i > 1)) {
                                var c = N();
                                for (r.sqrTo(o[1], c); h <= u; ) (o[h] = N()), r.mulTo(c, o[h - 2], o[h]), (h += 2);
                            }
                            var f,
                                l,
                                p = t.t - 1,
                                g = !0,
                                d = N();
                            for (n = F(t[p]) - 1; p >= 0; ) {
                                for (
                                    n >= a
                                        ? (f = (t[p] >> (n - a)) & u)
                                        : ((f = (t[p] & ((1 << (n + 1)) - 1)) << (a - n)),
                                          p > 0 && (f |= t[p - 1] >> (this.DB + n - a))),
                                        h = i;
                                    0 == (1 & f);

                                )
                                    (f >>= 1), --h;
                                if (((n -= h) < 0 && ((n += this.DB), --p), g)) o[f].copyTo(s), (g = !1);
                                else {
                                    for (; h > 1; ) r.sqrTo(s, d), r.sqrTo(d, s), (h -= 2);
                                    h > 0 ? r.sqrTo(s, d) : ((l = s), (s = d), (d = l)), r.mulTo(d, o[f], s);
                                }
                                for (; p >= 0 && 0 == (t[p] & (1 << n)); )
                                    r.sqrTo(s, d), (l = s), (s = d), (d = l), --n < 0 && ((n = this.DB - 1), --p);
                            }
                            return r.revert(s);
                        }),
                        (t.prototype.modInverse = function (e) {
                            var i = e.isEven();
                            if ((this.isEven() && i) || 0 == e.signum()) return t.ZERO;
                            for (
                                var r = e.clone(), n = this.clone(), s = C(1), o = C(0), h = C(0), a = C(1);
                                0 != r.signum();

                            ) {
                                for (; r.isEven(); )
                                    r.rShiftTo(1, r),
                                        i
                                            ? ((s.isEven() && o.isEven()) || (s.addTo(this, s), o.subTo(e, o)),
                                              s.rShiftTo(1, s))
                                            : o.isEven() || o.subTo(e, o),
                                        o.rShiftTo(1, o);
                                for (; n.isEven(); )
                                    n.rShiftTo(1, n),
                                        i
                                            ? ((h.isEven() && a.isEven()) || (h.addTo(this, h), a.subTo(e, a)),
                                              h.rShiftTo(1, h))
                                            : a.isEven() || a.subTo(e, a),
                                        a.rShiftTo(1, a);
                                r.compareTo(n) >= 0
                                    ? (r.subTo(n, r), i && s.subTo(h, s), o.subTo(a, o))
                                    : (n.subTo(r, n), i && h.subTo(s, h), a.subTo(o, a));
                            }
                            return 0 != n.compareTo(t.ONE)
                                ? t.ZERO
                                : a.compareTo(e) >= 0
                                ? a.subtract(e)
                                : a.signum() < 0
                                ? (a.addTo(e, a), a.signum() < 0 ? a.add(e) : a)
                                : a;
                        }),
                        (t.prototype.pow = function (t) {
                            return this.exp(t, new O());
                        }),
                        (t.prototype.gcd = function (t) {
                            var e = this.s < 0 ? this.negate() : this.clone(),
                                i = t.s < 0 ? t.negate() : t.clone();
                            if (e.compareTo(i) < 0) {
                                var r = e;
                                (e = i), (i = r);
                            }
                            var n = e.getLowestSetBit(),
                                s = i.getLowestSetBit();
                            if (s < 0) return e;
                            for (n < s && (s = n), s > 0 && (e.rShiftTo(s, e), i.rShiftTo(s, i)); e.signum() > 0; )
                                (n = e.getLowestSetBit()) > 0 && e.rShiftTo(n, e),
                                    (n = i.getLowestSetBit()) > 0 && i.rShiftTo(n, i),
                                    e.compareTo(i) >= 0
                                        ? (e.subTo(i, e), e.rShiftTo(1, e))
                                        : (i.subTo(e, i), i.rShiftTo(1, i));
                            return s > 0 && i.lShiftTo(s, i), i;
                        }),
                        (t.prototype.isProbablePrime = function (t) {
                            var e,
                                i = this.abs();
                            if (1 == i.t && i[0] <= x[x.length - 1]) {
                                for (e = 0; e < x.length; ++e) if (i[0] == x[e]) return !0;
                                return !1;
                            }
                            if (i.isEven()) return !1;
                            for (e = 1; e < x.length; ) {
                                for (var r = x[e], n = e + 1; n < x.length && r < R; ) r *= x[n++];
                                for (r = i.modInt(r); e < n; ) if (r % x[e++] == 0) return !1;
                            }
                            return i.millerRabin(t);
                        }),
                        (t.prototype.copyTo = function (t) {
                            for (var e = this.t - 1; e >= 0; --e) t[e] = this[e];
                            (t.t = this.t), (t.s = this.s);
                        }),
                        (t.prototype.fromInt = function (t) {
                            (this.t = 1),
                                (this.s = t < 0 ? -1 : 0),
                                t > 0 ? (this[0] = t) : t < -1 ? (this[0] = t + this.DV) : (this.t = 0);
                        }),
                        (t.prototype.fromString = function (e, i) {
                            var r;
                            if (16 == i) r = 4;
                            else if (8 == i) r = 3;
                            else if (256 == i) r = 8;
                            else if (2 == i) r = 1;
                            else if (32 == i) r = 5;
                            else {
                                if (4 != i) return void this.fromRadix(e, i);
                                r = 2;
                            }
                            (this.t = 0), (this.s = 0);
                            for (var n = e.length, s = !1, o = 0; --n >= 0; ) {
                                var h = 8 == r ? 255 & +e[n] : H(e, n);
                                h < 0
                                    ? '-' == e.charAt(n) && (s = !0)
                                    : ((s = !1),
                                      0 == o
                                          ? (this[this.t++] = h)
                                          : o + r > this.DB
                                          ? ((this[this.t - 1] |= (h & ((1 << (this.DB - o)) - 1)) << o),
                                            (this[this.t++] = h >> (this.DB - o)))
                                          : (this[this.t - 1] |= h << o),
                                      (o += r) >= this.DB && (o -= this.DB));
                            }
                            8 == r &&
                                0 != (128 & +e[0]) &&
                                ((this.s = -1), o > 0 && (this[this.t - 1] |= ((1 << (this.DB - o)) - 1) << o)),
                                this.clamp(),
                                s && t.ZERO.subTo(this, this);
                        }),
                        (t.prototype.clamp = function () {
                            for (var t = this.s & this.DM; this.t > 0 && this[this.t - 1] == t; ) --this.t;
                        }),
                        (t.prototype.dlShiftTo = function (t, e) {
                            var i;
                            for (i = this.t - 1; i >= 0; --i) e[i + t] = this[i];
                            for (i = t - 1; i >= 0; --i) e[i] = 0;
                            (e.t = this.t + t), (e.s = this.s);
                        }),
                        (t.prototype.drShiftTo = function (t, e) {
                            for (var i = t; i < this.t; ++i) e[i - t] = this[i];
                            (e.t = Math.max(this.t - t, 0)), (e.s = this.s);
                        }),
                        (t.prototype.lShiftTo = function (t, e) {
                            for (
                                var i = t % this.DB,
                                    r = this.DB - i,
                                    n = (1 << r) - 1,
                                    s = Math.floor(t / this.DB),
                                    o = (this.s << i) & this.DM,
                                    h = this.t - 1;
                                h >= 0;
                                --h
                            )
                                (e[h + s + 1] = (this[h] >> r) | o), (o = (this[h] & n) << i);
                            for (h = s - 1; h >= 0; --h) e[h] = 0;
                            (e[s] = o), (e.t = this.t + s + 1), (e.s = this.s), e.clamp();
                        }),
                        (t.prototype.rShiftTo = function (t, e) {
                            e.s = this.s;
                            var i = Math.floor(t / this.DB);
                            if (i >= this.t) e.t = 0;
                            else {
                                var r = t % this.DB,
                                    n = this.DB - r,
                                    s = (1 << r) - 1;
                                e[0] = this[i] >> r;
                                for (var o = i + 1; o < this.t; ++o)
                                    (e[o - i - 1] |= (this[o] & s) << n), (e[o - i] = this[o] >> r);
                                r > 0 && (e[this.t - i - 1] |= (this.s & s) << n), (e.t = this.t - i), e.clamp();
                            }
                        }),
                        (t.prototype.subTo = function (t, e) {
                            for (var i = 0, r = 0, n = Math.min(t.t, this.t); i < n; )
                                (r += this[i] - t[i]), (e[i++] = r & this.DM), (r >>= this.DB);
                            if (t.t < this.t) {
                                for (r -= t.s; i < this.t; ) (r += this[i]), (e[i++] = r & this.DM), (r >>= this.DB);
                                r += this.s;
                            } else {
                                for (r += this.s; i < t.t; ) (r -= t[i]), (e[i++] = r & this.DM), (r >>= this.DB);
                                r -= t.s;
                            }
                            (e.s = r < 0 ? -1 : 0),
                                r < -1 ? (e[i++] = this.DV + r) : r > 0 && (e[i++] = r),
                                (e.t = i),
                                e.clamp();
                        }),
                        (t.prototype.multiplyTo = function (e, i) {
                            var r = this.abs(),
                                n = e.abs(),
                                s = r.t;
                            for (i.t = s + n.t; --s >= 0; ) i[s] = 0;
                            for (s = 0; s < n.t; ++s) i[s + r.t] = r.am(0, n[s], i, s, 0, r.t);
                            (i.s = 0), i.clamp(), this.s != e.s && t.ZERO.subTo(i, i);
                        }),
                        (t.prototype.squareTo = function (t) {
                            for (var e = this.abs(), i = (t.t = 2 * e.t); --i >= 0; ) t[i] = 0;
                            for (i = 0; i < e.t - 1; ++i) {
                                var r = e.am(i, e[i], t, 2 * i, 0, 1);
                                (t[i + e.t] += e.am(i + 1, 2 * e[i], t, 2 * i + 1, r, e.t - i - 1)) >= e.DV &&
                                    ((t[i + e.t] -= e.DV), (t[i + e.t + 1] = 1));
                            }
                            t.t > 0 && (t[t.t - 1] += e.am(i, e[i], t, 2 * i, 0, 1)), (t.s = 0), t.clamp();
                        }),
                        (t.prototype.divRemTo = function (e, i, r) {
                            var n = e.abs();
                            if (!(n.t <= 0)) {
                                var s = this.abs();
                                if (s.t < n.t) return null != i && i.fromInt(0), void (null != r && this.copyTo(r));
                                null == r && (r = N());
                                var o = N(),
                                    h = this.s,
                                    a = e.s,
                                    u = this.DB - F(n[n.t - 1]);
                                u > 0 ? (n.lShiftTo(u, o), s.lShiftTo(u, r)) : (n.copyTo(o), s.copyTo(r));
                                var c = o.t,
                                    f = o[c - 1];
                                if (0 != f) {
                                    var l = f * (1 << this.F1) + (c > 1 ? o[c - 2] >> this.F2 : 0),
                                        p = this.FV / l,
                                        g = (1 << this.F1) / l,
                                        d = 1 << this.F2,
                                        v = r.t,
                                        m = v - c,
                                        y = null == i ? N() : i;
                                    for (
                                        o.dlShiftTo(m, y),
                                            r.compareTo(y) >= 0 && ((r[r.t++] = 1), r.subTo(y, r)),
                                            t.ONE.dlShiftTo(c, y),
                                            y.subTo(o, o);
                                        o.t < c;

                                    )
                                        o[o.t++] = 0;
                                    for (; --m >= 0; ) {
                                        var b = r[--v] == f ? this.DM : Math.floor(r[v] * p + (r[v - 1] + d) * g);
                                        if ((r[v] += o.am(0, b, r, m, 0, c)) < b)
                                            for (o.dlShiftTo(m, y), r.subTo(y, r); r[v] < --b; ) r.subTo(y, r);
                                    }
                                    null != i && (r.drShiftTo(c, i), h != a && t.ZERO.subTo(i, i)),
                                        (r.t = c),
                                        r.clamp(),
                                        u > 0 && r.rShiftTo(u, r),
                                        h < 0 && t.ZERO.subTo(r, r);
                                }
                            }
                        }),
                        (t.prototype.invDigit = function () {
                            if (this.t < 1) return 0;
                            var t = this[0];
                            if (0 == (1 & t)) return 0;
                            var e = 3 & t;
                            return (e =
                                ((e =
                                    ((e = ((e = (e * (2 - (15 & t) * e)) & 15) * (2 - (255 & t) * e)) & 255) *
                                        (2 - (((65535 & t) * e) & 65535))) &
                                    65535) *
                                    (2 - ((t * e) % this.DV))) %
                                this.DV) > 0
                                ? this.DV - e
                                : -e;
                        }),
                        (t.prototype.isEven = function () {
                            return 0 == (this.t > 0 ? 1 & this[0] : this.s);
                        }),
                        (t.prototype.exp = function (e, i) {
                            if (e > 4294967295 || e < 1) return t.ONE;
                            var r = N(),
                                n = N(),
                                s = i.convert(this),
                                o = F(e) - 1;
                            for (s.copyTo(r); --o >= 0; )
                                if ((i.sqrTo(r, n), (e & (1 << o)) > 0)) i.mulTo(n, s, r);
                                else {
                                    var h = r;
                                    (r = n), (n = h);
                                }
                            return i.revert(r);
                        }),
                        (t.prototype.chunkSize = function (t) {
                            return Math.floor((Math.LN2 * this.DB) / Math.log(t));
                        }),
                        (t.prototype.toRadix = function (t) {
                            if ((null == t && (t = 10), 0 == this.signum() || t < 2 || t > 36)) return '0';
                            var e = this.chunkSize(t),
                                i = Math.pow(t, e),
                                r = C(i),
                                n = N(),
                                s = N(),
                                o = '';
                            for (this.divRemTo(r, n, s); n.signum() > 0; )
                                (o = (i + s.intValue()).toString(t).substr(1) + o), n.divRemTo(r, n, s);
                            return s.intValue().toString(t) + o;
                        }),
                        (t.prototype.fromRadix = function (e, i) {
                            this.fromInt(0), null == i && (i = 10);
                            for (
                                var r = this.chunkSize(i), n = Math.pow(i, r), s = !1, o = 0, h = 0, a = 0;
                                a < e.length;
                                ++a
                            ) {
                                var u = H(e, a);
                                u < 0
                                    ? '-' == e.charAt(a) && 0 == this.signum() && (s = !0)
                                    : ((h = i * h + u),
                                      ++o >= r && (this.dMultiply(n), this.dAddOffset(h, 0), (o = 0), (h = 0)));
                            }
                            o > 0 && (this.dMultiply(Math.pow(i, o)), this.dAddOffset(h, 0)),
                                s && t.ZERO.subTo(this, this);
                        }),
                        (t.prototype.fromNumber = function (e, i, r) {
                            if ('number' == typeof i)
                                if (e < 2) this.fromInt(1);
                                else
                                    for (
                                        this.fromNumber(e, r),
                                            this.testBit(e - 1) || this.bitwiseTo(t.ONE.shiftLeft(e - 1), s, this),
                                            this.isEven() && this.dAddOffset(1, 0);
                                        !this.isProbablePrime(i);

                                    )
                                        this.dAddOffset(2, 0),
                                            this.bitLength() > e && this.subTo(t.ONE.shiftLeft(e - 1), this);
                            else {
                                var n = [],
                                    o = 7 & e;
                                (n.length = 1 + (e >> 3)),
                                    i.nextBytes(n),
                                    o > 0 ? (n[0] &= (1 << o) - 1) : (n[0] = 0),
                                    this.fromString(n, 256);
                            }
                        }),
                        (t.prototype.bitwiseTo = function (t, e, i) {
                            var r,
                                n,
                                s = Math.min(t.t, this.t);
                            for (r = 0; r < s; ++r) i[r] = e(this[r], t[r]);
                            if (t.t < this.t) {
                                for (n = t.s & this.DM, r = s; r < this.t; ++r) i[r] = e(this[r], n);
                                i.t = this.t;
                            } else {
                                for (n = this.s & this.DM, r = s; r < t.t; ++r) i[r] = e(n, t[r]);
                                i.t = t.t;
                            }
                            (i.s = e(this.s, t.s)), i.clamp();
                        }),
                        (t.prototype.changeBit = function (e, i) {
                            var r = t.ONE.shiftLeft(e);
                            return this.bitwiseTo(r, i, r), r;
                        }),
                        (t.prototype.addTo = function (t, e) {
                            for (var i = 0, r = 0, n = Math.min(t.t, this.t); i < n; )
                                (r += this[i] + t[i]), (e[i++] = r & this.DM), (r >>= this.DB);
                            if (t.t < this.t) {
                                for (r += t.s; i < this.t; ) (r += this[i]), (e[i++] = r & this.DM), (r >>= this.DB);
                                r += this.s;
                            } else {
                                for (r += this.s; i < t.t; ) (r += t[i]), (e[i++] = r & this.DM), (r >>= this.DB);
                                r += t.s;
                            }
                            (e.s = r < 0 ? -1 : 0),
                                r > 0 ? (e[i++] = r) : r < -1 && (e[i++] = this.DV + r),
                                (e.t = i),
                                e.clamp();
                        }),
                        (t.prototype.dMultiply = function (t) {
                            (this[this.t] = this.am(0, t - 1, this, 0, 0, this.t)), ++this.t, this.clamp();
                        }),
                        (t.prototype.dAddOffset = function (t, e) {
                            if (0 != t) {
                                for (; this.t <= e; ) this[this.t++] = 0;
                                for (this[e] += t; this[e] >= this.DV; )
                                    (this[e] -= this.DV), ++e >= this.t && (this[this.t++] = 0), ++this[e];
                            }
                        }),
                        (t.prototype.multiplyLowerTo = function (t, e, i) {
                            var r = Math.min(this.t + t.t, e);
                            for (i.s = 0, i.t = r; r > 0; ) i[--r] = 0;
                            for (var n = i.t - this.t; r < n; ++r) i[r + this.t] = this.am(0, t[r], i, r, 0, this.t);
                            for (n = Math.min(t.t, e); r < n; ++r) this.am(0, t[r], i, r, 0, e - r);
                            i.clamp();
                        }),
                        (t.prototype.multiplyUpperTo = function (t, e, i) {
                            --e;
                            var r = (i.t = this.t + t.t - e);
                            for (i.s = 0; --r >= 0; ) i[r] = 0;
                            for (r = Math.max(e - this.t, 0); r < t.t; ++r)
                                i[this.t + r - e] = this.am(e - r, t[r], i, 0, 0, this.t + r - e);
                            i.clamp(), i.drShiftTo(1, i);
                        }),
                        (t.prototype.modInt = function (t) {
                            if (t <= 0) return 0;
                            var e = this.DV % t,
                                i = this.s < 0 ? t - 1 : 0;
                            if (this.t > 0)
                                if (0 == e) i = this[0] % t;
                                else for (var r = this.t - 1; r >= 0; --r) i = (e * i + this[r]) % t;
                            return i;
                        }),
                        (t.prototype.millerRabin = function (e) {
                            var i = this.subtract(t.ONE),
                                r = i.getLowestSetBit();
                            if (r <= 0) return !1;
                            var n = i.shiftRight(r);
                            (e = (e + 1) >> 1) > x.length && (e = x.length);
                            for (var s = N(), o = 0; o < e; ++o) {
                                s.fromInt(x[Math.floor(Math.random() * x.length)]);
                                var h = s.modPow(n, this);
                                if (0 != h.compareTo(t.ONE) && 0 != h.compareTo(i)) {
                                    for (var a = 1; a++ < r && 0 != h.compareTo(i); )
                                        if (0 == (h = h.modPowInt(2, this)).compareTo(t.ONE)) return !1;
                                    if (0 != h.compareTo(i)) return !1;
                                }
                            }
                            return !0;
                        }),
                        (t.prototype.square = function () {
                            var t = N();
                            return this.squareTo(t), t;
                        }),
                        (t.prototype.gcda = function (t, e) {
                            var i = this.s < 0 ? this.negate() : this.clone(),
                                r = t.s < 0 ? t.negate() : t.clone();
                            if (i.compareTo(r) < 0) {
                                var n = i;
                                (i = r), (r = n);
                            }
                            var s = i.getLowestSetBit(),
                                o = r.getLowestSetBit();
                            if (o < 0) e(i);
                            else {
                                s < o && (o = s), o > 0 && (i.rShiftTo(o, i), r.rShiftTo(o, r));
                                var h = function () {
                                    (s = i.getLowestSetBit()) > 0 && i.rShiftTo(s, i),
                                        (s = r.getLowestSetBit()) > 0 && r.rShiftTo(s, r),
                                        i.compareTo(r) >= 0
                                            ? (i.subTo(r, i), i.rShiftTo(1, i))
                                            : (r.subTo(i, r), r.rShiftTo(1, r)),
                                        i.signum() > 0
                                            ? setTimeout(h, 0)
                                            : (o > 0 && r.lShiftTo(o, r),
                                              setTimeout(function () {
                                                  e(r);
                                              }, 0));
                                };
                                setTimeout(h, 10);
                            }
                        }),
                        (t.prototype.fromNumberAsync = function (e, i, r, n) {
                            if ('number' == typeof i)
                                if (e < 2) this.fromInt(1);
                                else {
                                    this.fromNumber(e, r),
                                        this.testBit(e - 1) || this.bitwiseTo(t.ONE.shiftLeft(e - 1), s, this),
                                        this.isEven() && this.dAddOffset(1, 0);
                                    var o = this,
                                        h = function () {
                                            o.dAddOffset(2, 0),
                                                o.bitLength() > e && o.subTo(t.ONE.shiftLeft(e - 1), o),
                                                o.isProbablePrime(i)
                                                    ? setTimeout(function () {
                                                          n();
                                                      }, 0)
                                                    : setTimeout(h, 0);
                                        };
                                    setTimeout(h, 0);
                                }
                            else {
                                var a = [],
                                    u = 7 & e;
                                (a.length = 1 + (e >> 3)),
                                    i.nextBytes(a),
                                    u > 0 ? (a[0] &= (1 << u) - 1) : (a[0] = 0),
                                    this.fromString(a, 256);
                            }
                        }),
                        t
                    );
                })(),
                O = (function () {
                    function t() {}
                    return (
                        (t.prototype.convert = function (t) {
                            return t;
                        }),
                        (t.prototype.revert = function (t) {
                            return t;
                        }),
                        (t.prototype.mulTo = function (t, e, i) {
                            t.multiplyTo(e, i);
                        }),
                        (t.prototype.sqrTo = function (t, e) {
                            t.squareTo(e);
                        }),
                        t
                    );
                })(),
                A = (function () {
                    function t(t) {
                        this.m = t;
                    }
                    return (
                        (t.prototype.convert = function (t) {
                            return t.s < 0 || t.compareTo(this.m) >= 0 ? t.mod(this.m) : t;
                        }),
                        (t.prototype.revert = function (t) {
                            return t;
                        }),
                        (t.prototype.reduce = function (t) {
                            t.divRemTo(this.m, null, t);
                        }),
                        (t.prototype.mulTo = function (t, e, i) {
                            t.multiplyTo(e, i), this.reduce(i);
                        }),
                        (t.prototype.sqrTo = function (t, e) {
                            t.squareTo(e), this.reduce(e);
                        }),
                        t
                    );
                })(),
                V = (function () {
                    function t(t) {
                        (this.m = t),
                            (this.mp = t.invDigit()),
                            (this.mpl = 32767 & this.mp),
                            (this.mph = this.mp >> 15),
                            (this.um = (1 << (t.DB - 15)) - 1),
                            (this.mt2 = 2 * t.t);
                    }
                    return (
                        (t.prototype.convert = function (t) {
                            var e = N();
                            return (
                                t.abs().dlShiftTo(this.m.t, e),
                                e.divRemTo(this.m, null, e),
                                t.s < 0 && e.compareTo(B.ZERO) > 0 && this.m.subTo(e, e),
                                e
                            );
                        }),
                        (t.prototype.revert = function (t) {
                            var e = N();
                            return t.copyTo(e), this.reduce(e), e;
                        }),
                        (t.prototype.reduce = function (t) {
                            for (; t.t <= this.mt2; ) t[t.t++] = 0;
                            for (var e = 0; e < this.m.t; ++e) {
                                var i = 32767 & t[e],
                                    r =
                                        (i * this.mpl + (((i * this.mph + (t[e] >> 15) * this.mpl) & this.um) << 15)) &
                                        t.DM;
                                for (t[(i = e + this.m.t)] += this.m.am(0, r, t, e, 0, this.m.t); t[i] >= t.DV; )
                                    (t[i] -= t.DV), t[++i]++;
                            }
                            t.clamp(), t.drShiftTo(this.m.t, t), t.compareTo(this.m) >= 0 && t.subTo(this.m, t);
                        }),
                        (t.prototype.mulTo = function (t, e, i) {
                            t.multiplyTo(e, i), this.reduce(i);
                        }),
                        (t.prototype.sqrTo = function (t, e) {
                            t.squareTo(e), this.reduce(e);
                        }),
                        t
                    );
                })(),
                I = (function () {
                    function t(t) {
                        (this.m = t),
                            (this.r2 = N()),
                            (this.q3 = N()),
                            B.ONE.dlShiftTo(2 * t.t, this.r2),
                            (this.mu = this.r2.divide(t));
                    }
                    return (
                        (t.prototype.convert = function (t) {
                            if (t.s < 0 || t.t > 2 * this.m.t) return t.mod(this.m);
                            if (t.compareTo(this.m) < 0) return t;
                            var e = N();
                            return t.copyTo(e), this.reduce(e), e;
                        }),
                        (t.prototype.revert = function (t) {
                            return t;
                        }),
                        (t.prototype.reduce = function (t) {
                            for (
                                t.drShiftTo(this.m.t - 1, this.r2),
                                    t.t > this.m.t + 1 && ((t.t = this.m.t + 1), t.clamp()),
                                    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3),
                                    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
                                t.compareTo(this.r2) < 0;

                            )
                                t.dAddOffset(1, this.m.t + 1);
                            for (t.subTo(this.r2, t); t.compareTo(this.m) >= 0; ) t.subTo(this.m, t);
                        }),
                        (t.prototype.mulTo = function (t, e, i) {
                            t.multiplyTo(e, i), this.reduce(i);
                        }),
                        (t.prototype.sqrTo = function (t, e) {
                            t.squareTo(e), this.reduce(e);
                        }),
                        t
                    );
                })();
            function N() {
                return new B(null);
            }
            function P(t, e) {
                return new B(t, e);
            }
            var M = 'undefined' != typeof navigator;
            M && 'Microsoft Internet Explorer' == navigator.appName
                ? ((B.prototype.am = function (t, e, i, r, n, s) {
                      for (var o = 32767 & e, h = e >> 15; --s >= 0; ) {
                          var a = 32767 & this[t],
                              u = this[t++] >> 15,
                              c = h * a + u * o;
                          (n =
                              ((a = o * a + ((32767 & c) << 15) + i[r] + (1073741823 & n)) >>> 30) +
                              (c >>> 15) +
                              h * u +
                              (n >>> 30)),
                              (i[r++] = 1073741823 & a);
                      }
                      return n;
                  }),
                  (S = 30))
                : M && 'Netscape' != navigator.appName
                ? ((B.prototype.am = function (t, e, i, r, n, s) {
                      for (; --s >= 0; ) {
                          var o = e * this[t++] + i[r] + n;
                          (n = Math.floor(o / 67108864)), (i[r++] = 67108863 & o);
                      }
                      return n;
                  }),
                  (S = 26))
                : ((B.prototype.am = function (t, e, i, r, n, s) {
                      for (var o = 16383 & e, h = e >> 14; --s >= 0; ) {
                          var a = 16383 & this[t],
                              u = this[t++] >> 14,
                              c = h * a + u * o;
                          (n = ((a = o * a + ((16383 & c) << 14) + i[r] + n) >> 28) + (c >> 14) + h * u),
                              (i[r++] = 268435455 & a);
                      }
                      return n;
                  }),
                  (S = 28)),
                (B.prototype.DB = S),
                (B.prototype.DM = (1 << S) - 1),
                (B.prototype.DV = 1 << S),
                (B.prototype.FV = Math.pow(2, 52)),
                (B.prototype.F1 = 52 - S),
                (B.prototype.F2 = 2 * S - 52);
            var j,
                q,
                L = [];
            for (j = '0'.charCodeAt(0), q = 0; q <= 9; ++q) L[j++] = q;
            for (j = 'a'.charCodeAt(0), q = 10; q < 36; ++q) L[j++] = q;
            for (j = 'A'.charCodeAt(0), q = 10; q < 36; ++q) L[j++] = q;
            function H(t, e) {
                var i = L[t.charCodeAt(e)];
                return null == i ? -1 : i;
            }
            function C(t) {
                var e = N();
                return e.fromInt(t), e;
            }
            function F(t) {
                var e,
                    i = 1;
                return (
                    0 != (e = t >>> 16) && ((t = e), (i += 16)),
                    0 != (e = t >> 8) && ((t = e), (i += 8)),
                    0 != (e = t >> 4) && ((t = e), (i += 4)),
                    0 != (e = t >> 2) && ((t = e), (i += 2)),
                    0 != (e = t >> 1) && ((t = e), (i += 1)),
                    i
                );
            }
            (B.ZERO = C(0)), (B.ONE = C(1));
            var U,
                K,
                k = (function () {
                    function t() {
                        (this.i = 0), (this.j = 0), (this.S = []);
                    }
                    return (
                        (t.prototype.init = function (t) {
                            var e, i, r;
                            for (e = 0; e < 256; ++e) this.S[e] = e;
                            for (i = 0, e = 0; e < 256; ++e)
                                (i = (i + this.S[e] + t[e % t.length]) & 255),
                                    (r = this.S[e]),
                                    (this.S[e] = this.S[i]),
                                    (this.S[i] = r);
                            (this.i = 0), (this.j = 0);
                        }),
                        (t.prototype.next = function () {
                            var t;
                            return (
                                (this.i = (this.i + 1) & 255),
                                (this.j = (this.j + this.S[this.i]) & 255),
                                (t = this.S[this.i]),
                                (this.S[this.i] = this.S[this.j]),
                                (this.S[this.j] = t),
                                this.S[(t + this.S[this.i]) & 255]
                            );
                        }),
                        t
                    );
                })(),
                _ = null;
            if (null == _) {
                (_ = []), (K = 0);
                var z = void 0;
                if ('undefined' != typeof window && window.crypto && window.crypto.getRandomValues) {
                    var Z = new Uint32Array(256);
                    for (window.crypto.getRandomValues(Z), z = 0; z < Z.length; ++z) _[K++] = 255 & Z[z];
                }
            }
            function Y() {
                if (null == U) {
                    for (U = new k(); K < 256; ) {
                        var t = Math.floor(65536 * Math.random());
                        _[K++] = 255 & t;
                    }
                    for (U.init(_), K = 0; K < _.length; ++K) _[K] = 0;
                    K = 0;
                }
                return U.next();
            }
            var J = (function () {
                    function t() {}
                    return (
                        (t.prototype.nextBytes = function (t) {
                            for (var e = 0; e < t.length; ++e) t[e] = Y();
                        }),
                        t
                    );
                })(),
                X = (function () {
                    function t() {
                        (this.n = null),
                            (this.e = 0),
                            (this.d = null),
                            (this.p = null),
                            (this.q = null),
                            (this.dmp1 = null),
                            (this.dmq1 = null),
                            (this.coeff = null);
                    }
                    return (
                        (t.prototype.doPublic = function (t) {
                            return t.modPowInt(this.e, this.n);
                        }),
                        (t.prototype.doPrivate = function (t) {
                            if (null == this.p || null == this.q) return t.modPow(this.d, this.n);
                            for (
                                var e = t.mod(this.p).modPow(this.dmp1, this.p),
                                    i = t.mod(this.q).modPow(this.dmq1, this.q);
                                e.compareTo(i) < 0;

                            )
                                e = e.add(this.p);
                            return e.subtract(i).multiply(this.coeff).mod(this.p).multiply(this.q).add(i);
                        }),
                        (t.prototype.setPublic = function (t, e) {
                            null != t && null != e && t.length > 0 && e.length > 0
                                ? ((this.n = P(t, 16)), (this.e = parseInt(e, 16)))
                                : console.error('Invalid RSA public key');
                        }),
                        (t.prototype.encrypt = function (t) {
                            var e = (this.n.bitLength() + 7) >> 3,
                                i = (function (t, e) {
                                    if (e < t.length + 11) return console.error('Message too long for RSA'), null;
                                    for (var i = [], r = t.length - 1; r >= 0 && e > 0; ) {
                                        var n = t.charCodeAt(r--);
                                        n < 128
                                            ? (i[--e] = n)
                                            : n > 127 && n < 2048
                                            ? ((i[--e] = (63 & n) | 128), (i[--e] = (n >> 6) | 192))
                                            : ((i[--e] = (63 & n) | 128),
                                              (i[--e] = ((n >> 6) & 63) | 128),
                                              (i[--e] = (n >> 12) | 224));
                                    }
                                    i[--e] = 0;
                                    for (var s = new J(), o = []; e > 2; ) {
                                        for (o[0] = 0; 0 == o[0]; ) s.nextBytes(o);
                                        i[--e] = o[0];
                                    }
                                    return (i[--e] = 2), (i[--e] = 0), new B(i);
                                })(t, e);
                            if (null == i) return null;
                            var r = this.doPublic(i);
                            if (null == r) return null;
                            for (var n = r.toString(16), s = n.length, o = 0; o < 2 * e - s; o++) n = '0' + n;
                            return n;
                        }),
                        (t.prototype.setPrivate = function (t, e, i) {
                            null != t && null != e && t.length > 0 && e.length > 0
                                ? ((this.n = P(t, 16)), (this.e = parseInt(e, 16)), (this.d = P(i, 16)))
                                : console.error('Invalid RSA private key');
                        }),
                        (t.prototype.setPrivateEx = function (t, e, i, r, n, s, o, h) {
                            null != t && null != e && t.length > 0 && e.length > 0
                                ? ((this.n = P(t, 16)),
                                  (this.e = parseInt(e, 16)),
                                  (this.d = P(i, 16)),
                                  (this.p = P(r, 16)),
                                  (this.q = P(n, 16)),
                                  (this.dmp1 = P(s, 16)),
                                  (this.dmq1 = P(o, 16)),
                                  (this.coeff = P(h, 16)))
                                : console.error('Invalid RSA private key');
                        }),
                        (t.prototype.generate = function (t, e) {
                            var i = new J(),
                                r = t >> 1;
                            this.e = parseInt(e, 16);
                            for (var n = new B(e, 16); ; ) {
                                for (
                                    ;
                                    (this.p = new B(t - r, 1, i)),
                                        0 != this.p.subtract(B.ONE).gcd(n).compareTo(B.ONE) ||
                                            !this.p.isProbablePrime(10);

                                );
                                for (
                                    ;
                                    (this.q = new B(r, 1, i)),
                                        0 != this.q.subtract(B.ONE).gcd(n).compareTo(B.ONE) ||
                                            !this.q.isProbablePrime(10);

                                );
                                if (this.p.compareTo(this.q) <= 0) {
                                    var s = this.p;
                                    (this.p = this.q), (this.q = s);
                                }
                                var o = this.p.subtract(B.ONE),
                                    h = this.q.subtract(B.ONE),
                                    a = o.multiply(h);
                                if (0 == a.gcd(n).compareTo(B.ONE)) {
                                    (this.n = this.p.multiply(this.q)),
                                        (this.d = n.modInverse(a)),
                                        (this.dmp1 = this.d.mod(o)),
                                        (this.dmq1 = this.d.mod(h)),
                                        (this.coeff = this.q.modInverse(this.p));
                                    break;
                                }
                            }
                        }),
                        (t.prototype.decrypt = function (t) {
                            var e = P(t, 16),
                                i = this.doPrivate(e);
                            return null == i
                                ? null
                                : (function (t, e) {
                                      for (var i = t.toByteArray(), r = 0; r < i.length && 0 == i[r]; ) ++r;
                                      if (i.length - r != e - 1 || 2 != i[r]) return null;
                                      for (++r; 0 != i[r]; ) if (++r >= i.length) return null;
                                      for (var n = ''; ++r < i.length; ) {
                                          var s = 255 & i[r];
                                          s < 128
                                              ? (n += String.fromCharCode(s))
                                              : s > 191 && s < 224
                                              ? ((n += String.fromCharCode(((31 & s) << 6) | (63 & i[r + 1]))), ++r)
                                              : ((n += String.fromCharCode(
                                                    ((15 & s) << 12) | ((63 & i[r + 1]) << 6) | (63 & i[r + 2]),
                                                )),
                                                (r += 2));
                                      }
                                      return n;
                                  })(i, (this.n.bitLength() + 7) >> 3);
                        }),
                        (t.prototype.generateAsync = function (t, e, i) {
                            var r = new J(),
                                n = t >> 1;
                            this.e = parseInt(e, 16);
                            var s = new B(e, 16),
                                o = this,
                                h = function () {
                                    var e = function () {
                                            if (o.p.compareTo(o.q) <= 0) {
                                                var t = o.p;
                                                (o.p = o.q), (o.q = t);
                                            }
                                            var e = o.p.subtract(B.ONE),
                                                r = o.q.subtract(B.ONE),
                                                n = e.multiply(r);
                                            0 == n.gcd(s).compareTo(B.ONE)
                                                ? ((o.n = o.p.multiply(o.q)),
                                                  (o.d = s.modInverse(n)),
                                                  (o.dmp1 = o.d.mod(e)),
                                                  (o.dmq1 = o.d.mod(r)),
                                                  (o.coeff = o.q.modInverse(o.p)),
                                                  setTimeout(function () {
                                                      i();
                                                  }, 0))
                                                : setTimeout(h, 0);
                                        },
                                        a = function () {
                                            (o.q = N()),
                                                o.q.fromNumberAsync(n, 1, r, function () {
                                                    o.q.subtract(B.ONE).gcda(s, function (t) {
                                                        0 == t.compareTo(B.ONE) && o.q.isProbablePrime(10)
                                                            ? setTimeout(e, 0)
                                                            : setTimeout(a, 0);
                                                    });
                                                });
                                        },
                                        u = function () {
                                            (o.p = N()),
                                                o.p.fromNumberAsync(t - n, 1, r, function () {
                                                    o.p.subtract(B.ONE).gcda(s, function (t) {
                                                        0 == t.compareTo(B.ONE) && o.p.isProbablePrime(10)
                                                            ? setTimeout(a, 0)
                                                            : setTimeout(u, 0);
                                                    });
                                                });
                                        };
                                    setTimeout(u, 0);
                                };
                            setTimeout(h, 0);
                        }),
                        (t.prototype.sign = function (t, e, i) {
                            var r = (function (t, e) {
                                if (e < t.length + 22) return console.error('Message too long for RSA'), null;
                                for (var i = e - t.length - 6, r = '', n = 0; n < i; n += 2) r += 'ff';
                                return P('0001' + r + '00' + t, 16);
                            })((Q[i] || '') + e(t).toString(), this.n.bitLength() / 4);
                            if (null == r) return null;
                            var n = this.doPrivate(r);
                            if (null == n) return null;
                            var s = n.toString(16);
                            return 0 == (1 & s.length) ? s : '0' + s;
                        }),
                        (t.prototype.verify = function (t, e, i) {
                            var r = P(e, 16),
                                n = this.doPublic(r);
                            return null == n
                                ? null
                                : (function (t) {
                                      for (var e in Q)
                                          if (Q.hasOwnProperty(e)) {
                                              var i = Q[e],
                                                  r = i.length;
                                              if (t.substr(0, r) == i) return t.substr(r);
                                          }
                                      return t;
                                  })(n.toString(16).replace(/^1f+00/, '')) == i(t).toString();
                        }),
                        t
                    );
                })(),
                Q = {
                    md2: '3020300c06082a864886f70d020205000410',
                    md5: '3020300c06082a864886f70d020505000410',
                    sha1: '3021300906052b0e03021a05000414',
                    sha224: '302d300d06096086480165030402040500041c',
                    sha256: '3031300d060960864801650304020105000420',
                    sha384: '3041300d060960864801650304020205000430',
                    sha512: '3051300d060960864801650304020305000440',
                    ripemd160: '3021300906052b2403020105000414',
                },
                W = {};
            W.lang = {
                extend: function (t, e, i) {
                    if (!e || !t)
                        throw new Error('YAHOO.lang.extend failed, please check that all dependencies are included.');
                    var r = function () {};
                    if (
                        ((r.prototype = e.prototype),
                        (t.prototype = new r()),
                        (t.prototype.constructor = t),
                        (t.superclass = e.prototype),
                        e.prototype.constructor == Object.prototype.constructor && (e.prototype.constructor = e),
                        i)
                    ) {
                        var n;
                        for (n in i) t.prototype[n] = i[n];
                        var s = function () {},
                            o = ['toString', 'valueOf'];
                        try {
                            'undefined' != typeof navigator &&
                                /MSIE/.test(navigator.userAgent) &&
                                (s = function (t, e) {
                                    for (n = 0; n < o.length; n += 1) {
                                        var i = o[n],
                                            r = e[i];
                                        'function' == typeof r && r != Object.prototype[i] && (t[i] = r);
                                    }
                                });
                        } catch (t) {}
                        s(t.prototype, i);
                    }
                },
            };
            var tt = {};
            (void 0 !== tt.asn1 && tt.asn1) || (tt.asn1 = {}),
                (tt.asn1.ASN1Util = new (function () {
                    (this.integerToByteHex = function (t) {
                        var e = t.toString(16);
                        return e.length % 2 == 1 && (e = '0' + e), e;
                    }),
                        (this.bigIntToMinTwosComplementsHex = function (t) {
                            var e = t.toString(16);
                            if ('-' != e.substr(0, 1))
                                e.length % 2 == 1 ? (e = '0' + e) : e.match(/^[0-7]/) || (e = '00' + e);
                            else {
                                var i = e.substr(1).length;
                                i % 2 == 1 ? (i += 1) : e.match(/^[0-7]/) || (i += 2);
                                for (var r = '', n = 0; n < i; n++) r += 'f';
                                e = new B(r, 16).xor(t).add(B.ONE).toString(16).replace(/^-/, '');
                            }
                            return e;
                        }),
                        (this.getPEMStringFromHex = function (t, e) {
                            return hextopem(t, e);
                        }),
                        (this.newObject = function (t) {
                            var e = tt.asn1,
                                i = e.DERBoolean,
                                r = e.DERInteger,
                                n = e.DERBitString,
                                s = e.DEROctetString,
                                o = e.DERNull,
                                h = e.DERObjectIdentifier,
                                a = e.DEREnumerated,
                                u = e.DERUTF8String,
                                c = e.DERNumericString,
                                f = e.DERPrintableString,
                                l = e.DERTeletexString,
                                p = e.DERIA5String,
                                g = e.DERUTCTime,
                                d = e.DERGeneralizedTime,
                                v = e.DERSequence,
                                m = e.DERSet,
                                y = e.DERTaggedObject,
                                b = e.ASN1Util.newObject,
                                T = Object.keys(t);
                            if (1 != T.length) throw 'key of param shall be only one.';
                            var S = T[0];
                            if (
                                -1 ==
                                ':bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:'.indexOf(
                                    ':' + S + ':',
                                )
                            )
                                throw 'undefined key: ' + S;
                            if ('bool' == S) return new i(t[S]);
                            if ('int' == S) return new r(t[S]);
                            if ('bitstr' == S) return new n(t[S]);
                            if ('octstr' == S) return new s(t[S]);
                            if ('null' == S) return new o(t[S]);
                            if ('oid' == S) return new h(t[S]);
                            if ('enum' == S) return new a(t[S]);
                            if ('utf8str' == S) return new u(t[S]);
                            if ('numstr' == S) return new c(t[S]);
                            if ('prnstr' == S) return new f(t[S]);
                            if ('telstr' == S) return new l(t[S]);
                            if ('ia5str' == S) return new p(t[S]);
                            if ('utctime' == S) return new g(t[S]);
                            if ('gentime' == S) return new d(t[S]);
                            if ('seq' == S) {
                                for (var E = t[S], w = [], D = 0; D < E.length; D++) {
                                    var x = b(E[D]);
                                    w.push(x);
                                }
                                return new v({ array: w });
                            }
                            if ('set' == S) {
                                for (E = t[S], w = [], D = 0; D < E.length; D++) (x = b(E[D])), w.push(x);
                                return new m({ array: w });
                            }
                            if ('tag' == S) {
                                var R = t[S];
                                if ('[object Array]' === Object.prototype.toString.call(R) && 3 == R.length) {
                                    var B = b(R[2]);
                                    return new y({ tag: R[0], explicit: R[1], obj: B });
                                }
                                var O = {};
                                if (
                                    (void 0 !== R.explicit && (O.explicit = R.explicit),
                                    void 0 !== R.tag && (O.tag = R.tag),
                                    void 0 === R.obj)
                                )
                                    throw "obj shall be specified for 'tag'.";
                                return (O.obj = b(R.obj)), new y(O);
                            }
                        }),
                        (this.jsonToASN1HEX = function (t) {
                            return this.newObject(t).getEncodedHex();
                        });
                })()),
                (tt.asn1.ASN1Util.oidHexToInt = function (t) {
                    for (
                        var e = '',
                            i = parseInt(t.substr(0, 2), 16),
                            r = ((e = Math.floor(i / 40) + '.' + (i % 40)), ''),
                            n = 2;
                        n < t.length;
                        n += 2
                    ) {
                        var s = ('00000000' + parseInt(t.substr(n, 2), 16).toString(2)).slice(-8);
                        (r += s.substr(1, 7)),
                            '0' == s.substr(0, 1) && ((e = e + '.' + new B(r, 2).toString(10)), (r = ''));
                    }
                    return e;
                }),
                (tt.asn1.ASN1Util.oidIntToHex = function (t) {
                    var e = function (t) {
                            var e = t.toString(16);
                            return 1 == e.length && (e = '0' + e), e;
                        },
                        i = function (t) {
                            var i = '',
                                r = new B(t, 10).toString(2),
                                n = 7 - (r.length % 7);
                            7 == n && (n = 0);
                            for (var s = '', o = 0; o < n; o++) s += '0';
                            for (r = s + r, o = 0; o < r.length - 1; o += 7) {
                                var h = r.substr(o, 7);
                                o != r.length - 7 && (h = '1' + h), (i += e(parseInt(h, 2)));
                            }
                            return i;
                        };
                    if (!t.match(/^[0-9.]+$/)) throw 'malformed oid string: ' + t;
                    var r = '',
                        n = t.split('.'),
                        s = 40 * parseInt(n[0]) + parseInt(n[1]);
                    (r += e(s)), n.splice(0, 2);
                    for (var o = 0; o < n.length; o++) r += i(n[o]);
                    return r;
                }),
                (tt.asn1.ASN1Object = function () {
                    (this.getLengthHexFromValue = function () {
                        if (void 0 === this.hV || null == this.hV) throw 'this.hV is null or undefined.';
                        if (this.hV.length % 2 == 1)
                            throw 'value hex must be even length: n=' + ''.length + ',v=' + this.hV;
                        var t = this.hV.length / 2,
                            e = t.toString(16);
                        if ((e.length % 2 == 1 && (e = '0' + e), t < 128)) return e;
                        var i = e.length / 2;
                        if (i > 15) throw 'ASN.1 length too long to represent by 8x: n = ' + t.toString(16);
                        return (128 + i).toString(16) + e;
                    }),
                        (this.getEncodedHex = function () {
                            return (
                                (null == this.hTLV || this.isModified) &&
                                    ((this.hV = this.getFreshValueHex()),
                                    (this.hL = this.getLengthHexFromValue()),
                                    (this.hTLV = this.hT + this.hL + this.hV),
                                    (this.isModified = !1)),
                                this.hTLV
                            );
                        }),
                        (this.getValueHex = function () {
                            return this.getEncodedHex(), this.hV;
                        }),
                        (this.getFreshValueHex = function () {
                            return '';
                        });
                }),
                (tt.asn1.DERAbstractString = function (t) {
                    tt.asn1.DERAbstractString.superclass.constructor.call(this),
                        (this.getString = function () {
                            return this.s;
                        }),
                        (this.setString = function (t) {
                            (this.hTLV = null), (this.isModified = !0), (this.s = t), (this.hV = stohex(this.s));
                        }),
                        (this.setStringHex = function (t) {
                            (this.hTLV = null), (this.isModified = !0), (this.s = null), (this.hV = t);
                        }),
                        (this.getFreshValueHex = function () {
                            return this.hV;
                        }),
                        void 0 !== t &&
                            ('string' == typeof t
                                ? this.setString(t)
                                : void 0 !== t.str
                                ? this.setString(t.str)
                                : void 0 !== t.hex && this.setStringHex(t.hex));
                }),
                W.lang.extend(tt.asn1.DERAbstractString, tt.asn1.ASN1Object),
                (tt.asn1.DERAbstractTime = function (t) {
                    tt.asn1.DERAbstractTime.superclass.constructor.call(this),
                        (this.localDateToUTC = function (t) {
                            return (utc = t.getTime() + 6e4 * t.getTimezoneOffset()), new Date(utc);
                        }),
                        (this.formatDate = function (t, e, i) {
                            var r = this.zeroPadding,
                                n = this.localDateToUTC(t),
                                s = String(n.getFullYear());
                            'utc' == e && (s = s.substr(2, 2));
                            var o =
                                s +
                                r(String(n.getMonth() + 1), 2) +
                                r(String(n.getDate()), 2) +
                                r(String(n.getHours()), 2) +
                                r(String(n.getMinutes()), 2) +
                                r(String(n.getSeconds()), 2);
                            if (!0 === i) {
                                var h = n.getMilliseconds();
                                if (0 != h) {
                                    var a = r(String(h), 3);
                                    o = o + '.' + (a = a.replace(/[0]+$/, ''));
                                }
                            }
                            return o + 'Z';
                        }),
                        (this.zeroPadding = function (t, e) {
                            return t.length >= e ? t : new Array(e - t.length + 1).join('0') + t;
                        }),
                        (this.getString = function () {
                            return this.s;
                        }),
                        (this.setString = function (t) {
                            (this.hTLV = null), (this.isModified = !0), (this.s = t), (this.hV = stohex(t));
                        }),
                        (this.setByDateValue = function (t, e, i, r, n, s) {
                            var o = new Date(Date.UTC(t, e - 1, i, r, n, s, 0));
                            this.setByDate(o);
                        }),
                        (this.getFreshValueHex = function () {
                            return this.hV;
                        });
                }),
                W.lang.extend(tt.asn1.DERAbstractTime, tt.asn1.ASN1Object),
                (tt.asn1.DERAbstractStructured = function (t) {
                    tt.asn1.DERAbstractString.superclass.constructor.call(this),
                        (this.setByASN1ObjectArray = function (t) {
                            (this.hTLV = null), (this.isModified = !0), (this.asn1Array = t);
                        }),
                        (this.appendASN1Object = function (t) {
                            (this.hTLV = null), (this.isModified = !0), this.asn1Array.push(t);
                        }),
                        (this.asn1Array = new Array()),
                        void 0 !== t && void 0 !== t.array && (this.asn1Array = t.array);
                }),
                W.lang.extend(tt.asn1.DERAbstractStructured, tt.asn1.ASN1Object),
                (tt.asn1.DERBoolean = function () {
                    tt.asn1.DERBoolean.superclass.constructor.call(this), (this.hT = '01'), (this.hTLV = '0101ff');
                }),
                W.lang.extend(tt.asn1.DERBoolean, tt.asn1.ASN1Object),
                (tt.asn1.DERInteger = function (t) {
                    tt.asn1.DERInteger.superclass.constructor.call(this),
                        (this.hT = '02'),
                        (this.setByBigInteger = function (t) {
                            (this.hTLV = null),
                                (this.isModified = !0),
                                (this.hV = tt.asn1.ASN1Util.bigIntToMinTwosComplementsHex(t));
                        }),
                        (this.setByInteger = function (t) {
                            var e = new B(String(t), 10);
                            this.setByBigInteger(e);
                        }),
                        (this.setValueHex = function (t) {
                            this.hV = t;
                        }),
                        (this.getFreshValueHex = function () {
                            return this.hV;
                        }),
                        void 0 !== t &&
                            (void 0 !== t.bigint
                                ? this.setByBigInteger(t.bigint)
                                : void 0 !== t.int
                                ? this.setByInteger(t.int)
                                : 'number' == typeof t
                                ? this.setByInteger(t)
                                : void 0 !== t.hex && this.setValueHex(t.hex));
                }),
                W.lang.extend(tt.asn1.DERInteger, tt.asn1.ASN1Object),
                (tt.asn1.DERBitString = function (t) {
                    if (void 0 !== t && void 0 !== t.obj) {
                        var e = tt.asn1.ASN1Util.newObject(t.obj);
                        t.hex = '00' + e.getEncodedHex();
                    }
                    tt.asn1.DERBitString.superclass.constructor.call(this),
                        (this.hT = '03'),
                        (this.setHexValueIncludingUnusedBits = function (t) {
                            (this.hTLV = null), (this.isModified = !0), (this.hV = t);
                        }),
                        (this.setUnusedBitsAndHexValue = function (t, e) {
                            if (t < 0 || 7 < t) throw 'unused bits shall be from 0 to 7: u = ' + t;
                            var i = '0' + t;
                            (this.hTLV = null), (this.isModified = !0), (this.hV = i + e);
                        }),
                        (this.setByBinaryString = function (t) {
                            var e = 8 - ((t = t.replace(/0+$/, '')).length % 8);
                            8 == e && (e = 0);
                            for (var i = 0; i <= e; i++) t += '0';
                            var r = '';
                            for (i = 0; i < t.length - 1; i += 8) {
                                var n = t.substr(i, 8),
                                    s = parseInt(n, 2).toString(16);
                                1 == s.length && (s = '0' + s), (r += s);
                            }
                            (this.hTLV = null), (this.isModified = !0), (this.hV = '0' + e + r);
                        }),
                        (this.setByBooleanArray = function (t) {
                            for (var e = '', i = 0; i < t.length; i++) 1 == t[i] ? (e += '1') : (e += '0');
                            this.setByBinaryString(e);
                        }),
                        (this.newFalseArray = function (t) {
                            for (var e = new Array(t), i = 0; i < t; i++) e[i] = !1;
                            return e;
                        }),
                        (this.getFreshValueHex = function () {
                            return this.hV;
                        }),
                        void 0 !== t &&
                            ('string' == typeof t && t.toLowerCase().match(/^[0-9a-f]+$/)
                                ? this.setHexValueIncludingUnusedBits(t)
                                : void 0 !== t.hex
                                ? this.setHexValueIncludingUnusedBits(t.hex)
                                : void 0 !== t.bin
                                ? this.setByBinaryString(t.bin)
                                : void 0 !== t.array && this.setByBooleanArray(t.array));
                }),
                W.lang.extend(tt.asn1.DERBitString, tt.asn1.ASN1Object),
                (tt.asn1.DEROctetString = function (t) {
                    if (void 0 !== t && void 0 !== t.obj) {
                        var e = tt.asn1.ASN1Util.newObject(t.obj);
                        t.hex = e.getEncodedHex();
                    }
                    tt.asn1.DEROctetString.superclass.constructor.call(this, t), (this.hT = '04');
                }),
                W.lang.extend(tt.asn1.DEROctetString, tt.asn1.DERAbstractString),
                (tt.asn1.DERNull = function () {
                    tt.asn1.DERNull.superclass.constructor.call(this), (this.hT = '05'), (this.hTLV = '0500');
                }),
                W.lang.extend(tt.asn1.DERNull, tt.asn1.ASN1Object),
                (tt.asn1.DERObjectIdentifier = function (t) {
                    var e = function (t) {
                            var e = t.toString(16);
                            return 1 == e.length && (e = '0' + e), e;
                        },
                        i = function (t) {
                            var i = '',
                                r = new B(t, 10).toString(2),
                                n = 7 - (r.length % 7);
                            7 == n && (n = 0);
                            for (var s = '', o = 0; o < n; o++) s += '0';
                            for (r = s + r, o = 0; o < r.length - 1; o += 7) {
                                var h = r.substr(o, 7);
                                o != r.length - 7 && (h = '1' + h), (i += e(parseInt(h, 2)));
                            }
                            return i;
                        };
                    tt.asn1.DERObjectIdentifier.superclass.constructor.call(this),
                        (this.hT = '06'),
                        (this.setValueHex = function (t) {
                            (this.hTLV = null), (this.isModified = !0), (this.s = null), (this.hV = t);
                        }),
                        (this.setValueOidString = function (t) {
                            if (!t.match(/^[0-9.]+$/)) throw 'malformed oid string: ' + t;
                            var r = '',
                                n = t.split('.'),
                                s = 40 * parseInt(n[0]) + parseInt(n[1]);
                            (r += e(s)), n.splice(0, 2);
                            for (var o = 0; o < n.length; o++) r += i(n[o]);
                            (this.hTLV = null), (this.isModified = !0), (this.s = null), (this.hV = r);
                        }),
                        (this.setValueName = function (t) {
                            var e = tt.asn1.x509.OID.name2oid(t);
                            if ('' === e) throw 'DERObjectIdentifier oidName undefined: ' + t;
                            this.setValueOidString(e);
                        }),
                        (this.getFreshValueHex = function () {
                            return this.hV;
                        }),
                        void 0 !== t &&
                            ('string' == typeof t
                                ? t.match(/^[0-2].[0-9.]+$/)
                                    ? this.setValueOidString(t)
                                    : this.setValueName(t)
                                : void 0 !== t.oid
                                ? this.setValueOidString(t.oid)
                                : void 0 !== t.hex
                                ? this.setValueHex(t.hex)
                                : void 0 !== t.name && this.setValueName(t.name));
                }),
                W.lang.extend(tt.asn1.DERObjectIdentifier, tt.asn1.ASN1Object),
                (tt.asn1.DEREnumerated = function (t) {
                    tt.asn1.DEREnumerated.superclass.constructor.call(this),
                        (this.hT = '0a'),
                        (this.setByBigInteger = function (t) {
                            (this.hTLV = null),
                                (this.isModified = !0),
                                (this.hV = tt.asn1.ASN1Util.bigIntToMinTwosComplementsHex(t));
                        }),
                        (this.setByInteger = function (t) {
                            var e = new B(String(t), 10);
                            this.setByBigInteger(e);
                        }),
                        (this.setValueHex = function (t) {
                            this.hV = t;
                        }),
                        (this.getFreshValueHex = function () {
                            return this.hV;
                        }),
                        void 0 !== t &&
                            (void 0 !== t.int
                                ? this.setByInteger(t.int)
                                : 'number' == typeof t
                                ? this.setByInteger(t)
                                : void 0 !== t.hex && this.setValueHex(t.hex));
                }),
                W.lang.extend(tt.asn1.DEREnumerated, tt.asn1.ASN1Object),
                (tt.asn1.DERUTF8String = function (t) {
                    tt.asn1.DERUTF8String.superclass.constructor.call(this, t), (this.hT = '0c');
                }),
                W.lang.extend(tt.asn1.DERUTF8String, tt.asn1.DERAbstractString),
                (tt.asn1.DERNumericString = function (t) {
                    tt.asn1.DERNumericString.superclass.constructor.call(this, t), (this.hT = '12');
                }),
                W.lang.extend(tt.asn1.DERNumericString, tt.asn1.DERAbstractString),
                (tt.asn1.DERPrintableString = function (t) {
                    tt.asn1.DERPrintableString.superclass.constructor.call(this, t), (this.hT = '13');
                }),
                W.lang.extend(tt.asn1.DERPrintableString, tt.asn1.DERAbstractString),
                (tt.asn1.DERTeletexString = function (t) {
                    tt.asn1.DERTeletexString.superclass.constructor.call(this, t), (this.hT = '14');
                }),
                W.lang.extend(tt.asn1.DERTeletexString, tt.asn1.DERAbstractString),
                (tt.asn1.DERIA5String = function (t) {
                    tt.asn1.DERIA5String.superclass.constructor.call(this, t), (this.hT = '16');
                }),
                W.lang.extend(tt.asn1.DERIA5String, tt.asn1.DERAbstractString),
                (tt.asn1.DERUTCTime = function (t) {
                    tt.asn1.DERUTCTime.superclass.constructor.call(this, t),
                        (this.hT = '17'),
                        (this.setByDate = function (t) {
                            (this.hTLV = null),
                                (this.isModified = !0),
                                (this.date = t),
                                (this.s = this.formatDate(this.date, 'utc')),
                                (this.hV = stohex(this.s));
                        }),
                        (this.getFreshValueHex = function () {
                            return (
                                void 0 === this.date &&
                                    void 0 === this.s &&
                                    ((this.date = new Date()),
                                    (this.s = this.formatDate(this.date, 'utc')),
                                    (this.hV = stohex(this.s))),
                                this.hV
                            );
                        }),
                        void 0 !== t &&
                            (void 0 !== t.str
                                ? this.setString(t.str)
                                : 'string' == typeof t && t.match(/^[0-9]{12}Z$/)
                                ? this.setString(t)
                                : void 0 !== t.hex
                                ? this.setStringHex(t.hex)
                                : void 0 !== t.date && this.setByDate(t.date));
                }),
                W.lang.extend(tt.asn1.DERUTCTime, tt.asn1.DERAbstractTime),
                (tt.asn1.DERGeneralizedTime = function (t) {
                    tt.asn1.DERGeneralizedTime.superclass.constructor.call(this, t),
                        (this.hT = '18'),
                        (this.withMillis = !1),
                        (this.setByDate = function (t) {
                            (this.hTLV = null),
                                (this.isModified = !0),
                                (this.date = t),
                                (this.s = this.formatDate(this.date, 'gen', this.withMillis)),
                                (this.hV = stohex(this.s));
                        }),
                        (this.getFreshValueHex = function () {
                            return (
                                void 0 === this.date &&
                                    void 0 === this.s &&
                                    ((this.date = new Date()),
                                    (this.s = this.formatDate(this.date, 'gen', this.withMillis)),
                                    (this.hV = stohex(this.s))),
                                this.hV
                            );
                        }),
                        void 0 !== t &&
                            (void 0 !== t.str
                                ? this.setString(t.str)
                                : 'string' == typeof t && t.match(/^[0-9]{14}Z$/)
                                ? this.setString(t)
                                : void 0 !== t.hex
                                ? this.setStringHex(t.hex)
                                : void 0 !== t.date && this.setByDate(t.date),
                            !0 === t.millis && (this.withMillis = !0));
                }),
                W.lang.extend(tt.asn1.DERGeneralizedTime, tt.asn1.DERAbstractTime),
                (tt.asn1.DERSequence = function (t) {
                    tt.asn1.DERSequence.superclass.constructor.call(this, t),
                        (this.hT = '30'),
                        (this.getFreshValueHex = function () {
                            for (var t = '', e = 0; e < this.asn1Array.length; e++)
                                t += this.asn1Array[e].getEncodedHex();
                            return (this.hV = t), this.hV;
                        });
                }),
                W.lang.extend(tt.asn1.DERSequence, tt.asn1.DERAbstractStructured),
                (tt.asn1.DERSet = function (t) {
                    tt.asn1.DERSet.superclass.constructor.call(this, t),
                        (this.hT = '31'),
                        (this.sortFlag = !0),
                        (this.getFreshValueHex = function () {
                            for (var t = new Array(), e = 0; e < this.asn1Array.length; e++) {
                                var i = this.asn1Array[e];
                                t.push(i.getEncodedHex());
                            }
                            return 1 == this.sortFlag && t.sort(), (this.hV = t.join('')), this.hV;
                        }),
                        void 0 !== t && void 0 !== t.sortflag && 0 == t.sortflag && (this.sortFlag = !1);
                }),
                W.lang.extend(tt.asn1.DERSet, tt.asn1.DERAbstractStructured),
                (tt.asn1.DERTaggedObject = function (t) {
                    tt.asn1.DERTaggedObject.superclass.constructor.call(this),
                        (this.hT = 'a0'),
                        (this.hV = ''),
                        (this.isExplicit = !0),
                        (this.asn1Object = null),
                        (this.setASN1Object = function (t, e, i) {
                            (this.hT = e),
                                (this.isExplicit = t),
                                (this.asn1Object = i),
                                this.isExplicit
                                    ? ((this.hV = this.asn1Object.getEncodedHex()),
                                      (this.hTLV = null),
                                      (this.isModified = !0))
                                    : ((this.hV = null),
                                      (this.hTLV = i.getEncodedHex()),
                                      (this.hTLV = this.hTLV.replace(/^../, e)),
                                      (this.isModified = !1));
                        }),
                        (this.getFreshValueHex = function () {
                            return this.hV;
                        }),
                        void 0 !== t &&
                            (void 0 !== t.tag && (this.hT = t.tag),
                            void 0 !== t.explicit && (this.isExplicit = t.explicit),
                            void 0 !== t.obj &&
                                ((this.asn1Object = t.obj),
                                this.setASN1Object(this.isExplicit, this.hT, this.asn1Object)));
                }),
                W.lang.extend(tt.asn1.DERTaggedObject, tt.asn1.ASN1Object);
            var et,
                it =
                    ((et = function (t, e) {
                        return (et =
                            Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array &&
                                function (t, e) {
                                    t.__proto__ = e;
                                }) ||
                            function (t, e) {
                                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
                            })(t, e);
                    }),
                    function (t, e) {
                        if ('function' != typeof e && null !== e)
                            throw new TypeError('Class extends value ' + String(e) + ' is not a constructor or null');
                        function i() {
                            this.constructor = t;
                        }
                        et(t, e),
                            (t.prototype = null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
                    }),
                rt = (function (t) {
                    function e(i) {
                        var r = t.call(this) || this;
                        return (
                            i &&
                                ('string' == typeof i
                                    ? r.parseKey(i)
                                    : (e.hasPrivateKeyProperty(i) || e.hasPublicKeyProperty(i)) &&
                                      r.parsePropertiesFrom(i)),
                            r
                        );
                    }
                    return (
                        it(e, t),
                        (e.prototype.parseKey = function (t) {
                            try {
                                var e = 0,
                                    i = 0,
                                    r = /^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/.test(t)
                                        ? (function (t) {
                                              var e;
                                              if (void 0 === c) {
                                                  var i = '0123456789ABCDEF',
                                                      r = ' \f\n\r\t \u2028\u2029';
                                                  for (c = {}, e = 0; e < 16; ++e) c[i.charAt(e)] = e;
                                                  for (i = i.toLowerCase(), e = 10; e < 16; ++e) c[i.charAt(e)] = e;
                                                  for (e = 0; e < r.length; ++e) c[r.charAt(e)] = -1;
                                              }
                                              var n = [],
                                                  s = 0,
                                                  o = 0;
                                              for (e = 0; e < t.length; ++e) {
                                                  var h = t.charAt(e);
                                                  if ('=' == h) break;
                                                  if (-1 != (h = c[h])) {
                                                      if (void 0 === h)
                                                          throw new Error('Illegal character at offset ' + e);
                                                      (s |= h),
                                                          ++o >= 2 ? ((n[n.length] = s), (s = 0), (o = 0)) : (s <<= 4);
                                                  }
                                              }
                                              if (o) throw new Error('Hex encoding incomplete: 4 bits missing');
                                              return n;
                                          })(t)
                                        : d.unarmor(t),
                                    n = w.decode(r);
                                if ((3 === n.sub.length && (n = n.sub[2].sub[0]), 9 === n.sub.length)) {
                                    (e = n.sub[1].getHexStringValue()),
                                        (this.n = P(e, 16)),
                                        (i = n.sub[2].getHexStringValue()),
                                        (this.e = parseInt(i, 16));
                                    var s = n.sub[3].getHexStringValue();
                                    this.d = P(s, 16);
                                    var o = n.sub[4].getHexStringValue();
                                    this.p = P(o, 16);
                                    var h = n.sub[5].getHexStringValue();
                                    this.q = P(h, 16);
                                    var a = n.sub[6].getHexStringValue();
                                    this.dmp1 = P(a, 16);
                                    var u = n.sub[7].getHexStringValue();
                                    this.dmq1 = P(u, 16);
                                    var f = n.sub[8].getHexStringValue();
                                    this.coeff = P(f, 16);
                                } else {
                                    if (2 !== n.sub.length) return !1;
                                    var l = n.sub[1].sub[0];
                                    (e = l.sub[0].getHexStringValue()),
                                        (this.n = P(e, 16)),
                                        (i = l.sub[1].getHexStringValue()),
                                        (this.e = parseInt(i, 16));
                                }
                                return !0;
                            } catch (t) {
                                return !1;
                            }
                        }),
                        (e.prototype.getPrivateBaseKey = function () {
                            var t = {
                                array: [
                                    new tt.asn1.DERInteger({ int: 0 }),
                                    new tt.asn1.DERInteger({ bigint: this.n }),
                                    new tt.asn1.DERInteger({ int: this.e }),
                                    new tt.asn1.DERInteger({ bigint: this.d }),
                                    new tt.asn1.DERInteger({ bigint: this.p }),
                                    new tt.asn1.DERInteger({ bigint: this.q }),
                                    new tt.asn1.DERInteger({ bigint: this.dmp1 }),
                                    new tt.asn1.DERInteger({ bigint: this.dmq1 }),
                                    new tt.asn1.DERInteger({ bigint: this.coeff }),
                                ],
                            };
                            return new tt.asn1.DERSequence(t).getEncodedHex();
                        }),
                        (e.prototype.getPrivateBaseKeyB64 = function () {
                            return l(this.getPrivateBaseKey());
                        }),
                        (e.prototype.getPublicBaseKey = function () {
                            var t = new tt.asn1.DERSequence({
                                    array: [
                                        new tt.asn1.DERObjectIdentifier({ oid: '1.2.840.113549.1.1.1' }),
                                        new tt.asn1.DERNull(),
                                    ],
                                }),
                                e = new tt.asn1.DERSequence({
                                    array: [
                                        new tt.asn1.DERInteger({ bigint: this.n }),
                                        new tt.asn1.DERInteger({ int: this.e }),
                                    ],
                                }),
                                i = new tt.asn1.DERBitString({ hex: '00' + e.getEncodedHex() });
                            return new tt.asn1.DERSequence({ array: [t, i] }).getEncodedHex();
                        }),
                        (e.prototype.getPublicBaseKeyB64 = function () {
                            return l(this.getPublicBaseKey());
                        }),
                        (e.wordwrap = function (t, e) {
                            if (!t) return t;
                            var i = '(.{1,' + (e = e || 64) + '})( +|$\n?)|(.{1,' + e + '})';
                            return t.match(RegExp(i, 'g')).join('\n');
                        }),
                        (e.prototype.getPrivateKey = function () {
                            var t = '-----BEGIN RSA PRIVATE KEY-----\n';
                            return (
                                (t += e.wordwrap(this.getPrivateBaseKeyB64()) + '\n') + '-----END RSA PRIVATE KEY-----'
                            );
                        }),
                        (e.prototype.getPublicKey = function () {
                            var t = '-----BEGIN PUBLIC KEY-----\n';
                            return (t += e.wordwrap(this.getPublicBaseKeyB64()) + '\n') + '-----END PUBLIC KEY-----';
                        }),
                        (e.hasPublicKeyProperty = function (t) {
                            return (t = t || {}).hasOwnProperty('n') && t.hasOwnProperty('e');
                        }),
                        (e.hasPrivateKeyProperty = function (t) {
                            return (
                                (t = t || {}).hasOwnProperty('n') &&
                                t.hasOwnProperty('e') &&
                                t.hasOwnProperty('d') &&
                                t.hasOwnProperty('p') &&
                                t.hasOwnProperty('q') &&
                                t.hasOwnProperty('dmp1') &&
                                t.hasOwnProperty('dmq1') &&
                                t.hasOwnProperty('coeff')
                            );
                        }),
                        (e.prototype.parsePropertiesFrom = function (t) {
                            (this.n = t.n),
                                (this.e = t.e),
                                t.hasOwnProperty('d') &&
                                    ((this.d = t.d),
                                    (this.p = t.p),
                                    (this.q = t.q),
                                    (this.dmp1 = t.dmp1),
                                    (this.dmq1 = t.dmq1),
                                    (this.coeff = t.coeff));
                        }),
                        e
                    );
                })(X);
            const nt = (function () {
                function t(t) {
                    void 0 === t && (t = {}),
                        (t = t || {}),
                        (this.default_key_size = t.default_key_size ? parseInt(t.default_key_size, 10) : 1024),
                        (this.default_public_exponent = t.default_public_exponent || '010001'),
                        (this.log = t.log || !1),
                        (this.key = null);
                }
                return (
                    (t.prototype.setKey = function (t) {
                        this.log && this.key && console.warn('A key was already set, overriding existing.'),
                            (this.key = new rt(t));
                    }),
                    (t.prototype.setPrivateKey = function (t) {
                        this.setKey(t);
                    }),
                    (t.prototype.setPublicKey = function (t) {
                        this.setKey(t);
                    }),
                    (t.prototype.decrypt = function (t) {
                        try {
                            return this.getKey().decrypt(p(t));
                        } catch (t) {
                            return !1;
                        }
                    }),
                    (t.prototype.encrypt = function (t) {
                        try {
                            return l(this.getKey().encrypt(t));
                        } catch (t) {
                            return !1;
                        }
                    }),
                    (t.prototype.sign = function (t, e, i) {
                        try {
                            return l(this.getKey().sign(t, e, i));
                        } catch (t) {
                            return !1;
                        }
                    }),
                    (t.prototype.verify = function (t, e, i) {
                        try {
                            return this.getKey().verify(t, p(e), i);
                        } catch (t) {
                            return !1;
                        }
                    }),
                    (t.prototype.getKey = function (t) {
                        if (!this.key) {
                            if (((this.key = new rt()), t && '[object Function]' === {}.toString.call(t)))
                                return void this.key.generateAsync(
                                    this.default_key_size,
                                    this.default_public_exponent,
                                    t,
                                );
                            this.key.generate(this.default_key_size, this.default_public_exponent);
                        }
                        return this.key;
                    }),
                    (t.prototype.getPrivateKey = function () {
                        return this.getKey().getPrivateKey();
                    }),
                    (t.prototype.getPrivateKeyB64 = function () {
                        return this.getKey().getPrivateBaseKeyB64();
                    }),
                    (t.prototype.getPublicKey = function () {
                        return this.getKey().getPublicKey();
                    }),
                    (t.prototype.getPublicKeyB64 = function () {
                        return this.getKey().getPublicBaseKeyB64();
                    }),
                    (t.version = '3.2.1'),
                    t
                );
            })();
        },
    ],
    e = {
        d: (t, i) => {
            for (var r in i) e.o(i, r) && !e.o(t, r) && Object.defineProperty(t, r, { enumerable: !0, get: i[r] });
        },
        o: (t, e) => Object.prototype.hasOwnProperty.call(t, e),
    },
    i = {};
t[1](0, i, e);

/* harmony default export */ __webpack_exports__["default"] = (i.default);


/***/ }),

/***/ "./sdk/util/param-util.ts":
/*!********************************!*\
  !*** ./sdk/util/param-util.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1743338__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.checkParams = exports.RULE_SUCCESS = exports.RULE_PARAM_NAME = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
var client_util_1 = __nested_webpack_require_1743338__(/*! ./client-util */ "./sdk/util/client-util.ts");
var RULE_PARAM_NAME;
(function (RULE_PARAM_NAME) {
    RULE_PARAM_NAME["NOT_EMPTY"] = "NOT_EMPTY";
    RULE_PARAM_NAME["ILLEGAL_CHARACTERS"] = "ILLEGAL_CHARACTERS";
    RULE_PARAM_NAME["TYPE_STRING"] = "TYPE_STRING";
    RULE_PARAM_NAME["TYPE_INTEGER"] = "TYPE_INTEGER";
    RULE_PARAM_NAME["TYPE_OBJECT"] = "TYPE_OBJECT";
    RULE_PARAM_NAME["MAX_LENGTH_10"] = "MAX_LENGTH_10";
    RULE_PARAM_NAME["MAX_LENGTH_64"] = "MAX_LENGTH_64";
    RULE_PARAM_NAME["MAX_LENGTH_100"] = "MAX_LENGTH_100";
    RULE_PARAM_NAME["MAX_LENGTH_128"] = "MAX_LENGTH_128";
    RULE_PARAM_NAME["MAX_LENGTH_256"] = "MAX_LENGTH_256";
    RULE_PARAM_NAME["MAX_LENGTH_1024"] = "MAX_LENGTH_1024";
})(RULE_PARAM_NAME = exports.RULE_PARAM_NAME || (exports.RULE_PARAM_NAME = {}));
exports.RULE_SUCCESS = {
    error: {
        code: 0,
        msg: 'suc',
    },
};
var RULE_PARAM = {
    NOT_EMPTY: function (key, value, action, logger, rule) {
        if (value === undefined || value === '' || value === null) {
            logger.error(action + " " + key + " is empty");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    ILLEGAL_CHARACTERS: function (key, value, action, logger, rule) {
        if (!client_util_1.ClientUtil.checkIllegalCharacters(value)) {
            logger.error(action + " " + key + " contains illegal characters");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    TYPE_STRING: function (key, value, action, logger, rule) {
        if (typeof value !== 'string') {
            logger.error(action + " " + key + " must be string");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    TYPE_INTEGER: function (key, value, action, logger, rule) {
        if (!client_util_1.ClientUtil.checkInteger(value, false)) {
            logger.error(action + " " + key + "  must be integer number");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    TYPE_OBJECT: function (key, value, action, logger, rule) {
        if (!value || typeof value !== 'object') {
            logger.error(action + " " + key + "  must be object");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    MAX_LENGTH_10: function (key, value, action, logger, rule) {
        if (value.length > 10) {
            logger.error(action + " " + key + " is too long");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    MAX_LENGTH_64: function (key, value, action, logger, rule) {
        if (value.length > 64) {
            logger.error(action + " " + key + " is too long");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    MAX_LENGTH_100: function (key, value, action, logger, rule) {
        if (value.length > 100) {
            logger.error(action + " " + key + " is too long");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    MAX_LENGTH_128: function (key, value, action, logger, rule) {
        if (value.length > 128) {
            logger.error(action + " " + key + " is too long");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    MAX_LENGTH_256: function (key, value, action, logger, rule) {
        if (value.length > 256) {
            logger.error(action + " " + key + " is too long");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    MAX_LENGTH_1024: function (key, value, action, logger, rule) {
        if (value.length > 1024) {
            logger.error(action + " " + key + " is too long");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
};
function checkParams(sourceMap, option) {
    // 先排序,按照输入顺序检测参数
    var arrayByKey = [], tempMap = {};
    for (var skey in sourceMap) {
        var order = sourceMap[skey].order;
        tempMap[order] = sourceMap[skey];
        sourceMap[skey].key = skey;
    }
    for (var tkey in tempMap) {
        arrayByKey.push(tempMap[tkey]);
    }
    // 按照规则名称执行对应的判断
    for (var i = 0; i < arrayByKey.length; i++) {
        var rules = arrayByKey[i].rules;
        for (var k = 0; k < rules.length; k++) {
            var _a = {
                key: arrayByKey[i].key,
                value: arrayByKey[i].value,
                action: option.action,
                logger: option.logger,
            }, key = _a.key, value = _a.value, action = _a.action, logger = _a.logger;
            var ruleKey = rules[k].name ? '' + rules[k].name : '';
            if (((value === undefined && ruleKey === RULE_PARAM_NAME.NOT_EMPTY) || value !== undefined) &&
                RULE_PARAM[ruleKey]) {
                var excuteRes = RULE_PARAM[ruleKey](key, value, action, logger, rules[k]);
                if (excuteRes != exports.RULE_SUCCESS) {
                    return excuteRes;
                }
            }
        }
    }
    return exports.RULE_SUCCESS;
}
exports.checkParams = checkParams;


/***/ }),

/***/ "./sdk/util/socket-util.ts":
/*!*********************************!*\
  !*** ./sdk/util/socket-util.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1749175__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ZegoSocketService = void 0;
var zego_entity_1 = __nested_webpack_require_1749175__(/*! ../src/zego.entity */ "./sdk/src/zego.entity.ts");
var zego_externalError_1 = __nested_webpack_require_1749175__(/*! ../src/zego.externalError */ "./sdk/src/zego.externalError.ts");
var ZegoSocketService = /** @class */ (function () {
    function ZegoSocketService(ENV) {
        this.socket = null;
        // private responseRouters: { [index: string]: Function } = {};
        // 发送消息信息存储, 超时不回包执行错误回调
        this.sendCommandList = new zego_entity_1.LinkedList();
        this.sendCommandMap = {};
        // 定时器最大处理消息个数
        this.sendDataCheckOnceCount = 100;
        // 超时多久后,没有处理的回调直接扔掉
        this.sendDataDropTimeout = 10 * 1000;
        // 定时器执行间隔
        this.sendDataCheckInterval = 2000;
        this.ENV = ENV;
    }
    ZegoSocketService.prototype.createSocket = function (server) {
        this.socket = zego_entity_1.createZegoWebSocket(server, this.ENV % 2);
    };
    ZegoSocketService.prototype.closeSocket = function () {
        if (this.socket) {
            this.socket.onclose = null;
            this.socket.onerror = null;
            this.socket.close();
            this.socket = null;
        }
    };
    ZegoSocketService.prototype.isDisConnect = function () {
        return !this.socket || this.socket.readyState !== 1;
    };
    /*
     *    消息发送接口
     *
     */
    ZegoSocketService.prototype.sendMessage = function (header, body, success, error, option) {
        if (success === void 0) { success = null; }
        if (error === void 0) { error = null; }
        if (option === void 0) { option = { timeOut: 6 * 1000 }; }
        var data = {
            header: header,
            body: body,
        };
        var cmdData = {
            data: data,
            seq: header.seq,
            deleted: false,
            sendTime: Date.parse(new Date() + ''),
            timeOut: option.timeOut,
            success: success,
            error: error,
        };
        var cmdDataNode = this.sendCommandList.push(cmdData);
        this.sendCommandMap[cmdData.seq] = cmdDataNode;
        this.socket && this.socket.send(JSON.stringify(data));
        return header.seq;
    };
    ZegoSocketService.prototype.sendPB = function (msg) {
        this.socket && this.socket.send(msg);
        return true;
    };
    // 回调所有未回包数据
    ZegoSocketService.prototype.checkSendMessageList = function (messageList) {
        var head = messageList.getFirst();
        while (head != null) {
            messageList.remove(head);
            if (head._data && head._data.error) {
                setTimeout(function () {
                    head &&
                        head._data &&
                        head._data.error &&
                        head._data.error(zego_externalError_1.errorCodeList.TIMEOUT, head._data.data.header.seq, head._data.data.body.custom_msg);
                }, 0);
            }
            head = messageList.getFirst();
        }
    };
    // 定时器轮询未回包数据,超时的调用错误回调
    ZegoSocketService.prototype.checkMessageListTimeout = function (messageList, messageMap) {
        var head = messageList.getFirst();
        var timestamp = Date.parse(new Date() + '');
        var checkCount = 0;
        var timeoutMsgCount = 0;
        var dropMsgCount = 0;
        while (head != null) {
            // 没有超时 继续等待
            if (head._data && head._data.sendTime + head._data.timeOut > timestamp) {
                break;
            }
            // 超时 删除缓存,准备调研错误回调
            head._data && delete messageMap[head._data.data.header.seq];
            messageList.remove(head);
            ++timeoutMsgCount;
            // 没有设置错误回调 或者积压太久没有来得及处理的回调,直接丢弃并计数
            if ((head._data && head._data.error == null) ||
                (head._data && head._data.sendTime + this.sendDataDropTimeout < timestamp)) {
                ++dropMsgCount;
            }
            else {
                setTimeout(function () {
                    head &&
                        head._data &&
                        head._data.error &&
                        head._data.error(zego_externalError_1.errorCodeList.TIMEOUT, head._data.data.header.seq, head._data.data.body.custom_msg);
                }, 0);
            }
            ++checkCount;
            if (checkCount >= this.sendDataCheckOnceCount) {
                break;
            }
            head = messageList.getFirst();
        }
        // if (timeoutMsgCount != 0 || dropMsgCount != 0) {
        //     console.error('zb.hb.cmt call success, stat: timeout=', timeoutMsgCount + '', 'drop=', dropMsgCount + '');
        // }
    };
    // 启动定时器,轮询
    ZegoSocketService.prototype.startCheck = function () {
        var _this = this;
        this.checkMessageListTimeout(this.sendCommandList, this.sendCommandMap);
        this.sendDataCheckTimer = setTimeout(function () {
            _this.startCheck();
        }, this.sendDataCheckInterval);
    };
    // 关闭轮询定时器
    ZegoSocketService.prototype.stopCheck = function () {
        this.checkSendMessageList(this.sendCommandList);
        clearTimeout(this.sendDataCheckTimer);
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ZegoSocketService.prototype.openHandler = function (hander) {
        var _this = this;
        if (this.socket)
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.socket.onopen = function (evt) {
                _this.socket.binaryType = 'arraybuffer';
                _this.responseHandler();
                hander(evt);
            };
    };
    /*
     *    "zb.sc.ws.rph: "ZegoExpressEngine.base.SocketCenter.responseHandler"
     */
    ZegoSocketService.prototype.responseHandler = function () {
        var _this = this;
        if (this.socket)
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.socket.onmessage = function (e) {
                var msg = typeof e.data == 'string'
                    ? JSON.parse(e.data)
                    : //: JSON.parse(String.fromCharCode.apply(null, new Uint8Array(e.data) as any));
                        e.data;
                _this.onMessage(msg);
            };
    };
    /*
     *    "zb.sc.ch": "ZegoExpressEngine.base.SocketCenter.closeHandler"
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ZegoSocketService.prototype.closeHandler = function (handler) {
        if (this.socket)
            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
            this.socket.onclose = function (evt) {
                handler(evt);
            };
    };
    /*
     *    "zb.sc.ws.oe": "ZegoExpressEngine.base.SocketCenter.errorHandler"
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ZegoSocketService.prototype.errorHandler = function (handler) {
        this.socket && (this.socket.onerror = handler);
    };
    //注册cmd回调事件
    ZegoSocketService.prototype.onMessage = function (msg) { };
    return ZegoSocketService;
}());
exports.ZegoSocketService = ZegoSocketService;


/***/ }),

/***/ "./sdk/util/string.ts":
/*!****************************!*\
  !*** ./sdk/util/string.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeString = exports.encodeString = void 0;
var encodeString = function (str) {
    return Uint8Array.from(Array.from(unescape(encodeURIComponent(str))).map(function (val) { return val.charCodeAt(0); }));
};
exports.encodeString = encodeString;
var decodeString = function (u8arr) {
    return decodeURIComponent(escape(String.fromCharCode.apply(String, Array.from(u8arr))));
};
exports.decodeString = decodeString;


/***/ }),

/***/ 0:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
});

/***/ }),

/***/ "../zego_express_web_rtm/dist/live/index.js":
/*!**************************************************!*\
  !*** ../zego_express_web_rtm/dist/live/index.js ***!
  \**************************************************/
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_573__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_573__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_573__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_573__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_573__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_573__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_573__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__nested_webpack_require_573__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __nested_webpack_require_573__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__nested_webpack_require_573__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_573__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_573__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_573__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_573__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_573__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_573__(__nested_webpack_require_573__.s = "./sdk/src/modules/live/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./sdk/src/modules/live/action.ts":
/*!****************************************!*\
  !*** ./sdk/src/modules/live/action.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ZEGO_RTM_ACTION = void 0;
var ZEGO_RTM_ACTION;
(function (ZEGO_RTM_ACTION) {
    ZEGO_RTM_ACTION["LIVE_SEND_SIGNAL"] = "zm.lv.ssg";
    ZEGO_RTM_ACTION["LIVE_RESPOND_JOIN_LIVE"] = "zm.lv.rjl";
    ZEGO_RTM_ACTION["LIVE_PUSH_SIGNAL"] = "zm.lv.pss";
    ZEGO_RTM_ACTION["SERVICE_PUSH"] = "zm.sv.ps";
    ZEGO_RTM_ACTION["SERVICE_SEND"] = "zm.sv.sd";
})(ZEGO_RTM_ACTION = exports.ZEGO_RTM_ACTION || (exports.ZEGO_RTM_ACTION = {}));


/***/ }),

/***/ "./sdk/src/modules/live/content.ts":
/*!*****************************************!*\
  !*** ./sdk/src/modules/live/content.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_5071__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.modulePros = exports.servicePros = exports.rtmPros = void 0;
// @ts-nocheck
var action_1 = __nested_webpack_require_5071__(/*! ./action */ "./sdk/src/modules/live/action.ts");
var error_1 = __nested_webpack_require_5071__(/*! ./error */ "./sdk/src/modules/live/error.ts");
var liveHandler_1 = __nested_webpack_require_5071__(/*! ./liveHandler */ "./sdk/src/modules/live/liveHandler.ts");
function requestJoinLive(destIdName, success, error, resultCallback, roomID) {
    var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
    if (!room) {
        error && error(error_1.errorCodeList.ROOM_NOT_EXIST, 0);
        return false;
    }
    return room.liveHandler.requestJoinLive(destIdName, success, error, resultCallback);
}
function inviteJoinLive(destIdName, success, error, resultCallback, roomID) {
    var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
    if (!room) {
        error && error(error_1.errorCodeList.ROOM_NOT_EXIST, 0);
        return false;
    }
    return room.liveHandler.inviteJoinLive(destIdName, success, error, resultCallback);
}
function endJoinLive(destIdName, success, error, roomID) {
    var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
    if (!room) {
        error && error(error_1.errorCodeList.ROOM_NOT_EXIST, 0);
        return false;
    }
    return room.liveHandler.endJoinLive(destIdName, success, error);
}
function respondJoinLive(requestId, respondResult, success, error, roomID) {
    var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
    if (!room) {
        error && error(error_1.errorCodeList.ROOM_NOT_EXIST, 0);
        return false;
    }
    return room.liveHandler.respondJoinLive(requestId, respondResult, success, error);
}
exports.rtmPros = {
    requestJoinLive: requestJoinLive,
    inviteJoinLive: inviteJoinLive,
    endJoinLive: endJoinLive,
    respondJoinLive: respondJoinLive,
};
function handlePushSignalMsg(msg) {
    var _a;
    var roomID = (_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id;
    var room = this.stateCenter.roomModulesList.find(function (roomModules) { return roomModules.roomID == roomID; });
    if (!room) {
        this.logger.error(action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + ' room no found ignore ' + JSON.stringify(msg));
        return;
    }
    room.liveHandler.handlePushSignalMsg(msg);
}
exports.servicePros = {
    handlePushSignalMsg: handlePushSignalMsg,
};
function initLiveHandler() {
    this.liveHandler = new liveHandler_1.LiveHandler(this.logger, this.stateCenter, this.service, this.liveRoomHandler, this.rtm, this);
}
exports.modulePros = {
    initLiveHandler: initLiveHandler,
};


/***/ }),

/***/ "./sdk/src/modules/live/entity.ts":
/*!****************************************!*\
  !*** ./sdk/src/modules/live/entity.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ENUM_PUSH_SIGNAL_SUB_CMD = exports.ENUM_SIGNAL_SUB_CMD = void 0;
exports.ENUM_SIGNAL_SUB_CMD = {
    none: 0,
    joinLiveRequest: 1001,
    joinLiveResult: 1002,
    joinLiveInvite: 1003,
    joinLiveStop: 1004,
};
exports.ENUM_PUSH_SIGNAL_SUB_CMD = {
    none: 0,
    pushJoinLiveRequest: 11001,
    pushJoinLiveResult: 11002,
    pushJoinLiveInvite: 11003,
    pushJoinLiveStop: 11004,
};


/***/ }),

/***/ "./sdk/src/modules/live/error.ts":
/*!***************************************!*\
  !*** ./sdk/src/modules/live/error.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.errorCodeList = void 0;
exports.errorCodeList = {
    ROOM_NOT_EXIST: {
        code: 1002014,
        msg: 'room not exist',
    },
    ROOM_INNER_ERROR: {
        code: 1002099,
        msg: 'room inner error',
    },
};


/***/ }),

/***/ "./sdk/src/modules/live/index.ts":
/*!***************************************!*\
  !*** ./sdk/src/modules/live/index.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_9500__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//@ts-nocheck
var content_1 = __nested_webpack_require_9500__(/*! ./content */ "./sdk/src/modules/live/content.ts");
exports.default = {
    type: 'live',
    install: function (rtm, liveRoomModule, service, liveRoomHandler) {
        for (var key in content_1.rtmPros) {
            Object.defineProperty(rtm.prototype, key, {
                value: content_1.rtmPros[key],
                writable: false,
            });
        }
        for (var key in content_1.servicePros) {
            Object.defineProperty(service.prototype, key, {
                value: content_1.servicePros[key],
                writable: false,
            });
            Object.defineProperty(liveRoomHandler.prototype, key, {
                value: content_1.servicePros[key],
                writable: false,
            });
        }
        for (var key in content_1.modulePros) {
            Object.defineProperty(liveRoomModule.prototype, key, {
                value: content_1.modulePros[key],
                writable: false,
            });
        }
    },
};


/***/ }),

/***/ "./sdk/src/modules/live/liveHandler.ts":
/*!*********************************************!*\
  !*** ./sdk/src/modules/live/liveHandler.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_10921__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveHandler = void 0;
var entity_1 = __nested_webpack_require_10921__(/*! ./entity */ "./sdk/src/modules/live/entity.ts");
var action_1 = __nested_webpack_require_10921__(/*! ./action */ "./sdk/src/modules/live/action.ts");
var error_1 = __nested_webpack_require_10921__(/*! ./error */ "./sdk/src/modules/live/error.ts");
var LiveHandler = /** @class */ (function () {
    function LiveHandler(logger, stateCenter, service, liveRoomHandler, rtm, room) {
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.service = service;
        this.liveRoomHandler = liveRoomHandler;
        this.rtm = rtm;
        this.room = room;
        this.joinLiveCallbackMap = {};
        this.joinLiveRequestMap = {};
    }
    LiveHandler.prototype.resetLiveHandler = function () {
        // 清除连麦信令
        this.joinLiveCallbackMap = {};
        this.joinLiveRequestMap = {};
    };
    LiveHandler.prototype.getSignalCmdContent = function (requestId, dest_id_name, result) {
        var data = {
            request_id: requestId,
            room_id: this.room.roomID,
            from_userid: this.stateCenter.idName,
            from_username: this.stateCenter.nickName,
            to_userid: dest_id_name,
        };
        if (result != undefined) {
            data['result'] = result;
        }
        return JSON.stringify(data);
    };
    LiveHandler.prototype.requestJoinLive = function (destIdName, success, error, resultCallback) {
        var requestId = this.stateCenter.getRequestId();
        var signalCmd = this.getSignalCmdContent(requestId, destIdName);
        if (resultCallback == undefined) {
            return false;
        }
        this.joinLiveCallbackMap[requestId] = resultCallback;
        this.sendSignalCmd(entity_1.ENUM_SIGNAL_SUB_CMD.joinLiveRequest, signalCmd, destIdName, success, error);
        return true;
    };
    //连麦信令
    LiveHandler.prototype.sendSignalCmd = function (cmd, signalMsg, dest_id_name, success, error) {
        var _this = this;
        if (!this.room.isLogin()) {
            this.logger.error(action_1.ZEGO_RTM_ACTION.LIVE_SEND_SIGNAL + ' state error');
            return;
        }
        var bodyData = {
            sub_cmd: cmd,
            signal_msg: signalMsg,
            dest_id_name: [dest_id_name],
        };
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.sendSignalCmd(bodyData, function (msg) {
            success && success(msg.header.seq);
        }, function (msg) {
            var err = error_1.errorCodeList.ROOM_INNER_ERROR;
            if (!msg.header || !msg.body) {
                msg.code && msg.msg && (err = msg);
                error && error(err, 0);
                return;
            }
            error && error(_this.rtm.getServerError(msg.body.err_code), msg.header.seq);
        }, this.room);
        this.logger.info(action_1.ZEGO_RTM_ACTION.LIVE_SEND_SIGNAL + ' call success' + cmd);
    };
    LiveHandler.prototype.inviteJoinLive = function (destIdName, success, error, resultCallback) {
        var requestId = this.stateCenter.getRequestId();
        var signalCmd = this.getSignalCmdContent(requestId, destIdName);
        if (resultCallback == undefined) {
            return false;
        }
        this.joinLiveCallbackMap[requestId] = resultCallback;
        this.sendSignalCmd(entity_1.ENUM_SIGNAL_SUB_CMD.joinLiveInvite, signalCmd, destIdName, success, error);
        return true;
    };
    LiveHandler.prototype.endJoinLive = function (destIdName, success, error) {
        var requestId = this.stateCenter.getRequestId();
        var signalCmd = this.getSignalCmdContent(requestId, destIdName);
        this.sendSignalCmd(entity_1.ENUM_SIGNAL_SUB_CMD.joinLiveStop, signalCmd, destIdName, success, error);
        return true;
    };
    LiveHandler.prototype.respondJoinLive = function (requestId, respondResult, success, error) {
        var dest_id_name = this.joinLiveRequestMap[requestId];
        if (!dest_id_name) {
            this.logger.info(action_1.ZEGO_RTM_ACTION.LIVE_RESPOND_JOIN_LIVE + ' no dest id name');
            return false;
        }
        var result = 0;
        if (respondResult === true)
            result = 1;
        var signalCmd = this.getSignalCmdContent(requestId, dest_id_name, result);
        this.sendSignalCmd(entity_1.ENUM_SIGNAL_SUB_CMD.joinLiveResult, signalCmd, dest_id_name, success, error);
        delete this.joinLiveRequestMap[requestId];
        return true;
    };
    // 连麦信令push
    LiveHandler.prototype.handlePushSignalMsg = function (msg) {
        var signalMsg = JSON.parse(msg.body.signal_msg);
        this.logger.info(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' hpsm= ', signalMsg);
        switch (msg.body.sub_cmd) {
            case entity_1.ENUM_PUSH_SIGNAL_SUB_CMD.pushJoinLiveRequest:
                this.handlePushJoinLiveRequestMsg(signalMsg);
                break;
            case entity_1.ENUM_PUSH_SIGNAL_SUB_CMD.pushJoinLiveResult:
                this.handlePushJoinLiveResultMsg(signalMsg);
                break;
            case entity_1.ENUM_PUSH_SIGNAL_SUB_CMD.pushJoinLiveInvite:
                this.handlePushJoinLiveInviteMsg(signalMsg);
                break;
            case entity_1.ENUM_PUSH_SIGNAL_SUB_CMD.pushJoinLiveStop:
                this.handlePushJoinLiveStopMsg(signalMsg);
        }
    };
    //请求连麦push
    LiveHandler.prototype.handlePushJoinLiveRequestMsg = function (signalMsg) {
        var requestId = signalMsg.request_id;
        if (typeof requestId !== 'string') {
            this.logger.error(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' no requestId');
            return;
        }
        var dest_id_name = signalMsg.from_userid;
        if (typeof dest_id_name !== 'string') {
            this.logger.error(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' no from user');
            return;
        }
        this.joinLiveRequestMap[requestId] = dest_id_name;
        this.onRecvJoinLiveRequest(requestId, signalMsg.from_userid, signalMsg.from_username, signalMsg.room_id);
        this.logger.info(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' onRecvJoinLiveRequest ' + dest_id_name);
    };
    LiveHandler.prototype.onRecvJoinLiveRequest = function (requestId, from_userid, from_username, roomid) {
        this.stateCenter.actionListener('recvJoinLiveRequest', requestId, from_userid, from_username, roomid);
    };
    LiveHandler.prototype.handlePushJoinLiveInviteMsg = function (signalMsg) {
        var requestId = signalMsg.request_id;
        if (typeof requestId !== 'string') {
            this.logger.error(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + 'no requestId');
            return;
        }
        var dest_id_name = signalMsg.from_userid;
        if (typeof dest_id_name !== 'string') {
            this.logger.error(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' no from user');
            return;
        }
        this.joinLiveRequestMap[requestId] = dest_id_name;
        this.onRecvInviteJoinLiveRequest(requestId, signalMsg.from_userid, signalMsg.from_username, signalMsg.room_id);
        this.logger.info(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' onRecvInviteJoinLiveRequest ' + dest_id_name);
    };
    LiveHandler.prototype.onRecvInviteJoinLiveRequest = function (requestId, from_userid, from_username, roomid) {
        this.stateCenter.actionListener('recvInviteJoinLiveRequest', requestId, from_userid, from_username, roomid);
    };
    LiveHandler.prototype.handlePushJoinLiveResultMsg = function (signalMsg) {
        var requestId = signalMsg.request_id;
        if (typeof requestId !== 'string') {
            this.logger.error(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' no requestId');
            return;
        }
        var result = signalMsg.result;
        if (result == undefined) {
            this.logger.info(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' no result');
            return;
        }
        var respondResult = result == 1 ? true : false;
        if (this.joinLiveCallbackMap[requestId]) {
            var result_callback = this.joinLiveCallbackMap[requestId];
            if (!result_callback) {
                this.logger.info(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' no callback');
                return;
            }
            this.logger.info(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' joinLiveRequest/invite result ' + respondResult);
            delete this.joinLiveCallbackMap[requestId];
            result_callback(respondResult, signalMsg.from_userid, signalMsg.from_username);
        }
    };
    /*
     *    "zb.lh.hpjlsm": "ZegoExpressEngine.base.LiveHandler.handlePushJoinLiveStopMsg",
     */
    LiveHandler.prototype.handlePushJoinLiveStopMsg = function (signalMsg) {
        var requestId = signalMsg.request_id;
        if (typeof requestId !== 'string') {
            this.logger.error(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' no requestId');
            return;
        }
        this.logger.info(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' onRecvEndJoinLiveCommand ' + signalMsg.from_userid);
        this.onRecvEndJoinLiveCommand(requestId, signalMsg.from_userid, signalMsg.from_username, signalMsg.room_id);
    };
    LiveHandler.prototype.onRecvEndJoinLiveCommand = function (requestId, from_userid, from_username, roomid) {
        this.stateCenter.actionListener('recvEndJoinLiveCommand', requestId, from_userid, from_username, roomid);
    };
    return LiveHandler;
}());
exports.LiveHandler = LiveHandler;


/***/ })

/******/ });
});

/***/ }),

/***/ "../zego_express_web_rtm/dist/message/index.js":
/*!*****************************************************!*\
  !*** ../zego_express_web_rtm/dist/message/index.js ***!
  \*****************************************************/
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_573__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_573__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_573__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_573__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_573__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_573__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_573__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__nested_webpack_require_573__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __nested_webpack_require_573__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__nested_webpack_require_573__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_573__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_573__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_573__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_573__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_573__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_573__(__nested_webpack_require_573__.s = "./sdk/src/modules/message/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};


/***/ }),

/***/ "./sdk/src/modules/message/action.ts":
/*!*******************************************!*\
  !*** ./sdk/src/modules/message/action.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ZEGO_RTM_ACTION = void 0;
var ZEGO_RTM_ACTION;
(function (ZEGO_RTM_ACTION) {
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_SEND_CUSTOM"] = "zm.scc";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_SEND_BCM"] = "zm.sbcm";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_SEND_RLM"] = "zm.srlm";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_SEND_BRM"] = "zm.sbrm";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_SEND_RAM"] = "zm.sram";
    ZEGO_RTM_ACTION["MESSAGE_SEND_RELIABLE"] = "zm.msg.sdr";
    ZEGO_RTM_ACTION["MESSAGE_FETCH_RELIABLE"] = "zm.msg.frm";
    ZEGO_RTM_ACTION["MESSAGE_RELIABLE_RSP"] = "zm.msg.rlr";
    ZEGO_RTM_ACTION["MESSAGE_RELIABLE_PUSH"] = "zm.msg.rps";
    ZEGO_RTM_ACTION["MESSAGE_SEND_ROOM_MSG"] = "zm.msg.srm";
    ZEGO_RTM_ACTION["MESSAGE_SEND_CUSTOM_MSG"] = "zm.msg.scm";
    ZEGO_RTM_ACTION["MESSAGE_SEND_BIG_MSG"] = "zm.msg.sbm";
    ZEGO_RTM_ACTION["MESSAGE_BIG_MSG_PUSH"] = "zm.msg.bps";
    ZEGO_RTM_ACTION["MESSAGE_SEND_RELAY_MSG"] = "zm.msg.slm";
    ZEGO_RTM_ACTION["SERVICE_PUSH"] = "zm.sv.ps";
})(ZEGO_RTM_ACTION = exports.ZEGO_RTM_ACTION || (exports.ZEGO_RTM_ACTION = {}));


/***/ }),

/***/ "./sdk/src/modules/message/content.ts":
/*!********************************************!*\
  !*** ./sdk/src/modules/message/content.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_46099__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.modulePros = exports.initMessageHandler = exports.servicePros = exports.handlePushMsg = exports.handleBigImMsgRsp = exports.handlePushTransMsg = exports.handlePushMergeMsg = exports.handlePushCustomMsg = exports.handlePushRoomMsg = exports.rtmPros = void 0;
// @ts-nocheck
var action_1 = __nested_webpack_require_46099__(/*! ./action */ "./sdk/src/modules/message/action.ts");
var log_event_1 = __nested_webpack_require_46099__(/*! ./log.event */ "./sdk/src/modules/message/log.event.ts");
var entity_1 = __nested_webpack_require_46099__(/*! ./entity */ "./sdk/src/modules/message/entity.ts");
var messageHandler_1 = __nested_webpack_require_46099__(/*! ./messageHandler */ "./sdk/src/modules/message/messageHandler.ts");
var error_1 = __nested_webpack_require_46099__(/*! ./error */ "./sdk/src/modules/message/error.ts");
function _sendBroadcastMessage(roomID, message, category, type) {
    var _this = this;
    if (category === void 0) { category = 1; }
    if (type === void 0) { type = 1; }
    return new Promise(function (resolve, reject) {
        // --log event start
        var reportSeq = _this.getReportSeq();
        _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendRoomMessage.event);
        var _a = _this.proxyRes(_this.dataReport, reportSeq, resolve, reject), interResolve = _a.interResolve, interReject = _a.interReject;
        if (typeof roomID !== 'string' || roomID == '') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_BCM + ' roomid must be string and not empty');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendRoomMessage.error.INPUT_PARAM, ' param roomID error');
            return;
        }
        if (message === undefined || message == '') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_BCM + ' message is empty');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendRoomMessage.error.IM_CONTENT_NULL);
            return;
        }
        if (typeof message !== 'string') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_BCM + ' message must be string');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendRoomMessage.error.INPUT_PARAM, ' param message error');
            return;
        }
        if (message.length > entity_1.MAX_MESSAGE_LENGTH) {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_BCM + ' message too long');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendRoomMessage.error.IM_CONTENT_TOO_LONG);
            return;
        }
        var room = _this.stateCenter.type == 'PUBLIC' ? _this.getRoomModules(roomID) : _this.stateCenter.priModules;
        if (!room) {
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendRoomMessage.error.ROOM_NOT_EXIST);
            return;
        }
        _this.dataReport.addMsgInfo(reportSeq, {
            room_sid: log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendRoomMessage.room_sid(room.sessionID),
        });
        room.messageHandler.sendRoomMsg(category, type, roomID, message, interResolve, interReject);
    });
}
function sendBroadcastMessage(roomID, message) {
    var _this = this;
    return new Promise(function (resolve, reject) {
        _sendBroadcastMessage
            .call(_this, roomID, message)
            .then(function (res) {
            resolve({ errorCode: res.errorCode, messageID: res.messageID, extendedData: res.extendedData });
        })
            .catch(function (err) {
            reject(err);
        });
    });
}
function _sendCustomCommand(roomID, command, toUserList) {
    var _this = this;
    return new Promise(function (resolve, reject) {
        //--- event log start
        var reportSeq = _this.getReportSeq();
        _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendCustomCommand.event);
        var _a = _this.proxyRes(_this.dataReport, reportSeq, resolve, reject), interResolve = _a.interResolve, interReject = _a.interReject;
        //--- event log end
        if (typeof roomID !== 'string' || roomID == '') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_CUSTOM + ' roomid must be string and not empty');
            interReject(error_1.errorCodeList.INPUT_PARAM, ' param roomID error');
            return;
        }
        if (!(toUserList instanceof Array) || toUserList.find(function (user) { return typeof user !== 'string'; })) {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_CUSTOM + ' dstMembers must be string array');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendCustomCommand.error.INPUT_PARAM, ' param toUserList error');
            return;
        }
        if (_this.stateCenter.type === 'PUBLIC' && typeof command !== 'string' && typeof command !== 'object') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_CUSTOM + ' custom content must be a non empty string or object');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendCustomCommand.error.INPUT_PARAM, ' param command error');
            return;
        }
        if (_this.stateCenter.type === 'PRIVATE' && typeof command !== 'string') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_CUSTOM + ' custom content must be a not empty string');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendCustomCommand.error.INPUT_PARAM, ' param command error');
            return;
        }
        if (typeof command === 'string' && command.length > entity_1.MAX_MESSAGE_LENGTH) {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_CUSTOM + ' command too long');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendCustomCommand.error.IM_CONTENT_TOO_LONG);
            return;
        }
        var room = _this.stateCenter.type == 'PUBLIC' ? _this.getRoomModules(roomID) : _this.stateCenter.priModules;
        if (!room) {
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendCustomCommand.error.ROOM_NOT_EXIST);
            return;
        }
        _this.dataReport.addMsgInfo(reportSeq, {
            room_sid: log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendCustomCommand.room_sid(room.sessionID),
        });
        room.messageHandler.sendCustomCommand(toUserList, command, interResolve, interReject);
    });
}
function sendCustomCommand(roomID, command, toUserList) {
    var _this = this;
    return new Promise(function (resolve, reject) {
        _sendCustomCommand
            .call(_this, roomID, command, toUserList)
            .then(function (res) {
            resolve({ errorCode: res.errorCode, extendedData: res.extendedData });
        })
            .catch(function (err) {
            reject(err);
        });
    });
}
function _sendBarrageMessage(roomID, message, category, type) {
    var _this = this;
    if (category === void 0) { category = 1; }
    if (type === void 0) { type = 1; }
    return new Promise(function (resolve, reject) {
        var reportSeq = _this.getReportSeq();
        _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTMLogEvent.kZegoTaskLiveSendRoomBigIM.event);
        var _a = _this.proxyRes(_this.dataReport, reportSeq, resolve, reject), interResolve = _a.interResolve, interReject = _a.interReject;
        if (typeof roomID !== 'string' || roomID == '') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_BRM + 'roomid must be string and not empty');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveSendRoomBigIM.error.INPUT_PARAM, ' param roomID error');
            return;
        }
        if (message === undefined || message == '') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_BRM + ' message is empty');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveSendRoomBigIM.error.IM_CONTENT_NULL);
            return;
        }
        if (typeof message !== 'string') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_BRM + ' message must be string');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveSendRoomBigIM.error.INPUT_PARAM, ' param message error');
            return;
        }
        if (message.length > entity_1.MAX_MESSAGE_LENGTH) {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_BRM + ' message too long');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveSendRoomBigIM.error.IM_CONTENT_TOO_LONG);
            return;
        }
        var room = _this.stateCenter.type == 'PUBLIC' ? _this.getRoomModules(roomID) : _this.stateCenter.priModules;
        if (!room) {
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveSendRoomBigIM.error.ROOM_NOT_EXIST);
            return;
        }
        _this.dataReport.addMsgInfo(reportSeq, {
            room_sid: log_event_1.ZegoRTMLogEvent.kZegoTaskLiveSendRoomBigIM.room_sid(room.sessionID),
        });
        room.messageHandler.sendBigRoomMessage(category, type, roomID, message, interResolve, interReject);
    });
}
function sendBarrageMessage(roomID, message) {
    var _this = this;
    return new Promise(function (resolve, reject) {
        _sendBarrageMessage
            .call(_this, roomID, message)
            .then(function (res) {
            resolve({ errorCode: res.errorCode, messageID: res.messageID, extendedData: res.extendedData });
        })
            .catch(function (err) {
            reject(err);
        });
    });
}
function _setRoomExtraInfo(roomID, type, data) {
    var _this = this;
    return new Promise(function (resolve, reject) {
        // TODO 长度检测
        var reportSeq = _this.getReportSeq();
        _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendReliableMessage.event);
        var _a = _this.proxyRes(_this.dataReport, reportSeq, resolve, reject), interResolve = _a.interResolve, interReject = _a.interReject;
        if (typeof roomID !== 'string' || roomID == '') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_BCM + ' roomid must be string and not empty');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendRoomMessage.error.INPUT_PARAM, ' param roomID error');
            return;
        }
        if (!type || typeof type !== 'string') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_RLM + ' type must be string');
            interReject({ errorCode: log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendReliableMessage.error.INPUT_PARAM.code });
            return;
        }
        if (type.length > entity_1.MAX_TRANS_TYPE_LENGTH) {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_RLM + ' type is too long');
            interReject({ errorCode: log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendReliableMessage.error.INPUT_PARAM.code });
            return;
        }
        if (!data || typeof data !== 'string') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_RLM + ' data must be string');
            interReject({ errorCode: log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendReliableMessage.error.INPUT_PARAM.code });
            return;
        }
        if (data.length > entity_1.MAX_TRANS_DATA_LENGTH) {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_RLM + ' type is too long');
            interReject({ errorCode: log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendReliableMessage.error.INPUT_PARAM.code });
            return;
        }
        // const interResolve = (seq: number): void => {
        //     resolve({ errorCode: 0 });
        // };
        var room = _this.stateCenter.type == 'PUBLIC' ? _this.getRoomModules(roomID) : _this.stateCenter.priModules;
        if (!room) {
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendReliableMessage.error.ROOM_NOT_EXIST);
            return;
        }
        _this.dataReport.addMsgInfo(reportSeq, {
            room_sid: log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendReliableMessage.room_sid(room.sessionID),
        });
        room.messageHandler.sendReliableMessage(type, data, interResolve, interReject);
    });
}
function setRoomExtraInfo(roomID, type, data) {
    return _setRoomExtraInfo.call(this, roomID, type, data);
}
function sendRelayMessage(type, data, success, error, roomID) {
    var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
    if (!room) {
        error && error(error_1.errorCodeList.ROOM_NOT_EXIST, 0);
        return;
    }
    room.messageHandler.sendRelayMessage(type, data, success, error);
}
exports.rtmPros = {
    _sendBroadcastMessage: _sendBroadcastMessage,
    sendBroadcastMessage: sendBroadcastMessage,
    _sendCustomCommand: _sendCustomCommand,
    sendCustomCommand: sendCustomCommand,
    _sendBarrageMessage: _sendBarrageMessage,
    sendBarrageMessage: sendBarrageMessage,
    _setRoomExtraInfo: _setRoomExtraInfo,
    setRoomExtraInfo: setRoomExtraInfo,
    sendRelayMessage: sendRelayMessage,
};
function handlePushRoomMsg(msg) {
    var _a = this.handlePushMsg(msg), room = _a[0], msg = _a[1];
    room.messageHandler.handlePushRoomMsg(msg);
}
exports.handlePushRoomMsg = handlePushRoomMsg;
function handlePushCustomMsg(msg) {
    var _a = this.handlePushMsg(msg), room = _a[0], msg = _a[1];
    room.messageHandler.handlePushCustomMsg(msg);
}
exports.handlePushCustomMsg = handlePushCustomMsg;
function handlePushMergeMsg(msg) {
    var _a;
    var roomID = (_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id;
    var room = this.stateCenter.type == 'PUBLIC' ? this.rtm.getRoomModules(roomID) : this.stateCenter.priModules;
    if (!room) {
        this.logger.error(action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + ' room no found ignore ' + JSON.stringify(msg));
        return;
    }
    room.messageHandler.handlePushMergeMsg(msg);
}
exports.handlePushMergeMsg = handlePushMergeMsg;
function handlePushTransMsg(msg) {
    var _a = this.handlePushMsg(msg), room = _a[0], msg = _a[1];
    room.messageHandler.handlePushTransMsg(msg);
}
exports.handlePushTransMsg = handlePushTransMsg;
function handleBigImMsgRsp(msg) {
    var _a;
    var roomID = (_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id;
    var room = this.stateCenter.type == 'PUBLIC' ? this.rtm.getRoomModules(roomID) : this.stateCenter.priModules;
    if (!room) {
        this.logger.error(action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + ' room no found ignore ' + JSON.stringify(msg));
        return;
    }
    room.messageHandler.handleBigImMsgRsp(msg);
}
exports.handleBigImMsgRsp = handleBigImMsgRsp;
function handlePushMsg(msg) {
    var _a;
    var roomID = (_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id;
    var room = this.rtm.getRoomModules(roomID);
    if (!room) {
        this.logger.error(action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + ' room no found ignore ' + JSON.stringify(msg));
        return;
    }
    // if (this.stateCenter.useNetAgent) {
    //     msg.body = msg.msg_body;
    //     delete msg.msg_body;
    // }
    return [room, msg];
}
exports.handlePushMsg = handlePushMsg;
exports.servicePros = {
    handlePushRoomMsg: handlePushRoomMsg,
    handlePushCustomMsg: handlePushCustomMsg,
    handlePushMergeMsg: handlePushMergeMsg,
    handlePushTransMsg: handlePushTransMsg,
    handleBigImMsgRsp: handleBigImMsgRsp,
    handlePushMsg: handlePushMsg,
};
function initMessageHandler() {
    this.messageHandler = new messageHandler_1.MessageHandler(this.logger, this.stateCenter, this.dataReport, this.service, this.liveRoomHandler, this.rtm, this);
}
exports.initMessageHandler = initMessageHandler;
exports.modulePros = {
    initMessageHandler: initMessageHandler,
};


/***/ }),

/***/ "./sdk/src/modules/message/entity.ts":
/*!*******************************************!*\
  !*** ./sdk/src/modules/message/entity.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_MESSAGE_LENGTH = exports.MAX_TRANS_DATA_LENGTH = exports.MAX_TRANS_TYPE_LENGTH = exports.ERROR_CODES = void 0;
exports.ERROR_CODES = {
    FETCH_TRANS_UNKNOWN_CHANNEL: 1000001108,
    FETCH_TRANS_UNKNOWN_TYPE: 1000001109,
    FETCH_TRANS_WRONG_SEQ: 1000001110,
};
exports.MAX_TRANS_TYPE_LENGTH = 128;
exports.MAX_TRANS_DATA_LENGTH = 1024 * 4;
exports.MAX_MESSAGE_LENGTH = 1024;


/***/ }),

/***/ "./sdk/src/modules/message/error.ts":
/*!******************************************!*\
  !*** ./sdk/src/modules/message/error.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.errorCodeList = void 0;
exports.errorCodeList = {
    INPUT_PARAM: {
        code: 1100001,
        msg: 'input parm error.',
    },
    TIMEOUT: {
        code: 1100002,
        msg: 'network timeout.',
    },
    IM_CONTENT_NULL: {
        code: 1009001,
        msg: 'message content is empty',
    },
    IM_CONTENT_TOO_LONG: {
        code: 1009002,
        msg: 'message content is too long',
    },
    IM_SEND_FAILED: {
        code: 1009010,
        msg: 'failed to send message',
    },
    ROOM_NOT_EXIST: {
        code: 1002014,
        msg: 'room not exist',
    },
    ROOM_INNER_ERROR: {
        code: 1002099,
        msg: 'room inner error',
    },
    TRANS_FREQUENTLY: {
        code: 1102022,
        msg: 'trans send frequently',
    },
    FREQ_LIMITED: {
        code: 1109001,
        msg: 'frequency limited.',
    },
};


/***/ }),

/***/ "./sdk/src/modules/message/index.ts":
/*!******************************************!*\
  !*** ./sdk/src/modules/message/index.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_64522__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//@ts-nocheck
var content_1 = __nested_webpack_require_64522__(/*! ./content */ "./sdk/src/modules/message/content.ts");
exports.default = {
    type: 'message',
    install: function (rtm, liveRoomModule, service, liveRoomHandler, priLiveRoomModule, priService) {
        for (var key in content_1.rtmPros) {
            Object.defineProperty(rtm.prototype, key, {
                value: content_1.rtmPros[key],
                writable: false,
            });
        }
        for (var key in content_1.servicePros) {
            Object.defineProperty(service.prototype, key, {
                value: content_1.servicePros[key],
                writable: false,
            });
            Object.defineProperty(priService.prototype, key, {
                value: content_1.servicePros[key],
                writable: false,
            });
            Object.defineProperty(liveRoomHandler.prototype, key, {
                value: content_1.servicePros[key],
                writable: false,
            });
        }
        for (var key in content_1.modulePros) {
            Object.defineProperty(liveRoomModule.prototype, key, {
                value: content_1.modulePros[key],
                writable: false,
            });
            Object.defineProperty(priLiveRoomModule.prototype, key, {
                value: content_1.modulePros[key],
                writable: false,
            });
        }
    },
};


/***/ }),

/***/ "./sdk/src/modules/message/log.event.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/message/log.event.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_66316__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ZegoRTMLogEvent = void 0;
var error_1 = __nested_webpack_require_66316__(/*! ./error */ "./sdk/src/modules/message/error.ts");
var getItem = function (item) { return item; };
exports.ZegoRTMLogEvent = {
    kZegoTaskLiveSendRoomBigIM: {
        event: '/liveroom/send_big_room_message',
        room_sid: getItem,
        error: {
            INPUT_PARAM: error_1.errorCodeList.INPUT_PARAM,
            IM_CONTENT_NULL: error_1.errorCodeList.IM_CONTENT_NULL,
            IM_CONTENT_TOO_LONG: error_1.errorCodeList.IM_CONTENT_TOO_LONG,
            ROOM_NOT_EXIST: error_1.errorCodeList.ROOM_NOT_EXIST,
        },
    },
    kZegoTaskLiveRoomSendCustomCommand: {
        event: '/liveroom/send_custom_command',
        room_sid: getItem,
        error: {
            INPUT_PARAM: error_1.errorCodeList.INPUT_PARAM,
            IM_CONTENT_NULL: error_1.errorCodeList.IM_CONTENT_NULL,
            IM_CONTENT_TOO_LONG: error_1.errorCodeList.IM_CONTENT_TOO_LONG,
            ROOM_NOT_EXIST: error_1.errorCodeList.ROOM_NOT_EXIST,
        },
    },
    kZegoTaskLiveRoomSendRoomMessage: {
        event: '/liveroom/send_room_message',
        room_sid: getItem,
        error: {
            INPUT_PARAM: error_1.errorCodeList.INPUT_PARAM,
            IM_CONTENT_NULL: error_1.errorCodeList.IM_CONTENT_NULL,
            IM_CONTENT_TOO_LONG: error_1.errorCodeList.IM_CONTENT_TOO_LONG,
            ROOM_NOT_EXIST: error_1.errorCodeList.ROOM_NOT_EXIST,
        },
    },
    kZegoTaskLiveRoomSendReliableMessage: {
        event: '/liveroom/send_reliable_message',
        room_sid: getItem,
        error: {
            INPUT_PARAM: error_1.errorCodeList.INPUT_PARAM,
            TRANS_FREQUENTLY: error_1.errorCodeList.TRANS_FREQUENTLY,
            ROOM_NOT_EXIST: error_1.errorCodeList.ROOM_NOT_EXIST,
        },
    },
    kZegoTaskLiveGetRoomBigIM: {
        event: '/liveroom/get_big_room_message',
    },
    kZegoTaskLiveRoomGetRoomMessage: {
        event: '/liveroom/get_room_message',
        room_sid: getItem,
    },
    kZegoTaskLiveRoomGetCustomCommand: {
        event: '/liveroom/get_custom_command',
    },
};


/***/ }),

/***/ "./sdk/src/modules/message/messageHandler.ts":
/*!***************************************************!*\
  !*** ./sdk/src/modules/message/messageHandler.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_68829__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageHandler = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
var error_1 = __nested_webpack_require_68829__(/*! ./error */ "./sdk/src/modules/message/error.ts");
var action_1 = __nested_webpack_require_68829__(/*! ./action */ "./sdk/src/modules/message/action.ts");
var log_event_1 = __nested_webpack_require_68829__(/*! ./log.event */ "./sdk/src/modules/message/log.event.ts");
var entity_1 = __nested_webpack_require_68829__(/*! ./entity */ "./sdk/src/modules/message/entity.ts");
var long_1 = __importDefault(__nested_webpack_require_68829__(/*! long */ "./node_modules/long/src/long.js"));
var MessageHandler = /** @class */ (function () {
    function MessageHandler(logger, stateCenter, dataReport, service, liveRoomHandler, rtm, room) {
        var _this = this;
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.dataReport = dataReport;
        this.service = service;
        this.liveRoomHandler = liveRoomHandler;
        this.rtm = rtm;
        this.room = room;
        this.sendRoomMsgTime = 0; //上一次发送房间消息时间
        this.sendRoomMsgInterval = 500; //发送房间消息最多500毫秒发送一次
        this.bigImCallbackMap = {};
        this.bigImLastTimeIndex = 0;
        this.bigIMmessageList = [];
        this.bigImTimer = null;
        this.relayTimer = null;
        this.serverTimeOffset = 0;
        this.datiTimeWindow = 0;
        this.bigimTimeWindow = 0;
        this.isReliable = false;
        this.transSeqMap = {};
        this.onRecvReliableMessage = function (transResults) {
            var extraInfoList = transResults.map(function (result) {
                return {
                    key: result.trans_type,
                    value: result.trans_data,
                    updateUser: {
                        userID: result.trans_idname,
                        userName: result.trans_nickname,
                    },
                    updateTime: long_1.default.isLong(result.trans_send_time) ? result.trans_send_time.toNumber() : result.trans_send_time,
                };
            });
            _this.stateCenter.actionListener('roomExtraInfoUpdate', _this.room.roomID, extraInfoList);
            transResults.forEach(function (result) {
                _this.stateCenter.actionListener('recvReliableMessage', result.trans_type, result.trans_seq, result.trans_data);
            });
        };
        // *********************************** 弹幕消息 end************************************************//
        // *********************************** relay消息 start************************************************//
        this.realyMessageList = [];
    }
    // *********************************** 房间附加消息 start************************************************//
    MessageHandler.prototype.loginRsp = function (msg) {
        var _this = this;
        //get time stamp & window
        if (msg.body.ret_timestamp != undefined && typeof msg.body.ret_timestamp == 'string') {
            var serverTime = parseFloat(msg.body.ret_timestamp);
            if (serverTime == 0) {
                this.serverTimeOffset = 0;
            }
            else {
                this.serverTimeOffset = msg.body.ret_timestamp - new Date().getTime();
            }
        }
        if (msg.body.bigim_time_window && typeof msg.body.bigim_time_window == 'number') {
            this.bigimTimeWindow = msg.body.bigim_time_window;
        }
        if (msg.body.dati_time_window && typeof msg.body.dati_time_window == 'number') {
            this.datiTimeWindow = msg.body.dati_time_window;
        }
        // fetch_trans
        if (msg.body.trans_seqs) {
            for (var i = 0; i < msg.body.trans_seqs.length; i++) {
                var trans_channel = msg.body.trans_seqs[i].trans_channel;
                var trans_seq_array = msg.body.trans_seqs[i].trans_seq_array;
                trans_seq_array = trans_seq_array.filter(function (item) {
                    var type = item.trans_type, seq = item.trans_seq;
                    if (!_this.transSeqMap[type] || _this.transSeqMap[type].seq < seq) {
                        return true;
                    }
                    else {
                        return false;
                    }
                });
                trans_seq_array.length > 0 && this.fetchReliableMessage(trans_channel, trans_seq_array);
            }
        }
    };
    MessageHandler.prototype.sendReliableMessage = function (type, data, success, error) {
        var _this = this;
        this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_RELIABLE + ' call');
        if (this.isReliable) {
            this.logger.error(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_RELIABLE + ' send too often');
            error(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendReliableMessage.error.TRANS_FREQUENTLY);
            return;
        }
        if (!this.transSeqMap[type]) {
            this.transSeqMap[type] = {
                seq: 0,
            };
        }
        var body = {
            trans_type: type,
            trans_data: data,
            trans_local_seq: this.transSeqMap[type].seq,
            trans_channel: 'clt',
        };
        this.isReliable = true;
        var sucCallBack = function (msg) {
            //update seq
            _this.transSeqMap[type].seq = msg.body.trans_seq;
            _this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_RELIABLE + ' trans ' + type + ' seq ' + msg.body.trans_seq);
            _this.isReliable = false;
            success({ seq: msg.header.seq, errorCode: 0 });
        };
        var errCallBack = function (msg) {
            var _err = error_1.errorCodeList.ROOM_INNER_ERROR;
            if (msg.body && msg.body.err_code) {
                _err = _this.rtm.getServerError(msg.body.err_code);
                _this.logger.error(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_ROOM_MSG + '  ' + _err.msg);
            }
            else if (msg == error_1.errorCodeList.TIMEOUT) {
                _err = error_1.errorCodeList.IM_SEND_FAILED;
            }
            else {
                _err = msg;
            }
            _this.isReliable = false;
            error(_err);
        };
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.sendReliableMessage(body, sucCallBack, errCallBack, this.room);
    };
    MessageHandler.prototype.fetchReliableMessage = function (trans_channel, fetch_array) {
        var _this = this;
        var data = {
            trans_channel: trans_channel,
            fetch_array: fetch_array,
        };
        var callBack = function (msg) {
            _this.handleFetchTransRsp(msg);
        };
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.fetchReliableMessage(data, callBack, callBack, this.room);
        this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_FETCH_RELIABLE + ' call success');
    };
    //fetch trans 回包
    MessageHandler.prototype.handleFetchTransRsp = function (msg) {
        if (msg.body && msg.body.err_code != 0) {
            this.logger.error(action_1.ZEGO_RTM_ACTION.MESSAGE_RELIABLE_RSP + ' trans send error ' + msg.body.err_code);
            return;
        }
        if (!msg.header || !msg.body) {
            this.logger.error(action_1.ZEGO_RTM_ACTION.MESSAGE_RELIABLE_RSP + ' trans send error ' + msg);
            return;
        }
        var trans_fetch_results = msg.body.trans_fetch_results;
        var transResults = [];
        if (Array.isArray(trans_fetch_results) && trans_fetch_results.length > 0) {
            for (var i = 0; i < trans_fetch_results.length; i++) {
                var trans_fetch_result = trans_fetch_results[i];
                if (trans_fetch_result.err_code === entity_1.ERROR_CODES.FETCH_TRANS_UNKNOWN_TYPE) {
                    this.logger.warn(action_1.ZEGO_RTM_ACTION.MESSAGE_RELIABLE_RSP +
                        ' fetch trans unknown type ' +
                        trans_fetch_result.err_code);
                    continue;
                }
                var type = trans_fetch_result.trans_type;
                var seq = trans_fetch_result.trans_seq;
                if (trans_fetch_result.err_code === entity_1.ERROR_CODES.FETCH_TRANS_WRONG_SEQ) {
                    this.logger.warn(action_1.ZEGO_RTM_ACTION.MESSAGE_RELIABLE_RSP +
                        ' fetch trans seq is wrong ' +
                        trans_fetch_result.err_code);
                    this.transSeqMap[type] = {
                        seq: seq,
                    };
                    continue;
                }
                if (!this.transSeqMap[type] || this.transSeqMap[type].seq < seq) {
                    this.transSeqMap[type] = {
                        seq: seq,
                    };
                    transResults.push(trans_fetch_result);
                }
                else {
                    this.logger.warn(action_1.ZEGO_RTM_ACTION.MESSAGE_RELIABLE_RSP + ' fetch trans seq wrong');
                }
                transResults.length > 0 && this.onRecvReliableMessage(transResults);
            }
        }
    };
    MessageHandler.prototype.handlePushTransMsg = function (msg) {
        var type = msg.body.trans_type;
        var seq = msg.body.trans_seq;
        if (!this.transSeqMap[type] || this.transSeqMap[type].seq < seq) {
            this.transSeqMap[type] = {
                seq: seq,
            };
            this.onRecvReliableMessage([msg.body]);
        }
        else {
            this.logger.warn(action_1.ZEGO_RTM_ACTION.MESSAGE_RELIABLE_PUSH + ' trans seq wrong');
        }
        this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_RELIABLE_PUSH + ' trans ' + type + ' seq ' + seq);
    };
    // *********************************** 房间附加消息 edn************************************************//
    // *********************************** 房间消息 start************************************************//
    MessageHandler.prototype.sendRoomMsg = function (msg_category, type, room_id, msg_content, success, error) {
        var _this = this;
        // 不是处于登录状态
        if (!this.room.isLogin()) {
            this.logger.error(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_ROOM_MSG + ' state error');
            return false;
        }
        var timestamp = Date.parse(new Date() + '');
        if (this.sendRoomMsgTime > 0 && this.sendRoomMsgTime + this.sendRoomMsgInterval > timestamp) {
            this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_ROOM_MSG + ' freq error');
            if (error) {
                error(error_1.errorCodeList.FREQ_LIMITED, 0, msg_category, msg_content);
            }
            return false;
        }
        this.sendRoomMsgTime = timestamp;
        var bodyData = {
            msg_category: msg_category,
            msg_type: 1,
            msg_priority: 1,
            msg_content: msg_content,
        };
        var sucCallBack = function (msg) {
            success({ seq: msg.header.seq, errorCode: 0, messageID: msg.body.msg_id });
        };
        var errCallBack = function (msg) {
            var _a;
            var err = error_1.errorCodeList.ROOM_INNER_ERROR;
            var msgID = 0;
            if (!msg.header || !msg.body) {
                msg.code && msg.msg && (err = msg);
                error({ seq: 0, errorCode: err.code, messageID: 0 });
                return;
            }
            _a = [
                _this.rtm.getServerError(_this.stateCenter.type == 'PRIVATE' ? msg.body.code : msg.body.err_code),
                msg.body.msg_id,
            ], err = _a[0], msgID = _a[1];
            _this.logger.error(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_ROOM_MSG + '  ' + err.msg);
            if (err == error_1.errorCodeList.TIMEOUT) {
                err = error_1.errorCodeList.IM_SEND_FAILED;
            }
            error({ seq: msg.header.seq, errorCode: err.code, messageID: msgID });
        };
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.sendRoomMsg(bodyData, sucCallBack, errCallBack, this.room);
        this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_ROOM_MSG + '  call success');
        return true;
    };
    MessageHandler.prototype.handlePushRoomMsg = function (msg) {
        var _this = this;
        var roomSid = '';
        if (this.stateCenter.useNetAgent) {
            roomSid = this.room.roomSessionID;
        }
        else {
            roomSid = msg.header.session_id;
        }
        var seq = this.rtm.getReportSeq();
        this.dataReport.newReport(seq);
        this.dataReport.addMsgInfo(seq, {
            room_sid: log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomGetRoomMessage.room_sid(roomSid),
        });
        var chatData = [];
        if (this.stateCenter.useNetAgent) {
            msg.body.msg_data.forEach(function (data) {
                var chatInfo = {
                    fromUser: {
                        userID: data.id_name,
                        userName: data.nick_name,
                    },
                    message: data.msg_content,
                    sendTime: data.send_time.toNumber(),
                    messageID: data.msg_id.toNumber(),
                };
                chatData.push(chatInfo);
            });
            msg.body.server_msg_id = msg.body.server_msg_id.toNumber();
            msg.body.ret_msg_id = msg.body.ret_msg_id.toNumber();
        }
        else {
            msg.body.chat_data.forEach(function (data) {
                var chatInfo = {
                    fromUser: {
                        userID: data.id_name,
                        userName: data.nick_name,
                    },
                    message: data.msg_content,
                    sendTime: data.send_time,
                    messageID: data.msg_id,
                };
                chatData.push(chatInfo);
                _this.dataReport.addMsgInfo(seq, {
                    from_msg_id: data.id_name,
                });
            });
        }
        this.dataReport.uploadReport(seq, log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomGetRoomMessage.event);
        this.stateCenter.actionListener('IMRecvBroadcastMessage', this.room.roomID, chatData);
        this.stateCenter.actionListener('_recvRoomMsg', msg.body.chat_data, msg.body.server_msg_id, msg.body.ret_msg_id);
    };
    // *********************************** 房间消息 end************************************************//
    // *********************************** 自定义消息 start************************************************//
    MessageHandler.prototype.sendCustomCommand = function (dstMembers, customContent, success, error) {
        var _this = this;
        if (!this.room.isLogin()) {
            this.logger.error(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_CUSTOM_MSG + ' state error');
            return false;
        }
        var customContent_send = {
            from_userid: this.stateCenter.idName,
            from_username: this.stateCenter.nickName,
            request_id: this.stateCenter.getRequestId(),
            custom_content: customContent || '',
            room_id: this.room.roomID,
        };
        var bodyData = {
            dest_id_name: dstMembers,
            custom_msg: JSON.stringify(customContent_send),
        };
        var sucCallBack = function (msg) {
            success({ seq: msg.header.seq, errorCode: 0 });
        };
        var errCallBack = function (msg) {
            // TODO
            var err = _this.rtm.getServerError(_this.stateCenter.type == 'PRIVATE' ? msg.body.code : msg.body.err_code);
            _this.logger.error(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_CUSTOM_MSG + ' ' + err.msg);
            var _err;
            if (err == error_1.errorCodeList.TIMEOUT) {
                _err = error_1.errorCodeList.IM_SEND_FAILED;
            }
            else {
                _err = err;
            }
            error({ seq: msg.header.seq, errorCode: _err.code });
        };
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.sendCustomCommand(bodyData, sucCallBack, errCallBack, this.room);
        this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_CUSTOM_MSG + ' call success');
        return true;
    };
    MessageHandler.prototype.handlePushCustomMsg = function (msg) {
        var _a;
        var fromUserId, fromUserName, roomId, command;
        var sub_msg = JSON.parse(msg.body.custommsg);
        _a = [
            sub_msg.from_userid,
            sub_msg.from_username,
            sub_msg.room_id,
            sub_msg.custom_content,
        ], fromUserId = _a[0], fromUserName = _a[1], roomId = _a[2], command = _a[3];
        var seq = this.rtm.getReportSeq();
        this.dataReport.newReport(seq);
        this.dataReport.uploadReport(seq, log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomGetCustomCommand.event);
        this.stateCenter.actionListener('IMRecvCustomCommand', roomId, { userID: fromUserId, userName: fromUserName }, command);
    };
    // *********************************** 自定义消息 end************************************************//
    // *********************************** 弹幕消息 start************************************************//
    MessageHandler.prototype.sendBigRoomMessage = function (category, type, room_id, content, success, error) {
        var _this = this;
        var timeWindow = this.bigimTimeWindow;
        var offset = this.serverTimeOffset;
        var serverTime = new Date().getTime() + offset;
        var clientId = this.rtm.getSeq().toString();
        this.bigImCallbackMap[clientId] = {
            success: success,
            error: error,
        };
        if (timeWindow == 0) {
            var bodyData = {
                msg_category: category,
                msg_type: 1,
                msg_content: content,
                bigmsg_client_id: clientId,
            };
            this.sendBigRoomMessageInternal([bodyData], function (msg) {
                _this.handleBigImMsgRsp(msg);
            }, function (err) {
                error && error(err);
            });
        }
        else {
            var currentIndex = Math.floor(serverTime / timeWindow);
            if (this.bigImLastTimeIndex < currentIndex && this.bigIMmessageList.length == 0) {
                this.bigImLastTimeIndex = currentIndex;
                var oneData = {
                    msg_category: category,
                    msg_type: 1,
                    msg_content: content,
                    bigmsg_client_id: clientId,
                };
                this.sendBigRoomMessageInternal([oneData], function (msg) {
                    _this.handleBigImMsgRsp(msg);
                }, function (err) {
                    error && error(err);
                });
            }
            else {
                this.bigIMmessageList.push({
                    msg_category: category,
                    msg_type: 1,
                    msg_content: content,
                    bigmsg_client_id: clientId,
                });
                if (this.bigIMmessageList.length == 1) {
                    this.setBigImTimer(offset, timeWindow);
                }
            }
        }
    };
    MessageHandler.prototype.sendBigRoomMessageInternal = function (msgs, success, error) {
        var bodyData = {
            msgs: msgs,
        };
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.sendBigRoomMessage(bodyData, function (msg) {
            success(msg);
        }, function (msg) {
            var err = error_1.errorCodeList.ROOM_INNER_ERROR;
            if (!msg.header || !msg.body) {
                msg.code && msg.msg && (err = msg);
                error(err);
            }
            error(err);
        }, this.room);
        this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_BIG_MSG + ' sendBigRoomMessage called');
    };
    MessageHandler.prototype.handleBigImMsgRsp = function (msg) {
        this.bigimTimeWindow = msg.body.bigim_time_window;
        for (var i = 0; i < msg.body.msgs.length; i++) {
            var clientId = msg.body.msgs[i].bigmsg_client_id;
            var msgId = msg.body.msgs[i].bigmsg_id;
            if (this.bigImCallbackMap[clientId]) {
                var success = this.bigImCallbackMap[clientId].success;
                if (success != null) {
                    // success(msg.header.seq, msgId);
                    success({ seq: msg.header.seq, errorCode: 0, messageID: msgId });
                }
                delete this.bigImCallbackMap[clientId];
            }
        }
    };
    MessageHandler.prototype.setBigImTimer = function (offset, timeWindow) {
        var _this = this;
        var serverTimestamp = new Date().getTime() + offset;
        var residue = timeWindow - (serverTimestamp % timeWindow);
        var interval = this.rtm.generateRandumNumber(timeWindow) + residue;
        this.bigImTimer = setTimeout(function () {
            _this.onBigImTimer();
        }, interval);
    };
    MessageHandler.prototype.onBigImTimer = function () {
        var _this = this;
        var serverTimestamp = new Date().getTime() + this.serverTimeOffset;
        this.bigImLastTimeIndex = Math.floor(serverTimestamp / this.bigimTimeWindow);
        var bodyData = [];
        var requestList = [];
        for (var i = 0; i < this.bigIMmessageList.length; i++) {
            if (i >= 20) {
                break;
            }
            var info = this.bigIMmessageList[i];
            bodyData.push({
                msg_category: info.msg_category,
                msg_type: info.msg_type,
                msg_content: info.msg_content,
                bigmsg_client_id: info.bigmsg_client_id,
            });
            requestList.push(info.bigmsg_client_id);
        }
        if (this.bigIMmessageList.length > 20) {
            this.bigIMmessageList.splice(0, 20);
        }
        else {
            this.bigIMmessageList = [];
        }
        this.sendBigRoomMessageInternal(bodyData, function (msg) {
            _this.handleBigImMsgRsp(msg);
        }, function (err, seq) {
            for (var i = 0; i < requestList.length; i++) {
                var clientId = requestList[i];
                var callbackInfo = _this.bigImCallbackMap[clientId];
                if (callbackInfo) {
                    if (callbackInfo.error != null) {
                        callbackInfo.error(err, seq);
                    }
                    delete _this.bigImCallbackMap[clientId];
                }
            }
        });
        this.bigImTimer && clearTimeout(this.bigImTimer);
        this.bigImTimer = null;
        if (this.bigIMmessageList.length > 0) {
            this.setBigImTimer(this.serverTimeOffset, this.bigimTimeWindow);
        }
    };
    MessageHandler.prototype.handlePushMergeMsg = function (msg) {
        for (var i = 0; i < msg.body.messages.length; i++) {
            if (msg.body.messages[i].sub_cmd === 14001 || msg.body.messages[i].sub_cmd === '/lr/push/bigim_chat') {
                this.handlePushBigRooMsg(msg.body.messages[i].msg_body);
            }
        }
    };
    MessageHandler.prototype.handlePushBigRooMsg = function (bodyString) {
        var messageBody;
        //messageBody json
        if (typeof bodyString === 'string') {
            try {
                messageBody = JSON.parse(bodyString);
            }
            catch (e) {
                this.logger.warn(action_1.ZEGO_RTM_ACTION.MESSAGE_BIG_MSG_PUSH + 'parse json error');
                return;
            }
        }
        else {
            messageBody = bodyString;
        }
        if (!messageBody) {
            this.logger.warn(action_1.ZEGO_RTM_ACTION.MESSAGE_BIG_MSG_PUSH + " cann't find message body");
            return;
        }
        var roomId = messageBody.room_id;
        var pushData = [];
        for (var i = 0; i < messageBody.msg_data.length; i++) {
            var message = messageBody.msg_data[i];
            var idName = message.id_name;
            if (idName == this.stateCenter.idName) {
                this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_BIG_MSG_PUSH + ' self message');
                continue;
            }
            pushData.push({
                idName: message.id_name,
                nickName: message.nick_name,
                messageId: message.bigmsg_id,
                category: message.msg_category,
                type: message.msg_type,
                content: message.msg_content,
                time: message.send_time || long_1.default.isLong(message.msg_timestamp) && message.msg_timestamp.toNumber(),
            });
        }
        if (pushData.length == 0) {
            this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_BIG_MSG_PUSH + ' no other pushData except self');
        }
        else {
            this.onRecvBigRoomMessage(pushData, roomId);
        }
        this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_BIG_MSG_PUSH + 'call success');
    };
    MessageHandler.prototype.onRecvBigRoomMessage = function (messageList, roomId) {
        var seq = this.rtm.getReportSeq();
        this.dataReport.newReport(seq);
        var chatData = [];
        messageList.forEach(function (data) {
            var chatInfo = {
                fromUser: {
                    userID: data.idName,
                    userName: data.nickName,
                },
                message: data.content,
                sendTime: data.time,
                messageID: data.messageId,
            };
            chatData.push(chatInfo);
        });
        this.dataReport.uploadReport(seq, log_event_1.ZegoRTMLogEvent.kZegoTaskLiveGetRoomBigIM.event);
        this.stateCenter.actionListener('IMRecvBarrageMessage', roomId, chatData);
        this.stateCenter.actionListener('_recvBigRoomMessage', messageList, roomId);
    };
    MessageHandler.prototype.resetMessageInfo = function () {
        //清除trans信令信息
        this.transSeqMap = {};
        //清除relay信令信息
        this.realyMessageList = [];
        if (this.relayTimer) {
            clearTimeout(this.relayTimer);
            this.relayTimer = null;
        }
        //清除大房间消息
        this.bigImLastTimeIndex = 0;
        this.bigIMmessageList = [];
        this.bigImCallbackMap = {};
        if (this.bigImTimer) {
            clearTimeout(this.bigImTimer);
            this.bigImTimer = null;
        }
        this.serverTimeOffset = 0;
        this.datiTimeWindow = 0;
        this.bigimTimeWindow = 0;
    };
    MessageHandler.prototype.sendRelayMessage = function (type, data, success, error) {
        var timeWindow = this.datiTimeWindow;
        var offset = this.serverTimeOffset;
        if (timeWindow > 0) {
            this.realyMessageList.push({
                type: type,
                data: data,
                success: success,
                error: error,
            });
            if (this.realyMessageList.length == 1) {
                this.setRelayTimer(offset, timeWindow);
            }
        }
        else {
            this.sendRelayMessageInternal(type, data, success, error);
        }
    };
    MessageHandler.prototype.sendRelayMessageInternal = function (type, data, success, error) {
        var _this = this;
        this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_RELAY_MSG + ' call');
        var bodyData = {
            relay_type: type,
            relay_data: data,
        };
        var room = this.room;
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.sendRelayMessage(bodyData, function (msg) {
            success && success(msg.header.seq, msg.body.relay_result);
        }, function (msg) {
            var err = error_1.errorCodeList.ROOM_INNER_ERROR;
            if (!msg.header || !msg.body) {
                msg.code && msg.msg && (err = msg);
                error && error(err, 0);
                return;
            }
            error && error(_this.rtm.getServerError(msg.body.err_code), msg.header.seq);
        }, room);
    };
    MessageHandler.prototype.setRelayTimer = function (offset, timeWindow) {
        var _this = this;
        var serverTimestamp = new Date().getTime() + offset;
        var residue = timeWindow * 2 - (serverTimestamp % timeWindow);
        var interval = this.rtm.generateRandumNumber(residue);
        this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_RELAY_MSG + ' setTimer ' + interval);
        this.relayTimer = setTimeout(function () {
            _this.onRelayTimer();
        }, interval);
    };
    MessageHandler.prototype.onRelayTimer = function () {
        if (this.realyMessageList.length == 0) {
            this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_RELAY_MSG + '  no relay data');
            return;
        }
        var relayInfo = this.realyMessageList[0];
        this.sendRelayMessageInternal(relayInfo.type, relayInfo.data, relayInfo.success, relayInfo.error);
        this.relayTimer && clearTimeout(this.relayTimer);
        this.relayTimer = null;
        this.realyMessageList.splice(0, 1);
        if (this.realyMessageList.length > 0) {
            this.setRelayTimer(this.serverTimeOffset, this.datiTimeWindow);
        }
    };
    MessageHandler.prototype.getRoomChatInfo = function (msgID, msgCount, success, error) {
        this.logger.debug('zb.mh.grc call');
        // 不是处于登录状态
        if (!this.room.isLogin()) {
            this.logger.error('zb.mh.srm no enter room');
            return;
        }
        var bodyData = {
            room_header: {
                room_id: this.room.roomID,
                room_sid: this.room.roomSid || '0',
                room_user_session_id: this.room.roomSessionID || '0',
            },
            // "request_id": this.stateCenter.getRequestId(),
            // "msg_priority": 1,
            msg_id: msgID,
            // "sort_type": sortType,
            msg_count: msgCount,
        };
        var callBack = function (msg, cmdSeq) {
            if (msg.body.code !== 0) {
                error({ errorCode: msg.body.code, extendData: msg.body.message || '' });
            }
            else {
                var chatData = msg.body.msg_data.map(function (data) {
                    return {
                        fromUser: {
                            userID: data.user_id,
                            userName: data.user_name,
                        },
                        message: data.msg_content,
                        sendTime: data.send_time,
                        messageID: data.msg_id,
                    };
                });
                success({ chatData: chatData });
            }
        };
        this.service.sendMessage('zegochat_js.room_im_chat_fetch', bodyData, callBack, callBack);
        this.logger.info('zb.mh.grc call success');
    };
    return MessageHandler;
}());
exports.MessageHandler = MessageHandler;


/***/ })

/******/ });
});

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./sdk/code/zh/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});