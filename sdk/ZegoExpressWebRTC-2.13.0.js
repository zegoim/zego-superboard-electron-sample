(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@protobufjs/aspromise/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/***/ (function(module) {

"use strict";

module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}


/***/ }),

/***/ "./node_modules/@protobufjs/base64/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};


/***/ }),

/***/ "./node_modules/@protobufjs/eventemitter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/***/ (function(module) {

"use strict";

module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};


/***/ }),

/***/ "./node_modules/@protobufjs/float/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/***/ (function(module) {

"use strict";


module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}


/***/ }),

/***/ "./node_modules/@protobufjs/inquire/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/***/ (function(module) {

"use strict";

module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}


/***/ }),

/***/ "./node_modules/@protobufjs/pool/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/***/ (function(module) {

"use strict";

module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}


/***/ }),

/***/ "./node_modules/@protobufjs/utf8/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};


/***/ }),

/***/ "./node_modules/protobufjs/minimal.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// minimal library entry point.


module.exports = __webpack_require__(/*! ./src/index-minimal */ "./node_modules/protobufjs/src/index-minimal.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
protobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ "./node_modules/protobufjs/src/writer_buffer.js");
protobuf.Reader       = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
protobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ "./node_modules/protobufjs/src/reader_buffer.js");

// Utility
protobuf.util         = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");
protobuf.rpc          = __webpack_require__(/*! ./rpc */ "./node_modules/protobufjs/src/rpc.js");
protobuf.roots        = __webpack_require__(/*! ./roots */ "./node_modules/protobufjs/src/roots.js");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = Reader;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};


/***/ }),

/***/ "./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = BufferReader;

// extends Reader
var Reader = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/***/ (function(module) {

"use strict";

module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = __webpack_require__(/*! ./rpc/service */ "./node_modules/protobufjs/src/rpc/service.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = Service;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = LongBits;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ "./node_modules/@protobufjs/aspromise/index.js");

// converts to / from base64 encoded strings
util.base64 = __webpack_require__(/*! @protobufjs/base64 */ "./node_modules/@protobufjs/base64/index.js");

// base class of rpc.Service
util.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ "./node_modules/@protobufjs/eventemitter/index.js");

// float handling accross browsers
util.float = __webpack_require__(/*! @protobufjs/float */ "./node_modules/@protobufjs/float/index.js");

// requires modules optionally and hides the call from bundlers
util.inquire = __webpack_require__(/*! @protobufjs/inquire */ "./node_modules/@protobufjs/inquire/index.js");

// converts to / from utf8 encoded strings
util.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ "./node_modules/@protobufjs/utf8/index.js");

// provides a node-like buffer pool in the browser
util.pool = __webpack_require__(/*! @protobufjs/pool */ "./node_modules/@protobufjs/pool/index.js");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = __webpack_require__(/*! ./longbits */ "./node_modules/protobufjs/src/util/longbits.js");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof __webpack_require__.g !== "undefined"
                   && __webpack_require__.g
                   && __webpack_require__.g.process
                   && __webpack_require__.g.process.versions
                   && __webpack_require__.g.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && __webpack_require__.g
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};


/***/ }),

/***/ "./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = Writer;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};


/***/ }),

/***/ "./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = BufferWriter;

// extends Writer
var Writer = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();


/***/ }),

/***/ "./sdk/code/zh/ZegoExpressDataChannel.web.ts":
/*!***************************************************!*\
  !*** ./sdk/code/zh/ZegoExpressDataChannel.web.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoRealTimeSequentialDataManager = void 0;
var manager_1 = __webpack_require__(/*! ../../src/modules/datachannel/manager */ "./sdk/src/modules/datachannel/manager.ts");
/**
 * 
 *
 *  ZEGO RTC   
 *
 */
var ZegoRealTimeSequentialDataManager = /** @class */ (function () {
    function ZegoRealTimeSequentialDataManager(zegoWebRTC, roomID) {
        this.dataChannelManager = new manager_1.DataChannelListener(zegoWebRTC, roomID);
    }
    /**
     * 
     *
     * Note: 2.12.2 
     *
     * Note:   streamID 
     *
     * Note: 
     *
     * Note: :   RTC 
     *
     * Note:  createRealTimeSequentialDataManager  ZegoRealTimeSequentialDataManager
     *
     * @param streamID  ID256  '~', '!', '@', '#', '$', '', '^', '&', '*', '(', ')', '_', '+', '=', '-', ', ';', '', ',', '.', '<', '>', '/', ''
     *
     * @return true 
     */
    ZegoRealTimeSequentialDataManager.prototype.startBroadcasting = function (streamID) {
        return this.dataChannelManager.startBroadcasting(streamID);
    };
    /**
     * 
     *
     * Note: 2.12.2 
     *
     * Note:   streamID 
     *
     * Note: 
     *
     * Note: :   RTC  RTC 
     *
     * Note:  createRealTimeSequentialDataManager  ZegoRealTimeSequentialDataManager
     *
     * @param streamID  ID, streamID
     *
     * @return 
     */
    ZegoRealTimeSequentialDataManager.prototype.stopBroadcasting = function (streamID) {
        return this.dataChannelManager.stopBroadcasting(streamID);
    };
    /**
     * 
     *
     * Note: 2.12.2 
     *
     * Note:  
     *
     * Note: 
     *
     * Note: :  
     *
     * Note:  createRealTimeSequentialDataManager  ZegoRealTimeSequentialDataManager startBroadcasting 
     *
     * @param streamID  ID
     * @param data 
     *
     * @return 
     */
    ZegoRealTimeSequentialDataManager.prototype.sendRealTimeSequentialData = function (streamID, data) {
        return this.dataChannelManager.sendRealTimeSequentialData(streamID, data);
    };
    /**
     * 
     *
     * Note: 2.12.2 
     *
     * Note:  streamID 
     *
     * Note: 
     *
     * Note: :   RTC 
     *
     * Note:  createRealTimeSequentialDataManager  ZegoRealTimeSequentialDataManager
     *
     * @param streamID  ID
     *
     * @return 
     */
    ZegoRealTimeSequentialDataManager.prototype.startSubscribing = function (streamID) {
        return this.dataChannelManager.startSubscribing(streamID);
    };
    /**
     * 
     *
     * Note: 2.12.2 
     *
     * Note:  streamID 
     *
     * Note: 
     *
     * Note: :   RTC  RTC 
     *
     * Note:  createRealTimeSequentialDataManager  ZegoRealTimeSequentialDataManager
     *
     * @param streamID  ID
     *
     * @return 
     */
    ZegoRealTimeSequentialDataManager.prototype.stopSubscribing = function (streamID) {
        return this.dataChannelManager.stopSubscribing(streamID);
    };
    /**
     * 
     *
     * Note: 2.12.2 
     *
     * Note:  SDK  event  ZegoDataChannelEvent
     *
     * Note: 
     *
     * Note:  createRealTimeSequentialDataManager 
     *
     * Note: , 
     *
     * Note:  off 
     *
     * @param event 
     * @param callBack 
     *
     * @return 
     */
    ZegoRealTimeSequentialDataManager.prototype.on = function (event, callBack) {
        this.dataChannelManager.on(event, callBack);
    };
    /**
     * 
     *
     * Note: 2.12.2 
     *
     * Note:  SDK  event  ZegoDataChannelEvent
     *
     * Note: 
     *
     * Note:  createRealTimeSequentialDataManager 
     *
     * Note: , 
     *
     * Note:  off 
     *
     * @param event 
     * @param callBack 
     *
     * @return 
     */
    ZegoRealTimeSequentialDataManager.prototype.off = function (event, callBack) {
        this.dataChannelManager.off(event, callBack);
    };
    return ZegoRealTimeSequentialDataManager;
}());
exports.ZegoRealTimeSequentialDataManager = ZegoRealTimeSequentialDataManager;


/***/ }),

/***/ "./sdk/code/zh/ZegoExpressEntity.web.ts":
/*!**********************************************!*\
  !*** ./sdk/code/zh/ZegoExpressEntity.web.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoRangeAudioMode = exports.ZegoRangeAudioMicrophoneState = exports.ZegoMixStreamRenderMode = void 0;
/**
 * 
 *
 * 
 *
 */
var ZegoMixStreamRenderMode;
(function (ZegoMixStreamRenderMode) {
    /**
     * 
     */
    ZegoMixStreamRenderMode[ZegoMixStreamRenderMode["AspectFill"] = 0] = "AspectFill";
    /**
     * 
     */
    ZegoMixStreamRenderMode[ZegoMixStreamRenderMode["AspectFit"] = 1] = "AspectFit";
})(ZegoMixStreamRenderMode = exports.ZegoMixStreamRenderMode || (exports.ZegoMixStreamRenderMode = {}));
/**
 * 
 *
 * 
 *
 * 
 *
 */
var ZegoRangeAudioMicrophoneState;
(function (ZegoRangeAudioMicrophoneState) {
    /**
     * 
     */
    ZegoRangeAudioMicrophoneState[ZegoRangeAudioMicrophoneState["Off"] = 0] = "Off";
    /**
     * 
     */
    ZegoRangeAudioMicrophoneState[ZegoRangeAudioMicrophoneState["TurningOn"] = 1] = "TurningOn";
    /**
     * 
     */
    ZegoRangeAudioMicrophoneState[ZegoRangeAudioMicrophoneState["On"] = 2] = "On";
})(ZegoRangeAudioMicrophoneState = exports.ZegoRangeAudioMicrophoneState || (exports.ZegoRangeAudioMicrophoneState = {}));
/**
 * 
 *
 * 
 *
 */
var ZegoRangeAudioMode;
(function (ZegoRangeAudioMode) {
    /**
     * 
     */
    ZegoRangeAudioMode[ZegoRangeAudioMode["World"] = 0] = "World";
    /**
     * 
     */
    ZegoRangeAudioMode[ZegoRangeAudioMode["Team"] = 1] = "Team";
})(ZegoRangeAudioMode = exports.ZegoRangeAudioMode || (exports.ZegoRangeAudioMode = {}));


/***/ }),

/***/ "./sdk/code/zh/ZegoExpressRangeAudio.web.ts":
/*!**************************************************!*\
  !*** ./sdk/code/zh/ZegoExpressRangeAudio.web.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoExpressRangeAudio = void 0;
var ZegoAudioListener_1 = __importDefault(__webpack_require__(/*! ../../src/modules/rangeaudio/ZegoAudioListener */ "./sdk/src/modules/rangeaudio/ZegoAudioListener.ts"));
/**
 * 
 *
 * : 
 *
 */
var ZegoExpressRangeAudio = /** @class */ (function () {
    function ZegoExpressRangeAudio(engine) {
        this.zegoAudioListener = ZegoAudioListener_1.default.getInstance(engine);
    }
    ZegoExpressRangeAudio.getInstance = function (engine) {
        if (!ZegoExpressRangeAudio.instance) {
            if (!engine) {
                throw Error("create instance failed.");
            }
            ZegoExpressRangeAudio.instance = new ZegoExpressRangeAudio(engine);
        }
        return ZegoExpressRangeAudio.instance;
    };
    /**
     * 
     *
     * Note: 2.10.0 
     *
     * Note:  SDK  event  ZegoRangeAudioEvent 
     *
     * Note: 
     *
     * Note:  createRangeAudioInstance  loginRoom 
     *
     * Note: , 
     *
     * Note:  off 
     *
     * @param event 
     * @param callBack 
     *
     * @return 
     */
    ZegoExpressRangeAudio.prototype.on = function (event, callBack) {
        return this.zegoAudioListener.on(event, callBack);
    };
    /**
     * 
     *
     * Note: 2.10.0 
     *
     * Note:  SDK  event 
     *
     * Note: 
     *
     * Note:  createRangeAudioInstance 
     *
     * Note: 
     *
     * @param event 
     * @param callBack 
     *
     * @return 
     */
    ZegoExpressRangeAudio.prototype.off = function (event, callBack) {
        return this.zegoAudioListener.off(event, callBack);
    };
    /**
     * 
     *
     * Note: 2.10.0 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: : 
     *
     * Note:  createRangeAudioInstance  ZegoExpressRangeAudio 
     *
     * @param range ,  0
     */
    ZegoExpressRangeAudio.prototype.setAudioReceiveRange = function (range) {
        this.zegoAudioListener.setAudioReceiveRange(range);
    };
    /**
     * 
     *
     * Note: 2.10.0 
     *
     * Note: :  SDK 
     *
     * Note: 
     *
     * Note:  enableSpeaker 
     *
     * Note:  ZegoExpressRangeAudio  enableSpeaker 
     *
     * @param position  3  number 
     * @param axisForward  3  number 
     * @param axisRight  3  number 
     * @param axisUp  3  number 
     */
    ZegoExpressRangeAudio.prototype.updateSelfPosition = function (position, axisForward, axisRight, axisUp) {
        this.zegoAudioListener.updateSelfPosition(position, axisForward, axisRight, axisUp);
    };
    /**
     * 
     *
     * Note: 2.10.0 
     *
     * Note:  userID  SDK 
     *
     * Note: 
     *
     * Note:  loginRoom 
     *
     * @param userID  ID
     * @param position  3  number 
     */
    ZegoExpressRangeAudio.prototype.updateAudioSource = function (userID, position) {
        this.zegoAudioListener.updateAudioSource(userID, position);
    };
    /**
     *  3D 
     *
     * Note: 2.10.0 
     *
     * Note: 3Denable true  3D  false  3D 
     *
     * Note: 
     *
     * Note: 3D
     *
     * Note: : 3D 
     *
     * Note:  createRangeAudioInstance 
     *
     * Note: :   3D  updateSelfPositon  updateAudioSource 
     *
     * @param enable  true
     */
    ZegoExpressRangeAudio.prototype.enableSpatializer = function (enable) {
        return this.zegoAudioListener.enableSpatializer(enable);
    };
    /**
     * 
     *
     * Note: 2.10.0 
     *
     * Note: enable  true  false 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  createRangeAudioInstance  loginRoom 
     *
     * Note:  microphoneStateUpdate 
     *
     * @param enable  true
     */
    ZegoExpressRangeAudio.prototype.enableMicrophone = function (enable) {
        return this.zegoAudioListener.enableMicrophone(enable);
    };
    /**
     * 
     *
     * Note: 2.10.0 
     *
     * Note: enable true  false 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  createRangeAudioInstance  loginRoom 
     *
     * @param enable  true
     */
    ZegoExpressRangeAudio.prototype.enableSpeaker = function (enable) {
        return this.zegoAudioListener.enableSpeaker(enable);
    };
    /**
     * 
     *
     * Note: 2.10.0 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  createRangeAudioInstance 
     *
     * Note:  setTeamID 
     *
     * @param mode mode  0  1 
     */
    ZegoExpressRangeAudio.prototype.setRangeAudioMode = function (mode) {
        this.zegoAudioListener.setRangeAudioMode(mode);
    };
    /**
     *  ID
     *
     * Note: 2.10.0 
     *
     * Note:  ID 
     *
     * Note: 
     *
     * Note:  undefined , 
     *
     * Note:  createRangeAudioInstance 
     *
     * Note:  etRangeAudioMode 
     *
     * @param teamID  ID
     */
    ZegoExpressRangeAudio.prototype.setTeamID = function (teamID) {
        this.zegoAudioListener.setRangeAudioTeamID(teamID);
    };
    /**
     *  AudioContext 
     *
     * Note: 2.10.0 
     *
     * Note:  isAudioContextRunning  AudioContext 
     *
     * Note:  createRangeAudioInstance 
     *
     * Note:  AudioContext  resumeAudioContext  AudioContext 
     *
     * @return AudioContext 
     */
    ZegoExpressRangeAudio.prototype.isAudioContextRunning = function () {
        return this.zegoAudioListener.getAudioContextState() === "running";
    };
    /**
     *  AudioContext 
     *
     * Note: 2.10.0 
     *
     * Note:  isAudioContextRunning  AudioContext 
     *
     * Note:  createRangeAudioInstance 
     *
     * Note:  JavaScript 
     *
     * Note:  isAudioContextRunning  AudioContext 
     *
     * @return 
     */
    ZegoExpressRangeAudio.prototype.resumeAudioContext = function () {
        return this.zegoAudioListener.resumeAudioContext();
    };
    return ZegoExpressRangeAudio;
}());
exports.ZegoExpressRangeAudio = ZegoExpressRangeAudio;


/***/ }),

/***/ "./sdk/code/zh/index.ts":
/*!******************************!*\
  !*** ./sdk/code/zh/index.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoExpressEngine = exports.ClientUtil = void 0;
//@ts-nocheck
var zego_client_web_1 = __webpack_require__(/*! ./zego.client.web */ "./sdk/code/zh/zego.client.web.ts");
var message_1 = __importDefault(__webpack_require__(/*! zego-express-engine-webrtm/message */ "../zego_express_web_rtm/dist/message/index.js"));
var live_1 = __importDefault(__webpack_require__(/*! zego-express-engine-webrtm/live */ "../zego_express_web_rtm/dist/live/index.js"));
var advance_1 = __importDefault(__webpack_require__(/*! ../../src/modules/advance */ "./sdk/src/modules/advance/index.ts"));
var audioMix_1 = __importDefault(__webpack_require__(/*! ../../src/modules/audioMix */ "./sdk/src/modules/audioMix/index.ts"));
var mixstream_1 = __importDefault(__webpack_require__(/*! ../../src/modules/mixstream */ "./sdk/src/modules/mixstream/index.ts"));
var rangeaudio_1 = __webpack_require__(/*! ../../src/modules/rangeaudio */ "./sdk/src/modules/rangeaudio/index.ts");
var datachannel_1 = __webpack_require__(/*! ../../src/modules/datachannel */ "./sdk/src/modules/datachannel/index.ts");
var videoEffect_1 = __webpack_require__(/*! ../../src/modules/videoEffect */ "./sdk/src/modules/videoEffect/index.ts");
zego_client_web_1.ZegoExpressEngine.use(message_1.default);
zego_client_web_1.ZegoExpressEngine.use(live_1.default);
zego_client_web_1.ZegoExpressEngine.use(advance_1.default);
zego_client_web_1.ZegoExpressEngine.use(audioMix_1.default);
zego_client_web_1.ZegoExpressEngine.use(mixstream_1.default);
zego_client_web_1.ZegoExpressEngine.use(rangeaudio_1.RangeAudio);
zego_client_web_1.ZegoExpressEngine.use(datachannel_1.DataChannel);
zego_client_web_1.ZegoExpressEngine.use(videoEffect_1.BeautyEffect);
var zego_client_web_2 = __webpack_require__(/*! ./zego.client.web */ "./sdk/code/zh/zego.client.web.ts");
Object.defineProperty(exports, "ClientUtil", ({ enumerable: true, get: function () { return zego_client_web_2.ClientUtil; } }));
var ZegoExpressEngine = /** @class */ (function (_super) {
    __extends(ZegoExpressEngine, _super);
    function ZegoExpressEngine() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ZegoExpressEngine;
}(zego_client_web_1.ZegoExpressEngine));
exports.ZegoExpressEngine = ZegoExpressEngine;


/***/ }),

/***/ "./sdk/code/zh/zego.client.web.ts":
/*!****************************************!*\
  !*** ./sdk/code/zh/zego.client.web.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientUtil = exports.ZegoExpressEngine = void 0;
var zego_express_engine_webrtm_1 = __webpack_require__(/*! zego-express-engine-webrtm */ "../zego_express_web_rtm/dist/ZegoExpressWebRTM.js");
var index_1 = __webpack_require__(/*! ../../src/webrtc/index */ "./sdk/src/webrtc/index.ts");
/**
 * 
 *
 * Note:  Express SDK 
 *
 */
var ZegoExpressEngine = /** @class */ (function (_super) {
    __extends(ZegoExpressEngine, _super);
    /**
       *  Engine
       *
       * Note: 1.0.0
       *
       * Note: 
       *
       * Note: 
       *
       * Note: 
       *
       * Note: 
       *
       * Note: 
       *
       * Note: server 
       *
       * Note: 
       *
       * Note: 
       *
       * Note: 
       *
       * Note: 
       *
       * @param appID  number  appID  appID   appID
  
       * @param server  SDK SDK   appID  server
       */
    function ZegoExpressEngine(appID, server) {
        var _this = this;
        zego_express_engine_webrtm_1.ZegoExpressWebRTMEngine.version = "2.13.0";
        _this = _super.call(this, appID, server, 0, arguments[2]) || this;
        _this.zegoWebRTC = new index_1.ZegoWebRTC(_this.logger, _this.dataReport, _this.zegoWebRTM);
        return _this;
    }
    /**
     * 
     *
     * Note: 2.10.0
     *
     * Note:  ZegoExpressEngine  core.js 
     *
     * Note:  ZegoExpressEngine 
     *
     * @param module 
     */
    ZegoExpressEngine.use = function (module) {
        zego_express_engine_webrtm_1.ZegoExpressWebRTMEngine.use(module);
        index_1.ZegoWebRTC.use(module);
    };
    /**
     * 
     *
     * Note: 1.0.0
     *
     * Note: 
     *
     * Note: 
     *
     * Note: none
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * @param checkType? : webRTC, VP8... 
     * @param checkLevel 0 1 
     */
    ZegoExpressEngine.prototype.checkSystemRequirements = function (checkType, checkLevel) {
        if (checkLevel === void 0) { checkLevel = 0; }
        return this.zegoWebRTC.checkSystemRequirements(checkLevel, checkType);
    };
    /**
     * 
     *
     * Note: 1.0.0
     *
     * Note: ZegoEvent  [ZegoRTCEvent](https://doc-zh.zego.im/article/api?doc=Express_Video_SDK_API~javascript_web~interface~ZegoRTCEvent)   [ZegoRTMEvent](https://doc-zh.zego.im/article/api?doc=Express_Video_SDK_API~javascript_web~interface~ZegoRTMEvent)   SDK 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * @param event 
     * @param callBack? 
     */
    ZegoExpressEngine.prototype.off = function (event, callBack) {
        if (this.zegoWebRTM.stateCenter.listenerList[event]) {
            return this.zegoWebRTM.off(event, callBack);
        }
        else if (this.zegoWebRTC.stateCenter.listenerList[event]) {
            return this.zegoWebRTC.off(event, callBack);
        }
        else {
            return false;
        }
    };
    /**
     * 
     *
     * Note: 1.0.0 
     *
     * Note: ZegoEvent  [ZegoRTCEvent](https://doc-zh.zego.im/article/api?doc=Express_Video_SDK_API~javascript_web~interface~ZegoRTCEvent)  [ZegoRTMEvent](https://doc-zh.zego.im/article/api?doc=Express_Video_SDK_API~javascript_web~interface~ZegoRTMEvent)  SDK  event 
     *
     * Note:  SDK 
     *
     * Note:  loginRoom 
     *
     * Note: , 
     *
     * Note:  off 
     *
     * @param event 
     * @param callBack 
     *
     * @return 
     */
    ZegoExpressEngine.prototype.on = function (event, callBack) {
        if (this.zegoWebRTM.stateCenter.listenerList[event]) {
            return this.zegoWebRTM.on(event, callBack);
        }
        else if (this.zegoWebRTC.stateCenter.listenerList[event]) {
            return this.zegoWebRTC.on(event, callBack);
        }
        else {
            return false;
        }
    };
    /**
     * 
     *
     * Note: 1.0.0 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  checkSystemRequirements 
     *
     * Note: 
     * 1.  pc  pc 
     * 2. https,localhost,127.0.0.1
     * 3.   <video>   oncanplay 
     * 4.  video  falsesafari 
     * 5.  enable  false,  replaceTrack 
     * 6.  source.screen.audio  true windows 
     * 7.  API  source.camera.videoQuality  source.screen.videoQuality 
     * 8. camera.channelCount  custom.channelCount  chrome 
     * 9.  startBitrate  target ( chrome )
     *
     * Note:  publishQualityUpdate  screenSharingEnded 
     *
     * Note:  destroyStream startPublishingStream
     *
     * @param source? 
     *
     * @return promise 
     */
    ZegoExpressEngine.prototype.createStream = function (source) {
        return this.zegoWebRTC.createStream(source);
    };
    /**
     *  Electron 
     *
     * Note: 2.11.0
     *
     * Note:  Electron 
     *
     * Note:  Electron 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: createStream
     *
     * @return electron 
     */
    ZegoExpressEngine.prototype.getElectronScreenSources = function () {
        return this.zegoWebRTC.getElectronScreenSources();
    };
    /**
     * 
     *
     * Note: 1.0.0
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  createStream
     *
     * Note: 
     *
     * @param localStream  stream
     */
    ZegoExpressEngine.prototype.destroyStream = function (localStream) {
        return this.zegoWebRTC.destroyStream(localStream);
    };
    /**
     * 
     *
     * Note: 1.0.0 
     *
     * Note:  streamID 
     *
     * Note: 
     *
     * Note: publishOption.videoCodec  H.264  VP8 ZEGO 
     *
     * Note:  createStream 
     *
     * Note:  publishQualityUpdate publisherStateUpdate
     *
     * Note:  stopPublishingStream 
     *
     * @param streamID  ID256  '~', '!', '@', '#', '$', '', '^', '&', '*', '(', ')', '_', '+', '=', '-', ', ';', '', ',', '.', '<', '>', '/', ''
     * @param localStream  stream
     * @param publishOption? 
     *
     * @return true 
     */
    ZegoExpressEngine.prototype.startPublishingStream = function (streamID, localStream, publishOption) {
        return this.zegoWebRTC.startPublishingStream(streamID, localStream, publishOption);
    };
    /**
     * 
     *
     * Note: 1.0.0
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:   <video>  <video>
     *
     * Note: 
     *
     * Note:  publishQualityUpdate publisherStateUpdate
     *
     * Note:  startPublishingStream
     *
     * Note: 
     *
     * @param streamID  ID,streamID
     */
    ZegoExpressEngine.prototype.stopPublishingStream = function (streamID) {
        return this.zegoWebRTC.stopPublishingStream(streamID);
    };
    /**
     * 
     *
     * Note: 1.14.0
     *
     * Note: 
     *
     * Note:  C 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:   localStream  SDK  createStream 
     *
     * Note: 
     *
     * Note:  publishQualityUpdate
     *
     * Note: 
     *
     * Note: 
     *
     * @param localStream  stream
     * @param constraints 
     */
    ZegoExpressEngine.prototype.setVideoConfig = function (localStream, constraints) {
        return this.zegoWebRTC.setVideoConfig(localStream, constraints);
    };
    /**
     * 
     *
     * Note: 1.14.0
     *
     * Note: 
     *
     * Note: 3A
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:   localStream  SDK  createStream 
     *
     * Note: 
     *
     * Note:  publishQualityUpdate
     *
     * Note: 
     *
     * Note: 
     *
     * @param localStream  stream
     * @param constraints 
     */
    ZegoExpressEngine.prototype.setAudioConfig = function (localStream, constraints) {
        return this.zegoWebRTC.setAudioConfig(localStream, constraints);
    };
    /**
     * 
     *
     * Note: 1.13.0
     *
     * Note: 
     *
     * Note:  mp3 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  localStream  SDK  createStream 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * @param localStream  stream
     * @param mediaStreamTrack 
     */
    ZegoExpressEngine.prototype.replaceTrack = function (localStream, mediaStreamTrack) {
        return this.zegoWebRTC.replaceTrack(localStream, mediaStreamTrack);
    };
    /**
     * 
     *
     * Note: 1.0.0
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  setMixingAudioVolume 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * @param localStream 
     * @param volume 0-100
     */
    ZegoExpressEngine.prototype.setCaptureVolume = function (localStream, volume) {
        return this.zegoWebRTC.setCaptureVolume(localStream, volume);
    };
    /**
     * 
     *
     * Note: 1.0.0
     *
     * Note:  
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  
     *
     * Note: 
     *
     * Note:  streamExtraInfoUpdate
     *
     * Note: 
     *
     * Note: 
     *
     * @param streamID  ID
     * @param extraInfo ; extraInfojson
     */
    ZegoExpressEngine.prototype.setStreamExtraInfo = function (streamID, extraInfo) {
        return this.zegoWebRTC.setStreamExtraInfo(streamID, extraInfo);
    };
    /**
     * CDN
     *
     * Note: 1.0.0
     *
     * Note:  CDN  ZEGO  CDN 
     *
     * Note:  CDN 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *       CDN  CDN  API  API
     *       CDN 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  CDN removePublishCdnUrl
     *
     * Note: 
     *
     * @param streamID  ID
     * @param targetURL CDN  rtmp
     */
    ZegoExpressEngine.prototype.addPublishCdnUrl = function (streamID, targetURL) {
        if (arguments.length === 3) {
            return this.zegoWebRTC.addPublishCdnUrl(
            // eslint-disable-next-line prefer-rest-params
            arguments[0], 
            // eslint-disable-next-line prefer-rest-params
            arguments[2]);
        }
        else {
            return this.zegoWebRTC.addPublishCdnUrl(streamID, targetURL);
        }
    };
    /**
     *  CDN
     *
     * Note: 1.0.0
     *
     * Note:   CDN  CDN  ZEGO  CDN 
     *
     * Note:  CDN 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *       CDN  CDN  API  API
     *       CDN 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  CDN addPublishCdnUrl
     *
     * Note: 
     *
     * @param streamID  ID
     * @param targetURL CDN  rtmp
     */
    ZegoExpressEngine.prototype.removePublishCdnUrl = function (streamID, targetURL) {
        if (arguments.length === 3) {
            return this.zegoWebRTC.removePublishCdnUrl(
            // eslint-disable-next-line prefer-rest-params
            arguments[0], 
            // eslint-disable-next-line prefer-rest-params
            arguments[2]);
        }
        else {
            return this.zegoWebRTC.removePublishCdnUrl(streamID, targetURL);
        }
    };
    /**
     * /
     *
     * Note: 1.0.0
     *
     * Note:  
     *
     * Note: 
     *
     * Note: 
     *
     * Note: /
     *
     * Note:  remoteCameraStatusUpdate
     *
     * Note:  / mutePublishStreamAudio
     *
     * @param localStream  stream
     * @param mute true false  false
     * @param retain  false 
     *
     * @return 
     */
    ZegoExpressEngine.prototype.mutePublishStreamVideo = function (localStream, mute, retain) {
        return this.zegoWebRTC.mutePublishStreamVideo(localStream, mute, retain);
    };
    /**
     * /
     *
     * Note: 1.0.0
     *
     * Note:  /
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     * 1. /
     * 2.  muteMicrophone 
     *
     * Note:  remoteMicStatusUpdate
     *
     * Note:  / mutePublishStreamVideo/ muteMicrophone
     *
     * @param localStream  stream
     * @param mute true false  false
     */
    ZegoExpressEngine.prototype.mutePublishStreamAudio = function (localStream, mute) {
        return this.zegoWebRTC.mutePublishStreamAudio(localStream, mute);
    };
    /**
     * 
     *
     * Note: 1.13.0 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  createStream 
     *
     * Note: 
     * 1.  MediaStream  useVideoDevicereplaceTrack 
     * 2.  setEffectsBeauty(localStream,false) 
     * 3.  destroyStream  SDK ,  SDK  setEffectsBeauty(localStream,false) 
     * 4. 
     *
     * Note: .
     *
     * @param localStream  MediaStream 
     * @param enable true false 
     * @param options  smoothIntensitywhitenIntensityrosyIntensitysharpenIntensity 0 - 100 50, options 
     */
    ZegoExpressEngine.prototype.setEffectsBeauty = function (localStream, enable, options) {
        return this.zegoWebRTC.setBeautyEffect(localStream, enable, options);
    };
    /**
     * 
     *
     * Note: 1.0.0 
     *
     * Note:  ID 
     *
     * Note: 
     *
     * Note:  roomStreamUpdate 
     *
     * Note: 
     * 1.  ZEGO  roomStreamUpdate 
     * 2.  CDN  
     *
     * Note:  playQualityUpdate playerStateUpdate 
     *
     * Note:  stopPlayStream 
     *
     * @param streamID  ID 
     * @param playOption? 
     *
     * @return promise 
     */
    ZegoExpressEngine.prototype.startPlayingStream = function (streamID, playOption) {
        return this.zegoWebRTC.startPlayingStream(streamID, playOption);
    };
    /**
     * 
     *
     * Note: 1.0.0
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  
     *
     * Note: 
     *
     * Note:  playQualityUpdate playerStateUpdate
     *
     * Note:  startPlayStream
     *
     * Note: 
     *
     * @param streamID  ID
     */
    ZegoExpressEngine.prototype.stopPlayingStream = function (streamID) {
        return this.zegoWebRTC.stopPlayingStream(streamID);
    };
    /**
     * 
     *
     * Note: 1.15.0
     *
     * Note:  
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:   mutePlayStreamAudio
     *
     * Note: 
     *
     * @param streamID ID
     * @param mute true false 
     */
    ZegoExpressEngine.prototype.mutePlayStreamVideo = function (streamID, mute) {
        return this.zegoWebRTC.mutePlayStreamVideo(streamID, mute);
    };
    /**
     * 
     *
     * Note: 1.15.0
     *
     * Note:  
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:   mutePlayStreamVideo
     *
     * Note: 
     *
     * @param streamID ID
     * @param mute true false 
     */
    ZegoExpressEngine.prototype.mutePlayStreamAudio = function (streamID, mute) {
        return this.zegoWebRTC.mutePlayStreamAudio(streamID, mute);
    };
    /**
     * 
     *
     * Note: 1.5.2 
     *
     * Note:  
     *
     * Note: PK
     *
     * Note:  startPublishingStream 
     *
     * Note: 
     *
     * Note: 1.  AppID 2.  ZEGO 3.  inputList  contentType  AUDIO ZegoMixStreamOutputConfig  outputBitrate outputFPS outputWidth outputHeight  1
     *
     * Note: 
     *
     * Note:   stopMixerTask 
     *
     * @param mixStreamConfig 
     */
    ZegoExpressEngine.prototype.startMixerTask = function (mixStreamConfig) {
        return this.zegoWebRTC.startMixerTask(mixStreamConfig);
    };
    /**
     * 
     *
     * Note: 1.5.2 
     *
     * Note:  taskID 
     *
     * Note:  PK 
     *
     * Note:  startMixerTask 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:   startMixerTask
     *
     * @param taskID  ID 256   '~', '!', '@', '#', '$', '', '^', '&', '*', '(', ')', '_', '+', '=', '-', ', ';', '', ',', '
     */
    ZegoExpressEngine.prototype.stopMixerTask = function (taskID) {
        return this.zegoWebRTC.stopMixerTask(taskID);
    };
    /**
     * 
     *
     * Note: 1.5.2 
     *
     * Note: 
     *
     * Note: 1. 2. 
     *
     * Note:  startMixerTask 
     *
     * Note: 
     *
     * Note:  startMixerTask
     *
     * @param config 
     */
    ZegoExpressEngine.prototype.setMixerTaskConfig = function (config) {
        return this.zegoWebRTC.setMixerTaskConfig(config);
    };
    /**
     * 
     *
     * Note: 1.7.0 
     *
     * Note:  HTMLMediaElement  streamID 
     *
     * Note: 
     *
     * Note:  startPublishingStream 
     *
     * Note:  6  mediaList  6
     *
     * Note: Chrome  86 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  stopMixingAudio 
     *
     * @param streamID  ID
     * @param mediaList 1.  <audio>  <video> 
     *                  2. / <audio>  <video> 
     */
    ZegoExpressEngine.prototype.startMixingAudio = function (streamID, mediaList) {
        return this.zegoWebRTC.startMixingAudio(streamID, mediaList);
    };
    /**
     * 
     *
     * Note: 1.7.0 
     *
     * Note:  mediaList 
     *
     * Note: 
     *
     * Note:  stratMixingAudio 
     *
     * Note:  checkSystemRequirements  "customCapture"  false  MediaStream
     *
     * Note: 
     *
     * Note: 
     *
     * Note:   startMixingAudio
     *
     * @param streamID  ID
     * @param mediaList? 1.  <audio>  <video> 
     *                   2. / <audio>  <video> 
     */
    ZegoExpressEngine.prototype.stopMixingAudio = function (streamID, mediaList) {
        return this.zegoWebRTC.stopMixingAudio(streamID, mediaList);
    };
    /**
     * 
     *
     * Note: 1.18.0 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  startMixingAudio 
     *
     * Note: Chrome  86 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  startMixingAudio
     *
     * @param streamID  ID
     * @param volume  0100100 
     * @param media  <video>  <audio>
     */
    ZegoExpressEngine.prototype.setMixingAudioVolume = function (streamID, volume, media) {
        return this.zegoWebRTC.setMixingAudioVolume(streamID, volume, media);
    };
    /**
     * id
     *
     * Note: 1.0.0
     *
     * Note:  id 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     * https,localhost,127.0.0.1
     * 
     * SafariiOS
     *  ID 
     *  createStream  ID
     * safari 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: createStreamuseAudioDeviceuseVideoDevice
     *
     * Note: 
     */
    ZegoExpressEngine.prototype.enumDevices = function () {
        return this.zegoWebRTC.enumDevices();
    };
    /**
     * 
     *
     * Note: 1.0.0
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  useAudioDevice
     *
     * Note: 
     *
     * @param localStream  stream
     * @param deviceID  ID
     */
    ZegoExpressEngine.prototype.useVideoDevice = function (localStream, deviceID) {
        return this.zegoWebRTC.useVideoDevice(localStream, deviceID);
    };
    /**
     * 
     *
     * Note: 1.0.0
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  useVideoDevice
     *
     * Note: 
     *
     * @param localStream  stream
     * @param deviceID  ID
     */
    ZegoExpressEngine.prototype.useAudioDevice = function (localStream, deviceID) {
        return this.zegoWebRTC.useAudioDevice(localStream, deviceID);
    };
    /**
     * 
     *
     * Note: 1.0.0
     *
     * Note:  soundLevelUpdate 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  
     *
     * Note: 
     *
     * Note:  soundLevelUpdate  capturedSoundLevelUpdate
     *
     * Note: 
     *
     * Note: 
     *
     * @param bool 
     * @param interval? 1000ms
     */
    ZegoExpressEngine.prototype.setSoundLevelDelegate = function (bool, interval) {
        return this.zegoWebRTC.setSoundLevelDelegate(bool, interval);
    };
    /**
     * 
     *
     * Note: 2.8.0 
     *
     * Note:  
     *
     * Note: 
     *
     * Note:  loginRoom 
     *
     * Note:   muteMicrophone /
     *
     * @return true false 
     */
    ZegoExpressEngine.prototype.isMicrophoneMuted = function () {
        return this.zegoWebRTC.isMicrophoneMuted();
    };
    /**
     * 
     *
     * Note: 2.8.0 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  isMicrophoneMuted  mutePublishStreamAudio / 
     *
     * @param mute true false  false
     */
    ZegoExpressEngine.prototype.muteMicrophone = function (mute) {
        return this.zegoWebRTC.muteMicrophone(mute);
    };
    /**
     * 
     *
     * Note: 2.10.0 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  ZegoExpressEngine  loginRoom 
     *
     * Note: :   startPublishingStream startPlayingStream 
     *
     * @return 
     */
    ZegoExpressEngine.prototype.createRangeAudioInstance = function () {
        return this.zegoWebRTC.createRangeAudioInstance();
    };
    /**
     * 
     *
     * Note: 2.12.2 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  ZegoExpressEngine 
     *
     * @param roomID ID
     *
     * @return 
     */
    ZegoExpressEngine.prototype.createRealTimeSequentialDataManager = function (roomID) {
        return this.zegoWebRTC.createRealTimeSequentialDataManager(roomID);
    };
    /**
     * 
     *
     * Note: 2.12.2 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  ZegoExpressEngine  createRealTimeSequentialDataManager 
     *
     * @param manager 
     */
    ZegoExpressEngine.prototype.destroyRealTimeSequentialDataManager = function (manager) {
        this.zegoWebRTC.destroyRealTimeSequentialDataManager(manager);
    };
    return ZegoExpressEngine;
}(zego_express_engine_webrtm_1.ZegoExpressWebRTMEngine));
exports.ZegoExpressEngine = ZegoExpressEngine;
var client_util_1 = __webpack_require__(/*! ../../src/util/client-util */ "./sdk/src/util/client-util.ts");
Object.defineProperty(exports, "ClientUtil", ({ enumerable: true, get: function () { return client_util_1.ClientUtil; } }));


/***/ }),

/***/ "./sdk/src/common/action.ts":
/*!**********************************!*\
  !*** ./sdk/src/common/action.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// import * as fs from "fs";
// import * as path from "path";
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZEGO_WECHATMINI_ACTION = exports.ZEGO_WEBRTC_ACTION = void 0;
// ****** sdk************//
var ZEGO_WEBRTC_ACTION;
(function (ZEGO_WEBRTC_ACTION) {
    ZEGO_WEBRTC_ACTION["CONSTRUCTOR"] = "zc.0";
    ZEGO_WEBRTC_ACTION["CHECK_SUPPORT"] = "zc.csr";
    ZEGO_WEBRTC_ACTION["CREATE_STREAM"] = "zc.cs";
    ZEGO_WEBRTC_ACTION["DESTROY_STREAM"] = "zc.ds";
    ZEGO_WEBRTC_ACTION["START_PUBLISHING_STREAM"] = "zc.sps.0";
    ZEGO_WEBRTC_ACTION["START_PLAYING_STREAM"] = "zc.sps.1";
    ZEGO_WEBRTC_ACTION["STOP_PUBLISHING_STREAM"] = "zc.sps.0.0";
    ZEGO_WEBRTC_ACTION["STOP_PLAYING_STREAM"] = "zc.sps.1.0";
    ZEGO_WEBRTC_ACTION["ON_STREAM"] = "zc.os";
    ZEGO_WEBRTC_ACTION["ON_PUSH_STREAM_UPDATE"] = "zc.opsu";
    ZEGO_WEBRTC_ACTION["BIND_WINDOW_LISTENER"] = "zc.wl";
    ZEGO_WEBRTC_ACTION["SET_AUDIO_OUTPUT"] = "zc.sao";
    ZEGO_WEBRTC_ACTION["SET_CUSTOM_SIGNAL_URL"] = "zc.scsu";
    ZEGO_WEBRTC_ACTION["SET_TURN_OVER_TCP_ONLY"] = "zc.stoto";
    ZEGO_WEBRTC_ACTION["RDH_ACTIVE"] = "zc.rdh.a";
    ZEGO_WEBRTC_ACTION["RDH_MAX_TIME"] = "zc.rdh.m";
    ZEGO_WEBRTC_ACTION["RDH_WEBRTC_URL_RSP"] = "zc.rdh.hfwur";
    ZEGO_WEBRTC_ACTION["PUBLISH_STATE_HANDLE"] = "zc.psh.0";
    ZEGO_WEBRTC_ACTION["PLAY_STATE_HANDLE"] = "zc.psh.1";
    ZEGO_WEBRTC_ACTION["STATECENTER_ACTION_LISTENER"] = "zc.sc.al";
    ZEGO_WEBRTC_ACTION["STATECENTER_SET_SETTING"] = "zc.sc.ss";
    ZEGO_WEBRTC_ACTION["SIGNAL_SET_SESSION_INFO"] = "zc.s.ssi";
    ZEGO_WEBRTC_ACTION["SIGNAL_RESET_CONNECT_TIMER"] = "zc.s.rct";
    ZEGO_WEBRTC_ACTION["SIGNAL_BIND_WEBSOCKET_HANDLE"] = "zc.s.bwh";
    ZEGO_WEBRTC_ACTION["SIGNAL_RESET_CHECK_MESSAGE"] = "zc.s.rcm";
    ZEGO_WEBRTC_ACTION["SIGNAL_UPDATE_TOKEN"] = "zc.s.ut";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_MESSAGE_WITH_CALLBACK"] = "zc.s.smwc";
    ZEGO_WEBRTC_ACTION["SIGNAL_CONNECT_SERVER"] = "zc.s.cs.0";
    ZEGO_WEBRTC_ACTION["SIGNAL_START_CONNECT_TIMER"] = "zc.s.sct";
    ZEGO_WEBRTC_ACTION["SIGNAL_DISCONNECT_SERVER"] = "zc.s.dc";
    ZEGO_WEBRTC_ACTION["SIGNAL_CREATE_SESSION"] = "zc.s.cs.1";
    ZEGO_WEBRTC_ACTION["SIGNAL_REMOVE_SESSION"] = "zc.s.rs";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_REMOVE_SESSION"] = "zc.s.srs";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_MESSAGE"] = "zc.s.sm";
    ZEGO_WEBRTC_ACTION["SIGNAL_HANDLE_RESPOND_DATA"] = "zc.s.hrd";
    ZEGO_WEBRTC_ACTION["SIGNAL_ADD_SESSION"] = "zc.s.as";
    ZEGO_WEBRTC_ACTION["SIGNAL_HANDLE_PUSH_DATA"] = "zc.s.hpd";
    ZEGO_WEBRTC_ACTION["SIGNAL_HANDLE_PUSH_RESET_SESSION_DATA"] = "zc.s.hprsd";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_MEDIA_DESC"] = "zc.s.smd";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_CANDIDATE_INFO"] = "zc.s.sci";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_MEDIA_DESC_ACK"] = "zc.s.smda";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_CANDIDATE_INFO_ACK"] = "zc.s.scia";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_CLOSE_SESSION_ACK"] = "zc.s.scsa";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_RESET_SESSION_ACK"] = "zc.s.srsa";
    ZEGO_WEBRTC_ACTION["SIGNAL_REGISTER_PUSH_CALLBACK"] = "zc.s.rpc";
    ZEGO_WEBRTC_ACTION["SIGNAL_CHECK_MESSAGE_TIMEOUT"] = "zc.s.cmt";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_HEARTBEAT"] = "zc.s.sh";
    ZEGO_WEBRTC_ACTION["SIGNAL_QUALITY_REPORT"] = "zc.s.qr";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_STREAM_STATUS"] = "zc.s.sss";
    ZEGO_WEBRTC_ACTION["SIGNAL_ACTIVE_PLAY_VIDEO_STREAM"] = "zc.s.apvs";
    ZEGO_WEBRTC_ACTION["SIGNAL_ACTIVE_PLAY_AUDIO_STREAM"] = "zc.s.apas";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_BROADCAST_STATUS"] = "zc.s.sbs";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_NET_PROBE"] = "zc.s.snp";
    ZEGO_WEBRTC_ACTION["SIGNAL_SEND_NET_QUALITY_INFO_PUSH_ACK"] = "zc.s.npa";
    ZEGO_WEBRTC_ACTION["PUBLISHER_START_PUBLISH"] = "zc.p.0.sp.0";
    ZEGO_WEBRTC_ACTION["PUBLISHER_PUBLISH_SUCCESS"] = "zc.p.ps";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS"] = "zc.p.0.ocpss";
    ZEGO_WEBRTC_ACTION["PUBLISHER_HANDLE_CREATE_SESSION_WITH_SDP"] = "zc.p.0.hcsws";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_CREATE_OFFER_SUCCESS"] = "zc.p.0.ocos";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_SET_LOCAL_DESCRIPTION_SUCCESS"] = "zc.p.0.oslds";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_GET_REMOTE_DESCRIPTION"] = "zc.p.0.ogrd";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_RECV_MEDIA_DESC"] = "zc.p.0.ormd";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_RECV_CANDIDATE_INFO"] = "zc.p.0.orci.0";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_RECV_PUBLISH_EVENT"] = "zc.p.0.orpe";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_RECV_CLIENT_INFO"] = "zc.p.0.orci.1";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_ICE_CANDIDATE"] = "zc.p.0.oic";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_CONNECTION_STATE_CHANGE"] = "zc.p.0.ocsc";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_ICE_CONNECTION_STATE_CHANGE"] = "zc.p.0.oicsc";
    ZEGO_WEBRTC_ACTION["PUBLISHER_RESET_PUBLISH"] = "zc.p.0.rp";
    ZEGO_WEBRTC_ACTION["PUBLISHER_SET_PLAYER_QUALITY_TIMER"] = "zc.p.0.spqt";
    ZEGO_WEBRTC_ACTION["PUBLISHER_UPLOAD_PUBLISH_QUALITY"] = "zc.p.0.upq";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_RECV_RESET_SESSION"] = "zc.p.0.orrs";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_RECV_CLOSE_SESSION"] = "zc.p.0.orcs";
    ZEGO_WEBRTC_ACTION["PUBLISHER_SEND_CANDIDATE_INFO"] = "zc.p.0.sci";
    ZEGO_WEBRTC_ACTION["PUBLISHER_STATE_ERROR"] = "zc.p.0.psr";
    ZEGO_WEBRTC_ACTION["PUBLISHER_STOP_PUBLISH"] = "zc.p.0.sp.1";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_DISCONNECT"] = "zc.p.0.od";
    ZEGO_WEBRTC_ACTION["PUBLISHER_START_SOUND_LEVEL"] = "zc.p.0.ssl.0";
    ZEGO_WEBRTC_ACTION["PUBLISHER_STOP_SOUND_LEVEL"] = "zc.p.0.ssl.1";
    ZEGO_WEBRTC_ACTION["PUBLISHER_HANDLE_ENC_BITRATE"] = "zc.p.0.heb";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_RECV_NET_QUALITY_INFO"] = "zc.p.0.nqi";
    ZEGO_WEBRTC_ACTION["PUBLISHER_ON_RECV_UPDATE_MEDIA_DESC"] = "zc.p.0.orumd";
    ZEGO_WEBRTC_ACTION["PLAYER_START_PLAY"] = "zc.p.1.sp.0";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS"] = "zc.p.ocpss.1";
    ZEGO_WEBRTC_ACTION["PLAYER_HANDLE_CREATE_SESSION_WITH_SDP"] = "zc.p.hcsws.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_CREATE_OFFER_SUCCESS"] = "zc.p.ocos.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_SET_LOCAL_DESCRIPTION_SUCCESS"] = "zc.p.oslds.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_RECV_MEDIA_DESC"] = "zc.p.ormd.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_RECV_CANDIDATE_INFO"] = "zc.p.orci.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_RECV_PLAY_EVENT"] = "zc.p.orpe.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_RECV_CLIENT_INFO"] = "zc.p.orci.1.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_ICE_CANDIDATE"] = "zc.p.oic.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_CONNECTION_STATE_CHANGE"] = "zc.p.ocsc.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_ICE_CONNECTION_STATE_CHANGE"] = "zc.p.oicsc.1";
    ZEGO_WEBRTC_ACTION["PLAYER_RESET_PLAY"] = "zc.p.rp.1";
    ZEGO_WEBRTC_ACTION["PLAYER_SET_PLAYER_QUALITY_TIMER"] = "zc.p.spqt.1";
    ZEGO_WEBRTC_ACTION["PLAYER_UPLOAD_PLAYER_QUALITY"] = "zc.p.upq.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_RECV_RESET_SESSION"] = "zc.p.orrs.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_RECV_CLOSE_SESSION"] = "zc.p.orcs.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_RECV_STREAM_STATUS"] = "zc.p.orss.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_GOT_REMOTE_STREAM"] = "zc.p.ogrs.1";
    ZEGO_WEBRTC_ACTION["PLAYER_SEND_CANDIDATE_INFO"] = "zc.p.sci.1";
    ZEGO_WEBRTC_ACTION["PLAYER_STATE_ERROR"] = "zc.p.psr.1";
    ZEGO_WEBRTC_ACTION["PLAYER_STOP_PLAY"] = "zc.p.1.sp.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_DISCONNECT"] = "zc.p.od.1";
    ZEGO_WEBRTC_ACTION["PLAYER_START_SOUND_LEVEL"] = "zc.p.ssl.1";
    ZEGO_WEBRTC_ACTION["PLAYER_STOP_SOUND_LEVEL"] = "zc.p.ssl.1.1";
    ZEGO_WEBRTC_ACTION["PLAYER_ON_RECV_NET_QUALITY_INFO"] = "zc.p.1.nqi";
    ZEGO_WEBRTC_ACTION["PUBLISH_SET_CAPTURE_VOLUME"] = "zc.p.scv";
    ZEGO_WEBRTC_ACTION["PUBLISH_SET_BEAUTY_EFFECT"] = "zc.p.0.sbe";
    ZEGO_WEBRTC_ACTION["STREAMHANDLER_MERGE_STREAM_BY_STREAM_SEQ"] = "zc.sh.msbss";
    ZEGO_WEBRTC_ACTION["STREAMHANDLER_MERGE_STREAM"] = "zc.sh.ms";
    ZEGO_WEBRTC_ACTION["STREAMHANDLER_PATCH_STREAM_LIST"] = "zc.sh.psl"; //
})(ZEGO_WEBRTC_ACTION = exports.ZEGO_WEBRTC_ACTION || (exports.ZEGO_WEBRTC_ACTION = {}));
var ZEGO_WECHATMINI_ACTION;
(function (ZEGO_WECHATMINI_ACTION) {
    ZEGO_WECHATMINI_ACTION["ADD_PUBLISH_CDN_URL"] = "zw.apcu";
    ZEGO_WECHATMINI_ACTION["REMOVE_PUBLISH_CDN_URL"] = "zw.rpcu";
    ZEGO_WECHATMINI_ACTION["STOP_MIXER_TASK"] = "zw.smt";
    ZEGO_WECHATMINI_ACTION["ON_STREAM"] = "zw.os";
    ZEGO_WECHATMINI_ACTION["ON_PUSH_STREAM_UPDATE"] = "zw.opsu";
    ZEGO_WECHATMINI_ACTION["ON_PUBLISH_STATE_UPDATE"] = "zw.w.opsu";
    ZEGO_WECHATMINI_ACTION["ON_PUBLISH_STATE_UPDATE_HANDLE"] = "zw.w.opsuh";
    ZEGO_WECHATMINI_ACTION["WECHATMINI_SETPREFERPLAYSOURCETYPE"] = "zw.w.sppst.1";
    ZEGO_WECHATMINI_ACTION["WECHATMINI_BIND_LISTENER"] = "zw.w.bl";
    ZEGO_WECHATMINI_ACTION["WECHATMINI_DELETE_LISTENER"] = "zw.w.dl";
    ZEGO_WECHATMINI_ACTION["WECHATMINI_UPDATE_PLAYER_STATE"] = "zw.w.ups";
    ZEGO_WECHATMINI_ACTION["WECHATMINI_UPDATE_PLAYER_NET_STATUS"] = "zw.w.upns";
    ZEGO_WECHATMINI_ACTION["WECHATMINI_SET_CUSTOM_SIGNAL_URL"] = "zw.w.scsu";
    ZEGO_WECHATMINI_ACTION["WECHATMINI_GET_NEXT_URL"] = "zw.w.gnu";
    ZEGO_WECHATMINI_ACTION["WECHATMINI_BIND_STREAM_CENTER_HANDLER"] = "zw.w.bsch";
    ZEGO_WECHATMINI_ACTION["WECHATMINI_BIND_RTM_LISTENER"] = "zw.w.brl";
    ZEGO_WECHATMINI_ACTION["PUBLISHMODULE_SET_PREFER_PUBLISH_SOURCE_TYPE"] = "zw.pu.sppst.0";
    ZEGO_WECHATMINI_ACTION["PUBLISHMODULE_START_PUBLISHING_STREAM"] = "zw.pu.sps.0";
    ZEGO_WECHATMINI_ACTION["PUBLISHMODULE_STOP_PUBLISHING_STREAM"] = "zw.pu.sps.0.0";
    ZEGO_WECHATMINI_ACTION["PUBLISHMODULE_FETCH_PUBLISH_STREAM_URL"] = "zw.pu.fpsu.0";
    ZEGO_WECHATMINI_ACTION["PUBLISHMODULE_HANDLE_FETCH_STREAM_PUBLISH_URL_RSP"] = "zw.pu.hfspur.0";
    ZEGO_WECHATMINI_ACTION["PUBLISHMODULE_DO_PUBLISH_STREAM"] = "zw.pu.dps.0";
    ZEGO_WECHATMINI_ACTION["PUBLISHMODULE_UPDATE_STREAM_INFO"] = "zw.pu.upi";
    ZEGO_WECHATMINI_ACTION["PUBLISHMODULE_HANDLE_STREAM_UPDATE_RSP"] = "zw.pu.hsur";
    ZEGO_WECHATMINI_ACTION["PLAYMODULE_START_PLAYING_STREAM"] = "zw.pl.sps.1";
    ZEGO_WECHATMINI_ACTION["PLAYMODULE_STOP_PLAYING_STREAM"] = "zw.pl.sps.1.0";
    ZEGO_WECHATMINI_ACTION["PLAYMODULE_START_PLAYING_STREAM_FROM_CDN"] = "zw.pl.spsfc";
    ZEGO_WECHATMINI_ACTION["PLAYMODULE_START_PLAYING_STREAM_FROM_BGP"] = "zw.pl.spsfb";
    ZEGO_WECHATMINI_ACTION["PLAYMODULE_DO_PLAY_STREAM"] = "zw.pl.dps";
    ZEGO_WECHATMINI_ACTION["PLAYMODULE_FETCH_PLAY_STREAM_URL"] = "zw.pl.fpsu";
    ZEGO_WECHATMINI_ACTION["PLAYMODULE_HANDLE_FETCH_STREAM_URL_RSP"] = "zw.pl.hfsur";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_RESET"] = "zw.scw.r.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_START_PUBLISHING_STREAM"] = "zw.scw.sps.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_START_PLAYING_STREAM"] = "zw.scw.sps.1";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_START_PLAYER"] = "zw.scw.sp.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_ON_STREAM_URL_UPDATE"] = "zw.scw.opuu.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_UPDATE_PLAYER_STATE"] = "zw.scw.ups.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_UPDATE_PLAYER_NET_STATUS"] = "zw.scw.upns";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_UPDATE_PUBLISHING_STATE"] = "zw.scw.ups.0.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_UPDATE_PLAYING_STATE"] = "zw.scw.ups.1.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_GET_NEXT_URL"] = "zw.scw.gnu";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_STOP_PUBLISHING_STREAM"] = "zw.scw.sps.0.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_STOP_PLAYING_STREAM"] = "zw.scw.sps.1.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_STOP_PLAYER"] = "zw.scw.sp.1";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_ON_PLAY_START"] = "zw.scw.ops.0";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_ON_PLAY_STOP"] = "zw.scw.ops.1";
    ZEGO_WECHATMINI_ACTION["STREAMCENTERWECHAT_ON_PLAY_RETRY"] = "zw.scw.opr";
    ZEGO_WECHATMINI_ACTION["PLAYWECHAT_TRY_START_PLAYER"] = "zw.pw.tsp.0";
    ZEGO_WECHATMINI_ACTION["PLAYWECHAT_UPDATE_EVENT"] = "zw.pw.ue";
    ZEGO_WECHATMINI_ACTION["PLAYWECHAT_GET_PLAY_URL"] = "zw.pw.gpu"; //
    // PLAYMODULE_
})(ZEGO_WECHATMINI_ACTION = exports.ZEGO_WECHATMINI_ACTION || (exports.ZEGO_WECHATMINI_ACTION = {}));
// const _path = path.resolve(__dirname, "action.ts");
// fs.readFile(_path, "utf8", (err, data) => {
//   if (err) {
//     console.error(err);
//   } else {
//     const actionArr: Array<string> = [];
//     const reg = /([A-Z])\w+ = "(.*)".*\/\/([\u4e00-\u9fa5_a-zA-Z0-9]+)/g;
//     data.replace(reg, (target, p, key, value, _content): any => {
//       actionArr.push(`${key} : ${value}`);
//     });
//     fs.writeFile(
//       path.resolve(__dirname, "../../../doc/action.log"),
//       actionArr.join("\r"),
//       "utf8",
//       err => {
//         console.log(err);
//       }
//     );
//   }
// });


/***/ }),

/***/ "./sdk/src/common/setting.config.ts":
/*!******************************************!*\
  !*** ./sdk/src/common/setting.config.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RTC = exports.ZegoSettingConfig = void 0;
var ZegoSettingConfig = /** @class */ (function () {
    function ZegoSettingConfig() {
        this.defaultSetting = {
            publish_video_codec: "H264",
            // publish_stream_video_bitrate: 800,
            camera_video_bitrate: 800,
            screen_video_bitrate: 1500,
            custom_video_bitrate: 0,
            l3_play_buffer_ms: 500,
            AEC: true,
            AGC: true,
            ANS: true,
            resource_mode: 0,
            bitrate_mode: "default"
        };
        this.setting = JSON.parse(JSON.stringify(this.defaultSetting));
    }
    ZegoSettingConfig.getInstance = function () {
        if (!ZegoSettingConfig.instance) {
            ZegoSettingConfig.instance = new ZegoSettingConfig();
        }
        return ZegoSettingConfig.instance;
    };
    ZegoSettingConfig.prototype.setSetting = function (settingFile, changeItems) {
        var isDynamic = Array.isArray(changeItems) && changeItems.length > 0;
        for (var settingGroup in settingFile) {
            for (var settingItem in settingFile[settingGroup]) {
                //  _enable  _enable  _force 
                if (!settingItem.endsWith("_ctrlmode")) {
                    if (isDynamic && changeItems.indexOf(settingItem) == -1) {
                        continue;
                    }
                    var _mode = settingFile[settingGroup][settingItem + "_ctrlmode"];
                    if (_mode === 1 || _mode === 2) {
                        this.setting[settingItem] = settingFile[settingGroup][settingItem];
                    }
                    else {
                        this.defaultSetting[settingItem] &&
                            (this.setting[settingItem] = this.defaultSetting[settingItem]);
                    }
                    typeof _mode === "number" &&
                        (this.setting[settingItem + "_ctrlmode"] =
                            settingFile[settingGroup][settingItem + "_ctrlmode"]);
                }
            }
        }
    };
    ZegoSettingConfig.prototype.getSetting = function (key, force) {
        if (force === void 0) { force = false; }
        if (force) {
            if (this.setting[key + "_ctrlmode"] == 2) {
                return this.setting[key];
            }
            else {
                return undefined;
            }
        }
        return this.setting[key];
    };
    return ZegoSettingConfig;
}());
exports.ZegoSettingConfig = ZegoSettingConfig;
exports.RTC = "rtc";


/***/ }),

/***/ "./sdk/src/common/stateCenter.ts":
/*!***************************************!*\
  !*** ./sdk/src/common/stateCenter.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StateCenter = void 0;
var zego_entity_1 = __webpack_require__(/*! ../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var client_util_1 = __webpack_require__(/*! ../util/client-util */ "./sdk/src/util/client-util.ts");
var action_1 = __webpack_require__(/*! ./action */ "./sdk/src/common/action.ts");
var setting_config_1 = __webpack_require__(/*! ./setting.config */ "./sdk/src/common/setting.config.ts");
var zego_entity_2 = __webpack_require__(/*! ./zego.entity */ "./sdk/src/common/zego.entity.ts");
var zego_log_event_1 = __webpack_require__(/*! ./zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var StateCenter = /** @class */ (function () {
    function StateCenter(logger, dataReport) {
        this.logger = logger;
        this.dataReport = dataReport;
        this.debug = false;
        this.testEnvironment = false;
        this.pullLimited = true;
        // 
        this.useNetAgent = true;
        this.configOK = false;
        this.relateService = [];
        this.role = 2;
        this.maxMemberCount = 0;
        this.roomCreateFlag = 1;
        //runState: ENUM_RUN_STATE = ENUM_RUN_STATE.logout;
        //lastRunState: ENUM_RUN_STATE = ENUM_RUN_STATE.logout;
        this.callbackList = {};
        this.publishStreamList = {};
        this.streamUrlMap = {};
        this.cmdCallback = {};
        this.customUrl = [];
        this.customPlayUrl = [];
        this.turnOverTcpOnly = false;
        this.customSetTcpOrUdp = false;
        this.supportUdp = false;
        //
        this.audioEffectBuffer = {};
        this.audioBitRate = 48000;
        //cdn
        this.cdnSeq = 0;
        //
        this.listenerList = {
            roomStreamUpdate: [],
            streamExtraInfoUpdate: [],
            playerStateUpdate: [],
            publisherStateUpdate: [],
            screenSharingEnded: [],
            publishQualityUpdate: [],
            playQualityUpdate: [],
            remoteCameraStatusUpdate: [],
            remoteMicStatusUpdate: [],
            soundLevelUpdate: [],
            capturedSoundLevelUpdate: [],
            videoDeviceStateChanged: [],
            audioDeviceStateChanged: [],
            deviceError: [],
            _deviceError: [],
            _remoteCameraStatusUpdate: [],
            _remoteMicStatusUpdate: [],
            _streamUpdated: [],
            receiveRealTimeSequentialData: [],
            beautyEffectOverload: []
        };
        // log event
        this.reportList = {};
        this.reportSeqList = {
            startPublish: {},
            rePublish: {},
            startPlay: {},
            rePlay: {},
            stopPublish: {},
            stopPlay: {}
        };
        this.streamTrigger = {};
        // 
        this.audioStreamList = {};
        // 
        this.deviceInfos = null;
        this.deviceChangeTimer = null;
        this.deviceStateOut = false;
        this.networkState = zego_entity_2.ENUM_NETWORK_STATE.offline;
        this.streamRetryTime = 300;
        this.checkList = [];
        this.anchor_info = {
            anchor_id: "",
            anchor_id_name: "",
            anchor_nick_name: ""
        };
        this.streamConnectTime = 0;
        this.clientIP = "";
        //
        this.type = "PUBLIC";
        this.roomList = [];
        this.isMultiRoom = false;
        this.browser = "";
        this.playAccelerate = false;
        this.logReportCallback = client_util_1.ClientUtil.logReportCallback;
        this.unregisterCallback = client_util_1.ClientUtil.unregisterCallback;
        this.checkIllegalCharacters = client_util_1.ClientUtil.checkIllegalCharacters;
        this.decodeServerError = client_util_1.ClientUtil.decodeServerError;
        this.getLiveRoomError = client_util_1.ClientUtil.getLiveRoomError;
        this.getServerError = client_util_1.ClientUtil.getServerError;
        this.mergeStreamList = client_util_1.ClientUtil.mergeStreamList;
        this.checkInteger = client_util_1.ClientUtil.checkInteger;
        this.isUrl = client_util_1.ClientUtil.isUrl;
        this.actionSuccessCallback = client_util_1.ClientUtil.actionSuccessCallback;
        this.checkValidNumber = client_util_1.ClientUtil.checkValidNumber;
        this.getDevices = client_util_1.ClientUtil.getDevices;
        this.settingConfig = new setting_config_1.ZegoSettingConfig();
    }
    // //
    // isLogin() {
    //     return this.runState === ENUM_RUN_STATE.login;
    // }
    //requestId
    StateCenter.prototype.getRequestId = function () {
        return this.idName + "-" + zego_entity_2.getSeq();
    };
    StateCenter.prototype.getSignalCmdContent = function (roomID, requestId, dest_id_name, result) {
        var data = {
            request_id: requestId,
            room_id: roomID,
            from_userid: this.idName,
            from_username: this.nickName,
            to_userid: dest_id_name
        };
        if (result != undefined) {
            data["result"] = result;
        }
        return JSON.stringify(data);
    };
    StateCenter.prototype.actionListener = function (listener) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (![
            "playQualityUpdate",
            "publishQualityUpdate",
            "soundLevelUpdate",
            "capturedSoundLevelUpdate"
        ].includes(listener) &&
            this.listenerList[listener]) {
            var reportSeq = zego_entity_1.getReportSeq();
            this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoListener.event);
            this.dataReport.addMsgInfo(reportSeq, {
                listener: listener,
                params: args
            });
            this.dataReport.uploadReport(reportSeq);
        }
        this.listenerList[listener] &&
            this.listenerList[listener].forEach(function (func) {
                try {
                    setTimeout(function () {
                        func.apply(void 0, args);
                    }, 0);
                }
                catch (error) {
                    _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.STATECENTER_ACTION_LISTENER +
                        " " +
                        listener +
                        " " +
                        error);
                }
            });
    };
    StateCenter.prototype.getRoomByRoomID = function (roomID) {
        return this.roomList.find(function (room) { return room.roomID == roomID; });
    };
    StateCenter.prototype.getPlayRoom = function (streamID) {
        return this.roomList.find(function (room) {
            return !!room.streamList.find(function (streamInfo) { return streamInfo.stream_id == streamID; });
        });
    };
    return StateCenter;
}());
exports.StateCenter = StateCenter;


/***/ }),

/***/ "./sdk/src/common/streamCenter.ts":
/*!****************************************!*\
  !*** ./sdk/src/common/streamCenter.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoStreamCenter = void 0;
var ZegoStreamCenter = /** @class */ (function () {
    function ZegoStreamCenter() {
        this.publisherList = {};
        this.playerList = {};
    }
    return ZegoStreamCenter;
}());
exports.ZegoStreamCenter = ZegoStreamCenter;


/***/ }),

/***/ "./sdk/src/common/streamHandler.ts":
/*!*****************************************!*\
  !*** ./sdk/src/common/streamHandler.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StreamHandler = void 0;
var zego_entity_1 = __webpack_require__(/*! ./zego.entity */ "./sdk/src/common/zego.entity.ts");
var zego_error_1 = __webpack_require__(/*! ./zego.error */ "./sdk/src/common/zego.error.ts");
var action_1 = __webpack_require__(/*! ./action */ "./sdk/src/common/action.ts");
// import { BusinessService } from "zego-express-engine-webrtm/sdk/src/modules/net/index";
// interface MixStreamConfig extends ZegoMixStreamConfig {
//   noTaskID?: boolean;
// }
// declare const $PROTO_VERSION: any;
// const PROTO_VERSION = $PROTO_VERSION;
// const REPORT_ACTION = {
//   eventStart: "eventStart",
//   eventEndWithMsgInfo: "eventEndWithMsgInfo",
//   addEventMsg: "addEventMsg",
//   addEvent: "addEvent",
//   eventEnd: "eventEnd",
//   addMsgInfo: "addMsgInfo"
// };
var StreamHandler = /** @class */ (function () {
    function StreamHandler(logger, stateCenter, rtm, streamCenter, roomID) {
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.rtm = rtm;
        this.streamCenter = streamCenter;
        this.roomID = roomID;
        this.minStreamSeq = 0;
        this.streamSeq = 0;
        this.streamQuerying = false;
        this.streamSeqMergeMap = null;
        this.streamListHBMergeInterval = 2000;
        this.streamListMergeInterval = 5000;
    }
    // sdk
    StreamHandler.prototype.setCDNInfo = function (streamInfo, streamItem) {
        streamInfo.urlFlv =
            streamItem.urls_flv instanceof Array
                ? streamItem.urls_flv[0]
                : typeof streamItem.urls_flv == "string"
                    ? streamItem.urls_flv
                    : "";
        streamInfo.urlHls =
            streamItem.urls_m3u8 instanceof Array
                ? streamItem.urls_m3u8[0]
                : typeof streamItem.urls_m3u8 == "string"
                    ? streamItem.urls_m3u8
                    : "";
        streamInfo.urlHttpsFlv =
            streamItem.urls_https_flv instanceof Array
                ? streamItem.urls_https_flv[0]
                : typeof streamItem.urls_https_flv == "string"
                    ? streamItem.urls_https_flv
                    : "";
        streamInfo.urlHttpsHls =
            streamItem.urls_https_m3u8 instanceof Array
                ? streamItem.urls_https_m3u8[0]
                : typeof streamItem.urls_https_m3u8 == "string"
                    ? streamItem.urls_https_m3u8
                    : "";
        streamInfo.urlRtmp =
            streamItem.urls_rtmp instanceof Array
                ? streamItem.urls_rtmp[0]
                : typeof streamItem.urls_rtmp == "string"
                    ? streamItem.urls_rtmp
                    : "";
    };
    // sdk
    StreamHandler.prototype.onStreamUpdated = function (roomid, type, streamList) { };
    // sdk
    StreamHandler.prototype.onStreamExtraInfoUpdated = function (roomid, streamList) { };
    StreamHandler.prototype.handleStreamStart = function (msg, room) {
        this.logger.info("zb.sh.hss call stream update");
        this.room = room;
        if (!msg.body) {
            this.logger.error("zb.sh.hss server response wrong");
            return;
        }
        this.streamListHBMergeInterval =
            msg.body.stream_list_hb_wait_merge_time || 2000;
        this.streamListMergeInterval =
            msg.body.stream_list_push_merge_timeout || 5000;
        this.streamQuerying = false;
        this.handleFullUpdateStream(msg.body.stream_seq, msg.body.stream_info || []);
        /* 
             */
        this.handleReconnectStream(msg.body.stream_info);
        this.logger.info("zb.sh.hss call end");
    };
    // sdk
    StreamHandler.prototype.onPublishStateUpdate = function (type, streamId, error) { };
    //  
    StreamHandler.prototype.updateStreamInfo = function (streamid, cmd, stream_extra_info, error) {
        var _this = this;
        var _a, _b;
        if (stream_extra_info === void 0) { stream_extra_info = ""; }
        this.logger.info("zb.sh.usi call");
        var extra_info = stream_extra_info;
        var streamInfo = (_a = this.room) === null || _a === void 0 ? void 0 : _a.streamList.find(function (item) { return item.streamid === streamid; });
        if (!streamInfo) {
            this.logger.warn("zb.sh.usi stream not in room cmd " + cmd);
        }
        console.error("updateStreamInfo", JSON.stringify(streamInfo));
        var data = {
            stream_id: streamid,
            extra_info: extra_info
        };
        if (cmd === 2002 || cmd === 2003) {
            data["stream_sid"] = (streamInfo === null || streamInfo === void 0 ? void 0 : streamInfo["stream_sid"]) || "";
        }
        var stream_msg = JSON.stringify(data);
        var bodyData = {
            sub_cmd: cmd,
            stream_msg: stream_msg,
            third_token: (_b = this.room) === null || _b === void 0 ? void 0 : _b.token
        };
        var streamCmd = "stream";
        var room = this.room;
        this.room.streamInfoList[streamid] = {};
        var sucCallBack = function (msg, seq) {
            // if (this.stateCenter.useNetAgent) {
            //   this.handleStreamUpdateRsp(msg);
            // } else {
            _this.handleStreamUpdateRsp(msg, streamid);
            // }
        };
        var failCallBack = function (result, seq) {
            var room = _this.room;
            if (room &&
                !room.isResetRoom &&
                !_this.rtm.isDisConnect() &&
                result.code &&
                result.code == zego_error_1.errorCodeList.TIMEOUT.code &&
                room.streamInfoList[streamid].seq == seq) {
                if ((cmd == 2001 &&
                    _this.stateCenter.publishStreamList[streamid] &&
                    _this.stateCenter.publishStreamList[streamid].state ==
                        zego_entity_1.ENUM_PUBLISH_STREAM_STATE.update_info) ||
                    cmd == 2002) {
                    //setTimeoutresetCheckMessageList
                    setTimeout(function () {
                        _this.updateStreamInfo(streamid, cmd, stream_extra_info, error);
                    }, 0);
                }
                else {
                    error && error(zego_error_1.errorCodeList.TIMEOUT);
                }
            }
            else {
                if (result.body && result.body.err_code) {
                    // TODO:  getServerError 
                    var err = _this.stateCenter.getServerError(result.body.err_code);
                    //  token 
                    if ([1011, 1000002002].includes(err.code)) {
                        err = zego_error_1.errorCodeList.TOKEN_EXPIRED;
                    }
                    error && error(err, seq);
                    // ,,
                    cmd === zego_entity_1.ENUM_STREAM_SUB_CMD.liveBegin &&
                        _this.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.error, streamid, err);
                }
            }
        };
        if (this.stateCenter.useNetAgent) {
            this.rtm.liveRoomHandler.sendStreamUpdate(bodyData, sucCallBack, failCallBack, {
                sessionID: room === null || room === void 0 ? void 0 : room.sessionID,
                roomID: room === null || room === void 0 ? void 0 : room.roomID,
                roomSessionID: room === null || room === void 0 ? void 0 : room.roomSessionID
            });
        }
        else {
            this.room.streamInfoList[streamid].seq = this.rtm.service.sendMessage(streamCmd, bodyData, sucCallBack, failCallBack, undefined, {
                sessionID: room === null || room === void 0 ? void 0 : room.sessionID,
                roomID: room === null || room === void 0 ? void 0 : room.roomID,
                roomSessionID: room === null || room === void 0 ? void 0 : room.roomSessionID
            });
        }
        this.logger.info("zb.sh.usi call success cmd " + cmd);
    };
    //
    StreamHandler.prototype.handleStreamUpdateRsp = function (msg, streamid) {
        var _a, _b, _c;
        if (this.rtm.isDisConnect()) {
            this.logger.error("zb.sh.hsur not login");
            return;
        }
        if (msg.body.err_code != 0) {
            this.logger.error("zb.sh.hsur stream update error " + msg.body.err_code);
            return;
        }
        this.logger.info("zb.sh.hsur stream seq " +
            this.streamSeq +
            " server seq " +
            msg.body.stream_seq);
        this.streamSeq = msg.body.stream_seq;
        var room = this.room;
        if (!room) {
            this.logger.info("hsur.0 room no found");
            return;
        }
        //  token 
        var remainTime = (_a = msg === null || msg === void 0 ? void 0 : msg.body) === null || _a === void 0 ? void 0 : _a.token_remain_time;
        if (remainTime) {
            var room_1 = this.stateCenter.getRoomByRoomID((_b = msg === null || msg === void 0 ? void 0 : msg.header) === null || _b === void 0 ? void 0 : _b.room_id);
            if (!room_1) {
                this.logger.error("zb.sh.hsur room no found ignore " +
                    JSON.stringify((_c = msg.header) === null || _c === void 0 ? void 0 : _c.room_id));
            }
            else {
                //  token 
                this.rtm.resetRoomTokenTimer(msg.header.room_id, msg.body.token_remain_time);
            }
        }
        if (this.stateCenter.useNetAgent) {
            // TODO stream_ver
            this.handleStreamSync(msg, streamid);
        }
        else {
            //publishStreamList
            for (var i = 0; i < msg.body.stream_info.length; i++) {
                var streamid_1 = msg.body.stream_info[i].stream_id;
                this.handleStreamRsp(room, streamid_1, msg.body.stream_info[i]);
                delete room.streamInfoList[streamid_1];
            }
        }
    };
    StreamHandler.prototype.handleStreamSync = function (msg, streamID) {
        if (msg.body.stream_seq > this.streamSeq) {
            this.fetchStreamList();
            return;
        }
        var streamInfo = this.room.streamList.find(function (streamInfo) { return streamInfo.stream_id == streamID; });
        if (streamInfo && msg.body.stream_ver > streamInfo.stream_ver) {
            this.fetchStreamList(streamID);
            return;
        }
        this.handleStreamRsp(this.room, streamID, {
            streamid: streamID,
            stream_sid: msg.body.stream_sid,
            stream_ver: msg.body.stream_ver,
            stream_nid: msg.body.stream_nid
        });
    };
    StreamHandler.prototype.handleStreamRsp = function (room, streamID, streamInfo) {
        var publish = this.stateCenter.publishStreamList[streamID];
        if (!publish) {
            this.logger.info("hsur.0 stream is not exist");
            return;
        }
        if (publish.state == zego_entity_1.ENUM_PUBLISH_STREAM_STATE.update_info) {
            publish.state = zego_entity_1.ENUM_PUBLISH_STREAM_STATE.publishing;
            if (!room.streamList.find(function (streamInfo) { return streamInfo.stream_id == streamID; })) {
                room.streamList.push(streamInfo);
            }
            this.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.start, streamID, {
                code: 0,
                message: ""
            });
        }
    };
    StreamHandler.prototype.handleFetchStreamListRsp = function (msg, updateStreamID) {
        this.logger.info("zb.sh.hfslr call");
        this.streamQuerying = false;
        if (msg.body.err_code !== 0) {
            this.logger.info("zb.sh.hfslr server error=", msg.body.err_code);
            return;
        }
        if (this.streamSeq === msg.body.stream_seq) {
            this.logger.info("zb.sh.hfslr same seq");
            return;
        }
        var _streams = msg.body.stream_info;
        if (updateStreamID) {
            _streams = msg.body.stream_info.filter(function (stream) { return stream.stream_id === updateStreamID; });
        }
        this.handleFullUpdateStream(msg.body.stream_seq, _streams);
        this.logger.info("zb.sh.hfslr call success");
    };
    StreamHandler.prototype.handleFullUpdateStream = function (serverStreamSeq, serverStreamList) {
        var _this = this;
        this.logger.info("zb.sh.hfus call");
        this.streamSeq = serverStreamSeq;
        this.logger.debug("zb.sh.hfus server seq " + this.streamSeq);
        this.stateCenter.mergeStreamList(this.stateCenter.idName, this.room.streamList, serverStreamList, function (addStreamList, delStreamList, updateStreamList) {
            if (addStreamList.length !== 0) {
                _this.logger.debug("zb.sh.hfus callback addstream");
                _this.onStreamUpdated(_this.roomID, zego_entity_1.ENUM_STREAM_UPDATE_TYPE.added, _this.makeCallbackStreamList(addStreamList));
            }
            if (delStreamList.length !== 0) {
                _this.logger.debug("zb.sh.hfus callback delstream");
                _this.onStreamUpdated(_this.roomID, zego_entity_1.ENUM_STREAM_UPDATE_TYPE.deleted, _this.makeCallbackStreamList(delStreamList));
            }
            if (updateStreamList.length !== 0) {
                _this.logger.debug("zb.sh.hfus callback updatestream");
                _this.onStreamExtraInfoUpdated(_this.roomID, _this.makeCallbackStreamList(updateStreamList));
            }
        });
        //this.room!.streamList = serverStreamList;
        this.logger.info("zb.sh.hfus call success");
    };
    StreamHandler.prototype.handlePushStreamUpdateMsg = function (msg) {
        this.logger.info("zb.sh.hpsum call");
        if (!msg.body.stream_info || msg.body.stream_info.length === 0) {
            this.logger.info("zb.sh.hpsum, emtpy list");
            return;
        }
        if (msg.body.stream_info.length + this.streamSeq !== msg.body.stream_seq) {
            this.logger.info("zb.sh.hpsum call updatestream");
            //this.mergeStreamByStreamSeq(msg.body.stream_cmd, msg.body.stream_seq, msg.body.stream_info)
            this.fetchStreamList();
            return;
        }
        this.streamSeq = msg.body.stream_seq;
        switch (msg.body.stream_cmd) {
            case zego_entity_1.ENUM_STREAM_UPDATE_CMD.added:
                this.handleAddedStreamList(msg.body.stream_info);
                break;
            case zego_entity_1.ENUM_STREAM_UPDATE_CMD.deleted:
                this.handleDeletedStreamList(msg.body.stream_info);
                break;
            case zego_entity_1.ENUM_STREAM_UPDATE_CMD.updated:
                this.handleUpdatedStreamList(msg.body.stream_info);
                break;
        }
        this.logger.info("zb.sh.hpsum call success");
    };
    StreamHandler.prototype.handlePriPushStreamUpdateMsg = function (msg) {
        this.logger.info("zb.sh.hpsum call");
        if (!msg.body.streams_info || msg.body.streams_info.length === 0) {
            this.logger.info("zb.sh.hpsum, emtpy list");
            return;
        }
        if (msg.body.streams_info.length + this.streamSeq !== msg.body.stream_seq) {
            this.logger.info("zb.sh.hpsum call updatestream");
            //   this.fetchStreamList()
            this.mergeStreamByStreamSeq(msg.body.stream_cmd, msg.body.stream_seq, msg.body.streams_info);
            return;
        }
        this.streamSeq = msg.body.stream_seq;
        switch (msg.body.stream_cmd) {
            case zego_entity_1.ENUM_STREAM_UPDATE_CMD_PRI.added:
                this.handleAddedStreamList(msg.body.streams_info);
                break;
            case zego_entity_1.ENUM_STREAM_UPDATE_CMD_PRI.deleted:
                this.handleDeletedStreamList(msg.body.streams_info);
                break;
            case zego_entity_1.ENUM_STREAM_UPDATE_CMD_PRI.updated:
                this.handleUpdatedStreamList(msg.body.streams_info);
                break;
        }
        this.logger.info("zb.sh.hpsum call success");
    };
    StreamHandler.prototype.handleAddedStreamList = function (streamList) {
        this.logger.debug("zb.sh.hasl call");
        var addStreamList = [];
        var flag;
        for (var i = 0; i < streamList.length; i++) {
            if (streamList[i].anchor_id_name == this.stateCenter.idName ||
                streamList[i].id_name == this.stateCenter.idName ||
                streamList[i].user_id === this.stateCenter.idName) {
                this.logger.debug("hdsl.0 have self stream added");
                continue;
            }
            flag = false;
            for (var j = 0; j < this.room.streamList.length; j++) {
                if (streamList[i].stream_id === this.room.streamList[j].stream_id) {
                    flag = true;
                    break;
                }
            }
            if (!flag) {
                addStreamList.push(streamList[i]);
            }
        }
        if (addStreamList.length !== 0) {
            this.logger.debug("zb.sh.hasl callback addstream");
            // this.room!.streamList.concat(addStreamList);
            for (var k = 0; k < addStreamList.length; k++) {
                this.room.streamList.push(addStreamList[k]);
            }
            this.onStreamUpdated(this.roomID, zego_entity_1.ENUM_STREAM_UPDATE_TYPE.added, this.makeCallbackStreamList(addStreamList));
        }
        this.logger.info("zb.sh.hasl call success");
    };
    StreamHandler.prototype.handleDeletedStreamList = function (streamList) {
        this.logger.debug("zb.sh.hdsl call");
        var delStreamList = [];
        for (var i = 0; i < streamList.length; i++) {
            if (streamList[i].anchor_id_name == this.stateCenter.idName ||
                streamList[i].id_name == this.stateCenter.idName ||
                streamList[i].user_id === this.stateCenter.idName) {
                this.logger.debug("zb.sh.hdsl have self stream deleted");
                continue;
            }
            for (var j = this.room.streamList.length - 1; j >= 0; j--) {
                if (streamList[i].stream_id === this.room.streamList[j].stream_id) {
                    this.room.streamList.splice(j--, 1);
                    delStreamList.push(streamList[i]);
                    break;
                }
            }
        }
        if (delStreamList.length !== 0) {
            this.logger.debug("zb.sh.hdsl callback delstream");
            this.onStreamUpdated(this.roomID, zego_entity_1.ENUM_STREAM_UPDATE_TYPE.deleted, this.makeCallbackStreamList(delStreamList));
        }
        this.logger.info("zb.sh.hdsl call");
    };
    StreamHandler.prototype.handleUpdatedStreamList = function (streamList) {
        this.logger.debug("zb.sh.husl call");
        var updateStreamList = [];
        for (var i = 0; i < streamList.length; i++) {
            if (streamList[i].anchor_id_name == this.stateCenter.idName ||
                streamList[i].id_name == this.stateCenter.idName ||
                streamList[i].user_id === this.stateCenter.idName) {
                this.logger.debug("hsul.0 have self stream updated");
                continue;
            }
            for (var j = 0; j < this.room.streamList.length; j++) {
                if (streamList[i].stream_id === this.room.streamList[j].stream_id) {
                    if (streamList[i].extra_info !== this.room.streamList[j].extra_info) {
                        this.room.streamList[j] = streamList[i];
                        updateStreamList.push(streamList[i]);
                    }
                    break;
                }
            }
        }
        if (updateStreamList.length !== 0) {
            this.logger.debug("zb.sh.husl callback updatestream");
            this.onStreamExtraInfoUpdated(this.roomID, this.makeCallbackStreamList(updateStreamList));
        }
        this.logger.info("zb.sh.husl call success");
    };
    // 
    StreamHandler.prototype.fetchStreamList = function (streamID) {
        var _this = this;
        var _a, _b, _c;
        this.logger.info("zb.sh.fsl call");
        // 
        if (this.rtm.isDisConnect()) {
            this.logger.info("zb.sh.fsl state error");
            return;
        }
        //  false  true
        if (this.streamQuerying) {
            this.logger.info("zb.sh.fsl already doing");
            return;
        }
        this.streamQuerying = true;
        this.logger.debug("zb.sh.fsl send fetch request");
        if (this.stateCenter.useNetAgent) {
            this.rtm.liveRoomHandler.getStreamList({}, function (msg) {
                _this.handleFetchStreamListRsp(msg, streamID);
            }, function (err) { }, {
                roomID: (_a = this.room) === null || _a === void 0 ? void 0 : _a.roomID,
                sessionID: (_b = this.room) === null || _b === void 0 ? void 0 : _b.sessionID,
                roomSessionID: (_c = this.room) === null || _c === void 0 ? void 0 : _c.roomSessionID
            });
        }
        else {
            var bodyData = {
                reserve: 0
            };
            // 
            var room = this.room;
            this.rtm.service.sendMessage("stream_info", bodyData, this.handleFetchStreamListRsp.bind(this), function (err, seq) { }, undefined, {
                roomID: room === null || room === void 0 ? void 0 : room.roomID,
                sessionID: room === null || room === void 0 ? void 0 : room.sessionID,
                roomSessionID: room === null || room === void 0 ? void 0 : room.roomSessionID
            });
        }
        this.logger.info("zb.sh.fsl call success");
        // }
    };
    StreamHandler.prototype.handleReconnectStream = function (newStreamList) {
        this.logger.info("zb.sh.hrs call");
        var publisherList = this.streamCenter.publisherList;
        var playerList = this.streamCenter.playerList;
        var _loop_1 = function (streamID) {
            // 
            if (publisherList[streamID].roomID !== this_1.roomID)
                return "continue";
            if (publisherList[streamID].publisher.state ==
                zego_entity_1.ENUM_PUBLISH_STATE.publishing &&
                !newStreamList.find(function (stream) { return stream.stream_id == streamID; })) {
                var cmd = void 0;
                this_1.stateCenter.type === "PUBLIC"
                    ? (cmd = zego_entity_1.ENUM_STREAM_SUB_CMD.liveBegin)
                    : (cmd = zego_entity_1.ENUM_STREAM_CMD_PRI.liveBegin);
                this_1.updateStreamInfo(streamID, cmd, this_1.stateCenter.publishStreamList[streamID].extra_info);
                //
            }
            else if (publisherList[streamID].publisher.state == zego_entity_1.ENUM_PUBLISH_STATE.stop &&
                newStreamList.find(function (stream) { return stream.stream_id == streamID; })) {
                var cmd = void 0;
                this_1.stateCenter.type === "PUBLIC"
                    ? (cmd = zego_entity_1.ENUM_STREAM_SUB_CMD.liveEnd)
                    : (cmd = zego_entity_1.ENUM_STREAM_CMD_PRI.liveEnd);
                this_1.updateStreamInfo(streamID, cmd);
                //statecenter.streamList
                for (var i = 0; i < this_1.room.streamList.length; i++) {
                    if (this_1.room.streamList[i].stream_id == streamID) {
                        this_1.room.streamList.splice(i--, 1);
                        break;
                    }
                }
            }
        };
        var this_1 = this;
        for (var streamID in publisherList) {
            _loop_1(streamID);
        }
        //
        for (var streamID in publisherList) {
            if (publisherList[streamID].roomID !== this.roomID)
                continue;
            if (publisherList[streamID].isReDispatch) {
                this.logger.info("zb.sh.hrs " + streamID + "retry dispatch");
                var retryDispatchHandler = publisherList[streamID].retryDispatchHandler;
                retryDispatchHandler.stopMaxTime();
                retryDispatchHandler.invalid();
                retryDispatchHandler.initStream(streamID, publisherList[streamID].publishOption, true);
                retryDispatchHandler.active(0);
                publisherList[streamID].isReDispatch = false;
            }
        }
        for (var streamID in playerList) {
            if (playerList[streamID].roomID !== this.roomID)
                continue;
            if (playerList[streamID].isReDispatch) {
                this.logger.info("zb.sh.hrs " + streamID + "retry dispatch");
                var retryDispatchHandler = playerList[streamID].retryDispatchHandler;
                retryDispatchHandler.stopMaxTime();
                retryDispatchHandler.invalid();
                retryDispatchHandler.initStream(streamID, playerList[streamID].playOption, false);
                retryDispatchHandler.active(0);
                playerList[streamID].isReDispatch = false;
            }
        }
        this.logger.info("zb.sh.hrs end");
    };
    StreamHandler.prototype.makeCallbackStreamList = function (streamList) {
        var callbackStreamList = [];
        // if (this.stateCenter.type === "PUBLIC") {
        var resource_info = this.stateCenter.appConfig.media_config.play_config.resource_info;
        console.warn("resource_info", resource_info);
        var cdns = resource_info.find(function (item) {
            return item.resource_type === zego_entity_1.ResourceType.CDN;
        });
        // const stream = { urls_flv: flvs, urls_m3u8: hls, urls_rtmp: rtmps };
        if (streamList && streamList.length > 0) {
            for (var i = 0; i < streamList.length; i++) {
                var flvs = [];
                var hls = [];
                var rtmps = [];
                var streamID = streamList[i].stream_id;
                if (cdns) {
                    for (var i_1 = 0; i_1 < cdns.service_info.length; i_1++) {
                        var _a = cdns.service_info[i_1], protocol = _a.protocol, url_template = _a.url_template;
                        switch (protocol) {
                            case zego_entity_1.ProtocolType.FLV:
                                var flvUrl = url_template.replace("{STREAM_NAME}", streamID);
                                flvs.push(flvUrl);
                                break;
                            case zego_entity_1.ProtocolType.HLS:
                                var hlsUrl = url_template.replace("{STREAM_NAME}", streamID);
                                hls.push(hlsUrl);
                                break;
                            case zego_entity_1.ProtocolType.RTMP:
                                var rtmpUrl = url_template.replace("{STREAM_NAME}", streamID);
                                rtmps.push(rtmpUrl);
                                break;
                        }
                    }
                }
                streamList[i].urls_flv = flvs;
                streamList[i].urls_m3u8 = hls;
                streamList[i].urls_rtmp = rtmps;
                var streamInfo = {
                    user: {
                        userID: streamList[i].anchor_id_name || streamList[i].id_name,
                        userName: streamList[i].anchor_nick_name || streamList[i].nick_name
                    },
                    extraInfo: streamList[i].extra_info,
                    streamID: streamList[i].stream_id,
                    roomID: "",
                    urlFlv: "",
                    urlRtmp: "",
                    urlHls: "",
                    urlHttpsFlv: "",
                    urlHttpsHls: "",
                    streamGID: streamList[i].stream_gid,
                    closeType: streamList[i].close_type
                };
                this.setCDNInfo(streamInfo, streamList[i]);
                callbackStreamList.push(streamInfo);
            }
        }
        // } else {
        //   if (streamList && streamList.length > 0) {
        //     for (let i = 0; i < streamList.length; i++) {
        //       const streamInfo = {
        //         user_id: streamList[i].user_id,
        //         user_name: streamList[i].user_name,
        //         stream_id: streamList[i].stream_id,
        //         stream_sid: streamList[i].stream_sid,
        //         extra_info: streamList[i].extra_info,
        //         title: streamList[i].title,
        //         stream_ver: streamList[i].stream_ver
        //       };
        //       //this.setCDNInfo(streamInfo, streamList[i]);
        //       callbackStreamList.push(streamInfo);
        //     }
        //   }
        // }
        return callbackStreamList;
    };
    StreamHandler.prototype.sendBizChannelRequest = function (reqBody, success, error, isRetry) {
        var _this = this;
        if (isRetry === void 0) { isRetry = false; }
        reqBody = Object.assign(reqBody, { is_retry_req: isRetry ? 1 : 0 });
        var room = this.room;
        this.rtm.service.sendMessage("biz_channel", reqBody, function (msg, seq) {
            success(msg.header.seq, msg.body.cmd, msg.body.rsp_body);
        }, function (msg, seq) {
            var err = msg.body.err_code;
            var rspBody = msg.body.rsp_body;
            // retry
            if (typeof err == "number" && err === 2002) {
                _this.sendBizChannelRequest(reqBody, success, error, true);
                return;
            }
            error(err, seq, rspBody);
        }, undefined, {
            roomID: room === null || room === void 0 ? void 0 : room.roomID,
            sessionID: room === null || room === void 0 ? void 0 : room.sessionID,
            roomSessionID: room === null || room === void 0 ? void 0 : room.roomSessionID
        });
    };
    StreamHandler.prototype.sendBizChannelRequestV2 = function (requestInfo, reqBody, successCb, errorCb) {
        var _this = this;
        var server = requestInfo.server, location = requestInfo.location, cmd = requestInfo.cmd, channel = requestInfo.channel;
        var netAgent = this.rtm.netAgent;
        var httpIO = netAgent.getHttpRequest(server);
        var room = this.room;
        var bodyStr = undefined;
        var timestamp = reqBody.timestamp;
        if (reqBody) {
            bodyStr = JSON.stringify(reqBody);
        }
        var reqWrapBody = {
            cmd: cmd,
            req_body: bodyStr,
            appid: this.stateCenter.appid,
            timestamp: timestamp || Math.ceil(new Date().getTime() / 1000),
            // 
            token: room === null || room === void 0 ? void 0 : room.token,
            user_id: this.stateCenter.idName,
            channel: channel || "media"
        };
        console.error("token", room === null || room === void 0 ? void 0 : room.token);
        console.error("sendBizChannelRequestV2", reqWrapBody, requestInfo);
        httpIO === null || httpIO === void 0 ? void 0 : httpIO.sendRequest({
            headers: [],
            body: reqWrapBody,
            idName: this.stateCenter.idName,
            method_no: 2,
            ack: false,
            location: location
        }, function (res) {
            console.error("sendBizChannelRequestV2", res);
            var status_code = res.status_code, body = res.body;
            if (status_code !== 200) {
                errorCb(status_code);
                return;
            }
            var bodyWrap = body;
            if (typeof body === "string") {
                try {
                    bodyWrap = JSON.parse(body);
                }
                catch (error) {
                    errorCb(status_code);
                    throw error;
                }
            }
            var err_code = bodyWrap.err_code, rsp_body = bodyWrap.rsp_body;
            var rspBodyObj = undefined;
            try {
                rspBodyObj = JSON.parse(rsp_body);
            }
            catch (error) {
                rspBodyObj = rsp_body;
            }
            if (err_code !== 0) {
                if (typeof err_code == "number" && err_code === 2002) {
                    _this.sendBizChannelRequest(reqBody, successCb, errorCb, true);
                    return;
                }
                errorCb(status_code, err_code, rspBodyObj);
                return;
            }
            successCb(rspBodyObj);
        }, function (res, txid, errorCode) {
            errorCb(-1, -1, undefined, errorCode);
        });
    };
    StreamHandler.prototype.sendRTMPRequest = function (requestInfo, reqBody) {
        var location = "/v1/rtmp/dispatch/" + this.stateCenter.appid + "/777/push";
        var netAgent = this.rtm.netAgent;
        var httpIO = netAgent.getHttpRequest(1);
        var room = this.room;
        httpIO === null || httpIO === void 0 ? void 0 : httpIO.sendRequest({
            headers: [
                { name: "Token-Appid", val: this.stateCenter.appid + "" },
                { name: "Token-Str", val: (room === null || room === void 0 ? void 0 : room.token) || "" },
                { name: "Token-Userid", val: this.stateCenter.idName },
                { name: "Token-Biztype", val: "2" }
            ],
            body: {},
            idName: this.stateCenter.idName,
            method_no: 1,
            ack: false,
            location: location
        }, function (res) {
            console.log("rspBody", JSON.parse(res.body));
            // rtmpurl
            debugger;
        }, function (res, txid, error) { });
    };
    StreamHandler.prototype.updateStreamExtraInfo = function (streamid, extraInfo, success, error) { };
    StreamHandler.prototype.setStreamExtraInfo = function (streamID, extraInfo, success, error) { };
    StreamHandler.prototype._publishTarget = function (cdnPushConfig, success, error) { };
    StreamHandler.prototype.patchStreamList = function (msg) {
        var _this = this;
        if (typeof msg.body.StreamRefresh === "number" &&
            msg.body.StreamRefresh !== 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STREAMHANDLER_PATCH_STREAM_LIST + " stream refresh ");
            this.fetchStreamList();
            return;
        }
        if (msg.body.stream_seq !== this.streamSeq && !this.streamSeqMergeMap) {
            // 
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STREAMHANDLER_PATCH_STREAM_LIST +
                " call update stream " +
                this.streamSeq +
                " server " +
                msg.body.stream_seq);
            this.streamSeqMergeTimer && clearTimeout(this.streamSeqMergeTimer);
            this.streamSeqMergeTimer = setTimeout(function () {
                _this.handleMergeTimeout();
            }, this.streamListHBMergeInterval);
        }
        this.minStreamSeq = msg.body.stream_seq;
    };
    StreamHandler.prototype.mergeStreamByStreamSeq = function (cmd, streamSeq, streamList) {
        var _this = this;
        if (!this.streamSeqMergeMap) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.STREAMHANDLER_MERGE_STREAM_BY_STREAM_SEQ +
                " new merge stream list " +
                this.streamSeq +
                " server " +
                streamSeq);
            this.streamSeqMergeMap = {};
            //  streamSeq 
            this.streamSeqMergeTimer && clearTimeout(this.streamSeqMergeTimer);
            this.streamSeqMergeTimer = setTimeout(function () {
                _this.handleMergeTimeout();
            }, this.streamListMergeInterval);
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STREAMHANDLER_MERGE_STREAM_BY_STREAM_SEQ +
            (" " + this.streamSeqMergeMap + " " + cmd + " " + streamSeq + " " + streamList));
        this.streamSeqMergeMap[streamSeq] = { cmd: cmd, streamList: streamList };
    };
    StreamHandler.prototype.handleMergeTimeout = function () {
        if (!this.streamSeqMergeMap)
            return;
        var streamSeqList = Object.keys(this.streamSeqMergeMap)
            .map(function (key) { return +key; })
            .sort(function (a, b) { return a - b; });
        // streamSeq 
        if (streamSeqList[streamSeqList.length - 1] - streamSeqList[0] + 1 ===
            streamSeqList.length ||
            streamSeqList[streamSeqList.length - 1] >= this.minStreamSeq) {
            this.mergeStream(streamSeqList);
        }
        else {
            this.streamSeqMergeMap = null;
            this.fetchStreamList();
        }
    };
    StreamHandler.prototype.mergeStream = function (streamSeqList) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STREAMHANDLER_MERGE_STREAM +
            " merge streamList " +
            this.streamSeq +
            " streamSeqList " +
            streamSeqList.join(","));
        var streamSeq = streamSeqList[streamSeqList.length - 1];
        // streamSeq
        var streamList = [];
        streamSeqList.forEach(function (seq) {
            if (_this.streamSeqMergeMap && _this.streamSeqMergeMap[seq]) {
                switch (_this.streamSeqMergeMap[seq].cmd) {
                    case zego_entity_1.ENUM_STREAM_UPDATE_CMD.added:
                        _this.streamSeqMergeMap[seq].streamList.forEach(function (stream) {
                            var index = streamList.findIndex(function (_stream) { return _stream.stream_id == stream.stream_id; });
                            index !== -1 && streamList.splice(index);
                            streamList.push(stream);
                        });
                        break;
                    case zego_entity_1.ENUM_STREAM_UPDATE_CMD.deleted:
                        _this.streamSeqMergeMap[seq].streamList.forEach(function (stream) {
                            var index = streamList.findIndex(function (_stream) { return _stream.stream_id == stream.stream_id; });
                            index !== -1 && streamList.splice(index);
                        });
                        break;
                    case zego_entity_1.ENUM_STREAM_UPDATE_CMD.updated:
                        _this.streamSeqMergeMap[seq].streamList.forEach(function (stream) {
                            var index = streamList.findIndex(function (_stream) { return _stream.stream_id == stream.stream_id; });
                            index !== -1 && streamList.splice(index);
                            streamList.push(stream);
                        });
                        break;
                }
            }
        });
        this.streamSeqMergeMap = null;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STREAMHANDLER_MERGE_STREAM + " " + streamList);
        this.handleFullUpdateStream(streamSeq, streamList);
    };
    StreamHandler.prototype.reset = function () {
        this.minStreamSeq = 0;
        this.streamSeqMergeMap = null;
        if (this.streamSeqMergeTimer) {
            clearTimeout(this.streamSeqMergeTimer);
            this.streamSeqMergeTimer = undefined;
        }
        this.streamListHBMergeInterval = 2000;
        this.streamListMergeInterval = 5000;
    };
    return StreamHandler;
}());
exports.StreamHandler = StreamHandler;


/***/ }),

/***/ "./sdk/src/common/zego.entity.ts":
/*!***************************************!*\
  !*** ./sdk/src/common/zego.entity.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.E_CLIENT_TYPE = exports.ENUM_SOURCE_TYPE = exports.ENUM_DISPATCH_TYPE = exports.ENUM_BROADCASTER_STATUS = exports.ENUM_PLAY_SOURCE_TYPE = exports.ENUM_PUBLISH_STATE_NEGO = exports.ENUM_PUSH_SIGNAL_SUB_CMD = exports.ENUM_SIGNAL_SUB_CMD = exports.QUALITYLEVEL = exports.SERVER_ERROR_CODE = exports.ENUM_STREAM_UPDATE_CMD_PRI = exports.ENUM_STREAM_UPDATE_CMD = exports.MINIUM_HEARTBEAT_INTERVAL = exports.STREAM_DELETE_REASON = exports.ENUM_NETWORK_STATE = exports.ENUM_RUN_STATE = exports.ENUM_STREAM_UPDATE_TYPE = exports.ENUM_STREAM_CMD_PRI = exports.ENUM_STREAM_SUB_CMD = exports.ENUM_PUBLISH_STREAM_STATE = exports.MAX_RETRY_CONNECT_INTERVAL = exports.MAX_TRANS_DATA_LENGTH = exports.MAX_TRANS_TYPE_LENGTH = exports.MAX_MESSAGE_LENGTH = exports.MAX_ROOM_ID_LENGTH = exports.MAX_USER_NAME_LENGTH = exports.MAX_USER_ID_LENGTH = exports.MAX_STREAM_ID_LENGTH = exports.MAX_TRY_HEARTBEAT_COUNT = exports.SEND_MSG_TIMEOUT = exports.SEND_MSG_RESET = exports.MAX_TRY_CONNECT_COUNT = exports.streamMap = exports.ENUM_CONNECT_STATE = exports.ProtocolType = exports.ResourceType = exports.ENUM_PROBE_STATE = exports.ENUM_PLAY_STATE_NEGO = exports.ENUM_PLAYER_STATE = exports.ENUM_PLAY_STATE = exports.ENUM_PUBLISH_STATE = exports.ENUM_SCREEM_RESOLUTION_TYPE = exports.ENUM_RESOLUTION_TYPE = exports.ENUM_SIGNAL_STATE = exports.ERROR_CODES = exports.ENUM_REMOTE_TYPE = exports.LOG_LEVEL = exports.ENUM_LOG_LEVEL = exports.ROOMVERSION = exports.PROTO_VERSION = void 0;
exports.ZegoExpressWebRTM = exports.ZegoDataReport = exports.ZegoLogger = exports.ZegoExpressWebRTMEngine = exports.getReportSeq = exports.getSeq = exports.QUALITY_CONSTANT = exports.QualityGrade = exports.REPORT_ACTION = exports.ENUM_RETRY_STATE = exports.ENUM_PLAY_STATE_UPDATE = exports.ENUM_PUBLISH_STATE_UPDATE = exports.LinkedList = exports.ListNode = void 0;
exports.PROTO_VERSION = "2.13.0";
exports.ROOMVERSION = "V1";
var ENUM_LOG_LEVEL;
(function (ENUM_LOG_LEVEL) {
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["debug"] = 0] = "debug";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["info"] = 1] = "info";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["warn"] = 2] = "warn";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["error"] = 3] = "error";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["report"] = 99] = "report";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["disable"] = 100] = "disable";
})(ENUM_LOG_LEVEL = exports.ENUM_LOG_LEVEL || (exports.ENUM_LOG_LEVEL = {}));
exports.LOG_LEVEL = {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3,
    report: 99,
    disable: 100
};
var ENUM_REMOTE_TYPE;
(function (ENUM_REMOTE_TYPE) {
    ENUM_REMOTE_TYPE[ENUM_REMOTE_TYPE["disable"] = 0] = "disable";
    ENUM_REMOTE_TYPE[ENUM_REMOTE_TYPE["websocket"] = 1] = "websocket";
    ENUM_REMOTE_TYPE[ENUM_REMOTE_TYPE["https"] = 2] = "https";
})(ENUM_REMOTE_TYPE = exports.ENUM_REMOTE_TYPE || (exports.ENUM_REMOTE_TYPE = {}));
exports.ERROR_CODES = {
    ROOM_SESSION_ID_ERR: 1000000152,
    FETCH_TRANS_UNKNOWN_CHANNEL: 1000001108,
    FETCH_TRANS_UNKNOWN_TYPE: 1000001109,
    FETCH_TRANS_WRONG_SEQ: 1000001110
};
var ENUM_SIGNAL_STATE;
(function (ENUM_SIGNAL_STATE) {
    ENUM_SIGNAL_STATE[ENUM_SIGNAL_STATE["disconnected"] = 0] = "disconnected";
    ENUM_SIGNAL_STATE[ENUM_SIGNAL_STATE["connecting"] = 1] = "connecting";
    ENUM_SIGNAL_STATE[ENUM_SIGNAL_STATE["connected"] = 2] = "connected";
})(ENUM_SIGNAL_STATE = exports.ENUM_SIGNAL_STATE || (exports.ENUM_SIGNAL_STATE = {}));
exports.ENUM_RESOLUTION_TYPE = {
    LOW: {
        width: 320,
        height: 240,
        frameRate: 15,
        bitRate: 300
    },
    MEDIUM: {
        width: 640,
        height: 480,
        frameRate: 15,
        bitRate: 800
    },
    HIGH: {
        width: 1280,
        height: 720,
        frameRate: 20,
        bitRate: 1500
    }
};
exports.ENUM_SCREEM_RESOLUTION_TYPE = {
    LOW: {
        frameRate: 20,
        bitRate: 800
    },
    MEDIUM: {
        frameRate: 15,
        bitRate: 1500
    },
    HIGH: {
        frameRate: 5,
        bitRate: 2000
    }
};
exports.ENUM_PUBLISH_STATE = {
    start: 0,
    waitingSessionRsp: 1,
    waitingOfferRsp: 2,
    waitingServerAnswer: 3,
    waitingServerICE: 4,
    connecting: 5,
    publishing: 6,
    stop: 7,
    didNotStart: 8
};
exports.ENUM_PLAY_STATE = {
    start: 0,
    waitingSessionRsp: 1,
    waitingOfferRsp: 2,
    waitingServerAnswer: 3,
    waitingServerICE: 4,
    connecting: 5,
    playing: 6,
    stop: 7,
    didNotStart: 8
};
// 
exports.ENUM_PLAYER_STATE = {
    start: 0,
    playing: 1,
    stop: 2
};
exports.ENUM_PLAY_STATE_NEGO = {
    stop: 0,
    start: 1,
    waiterAnswer: 2,
    waitingCandidate: 3,
    sendCandidate: 4,
    iceConnected: 5,
    iceDisconnected: 6,
    iceClosed: 7,
    iceFailed: 8
};
var ENUM_PROBE_STATE;
(function (ENUM_PROBE_STATE) {
    ENUM_PROBE_STATE[ENUM_PROBE_STATE["tryProbe"] = 0] = "tryProbe";
    ENUM_PROBE_STATE[ENUM_PROBE_STATE["probed"] = 2] = "probed";
})(ENUM_PROBE_STATE = exports.ENUM_PROBE_STATE || (exports.ENUM_PROBE_STATE = {}));
var ResourceType;
(function (ResourceType) {
    ResourceType[ResourceType["CDN"] = 0] = "CDN";
    ResourceType[ResourceType["RTC"] = 1] = "RTC";
    ResourceType[ResourceType["L3"] = 2] = "L3";
})(ResourceType = exports.ResourceType || (exports.ResourceType = {}));
var ProtocolType;
(function (ProtocolType) {
    ProtocolType[ProtocolType["UDP"] = 0] = "UDP";
    ProtocolType[ProtocolType["RTMP"] = 1] = "RTMP";
    ProtocolType[ProtocolType["FLV"] = 2] = "FLV";
    ProtocolType[ProtocolType["HLS"] = 3] = "HLS";
    ProtocolType[ProtocolType["WEBRTC"] = 4] = "WEBRTC";
})(ProtocolType = exports.ProtocolType || (exports.ProtocolType = {}));
exports.ENUM_CONNECT_STATE = {
    disconnect: 0,
    connecting: 1,
    connected: 2
};
exports.streamMap = {
    "/lr/push/stream_add": 12001,
    "/lr/push/stream_delete": 12002,
    "/lr/push/stream_update": 12003
};
exports.MAX_TRY_CONNECT_COUNT = 3;
exports.SEND_MSG_RESET = 2;
exports.SEND_MSG_TIMEOUT = 1;
exports.MAX_TRY_HEARTBEAT_COUNT = 5;
exports.MAX_STREAM_ID_LENGTH = 256;
exports.MAX_USER_ID_LENGTH = 64;
exports.MAX_USER_NAME_LENGTH = 256;
exports.MAX_ROOM_ID_LENGTH = 128;
exports.MAX_MESSAGE_LENGTH = 1024;
exports.MAX_TRANS_TYPE_LENGTH = 128;
exports.MAX_TRANS_DATA_LENGTH = 1024 * 4;
exports.MAX_RETRY_CONNECT_INTERVAL = 12;
exports.ENUM_PUBLISH_STREAM_STATE = {
    waiting_url: 1,
    tryPublish: 2,
    update_info: 3,
    publishing: 4,
    stop: 5,
    retryPublish: 6
};
exports.ENUM_STREAM_SUB_CMD = {
    liveNone: 0,
    liveBegin: 2001,
    liveEnd: 2002,
    liveUpdate: 2003
};
exports.ENUM_STREAM_CMD_PRI = {
    liveBegin: "zegochat_js.room_stream_create_req",
    liveEnd: "zegochat_js.room_stream_delete_req",
    liveUpdate: "zegochat_js.room_stream_update_req"
};
exports.ENUM_STREAM_UPDATE_TYPE = {
    added: 1,
    deleted: 0
};
//
var ENUM_RUN_STATE;
(function (ENUM_RUN_STATE) {
    ENUM_RUN_STATE[ENUM_RUN_STATE["logout"] = 0] = "logout";
    ENUM_RUN_STATE[ENUM_RUN_STATE["trylogin"] = 1] = "trylogin";
    ENUM_RUN_STATE[ENUM_RUN_STATE["login"] = 2] = "login";
})(ENUM_RUN_STATE = exports.ENUM_RUN_STATE || (exports.ENUM_RUN_STATE = {}));
var ENUM_NETWORK_STATE;
(function (ENUM_NETWORK_STATE) {
    ENUM_NETWORK_STATE[ENUM_NETWORK_STATE["offline"] = 0] = "offline";
    ENUM_NETWORK_STATE[ENUM_NETWORK_STATE["online"] = 1] = "online";
})(ENUM_NETWORK_STATE = exports.ENUM_NETWORK_STATE || (exports.ENUM_NETWORK_STATE = {}));
exports.STREAM_DELETE_REASON = {
    0: {
        code: 1,
        description: "user_stop_publishing_stream_normal"
    },
    1: {
        code: 2,
        description: "user_heart_beat_timeout"
    },
    2: {
        code: 3,
        description: "user_repeat_login"
    },
    3: {
        code: 4,
        description: "user_kicked_out"
    },
    4: {
        code: 5,
        description: "user_offline"
    },
    100: {
        code: 6,
        description: "remove_by_server"
    }
    // 1000: {
    //     code: 0,
    //     description: 'unknown',
    // },
};
exports.MINIUM_HEARTBEAT_INTERVAL = 3000; //
exports.ENUM_STREAM_UPDATE_CMD = {
    added: 12001,
    deleted: 12002,
    updated: 12003
};
exports.ENUM_STREAM_UPDATE_CMD_PRI = {
    added: 1,
    updated: 2,
    deleted: 3
};
exports.SERVER_ERROR_CODE = 10000;
var QUALITYLEVEL;
(function (QUALITYLEVEL) {
    QUALITYLEVEL[QUALITYLEVEL["low"] = 1] = "low";
    QUALITYLEVEL[QUALITYLEVEL["stantard"] = 2] = "stantard";
    QUALITYLEVEL[QUALITYLEVEL["hight"] = 3] = "hight";
    QUALITYLEVEL[QUALITYLEVEL["custome"] = 4] = "custome";
})(QUALITYLEVEL = exports.QUALITYLEVEL || (exports.QUALITYLEVEL = {}));
exports.ENUM_SIGNAL_SUB_CMD = {
    none: 0,
    joinLiveRequest: 1001,
    joinLiveResult: 1002,
    joinLiveInvite: 1003,
    joinLiveStop: 1004
};
exports.ENUM_PUSH_SIGNAL_SUB_CMD = {
    none: 0,
    pushJoinLiveRequest: 11001,
    pushJoinLiveResult: 11002,
    pushJoinLiveInvite: 11003,
    pushJoinLiveStop: 11004
};
exports.ENUM_PUBLISH_STATE_NEGO = {
    stop: 0,
    start: 1,
    waiterAnswer: 2,
    waitingCandidate: 3,
    sendCandidate: 4,
    iceConnected: 5,
    iceDisconnected: 6,
    iceClosed: 7,
    iceFailed: 8
};
//
var ENUM_PLAY_SOURCE_TYPE;
(function (ENUM_PLAY_SOURCE_TYPE) {
    ENUM_PLAY_SOURCE_TYPE[ENUM_PLAY_SOURCE_TYPE["cdn"] = 0] = "cdn";
    ENUM_PLAY_SOURCE_TYPE[ENUM_PLAY_SOURCE_TYPE["ultra"] = 1] = "ultra";
})(ENUM_PLAY_SOURCE_TYPE = exports.ENUM_PLAY_SOURCE_TYPE || (exports.ENUM_PLAY_SOURCE_TYPE = {}));
//
var ENUM_BROADCASTER_STATUS;
(function (ENUM_BROADCASTER_STATUS) {
    ENUM_BROADCASTER_STATUS[ENUM_BROADCASTER_STATUS["stop"] = 0] = "stop";
    ENUM_BROADCASTER_STATUS[ENUM_BROADCASTER_STATUS["start"] = 1] = "start";
})(ENUM_BROADCASTER_STATUS = exports.ENUM_BROADCASTER_STATUS || (exports.ENUM_BROADCASTER_STATUS = {}));
//
var ENUM_DISPATCH_TYPE;
(function (ENUM_DISPATCH_TYPE) {
    ENUM_DISPATCH_TYPE[ENUM_DISPATCH_TYPE["cdn"] = 0] = "cdn";
    ENUM_DISPATCH_TYPE[ENUM_DISPATCH_TYPE["ultra"] = 1] = "ultra";
    ENUM_DISPATCH_TYPE[ENUM_DISPATCH_TYPE["customUrl"] = 2] = "customUrl";
})(ENUM_DISPATCH_TYPE = exports.ENUM_DISPATCH_TYPE || (exports.ENUM_DISPATCH_TYPE = {}));
var ENUM_SOURCE_TYPE;
(function (ENUM_SOURCE_TYPE) {
    ENUM_SOURCE_TYPE[ENUM_SOURCE_TYPE["CDN"] = 0] = "CDN";
    ENUM_SOURCE_TYPE[ENUM_SOURCE_TYPE["BGP"] = 1] = "BGP";
})(ENUM_SOURCE_TYPE = exports.ENUM_SOURCE_TYPE || (exports.ENUM_SOURCE_TYPE = {}));
var E_CLIENT_TYPE;
(function (E_CLIENT_TYPE) {
    E_CLIENT_TYPE[E_CLIENT_TYPE["ClientType_None"] = 0] = "ClientType_None";
    E_CLIENT_TYPE[E_CLIENT_TYPE["ClientType_H5"] = 1] = "ClientType_H5";
    E_CLIENT_TYPE[E_CLIENT_TYPE["ClientType_SmallPragram"] = 2] = "ClientType_SmallPragram";
    E_CLIENT_TYPE[E_CLIENT_TYPE["ClientType_Webrtc"] = 3] = "ClientType_Webrtc"; //webrtc
})(E_CLIENT_TYPE = exports.E_CLIENT_TYPE || (exports.E_CLIENT_TYPE = {}));
var ListNode = /** @class */ (function () {
    function ListNode(id, data) {
        if (id === void 0) { id = null; }
        if (data === void 0) { data = null; }
        this._id = null;
        this.next = null;
        this.prev = null;
        this._id = id;
        this._data = data;
    }
    Object.defineProperty(ListNode.prototype, "id", {
        get: function () {
            if (this._id) {
                return this._id;
            }
            else {
                return null;
            }
        },
        set: function (id) {
            this._id = id;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ListNode.prototype, "data", {
        get: function () {
            return this._data;
        },
        set: function (data) {
            this._data = data;
        },
        enumerable: false,
        configurable: true
    });
    ListNode.prototype.hasNext = function () {
        return this.next && this.next.id;
    };
    ListNode.prototype.hasPrev = function () {
        return this.prev && this.prev.id;
    };
    return ListNode;
}());
exports.ListNode = ListNode;
var LinkedList = /** @class */ (function () {
    function LinkedList() {
        //initialize end buffer nodes
        this.start = new ListNode();
        this.end = new ListNode();
        //initialize counters
        this._idCounter = 0;
        this._numNodes = 0;
        //initialize node pointers
        this.start.next = this.end;
        this.start.prev = null;
        this.end.prev = this.start;
        this.end.next = null;
    }
    /**
     *   Inserts a node before another node in the linked list
     *   @param {Node} toInsertBefore
     *   @param {Node} node
     */
    LinkedList.prototype.insertBefore = function (toInsertBefore, data) {
        var newNode = new ListNode(this._idCounter, data);
        newNode.next = toInsertBefore;
        newNode.prev = toInsertBefore.prev;
        if (toInsertBefore.prev)
            toInsertBefore.prev.next = newNode;
        toInsertBefore.prev = newNode;
        ++this._idCounter;
        ++this._numNodes;
        return newNode;
    };
    /**
     *   Adds data wrapped in a Node object to the end of the linked list
     *   @param {object} data
     */
    LinkedList.prototype.addLast = function (data) {
        return this.insertBefore(this.end, data);
    };
    /**
     *   Alias for addLast
     *   @param {object} data
     */
    LinkedList.prototype.add = function (data) {
        return this.addLast(data);
    };
    /**
     *   Gets and returns the first node in the linked list or null
     *   @return {Node/null}
     */
    LinkedList.prototype.getFirst = function () {
        if (this._numNodes === 0) {
            return null;
        }
        else {
            return this.start.next;
        }
    };
    /**
     *   Gets and returns the last node in the linked list or null
     *   @return {Node/null}
     */
    LinkedList.prototype.getLast = function () {
        if (this._numNodes === 0) {
            return null;
        }
        else {
            return this.end.prev;
        }
    };
    /**
     *   Gets and returns the size of the linked list
     *   @return {number}
     */
    LinkedList.prototype.size = function () {
        return this._numNodes;
    };
    /**
     *   (Internal) Gets and returns the node at the specified index starting from the first in the linked list
     *   Use getAt instead of this function
     *   @param {number} index
     */
    LinkedList.prototype.getFromFirst = function (index) {
        var count = 0, temp = this.start.next;
        if (index >= 0) {
            while (count < index && temp !== null) {
                temp = temp.next;
                ++count;
            }
        }
        else {
            temp = null;
        }
        if (temp === null) {
            throw "Index out of bounds.";
        }
        return temp;
    };
    /**
     *   Gets and returns the Node at the specified index in the linked list
     *   @param {number} index
     */
    LinkedList.prototype.get = function (index) {
        var temp = null;
        if (index === 0) {
            temp = this.getFirst();
        }
        else if (index === this._numNodes - 1) {
            temp = this.getLast();
        }
        else {
            temp = this.getFromFirst(index);
        }
        return temp;
    };
    /**
     *   Removes and returns node from the linked list by rearranging pointers
     *   @param {Node} node
     *   @return {Node}
     */
    LinkedList.prototype.remove = function (node) {
        if (node.prev)
            node.prev.next = node.next;
        if (node.next)
            node.next.prev = node.prev;
        --this._numNodes;
        return node;
    };
    /**
     *   Removes and returns the first node in the linked list if it exists, otherwise returns null
     *   @return {Node/null}
     */
    LinkedList.prototype.removeFirst = function () {
        var temp = null;
        if (this._numNodes > 0 && this.start.next) {
            temp = this.remove(this.start.next);
        }
        return temp;
    };
    /**
     *   Removes and returns the last node in the linked list if it exists, otherwise returns null
     *   @return {Node/null}
     */
    LinkedList.prototype.removeLast = function () {
        var temp = null;
        if (this._numNodes > 0 && this.end.prev) {
            temp = this.remove(this.end.prev);
        }
        return temp;
    };
    /**
     *   Removes all nodes from the list
     */
    LinkedList.prototype.removeAll = function () {
        this.start.next = this.end;
        this.end.prev = this.start;
        this._numNodes = 0;
        this._idCounter = 0;
    };
    /**
     *    Iterates the list calling the given fn for each node
     *    @param {function} fn
     */
    LinkedList.prototype.each = function (iterator) {
        var temp = this.start;
        while (temp.hasNext()) {
            temp = temp.next;
            iterator(temp);
        }
    };
    LinkedList.prototype.find = function (iterator) {
        var temp = this.start, found = false, result = null;
        while (temp.hasNext() && !found) {
            temp = temp.next;
            if (iterator(temp)) {
                result = temp;
                found = true;
            }
        }
        return result;
    };
    LinkedList.prototype.map = function (iterator) {
        var temp = this.start;
        var results = [];
        while (temp.hasNext()) {
            temp = temp.next;
            if (iterator(temp)) {
                results.push(temp);
            }
        }
        return results;
    };
    /**
     *    Alias for addLast
     *    @param {object} data
     */
    LinkedList.prototype.push = function (data) {
        return this.addLast(data);
    };
    /**
     *    Performs insertBefore on the first node
     *    @param {object} data
     */
    LinkedList.prototype.unshift = function (data) {
        if (this._numNodes > 0) {
            this.insertBefore(this.start.next, data);
        }
        else {
            this.insertBefore(this.end, data);
        }
    };
    /**
     *    Alias for removeLast
     */
    LinkedList.prototype.pop = function () {
        return this.removeLast();
    };
    /**
     *    Alias for removeFirst()
     */
    LinkedList.prototype.shift = function () {
        return this.removeFirst();
    };
    return LinkedList;
}());
exports.LinkedList = LinkedList;
exports.ENUM_PUBLISH_STATE_UPDATE = {
    start: 0,
    error: 1,
    retry: 2
};
exports.ENUM_PLAY_STATE_UPDATE = {
    start: 0,
    error: 1,
    retry: 2,
    stop: 3
};
exports.ENUM_RETRY_STATE = {
    didNotStart: 0,
    retrying: 1,
    finished: 2
};
exports.REPORT_ACTION = {
    eventStart: "eventStart",
    eventEndWithMsgInfo: "eventEndWithMsgInfo",
    addEventMsg: "addEventMsg",
    addEvent: "addEvent",
    eventEnd: "eventEnd",
    addMsgInfo: "addMsgInfo"
};
var QualityGrade;
(function (QualityGrade) {
    QualityGrade[QualityGrade["Unknown"] = -1] = "Unknown";
    QualityGrade[QualityGrade["Excellent"] = 0] = "Excellent";
    QualityGrade[QualityGrade["Good"] = 1] = "Good";
    QualityGrade[QualityGrade["Middle"] = 2] = "Middle";
    QualityGrade[QualityGrade["Poor"] = 3] = "Poor";
    QualityGrade[QualityGrade["Die"] = 4] = "Die";
})(QualityGrade = exports.QualityGrade || (exports.QualityGrade = {}));
var QUALITY_CONSTANT;
(function (QUALITY_CONSTANT) {
    QUALITY_CONSTANT[QUALITY_CONSTANT["MinQuality"] = 0] = "MinQuality";
    QUALITY_CONSTANT[QUALITY_CONSTANT["DieQuality"] = 0] = "DieQuality";
    QUALITY_CONSTANT[QUALITY_CONSTANT["PoorMinQuality"] = 1] = "PoorMinQuality";
    QUALITY_CONSTANT[QUALITY_CONSTANT["MiddleMinQuality"] = 30] = "MiddleMinQuality";
    QUALITY_CONSTANT[QUALITY_CONSTANT["GoodMinQuality"] = 60] = "GoodMinQuality";
    QUALITY_CONSTANT[QUALITY_CONSTANT["ExcellentMinQuality"] = 85] = "ExcellentMinQuality";
    QUALITY_CONSTANT[QUALITY_CONSTANT["MaxQuality"] = 100] = "MaxQuality";
})(QUALITY_CONSTANT = exports.QUALITY_CONSTANT || (exports.QUALITY_CONSTANT = {}));
var zego_express_engine_webrtm_1 = __webpack_require__(/*! zego-express-engine-webrtm */ "../zego_express_web_rtm/dist/ZegoExpressWebRTM.js");
Object.defineProperty(exports, "getSeq", ({ enumerable: true, get: function () { return zego_express_engine_webrtm_1.getSeq; } }));
Object.defineProperty(exports, "getReportSeq", ({ enumerable: true, get: function () { return zego_express_engine_webrtm_1.getReportSeq; } }));
Object.defineProperty(exports, "ZegoExpressWebRTMEngine", ({ enumerable: true, get: function () { return zego_express_engine_webrtm_1.ZegoExpressWebRTMEngine; } }));
Object.defineProperty(exports, "ZegoLogger", ({ enumerable: true, get: function () { return zego_express_engine_webrtm_1.ZegoLogger; } }));
Object.defineProperty(exports, "ZegoDataReport", ({ enumerable: true, get: function () { return zego_express_engine_webrtm_1.ZegoDataReport; } }));
Object.defineProperty(exports, "ZegoExpressWebRTM", ({ enumerable: true, get: function () { return zego_express_engine_webrtm_1.ZegoExpressWebRTM; } }));


/***/ }),

/***/ "./sdk/src/common/zego.error.ts":
/*!**************************************!*\
  !*** ./sdk/src/common/zego.error.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorCodeList = void 0;
exports.errorCodeList = {
    // commonErr
    NOT_LOGIN: {
        code: 1000002,
        message: "not login room"
    },
    STREAMID_TOO_LONG: {
        code: 1000014,
        message: "stream ID is too long"
    },
    STREAM_ID_NULL: {
        code: 1000015,
        message: "streamID is empty"
    },
    STREAM_ID_INVALID_CHARACTER: {
        code: 1000016,
        message: "stream ID contains illegal characters"
    },
    NETWORK_BROKEN: {
        code: 1000017,
        message: "network is broken"
    },
    LOCALSTREAM_WRONG: {
        code: 1000018,
        message: "local stream wrong"
    },
    GET_CONFIG_FAIL: {
        code: 1103069,
        message: "get app config fail"
    },
    // 
    INPUT_PARAM: {
        code: 1100001,
        message: "input param error."
    },
    TIMEOUT: {
        code: 1100002,
        message: "network timeout."
    },
    SOCKET_CLOSE: {
        code: 1100003,
        msg: "socket close"
    },
    // rtc 
    INIT_SDK_WRONG: {
        code: 1101000,
        message: "init sdk wrong"
    },
    WX_GET_SETTING_FAIL: {
        code: 1101001,
        message: "wx get setting fail"
    },
    // roomErr
    // NONE_APP_ID: {
    //     code: 1001000,
    //     message: 'app id can not be 0',
    // },
    // ROOM_COUNT_EXCEED: {
    //     code: 1002001,
    //     message: 'login rooms exceeds the upper limit',
    // },
    USER_ID_NULL: {
        code: 1002005,
        message: "user ID is empty"
    },
    USER_ID_INVALID_CHARACTER: {
        code: 1002006,
        message: "user ID contains illegal characters"
    },
    USER_ID_TOO_LONG: {
        code: 1002007,
        message: "user ID is too long"
    },
    USER_NAME_NULL: {
        code: 1002008,
        message: "username is empty"
    },
    // USER_NAME_INVALID_CHARACTER: {
    //     code: 1002009,
    //     message: 'username contains illegal characters',
    // },
    USER_NAME_TOO_LONG: {
        code: 1002010,
        message: "username is too long"
    },
    ROOM_ID_NULL: {
        code: 1002011,
        message: "room ID is empty"
    },
    ROOM_ID_INVALID_CHARACTER: {
        code: 1002012,
        message: "room ID contains illegal characters"
    },
    ROOM_ID_TOO_LONG: {
        code: 1002013,
        message: "room ID is too long"
    },
    LOGIN_TIMEOUT: {
        code: 1002031,
        message: "login timeout"
    },
    ROOM_MAX_USER_COUNT: {
        code: 1002034,
        message: "users logging into the room exceeds the maximum number"
    },
    MULTIPLE_LOGIN_KICKOUT: {
        code: 1002050,
        message: "kickout may be the same user ID login other"
    },
    ROOM_RETRY_TIMEOUT: {
        code: 1002053,
        message: "network is broken and login fail."
    },
    MANUAL_KICKOUT: {
        code: 1002055,
        message: "server has sent a signal to kick out"
    },
    ROOM_INNER_ERROR: {
        code: 1002099,
        message: "room inner error"
    },
    // web
    HEARTBEAT_TIMEOUT: {
        code: 1102001,
        message: "heartbeat timeout."
    },
    // access_svr
    PARSE_JSON_ERROR: {
        code: 1102011,
        message: "parse json error."
    },
    LOGIN_PROCESSING: {
        code: 1102012,
        message: "login is processing."
    },
    LIVEROOM_REQUEST_ERROR: {
        code: 1102013,
        message: "liveroom request error."
    },
    ZPUSH_REQUEST_FAIL: {
        code: 1102014,
        message: "zpush request fail."
    },
    LOGIN_STATE_WRONG: {
        code: 1102015,
        message: "user login state is wrong."
    },
    TOKEN_ERROR: {
        code: 1102016,
        message: "token error"
    },
    DISPATCH_ERROR: {
        code: 1102017,
        message: "dispatch error"
    },
    TOKEN_EXPIRED: {
        code: 1102018,
        message: "token expired"
    },
    SUBCMD_ERROR: {
        code: 1102019,
        message: "subcmd error."
    },
    ZEGO_AUTH_ERROR: {
        code: 1102020,
        message: "zego auth error."
    },
    BIZ_CHANNEL_ERROR: {
        code: 1102021,
        message: "biz channel error."
    },
    DISPATCH_TIMEOUT: {
        code: 1102022,
        message: "dispatch request timeout"
    },
    CONNECT_FAILED: {
        code: 1102023,
        message: "connect signal fail"
    },
    // ROOM_INNER_ERROR: {
    //     code: 1102099,
    //     message: 'unknown error.',
    // },
    // publishStreamErr
    PUBLISHER_MEDIA_SERVER_FORBID: {
        code: 1003025,
        message: "stream is forbided by media server"
    },
    PUBLISHER_EXTRA_INFO_TOO_LONG: {
        code: 1003051,
        message: "stream extra info is too long"
    },
    PUBLISHER_PARAM: {
        code: 1103001,
        message: "input param error"
    },
    PUBLISHER_BROWSER_NOT_SUPPORT: {
        code: 1103002,
        message: "browser do not support"
    },
    PUBLISHER_DISPATCH_FAIL: {
        code: 1103003,
        message: "dispatch request error"
    },
    PUBLISHER_SCREEN_FAILED: {
        code: 1103010,
        message: "screen fail"
    },
    ENUMERATE_DEVICES_FAIL: {
        code: 1103011,
        message: "enumerate devices fail"
    },
    PUBLISHER_DISPATCH_REQUEST_FAIL: {
        code: 1103020,
        message: "dispatch request fail"
    },
    PUBLISHER_SESSION_REQUEST_FAIL: {
        code: 1103021,
        message: "session request fail"
    },
    PUBLISHER_CREATE_OFFER_ERROR: {
        code: 1103022,
        message: "create offer error"
    },
    PUBLISHER_SET_LOCAL_DESC_ERROR: {
        code: 1103023,
        message: "setLocalDescription error"
    },
    PUBLISHER_MEDIA_DESC_ERROR: {
        code: 1103024,
        message: "mediaDesc error"
    },
    PUBLISHER_SET_REMOTE_DESC_ERROR: {
        code: 1103025,
        message: "other side offer error"
    },
    PUBLISHER_CANDIDATE_ERROR: {
        code: 1103026,
        message: "candidate error"
    },
    PUBLISHER_SESSION_CLOSED: {
        code: 1103027,
        message: "server session closed"
    },
    PUBLISHER_MEDIA_CONNECTION_ERROR: {
        code: 1103028,
        message: "ice connection error"
    },
    PUBLISHER_SERVER_NEGO_TIMEOUT: {
        code: 1103030,
        message: "negotiation timeout"
    },
    PUBLISH_DEVICE_OUT_ERR: {
        code: 1103041,
        message: "device change "
    },
    PUBLISH_SCREEN_CANCELED: {
        code: 1103042,
        message: "screen canceled"
    },
    PUBLISH_SCREEN_NOT_SUPPORT: {
        code: 1103043,
        message: "screen not support"
    },
    PUBLISH_NO_PREVIEW: {
        code: 1103044,
        message: "stream is not from zego"
    },
    REPEATED_PULL: {
        code: 1103049,
        message: "repeated pull same stream"
    },
    PUBLISHER_WEBSOCKET_DISCONNECTED: {
        code: 1103050,
        message: "websocket disconnected"
    },
    PUBLISHER_RETRY_TIMEOUT: {
        code: 1103051,
        message: "publisher retry timeout"
    },
    PUBLISHER_HTTPS_REQUIRED: {
        code: 1103053,
        message: "https is required"
    },
    PUBLISHER_NO_PREVIEW: {
        code: 1103054,
        message: "no preview"
    },
    PUBLISHER_STREAM_NO_FOUND: {
        code: 1103055,
        message: "publish stream no found"
    },
    PUBLISHER_IS_PUBLISHING: {
        code: 1103056,
        message: "publish is publishing"
    },
    PUBLISHER_CLIENT_IP_CHANGED: {
        code: 1103058,
        message: "client ip changed"
    },
    PUBLISHER_TTL_OVERTIME: {
        code: 1103059,
        message: "ttl over time"
    },
    PUBLISHER_SESSION_TIMEOUT: {
        code: 1103060,
        message: "session request timeout"
    },
    PUBLISHER_GET_USER_MEDIA_FAIL: {
        code: 1103061,
        message: "get media fail"
    },
    PUBLISHER_DEVICE_NO_ALLOWED: {
        code: 1103064,
        message: "get device not allowed"
    },
    PUBLISHER_DEVICE_NO_READABLE: {
        code: 1103065,
        message: "device is not readable"
    },
    PUBLISHER_OVER_CONSTRAINED: {
        code: 1103066,
        message: "device does not meet constraints"
    },
    PUBLISHER_UPDATE_SDP_TIMEOUT: {
        code: 1103067,
        message: "update sdp time out"
    },
    PUBLISHER_UPDATE_SDP_FAIL: {
        code: 1103068,
        message: "update sdp fail"
    },
    // play
    PLAYER_PARAM: {
        code: 1104001,
        message: "input parm error"
    },
    PLAYER_DISPATCH_REQUEST_FAIL: {
        code: 1104020,
        message: "dispatch request fail"
    },
    PLAYER_SESSION_REQUEST_FAIL: {
        code: 1104021,
        message: "session request fail"
    },
    PLAYER_CREATE_OFFER_ERROR: {
        code: 1104022,
        message: "create offer error"
    },
    PLAYER_SET_LOCAL_DESC_ERROR: {
        code: 1104023,
        message: "setLocalDescription error"
    },
    PLAYER_MEDIA_DESC_ERROR: {
        code: 1104024,
        message: "mediaDesc error"
    },
    PLAYER_SET_REMOTE_DESC_ERROR: {
        code: 1104025,
        message: "other side offer error"
    },
    PLAYER_CANDIDATE_ERROR: {
        code: 1104026,
        message: "candidate error"
    },
    PLAYER_SESSION_CLOSED: {
        code: 1104027,
        message: "server session closed"
    },
    PLAYER_MEDIA_CONNECTION_ERROR: {
        code: 1104028,
        message: "ice connection error"
    },
    PLAYER_WEBSOCKET_DISCONNECTED: {
        code: 1104029,
        message: "websocket disconnected"
    },
    PLAYER_SERVER_NEGO_TIMEOUT: {
        code: 1104030,
        message: "negotiation timeout"
    },
    PLAYER_RETRY_TIMEOUT: {
        code: 1104031,
        message: "player retry timeout"
    },
    PLAYER_IS_PLAYING: {
        code: 1104032,
        message: "player is playing"
    },
    PLAYER_CLIENT_IP_CHANGED: {
        code: 1104033,
        message: "client ip changed"
    },
    PLAYER_TTL_OVERTIME: {
        code: 1104034,
        message: "ttl is over time"
    },
    PLAYER_SESSION_RESET: {
        code: 1104035,
        message: "reset session push"
    },
    PLAYER_SESSION_TIMEOUT: {
        code: 1104036,
        message: "session request timeout"
    },
    PLAYER_PROBE_TIMEOUT: {
        code: 1104037,
        message: "probe time out"
    },
    PLAYER_UNSUPPORTED_PROTOCOL: {
        code: 1104038,
        message: "resource mode is not supported"
    },
    DEVICE_ERROR_TYPE_UNPLUGGED: {
        code: 1006006,
        message: "the device is unplugged"
    },
    // imErr
    IM_CONTENT_NULL: {
        code: 1009001,
        message: "message content is empty"
    },
    IM_CONTENT_TOO_LONG: {
        code: 1009002,
        message: "message content is too long"
    },
    IM_SEND_FAILED: {
        code: 1009010,
        message: "failed to send message"
    },
    // web
    FREQ_LIMITED: {
        code: 1109001,
        message: "frequency limited."
    }
};


/***/ }),

/***/ "./sdk/src/common/zego.log.event.ts":
/*!******************************************!*\
  !*** ./sdk/src/common/zego.log.event.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoWechatLogEvent = exports.ZegoRTCLogEvent = void 0;
var zego_error_1 = __webpack_require__(/*! ./zego.error */ "./sdk/src/common/zego.error.ts");
// import * as fs from "fs";
// import * as path from "path";
var getItem = function (item) { return item; };
exports.ZegoRTCLogEvent = {
    kZegoTaskCreateStream: {
        event: "/sdk/create_stream",
        error: {
            kBrowserNotSupportError: zego_error_1.errorCodeList.PUBLISHER_BROWSER_NOT_SUPPORT,
            kParamError: zego_error_1.errorCodeList.PUBLISHER_PARAM,
            kScreenCancelError: zego_error_1.errorCodeList.PUBLISH_SCREEN_CANCELED,
            kScreenFailedError: zego_error_1.errorCodeList.PUBLISHER_SCREEN_FAILED,
            kScreenNotSupportError: zego_error_1.errorCodeList.PUBLISH_SCREEN_NOT_SUPPORT,
            kHttpsRequiredError: zego_error_1.errorCodeList.PUBLISHER_HTTPS_REQUIRED,
            kGetUserMediaError: zego_error_1.errorCodeList.PUBLISHER_GET_USER_MEDIA_FAIL,
            kDeviceNoAllowedError: zego_error_1.errorCodeList.PUBLISHER_DEVICE_NO_ALLOWED,
            kDeviceNoReadableError: zego_error_1.errorCodeList.PUBLISHER_DEVICE_NO_READABLE,
            kDeviceOverConstrainedError: zego_error_1.errorCodeList.PUBLISHER_OVER_CONSTRAINED
        },
        stream_type: getItem,
        screen: getItem,
        camera: getItem,
        custom: getItem
    },
    kZegoTaskPublishStart: {
        event: "/sdk/api/publish_request",
        error: {
            kPublishParamError: zego_error_1.errorCodeList.PUBLISHER_PARAM,
            kPublishNetworkTimeoutError: zego_error_1.errorCodeList.TIMEOUT,
            kPublishDispatchTimeoutError: zego_error_1.errorCodeList.DISPATCH_TIMEOUT,
            kPublishDispatchError: zego_error_1.errorCodeList.DISPATCH_ERROR,
            kPublishNetworkBrokenError: zego_error_1.errorCodeList.NETWORK_BROKEN,
            kPublishNoPreviewError: zego_error_1.errorCodeList.PUBLISH_NO_PREVIEW,
            kPublishNoLoginError: zego_error_1.errorCodeList.NOT_LOGIN,
            kPublishRetryTimeoutError: zego_error_1.errorCodeList.PUBLISHER_RETRY_TIMEOUT,
            kMediaServerForbidError: zego_error_1.errorCodeList.PUBLISHER_MEDIA_SERVER_FORBID,
            kPublishTokenExpiredError: zego_error_1.errorCodeList.TOKEN_EXPIRED,
            kPublishSessionClosedError: zego_error_1.errorCodeList.PUBLISHER_SESSION_CLOSED,
            kPublishNegoTimeoutError: zego_error_1.errorCodeList.PUBLISHER_SERVER_NEGO_TIMEOUT,
            kCreateOfferError: zego_error_1.errorCodeList.PUBLISHER_CREATE_OFFER_ERROR,
            kSetLocalDescError: zego_error_1.errorCodeList.PUBLISHER_SET_LOCAL_DESC_ERROR,
            kSessionTimeoutError: zego_error_1.errorCodeList.PUBLISHER_SESSION_TIMEOUT,
            kSessionRequestError: zego_error_1.errorCodeList.PUBLISHER_SESSION_REQUEST_FAIL,
            kSetRemoteDescError: zego_error_1.errorCodeList.PUBLISHER_SET_REMOTE_DESC_ERROR,
            kMediaConnectionError: zego_error_1.errorCodeList.PUBLISHER_MEDIA_CONNECTION_ERROR,
            kWebsocketDisconnectedError: zego_error_1.errorCodeList.PUBLISHER_WEBSOCKET_DISCONNECTED,
            kMediaDescError: zego_error_1.errorCodeList.PUBLISHER_MEDIA_DESC_ERROR,
            kCandidateError: zego_error_1.errorCodeList.PUBLISHER_CANDIDATE_ERROR,
            kIsPublishing: zego_error_1.errorCodeList.PUBLISHER_IS_PUBLISHING,
            kClientIPChangedError: zego_error_1.errorCodeList.PUBLISHER_CLIENT_IP_CHANGED,
            kTTLOverTimeError: zego_error_1.errorCodeList.PUBLISHER_TTL_OVERTIME,
            kUpdateMediaDescriptionTimeOut: zego_error_1.errorCodeList.PUBLISHER_UPDATE_SDP_TIMEOUT,
            kUpdateMediaDescriptionError: zego_error_1.errorCodeList.PUBLISHER_UPDATE_SDP_FAIL
        },
        publishOption: getItem,
        message: getItem,
        session_id: getItem,
        stream: getItem,
        video_en_codec_id: getItem,
        cap_w: getItem,
        cap_h: getItem,
        w: getItem,
        h: getItem,
        video_en_fps: getItem,
        video_en_bps: getItem,
        audio_c_channel_count: getItem,
        audio_en_bps: getItem,
        aec_level: getItem,
        ans_level: getItem,
        agc: getItem,
        traffic_control_min_video_bitrate: getItem
    },
    kZegoTaskVideoCaptureSize: {
        event: "/sdk/api/publish_video_c_size",
        session_id: getItem,
        w: getItem,
        h: getItem
    },
    kZegoTaskVideoPlaySize: {
        event: "/sdk/play_video_size_changed",
        session_id: getItem,
        w: getItem,
        h: getItem
    },
    kZegoTaskRePublish: {
        event: "/sdk/republish",
        stream: getItem
    },
    kZegoTaskPublishStop: {
        event: "/sdk/stop_publish",
        error: {
            kParamError: zego_error_1.errorCodeList.PUBLISHER_PARAM
        },
        stream: getItem
    },
    // kZegoTaskRtcPublishStateUpdate: '/rtc/publish_stat_report', ///< 
    // kZegoTaskCdnPublishStateUpdate: '/cdn/publish_stat_report', ///< 
    kZegoTaskPlayStart: {
        event: "/sdk/api/play_request",
        error: {
            kStreamIDNullError: zego_error_1.errorCodeList.STREAM_ID_NULL,
            kPlayParamError: zego_error_1.errorCodeList.PLAYER_PARAM,
            kPlayStreamIDToLongError: zego_error_1.errorCodeList.STREAMID_TOO_LONG,
            kPlayStreamIDInvalidCharacterError: zego_error_1.errorCodeList.STREAM_ID_INVALID_CHARACTER,
            kPlayNoLoginError: zego_error_1.errorCodeList.NOT_LOGIN,
            kPlayRepeatedPullError: zego_error_1.errorCodeList.REPEATED_PULL,
            kPlayNetworkTimeoutError: zego_error_1.errorCodeList.TIMEOUT,
            kPlayDispatchTimeoutError: zego_error_1.errorCodeList.DISPATCH_TIMEOUT,
            kPlayDispatchError: zego_error_1.errorCodeList.DISPATCH_ERROR,
            kPlayNetworkBrokenError: zego_error_1.errorCodeList.NETWORK_BROKEN,
            kPlayUnsupportedResourceMode: zego_error_1.errorCodeList.PLAYER_UNSUPPORTED_PROTOCOL,
            kPlayRetryTimeoutError: zego_error_1.errorCodeList.PLAYER_RETRY_TIMEOUT,
            kPlaySessionClosedError: zego_error_1.errorCodeList.PLAYER_SESSION_CLOSED,
            kPlaySessionResetError: zego_error_1.errorCodeList.PLAYER_SESSION_RESET,
            kPlayNegoTimeoutError: zego_error_1.errorCodeList.PLAYER_SERVER_NEGO_TIMEOUT,
            kCreateOfferError: zego_error_1.errorCodeList.PLAYER_CREATE_OFFER_ERROR,
            kSetLocalDescError: zego_error_1.errorCodeList.PLAYER_SET_LOCAL_DESC_ERROR,
            kSessionRequestError: zego_error_1.errorCodeList.PLAYER_SESSION_REQUEST_FAIL,
            kSessionTimeoutError: zego_error_1.errorCodeList.PLAYER_SESSION_TIMEOUT,
            kSetRemoteDescError: zego_error_1.errorCodeList.PLAYER_SET_REMOTE_DESC_ERROR,
            kMediaConnectionError: zego_error_1.errorCodeList.PLAYER_MEDIA_CONNECTION_ERROR,
            kWebsocketDisconnectedError: zego_error_1.errorCodeList.PLAYER_WEBSOCKET_DISCONNECTED,
            kCandidateError: zego_error_1.errorCodeList.PLAYER_CANDIDATE_ERROR,
            kMediaDescError: zego_error_1.errorCodeList.PLAYER_MEDIA_DESC_ERROR,
            kIsPlaying: zego_error_1.errorCodeList.PLAYER_IS_PLAYING,
            kClientIPChangedError: zego_error_1.errorCodeList.PLAYER_CLIENT_IP_CHANGED,
            kTTLOverTimeError: zego_error_1.errorCodeList.PLAYER_TTL_OVERTIME,
            kProbeTimeOutError: zego_error_1.errorCodeList.PLAYER_PROBE_TIMEOUT
        },
        playOption: getItem,
        message: getItem,
        session_id: getItem,
        stream: getItem,
        audio_activate: getItem,
        video_activate: getItem
    },
    kZegoTaskRePlay: {
        event: "/sdk/replay",
        stream: getItem
    },
    kZegoTaskPlayStop: {
        event: "/sdk/stop_play",
        error: {
            kParamError: zego_error_1.errorCodeList.PUBLISHER_PARAM
        },
        stream: getItem
    },
    // kZegoTaskDispatch: '/rtc/dispatch', ///< Dispatch
    kZegoTaskEnumDevices: {
        event: "/device/list",
        error: {
            kBrowserNotSupportError: zego_error_1.errorCodeList.PUBLISHER_BROWSER_NOT_SUPPORT,
            kEnumDevicesError: zego_error_1.errorCodeList.ENUMERATE_DEVICES_FAIL
        },
        dev_list: getItem
    },
    kZegoTaskAudioOutput: {
        event: "/device/audio_capture",
        error: {
            kBrowserNotSupportError: zego_error_1.errorCodeList.PUBLISHER_BROWSER_NOT_SUPPORT,
            kEnumDevicesError: zego_error_1.errorCodeList.ENUMERATE_DEVICES_FAIL
        },
        session_id: getItem,
        device: getItem
    },
    kZegoTaskVideoCapture: {
        event: "/device/video_capture",
        error: {
            kBrowserNotSupportError: zego_error_1.errorCodeList.PUBLISHER_BROWSER_NOT_SUPPORT,
            kEnumDevicesError: zego_error_1.errorCodeList.ENUMERATE_DEVICES_FAIL
        },
        session_id: getItem,
        device: getItem
    },
    kZegoTaskDeviceInterrupt: {
        event: "/device/interrupt",
        error: {
            kBrowserNotSupportError: zego_error_1.errorCodeList.PUBLISHER_BROWSER_NOT_SUPPORT,
            kEnumDevicesError: zego_error_1.errorCodeList.ENUMERATE_DEVICES_FAIL
        },
        session_id: getItem,
        interrupt: getItem
    },
    kZegoTaskSetDebug: "/sdk/set_debug",
    kZegoTaskSetLog: "/sdk/set_log_config",
    kZegoTaskCheckSystemRequirements: {
        event: "/sdk/check_system",
        capability: getItem
    },
    kZegoTaskRemoteCameraUpdate: {
        event: "/sdk/remote_camera_update",
        stream: getItem,
        status: getItem
    },
    kZegoTaskRemoteMicUpdate: {
        event: "/sdk/remote_mic_update",
        stream: getItem,
        status: getItem
    },
    kZegoTaskDestroyStream: {
        event: "/sdk/destroy_stream",
        error: {
            kLocalStreamError: zego_error_1.errorCodeList.LOCALSTREAM_WRONG
        }
    },
    kZegoTaskScreenSharingEnded: "/sdk/screen_share_end",
    kZegoTaskAudioOutputChanged: {
        event: "/device/api/audio_output",
        session_id: getItem,
        stream: getItem,
        device: getItem,
        reason: getItem
    },
    kZegoEventPublishStat: "/sdk/publish_stat_report",
    kZegoEventPlayStat: "/sdk/play_stat_report",
    kZegoTaskLiveRoomGetStreamUpdateInfo: {
        event: "/liveroom/get_stream_update_info",
        stream_update_type: getItem,
        update_stream: getItem
    },
    kZegoTaskLiveRoomGetStreamExtraInfo: {
        event: "/liveroom/get_stream_extra_info",
        update_stream: getItem
    },
    kZegoTaskPlayDecodeFirstVideoFrame: {
        event: "/sdk/play_decode_first_video_frame",
        session_id: getItem,
        fft_consumed: getItem
    },
    kZegoVisibilityChange: {
        event: "/app/background"
    },
    kZegoSetCaptureVolume: {
        event: "/sdk/set_capture_volume",
        error: {
            kParamError: zego_error_1.errorCodeList.INPUT_PARAM
        }
    },
    kZegoListener: {
        event: "/sdk/listener"
    },
    kZegoNetProbe: {
        event: "/sdk/net_probe"
    },
    kZegoNetProbeResult: {
        event: "/sdk/net_probe_result"
    },
    kZegoTaskCloudSettingCache: {
        event: "/cloud_setting/cache"
    },
    kZegoTaskCloudSettingRefresh: {
        event: "/cloud_setting/refresh"
    }
};
exports.ZegoWechatLogEvent = {
    kZegoTaskCheckSystemRequirements: {
        event: "/sdk/check_system",
        error: {
            kCheckSystemGetSettingFailError: zego_error_1.errorCodeList.WX_GET_SETTING_FAIL
        },
        capability: getItem
    },
    kZegoTaskPublishStart: {
        event: "/sdk/api/publish_request",
        error: {
            kPublishStreamIDNullError: zego_error_1.errorCodeList.STREAM_ID_NULL,
            kPublishParamError: zego_error_1.errorCodeList.PUBLISHER_PARAM,
            kPublishStreamIDTooLongError: zego_error_1.errorCodeList.STREAMID_TOO_LONG,
            kPublishStreamIDInvalidCharacterError: zego_error_1.errorCodeList.STREAM_ID_INVALID_CHARACTER,
            kPublishNetworkTimeoutError: zego_error_1.errorCodeList.TIMEOUT,
            kPublishDispatchTimeoutError: zego_error_1.errorCodeList.DISPATCH_TIMEOUT,
            kPublishDispatchError: zego_error_1.errorCodeList.DISPATCH_ERROR,
            kPublishNetworkBrokenError: zego_error_1.errorCodeList.NETWORK_BROKEN,
            kPublishNoLoginError: zego_error_1.errorCodeList.NOT_LOGIN,
            kPublishRetryTimeoutError: zego_error_1.errorCodeList.PUBLISHER_RETRY_TIMEOUT,
            kIsPublishing: zego_error_1.errorCodeList.PUBLISHER_IS_PUBLISHING
        },
        publishOption: getItem,
        stream: getItem,
        message: getItem
    },
    kZegoTaskPlayStart: {
        event: "/sdk/api/play_request",
        error: {
            kPlayStreamIDNullError: zego_error_1.errorCodeList.STREAM_ID_NULL,
            kPlayParamError: zego_error_1.errorCodeList.PLAYER_PARAM,
            kPlayStreamIDTooLongError: zego_error_1.errorCodeList.STREAMID_TOO_LONG,
            kPlayStreamIDInvalidCharacterError: zego_error_1.errorCodeList.STREAM_ID_INVALID_CHARACTER,
            kPlayNoLoginError: zego_error_1.errorCodeList.NOT_LOGIN,
            kPlayRepeatedPullError: zego_error_1.errorCodeList.REPEATED_PULL,
            kPlayNetworkTimeoutError: zego_error_1.errorCodeList.TIMEOUT,
            kPlayDispatchTimeoutError: zego_error_1.errorCodeList.DISPATCH_TIMEOUT,
            kPlayDispatchError: zego_error_1.errorCodeList.DISPATCH_ERROR,
            kPlayNetworkBrokenError: zego_error_1.errorCodeList.NETWORK_BROKEN,
            kPlayRetryTimeoutError: zego_error_1.errorCodeList.PLAYER_RETRY_TIMEOUT,
            kIsPlaying: zego_error_1.errorCodeList.PLAYER_IS_PLAYING
        },
        playOption: getItem,
        message: getItem,
        session_id: getItem,
        stream: getItem,
        audio_activate: getItem,
        video_activate: getItem
    },
    kZegoEventPublishStat: "/sdk/publish_stat_report",
    kZegoEventPlayStat: "/sdk/play_stat_report",
    kZegoTaskRePublish: "/sdk/republish",
    kZegoTaskRePlay: "/sdk/replay",
    kZegoTaskPublishStop: {
        event: "/sdk/stop_publish",
        error: {
            kParamError: zego_error_1.errorCodeList.PUBLISHER_PARAM
        },
        stream: getItem
    },
    kZegoTaskPlayStop: {
        event: "/sdk/stop_play",
        error: {
            kParamError: zego_error_1.errorCodeList.PUBLISHER_PARAM
        },
        stream: getItem
    },
    kZegoTaskLiveRoomGetStreamUpdateInfo: {
        event: "/liveroom/get_stream_update_info",
        stream_update_type: getItem,
        update_stream: getItem
    },
    kZegoTaskLiveRoomGetStreamExtraInfo: {
        event: "/liveroom/get_stream_extra_info",
        update_stream: getItem
    }
};
// fs.writeFile(
//   path.resolve(__dirname, "../../../doc/logevent.json"),
//   JSON.stringify(ZegoRTCLogEvent),
//   "utf8",
//   err => {
//     console.log(err);
//   }
// );


/***/ }),

/***/ "./sdk/src/modules/advance/action.ts":
/*!*******************************************!*\
  !*** ./sdk/src/modules/advance/action.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZEGO_WEBRTC_ACTION = void 0;
var ZEGO_WEBRTC_ACTION;
(function (ZEGO_WEBRTC_ACTION) {
    ZEGO_WEBRTC_ACTION["SET_VIDEO_CONFIG"] = "zc.svc";
    ZEGO_WEBRTC_ACTION["SET_AUDIO_CONFIG"] = "zc.sac";
    ZEGO_WEBRTC_ACTION["REPLACE_TRACK"] = "zc.rp";
    ZEGO_WEBRTC_ACTION["SET_BEAUTY_EFFECT"] = "zc.sbe";
    ZEGO_WEBRTC_ACTION["ENABLE_STREAM"] = "zc.es";
    ZEGO_WEBRTC_ACTION["ENABLE_MIC_ONLY"] = "zc.emo";
    ZEGO_WEBRTC_ACTION["ACTIVATE_SEI_INSERT"] = "zc.asi";
    ZEGO_WEBRTC_ACTION["MUTE_PUBLISH_STREAM_VIDEO"] = "zc.mpsv.0";
    ZEGO_WEBRTC_ACTION["MUTE_PUBLISH_STREAM_AUDIO"] = "zc.mpsa.0";
    ZEGO_WEBRTC_ACTION["MUTE_MIC"] = "zc.mm";
    ZEGO_WEBRTC_ACTION["MUTE_PLAY_STREAM_VIDEO"] = "zc.mpsv.1";
    ZEGO_WEBRTC_ACTION["MUTE_PLAY_STREAM_AUDIO"] = "zc.mpsa.1";
    ZEGO_WEBRTC_ACTION["ADD_TRACK"] = "zc.at";
    ZEGO_WEBRTC_ACTION["REMOVE_TRACK"] = "zc.rt";
    ZEGO_WEBRTC_ACTION["HANDLE_TRACK"] = "zc.ht"; //
})(ZEGO_WEBRTC_ACTION = exports.ZEGO_WEBRTC_ACTION || (exports.ZEGO_WEBRTC_ACTION = {}));


/***/ }),

/***/ "./sdk/src/modules/advance/advancedModule.ts":
/*!***************************************************!*\
  !*** ./sdk/src/modules/advance/advancedModule.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdvancedModule = void 0;
var action_1 = __webpack_require__(/*! ./action */ "./sdk/src/modules/advance/action.ts");
var error_1 = __webpack_require__(/*! ./error */ "./sdk/src/modules/advance/error.ts");
var log_event_1 = __webpack_require__(/*! ./log.event */ "./sdk/src/modules/advance/log.event.ts");
var AdvancedModule = /** @class */ (function () {
    function AdvancedModule(logger, dataReport, streamCenter, stateCenter) {
        this.logger = logger;
        this.dataReport = dataReport;
        this.streamCenter = streamCenter;
        this.stateCenter = stateCenter;
        this.screenShotReady = false;
    }
    //
    AdvancedModule.prototype.setVideoConfig = function (localStream, constraints) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SET_VIDEO_CONFIG + " call");
        return new Promise(function (resolve, reject) {
            var reportSeq = _this.stateCenter.getReportSeq();
            _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.event);
            if (!(localStream instanceof MediaStream)) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_VIDEO_CONFIG + " localStream not found");
                _this.dataReport.addMsgInfo(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kLocalStreamError);
                _this.dataReport.uploadReport(reportSeq);
                reject({
                    errorCode: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.code,
                    extendedData: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.message +
                        " localStream no found"
                });
                return;
            }
            if (!constraints ||
                typeof constraints !== "object" ||
                Object.keys(constraints).length == 0) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_VIDEO_CONFIG + " constraints wrong");
                _this.dataReport.addMsgInfo(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError);
                _this.dataReport.uploadReport(reportSeq);
                reject({
                    errorCode: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.code,
                    extendedData: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.message +
                        " constraints wrong"
                });
                return;
            }
            if (constraints.width &&
                !_this.stateCenter.checkValidNumber(constraints.width)) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_VIDEO_CONFIG +
                    " constraints width integer number, range[1, 10000]");
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.code,
                    message: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.message +
                        " constraints width integer number, range[1, 10000]"
                });
                _this.dataReport.uploadReport(reportSeq);
                reject({
                    errorCode: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.code,
                    extendedData: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.message +
                        " constraints wrong"
                });
                return;
            }
            if (constraints.height &&
                !_this.stateCenter.checkValidNumber(constraints.height)) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_VIDEO_CONFIG +
                    " constraints height integer number, range[1, 10000]");
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.code,
                    message: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.message +
                        " constraints height integer number, range[1, 10000]"
                });
                _this.dataReport.uploadReport(reportSeq);
                reject({
                    errorCode: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.code,
                    extendedData: log_event_1.ZegoRTCLogEvent.kZegoSetVideoConfig.error.kParamError.message +
                        " constraints wrong"
                });
                return;
            }
            var interResolve = function (result) {
                _this.dataReport.uploadReport(reportSeq);
                resolve(result);
            };
            _this.setPublishStreamConstraints(localStream, constraints, interResolve);
        });
    };
    AdvancedModule.prototype.setAudioConfig = function (localStream, constraints) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SET_AUDIO_CONFIG + " call");
        return new Promise(function (resolve) {
            var reportSeq = _this.stateCenter.getReportSeq();
            _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoSetAudioConfig.event);
            if (!(localStream instanceof MediaStream)) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_AUDIO_CONFIG + " localStream not found");
                _this.dataReport.addMsgInfo(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoSetAudioConfig.error.kParamError);
                _this.dataReport.uploadReport(reportSeq);
                resolve({
                    errorCode: log_event_1.ZegoRTCLogEvent.kZegoSetAudioConfig.error.kParamError.code,
                    extendedData: log_event_1.ZegoRTCLogEvent.kZegoSetAudioConfig.error.kParamError.message +
                        " localStream no found"
                });
                return;
            }
            if (!constraints ||
                typeof constraints !== "object" ||
                Object.keys(constraints).length == 0 ||
                (constraints.AEC !== undefined &&
                    typeof constraints.AEC !== "boolean") ||
                (constraints.AGC !== undefined &&
                    typeof constraints.AGC !== "boolean") ||
                (constraints.ANS !== undefined && typeof constraints.ANS !== "boolean")) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_AUDIO_CONFIG + " constraints wrong");
                _this.dataReport.addMsgInfo(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoSetAudioConfig.error.kParamError);
                _this.dataReport.uploadReport(reportSeq);
                resolve({
                    errorCode: log_event_1.ZegoRTCLogEvent.kZegoSetAudioConfig.error.kParamError.code,
                    extendedData: log_event_1.ZegoRTCLogEvent.kZegoSetAudioConfig.error.kParamError.message +
                        " constraints wrong"
                });
                return;
            }
            var interResolve = function (result) {
                _this.dataReport.uploadReport(reportSeq);
                resolve(result);
            };
            _this.setPublishStreamConstraints(localStream, constraints, interResolve);
        });
    };
    AdvancedModule.prototype.enableStream = function (localStream, option) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.ENABLE_STREAM + " call");
        if (typeof option.video !== "boolean" &&
            typeof option.audio !== "boolean") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.ENABLE_STREAM + " option error");
            return false;
        }
        var video = true, audio = true;
        if (typeof option.video == "boolean") {
            video = this.enableCamera(localStream, option.video, option.retain);
        }
        if (typeof option.audio == "boolean") {
            audio = this.enableMicrophone(localStream, option.audio);
        }
        return video && audio;
    };
    AdvancedModule.prototype.enableMicrophoneOnly = function (enable) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.ENABLE_MIC_ONLY + " call");
        if (typeof enable !== "boolean") {
            // this.logger.error(ZEGO_WEBRTC_ACTION.ENABLE_STREAM + " option error");
            return false;
        }
        var changedCount = 0;
        for (var index = 0; index < this.streamCenter.previewStreamList.length; index++) {
            var preview = this.streamCenter.previewStreamList[index];
            var result = preview.enableMicrophoneOnly(enable, this.streamCenter);
            if (result) {
                changedCount++;
            }
            else {
                this.logger.error("zsc.emo.0 previewer " + index + " change mic mute state failed");
                return false;
            }
        }
        this.streamCenter.isMicEnabled = enable;
        return true;
    };
    AdvancedModule.prototype.replaceTrack = function (localStream, mediaStreamTrack) {
        return __awaiter(this, void 0, void 0, function () {
            var seq, result;
            return __generator(this, function (_a) {
                seq = this.stateCenter.getReportSeq();
                this.dataReport.newReport(seq, log_event_1.ZegoRTCLogEvent.kZegoReplaceTrack.event);
                if (!(localStream instanceof MediaStream)) {
                    this.logger.error(action_1.ZEGO_WEBRTC_ACTION.REPLACE_TRACK + " localStream not found");
                    this.dataReport.uploadReport(seq, undefined, log_event_1.ZegoRTCLogEvent.kZegoReplaceTrack.error.kParamError);
                    return [2 /*return*/, {
                            errorCode: log_event_1.ZegoRTCLogEvent.kZegoReplaceTrack.error.kParamError.code,
                            extendedData: log_event_1.ZegoRTCLogEvent.kZegoReplaceTrack.error.kParamError.message +
                                " localStream no found"
                        }];
                }
                if (!mediaStreamTrack || !(mediaStreamTrack instanceof MediaStreamTrack)) {
                    this.logger.error(action_1.ZEGO_WEBRTC_ACTION.REPLACE_TRACK + " mediastream track no found");
                    this.dataReport.uploadReport(seq, undefined, log_event_1.ZegoRTCLogEvent.kZegoReplaceTrack.error.kParamError);
                    return [2 /*return*/, {
                            errorCode: log_event_1.ZegoRTCLogEvent.kZegoReplaceTrack.error.kParamError.code,
                            extendedData: log_event_1.ZegoRTCLogEvent.kZegoReplaceTrack.error.kParamError.message +
                                " mediastream track no found"
                        }];
                }
                result = this._replaceTrack(localStream, mediaStreamTrack);
                this.dataReport.uploadReport(seq);
                return [2 /*return*/, result];
            });
        });
    };
    AdvancedModule.prototype.setPublishStreamConstraints = function (stream, constraints, success) {
        var _this = this;
        var publisher = null;
        this.logger.info("zsc.spsc.0 constraints", JSON.stringify(constraints));
        for (var i in this.streamCenter.publisherList) {
            this.streamCenter.publisherList[i].localStream == stream &&
                (publisher = this.streamCenter.publisherList[i]);
        }
        if (!publisher) {
            this.logger.error("zsc.spsc.0 publisher not found");
            success &&
                success({
                    errorCode: error_1.errorCodeList.PUBLISH_NOT_PUBLISH.code,
                    extendedData: error_1.errorCodeList.PUBLISH_NOT_PUBLISH.message
                });
            return;
        }
        this.logger.info("zsc.spsc.0 streamId ", publisher.streamID);
        var preview = publisher === null || publisher === void 0 ? void 0 : publisher.publisher.previewer;
        if (!preview) {
            this.logger.error("zsc.spsc.0 preview no found");
            success &&
                success({
                    errorCode: error_1.errorCodeList.PUBLISH_NO_PREVIEW.code,
                    extendedData: error_1.errorCodeList.PUBLISH_NO_PREVIEW.message
                });
            return;
        }
        // if ((constraints.width && constraints.width < 100) || (constraints.height && constraints.height < 100)) {
        //     this.logger.error('zsc.spsc.0 constraints wrong');
        //     error && error(errorCodeList.INPUT_PARAM);
        //     return;
        // }
        var applyVideo = false;
        var applyAudio = false;
        if (constraints.width || constraints.height || constraints.frameRate) {
            preview.mediaStreamConfig.videoQuality = 4;
            applyVideo = true;
        }
        if (constraints.ANS !== undefined ||
            constraints.AGC !== undefined ||
            constraints.AEC !== undefined) {
            applyAudio = true;
        }
        var localStream = preview.localStream;
        var videoTrack = preview.videoTrack;
        var audioTrack = preview.audioTrack;
        if (applyVideo && !videoTrack) {
            this.logger.error("zsc.spsc.0 video track not found");
            success &&
                success({
                    errorCode: error_1.errorCodeList.TRACK_NOT_FOUND.code,
                    extendedData: error_1.errorCodeList.TRACK_NOT_FOUND.message
                });
        }
        else {
            constraints.video = true;
        }
        if (applyAudio && !audioTrack) {
            this.logger.error("zsc.spsc.0 audio track not found");
            success &&
                success({
                    errorCode: error_1.errorCodeList.TRACK_NOT_FOUND.code,
                    extendedData: error_1.errorCodeList.TRACK_NOT_FOUND.message
                });
        }
        else {
            constraints.audio = true;
        }
        var oldMediaStreamConfig = JSON.parse(JSON.stringify(preview.mediaStreamConfig));
        var mediaStreamConfig = Object.assign(preview.mediaStreamConfig, constraints);
        var mediaStreamConstraints = preview.getMediaStreamConstraints(mediaStreamConfig, true);
        this.logger.info("zsc.spsc.0 applyConstraints ", JSON.stringify(mediaStreamConstraints));
        var promiseList = [];
        if (applyVideo) {
            promiseList.push(videoTrack.applyConstraints(mediaStreamConstraints.video));
        }
        if (applyAudio) {
            audioTrack.stop();
            promiseList.push(navigator.mediaDevices.getUserMedia({
                video: false,
                audio: mediaStreamConstraints.audio
            }));
        }
        if (constraints.maxBitrate) {
            var sender = publisher.publisher.peerConnection
                .getSenders()
                .find(function (s) { return s.track && s.track.kind === "video"; });
            var parameters = sender.getParameters();
            if (sender) {
                if (!parameters.encodings) {
                    parameters.encodings = [{}];
                }
                // parameters.encodings[0].minBitrate = minBitRate * 1e3;
                parameters.encodings[0].maxBitrate = constraints.maxBitrate * 1e3;
                promiseList.push(sender.setParameters(parameters));
            }
            else {
                this.logger.error("zsc.spsc.0 video sender no found");
            }
        }
        if (promiseList.length > 0) {
            Promise.all(promiseList)
                .then(function (values) {
                _this.logger.info("zsc.spsc.0 set constraints success", values[1]);
                var stream;
                if (applyAudio) {
                    if (applyVideo) {
                        stream = values[1];
                    }
                    else {
                        stream = values[0];
                    }
                    var audioTrack_1 = stream.getAudioTracks()[0];
                    audioTrack_1.enabled = publisher.publisher.mic_status === 0;
                    var sender = publisher.publisher.peerConnection
                        .getSenders()
                        .find(function (s) { return s.track.kind === "audio"; });
                    if (sender) {
                        sender.replaceTrack(audioTrack_1);
                        if (localStream) {
                            var preview_1 = _this.streamCenter.checkPreview(localStream);
                            if (preview_1) {
                                preview_1.replacePreviewTrack(audioTrack_1);
                                preview_1.gainNode = null;
                            }
                        }
                    }
                }
                //
                if (constraints.maxBitrate) {
                    publisher.publisher &&
                        (publisher.publisher.videoInfo.bitRate = constraints.maxBitrate);
                }
                success && success({ errorCode: 0, extendedData: "" });
            })
                .catch(function (err) {
                _this.logger.error("zsc.spsc.0 fail reason ", err.name, JSON.stringify(err));
                success &&
                    success({
                        errorCode: error_1.errorCodeList.PUBLISHER_CONSTRAINTS_ERROR.code,
                        extendedData: err.name + " " + (err.constraint ? "constraint:" + err.constraint : "")
                    });
            });
        }
        else {
            this.logger.warn("zsc.spsc.0 constaints is no changes");
            if (applyAudio) {
                var oldMediaStreamConstraints = preview.getMediaStreamConstraints(oldMediaStreamConfig);
                this.logger.info("zsc.spsc.0 oldMediaStreamConstraints ", JSON.stringify(oldMediaStreamConstraints));
                navigator.mediaDevices
                    .getUserMedia({
                    video: false,
                    audio: oldMediaStreamConstraints.audio
                })
                    .then(function (_stream) {
                    var backAudioTrack = _stream.getAudioTracks()[0];
                    var localAudioTrack = preview.audioTrack || audioTrack;
                    var sender = publisher.publisher.peerConnection
                        .getSenders()
                        .find(function (s) {
                        return s.track !== null && s.track.kind === audioTrack.kind;
                    });
                    if (sender) {
                        sender.replaceTrack(backAudioTrack);
                        var previewer = _this.streamCenter.checkPreview(localStream);
                        previewer && previewer.replacePreviewTrack(backAudioTrack);
                    }
                    _this.logger.info("zsc.spsc.0.1 setbackup suc ");
                })
                    .catch(function (_err) {
                    _this.logger.error("zsc.spsc.0.1 setbackup fail " + _err.name);
                });
            }
            success &&
                success({
                    errorCode: error_1.errorCodeList.PUBLISHER_CONSTRAINTS_ERROR.code,
                    extendedData: "constraints is no changes"
                });
        }
    };
    AdvancedModule.prototype.useVideoDevice = function (localStream, deviceID) {
        var _this = this;
        this.logger.info("zc.uvd.0 call");
        return new Promise(function (resolve) {
            var reportSeq = _this.stateCenter.getReportSeq();
            _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.event);
            _this.dataReport.addMsgInfo(reportSeq, {
                device: log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.device(deviceID)
            });
            if (!(localStream instanceof MediaStream)) {
                _this.logger.error("zc.uvd.0 localStream not found");
                _this.dataReport.addMsgInfo(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.error.kLocalStreamError);
                _this.dataReport.uploadReport(reportSeq);
                resolve({
                    errorCode: log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.error.kParamError.code,
                    extendedData: log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.error.kParamError.message
                });
                return;
            }
            if (typeof deviceID !== "string") {
                _this.logger.error("zc.uvd.0 deviceID must be string");
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.error.kParamError.code,
                    message: log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.error.kParamError.message +
                        " deviceID must be string"
                });
                _this.dataReport.uploadReport(reportSeq);
                resolve({
                    errorCode: log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.error.kParamError.code,
                    extendedData: log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.error.kParamError.message
                });
                return;
            }
            var interResolve = function (res) {
                var _a, _b;
                _this.dataReport.uploadReport(reportSeq);
                var publisher = _this.streamCenter.checkPublish(localStream);
                if (publisher) {
                    publisher.cameraLabel =
                        ((_b = (_a = publisher.publisher.previewer) === null || _a === void 0 ? void 0 : _a.videoTrack) === null || _b === void 0 ? void 0 : _b.label) ||
                            publisher.cameraLabel;
                }
                resolve(res);
            };
            _this.stateCenter.getDevices(function (devicesInfos) {
                var cameras = devicesInfos.cameras;
                if (!cameras.find(function (camera) { return camera.deviceID == deviceID; })) {
                    _this.logger.error("zc.uvd.0 device is not found");
                    resolve({
                        errorCode: log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.error
                            .kDevicesNoFoundError.code,
                        extendedData: log_event_1.ZegoRTCLogEvent.kZegoTaskUseVideoDevice.error
                            .kDevicesNoFoundError.message
                    });
                    return;
                }
                _this.switchDevice("video", localStream, deviceID, interResolve);
            }, function (err) {
                _this.logger.warn("zc.uvd.0 getDevices err:", err);
                _this.switchDevice("video", localStream, deviceID, interResolve);
            });
        });
        // return this.setPublishStreamConstraints(localStream, {
        //     videoInput: deviceID,
        // });
    };
    AdvancedModule.prototype.useAudioDevice = function (localStream, deviceID) {
        var _this = this;
        this.logger.info("zc.uad.1 call");
        return new Promise(function (resolve) {
            var reportSeq = _this.stateCenter.getReportSeq();
            _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskUseAudioDevice.event);
            _this.dataReport.addMsgInfo(reportSeq, {
                device: log_event_1.ZegoRTCLogEvent.kZegoTaskUseAudioDevice.device(deviceID)
            });
            var interReject = function (error, msg) {
                _this.logger.error("zc.uad.1 " + msg);
                var err = error;
                err.message = err.message + (msg ? " " + msg : "");
                _this.dataReport.addMsgInfo(reportSeq, err);
                _this.dataReport.uploadReport(reportSeq);
                resolve({
                    errorCode: err.code,
                    extendedData: err.message
                });
            };
            var interResolve = function (result) {
                var _a;
                _this.dataReport.uploadReport(reportSeq);
                var publisher = _this.streamCenter.checkPublish(localStream);
                if (publisher) {
                    publisher.microLabel =
                        ((_a = localStream.getAudioTracks()[0]) === null || _a === void 0 ? void 0 : _a.label) || publisher.microLabel;
                }
                resolve(result);
            };
            if (!(localStream instanceof MediaStream)) {
                interReject(log_event_1.ZegoRTCLogEvent.kZegoTaskUseAudioDevice.error.kLocalStreamError, "localStream not found");
                return;
            }
            if (typeof deviceID !== "string") {
                interReject(log_event_1.ZegoRTCLogEvent.kZegoTaskUseAudioDevice.error.kParamError, "deviceID must be string");
                return;
            }
            _this.stateCenter.getDevices(function (devicesInfos) {
                var microphones = devicesInfos.microphones;
                if (!microphones.find(function (microphone) { return microphone.deviceID == deviceID; })) {
                    _this.logger.error("zc.uad.1 device is not found");
                    resolve({
                        errorCode: log_event_1.ZegoRTCLogEvent.kZegoTaskUseAudioDevice.error
                            .kDevicesNoFoundError.code,
                        extendedData: log_event_1.ZegoRTCLogEvent.kZegoTaskUseAudioDevice.error
                            .kDevicesNoFoundError.message
                    });
                    return;
                }
                _this.switchDevice("audio", localStream, deviceID, interResolve);
            }, function (err) {
                _this.logger.warn("zc.uad.1 getDevices err:", err);
                _this.switchDevice("audio", localStream, deviceID, interResolve);
            });
        });
        // return this.setPublishStreamConstraints(localStream, {
        //     audioInput: deviceID,
        // });
    };
    AdvancedModule.prototype.publishTarget = function (cdnPushConfig) {
        var _this = this;
        var reportSeq = this.stateCenter.getReportSeq();
        switch (cdnPushConfig.type) {
            case "addpush":
                this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskAddPublishCdnUrl.event);
                break;
            case "delpush":
                this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskRemovePublishCdnUrl.event);
                break;
            case "clearpush":
                this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskRemovePublishCdnUrl.event);
                break;
        }
        this.dataReport.addMsgInfo(reportSeq, {
            stream: log_event_1.ZegoRTCLogEvent.kZegoTaskRemovePublishCdnUrl.stream(cdnPushConfig.streamID),
            target_url: log_event_1.ZegoRTCLogEvent.kZegoTaskRemovePublishCdnUrl.target_url(cdnPushConfig.pushUrl)
        });
        return new Promise(function (resolve, reject) {
            var innerReject = function (err, externMsg) {
                _this.logger.error("zb.pt" + (externMsg || err.message));
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: err.code,
                    message: err.message + (externMsg || "")
                });
                _this.dataReport.uploadReport(reportSeq);
                reject({
                    errorCode: err.code,
                    extendedData: err.message + (externMsg ? " " + externMsg : "")
                });
            };
            if (["addpush", "delpush", "clearpush"].indexOf(cdnPushConfig.type) == -1) {
                _this.logger.error("zb.sh.pt cdn push type error");
                innerReject(error_1.errorCodeList.PUBLISHER_CDN_PUSH_ERROR, "type error");
                return;
            }
            if (!cdnPushConfig.streamID ||
                typeof cdnPushConfig.streamID !== "string") {
                innerReject(log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kParamError, "stream id type error");
                return;
            }
            if (!cdnPushConfig.pushUrl || typeof cdnPushConfig.pushUrl !== "string") {
                innerReject(log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kParamError, "push url error");
                return;
            }
            if (!_this.stateCenter.publishStreamList[cdnPushConfig.streamID]) {
                innerReject(log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error
                    .kPublishStreamNoFoundError);
                return;
            }
            var room = _this.streamCenter.getRoomByStreamID(cdnPushConfig.streamID);
            if (!room) {
                innerReject(log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kNoLoginError);
                return;
            }
            var innerResolve = function (res) {
                _this.dataReport.uploadReport(reportSeq);
                resolve(res);
            };
            room.streamHandler._publishTarget(cdnPushConfig, innerResolve, innerReject);
        });
    };
    AdvancedModule.prototype.handleTrack = function (type, stream, track, success, error) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var preview, publish, publisher_1, previewer_1, pc, sender_1, transceiver, videoInfo, trackPreview, desc;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(stream instanceof MediaStream)) {
                            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK + " stream wrong");
                            error({
                                errorCode: error_1.errorCodeList.INPUT_PARAM.code,
                                extendedData: error_1.errorCodeList.INPUT_PARAM.message
                            });
                            return [2 /*return*/];
                        }
                        if (!(track instanceof MediaStreamTrack) || track.kind == "audio") {
                            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK + " only can handle video track");
                            error({
                                errorCode: error_1.errorCodeList.INPUT_PARAM.code,
                                extendedData: error_1.errorCodeList.INPUT_PARAM.message
                            });
                            return [2 /*return*/];
                        }
                        preview = this.streamCenter.checkPreview(stream);
                        if (!preview) {
                            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK + " stream no found");
                            error &&
                                error({
                                    errorCode: error_1.errorCodeList.PUBLISH_NO_PREVIEW.code,
                                    extendedData: error_1.errorCodeList.PUBLISH_NO_PREVIEW.message
                                });
                            return [2 /*return*/];
                        }
                        else if (track.kind === "video" && ((_a = preview.videoEffect) === null || _a === void 0 ? void 0 : _a.enabled)) {
                            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK +
                                " need to disable video beauty effect first");
                            error &&
                                error({
                                    errorCode: error_1.errorCodeList.VIDEO_EFFECT_IS_RUNNING.code,
                                    extendedData: "need to disable video beauty effect before add or remove track"
                                });
                            return [2 /*return*/];
                        }
                        if (type == "ADD" &&
                            (stream.getTracks().length >= 2 ||
                                stream.getTracks().find(function (localTrack) { return localTrack.kind == track.kind; }))) {
                            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK +
                                " only stream which have one track and kind no exist can add track");
                            error &&
                                error({
                                    errorCode: error_1.errorCodeList.TRACK_CAN_NOT_ADD.code,
                                    extendedData: error_1.errorCodeList.TRACK_CAN_NOT_ADD.message
                                });
                            return [2 /*return*/];
                        }
                        else if (type == "REMOVE" &&
                            (stream.getTracks().length == 1 || !stream.getTracks().includes(track))) {
                            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK + " not supported");
                            error({
                                errorCode: error_1.errorCodeList.HANDLE_TRACK_NOT_SUPPORTED.code,
                                extendedData: error_1.errorCodeList.HANDLE_TRACK_NOT_SUPPORTED.message
                            });
                            return [2 /*return*/];
                        }
                        publish = this.streamCenter.checkPublish(stream);
                        //
                        if (publish &&
                            (publish.publisher.stateNego !== 5 ||
                                publish.publisher.isUpdateSDP == true)) {
                            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK + " publish state wrong");
                            error &&
                                error({
                                    errorCode: error_1.errorCodeList.PUBLISHER_STATE_WRONG.code,
                                    extendedData: error_1.errorCodeList.PUBLISHER_STATE_WRONG.message
                                });
                            return [2 /*return*/];
                        }
                        if (!publish) return [3 /*break*/, 6];
                        publisher_1 = publish.publisher;
                        previewer_1 = preview;
                        pc = publish.publisher.peerConnection;
                        publisher_1.isUpdateSDP = true;
                        if (!(type == "ADD")) return [3 /*break*/, 1];
                        // console.error("pc");
                        pc.addTrack(track, stream);
                        return [3 /*break*/, 4];
                    case 1:
                        if (!window.RTCPeerConnection ||
                            //@ts-ignore
                            !window.RTCPeerConnection.prototype.getTransceivers ||
                            !window.RTCRtpTransceiver.prototype.stop) {
                            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK + " not supported getTransceivers");
                            error({
                                errorCode: error_1.errorCodeList.HANDLE_TRACK_NOT_SUPPORTED.code,
                                extendedData: error_1.errorCodeList.HANDLE_TRACK_NOT_SUPPORTED.message
                            });
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, pc
                                .getSenders()
                                .find(function (s) { return s.track && s.track == track; })];
                    case 2:
                        sender_1 = _b.sent();
                        return [4 /*yield*/, pc
                                .getTransceivers()
                                .find(function (tran) { return tran.sender == sender_1; })];
                    case 3:
                        transceiver = _b.sent();
                        if (sender_1 && transceiver && transceiver.stop) {
                            try {
                                pc.removeTrack(sender_1);
                                transceiver.stop();
                            }
                            catch (error) {
                                this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK + " " + error);
                                error &&
                                    error({
                                        errorCode: error_1.errorCodeList.PUBLISHER_UPDATE_SDP_FAIL.code,
                                        extendedData: error_1.errorCodeList.PUBLISHER_UPDATE_SDP_FAIL.message + " " + error
                                    });
                            }
                        }
                        else {
                            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.HANDLE_TRACK + " sender no found");
                            error &&
                                error({
                                    errorCode: error_1.errorCodeList.TRACK_NOT_FOUND.code,
                                    extendedData: error_1.errorCodeList.TRACK_NOT_FOUND.message
                                });
                            return [2 /*return*/];
                        }
                        _b.label = 4;
                    case 4:
                        videoInfo = {};
                        trackPreview = this.streamCenter.previewStreamList.find(function (preview) {
                            return preview.localStream
                                .getTracks()
                                .find(function (_track) { return _track == track; });
                        });
                        if (trackPreview && type == "ADD") {
                            videoInfo = trackPreview.videoInfo;
                        }
                        else {
                            videoInfo = {};
                        }
                        return [4 /*yield*/, pc.createOffer()];
                    case 5:
                        desc = _b.sent();
                        publisher_1.onCreateOfferSuccess(desc, true, videoInfo, function (result) { return __awaiter(_this, void 0, void 0, function () {
                            var trackKey;
                            return __generator(this, function (_a) {
                                if (result !== 0) {
                                    error &&
                                        error({
                                            errorCode: error_1.errorCodeList.PUBLISHER_UPDATE_SDP_FAIL.code,
                                            extendedData: error_1.errorCodeList.PUBLISHER_UPDATE_SDP_FAIL.message
                                        });
                                }
                                else {
                                    trackKey = track.kind == "video" ? "videoTrack" : "audioTrack";
                                    if (type == "ADD") {
                                        // console.error("");
                                        // 
                                        stream.addTrack(track);
                                        previewer_1[trackKey] = track;
                                        // 
                                        if (track.kind == "video" && track.enabled == true) {
                                            publisher_1.sendStreamStatus(0, publisher_1.mic_status);
                                        }
                                        else if (track.enabled == true) {
                                            publisher_1.sendStreamStatus(publisher_1.camera_status, 0);
                                        }
                                    }
                                    else {
                                        // 
                                        if (track.kind == "video") {
                                            publisher_1.sendStreamStatus(2, publisher_1.mic_status);
                                        }
                                        else {
                                            publisher_1.sendStreamStatus(publisher_1.camera_status, 2);
                                        }
                                        // 
                                        stream.removeTrack(track);
                                        previewer_1[trackKey] = null;
                                    }
                                    if (type == "ADD") {
                                        preview.mediaStreamConfig.video = true;
                                    }
                                    else {
                                        preview.mediaStreamConfig.video = false;
                                    }
                                    success({ errorCode: 0, extendedData: "" });
                                }
                                return [2 /*return*/];
                            });
                        }); });
                        return [3 /*break*/, 7];
                    case 6:
                        type == "ADD" ? stream.addTrack(track) : stream.removeTrack(track);
                        success({ errorCode: 0, extendedData: "" });
                        if (type == "ADD") {
                            preview.mediaStreamConfig.video = true;
                        }
                        else {
                            preview.mediaStreamConfig.video = false;
                        }
                        _b.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    AdvancedModule.prototype.switchDevice = function (type, localStream, deviceId, callBack) {
        var _this = this;
        // let sender;
        var publisherInfo = this.streamCenter.checkPublish(localStream);
        if (publisherInfo &&
            publisherInfo.publisher &&
            publisherInfo.publisher.stateNego !== 5) {
            this.logger.error("zsc.sd.0 stream is publishing");
            callBack &&
                callBack({
                    errorCode: error_1.errorCodeList.PUBLISHER_STREAM_NO_FOUND.code,
                    extendedData: error_1.errorCodeList.PUBLISHER_STREAM_NO_FOUND.message
                });
            return;
        }
        var preview = this.streamCenter.checkPreview(localStream);
        if (!preview) {
            this.logger.error("zsc.sd.0 preview no found");
            callBack &&
                callBack({
                    errorCode: error_1.errorCodeList.PUBLISH_NO_PREVIEW.code,
                    extendedData: error_1.errorCodeList.PUBLISH_NO_PREVIEW.message
                });
            return;
        }
        if (type === "video" && preview.mediaStreamConfig.video == false) {
            this.logger.error("zsc.sd.0 camera can not be changed when video is false");
            callBack &&
                callBack({
                    errorCode: error_1.errorCodeList.VIDEO_DEVICE_FALSE.code,
                    extendedData: error_1.errorCodeList.VIDEO_DEVICE_FALSE.message
                });
            return;
        }
        if (type === "audio" && preview.mediaStreamConfig.audio == false) {
            this.logger.error("zsc.sd.0 microphone can not be changed when audio is false");
            callBack &&
                callBack({
                    errorCode: error_1.errorCodeList.AUDIO_DEVICE_FALSE.code,
                    extendedData: error_1.errorCodeList.AUDIO_DEVICE_FALSE.message
                });
            return;
        }
        if (preview.mediaStreamConfig.videoInput !== deviceId) {
            delete preview.mediaStreamConfig.facingMode;
        }
        var mediaStreamConfig = {};
        var lastTrack;
        if (type === "video") {
            mediaStreamConfig.videoInput = deviceId;
            lastTrack = preview.videoTrack;
        }
        else {
            mediaStreamConfig.audioInput = deviceId;
            lastTrack = preview.audioTrack;
        }
        // const isSafari: boolean = /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
        //   8safari
        // FireFox NotReadableError: Concurrent mic process limit
        // !isSafari && lastTrack.stop();
        var bro = this.stateCenter.browser;
        this.logger.info("zsc.sd.0 browser " + bro);
        bro === "firefox" && lastTrack.stop();
        var constraints = __assign(__assign({}, preview.mediaStreamConfig), mediaStreamConfig);
        var mediaStreamConstraints = preview.getMediaStreamConstraints(constraints);
        /** */
        var replaceStreamTracks = function (originStream, newStream) {
            newStream.getTracks().forEach(function (track) {
                if (track.kind === type) {
                    var key = type === "video" ? "videoTrack" : "audioTrack";
                    var localTrack = preview[key];
                    track.enabled = localTrack.enabled;
                    localTrack && localTrack.stop();
                    if (publisherInfo) {
                        publisherInfo.publisher.replacePublishedTrack(track);
                    }
                    else if (preview) {
                        preview.replacePreviewTrack(track);
                    }
                }
                // if (publisherInfo) {
                //   const sender = publisherInfo.publisher.peerConnection
                //     ?.getSenders()
                //     .find((s: any) => s.track !== null && s.track.kind === track.kind);
                //   if (localTrack.kind === type) {
                //     if (sender) {
                //       sender.replaceTrack(track);
                //       preview.gainNode = null;
                //     } else {
                //       this.logger.warn(
                //         "zsc.sd.0 no sender found, only switching device on localMediaElement"
                //       );
                //     }
                //   }
                //   const enable = track.enabled ? 0 : 20;
                //   const publisher = publisherInfo.publisher;
                //   const camera_status = publisher.camera_status;
                //   const mic_status = publisher.mic_status;
                //   if (type == "video" && enable !== camera_status) {
                //     publisher.sendStreamStatus(enable, mic_status);
                //   }
                //   if (type == "audio" && enable !== mic_status) {
                //     publisher.sendStreamStatus(camera_status, enable);
                //   }
                // }
            });
            // localStream 
            preview.restartSoundLevel();
        };
        type == "audio"
            ? (mediaStreamConstraints.video = false)
            : (mediaStreamConstraints.audio = false);
        navigator.mediaDevices.getUserMedia(mediaStreamConstraints).then(function (stream) {
            Object.assign(preview.mediaStreamConfig, mediaStreamConfig);
            replaceStreamTracks(localStream, stream);
            _this.logger.info("zsc.sd.0 swtich " + type + " device success");
            callBack && callBack({ errorCode: 0, extendedData: "" });
        }, function (err) {
            var _a, _b;
            // 
            type == "video"
                ? (_a = preview.videoTrack) === null || _a === void 0 ? void 0 : _a.stop() : (_b = preview.audioTrack) === null || _b === void 0 ? void 0 : _b.stop();
            _this.logger.warn("zsc.sd.0 swtich " +
                type +
                " device failed, stop last device and retry. ", err + "");
            navigator.mediaDevices.getUserMedia(mediaStreamConstraints).then(function (stream1) {
                Object.assign(preview.mediaStreamConfig, mediaStreamConfig);
                replaceStreamTracks(localStream, stream1);
                _this.logger.info("zsc.sd.0 swtich " + type + " device success");
                callBack && callBack({ errorCode: 0, extendedData: "" });
            }, function (err1) {
                _this.logger.warn("zsc.sd.0 swtich " +
                    type +
                    " device failed and recover last device. ", err1 + "");
                // recover
                var lastConstraints = preview.getMediaStreamConstraints(preview.mediaStreamConfig);
                var errCode = error_1.errorCodeList.VIDEO_DEVICE_FALSE;
                if (type === "audio") {
                    errCode = error_1.errorCodeList.AUDIO_DEVICE_FALSE;
                }
                navigator.mediaDevices.getUserMedia(lastConstraints).then(function (stream2) {
                    replaceStreamTracks(localStream, stream2);
                    _this.logger.info("zsc.sd.0 recover last " + type + " device success");
                    callBack &&
                        callBack({
                            errorCode: errCode.code,
                            extendedData: errCode.message + " " + JSON.stringify(err1)
                        });
                }, function (err2) {
                    _this.logger.error("zsc.sd.0 swtich " +
                        type +
                        " device and recover failed, please recreate stream. ", err2 + "");
                    callBack &&
                        callBack({
                            errorCode: errCode.code,
                            extendedData: errCode.message + " " + JSON.stringify(err2)
                        });
                });
            });
        });
    };
    AdvancedModule.prototype._replaceTrack = function (localStream, mediaStreamTrack
    // callBack?: (result: { errorCode: number; extendedData: string }) => void
    ) {
        var preview = this.streamCenter.checkPreview(localStream);
        var publisher = this.streamCenter.checkPublish(localStream);
        // const isSafari: boolean =
        //   /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
        if (!publisher) {
            if (!preview) {
                this.logger.error("zc.rt.0 preview no found");
                return {
                    errorCode: error_1.errorCodeList.PUBLISH_NO_PREVIEW.code,
                    extendedData: error_1.errorCodeList.PUBLISH_NO_PREVIEW.message
                };
            }
            var localStream_1 = preview.localStream;
            var localTrack = localStream_1
                .getTracks()
                .find(function (t) { return t.kind === mediaStreamTrack.kind; });
            if (!localTrack) {
                this.logger.error("zc.rt.0 track no found");
                return {
                    errorCode: error_1.errorCodeList.TRACK_NOT_FOUND.code,
                    extendedData: error_1.errorCodeList.TRACK_NOT_FOUND.message
                };
            }
            // !isSafari && localTrack.stop();
            // 
            preview.replacePreviewTrack(mediaStreamTrack);
            return { errorCode: 0, extendedData: "" };
        }
        else {
            var result = publisher.publisher.replacePublishedTrack(mediaStreamTrack);
            return result;
        }
    };
    AdvancedModule.prototype.enableMicrophone = function (localStream, enable) {
        var preview = this.streamCenter.checkPreview(localStream);
        if (!preview) {
            this.logger.error("zsc.em.0 no preview");
            return false;
        }
        return preview.enableMicrophone(enable, this.streamCenter);
    };
    AdvancedModule.prototype.enableCamera = function (localStream, enable, retain) {
        var preview = this.streamCenter.checkPreview(localStream);
        if (!preview) {
            this.logger.error("zsc.ec.0 no preview");
            return false;
        }
        return preview.enableCamera(enable, this.streamCenter, retain);
    };
    AdvancedModule.prototype.setBeautyEffect = function (localStream, enable, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // const seq = this.stateCenter.getReportSeq();
            // this.dataReport.newReport(seq, ZegoRTCLogEvent.kZegoReplaceTrack.event);
            // 
            if (!(localStream instanceof MediaStream)) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_BEAUTY_EFFECT + " localStream not found");
                // this.dataReport.uploadReport(
                //   seq,
                //   undefined,
                //   ZegoRTCLogEvent.kZegoReplaceTrack.error.kParamError
                // );
                reject({
                    errorCode: log_event_1.ZegoRTCLogEvent.kZegoReplaceTrack.error.kParamError.code,
                    extendedData: log_event_1.ZegoRTCLogEvent.kZegoReplaceTrack.error.kParamError.message +
                        " localStream no found"
                });
                return;
            }
            enable = !!enable;
            var resolveResult = function (result) {
                // this.dataReport.uploadReport(seq);
                resolve(result);
            };
            // this._replaceTrack(localStream, mediaStreamTrack, resolveResult);
            var preview = _this.streamCenter.checkPreview(localStream);
            if (!preview) {
                _this.logger.error("zc.sbe.0 preview no found");
                resolveResult({
                    errorCode: error_1.errorCodeList.PUBLISH_NO_PREVIEW.code,
                    extendedData: error_1.errorCodeList.PUBLISH_NO_PREVIEW.message
                });
                return;
            }
            preview
                .setBeautyEffect(enable, options)
                .then(function () {
                resolveResult({ errorCode: 0, extendedData: "" });
            })
                .catch(function (err) {
                reject({
                    errorCode: -1,
                    extendedData: err.toString()
                });
            });
        });
    };
    return AdvancedModule;
}());
exports.AdvancedModule = AdvancedModule;


/***/ }),

/***/ "./sdk/src/modules/advance/content.ts":
/*!********************************************!*\
  !*** ./sdk/src/modules/advance/content.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.signal = exports.publisher = exports.publishModule = exports.playModule = exports.preview = exports.streamHandler = exports.zegoWebRTC = exports.ENUM_PUBLISH_STREAM_STATE = exports.ENUM_STREAM_CMD_PRI = exports.ENUM_STREAM_SUB_CMD = exports.PROTO_VERSION = void 0;
//@ts-nocheck
var action_1 = __webpack_require__(/*! ./action */ "./sdk/src/modules/advance/action.ts");
var error_1 = __webpack_require__(/*! ./error */ "./sdk/src/modules/advance/error.ts");
var log_event_1 = __webpack_require__(/*! ./log.event */ "./sdk/src/modules/advance/log.event.ts");
var mediaUtil_1 = __webpack_require__(/*! ./mediaUtil */ "./sdk/src/modules/advance/mediaUtil.ts");
var SEND_MSG_TIMEOUT = 1;
exports.PROTO_VERSION = "2.13.0";
exports.ENUM_STREAM_SUB_CMD = {
    liveNone: 0,
    liveBegin: 2001,
    liveEnd: 2002,
    liveUpdate: 2003
};
exports.ENUM_STREAM_CMD_PRI = {
    liveBegin: "zegochat_js.room_stream_create_req",
    liveEnd: "zegochat_js.room_stream_delete_req",
    liveUpdate: "zegochat_js.room_stream_update_req"
};
exports.ENUM_PUBLISH_STREAM_STATE = {
    waiting_url: 1,
    tryPublish: 2,
    update_info: 3,
    publishing: 4,
    stop: 5,
    retryPublish: 6
};
//ZegoWebRTC
exports.zegoWebRTC = {
    mutePublishStreamVideo: function (localStream, mute, retain) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_PUBLISH_STREAM_VIDEO + " call");
        var reportSeq = this.stateCenter.getReportSeq();
        this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskMutePublishVideo);
        if (typeof mute !== "boolean" ||
            (retain !== undefined && typeof retain !== "boolean")) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.MUTE_PUBLISH_STREAM_VIDEO + " option error");
            return false;
        }
        var res = this.rtcModules.advancedModule.enableStream(localStream, {
            video: !mute,
            retain: retain
        });
        this.dataReport.uploadReport(reportSeq);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_PUBLISH_STREAM_VIDEO + " end");
        return res;
    },
    mutePublishStreamAudio: function (localStream, mute) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_PUBLISH_STREAM_AUDIO + " call");
        var reportSeq = this.stateCenter.getReportSeq();
        this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskMutePublishAudio);
        if (typeof mute !== "boolean") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.MUTE_PUBLISH_STREAM_AUDIO + " option error");
            return false;
        }
        var res = this.rtcModules.advancedModule.enableStream(localStream, {
            audio: !mute
        });
        this.dataReport.uploadReport(reportSeq);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_PUBLISH_STREAM_AUDIO + " end");
        return res;
    },
    mutePlayStreamVideo: function (streamID, mute) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_PLAY_STREAM_VIDEO +
            " call " +
            streamID +
            " " +
            mute);
        var reportSeq = this.stateCenter.getReportSeq();
        this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskMutePlayVideo);
        var res = this.rtcModules.playModule.mutePlayStream(streamID, "video", mute);
        this.dataReport.uploadReport(reportSeq);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_PLAY_STREAM_VIDEO + " end");
        return res;
    },
    mutePlayStreamAudio: function (streamID, mute) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_PLAY_STREAM_AUDIO +
            " call " +
            streamID +
            " " +
            mute);
        var reportSeq = this.stateCenter.getReportSeq();
        this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskMutePlayAudio);
        var res = this.rtcModules.playModule.mutePlayStream(streamID, "audio", mute);
        this.dataReport.uploadReport(reportSeq);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_PLAY_STREAM_AUDIO + "end");
        return res;
    },
    muteMicrophone: function (mute) {
        // return false
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_MIC + " call");
        var reportSeq = this.stateCenter.getReportSeq();
        this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskMuteMicrophone);
        if (typeof mute !== "boolean") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.MUTE_MIC + " option error");
            return false;
        }
        var res = this.rtcModules.advancedModule.enableMicrophoneOnly(!mute);
        this.dataReport.uploadReport(reportSeq);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MUTE_MIC + " end");
        return res;
    },
    activateSEIInsert: function (config) {
        var stream = config.stream, action = config.action, infoType = config.infoType;
        return this.rtcModules.publishModule.activateSEIInsert(stream, action, infoType);
    },
    getAudioInfo: function (localStream, errCallBack, option) {
        if (!localStream) {
            this.logger.error("localStream is empty!");
            return false;
        }
        var _option = __assign({}, option);
        return new mediaUtil_1.MediaUtil(this.ac, _option).connectToSource(localStream, function (e) {
            errCallBack(e);
        });
    },
    startRecord: function (stream) {
        var _this = this;
        var preview = this.streamCenter.checkPreview(stream);
        if (!preview) {
            this.logger.error("stream is not from zego!");
            return;
        }
        var playStreamClone = stream.clone();
        var audioTracksClone = playStreamClone.getAudioTracks();
        if (audioTracksClone.length > 0 && preview.hasEmptyAudioTrack) {
            audioTracksClone.forEach(function (track) {
                playStreamClone.removeTrack(track);
            });
        }
        this.recordedBlobs = [];
        var options = { mimeType: "video/webm;codecs=vp9" };
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
            options = { mimeType: "video/webm;codecs=vp8,opus" };
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                options = { mimeType: "video/webm;codecs=vp8" };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options = { mimeType: "video/webm" };
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options = { mimeType: "" };
                    }
                }
            }
        }
        try {
            this.mediaRecorder = new MediaRecorder(playStreamClone, options);
        }
        catch (e) {
            this.logger.error("Exception while creating ZegoMediaRecorder:", e);
            return;
        }
        this.mediaRecorder.onstop = function (event) {
            _this.logger.warn("Recorder stopped: " + event);
        };
        this.mediaRecorder.ondataavailable = this.handleDataAvailable.bind(this);
        this.mediaRecorder.start(10); // collect 10ms of data
    },
    stopRecord: function () {
        if (this.mediaRecorder) {
            this.mediaRecorder.stop();
        }
        else {
            this.logger.warn("please invoke startRecord first");
        }
    },
    resumeRecord: function () {
        if (this.mediaRecorder) {
            this.mediaRecorder.resume();
        }
        else {
            this.logger.warn("please invoke startRecord first");
        }
    },
    pauseRecord: function () {
        if (this.mediaRecorder) {
            this.mediaRecorder.pause();
        }
        else {
            this.logger.warn("please invoke startRecord first");
        }
    },
    saveRecord: function (name) {
        if (this.mediaRecorder && this.recordedBlobs) {
            var blob = new Blob(this.recordedBlobs, { type: "video/webm" });
            var url_1 = window.URL.createObjectURL(blob);
            var a_1 = document.createElement("a");
            a_1.style.display = "none";
            a_1.href = url_1;
            a_1.download = name + ".webm";
            document.body.appendChild(a_1);
            a_1.click();
            setTimeout(function () {
                document.body.removeChild(a_1);
                window.URL.revokeObjectURL(url_1);
            }, 100);
        }
        else {
            this.logger.warn("please invoke startRecord first");
        }
    },
    handleDataAvailable: function (event) {
        if (event.data && event.data.size > 0) {
            this.recordedBlobs.push(event.data);
        }
    },
    takeSnapShot: function (el, img) {
        if (el && el.videoHeight !== 0) {
            var canvas = document.createElement("canvas");
            canvas.width = el.videoWidth;
            canvas.height = el.videoHeight;
            var canvasContext = canvas.getContext("2d");
            canvasContext &&
                canvasContext.drawImage(el, 0, 0, canvas.width, canvas.height);
            img.src = canvas.toDataURL("image/jpeg");
        }
        else {
            this.logger.error("video can not empty");
        }
    },
    saveSnapShot: function (el, name) {
        if (el && el.videoHeight !== 0) {
            var canvas = document.createElement("canvas");
            canvas.width = el.videoWidth;
            canvas.height = el.videoHeight;
            var canvasContext = canvas.getContext("2d");
            canvasContext &&
                canvasContext.drawImage(el, 0, 0, canvas.width, canvas.height);
            canvas.toBlob(function (blob) {
                var url = window.URL.createObjectURL(blob);
                var a = document.createElement("a");
                a.style.display = "none";
                a.href = url;
                a.download = name + ".jpeg";
                document.body.appendChild(a);
                a.click();
                setTimeout(function () {
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                }, 100);
            });
        }
        else {
            this.logger.error("video can not empty");
        }
    },
    setStreamExtraInfo: function (streamID, extraInfo) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var reportSeq = _this.stateCenter.getReportSeq();
            _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.event);
            _this.dataReport.addMsgInfo(reportSeq, {
                stream: log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.stream(streamID),
                stream_extra_info: log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.stream_extra_info(extraInfo)
            });
            var handleError = function (err, errMsg) {
                _this.logger.error("zb.ssei " + errMsg);
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: err.code,
                    message: err.message + " " + errMsg
                });
                _this.dataReport.uploadReport(reportSeq);
                reject({
                    errorCode: err.code,
                    extendedData: err.message + " " + errMsg
                });
            };
            if (typeof streamID !== "string" || streamID == "") {
                handleError(log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.error
                    .kParamError, "streamID must be string and not empty");
                return;
            }
            if (typeof extraInfo !== "string" || extraInfo == "") {
                handleError(log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.error
                    .kParamError, "extraInfo must be string and no empty");
                return;
            }
            if (_this.RTM.isDisConnect()) {
                handleError(log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.error
                    .kNoLoginError, "not login");
                return;
            }
            if (!_this.stateCenter.publishStreamList[streamID]) {
                handleError(log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.error
                    .kPublishStreamNoFoundError, "publish stream no found");
                return;
            }
            var room = _this.streamCenter.getRoomByStreamID(streamID);
            if (!room) {
                handleError(log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.error
                    .kNoLoginError, "not login");
                return;
            }
            _this.dataReport.addMsgInfo(reportSeq, {
                room_sid: log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.room_sid(room.sessionID)
            });
            room.streamHandler.setStreamExtraInfo(streamID, extraInfo, resolve, handleError);
            _this.dataReport.uploadReport(reportSeq);
        });
    },
    addTrack: function (stream, track) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.ADD_TRACK + " call");
            _this.rtcModules.advancedModule.handleTrack("ADD", stream, track, resolve, reject);
        });
    },
    removeTrack: function (stream, track) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.REMOVE_TRACK + " call");
            _this.rtcModules.advancedModule.handleTrack("REMOVE", stream, track, resolve, reject);
        });
    }
};
//streamHandler
exports.streamHandler = {
    _publishTarget: function (cdnPushConfig, success, error) {
        var _this = this;
        this.logger.info("zb.sh.pt" + "call");
        var timestamp = Math.ceil(new Date().getTime() / 1000);
        var totalStreamId = cdnPushConfig.streamID;
        if (this.stateCenter.testEnvironment) {
            totalStreamId =
                "zegotest-" + this.stateCenter.appid + "-" + cdnPushConfig.streamID;
        }
        var req_body = {
            appid: this.stateCenter.appid,
            biz_type: 0,
            timestamp: timestamp,
            // signature: cdnPushConfig.signature,
            seq: this.stateCenter.cdnSeq++,
            version: exports.PROTO_VERSION * 1,
            stream_id: totalStreamId,
            pushurl: cdnPushConfig.pushUrl
            //  guid signature session_secret AppSecret stream
        };
        this.logger.debug("zb.sh.pt" + " send command");
        var useNetAgent = this.stateCenter.useNetAgent;
        if (!useNetAgent) {
            var body = {
                channel: "media",
                cmd: cdnPushConfig.type,
                req_body: JSON.stringify(req_body)
            };
            this.sendBizChannelRequest(body, function (seq, cmd, rspBody) {
                _this.logger.info("zb.sh.pt" + " receive message");
                if (rspBody.length == 0) {
                    error(log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kNoResponseError);
                    return;
                }
                var data = JSON.parse(rspBody);
                var code = data.code, message = data.message;
                if (!code || code == 0) {
                    _this.logger.info("zb.sh.pt " + cdnPushConfig.type + " success");
                    success && success({ errorCode: 0, extendedData: "" });
                }
                else {
                    _this.logger.error("zb.sh.pt " +
                        cdnPushConfig.type +
                        " error code: " +
                        code +
                        " " +
                        message);
                    error(error_1.errorCodeList.UNKNOWN_SERVER_ERROR, " cmd: " + cdnPushConfig.type + " " + code + " " + message);
                }
            }, function (err, seq, rspbody) {
                _this.logger.info("zb.sh.pt error: " + err);
                var message = "";
                var errorCode = log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kUnknownServerError;
                if (err == 2001) {
                    errorCode =
                        log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kInvalidChannelError;
                }
                else if (err == 2002) {
                    errorCode =
                        log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kBizChannelError;
                }
                _this.logger.error("zb.sh.pt " + message);
                error(errorCode, " cmd: " + cdnPushConfig.type + " " + err + " " + message + "  ");
            });
        }
        else {
            this.sendBizChannelRequestV2({
                server: 1,
                location: "/liveroomcmd/push",
                cmd: cdnPushConfig.type
            }, req_body, function (rspBody) {
                _this.logger.info("zb.sh.pt" + " receive message");
                var _a = rspBody || {}, code = _a.code, message = _a.message;
                if (!code || code == 0) {
                    _this.logger.info("zb.sh.pt " + cdnPushConfig.type + " success");
                    success && success({ errorCode: 0, extendedData: "" });
                }
                else {
                    _this.logger.error("zb.sh.pt " +
                        cdnPushConfig.type +
                        " error code: " +
                        code +
                        " " +
                        message);
                    error(error_1.errorCodeList.UNKNOWN_SERVER_ERROR, " cmd: " + cdnPushConfig.type + " " + code + " " + message);
                }
            }, function (httpCode, bizError, rspBody, errorCode) {
                var message = "";
                // SDK
                if (errorCode) {
                    error && error(errorCode, message);
                    return;
                }
                else {
                    errorCode =
                        log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kUnknownServerError;
                }
                if (httpCode === 200) {
                    _this.logger.info("zb.sh.pt error: " + bizError);
                    errorCode =
                        log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kUnknownServerError;
                    if (bizError == 2001) {
                        errorCode =
                            log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error
                                .kInvalidChannelError;
                    }
                    else if (bizError == 2002) {
                        errorCode =
                            log_event_1.ZegoRTCLogEvent.kZegoTaskPublishTarget.error.kBizChannelError;
                    }
                    message = "cmd: " + cdnPushConfig.type + ", biz_code: " + bizError;
                }
                else {
                    message = "request media server fail, error: " + httpCode;
                }
                _this.logger.error("zb.sh.pt " + message);
                error && error(errorCode, message);
            });
            // this.sendRTMPRequest(
            //   {},
            //   req_body,
            //   (httpCode: number, rspBody: any) => {},
            //   (error: { code: string; message: "" }) => {}
            // );
        }
    },
    updateStreamExtraInfo: function (streamid, extraInfo, success, error) {
        this.logger.info("zb.sh.usei call");
        var cmd;
        this.stateCenter.type === "PUBLIC"
            ? (cmd = exports.ENUM_STREAM_SUB_CMD.liveUpdate)
            : (cmd = exports.ENUM_STREAM_CMD_PRI.liveUpdate);
        if (this.stateCenter.publishStreamList[streamid] &&
            this.stateCenter.publishStreamList[streamid].state >=
                exports.ENUM_PUBLISH_STREAM_STATE.update_info) {
            this.stateCenter.publishStreamList[streamid].extra_info = extraInfo;
            this.updateStreamInfo(streamid, cmd, extraInfo);
            success({ errorCode: 0 });
        }
        else if (this.stateCenter.publishStreamList[streamid] &&
            this.stateCenter.publishStreamList[streamid].state ===
                exports.ENUM_PUBLISH_STREAM_STATE.tryPublish) {
            this.stateCenter.publishStreamList[streamid].extra_info = extraInfo;
            success({ errorCode: 0 });
        }
        else {
            error(log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomSendStreamExtraInfo.error
                .kUpdateStreamInfoFailError);
        }
    },
    setStreamExtraInfo: function (streamID, extraInfo, success, error) {
        this.updateStreamExtraInfo(streamID, extraInfo, success, error);
    }
};
//preview
exports.preview = {
    enableCamera: function (enable, streamCenter, retain) {
        var _this = this;
        var _a, _b, _c;
        if (!this.localStream) {
            this.logger.error("zp.ec.2 no localStream");
            return false;
        }
        var track = this.videoTrack;
        if ((!retain || enable) && track) {
            track.enabled = enable;
            // fix chrome 87 chrome 92 
            if (this.stateCenter.browser === "chrome" &&
                enable &&
                typeof track.getSettings().width !== undefined &&
                track.getSettings().width > 0) {
                var videoWidth = track.getSettings().width - 1;
                var videoHeight = track.getSettings().height - 1;
                track.applyConstraints({ width: videoWidth, height: videoHeight });
                setTimeout(function () {
                    track.applyConstraints({
                        width: _this.videoInfo.width,
                        height: _this.videoInfo.height
                    });
                }, 200);
            }
        }
        var publisher = (_a = streamCenter.checkPublish(this.localStream)) === null || _a === void 0 ? void 0 : _a.publisher;
        if (publisher) {
            var sender = (_b = publisher.peerConnection) === null || _b === void 0 ? void 0 : _b.getSenders().find(function (s) { var _a; return ((_a = s.track) === null || _a === void 0 ? void 0 : _a.kind) === "video"; });
            if (retain && !enable) {
                var _track = this.videoTrack.clone();
                sender === null || sender === void 0 ? void 0 : sender.replaceTrack(_track);
                _track.stop();
            }
            else if (enable) {
                if (((_c = this.videoEffect) === null || _c === void 0 ? void 0 : _c.enabled) && this.videoEffect.output) {
                    sender === null || sender === void 0 ? void 0 : sender.replaceTrack(this.videoEffect.output);
                }
                else {
                    sender === null || sender === void 0 ? void 0 : sender.replaceTrack(this.videoTrack);
                }
            }
            var camera_status = enable ? 0 : 20;
            var mic_status = this.isAudioEnabled && streamCenter.isMicEnabled ? 0 : 20;
            if (publisher.signal &&
                (publisher.camera_status !== camera_status ||
                    publisher.mic_status !== mic_status)) {
                publisher.sendStreamStatus(camera_status, mic_status);
            }
        }
        this.logger.info("zp.ec.2 call success");
        return true;
    },
    enableMicrophone: function (enable, streamCenter) {
        var _a;
        if (!this.localStream) {
            this.logger.error("zp.em.2 no localStream");
            return false;
        }
        this.localStream.getAudioTracks().forEach(function (track) {
            track.enabled = enable;
        });
        this.audioTrack &&
            (this.audioTrack.enabled = enable && streamCenter.isMicEnabled);
        var publisher = (_a = streamCenter.checkPublish(this.localStream)) === null || _a === void 0 ? void 0 : _a.publisher;
        if (publisher && publisher.signal) {
            // wait signal connected
            var camera_status = publisher.camera_status;
            var mic_status = enable && streamCenter.isMicEnabled ? 0 : 20;
            if (publisher.camera_status !== camera_status ||
                publisher.mic_status !== mic_status) {
                publisher.sendStreamStatus(camera_status, mic_status);
            }
        }
        this.isAudioEnabled = enable;
        this.logger.debug("zp.em.2 call success");
        return true;
    },
    /**
     * 
     * @param track 
     * @param isEffectTrack 
     * @returns
     */
    replacePreviewTrack: function (track, isEffectTrack) {
        var _a;
        if (isEffectTrack === void 0) { isEffectTrack = false; }
        return __awaiter(this, void 0, void 0, function () {
            var type, localTrack;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!track || !track.kind || !this.localStream)
                            return [2 /*return*/];
                        type = track.kind === "audio" ? "audioTrack" : "videoTrack";
                        if (!(!isEffectTrack && ((_a = this.videoEffect) === null || _a === void 0 ? void 0 : _a.enabled) && track.kind === "video")) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.videoEffect.setInput(track)];
                    case 1:
                        _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        localTrack = this.localStream
                            .getTracks()
                            .find(function (item) { return item.kind === track.kind; });
                        if (localTrack) {
                            this.localStream.removeTrack(localTrack);
                        }
                        this.localStream.addTrack(track);
                        _b.label = 3;
                    case 3:
                        if (!isEffectTrack) {
                            this[type] = track;
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
};
//playModule
exports.playModule = {
    mutePlayStream: function (streamID, type, mute) {
        var _this = this;
        this.logger.info("zsc.mps.0 call " + type + " " + mute);
        return new Promise(function (resolve, reject) {
            if (typeof streamID !== "string" || streamID == "") {
                _this.logger.error("zsc.mps.0 streamID must be string and not empty");
                reject(false);
                return;
            }
            if (typeof mute !== "boolean") {
                _this.logger.error("zsc.mps.0 mute must be boolean");
                reject(false);
                return;
            }
            var player = _this.streamCenter.playerList[streamID];
            if (!player) {
                _this.logger.error("zsc.mps.0 player not found");
                reject(false);
                return;
            }
            if (type === "video") {
                if (
                // @ts-ignore
                (player.playOption && player.playOption.video === false) ||
                    (player.player && player.player.cameraStatus !== 0)) {
                    _this.logger.error("zsc.mps.0 stream no contain video");
                    reject(false);
                    return;
                }
                player.player.signal.ActivatePlayVideoStream(_this.stateCenter.getSeq(), player.player.sessionId, mute, function () {
                    _this.logger.info("zsc.mps.0 suc");
                    //
                    var reportSeq = _this.stateCenter.getReportSeq();
                    player.player.playMediaStatus.video = !mute;
                    _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoPlayContentChanged.event);
                    _this.dataReport.addMsgInfo(reportSeq, {
                        session_id: log_event_1.ZegoRTCLogEvent.kZegoPlayContentChanged.session_id(player.player.sessionId),
                        video_activate: log_event_1.ZegoRTCLogEvent.kZegoPlayContentChanged.video_activate(player.player.playMediaStatus.video ? 1 : 0),
                        audio_activate: log_event_1.ZegoRTCLogEvent.kZegoPlayContentChanged.audio_activate(player.player.playMediaStatus.audio ? 1 : 0)
                    });
                    _this.playVideoStatus = _this.dataReport.uploadReport(reportSeq);
                    resolve(true);
                }, function () {
                    _this.logger.error("zsc.mps.0 fail");
                    reject(false);
                });
            }
            else if (type === "audio") {
                if (
                // @ts-ignore
                (player.playOption && player.playOption.audio === false) ||
                    (player.player && player.player.micStatus !== 0)) {
                    _this.logger.error("zsc.mps.0 stream no contain audio");
                    reject(false);
                    return;
                }
                player.player.signal.ActivatePlayAudioStream(_this.stateCenter.getSeq(), player.player.sessionId, mute, function () {
                    _this.logger.info("zsc.mps.0 suc");
                    //
                    var reportSeq = _this.stateCenter.getReportSeq();
                    player.player.playMediaStatus.audio = !mute;
                    _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTCLogEvent.kZegoPlayContentChanged.event);
                    _this.dataReport.addMsgInfo(reportSeq, {
                        session_id: log_event_1.ZegoRTCLogEvent.kZegoPlayContentChanged.session_id(player.player.sessionId),
                        video_activate: log_event_1.ZegoRTCLogEvent.kZegoPlayContentChanged.video_activate(player.player.playMediaStatus.video ? 1 : 0),
                        audio_activate: log_event_1.ZegoRTCLogEvent.kZegoPlayContentChanged.audio_activate(player.player.playMediaStatus.audio ? 1 : 0)
                    });
                    _this.dataReport.uploadReport(reportSeq);
                    resolve(true);
                }, function () {
                    _this.logger.error("zsc.mps.0 fail");
                    reject(false);
                });
            }
            else {
                reject(false);
            }
        });
    },
    setStreamAudioOutput: function (localVideo, audioOutput) {
        var _this = this;
        if (audioOutput != undefined && audioOutput.length != 0 && localVideo) {
            this.logger.debug("zsc.ssao.0 device " + audioOutput);
            if (!localVideo) {
                this.logger.error("zsc.ssao.0 no localVideo");
                return false;
            }
            if (localVideo.sinkId !== "undefined") {
                localVideo
                    .setSinkId(audioOutput)
                    .then(function () {
                    _this.logger.info("zsc.ssao.0 success device: " + audioOutput);
                    // _this.audioOutput = audioOutput;
                })
                    .catch(function (error) {
                    _this.logger.info("zsc.ssao.0 " + error.name);
                });
                return true;
            }
            else {
                this.logger.error("zsc.ssao.0 browser does not suppport");
                return false;
            }
        }
        return false;
    }
};
//publishModule
exports.publishModule = {
    activateSEIInsert: function (stream, action, infoType) {
        if (infoType === void 0) { infoType = 0; }
        var previewStream = this.streamCenter.checkPreview(stream);
        if (!previewStream) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.ACTIVATE_SEI_INSERT + " stream is not created");
            return false;
        }
        if (action === 0 || action === 1) {
            previewStream.activatesSEIConfig = {
                action: action,
                infoType: infoType
            };
        }
        else {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.ACTIVATE_SEI_INSERT +
                " value of action should be 0 or 1");
            return false;
        }
        var publisher = this.streamCenter.checkPublish(stream);
        if (publisher) {
            publisher === null || publisher === void 0 ? void 0 : publisher.publisher.activateSEIInsert(action, infoType);
        }
        return true;
    }
};
//publisher
exports.publisher = {
    activateSEIInsert: function (action, infoType) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (!_this.signal) {
                return resolve(false);
            }
            _this.signal &&
                _this.signal.activateSEIInsert(_this.stateCenter.getSeq(), _this.sessionId, _this.peerID, action, infoType, function (seq, sessionID, body) {
                    // 0 success, 1 invalid param, 2 peer not exist
                    var result = false;
                    if (body.result === 0) {
                        _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.ACTIVATE_SEI_INSERT + " called success");
                        result = true;
                    }
                    else if (body.result === 1) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.ACTIVATE_SEI_INSERT +
                            " " +
                            body.peer_id +
                            " invalid param.");
                        result = false;
                    }
                    else if (body.result === 2) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.ACTIVATE_SEI_INSERT + " peer not exist");
                        result = false;
                    }
                    resolve(result);
                }, function (errcode) {
                    if (SEND_MSG_TIMEOUT === errcode) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.ACTIVATE_SEI_INSERT + " request timeout");
                    }
                });
            return false;
        });
    },
    replacePublishedTrack: function (mediaStreamTrack, isEffectTrack) {
        var _a, _b;
        if (isEffectTrack === void 0) { isEffectTrack = false; }
        return __awaiter(this, void 0, void 0, function () {
            var localStream, previewer, videoEffect, kind, localTrack, sender, cameraStatus, micStatus;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        localStream = this.localStream;
                        previewer = this.previewer;
                        videoEffect = previewer === null || previewer === void 0 ? void 0 : previewer.videoEffect;
                        kind = mediaStreamTrack.kind;
                        localTrack = previewer[kind + "Track"];
                        sender = (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.getSenders().find(function (s) { return s.track.kind === kind; });
                        if (!localTrack) return [3 /*break*/, 2];
                        cameraStatus = 0;
                        micStatus = 0;
                        if (kind === "video") {
                            // 
                            if (isEffectTrack) {
                                cameraStatus = localTrack.enabled === true ? 0 : 20;
                            }
                            else {
                                cameraStatus = mediaStreamTrack.enabled === true ? 0 : 20;
                            }
                            micStatus =
                                localStream.getAudioTracks()[0] &&
                                    localStream.getAudioTracks()[0].enabled == true
                                    ? 0
                                    : 20;
                        }
                        else if (kind === "audio") {
                            micStatus = mediaStreamTrack.enabled === true ? 0 : 20;
                            cameraStatus = ((_b = previewer.videoTrack) === null || _b === void 0 ? void 0 : _b.enabled) == true ? 0 : 20;
                        }
                        // !isSafari && localTrack.stop();
                        // 
                        return [4 /*yield*/, previewer.replacePreviewTrack(mediaStreamTrack, isEffectTrack)];
                    case 1:
                        // !isSafari && localTrack.stop();
                        // 
                        _c.sent();
                        // 
                        if (sender) {
                            if (kind === "audio" || isEffectTrack || !(videoEffect === null || videoEffect === void 0 ? void 0 : videoEffect.enabled)) {
                                sender.replaceTrack(mediaStreamTrack);
                            }
                            if (this.camera_status !== cameraStatus ||
                                this.mic_status !== micStatus) {
                                this.sendStreamStatus(cameraStatus, micStatus);
                            }
                        }
                        else {
                            this.logger.info("zc.rt.1 replace remote track will work after stream published");
                        }
                        this.logger.info("zc.rt.1 replace remote track success");
                        return [2 /*return*/, { errorCode: 0, extendedData: "" }];
                    case 2:
                        this.logger.error("zc.rt.1 publisher track no found");
                        return [2 /*return*/, {
                                errorCode: error_1.errorCodeList.TRACK_NOT_FOUND.code,
                                extendedData: error_1.errorCodeList.TRACK_NOT_FOUND.message
                            }];
                }
            });
        });
    }
};
exports.signal = {
    activateSEIInsert: function (seq, sessionID, peerID, action, infoType, success, error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.ACTIVATE_SEI_INSERT + " call " + sessionID);
        var cmd = "ActivateSEIInsertReq";
        var body = {
            peer_id: peerID,
            action: action,
            info_type: infoType
        };
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    }
};


/***/ }),

/***/ "./sdk/src/modules/advance/error.ts":
/*!******************************************!*\
  !*** ./sdk/src/modules/advance/error.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorCodeList = void 0;
exports.errorCodeList = {
    NOT_LOGIN: {
        code: 1000002,
        message: "not login room"
    },
    INPUT_PARAM: {
        code: 1100001,
        message: "input param error."
    },
    PUBLISH_NOT_PUBLISH: {
        code: 1103040,
        message: "publisher not found"
    },
    PUBLISH_NO_PREVIEW: {
        code: 1103044,
        message: "stream is not from zego"
    },
    TRACK_NOT_FOUND: {
        code: 1103047,
        message: "track is not found"
    },
    DEVICE_NOT_FOUND: {
        code: 1103048,
        message: "device is not found"
    },
    PUBLISHER_CONSTRAINTS_ERROR: {
        code: 1103029,
        message: "constraint error"
    },
    PUBLISHER_CDN_PUSH_ERROR: {
        code: 1103052,
        message: "publisher cdn push error"
    },
    VIDEO_DEVICE_FALSE: {
        code: 1103045,
        message: "video is false"
    },
    AUDIO_DEVICE_FALSE: {
        code: 1103046,
        message: "audio is false"
    },
    UNKNOWN_SERVER_ERROR: {
        code: 1100999,
        message: "unknown server error"
    },
    LOCALSTREAM_WRONG: {
        code: 1000018,
        message: "local stream wrong"
    },
    PUBLISHER_STREAM_NO_FOUND: {
        code: 1103055,
        message: "publish stream no found"
    },
    PUBLISH_TARGET_NO_RESPONSE: {
        code: 1103063,
        message: "publish target no response"
    },
    BIZ_CHANNEL_ERROR: {
        code: 1102021,
        message: "biz channel error."
    },
    INVALID_CHANNEL: {
        code: 1102024,
        message: "invalid channel"
    },
    PUBLISHER_EXTRA_INFO_NULL: {
        code: 1003050,
        message: "extra info of publishing stream is null"
    },
    PUBLISHER_UPDATE_STREAM_INFO_FAIL: {
        code: 1103062,
        message: "update stream info fail"
    },
    TRACK_CAN_NOT_ADD: {
        code: 1103063,
        message: "only stream which have one track and kind no exist can add track"
    },
    TRACK_CAN_NOT_REMOVE: {
        code: 1103064,
        message: "stream which only has one track can not remove "
    },
    PUBLISHER_UPDATE_SDP_FAIL: {
        code: 1103068,
        message: "update sdp fail"
    },
    PUBLISHER_STATE_WRONG: {
        code: 1103069,
        message: "publisher state wrong"
    },
    HANDLE_TRACK_NOT_SUPPORTED: {
        code: 1103070,
        message: "not support remove track"
    },
    VIDEO_EFFECT_IS_RUNNING: {
        code: 1103071,
        message: "video effect processor is running"
    }
};


/***/ }),

/***/ "./sdk/src/modules/advance/index.ts":
/*!******************************************!*\
  !*** ./sdk/src/modules/advance/index.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//@ts-nocheck
var advancedModule_1 = __webpack_require__(/*! ./advancedModule */ "./sdk/src/modules/advance/advancedModule.ts");
var content_1 = __webpack_require__(/*! ./content */ "./sdk/src/modules/advance/content.ts");
exports["default"] = {
    type: "Advance",
    install: function (ZegoWebRTC, RTCModules, StreamHandler, Preview, PlayModule, PublishModule, Publisher, Signal) {
        Object.defineProperty(RTCModules.prototype, "initAdvance", {
            value: function () {
                this.advancedModule = new advancedModule_1.AdvancedModule(this.logger, this.dataReport, this.streamCenter, this.stateCenter);
            },
            writable: false
        });
        for (var key in content_1.zegoWebRTC) {
            Object.defineProperty(ZegoWebRTC.prototype, key, {
                value: content_1.zegoWebRTC[key],
                writable: false
            });
        }
        for (var key in content_1.streamHandler) {
            Object.defineProperty(StreamHandler.prototype, key, {
                value: content_1.streamHandler[key],
                writable: false
            });
        }
        for (var key in content_1.preview) {
            Object.defineProperty(Preview.prototype, key, {
                value: content_1.preview[key],
                writable: false
            });
        }
        for (var key in content_1.playModule) {
            Object.defineProperty(PlayModule.prototype, key, {
                value: content_1.playModule[key],
                writable: false
            });
        }
        for (var key in content_1.publishModule) {
            Object.defineProperty(PublishModule.prototype, key, {
                value: content_1.publishModule[key],
                writable: false
            });
        }
        for (var key in content_1.publisher) {
            Object.defineProperty(Publisher.prototype, key, {
                value: content_1.publisher[key],
                writable: false
            });
        }
        for (var key in content_1.signal) {
            Object.defineProperty(Signal.prototype, key, {
                value: content_1.signal[key],
                writable: false
            });
        }
    }
};


/***/ }),

/***/ "./sdk/src/modules/advance/log.event.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/advance/log.event.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoRTCLogEvent = void 0;
var error_1 = __webpack_require__(/*! ./error */ "./sdk/src/modules/advance/error.ts");
var getItem = function (item) { return item; };
exports.ZegoRTCLogEvent = {
    kZegoSetVideoConfig: {
        event: "/sdk/set_video_config",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM,
            kLocalStreamError: error_1.errorCodeList.LOCALSTREAM_WRONG
        }
    },
    kZegoSetAudioConfig: {
        event: "/sdk/set_audio_config",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM
        }
    },
    kZegoReplaceTrack: {
        event: "/sdk/replace_track",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM
        }
    },
    kZegoTaskUseVideoDevice: {
        event: "/device/api/video_c",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM,
            kDevicesNoFoundError: error_1.errorCodeList.DEVICE_NOT_FOUND,
            kLocalStreamError: error_1.errorCodeList.LOCALSTREAM_WRONG
        },
        device: getItem
    },
    kZegoTaskUseAudioDevice: {
        event: "/device/api/audio_c",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM,
            kDevicesNoFoundError: error_1.errorCodeList.DEVICE_NOT_FOUND,
            kLocalStreamError: error_1.errorCodeList.LOCALSTREAM_WRONG
        },
        device: getItem
    },
    kZegoTaskPublishTarget: {
        event: "/sdk/publish_target",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM,
            kPublishStreamNoFoundError: error_1.errorCodeList.PUBLISHER_STREAM_NO_FOUND,
            kNoLoginError: error_1.errorCodeList.NOT_LOGIN,
            kNoResponseError: error_1.errorCodeList.PUBLISH_TARGET_NO_RESPONSE,
            kBizChannelError: error_1.errorCodeList.BIZ_CHANNEL_ERROR,
            kInvalidChannelError: error_1.errorCodeList.INVALID_CHANNEL,
            kUnknownServerError: error_1.errorCodeList.UNKNOWN_SERVER_ERROR
        }
    },
    kZegoTaskAddPublishCdnUrl: {
        event: "/sdk/add_publish_cdn_url",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM
        }
    },
    kZegoTaskRemovePublishCdnUrl: {
        event: "/sdk/remove_publish_cdn_url",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM
        },
        stream: getItem,
        target_url: getItem
    },
    kZegoTaskClearPublishCdnUrl: {
        event: "/sdk/clear_publish_cdn_url",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM
        }
    },
    kZegoPlayContentChanged: {
        event: "/sdk/play_content_changed",
        session_id: getItem,
        video_activate: getItem,
        audio_activate: getItem
    },
    kZegoTaskMutePublishVideo: "/sdk/mute_publish_video",
    kZegoTaskMutePublishAudio: "/sdk/mute_publish_audio",
    kZegoTaskMuteMicrophone: "/sdk/mute_microphone",
    kZegoTaskMutePlayVideo: "/sdk/mute_play_video",
    kZegoTaskMutePlayAudio: "/sdk/mute_play_audio",
    kZegoTaskLiveRoomSendStreamExtraInfo: {
        event: "/liveroom/send_stream_extra_info",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM,
            kExtraInfoNullError: error_1.errorCodeList.PUBLISHER_EXTRA_INFO_NULL,
            kNoLoginError: error_1.errorCodeList.NOT_LOGIN,
            kPublishStreamNoFoundError: error_1.errorCodeList.PUBLISHER_STREAM_NO_FOUND,
            kUpdateStreamInfoFailError: error_1.errorCodeList.PUBLISHER_UPDATE_STREAM_INFO_FAIL
        },
        stream: getItem,
        stream_extra_info: getItem,
        room_sid: getItem
    }
};


/***/ }),

/***/ "./sdk/src/modules/advance/mediaUtil.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/advance/mediaUtil.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MediaUtil = void 0;
var MediaUtil = /** @class */ (function () {
    function MediaUtil(context, _a) {
        var _this = this;
        var type = _a.type, _b = _a.channels, channels = _b === void 0 ? 1 : _b, _c = _a.bufferSize, bufferSize = _c === void 0 ? 0 : _c, _d = _a.sampleBit, sampleBit = _d === void 0 ? 16 : _d, _e = _a.sampleRate, sampleRate = _e === void 0 ? 44100 : _e;
        this.instant = 0.0;
        this.slow = 0.0;
        this.clip = 0.0;
        this.context = context;
        this.type = type;
        this.channels = channels;
        this.bufferSize = bufferSize;
        this.sampleBit = sampleBit;
        this.sampleRate = sampleRate;
        this.script = context.createScriptProcessor(bufferSize, channels, channels);
        var audioprocessTime = new Date().getTime();
        this.script.addEventListener("audioprocess", function (event) {
            var input = event.inputBuffer.getChannelData(0);
            var i;
            var sum = 0.0;
            var clipcount = 0;
            for (i = 0; i < input.length; ++i) {
                sum += input[i] * input[i];
                if (Math.abs(input[i]) > 0.99) {
                    clipcount += 1;
                }
            }
            _this.instant = Math.sqrt(sum / input.length);
            _this.slow = 0.95 * _this.slow + 0.05 * _this.instant;
            _this.clip = clipcount / input.length;
            // 
            if (type === "pcm" || type === "wav") {
                var buffer = [];
                for (var i_1 = 0; i_1 < _this.channels; i_1++) {
                    buffer.push(event.inputBuffer.getChannelData(i_1));
                }
                _this.recorderBuffer(buffer);
            }
        });
        // ,worker
        if (type === "pcm" || type === "wav") {
            this.initRecorderBuffer(type);
        }
    }
    MediaUtil.prototype.connectToSource = function (stream, callback) {
        try {
            this.mic = this.context.createMediaStreamSource(stream);
            this.mic.connect(this.script);
            // necessary to make sample run, but should not be.
            this.script.connect(this.context.destination);
            if (typeof callback !== "undefined") {
                callback(null);
            }
        }
        catch (e) {
            console.error(e);
            if (typeof callback !== "undefined") {
                callback(e);
            }
        }
        return this;
    };
    MediaUtil.prototype.recorderBuffer = function (audioBuffer) {
        this.worker.postMessage({
            command: "record",
            val: audioBuffer
        });
    };
    MediaUtil.prototype.initRecorderBuffer = function (type) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var outSelf = this;
        this.worker = this.inlineWorker(function () {
            var record = [], sampleChannel, sampleBit, sampleRate, oldSampleRate, bufferSize, type;
            function init(option) {
                sampleChannel = option.sampleChannel;
                sampleBit = option.sampleBit;
                sampleRate = option.sampleRate;
                oldSampleRate = option.oldSampleRate;
                bufferSize = option.bufferSize;
                type = option.type;
            }
            function floatTo16BitPCM(output, offset, input) {
                for (var i = 0; i < input.length; i++, offset += 2) {
                    var s = Math.max(-1, Math.min(1, input[i]));
                    output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
                }
            }
            function floatTo8BitPCM(output, offset, input) {
                for (var i = 0; i < input.length; i++, offset++) {
                    //1
                    var s = Math.max(-1, Math.min(1, input[i]));
                    var val = s < 0 ? s * 0x80 : s * 0x7f;
                    val += 128;
                    output.setInt8(offset, val);
                }
            }
            function floatToPCM(samples, _sampleBit) {
                var dataLength;
                if (_sampleBit == 8) {
                    dataLength = samples.length;
                }
                else if (_sampleBit == 16) {
                    //16
                    dataLength = samples.length;
                    dataLength = dataLength * 2;
                }
                var buffer = new ArrayBuffer(dataLength);
                var view = new DataView(buffer);
                if (_sampleBit == 8) {
                    floatTo8BitPCM(view, 0, samples);
                }
                else if (sampleBit == 16) {
                    floatTo16BitPCM(view, 0, samples);
                }
                return view;
            }
            function writeString(view, offset, string) {
                for (var i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }
            function encodeWave(samples, _sampleBit) {
                var dataLength;
                if (_sampleBit == 8) {
                    dataLength = samples.length;
                }
                else if (sampleBit == 16) {
                    //16
                    dataLength = samples.length;
                    dataLength = dataLength * 2;
                }
                var buffer = new ArrayBuffer(dataLength + 44);
                var view = new DataView(buffer);
                var newSamepleRate = sampleRate;
                var newSampleBits = sampleBit;
                var newSampleChannel = sampleChannel;
                writeString(view, 0, "RIFF");
                view.setUint32(4, 36 + dataLength, true);
                writeString(view, 8, "WAVE");
                writeString(view, 12, "fmt ");
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, newSampleChannel, true);
                view.setUint32(24, newSamepleRate, true);
                view.setUint32(28, newSamepleRate * newSampleChannel * (newSampleBits / 8), true);
                view.setUint16(32, newSampleChannel * (newSampleBits / 8), true);
                view.setUint16(34, newSampleBits, true);
                writeString(view, 36, "data");
                view.setUint32(40, dataLength, true);
                if (sampleBit == 8) {
                    floatTo8BitPCM(view, 44, samples);
                }
                else if (sampleBit == 16) {
                    floatTo16BitPCM(view, 44, samples);
                }
                return view;
            }
            //
            function compressHandler(compressRate, data) {
                var result = new Float32Array(data.length / compressRate);
                var index = 0, j = 0;
                while (index < result.length) {
                    result[index] = data[j];
                    j += compressRate;
                    index++;
                }
                return result;
            }
            //buffer
            function getAudioBuffer(data, _bufferSize, _record) {
                var result = new Float32Array(_bufferSize * data.length);
                var offset = 0;
                for (var i = 0; i < _record[0].length; i++) {
                    result.set(_record[0][i], offset);
                    offset += _record[0][i].length;
                    //console.log(offset);
                }
                return result;
            }
            //
            function combineChannels(channelL, channelR) {
                var result = new Float32Array(channelL.length + channelR.length);
                for (var i = 0; i < channelL.length + channelR.length; i += 2) {
                    result[i] = channelL[(i / 2) >> 0];
                    result[i + 1] = channelR[(i / 2) >> 0];
                }
                return result;
            }
            function collectBuffer(compressRate) {
                var collect_record, compress_collect_record;
                if (sampleChannel == 1) {
                    //
                    collect_record = getAudioBuffer(record[0], bufferSize, record);
                    if (compressRate != 1) {
                        //
                        compress_collect_record = compressHandler(compressRate, collect_record);
                    }
                }
                else if (sampleChannel == 2) {
                    //
                    //1,2
                    var collect_record_1 = getAudioBuffer(record[0], bufferSize, record);
                    var collect_record_2 = getAudioBuffer(record[1], bufferSize, record);
                    var compress_collect_record_1 = void 0, compress_collect_record_2 = void 0;
                    if (compressRate != 1) {
                        //12
                        compress_collect_record_1 = compressHandler(compressRate, collect_record_1);
                        compress_collect_record_2 = compressHandler(compressRate, collect_record_2);
                        compress_collect_record = combineChannels(compress_collect_record_1, compress_collect_record_2);
                    }
                    else {
                        collect_record = combineChannels(collect_record_1, collect_record_2);
                    }
                }
                if (compressRate != 1) {
                    //
                    return compress_collect_record;
                }
                else {
                    return collect_record;
                }
            }
            function collectPCM(compressRate) {
                var result = collectBuffer(compressRate);
                var interleaveData = floatToPCM(result, sampleBit);
                // @ts-ignore
                self.postMessage({
                    command: "exportPcmLive",
                    val: interleaveData
                });
            }
            function collectWAV(compressRate) {
                var result = collectBuffer(compressRate);
                var interleaveData = encodeWave(result, sampleBit);
                // @ts-ignore
                self.postMessage({
                    command: "exportWav",
                    val: interleaveData
                });
            }
            function recordData(buffer) {
                for (var i = 0; i < sampleChannel; i++) {
                    if (!record[i]) {
                        record[i] = [];
                    }
                    record[i].push(buffer[i]);
                }
                var compressRate = Math.round(oldSampleRate / sampleRate);
                if (type === "pcm") {
                    collectPCM(compressRate);
                }
                else if (type === "wav") {
                    collectWAV(compressRate);
                }
                record = []; //
            }
            //@ts-ignore
            this.onmessage = function (e) {
                switch (e.data.command) {
                    case "init":
                        init(e.data.val);
                        break;
                    case "record":
                        recordData(e.data.val);
                        break;
                }
            };
        });
        this.worker.postMessage({
            command: "init",
            val: {
                sampleChannel: this.channels,
                sampleBit: this.sampleBit,
                sampleRate: this.sampleRate,
                oldSampleRate: this.context.sampleRate,
                bufferSize: this.bufferSize,
                type: type
            }
        });
        this.worker.onmessage = function (e) {
            switch (e.data.command) {
                case "exportPcmLive":
                    outSelf.onReceiveBuffer(e.data.val);
                    break;
                case "exportWav":
                    outSelf.onReceiveWav(e.data.val);
                    break;
            }
        };
    };
    MediaUtil.prototype.onReceiveBuffer = function (val) { };
    MediaUtil.prototype.onReceiveWav = function (wavBlob) { };
    MediaUtil.prototype.writeString = function (view, offset, string) {
        for (var i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    };
    MediaUtil.prototype.writeBuffer = function (view, offset, buffer) {
        for (var i = 0; i < buffer.byteLength; i++) {
            view.setUint8(offset + i, buffer[i]);
        }
    };
    MediaUtil.prototype.concatenation = function (segments) {
        var sumLength = 0;
        for (var i = 0; i < segments.length; ++i) {
            sumLength += segments[i].buffer.byteLength;
        }
        var whole = new Uint8Array(sumLength);
        var pos = 0;
        for (var i = 0; i < segments.length; ++i) {
            whole.set(new Uint8Array(segments[i].buffer), pos);
            pos += segments[i].buffer.byteLength;
        }
        return whole;
    };
    MediaUtil.prototype.encodeWave = function (samples) {
        var wholeBuffer = this.concatenation(samples);
        var dataLength = wholeBuffer.byteLength;
        var buffer = new ArrayBuffer(dataLength + 44);
        var view = new DataView(buffer);
        var newSamepleRate = this.sampleRate;
        var newSampleBits = this.sampleBit;
        var newSampleChannel = this.channels;
        this.writeString(view, 0, "RIFF");
        view.setUint32(4, 36 + dataLength, true);
        this.writeString(view, 8, "WAVE");
        this.writeString(view, 12, "fmt ");
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, newSampleChannel, true);
        view.setUint32(24, newSamepleRate, true);
        view.setUint32(28, newSamepleRate * newSampleChannel * (newSampleBits / 8), true);
        view.setUint16(32, newSampleChannel * (newSampleBits / 8), true);
        view.setUint16(34, newSampleBits, true);
        this.writeString(view, 36, "data");
        view.setUint32(40, dataLength, true);
        this.writeBuffer(view, 44, wholeBuffer);
        return view;
    };
    MediaUtil.prototype.stop = function () {
        this.mic.disconnect();
        this.script.disconnect();
    };
    MediaUtil.prototype.inlineWorker = function (func) {
        //worker
        if (Worker && func) {
            var functionBody = func
                .toString()
                .trim()
                .match(/^function\s*\w*\s*\([\w\s,]*\)\s*{([\w\W]*?)}$/)[1];
            var url = URL.createObjectURL(new window.Blob([functionBody], {
                type: "text/javascript"
            }));
            return new Worker(url);
        }
        return null;
    };
    return MediaUtil;
}());
exports.MediaUtil = MediaUtil;


/***/ }),

/***/ "./sdk/src/modules/audioMix/action.ts":
/*!********************************************!*\
  !*** ./sdk/src/modules/audioMix/action.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZEGO_WEBRTC_ACTION = void 0;
var ZEGO_WEBRTC_ACTION;
(function (ZEGO_WEBRTC_ACTION) {
    ZEGO_WEBRTC_ACTION["PRELOAD_EFFECT"] = "zc.pe.0";
    ZEGO_WEBRTC_ACTION["PLAY_EFFECT"] = "zc.pe.1";
    ZEGO_WEBRTC_ACTION["PAUSE_EFFECT"] = "zc.pe.2";
    ZEGO_WEBRTC_ACTION["RESUME_EFFECT"] = "zc.re";
    ZEGO_WEBRTC_ACTION["STOP_EFFECT"] = "zc.se";
    ZEGO_WEBRTC_ACTION["UNLOAD_EFFECT"] = "zc.ue";
    ZEGO_WEBRTC_ACTION["SET_EFFECT_VOLUME"] = "zc.sev";
    ZEGO_WEBRTC_ACTION["START_MIXING_AUDIO"] = "zc.sma.0";
    ZEGO_WEBRTC_ACTION["STOP_MIXING_AUDIO"] = "zc.sma.1";
    ZEGO_WEBRTC_ACTION["MIXING_BUFFER"] = "zc.mb";
    ZEGO_WEBRTC_ACTION["STOP_MIXING_BUFFER"] = "zc.smb";
    ZEGO_WEBRTC_ACTION["SET_MIXING_AUDIO_VOLUME"] = "zc.smav";
    ZEGO_WEBRTC_ACTION["PUBLISHER_PLAY_EFFECT"] = "zc.p.0.pe.0";
    ZEGO_WEBRTC_ACTION["PUBLISHER_PAUSE_EFFECT"] = "zc.p.0.pe.1";
    ZEGO_WEBRTC_ACTION["PUBLISHER_RESUME_EFFECT"] = "zc.p.0.re";
    ZEGO_WEBRTC_ACTION["PUBLISHER_STOP_EFFECT"] = "zc.p.0.se";
    ZEGO_WEBRTC_ACTION["PUBLISHER_START_MIXING_AUDIO"] = "zc.p.0.sma.0";
    ZEGO_WEBRTC_ACTION["PUBLISHER_STOP_MIXING_AUDIO"] = "zc.p.0.sma.1";
    ZEGO_WEBRTC_ACTION["PUBLISHER_MIXING_BUFFER"] = "zc.p.0.mb";
    ZEGO_WEBRTC_ACTION["PUBLISHER_SET_MIXING_AUDIO_VOLUME"] = "zc.p.0.smav"; //
})(ZEGO_WEBRTC_ACTION = exports.ZEGO_WEBRTC_ACTION || (exports.ZEGO_WEBRTC_ACTION = {}));


/***/ }),

/***/ "./sdk/src/modules/audioMix/audioMix.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/audioMix/audioMix.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AudioMix = void 0;
var error_1 = __webpack_require__(/*! ./error */ "./sdk/src/modules/audioMix/error.ts");
var AudioMix = /** @class */ (function () {
    function AudioMix(logger, stateCenter, ac, mediaEleSources) {
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.ac = ac;
        this.mediaEleSources = mediaEleSources;
        this.audioBufferList = [];
        this.loop = false;
        this.replace = false;
        this.effectEndedCallBack = null;
        this.effectEndedListener = null;
        this.startTimes = 0;
        this.startOffset = 0;
        this.pauseTimes = 0;
        this.resumeOffset = 0;
        //
        this.paused = false;
        this.isMixAudio = false;
        this.isMixingBuffer = false;
        this.audioCurrentTimer = null;
    }
    //
    AudioMix.prototype.preloadEffect = function (effectUrl, callBack) {
        var _this = this;
        this.logger.info("amu.pe.0 start preload effect");
        var xhr = new XMLHttpRequest();
        xhr.open("GET", effectUrl, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = function () {
            if (xhr.status == 200 || xhr.status == 304) {
                var buffer = xhr.response;
                _this.ac.resume();
                _this.ac.decodeAudioData(buffer, function (ab) {
                    _this.logger.info("amu.pe.0 effect preload success");
                    callBack("", ab);
                }, function (err) {
                    callBack(err);
                });
            }
            else {
                var err = xhr.statusText;
                callBack(err);
            }
        };
        xhr.send();
    };
    AudioMix.prototype.playEffect = function (playTime, loop, replace, start, end) {
        var _this = this;
        if (this.isMixAudio === true) {
            this.logger.error("amu.pe.1 audio is mixing");
            return;
        }
        if (!this.audioBuffer) {
            this.logger.error("amu.pe.1 no audio buffer found");
            return;
        }
        this.startOffset = playTime || 0;
        this.loop = loop || false;
        this.replace = replace || false;
        this.effectEndedCallBack = end;
        this.mixEffect(this.audioBuffer, function () {
            loop ? (_this.buffSource.loop = true) : (_this.buffSource.loop = false);
            playTime
                ? _this.buffSource.start(0, playTime / 1e3)
                : _this.buffSource.start(0);
            _this.startTimes = Date.now();
            _this.effectEndedListener = _this.effectEndedHandler.bind(_this);
            _this.buffSource.addEventListener("ended", _this.effectEndedListener);
            start && start();
        });
    };
    AudioMix.prototype.mixingBuffer = function (ab, callBack) {
        var _this = this;
        if (this.isMixAudio === true &&
            this.audioBufferList.length == 0 &&
            this.isMixingBuffer == false) {
            this.logger.error("amu.mb.0 audio is mixing");
            return;
        }
        this.ac.resume();
        this.ac.decodeAudioData(ab, function (audioBuffer) {
            _this.audioBufferList.push(audioBuffer);
            _this.audioBufferList.length == 1 &&
                _this.playRealTimeEffect(_this.audioBufferList[0]);
            _this.isMixingBuffer = true;
            callBack && callBack();
        }, function (err) {
            _this.logger.error("amu.mb.0 " + err);
            callBack &&
                callBack({
                    code: error_1.errorCodeList.PUBLISHER_DECODE_AUDIO_FAIL.code,
                    message: error_1.errorCodeList.PUBLISHER_DECODE_AUDIO_FAIL.message + " " + err
                });
        });
    };
    AudioMix.prototype.stopMingBuffer = function () {
        this.isMixingBuffer = false;
        return this.stopMixingAudio();
    };
    AudioMix.prototype.playRealTimeEffect = function (ab) {
        var _this = this;
        this.mixEffect(ab, function () {
            _this.buffSource && _this.buffSource.start(0);
            _this.buffSource &&
                _this.buffSource.addEventListener("ended", function () {
                    _this.audioBufferList.shift();
                    _this.audioBufferList.length > 0 &&
                        _this.isMixAudio &&
                        _this.playRealTimeEffect(_this.audioBufferList[0]);
                });
        });
    };
    AudioMix.prototype.pauseEffect = function () {
        if (this.audioBufferList.length > 0) {
            this.logger.error("amu.pe.0 real time buffer can not be paused");
            return;
        }
        this.stopMixingAudio();
        this.resumeOffset =
            (this.pauseTimes - this.startTimes + this.startOffset) %
                (this.audioBuffer.duration * 1e3);
        this.paused = true;
    };
    AudioMix.prototype.resumeEffect = function () {
        if (this.audioBufferList.length > 0) {
            this.logger.error("amu.pe.0 real time buffer can not be resume");
            return;
        }
        this.playEffect(this.resumeOffset, this.loop, this.replace, undefined, this.effectEndedCallBack);
        this.startOffset = this.resumeOffset;
        this.paused = false;
    };
    AudioMix.prototype.mixEffect = function (audioBuffer, callBack) {
        if (!this.localStream) {
            this.logger.error("amu.me.0 localStream can not be found");
            return;
        }
        this.ac.resume();
        this.gainNode = this.ac.createGain();
        this.buffSource = this.ac.createBufferSource();
        this.buffSource.buffer = audioBuffer;
        this.buffSource.connect(this.gainNode);
        this.gainNode.connect(this.ac.destination);
        this.replaceTrack() && callBack();
    };
    //
    AudioMix.prototype.startMixingAudio = function (audio, replace) {
        this.replace = replace || false;
        if (this.isMixAudio) {
            this.logger.error("amu.sma.0 audio is mixing");
            return false;
        }
        if (!this.localStream) {
            this.logger.error("amu.sma.0 localStream can not be found");
            return false;
        }
        audio.captureStream =
            audio.captureStream ||
                audio.mozCaptureStream ||
                audio.webkitCaptureStream;
        //
        this.ac.resume();
        this.gainNode = this.ac.createGain();
        var bro = this.stateCenter.browser;
        if (bro === "safari") {
            var mediaEle = this.mediaEleSources.find(function (item) { return item.audio === audio; });
            if (mediaEle) {
                this.mixAudio = mediaEle.node;
            }
            else {
                var node = this.ac.createMediaElementSource(audio);
                this.mixAudio = node;
                this.mediaEleSources.push({ audio: audio, node: node });
            }
            audio.currentTime = audio.currentTime;
            this.audioCurrentTimer = setInterval(function () {
                audio.currentTime = audio.currentTime + 0.45;
            }, 6000);
        }
        else {
            this.mixAudio = this.ac.createMediaStreamSource(audio.captureStream());
        }
        this.mixAudio.connect(this.gainNode);
        return this.replaceTrack();
    };
    AudioMix.prototype.replaceTrack = function () {
        this.streamSource = this.ac.createMediaStreamSource(this.localStream);
        this.destination = this.ac.createMediaStreamDestination();
        !this.replace && this.streamSource.connect(this.destination);
        this.gainNode.connect(this.destination);
        //
        var audioTrack = this.destination.stream.getAudioTracks()[0];
        var sender = this.peerConnection
            .getSenders()
            .find(function (s) { return s.track.kind === audioTrack.kind; });
        if (!sender) {
            this.logger.error("amu.rt.0 no sender");
            return false;
        }
        this.micTrack = this.localStream.getAudioTracks()[0];
        sender.replaceTrack(audioTrack);
        this.localStream.removeTrack(this.micTrack);
        this.localStream.addTrack(audioTrack);
        this.isMixAudio = true;
        return true;
    };
    AudioMix.prototype.stopMixingAudio = function () {
        var _this = this;
        if (this.paused) {
            this.logger.info("amu.sma.1 audioEffect paused");
            return true;
        }
        if (!this.isMixAudio) {
            this.logger.warn("amu.sma.1 no mixing audio found");
            return true;
        }
        if (!this.localStream) {
            this.logger.error("amu.sma.1 localStream can not be found");
            return false;
        }
        var sender = this.peerConnection
            .getSenders()
            .find(function (s) { return s.track.kind === _this.micTrack.kind; });
        // sender.replaceTrack(this.micTrack);
        // this.localStream.removeTrack(this.localStream.getAudioTracks()[0]);
        // this.localStream.addTrack(this.micTrack!);
        if (this.mixAudio) {
            this.mixAudio.disconnect(this.gainNode);
            this.mixAudio = null;
            if (this.audioCurrentTimer) {
                clearInterval(this.audioCurrentTimer);
                this.audioCurrentTimer = null;
            }
        }
        else if (this.buffSource) {
            this.buffSource.removeEventListener("ended", this.effectEndedListener);
            this.buffSource.stop();
            this.pauseTimes = Date.now();
            this.buffSource.disconnect(this.gainNode);
            this.buffSource = null;
        }
        this.gainNode.disconnect(this.destination);
        //this.micTrack = null;
        this.isMixAudio = false;
        this.audioBufferList = [];
        return true;
    };
    AudioMix.prototype.setMixingAudioVolume = function (volume) {
        if (!this.gainNode) {
            this.logger.error("amu.sma.2 no mixing audio found");
            return false;
        }
        this.gainNode.gain.value = volume;
        return true;
    };
    AudioMix.prototype.effectEndedHandler = function () {
        this.stopMixingAudio();
        this.effectEndedCallBack && this.effectEndedCallBack();
    };
    return AudioMix;
}());
exports.AudioMix = AudioMix;


/***/ }),

/***/ "./sdk/src/modules/audioMix/audioModule.ts":
/*!*************************************************!*\
  !*** ./sdk/src/modules/audioMix/audioModule.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AudioMixModule = void 0;
var action_1 = __webpack_require__(/*! ./action */ "./sdk/src/modules/audioMix/action.ts");
var logevent_1 = __webpack_require__(/*! ./logevent */ "./sdk/src/modules/audioMix/logevent.ts");
var AudioMixModule = /** @class */ (function () {
    function AudioMixModule(logger, dataReport, stateCenter, streamCenter, ac) {
        this.logger = logger;
        this.dataReport = dataReport;
        this.stateCenter = stateCenter;
        this.streamCenter = streamCenter;
        this.ac = ac;
        this.buffer = null;
        this.blank = null;
        if (this.stateCenter.browser == "safari" &&
            this.blank == null &&
            this.buffer == null) {
            this.ac.resume();
            this.buffer = this.ac.createBuffer(1, 1, this.ac.sampleRate);
            this.blank = this.ac.createBufferSource();
            this.blank.buffer = this.buffer;
            this.blank.connect(this.ac.destination);
            this.blank.start();
        }
    }
    //
    AudioMixModule.prototype.preloadEffect = function (id, effectUrl, callBack) {
        if (!id ||
            typeof id !== "string" ||
            !effectUrl ||
            typeof effectUrl !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PRELOAD_EFFECT + " params error");
            return;
        }
        if (this.stateCenter.audioEffectBuffer[id]) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PRELOAD_EFFECT + " audio buffer already exists");
            return;
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PRELOAD_EFFECT + " start preload effect");
        this._preloadEffect(this.ac, id, effectUrl, callBack);
    };
    AudioMixModule.prototype.playEffect = function (audioMixConfig, start, end) {
        if (!audioMixConfig.streamID ||
            typeof audioMixConfig.streamID !== "string" ||
            !audioMixConfig.effectID ||
            typeof audioMixConfig.effectID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAY_EFFECT + " params error");
            return;
        }
        if (!this.stateCenter.audioEffectBuffer[audioMixConfig.effectID]) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAY_EFFECT + " audio buffer doesn't exists");
            return;
        }
        this._playEffect(audioMixConfig, start, end);
    };
    AudioMixModule.prototype.pauseEffect = function (streamID, effectID) {
        if (!streamID || typeof streamID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PAUSE_EFFECT + " streamID format error");
            return false;
        }
        if (effectID && typeof effectID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PAUSE_EFFECT + " effect ");
        }
        return this._pauseEffect(streamID, effectID);
    };
    AudioMixModule.prototype.resumeEffect = function (streamID, effectID) {
        if (!streamID || typeof streamID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.RESUME_EFFECT + " streamID format error");
            return false;
        }
        if (effectID && typeof effectID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.RESUME_EFFECT + " effect ");
        }
        return this._resumeEffect(streamID, effectID);
    };
    AudioMixModule.prototype.stopEffect = function (streamID, effectID) {
        if (!streamID || typeof streamID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.STOP_EFFECT + " streamID format error");
            return false;
        }
        if (effectID && typeof effectID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.STOP_EFFECT + " effect ");
        }
        return this._stopEffect(streamID, effectID);
    };
    AudioMixModule.prototype.unloadEffect = function (effecId) {
        if (!effecId || typeof effecId !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.UNLOAD_EFFECT + " params error");
            return false;
        }
        delete this.stateCenter.audioEffectBuffer[effecId];
        return true;
    };
    AudioMixModule.prototype.setEffectVolume = function (streamID, volume, effectID) {
        if (!streamID || typeof streamID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_EFFECT_VOLUME + " streamID format error");
            return false;
        }
        if (effectID && typeof effectID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_EFFECT_VOLUME + " effect ");
        }
        var publisher = this.streamCenter.getPublisher(streamID);
        if (!publisher) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_EFFECT_VOLUME + " publisher doesn't exist");
            return false;
        }
        return publisher.setEffectVolume(volume / 100, effectID);
    };
    //
    AudioMixModule.prototype.startMixingAudio = function (streamID, audio) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.START_MIXING_AUDIO + " call " + streamID);
        if (!streamID || typeof streamID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_MIXING_AUDIO + " stream id type error");
            return false;
        }
        if (!audio) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_MIXING_AUDIO + " no audio");
            return false;
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.START_MIXING_AUDIO + " end " + streamID);
        if (Array.isArray(audio) && audio.length !== 0) {
            return this._startMixingAudio(streamID, audio);
        }
        else {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_MIXING_AUDIO + " audio param type error");
            return false;
        }
    };
    //
    AudioMixModule.prototype.stopMixingAudio = function (streamID, audio) {
        if (!streamID || typeof streamID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.STOP_MIXING_AUDIO + " param streamID format error");
            return false;
        }
        if ((Array.isArray(audio) && audio.length !== 0) ||
            typeof audio == "undefined") {
            return this._stopMixingAudio(streamID, audio);
        }
        else {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.STOP_MIXING_AUDIO + " audio param type error");
            return false;
        }
    };
    AudioMixModule.prototype.mixingBuffer = function (streamID, sourceID, arrayBuffer, callBack) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MIXING_BUFFER +
            " call streamID: " +
            streamID +
            " sourceID:" +
            sourceID);
        if (!streamID || typeof streamID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.MIXING_BUFFER + " param streamid format error");
            return;
        }
        if (!sourceID || typeof sourceID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.MIXING_BUFFER + " param source id format error");
            return;
        }
        this._mixingBuffer(streamID, sourceID, arrayBuffer, callBack);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.MIXING_BUFFER + " end");
    };
    AudioMixModule.prototype.stopMixingBuffer = function (streamID, sourceID) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STOP_MIXING_BUFFER +
            " call streamID: " +
            streamID +
            " sourceID:" +
            sourceID);
        if (!streamID || typeof streamID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.STOP_MIXING_BUFFER + " param streamid format error");
            return false;
        }
        if (!sourceID || typeof sourceID !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.STOP_MIXING_BUFFER + " param source id format error");
            return false;
        }
        return this._stopMixingBuffer(streamID, sourceID);
    };
    AudioMixModule.prototype.setMixingAudioVolume = function (streamID, volume, audio) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SET_MIXING_AUDIO_VOLUME + " call");
        if (typeof streamID !== "string" || streamID == "") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_MIXING_AUDIO_VOLUME +
                " stream ID must be string and not empty");
            return false;
        }
        if (typeof volume !== "number" || volume < 0 || volume > 100) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_MIXING_AUDIO_VOLUME +
                " volume must be a number between 0 and 100");
            return false;
        }
        if (!audio || !(audio instanceof HTMLMediaElement)) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_MIXING_AUDIO_VOLUME + " no audio");
            return false;
        }
        return this._setMixingAudioVolume(streamID, volume, audio);
    };
    AudioMixModule.prototype.getSoundLevel = function (localStream, sucCallBack, errCallBack) {
        this.logger.info("zc.gsl call");
        var reportSeq = this.stateCenter.getReportSeq();
        this.dataReport.newReport(reportSeq, logevent_1.ZegoRTCLogEvent.kZegoTaskGetSoundLevel.event);
        try {
            this.ac.resume();
            var mic = this.ac.createMediaStreamSource(localStream);
            var script = this.ac.createScriptProcessor(4096, 1, 1); //4096
            this.stateCenter.audioStreamList[localStream.id] = { mic: mic, script: script };
            mic.connect(script); //
            script.connect(this.ac.destination);
            script.onaudioprocess = function (e) {
                //
                var buffer = e.inputBuffer.getChannelData(0); //PCM32
                //
                var maxVal = 0;
                for (var i = 0; i < buffer.length; i++) {
                    if (maxVal < buffer[i]) {
                        maxVal = buffer[i];
                    }
                }
                sucCallBack(maxVal);
            };
            this.dataReport.uploadReport(reportSeq);
        }
        catch (err) {
            errCallBack(err);
            this.dataReport.addMsgInfo(reportSeq, logevent_1.ZegoRTCLogEvent.kZegoTaskGetSoundLevel.error.kGetSoundLevelError);
            this.dataReport.uploadReport(reportSeq);
        }
        this.logger.info("zc.gsl call success");
    };
    AudioMixModule.prototype.stopSoundLevel = function (localStream) {
        this.logger.info("zc.ssl call");
        var reportSeq = this.stateCenter.getReportSeq();
        this.dataReport.newReport(reportSeq, logevent_1.ZegoRTCLogEvent.kZegoTaskStopSoundLevel);
        var ctx = this.stateCenter.audioStreamList[localStream.id];
        ctx.mic.disconnect();
        ctx.script.disconnect();
        delete this.stateCenter.audioStreamList[localStream.id];
        this.dataReport.uploadReport(reportSeq);
    };
    AudioMixModule.prototype._preloadEffect = function (ac, id, effectUrl, callBack) {
        var _this = this;
        var xhr = new XMLHttpRequest();
        xhr.open("GET", effectUrl, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = function () {
            if (xhr.status == 200 || xhr.status == 304) {
                var buffer = xhr.response;
                ac.decodeAudioData(buffer, function (ab) {
                    _this.logger.info("zc.pe.0 effect preload success");
                    _this.stateCenter.audioEffectBuffer[id] = ab;
                    callBack && callBack();
                }, function (err) {
                    _this.logger.error("zc.pe.0 effect preload fail " + err);
                    callBack && callBack(err);
                });
            }
            else {
                var err = xhr.statusText;
                _this.logger.error("zc.pe.0 effect preload fail " + err);
                callBack && callBack(err);
            }
        };
        xhr.send();
    };
    AudioMixModule.prototype._playEffect = function (audioMixConfig, start, end) {
        var audioBuffer = this.stateCenter.audioEffectBuffer[audioMixConfig.effectID];
        var publisher = this.streamCenter.getPublisher(audioMixConfig.streamID);
        if (!publisher) {
            this.logger.error("zc.pe.1 publisher doesn't exist");
            return;
        }
        if (audioBuffer) {
            publisher.playEffect(audioMixConfig, audioBuffer, start, end);
        }
        else {
            this.logger.error("zc.pe.1 no audio buffer found");
        }
    };
    AudioMixModule.prototype._pauseEffect = function (streamID, effectID) {
        var publisher = this.streamCenter.getPublisher(streamID);
        if (!publisher) {
            this.logger.error("zc.pe.2 publisher doesn't exist");
            return false;
        }
        return publisher.pauseEffect(effectID);
    };
    AudioMixModule.prototype._resumeEffect = function (streamID, effectID) {
        var publisher = this.streamCenter.getPublisher(streamID);
        if (!publisher) {
            this.logger.error("zc.re.0 publisher doesn't exist");
            return false;
        }
        return publisher.resumeEffect(effectID);
    };
    AudioMixModule.prototype._stopEffect = function (streamID, effectID) {
        var publisher = this.streamCenter.getPublisher(streamID);
        if (!publisher) {
            this.logger.error("zc.re.0 publisher doesn't exist");
            return false;
        }
        return publisher.stopEffect(effectID);
    };
    AudioMixModule.prototype._setMixingAudioVolume = function (streamID, volume, audio) {
        var publisher = this.streamCenter.getPublisher(streamID);
        if (!publisher) {
            this.logger.error("zc.sma.2 publisher doesn't exist");
            return false;
        }
        // return true;
        //todo
        return publisher.setMixingAudioVolume(volume / 100, audio);
    };
    AudioMixModule.prototype._startMixingAudio = function (streamID, mediaList) {
        var publisher = this.streamCenter.getPublisher(streamID);
        if (!publisher) {
            this.logger.error("zc.sma.0 publisher doesn't exist");
            return false;
        }
        return publisher.startMixingAudio(mediaList);
    };
    AudioMixModule.prototype._stopMixingAudio = function (streamID, audio) {
        var publisher = this.streamCenter.getPublisher(streamID);
        if (!publisher) {
            this.logger.error("zc.sma.1 publisher doesn't exist");
            return false;
        }
        return publisher.stopMixingAudio(audio);
    };
    AudioMixModule.prototype._mixingBuffer = function (streamID, sourceID, arrayBuffer, callBack) {
        var publisher = this.streamCenter.getPublisher(streamID);
        if (!publisher) {
            this.logger.error("zc.mb.0 publisher doesn't exist");
            return;
        }
        if (arrayBuffer instanceof ArrayBuffer) {
            publisher.mixingBuffer(sourceID, arrayBuffer, callBack);
        }
        else {
            this.logger.error("zc.mb.0 array buffer not found");
            return;
        }
    };
    AudioMixModule.prototype._stopMixingBuffer = function (streamID, sourceID) {
        var publisher = this.streamCenter.getPublisher(streamID);
        if (!publisher) {
            this.logger.error("zc.sma.1 publisher doesn't exist");
            return false;
        }
        return publisher.stopMixingBuffer(sourceID);
    };
    return AudioMixModule;
}());
exports.AudioMixModule = AudioMixModule;


/***/ }),

/***/ "./sdk/src/modules/audioMix/content.ts":
/*!*********************************************!*\
  !*** ./sdk/src/modules/audioMix/content.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.publisher = void 0;
//@ts-nocheck
var action_1 = __webpack_require__(/*! ./action */ "./sdk/src/modules/audioMix/action.ts");
var audioMix_1 = __webpack_require__(/*! ./audioMix */ "./sdk/src/modules/audioMix/audioMix.ts");
//publisher
exports.publisher = {
    playEffect: function (AudioMixConfig, audioBuffer, start, end) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_PLAY_EFFECT + "" + this.streamId + " call");
        if (this.effectList.find(function (effect) {
            return effect.effectID == AudioMixConfig.effectID &&
                effect.audioBuffer == audioBuffer;
        })) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_PLAY_EFFECT +
                "" +
                this.streamId +
                " effect alreadly exist ");
            return;
        }
        else {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            var audioMix = new audioMix_1.AudioMix(this.logger, this.stateCenter, this.ac, this.mediaEleSources);
            audioMix.localStream = this.localStream;
            audioMix.peerConnection = this.peerConnection;
            audioMix.audioBuffer = audioBuffer;
            this.effectList.push({
                audioMix: audioMix,
                effectID: AudioMixConfig.effectID,
                audioBuffer: audioBuffer
            });
            audioMix.playEffect(AudioMixConfig.playTime, AudioMixConfig.loop, false, start, end);
            this.streamCenter.soundLevelDelegate && this.startSoundLevel();
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_PLAY_EFFECT +
                "" +
                this.streamId +
                " play effect " +
                AudioMixConfig.effectID +
                " success");
        }
    },
    pauseEffect: function (effectID) {
        var effect = this.effectList.find(function (effect) { return effect.effectID == effectID; });
        if (effect) {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            effect.audioMix.pauseEffect();
            this.streamCenter.soundLevelDelegate && this.startSoundLevel();
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_PAUSE_EFFECT +
                " " +
                this.streamId +
                " pause " +
                effectID +
                " success");
        }
        else if (typeof effectID == "undefined") {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            this.effectList.forEach(function (effect) { return effect.audioMix.pauseEffect(); });
            this.streamCenter.soundLevelDelegate && this.startSoundLevel();
        }
        else {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_PAUSE_EFFECT +
                " " +
                this.streamId +
                " no effect ID found");
            return false;
        }
        return true;
    },
    resumeEffect: function (effectID) {
        var effect = this.effectList.find(function (effect) { return effect.effectID == effectID; });
        if (effect) {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            effect.audioMix.resumeEffect();
            this.streamCenter.soundLevelDelegate && this.startSoundLevel();
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_RESUME_EFFECT +
                " " +
                this.streamId +
                " resume" +
                effectID +
                " success");
        }
        else if (typeof effectID == "undefined") {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            this.effectList.forEach(function (effect) { return effect.audioMix.resumeEffect(); });
            this.streamCenter.soundLevelDelegate && this.startSoundLevel();
        }
        else {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_RESUME_EFFECT +
                " " +
                this.streamId +
                " no effect ID found");
            return false;
        }
        return false;
    },
    stopEffect: function (effectID) {
        var effect = this.effectList.find(function (effect) { return effect.effectID == effectID; });
        if (effect) {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            effect.audioMix.stopMixingAudio();
            this.effectList.splice(this.effectList.indexOf(effect), 1);
            this.streamCenter.soundLevelDelegate && this.startSoundLevel();
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_STOP_EFFECT +
                " " +
                this.streamId +
                " pause " +
                effectID +
                " success");
        }
        else if (typeof effectID == "undefined") {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            this.effectList.forEach(function (effect) { return effect.audioMix.stopMixingAudio(); });
            this.effectList = [];
            this.streamCenter.soundLevelDelegate && this.startSoundLevel();
        }
        else {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_STOP_EFFECT +
                " " +
                this.streamId +
                " no effect ID found");
            return false;
        }
        // this.rebackMic();
        return true;
    },
    setEffectVolume: function (volume, effectID) {
        var effect = this.effectList.find(function (effect) { return effect.effectID == effectID; });
        if (effect) {
            effect.audioMix.setMixingAudioVolume(volume);
            this.logger.info("zp.sev.0 " + this.streamId + " set volume " + effectID + " success");
        }
        else if (typeof effectID == "undefined") {
            this.effectList.forEach(function (effect) {
                return effect.audioMix.setMixingAudioVolume(volume);
            });
        }
        else {
            this.logger.error("zp.sev.0 " + this.streamId + " no effect ID found");
            return false;
        }
        return true;
    },
    startMixingAudio: function (mediaList) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_MIXING_AUDIO +
            " " +
            this.streamId +
            " call");
        if (!this.localStream) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_MIXING_AUDIO +
                " localStream not found");
            return false;
        }
        if (!this.micTrack)
            this.micTrack =
                this.localStream.getAudioTracks().length > 0
                    ? this.localStream.getAudioTracks()[0]
                    : null;
        mediaList.forEach(function (media) {
            if (_this.audioMixList.find(function (i) { return i.media == media; })) {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_MIXING_AUDIO +
                    " " +
                    _this.streamId +
                    " mix audio already exist");
            }
            else {
                _this.streamCenter.soundLevelDelegate && _this.stopSoundLevel();
                var audioMix = new audioMix_1.AudioMix(_this.logger, _this.stateCenter, _this.ac, _this.mediaEleSources);
                audioMix.localStream = _this.localStream;
                audioMix.peerConnection = _this.peerConnection;
                _this.audioMixList.push({
                    audioMix: audioMix,
                    media: media
                });
                audioMix.startMixingAudio(media);
                _this.streamCenter.soundLevelDelegate && _this.startSoundLevel();
            }
        });
        return true;
    },
    stopMixingAudio: function (media) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_STOP_MIXING_AUDIO +
            " " +
            this.streamId +
            " call");
        if (media) {
            media.forEach(function (media) {
                for (var i = 0; i < _this.audioMixList.length; i++) {
                    if (_this.audioMixList[i].media == media) {
                        _this.audioMixList[i].audioMix.stopMixingAudio() &&
                            _this.audioMixList.splice(i--, 1);
                        break;
                    }
                }
            });
        }
        else {
            this.audioMixList.forEach(function (i) { return i.audioMix.stopMixingAudio(); });
            this.audioMixList = [];
        }
        // this.rebackMic();
        return true;
    },
    mixingBuffer: function (sourceID, arrayBuffer, callBack) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_MIXING_BUFFER + " " + this.streamId + " call");
        if (!this.micTrack)
            this.micTrack =
                this.localStream.getAudioTracks().length > 0
                    ? this.localStream.getAudioTracks()[0]
                    : null;
        if (this.arrayBufferMap[sourceID]) {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            this.arrayBufferMap[sourceID].mixingBuffer(arrayBuffer, function () {
                _this.streamCenter.soundLevelDelegate && _this.startSoundLevel();
                callBack && callBack();
            });
        }
        else {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            var audioMix = new audioMix_1.AudioMix(this.logger, this.stateCenter, this.ac, this.mediaEleSources);
            audioMix.localStream = this.localStream;
            audioMix.peerConnection = this.peerConnection;
            this.arrayBufferMap[sourceID] = audioMix;
            audioMix.mixingBuffer(arrayBuffer, function () {
                _this.streamCenter.soundLevelDelegate && _this.startSoundLevel();
                callBack && callBack();
            });
        }
    },
    stopMixingBuffer: function (sourceID) {
        if (sourceID && this.arrayBufferMap[sourceID]) {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            this.arrayBufferMap[sourceID].stopMingBuffer();
            delete this.arrayBufferMap[sourceID];
            this.streamCenter.soundLevelDelegate && this.startSoundLevel();
            return true;
        }
        else if (typeof sourceID == "undefined") {
            this.streamCenter.soundLevelDelegate && this.stopSoundLevel();
            for (var i in this.arrayBufferMap) {
                this.arrayBufferMap[i].stopMingBuffer();
            }
            this.streamCenter.soundLevelDelegate && this.startSoundLevel();
            return true;
        }
        else {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_MIXING_BUFFER +
                " " +
                this.streamId +
                " arrayBuffer no found");
            return false;
        }
        // this.rebackMic();
    },
    setMixingAudioVolume: function (volume, audio) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SET_MIXING_AUDIO_VOLUME +
            " " +
            this.streamId +
            " call");
        var audioMixItem = this.audioMixList.find(function (item) { return item.media === audio; });
        if (audioMixItem) {
            audioMixItem.audioMix.setMixingAudioVolume(volume);
        }
        else {
            // todo
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SET_MIXING_AUDIO_VOLUME +
                " " +
                this.streamId +
                " audio is not mixing");
            return false;
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SET_MIXING_AUDIO_VOLUME +
            " " +
            this.streamId +
            " call success");
        return true;
    }
};


/***/ }),

/***/ "./sdk/src/modules/audioMix/error.ts":
/*!*******************************************!*\
  !*** ./sdk/src/modules/audioMix/error.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorCodeList = void 0;
exports.errorCodeList = {
    GET_SOUND_LEVEL_FAIL: {
        code: 1000019,
        message: "get sound level error"
    },
    PUBLISHER_DECODE_AUDIO_FAIL: {
        code: 1103057,
        message: "decode audio data fail"
    }
};


/***/ }),

/***/ "./sdk/src/modules/audioMix/index.ts":
/*!*******************************************!*\
  !*** ./sdk/src/modules/audioMix/index.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//@ts-nocheck
var audioModule_1 = __webpack_require__(/*! ./audioModule */ "./sdk/src/modules/audioMix/audioModule.ts");
var content_1 = __webpack_require__(/*! ./content */ "./sdk/src/modules/audioMix/content.ts");
exports["default"] = {
    type: "AudioMix",
    install: function (RTCModules, ZegoPublish) {
        Object.defineProperty(RTCModules.prototype, "initAudioMix", {
            value: function () {
                this.audioMixModule = new audioModule_1.AudioMixModule(this.logger, this.dataReport, this.stateCenter, this.streamCenter, this.ac);
            }
        });
        for (var key in content_1.publisher) {
            Object.defineProperty(ZegoPublish.prototype, key, {
                value: content_1.publisher[key],
                writable: false
            });
        }
    }
};


/***/ }),

/***/ "./sdk/src/modules/audioMix/logevent.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/audioMix/logevent.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoRTCLogEvent = void 0;
var error_1 = __webpack_require__(/*! ./error */ "./sdk/src/modules/audioMix/error.ts");
exports.ZegoRTCLogEvent = {
    kZegoTaskGetSoundLevel: {
        event: "/sdk/get_sound_level",
        error: {
            kGetSoundLevelError: error_1.errorCodeList.GET_SOUND_LEVEL_FAIL
        }
    },
    kZegoTaskStopSoundLevel: "/sdk/stop_sound_level"
};


/***/ }),

/***/ "./sdk/src/modules/datachannel/index.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/datachannel/index.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataChannel = void 0;
var ZegoExpressDataChannel_web_1 = __webpack_require__(/*! ../../../code/zh/ZegoExpressDataChannel.web */ "./sdk/code/zh/ZegoExpressDataChannel.web.ts");
exports.DataChannel = {
    type: "DataChannel",
    install: function (ZegoWebRTC) {
        Object.defineProperty(ZegoWebRTC.prototype, "createRealTimeSequentialDataManager", {
            value: function (roomID) {
                this.enableDataChannel(true);
                var room = this.stateCenter.getRoomByRoomID(roomID);
                if (!room) {
                    this.logger.error("zc.crsdm room no exist");
                    return null;
                }
                if (!room.dataChannelManager) {
                    room.dataChannelManager = new ZegoExpressDataChannel_web_1.ZegoRealTimeSequentialDataManager(this, roomID);
                    return room.dataChannelManager;
                }
                else {
                    return null;
                }
            },
            writable: false
        });
        Object.defineProperty(ZegoWebRTC.prototype, "destroyRealTimeSequentialDataManager", {
            value: function (manager) {
                var room = this.stateCenter.roomList.find(function (room) { return room.dataChannelManager == manager; });
                if (room) {
                    //@ts-ignore
                    manager.dataChannelManager.reset();
                    room.dataChannelManager = null;
                }
            },
            writable: false
        });
    }
};


/***/ }),

/***/ "./sdk/src/modules/datachannel/manager.ts":
/*!************************************************!*\
  !*** ./sdk/src/modules/datachannel/manager.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataChannelListener = void 0;
var CHUNK_MTU = 1151; //1191 - 40 max size of single message slice
var MSG_HEADER_SIZE = 10; //1 + 1 + 2 + 2 + 4
var END_OF_MSG = 0x1;
var TYPE_USER_DATA = 1;
var DataChannelListener = /** @class */ (function () {
    function DataChannelListener(zegoWebRTC, roomID) {
        this.zegoWebRTC = zegoWebRTC;
        this.roomID = roomID;
        this.pubDataChannelList = [];
        this.subDataChannelList = [];
        this.listenerList = {
            receiveRealTimeSequentialData: []
        };
        this.logger = zegoWebRTC.logger;
    }
    // 
    //  startPublishingStream  main publish channel
    //  -  Broadcast
    //  - 
    // ID streamID 
    DataChannelListener.prototype.startBroadcasting = function (streamID, config) {
        return __awaiter(this, void 0, void 0, function () {
            var publish, can, _a, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.logger.info("dc.sb.0 call");
                        if (this.pubDataChannelList.includes(streamID)) {
                            this.logger.error("dc.sb.0 datachannel already exist");
                            return [2 /*return*/, false];
                        }
                        publish = this.zegoWebRTC.streamCenter.publisherList[streamID];
                        if (publish && publish.publisher.dataChannel) {
                            this.pubDataChannelList.push(streamID);
                            return [2 /*return*/, true];
                        }
                        else if (publish && !publish.publisher.dataChannel) {
                            this.logger.error("dc.sb.0 publish datachannel no exist, try other stream ID");
                            return [2 /*return*/, false];
                        }
                        if (!!this.broadcastStream) return [3 /*break*/, 2];
                        can = document.createElement("canvas");
                        _a = this;
                        return [4 /*yield*/, this.zegoWebRTC.createStream({
                                custom: {
                                    //@ts-ignore
                                    source: can
                                }
                            })];
                    case 1:
                        _a.broadcastStream = _b.sent();
                        _b.label = 2;
                    case 2:
                        result = this.zegoWebRTC.startPublishingStream(streamID, this.broadcastStream, { roomID: this.roomID }, true);
                        if (result)
                            this.pubDataChannelList.push(streamID);
                        this.logger.info("dc.sb.0 end");
                        return [2 /*return*/, result];
                }
            });
        });
    };
    //  main publish channel
    DataChannelListener.prototype.stopBroadcasting = function (streamID) {
        this.logger.info("dc.sb.1 call");
        this.pubDataChannelList = this.pubDataChannelList.filter(function (val) { return val !== streamID; });
        //
        var publish = this.zegoWebRTC.streamCenter.publisherList[streamID];
        if (!publish) {
            this.logger.error("dc.sb.1 datachannel no found");
            return false;
        }
        if (publish.room.roomID == this.roomID && publish.isDataChannel) {
            this.zegoWebRTC.stopPublishingStream(streamID);
        }
        this.logger.info("dc.sb.1 end");
        return true;
    };
    // 
    // 
    DataChannelListener.prototype.sendRealTimeSequentialData = function (streamID, data) {
        //@ts-ignore
        if (!data instanceof ArrayBuffer) {
            this.logger.error("dc.srsd data type wrong");
            return false;
        }
        var publisher = this.zegoWebRTC.streamCenter.publisherList[streamID];
        if (!publisher || !this.pubDataChannelList.includes(streamID)) {
            this.logger.error("dc.srsd datachannel no found");
            return false;
        }
        return this.sendBCMessage(publisher.publisher, data);
    };
    DataChannelListener.prototype.sendBCMessage = function (publisher, message) {
        var _a;
        if (!publisher.dataChannelState) {
            //this.logger.error("zp.sbcm.0 data channel state wrong");
            return false;
        }
        var uint8_payload = new Uint8Array(message);
        //Message fragment for the limit of mtu
        var off_set = 0;
        var left = message.byteLength;
        var sn0 = publisher.send_seq;
        var flag = 0;
        var ts = new Date().getTime();
        var msg_frag_len = 0;
        while (left > 0) {
            if (left > CHUNK_MTU) {
                msg_frag_len = CHUNK_MTU - MSG_HEADER_SIZE;
            }
            else {
                msg_frag_len = left;
                flag = END_OF_MSG;
            }
            var send_chunk = new Uint8Array(msg_frag_len + MSG_HEADER_SIZE);
            //type
            send_chunk[0] = TYPE_USER_DATA;
            //flag
            send_chunk[1] = flag;
            //sn
            send_chunk[2] = (publisher.send_seq >> 8) & 0xff;
            send_chunk[3] = publisher.send_seq & 0xff;
            //sn0
            send_chunk[4] = (sn0 >> 8) & 0xff;
            send_chunk[5] = sn0 & 0xff;
            //ts
            send_chunk[6] = (ts >> 24) & 0xff;
            send_chunk[7] = (ts >> 16) & 0xff;
            send_chunk[8] = (ts >> 8) & 0xff;
            send_chunk[9] = ts & 0xff;
            //coopy data
            for (var i = 0; i < msg_frag_len; i++) {
                send_chunk[i + MSG_HEADER_SIZE] = uint8_payload[i + off_set];
            }
            left -= msg_frag_len;
            off_set += msg_frag_len;
            publisher.send_seq++;
            if (publisher.send_seq >= 65536) {
                publisher.send_seq = 0;
            }
            (_a = publisher.dataChannel) === null || _a === void 0 ? void 0 : _a.send(send_chunk);
        }
        return true;
    };
    //   ID startPlayingStream
    //  Subscribe 
    DataChannelListener.prototype.startSubscribing = function (streamID, config) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var play, player;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        this.logger.info("dc.ss.0 call");
                        if (this.subDataChannelList.includes(streamID)) {
                            this.logger.error("dc.ss.0 datachannel already exist");
                            return [2 /*return*/, false];
                        }
                        play = this.zegoWebRTC.streamCenter.playerList[streamID];
                        if (!!play) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.zegoWebRTC.startPlayingStream(streamID, undefined, true)];
                    case 1:
                        _c.sent();
                        play = this.zegoWebRTC.streamCenter.playerList[streamID];
                        _c.label = 2;
                    case 2:
                        player = play.player;
                        if (!player.dataChannel) {
                            this.logger.error("dc.ss.0 datachannel no exist, try other stream ID");
                            return [2 /*return*/, false];
                        }
                        !((_a = player.onDataChannelList) === null || _a === void 0 ? void 0 : _a.includes(this.onReceivedDataChannel.bind(this))) && ((_b = player.onDataChannelList) === null || _b === void 0 ? void 0 : _b.push(this.onReceivedDataChannel.bind(this)));
                        this.subDataChannelList.push(streamID);
                        this.logger.info("dc.ss.0 end");
                        return [2 /*return*/, true];
                }
            });
        });
    };
    //  config 
    // 
    DataChannelListener.prototype.stopSubscribing = function (streamID) {
        this.logger.info("dc.ss.1 call");
        this.subDataChannelList = this.subDataChannelList.filter(function (val) { return val !== streamID; });
        //
        var play = this.zegoWebRTC.streamCenter.playerList[streamID];
        if (!play) {
            this.logger.error("dc.ss.1 datachannel no subscribe");
            return false;
        }
        if (play.room.roomID == this.roomID && play.isDataChannel) {
            this.zegoWebRTC.stopPlayingStream(streamID);
        }
        this.logger.info("dc.ss.1 end");
        return true;
    };
    /**
     * 
     *
     * Note: 2.10.0 
     *
     * Note:  SDK  event  ZegoRangeAudioEvent 
     *
     * Note: 
     *
     * Note:  createRangeAudioInstance  loginRoom 
     *
     * Note: , 
     *
     * Note:  off 
     *
     * @param event 
     * @param callBack 
     *
     * @return 
     */
    DataChannelListener.prototype.on = function (event, callBack) {
        this.bindListener(event, callBack);
    };
    /**
     * 
     *
     * Note: 2.10.0 
     *
     * Note:  SDK  event 
     *
     * Note: 
     *
     * Note:  createRangeAudioInstance 
     *
     * Note: 
     *
     * @param event 
     * @param callBack 
     *
     * @return 
     */
    DataChannelListener.prototype.off = function (event, callBack) {
        this.deleteListener(event, callBack);
    };
    DataChannelListener.prototype.bindListener = function (listener, callBack) {
        if (!this.listenerList[listener]) {
            this.logger.error("dc.o.0 event " + listener + " no found");
            return false;
        }
        if (typeof callBack !== "function") {
            this.logger.error("zc.o.0 listener callBack must be funciton");
            return false;
        }
        this.listenerList[listener].indexOf(callBack) == -1 &&
            this.listenerList[listener].push(callBack);
        return true;
    };
    DataChannelListener.prototype.deleteListener = function (listener, callBack) {
        if (!this.listenerList[listener]) {
            this.logger.error("dc.o.1 listener no found");
            return false;
        }
        var li = this.listenerList[listener];
        if (callBack) {
            li.splice(li.indexOf(callBack), 1);
        }
        else {
            this.listenerList[listener] = [];
        }
        return true;
    };
    DataChannelListener.prototype.actionListener = function (listener) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.listenerList[listener] &&
            this.listenerList[listener].forEach(function (func) {
                try {
                    setTimeout(function () {
                        func.apply(void 0, args);
                    }, 0);
                }
                catch (error) {
                    _this.logger.error("dc.al" + " " + listener + " " + error);
                }
            });
    };
    DataChannelListener.prototype.onReceivedDataChannel = function (copy_buffer, copy_len, streamID) {
        this.actionListener("receiveRealTimeSequentialData", copy_buffer, copy_len, streamID);
    };
    DataChannelListener.prototype.reset = function () {
        var _this = this;
        this.logger.info("dc.rs " + "call");
        //
        this.pubDataChannelList.forEach(function (streamID) {
            var publish = _this.zegoWebRTC.streamCenter.publisherList[streamID];
            if (publish &&
                publish.room.roomID == _this.roomID &&
                publish.isDataChannel) {
                _this.zegoWebRTC.stopPublishingStream(streamID);
            }
        });
        //
        this.subDataChannelList.forEach(function (streamID) {
            var play = _this.zegoWebRTC.streamCenter.playerList[streamID];
            if (play && play.room.roomID == _this.roomID && play.isDataChannel) {
                _this.zegoWebRTC.stopPlayingStream(streamID);
            }
        });
        for (var key in this.listenerList) {
            this.listenerList[key] = [];
        }
        this.broadcastStream && this.zegoWebRTC.destroyStream(this.broadcastStream);
        this.broadcastStream = undefined;
        this.logger.info("dc.rs " + "end");
    };
    return DataChannelListener;
}());
exports.DataChannelListener = DataChannelListener;


/***/ }),

/***/ "./sdk/src/modules/mixstream/content.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/mixstream/content.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// @ts-nocheck
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.streamHandler = exports.zegoWebRTC = void 0;
var error_1 = __webpack_require__(/*! ./error */ "./sdk/src/modules/mixstream/error.ts");
var logevent_1 = __webpack_require__(/*! ./logevent */ "./sdk/src/modules/mixstream/logevent.ts");
var PROTO_VERSION = "2.13.0";
var MAX_MIX_TASK_ID_LENGTH = 256;
var MIXSTREAM_ERROR_CODE = 10000;
var mixStreamAdvance = {};
var REPORT_ACTION = {
    eventStart: "eventStart",
    eventEndWithMsgInfo: "eventEndWithMsgInfo",
    addEventMsg: "addEventMsg",
    addEvent: "addEvent",
    eventEnd: "eventEnd",
    addMsgInfo: "addMsgInfo"
};
var MIXER_INPUT_PARAMETERS_ERROR = {
    code: 1005027,
    message: "mix stream input parameters are wrong"
};
//ClientUtil
function mixServerError(code) {
    // const mixServerErrorList: any = {
    //   82000001: "kMixStreamFailError",
    //   82000002: "kMixStreamInputError",
    //   82000003: "kMixStreamAuthError",
    //   82000150: "kMixStreamNotExistError",
    //   82000151: "kMixStreamStartMixError",
    //   82000152: "kMixStreamStopMixError",
    //   82000155: "kMixStreamInputFormatError",
    //   82000156: "kMixStreamOutputFormatError",
    //   82000157: "kMixStreamNotOpenError",
    //   82000158: "kMixStreamInputExceedError",
    //   82000159: "kMixStreamDispatchError",
    //   82000160: "kMixStreamStopMixOwnerError",
    //   82000170: "kMixStreamWaterMarkParamError",
    //   82000171: "kMixStreamWaterMarkImageError",
    //   82000190: "kMixStreamQpsOverloadError"
    // };
    var mixServerErrorMap = {
        1: "MIXER_START_REQUEST_ERROR",
        2: "MIXER_START_REQUEST_ERROR",
        3: "MIXER_AUTHENTICATION_FAILED",
        // 4: "MIXER_PARSE_PARAMS_ERROR",
        // 5: "MIXER_START_ACQUIRE_LOCK_ERROR",
        // 6: "MIXER_STOP_ACQUIRE_LOCK_ERROR",
        // 7: "MIXER_START_REQUEST_ERROR",
        // 8: "MIXER_START_CREATE_EOS_FAILED",
        // 9: "MIXER_START_SEND_EOS_FAILED",
        // 10: "MIXER_START_CALLBACK_ERROR",
        // 11: "MIXER_START_BYPASS_ERROR",
        // 12: "MIXER_CLOSE_OWNER_OTHER_STREAM_ERROR",
        // 13: "MIXER_UPDATE_OWNER_ERROR",
        // 14: "MIXER_",
        // 15: "MIXER_",
        // 16: "MIXER_",
        // 17: "MIXER_",
        150: "MIXER_INPUT_STREAM_NOT_EXISTS",
        151: "MIXER_START_REQUEST_ERROR",
        152: "MIXER_STOP_REQUEST_ERROR",
        153: "MIXER_INPUT_PARAMETERS_ERROR",
        154: "MIXER_EXCEED_MAX_OUTPUT_COUNT",
        155: "MIXER_INPUT_PARAMETERS_ERROR",
        156: "MIXER_VIDEO_CONFIG_INVALID",
        157: "MIXER_NO_SERVICES",
        158: "MIXER_EXCEED_MAX_INPUT_COUNT",
        159: "MIXER_START_REQUEST_ERROR",
        160: "MIXER_NOT_OWNER_STOPMIXER",
        170: "MIXER_WATERMARK_PARAMETERS_ERROR",
        171: "MIXER_WATERMARK_NULL",
        175: "MIXER_REPEAT_INPUT",
        190: "MIXER_START_REQUEST_ERROR"
    };
    var res = "MIXER_INNER_ERROR";
    if (code > 1000000000) {
        // const errcode = code - 1000000000 + 82000000;
        // if (mixServerErrorList[errcode]) {
        //   res[0] = mixServerErrorList[errcode];
        // } else {
        //   res[0] = "";
        // }
        if (mixServerErrorMap[code - 1000000000]) {
            res = mixServerErrorMap[code - 1000000000];
        }
    }
    return res;
}
function getMixMapError(stateCenter, err) {
    var reportErr;
    var externalErr = "";
    var codeMap = error_1.errorCodeList;
    if (err.errorCode < 2000000000 && err.errorCode > 1000000000) {
        // @ts-ignore
        // reportErr = errorList[errName];
        externalErr = mixServerError(err.errorCode - MIXSTREAM_ERROR_CODE);
        reportErr = codeMap[externalErr];
    }
    else if (err.errorCode < 1000000) {
        reportErr = stateCenter.decodeServerError(err.errorCode, err.extendedData);
        externalErr = stateCenter.getLiveRoomError(err.errorCode);
    }
    var actualError = codeMap[externalErr];
    return { reportErr: reportErr, actualError: actualError };
}
//ZegoWebRTC
exports.zegoWebRTC = {
    startMixerTask: function (mixStreamConfig) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var reportSeq = _this.stateCenter.getReportSeq();
            _this.dataReport.newReport(reportSeq, logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.event);
            _this.stateCenter.logReportCallback("kZegoTaskMixStart" + mixStreamConfig.taskID, _this.dataReport, reportSeq, _this.stateCenter.reportList);
            // 
            var paramsError = {
                errorCode: MIXER_INPUT_PARAMETERS_ERROR.code,
                extendedData: MIXER_INPUT_PARAMETERS_ERROR.message
            };
            var hasError = !!(mixStreamConfig === null || mixStreamConfig === void 0 ? void 0 : mixStreamConfig.inputList.find(function (item) {
                if (item.streamID === undefined || item.streamID === null) {
                    paramsError.extendedData =
                        paramsError.extendedData + ". streamID should be of string type";
                    return true;
                }
                return false;
            }));
            if (hasError) {
                _this.dataReport.addMsgInfo(reportSeq, paramsError);
                _this.dataReport.uploadReport(reportSeq);
                _this.stateCenter.unregisterCallback("kZegoTaskMixStart" + mixStreamConfig.taskID, _this.stateCenter.reportList);
                reject(paramsError);
                return;
            }
            if (mixStreamConfig.outputConfig &&
                mixStreamConfig.outputConfig.outputFps) {
                mixStreamConfig.outputConfig.outputFPS =
                    mixStreamConfig.outputConfig.outputFps;
            }
            var interResolve = function (res) {
                _this.dataReport.uploadReport(reportSeq);
                _this.stateCenter.unregisterCallback("kZegoTaskMixStart" + mixStreamConfig.taskID, _this.stateCenter.reportList);
                resolve(res);
            };
            var interReject = function (err) {
                var _a = getMixMapError(_this.stateCenter, err), reportErr = _a.reportErr, actualError = _a.actualError;
                if (reportErr) {
                    _this.dataReport.addMsgInfo(reportSeq, reportErr);
                }
                else {
                    _this.dataReport.addMsgInfo(reportSeq, err);
                }
                _this.dataReport.uploadReport(reportSeq);
                _this.stateCenter.unregisterCallback("kZegoTaskMixStart" + mixStreamConfig.taskID, _this.stateCenter.reportList);
                if (actualError) {
                    err.errorCode = actualError === null || actualError === void 0 ? void 0 : actualError.code;
                    err.extendedData = (actualError === null || actualError === void 0 ? void 0 : actualError.message) || "";
                }
                reject(err);
            };
            var room = _this.stateCenter.roomList[0];
            if (!room) {
                interReject({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kNoLoginError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kNoLoginError.message
                });
                return;
            }
            room.streamHandler.updateMixStream(mixStreamConfig, interResolve, interReject);
        });
    },
    setMixerTaskConfig: function (config) {
        var _this = this;
        return new Promise(function (res, rej) {
            var reportSeq = _this.stateCenter.getReportSeq();
            _this.dataReport.newReport(reportSeq, logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.event);
            _this.stateCenter.logReportCallback("kZegoTaskMixConfig", _this.dataReport, reportSeq, _this.stateCenter.reportList);
            var room = _this.stateCenter.roomList[0];
            if (!room) {
                rej({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error.kNoLoginError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error.kNoLoginError.message
                });
                return;
            }
            room.streamHandler
                .setMixerTaskConfig(config)
                .then(function (result) {
                _this.dataReport.uploadReport(reportSeq);
                _this.stateCenter.unregisterCallback("kZegoTaskMixConfig", _this.stateCenter.reportList);
                res(result);
            })
                .catch(function (err) {
                _this.dataReport.addMsgInfo(reportSeq, err);
                _this.dataReport.uploadReport(reportSeq);
                _this.stateCenter.unregisterCallback("kZegoTaskMixConfig", _this.stateCenter.reportList);
                rej(err);
            });
        });
    },
    stopMixerTask: function (taskId) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var reportSeq = _this.stateCenter.getReportSeq();
            _this.dataReport.newReport(reportSeq, logevent_1.ZegoRTCLogEvent.kZegoTaskMixStop.event);
            if (!taskId ||
                typeof taskId !== "string" ||
                taskId.length > MAX_MIX_TASK_ID_LENGTH ||
                !_this.stateCenter.checkIllegalCharacters(taskId)) {
                _this.logger.error("zb.rh.lg taskID must be string less 256");
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStop.error.kParamError.code,
                    message: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStop.error.kParamError.message +
                        " param taskID error"
                });
                _this.dataReport.uploadReport(reportSeq);
                reject({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStop.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStop.error.kParamError.message +
                        " param taskID error"
                });
                return;
            }
            var interResolve = function (res) {
                _this.dataReport.uploadReport(reportSeq);
                resolve(res);
            };
            var interReject = function (err) {
                var _a = getMixMapError(_this.stateCenter, err), reportErr = _a.reportErr, actualError = _a.actualError;
                if (reportErr) {
                    _this.dataReport.addMsgInfo(reportSeq, reportErr);
                }
                else {
                    _this.dataReport.addMsgInfo(reportSeq, err);
                }
                _this.dataReport.uploadReport(reportSeq);
                if (actualError) {
                    err.errorCode = actualError === null || actualError === void 0 ? void 0 : actualError.code;
                    err.extendedData = (actualError === null || actualError === void 0 ? void 0 : actualError.message) || "";
                }
                reject(err);
            };
            var room = _this.stateCenter.roomList[0];
            if (!room) {
                interReject({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStop.error.kNoLoginError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStop.error.kNoLoginError.message
                });
                return;
            }
            room.streamHandler.stopMixStream(taskId, interResolve, interReject);
        });
    }
};
//streamHandler
exports.streamHandler = {
    setMixerTaskConfig: function (advance) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var _a;
            var _mixStreamAdvance = {};
            var config = {};
            // if (
            //     advance &&
            //     advance.userData &&
            //     typeof advance.userData == 'string' &&
            //     (advance.userData as string).length <= 10000
            // ) {
            //     mixStreamAdvance.userData = advance.userData;
            // }
            if (advance && advance.videoCodec) {
                var videoc = advance.videoCodec.toLowerCase();
                if (["vp8", "h264"].indexOf(videoc) == -1) {
                    _this.logger.error("zb.sh.ums param videoCode error");
                    reject({
                        errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error
                            .kVideoConfigInvalidError.code,
                        extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error
                            .kVideoConfigInvalidError.message
                    });
                    return false;
                }
                //@ts-ignore
                _mixStreamAdvance.videoCodec = videoc;
                config["video_codec"] = videoc;
                // mixStreamAdvance.extraParams = [{ key: 'video_encode', value: advance.videoCodec }];
            }
            if (advance.backgroundColor) {
                // mixOutput["output_bg_color"] = mixStreamConfig.outputBgColor;
                if (!_this.stateCenter.checkInteger(advance.backgroundColor)) {
                    _this.logger.error("zb.sh.ums param backgroundColor must be integer number");
                    reject({
                        errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error.kParamError.code,
                        extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error.kParamError.message
                    });
                    return false;
                }
                _mixStreamAdvance.backgroundColor = advance.backgroundColor;
                config["background_color"] = advance.backgroundColor;
            }
            if (advance.backgroundImage) {
                // mixOutput["output_bg_image"] = mixStreamConfig.outputBgImage;
                if (typeof advance.backgroundImage !== "string") {
                    _this.logger.error("zb.sh.ums param outputBgImage error");
                    reject({
                        errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error.kParamError.code,
                        extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error.kParamError.message
                    });
                    return false;
                }
                if (!(advance.backgroundImage.startsWith("preset-id://") &&
                    (advance.backgroundImage.endsWith(".jpg") ||
                        advance.backgroundImage.endsWith(".png")))) {
                    _this.logger.error("zb.sh.ums illegal input background image URL");
                    reject({
                        errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error
                            .kBackgroundImageUrlInvalidError.code,
                        extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.error
                            .kBackgroundImageUrlInvalidError.message
                    });
                    return false;
                }
                _mixStreamAdvance.backgroundImage = advance.backgroundImage;
                config["background_image"] = advance.backgroundImage;
            }
            if (advance.waterMark) {
                _mixStreamAdvance.waterMark = advance.waterMark;
                config["water_mark"] = advance.waterMark;
            }
            if (advance.extraParams) {
                if (!_mixStreamAdvance.extraParams)
                    _mixStreamAdvance.extraParams = [];
                (_a = _mixStreamAdvance.extraParams).push.apply(_a, advance.extraParams);
            }
            _mixStreamAdvance = mixStreamAdvance;
            _this.stateCenter.actionSuccessCallback("kZegoTaskMixConfig", _this.stateCenter.reportList) &&
                _this.stateCenter.actionSuccessCallback("kZegoTaskMixConfig", _this.stateCenter.reportList)(REPORT_ACTION.addMsgInfo, undefined, {
                    config: logevent_1.ZegoRTCLogEvent.kZegoTaskMixConfig.config(config)
                });
            resolve({ errorCode: 0, extendedData: "" });
        });
    },
    stopMixStream: function (taskid, successCallback, errorCallback, outputStreamId, outputUrl) {
        var _this = this;
        this.logger.info("zb.sh.sms call");
        // if (!taskid || typeof taskid !== 'string') {
        //     this.logger.error('zb.sh.sms taskid error');
        //     return false;
        // }
        var req_body = {
            id_name: this.stateCenter.idName,
            live_channel: this.roomID,
            appid: this.stateCenter.appid,
            version: PROTO_VERSION
        };
        if (typeof taskid === "string") {
            req_body["task_id"] = taskid;
        }
        if (outputStreamId != undefined) {
            if (this.stateCenter.testEnvironment) {
                req_body["stream_id"] =
                    "zegotest-" + this.stateCenter.appid + "-" + outputStreamId;
            }
            else {
                req_body["stream_id"] = outputStreamId;
            }
        }
        else if (outputUrl != undefined) {
            req_body["mixurl"] = outputUrl;
        }
        var useNetAgent = this.stateCenter.useNetAgent;
        if (!useNetAgent) {
            var body = {
                channel: "zeus",
                cmd: "stop_mix",
                req_body: JSON.stringify(req_body)
            };
            this.sendBizChannelRequest(body, function () {
                if (successCallback) {
                    successCallback({ errorCode: 0, extendedData: "" });
                }
            }, function (error) {
                if (typeof error == "number") {
                    if (errorCallback) {
                        errorCallback({
                            errorCode: _this.stateCenter.getServerError(MIXSTREAM_ERROR_CODE + error).code,
                            extendedData: ""
                        });
                    }
                }
                else {
                    _this.logger.error("zb.sh.sms stop mix fail " + JSON.stringify(error));
                    var _err = void 0;
                    if (error == error_1.errorCodeList.TIMEOUT) {
                        _err = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStop.error.kRequestError;
                    }
                    else {
                        _err = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStop.error.kInternalError;
                    }
                    if (errorCallback) {
                        errorCallback({
                            errorCode: _err.code,
                            extendedData: _err.message
                        });
                    }
                }
            });
        }
        else {
            this.sendBizChannelRequestV2({
                server: 12,
                location: "/interface/command",
                cmd: "stop_mix"
            }, req_body, function (rspBody) {
                if (successCallback) {
                    successCallback({ errorCode: 0, extendedData: "" });
                }
            }, function (httpCode, bizError, rspBody, errorCode) {
                var message = "";
                // SDK
                if (errorCode) {
                    if (errorCode == error_1.errorCodeList.TIMEOUT) {
                        errorCode = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kRequestError;
                    }
                    errorCallback && errorCallback(errorCode, message);
                    return;
                }
                else {
                    errorCode = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kInternalError;
                }
                if (httpCode === 200) {
                    if (typeof bizError == "number") {
                        _this.logger.debug("zb.sh.sms error: " + bizError);
                        bizError = bizError + 1000000000; // 
                        if (errorCallback) {
                            errorCallback({
                                errorCode: _this.stateCenter.getServerError(MIXSTREAM_ERROR_CODE + bizError).code,
                                extendedData: message
                            });
                        }
                        return;
                    }
                    else {
                        _this.logger.error("zb.sh.sms stop mix fail " + JSON.stringify(error));
                        var _err = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kInternalError;
                        if (errorCallback) {
                            errorCallback({
                                errorCode: _err.code,
                                extendedData: _err.message
                            });
                        }
                    }
                }
                else {
                    message = "request mix server fail, error: " + httpCode;
                    _this.logger.error("zb.sh.sms " + message);
                    errorCallback && errorCallback(errorCode, message);
                }
            });
        }
        return true;
    },
    updateMixStream: function (mixStreamConfig, successCallback, errorCallback) {
        var _a;
        var _this = this;
        this.logger.info("zb.sh.ums call");
        /***
         * 
         */
        var allAudio = false;
        {
            if (!mixStreamConfig.noTaskID && !mixStreamConfig.taskID) {
                this.logger.error("zb.sh.ums no taskId found");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kTaskIDNullError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kTaskIDNullError.message
                });
                return false;
            }
            if (!mixStreamConfig.noTaskID &&
                typeof mixStreamConfig.taskID !== "string") {
                this.logger.error("zb.rh.lg taskId must be string");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.message
                });
                return false;
            }
            if (!mixStreamConfig.noTaskID &&
                mixStreamConfig.taskID.length > MAX_MIX_TASK_ID_LENGTH) {
                this.logger.error("zb.sh.ums taskId is too long");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kTaskIDToLongError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kTaskIDToLongError.message
                });
                return false;
            }
            if (!mixStreamConfig.noTaskID &&
                !this.stateCenter.checkIllegalCharacters(mixStreamConfig.taskID)) {
                this.logger.error("zb.sh.ums task ID contains illegal characters");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kTaskIDInvalidCharacterError
                        .code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kTaskIDInvalidCharacterError
                        .message
                });
                return false;
            }
            if (!mixStreamConfig.inputList || mixStreamConfig.inputList.length == 0) {
                this.logger.error("zb.sh.ums input list wrong");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kInputListNullError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kInputListNullError.message
                });
                return false;
            }
            // 
            mixStreamConfig.inputList.forEach(function (streamInfo) {
                if (streamInfo.contentType === "AUDIO") {
                    !streamInfo.layout &&
                        (streamInfo.layout = { top: 0, left: 0, bottom: 0, right: 0 });
                    streamInfo.layout.top = 0;
                    streamInfo.layout.left = 0;
                    streamInfo.layout.bottom = 1;
                    streamInfo.layout.right = 1;
                }
            });
            for (var i = 0; i < mixStreamConfig.inputList.length; i++) {
                var inputInfo = mixStreamConfig.inputList[i];
                var paramError = {
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.message
                };
                if (typeof inputInfo.layout !== "object") {
                    this.logger.error("zb.sh.ums input layout must be object");
                    errorCallback(paramError);
                    return false;
                }
                if (!this.stateCenter.checkInteger(inputInfo.layout.top, false) ||
                    !this.stateCenter.checkInteger(inputInfo.layout.bottom, false) ||
                    !this.stateCenter.checkInteger(inputInfo.layout.left, false) ||
                    !this.stateCenter.checkInteger(inputInfo.layout.right, false)) {
                    this.logger.error("zb.sh.ums topleftbottomright must be integer number");
                    errorCallback(paramError);
                    return false;
                }
                // 
                if (inputInfo.renderMode !== undefined &&
                    ![0, 1].includes(inputInfo.renderMode)) {
                    this.logger.error("zb.sh.ums render_mode is wrong");
                    errorCallback(paramError);
                    return false;
                }
            }
            if (!mixStreamConfig.outputList ||
                mixStreamConfig.outputList.length == 0) {
                this.logger.error("zb.sh.ums no output list found");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kOutputListNullError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kOutputListNullError.message
                });
                return false;
            }
            if (mixStreamConfig.outputList.some(function (output) {
                return (typeof output === "string" &&
                    !_this.stateCenter.isUrl(output) &&
                    !_this.stateCenter.checkIllegalCharacters(output)) ||
                    (typeof output === "object" &&
                        output.target &&
                        !_this.stateCenter.isUrl(output.target) &&
                        !_this.stateCenter.checkIllegalCharacters(output.target));
            })) {
                this.logger.error("zb.sh.ums stream output target is incorrect");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kOutputTargetInvalidError
                        .code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kOutputTargetInvalidError
                        .message
                });
                return false;
            }
            allAudio = mixStreamConfig.inputList.every(function (input) { return input.contentType === "AUDIO"; });
            if (!allAudio &&
                (!mixStreamConfig.outputConfig ||
                    typeof mixStreamConfig.outputConfig !== "object")) {
                this.logger.error("zb.sh.ums no output config found");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kOutputNoTargetError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kOutputNoTargetError.message
                });
                return false;
            }
            if (allAudio) {
                // output
                mixStreamConfig.outputConfig = __assign(__assign({}, (mixStreamConfig.outputConfig || {})), { outputBitrate: 0.001, outputFPS: 1, outputWidth: 1, outputHeight: 1 });
            }
            if (!allAudio &&
                (!mixStreamConfig.outputConfig.outputBitrate ||
                    !this.stateCenter.checkInteger(mixStreamConfig.outputConfig.outputBitrate))) {
                this.logger.error("zb.sh.ums bitrate param is required and must be integer number");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.message
                });
                return false;
            }
            if (!mixStreamConfig.outputConfig.outputFPS ||
                !this.stateCenter.checkInteger(mixStreamConfig.outputConfig.outputFPS)) {
                this.logger.error("zb.sh.ums fps param is required and must be integer number");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.message
                });
                return false;
            }
            if (!mixStreamConfig.outputConfig.outputWidth ||
                !this.stateCenter.checkInteger(mixStreamConfig.outputConfig.outputWidth)) {
                this.logger.error("zb.sh.ums width param is required and must be integer number");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.message
                });
                return false;
            }
            if (!mixStreamConfig.outputConfig.outputHeight ||
                !this.stateCenter.checkInteger(mixStreamConfig.outputConfig.outputHeight)) {
                this.logger.error("zb.sh.ums height param is required and must be integer number");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.message
                });
                return false;
            }
            if (mixStreamConfig.outputConfig.outputAudioCodecID !== undefined &&
                !this.stateCenter.checkInteger(mixStreamConfig.outputConfig.outputAudioCodecID, false)) {
                this.logger.error("zb.sh.ums AudioCodecID param must be integer number");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.message
                });
                return false;
            }
            if (mixStreamConfig.outputConfig.outputAudioBitrate !== undefined &&
                !this.stateCenter.checkInteger(mixStreamConfig.outputConfig.outputAudioBitrate)) {
                this.logger.error("zb.sh.ums AudioBitrate param must be integer number");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.message
                });
                return false;
            }
            if (mixStreamConfig.outputConfig.outputAudioChannels !== undefined &&
                !this.stateCenter.checkInteger(mixStreamConfig.outputConfig.outputAudioChannels, false)) {
                this.logger.error("zb.sh.ums AudioChannels param must be integer number");
                errorCallback({
                    errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.code,
                    extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kParamError.message
                });
                return false;
            }
        }
        /***
         * 
         */
        var req_body = {};
        {
            var _bypass = 0;
            if (
            // @ts-ignore 
            mixStreamConfig.outputConfig.singleStreamPassThrough &&
                // @ts-ignore
                typeof mixStreamConfig.outputConfig.singleStreamPassThrough ===
                    "boolean") {
                // @ts-ignore
                _bypass = mixStreamConfig.outputConfig.singleStreamPassThrough ? 1 : 0;
            }
            req_body = {
                task_id: mixStreamConfig.taskID,
                id_name: this.stateCenter.idName,
                live_channel: this.roomID,
                appid: this.stateCenter.appid,
                version: PROTO_VERSION,
                bypass: _bypass,
                timestamp: Math.ceil(new Date().getTime() / 1000)
            };
            //  signaturetimestampseqis_cmd_mix
            // @ts-ignore
            var _advance_1 = mixStreamAdvance;
            if (_advance_1) {
                // if (_advance.userData) {
                //     req_body['UserData'] = _advance.userData;
                // }
                if (_advance_1.videoCodec) {
                    req_body["extra_params"] = [
                        { key: "video_encode", value: _advance_1.videoCodec }
                    ];
                }
                if (_advance_1.backgroundColor) {
                    req_body["output_bg_color"] = _advance_1.backgroundColor;
                }
                if (_advance_1.backgroundImage) {
                    req_body["output_bg_image"] = _advance_1.backgroundImage;
                }
                if (_advance_1.waterMark) {
                    req_body["watermark"] = _advance_1.waterMark;
                }
                if (_advance_1.extraParams) {
                    !req_body["extra_params"] && (req_body["extra_params"] = []);
                    (_a = req_body["extra_params"]).push.apply(_a, _advance_1.extraParams);
                }
            }
            // 
            req_body["MixInput"] = mixStreamConfig.inputList.map(function (item, index) {
                var totalStreamId = item.streamID;
                if (_this.stateCenter.testEnvironment) {
                    totalStreamId =
                        "zegotest-" + _this.stateCenter.appid + "-" + item.streamID;
                }
                return {
                    stream_id: totalStreamId,
                    content_control: item.contentType === "AUDIO" ? 1 : 0,
                    rect: {
                        layer: index,
                        top: item.layout.top,
                        left: item.layout.left,
                        bottom: item.layout.bottom,
                        right: item.layout.right
                    },
                    render_mode: item.renderMode
                };
            });
            this.stateCenter.actionSuccessCallback("kZegoTaskMixStart" + mixStreamConfig.taskID, this.stateCenter.reportList) &&
                this.stateCenter.actionSuccessCallback("kZegoTaskMixStart" + mixStreamConfig.taskID, this.stateCenter.reportList)(REPORT_ACTION.addMsgInfo, undefined, {
                    mix_stream_id: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.mix_stream_id(mixStreamConfig.taskID),
                    stream_cnt: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.stream_cnt(req_body["MixInput"].length),
                    input_stream_list: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.input_stream_list(req_body["MixInput"])
                });
            // 
            req_body["MixOutput"] = mixStreamConfig.outputList.map(function (item) {
                var outputStreamInfo = {};
                var _target = "";
                if (typeof item === "string") {
                    _target = item;
                }
                else if (typeof item === "object" && item["target"]) {
                    _target = item.target;
                }
                else {
                    _this.logger.error("zb.sh.ums output target required");
                    errorCallback({
                        errorCode: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kOutputTargetInvalidError
                            .code,
                        extendedData: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kOutputTargetInvalidError
                            .message
                    });
                    return false;
                }
                if (_target.startsWith("rtmp://") ||
                    (_target.startsWith("https://") && _target.endsWith(".flv")) ||
                    (_target.startsWith("https://") && _target.endsWith(".m3u8"))) {
                    outputStreamInfo["mixurl"] = _target;
                }
                else {
                    if (_this.stateCenter.testEnvironment) {
                        outputStreamInfo["stream_id"] =
                            "zegotest-" + _this.stateCenter.appid + "-" + _target;
                    }
                    else {
                        outputStreamInfo["stream_id"] = _target;
                    }
                }
                outputStreamInfo["bitrate"] =
                    mixStreamConfig.outputConfig.outputBitrate * 1000;
                outputStreamInfo["fps"] = mixStreamConfig.outputConfig.outputFPS;
                outputStreamInfo["width"] = mixStreamConfig.outputConfig.outputWidth;
                outputStreamInfo["height"] = mixStreamConfig.outputConfig.outputHeight;
                if (mixStreamConfig.outputConfig.outputAudioCodecID) {
                    outputStreamInfo["audio_enc_id"] =
                        mixStreamConfig.outputConfig.outputAudioCodecID;
                }
                if (_advance_1.videoCodec === "vp8") {
                    outputStreamInfo["audio_enc_id"] = 3;
                }
                else if (_advance_1.videoCodec === "h264") {
                    outputStreamInfo["audio_enc_id"] = 0;
                }
                if (mixStreamConfig.outputConfig.outputAudioBitrate) {
                    outputStreamInfo["audio_bitrate"] =
                        mixStreamConfig.outputConfig.outputAudioBitrate * 1000;
                }
                if (mixStreamConfig.outputConfig.outputAudioChannels) {
                    outputStreamInfo["audio_channel_cnt"] =
                        mixStreamConfig.outputConfig.outputAudioChannels;
                }
                if (_this.stateCenter.testEnvironment) {
                    outputStreamInfo["testenv"] = 1;
                }
                else {
                    outputStreamInfo["testenv"] = 0;
                }
                return outputStreamInfo;
            });
            this.stateCenter.actionSuccessCallback("kZegoTaskMixStart" + mixStreamConfig.taskID, this.stateCenter.reportList) &&
                this.stateCenter.actionSuccessCallback("kZegoTaskMixStart" + mixStreamConfig.taskID, this.stateCenter.reportList)(REPORT_ACTION.addMsgInfo, undefined, {
                    output_target_list: logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.output_target_list(req_body["MixOutput"])
                });
        }
        this.logger.debug("zb.sh.ums send command");
        var useNetAgent = this.stateCenter.useNetAgent;
        var prefix = "zegotest-" + this.stateCenter.appid + "-";
        if (!useNetAgent) {
            var body = {
                channel: "zeus",
                cmd: "start_mix",
                req_body: JSON.stringify(req_body)
            };
            this.sendBizChannelRequest(body, function (seq, cmd, rspBody) {
                _this.logger.debug("zb.sh.ums receive message");
                if (rspBody.length == 0) {
                    if (errorCallback) {
                        errorCallback({
                            errorCode: _this.stateCenter.getServerError(MIXSTREAM_ERROR_CODE + 1).code,
                            extendedData: ""
                        });
                    }
                    return;
                }
                var data = JSON.parse(rspBody);
                var mixPlayInfoList = [];
                for (var i = 0; i < data.play.length; i++) {
                    var mixPlayInfo = {
                        rtmpURL: "",
                        hlsURL: "",
                        flvURL: ""
                    };
                    var streamID = data.play[i].stream_alias || "";
                    if (_this.stateCenter.testEnvironment &&
                        streamID &&
                        streamID.startsWith(prefix)) {
                        streamID = streamID.slice(prefix.length);
                    }
                    mixPlayInfo["streamID"] = streamID;
                    if (data.play[i].rtmp_url && data.play[i].rtmp_url.length > 0) {
                        mixPlayInfo.rtmpURL = data.play[i].rtmp_url;
                    }
                    if (data.play[i].hls_url && data.play[i].hls_url.length > 0) {
                        mixPlayInfo["hlsURL"] = data.play[i].hls_url;
                    }
                    if (data.play[i].hdl_url && data.play[i].hdl_url.length > 0) {
                        mixPlayInfo["flvURL"] = data.play[i].hdl_url;
                    }
                    mixPlayInfoList.push(mixPlayInfo);
                }
                if (successCallback) {
                    var mixs = { mixerOutputList: mixPlayInfoList };
                    successCallback({
                        errorCode: 0,
                        extendedData: JSON.stringify(mixs)
                    });
                    // successCallback({ errorCode: 0 ,extendedData: ''})
                }
            }, function (error, seq, rspBody) {
                if (typeof error == "number") {
                    _this.logger.debug("zb.sh.ums error: " + error);
                    var nonExistsStreamId = [];
                    if (error == 1000000150 && rspBody.length != 0) {
                        //no stream list
                        var data = JSON.parse(rspBody);
                        for (var i = 0; i < data.non_exist_streams.length; i++) {
                            var totalStreamId = data.non_exist_streams[i];
                            if (_this.stateCenter.testEnvironment &&
                                totalStreamId.startsWith(prefix)) {
                                nonExistsStreamId.push(totalStreamId.slice(prefix.length));
                            }
                            else {
                                nonExistsStreamId.push(totalStreamId);
                            }
                        }
                    }
                    if (errorCallback) {
                        errorCallback({
                            errorCode: _this.stateCenter.getServerError(MIXSTREAM_ERROR_CODE + error).code,
                            extendedData: ""
                        });
                    }
                }
                else {
                    _this.logger.debug("zb.sh.ums error code " + error.code);
                    var _err = void 0;
                    if (error == error_1.errorCodeList.TIMEOUT) {
                        _err = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kRequestError;
                    }
                    else {
                        _err = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kInternalError;
                    }
                    if (errorCallback) {
                        errorCallback({
                            errorCode: _err.code,
                            extendedData: _err.message
                        });
                    }
                }
            });
        }
        else {
            this.sendBizChannelRequestV2({
                server: 12,
                location: "/interface/command",
                cmd: "start_mix"
            }, req_body, function (rspBody) {
                var data = rspBody;
                var mixPlayInfoList = data.play.map(function (item) {
                    var mixPlayInfo = {
                        rtmpURL: "",
                        hlsURL: "",
                        flvURL: ""
                    };
                    var streamID = item.stream_alias || "";
                    if (_this.stateCenter.testEnvironment &&
                        streamID &&
                        streamID.startsWith(prefix)) {
                        streamID = streamID.slice(prefix.length);
                    }
                    mixPlayInfo["streamID"] = streamID;
                    if (item.rtmp_url && item.rtmp_url.length > 0) {
                        mixPlayInfo.rtmpURL = item.rtmp_url;
                    }
                    if (item.hls_url && item.hls_url.length > 0) {
                        mixPlayInfo["hlsURL"] = item.hls_url;
                    }
                    if (item.hdl_url && item.hdl_url.length > 0) {
                        mixPlayInfo["flvURL"] = item.hdl_url;
                    }
                    return mixPlayInfo;
                });
                if (successCallback) {
                    var mixs = { mixerOutputList: mixPlayInfoList };
                    successCallback({
                        errorCode: 0,
                        extendedData: JSON.stringify(mixs)
                    });
                }
            }, function (httpCode, bizError, rspBody, errorCode) {
                var message = "";
                // SDK
                if (errorCode) {
                    if (errorCode == error_1.errorCodeList.TIMEOUT) {
                        errorCode = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kRequestError;
                    }
                    errorCallback && errorCallback(errorCode, message);
                }
                else {
                    errorCode = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kInternalError;
                }
                if (httpCode === 200) {
                    if (typeof bizError == "number") {
                        _this.logger.debug("zb.sh.ums error: " + bizError);
                        bizError = bizError + 1000000000; // 
                        if (bizError == 1000000150 && rspBody) {
                            var data = rspBody;
                            var nonExistsStreamId = (data === null || data === void 0 ? void 0 : data.non_exist_streams.map(function (item) {
                                if (_this.stateCenter.testEnvironment &&
                                    item.startsWith(prefix)) {
                                    return item.slice(prefix.length);
                                }
                                else {
                                    return item;
                                }
                            })) || [];
                            nonExistsStreamId.length > 0 &&
                                (_this.logger.debug("zb.sh.ums not exist streams: " + nonExistsStreamId),
                                    (message = nonExistsStreamId.join(",")));
                        }
                        if (errorCallback) {
                            errorCallback({
                                errorCode: _this.stateCenter.getServerError(MIXSTREAM_ERROR_CODE + bizError).code,
                                extendedData: message
                            });
                        }
                        return;
                    }
                    else {
                        _this.logger.debug("zb.sh.ums error code " + bizError);
                        var _err = logevent_1.ZegoRTCLogEvent.kZegoTaskMixStart.error.kInternalError;
                        if (errorCallback) {
                            errorCallback({
                                errorCode: _err.code,
                                extendedData: _err.message
                            });
                        }
                    }
                }
                else {
                    message = "request mix server fail, error: " + httpCode;
                    _this.logger.error("zb.sh.ums " + message);
                    errorCallback && errorCallback(errorCode, message);
                }
                // } else {
                //TODO: 
                //   this.logger.debug("zb.sh.ums error code " + error.code);
                //   let _err;
                //   if (error == errorCodeList.TIMEOUT) {
                //     _err = ZegoRTCLogEvent.kZegoTaskMixStart.error.kRequestError;
                //   } else {
                //     _err = ZegoRTCLogEvent.kZegoTaskMixStart.error.kInternalError;
                //   }
                //   if (errorCallback) {
                //     errorCallback({
                //       errorCode: _err.code,
                //       extendedData: _err.message
                //     });
                //   }
                // }
            });
        }
        return true;
    }
};


/***/ }),

/***/ "./sdk/src/modules/mixstream/error.ts":
/*!********************************************!*\
  !*** ./sdk/src/modules/mixstream/error.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorCodeList = void 0;
exports.errorCodeList = {
    NOT_LOGIN: {
        code: 1000002,
        message: "not login room"
    },
    INPUT_PARAM: {
        code: 1100001,
        message: "input param error."
    },
    TIMEOUT: {
        code: 1100002,
        message: "network timeout."
    },
    // mixStreamErr
    MIXER_NO_SERVICES: {
        code: 1005000,
        message: "no mix stream service"
    },
    MIXER_TASK_ID_NULL: {
        code: 1005001,
        message: "mixer task is null"
    },
    MIXER_TASK_ID_TOO_LONG: {
        code: 1005002,
        message: "task ID is too long"
    },
    MIXER_TASK_ID_INVALID_CHARACTER: {
        code: 1005003,
        message: "task ID contains illegal characters"
    },
    MIXER_NO_OUTPUT_TARGET: {
        code: 1005005,
        message: "task configuration does not specify output"
    },
    MIXER_OUTPUT_TARGET_INVALID: {
        code: 1005006,
        message: "stream output target is incorrect"
    },
    MIXER_START_REQUEST_ERROR: {
        code: 1005010,
        message: "start mixer task fail, possibly due to network reasons"
    },
    MIXER_STOP_REQUEST_ERROR: {
        code: 1005011,
        message: "stop mixer task fail, possibly due to network reasons"
    },
    MIXER_NOT_OWNER_STOP_MIXER: {
        code: 1005012,
        message: " maxed task must be stopped by the start user of the task"
    },
    MIXER_INPUTLIST_NULL: {
        code: 1005020,
        message: "Mixed stream task input list is null"
    },
    MIXER_OUTPUTLIST_NULL: {
        code: 1005021,
        message: "Mixed stream task output list is null"
    },
    MIXER_VIDEO_CONFIG_INVALID: {
        code: 1005023,
        message: "invalid mixed stream task video configuration"
    },
    MIXER_EXCEED_MAX_INPUT_COUNT: {
        code: 1005025,
        message: "more than the maximum number of input streams"
    },
    MIXER_INPUT_STREAM_NOT_EXISTS: {
        code: 1005026,
        message: "Input stream does not exist"
    },
    MIXER_EXCEED_MAX_OUTPUT_COUNT: {
        code: 1005030,
        message: "more than the maximum number of output streams"
    },
    MIXER_AUTHENTICATION_FAILED: {
        code: 1005050,
        message: "mixed stream authentication failed"
    },
    MIXER_WATERMARK_NULL: {
        code: 1005061,
        mag: "input watermark is null"
    },
    MIXER_WATERMARK_PARAMETERS_ERROR: {
        code: 1005062,
        message: "input watermark parameter is wrong"
    },
    MIXER_WATERMARK_URL_INVALID: {
        code: 1005063,
        message: "illegal input watermark URL"
    },
    MIXER_BACKGROUND_IMAGE_URL_INVALID: {
        code: 1005067,
        message: "illegal input background image URL"
    },
    MIXER_REPEAT_INPUT: {
        code: 1005099,
        message: "mix stream input repeat"
    },
    MIXER_INNER_ERROR: {
        code: 1005099,
        message: "mixer internal error"
    }
};


/***/ }),

/***/ "./sdk/src/modules/mixstream/index.ts":
/*!********************************************!*\
  !*** ./sdk/src/modules/mixstream/index.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//@ts-nocheck
var content_1 = __webpack_require__(/*! ./content */ "./sdk/src/modules/mixstream/content.ts");
exports["default"] = {
    type: "MixStream",
    install: function (RTC, SH) {
        //ZegoWebRTC
        for (var key in content_1.zegoWebRTC) {
            Object.defineProperty(RTC.prototype, key, {
                value: content_1.zegoWebRTC[key],
                writable: false
            });
        }
        //streamHandler
        for (var key in content_1.streamHandler) {
            Object.defineProperty(SH.prototype, key, {
                value: content_1.streamHandler[key],
                writable: false
            });
        }
    }
};


/***/ }),

/***/ "./sdk/src/modules/mixstream/logevent.ts":
/*!***********************************************!*\
  !*** ./sdk/src/modules/mixstream/logevent.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoRTCLogEvent = void 0;
var error_1 = __webpack_require__(/*! ./error */ "./sdk/src/modules/mixstream/error.ts");
var getItem = function (item) { return item; };
exports.ZegoRTCLogEvent = {
    kZegoTaskMixStart: {
        event: "/mix/start_mix",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM,
            kTaskIDNullError: error_1.errorCodeList.MIXER_TASK_ID_NULL,
            kTaskIDToLongError: error_1.errorCodeList.MIXER_TASK_ID_TOO_LONG,
            kTaskIDInvalidCharacterError: error_1.errorCodeList.MIXER_TASK_ID_INVALID_CHARACTER,
            kInputListNullError: error_1.errorCodeList.MIXER_INPUTLIST_NULL,
            kOutputListNullError: error_1.errorCodeList.MIXER_OUTPUTLIST_NULL,
            kOutputTargetInvalidError: error_1.errorCodeList.MIXER_OUTPUT_TARGET_INVALID,
            kOutputNoTargetError: error_1.errorCodeList.MIXER_NO_OUTPUT_TARGET,
            kRequestError: error_1.errorCodeList.MIXER_START_REQUEST_ERROR,
            kInternalError: error_1.errorCodeList.MIXER_INNER_ERROR,
            kNoLoginError: error_1.errorCodeList.NOT_LOGIN
        },
        mix_stream_id: getItem,
        stream_cnt: getItem,
        input_stream_list: getItem,
        output_target_list: getItem
    },
    kZegoTaskMixStop: {
        event: "/mix/stop_mix",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM,
            kTaskIDNullError: error_1.errorCodeList.MIXER_TASK_ID_NULL,
            kRequestError: error_1.errorCodeList.MIXER_STOP_REQUEST_ERROR,
            kInternalError: error_1.errorCodeList.MIXER_INNER_ERROR,
            kNoLoginError: error_1.errorCodeList.NOT_LOGIN
        }
    },
    kZegoTaskMixConfig: {
        event: "/mix/config_mix",
        error: {
            kParamError: error_1.errorCodeList.INPUT_PARAM,
            kVideoConfigInvalidError: error_1.errorCodeList.MIXER_VIDEO_CONFIG_INVALID,
            kBackgroundImageUrlInvalidError: error_1.errorCodeList.MIXER_BACKGROUND_IMAGE_URL_INVALID,
            kNoLoginError: error_1.errorCodeList.NOT_LOGIN
        },
        config: getItem
    }
};


/***/ }),

/***/ "./sdk/src/modules/rangeaudio/ZegoAudioListener.ts":
/*!*********************************************************!*\
  !*** ./sdk/src/modules/rangeaudio/ZegoAudioListener.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var AudioSource_1 = __importDefault(__webpack_require__(/*! ./modules/AudioSource */ "./sdk/src/modules/rangeaudio/modules/AudioSource.ts"));
var RangeListener_1 = __importDefault(__webpack_require__(/*! ./modules/RangeListener */ "./sdk/src/modules/rangeaudio/modules/RangeListener.ts"));
var PlayStreamHandler_1 = __importDefault(__webpack_require__(/*! ./modules/PlayStreamHandler */ "./sdk/src/modules/rangeaudio/modules/PlayStreamHandler.ts"));
var EventManager_1 = __importDefault(__webpack_require__(/*! ./modules/EventManager */ "./sdk/src/modules/rangeaudio/modules/EventManager.ts"));
var checkParam_1 = __webpack_require__(/*! ./utils/checkParam */ "./sdk/src/modules/rangeaudio/utils/checkParam.ts");
var ZegoExpressEntity_web_1 = __webpack_require__(/*! ../../../code/zh/ZegoExpressEntity.web */ "./sdk/code/zh/ZegoExpressEntity.web.ts");
var ZegoAudioListener = /** @class */ (function () {
    function ZegoAudioListener(zegoRTC) {
        var _this = this;
        // 
        this.isSpatial = false;
        // ()
        this.audioSourceList = [];
        // ()
        this.speakingUserIdList = [];
        this._audioCtx = null;
        this.zegoRTC = zegoRTC;
        // 
        this.zegoRTC.on("roomStreamUpdate", function (roomID, updateType, streamList) {
            var changeIdList = streamList.map(function (item) { return item.streamID; });
            if (updateType === "DELETE") {
                // 
                _this.speakingUserIdList = _this.speakingUserIdList.filter(function (item) {
                    var isSpeaking = !changeIdList.includes(item);
                    if (!isSpeaking) {
                        var audioSource = _this.audioSourceMap[item];
                        if (audioSource && audioSource.isPlaying) {
                            audioSource.stopPlayingAudio();
                        }
                    }
                    return isSpeaking;
                });
            }
            else if (updateType === "ADD") {
                _this.speakingUserIdList = _this.speakingUserIdList.concat(changeIdList);
                // 
                streamList.forEach(function (item) {
                    if (!_this.audioSourceMap[item.streamID]) {
                        var _a = _this.getStreamInfo(item.extraInfo), teamID = _a.teamID, sendMode = _a.sendMode;
                        var audioSource = new AudioSource_1.default({
                            userID: item.streamID,
                            teamID: teamID,
                            sendMode: sendMode
                        }, {
                            audioCtx: _this.audioCtx,
                            zegoRTC: _this.zegoRTC,
                            isSpatial: _this.isSpatial,
                            maxDistance: _this.rangeListener.recvRange
                        });
                        _this.audioSourceList.push(audioSource);
                        _this.playStreamHandler.handlePlayAudioTask();
                    }
                });
            }
            // console.log("", this.speakingUserIdList);
            _this.playStreamHandler.setAudioSourceList(_this.speakingAudioSourceList);
        });
        // 
        this.zegoRTC.on("playerStateUpdate", function (result) {
            var audioSource = _this.audioSourceMap[result.streamID];
            if (audioSource) {
                // 
                if (result.state === "NO_PLAY") {
                    audioSource.isPlaying = false;
                }
                else {
                    audioSource.isPlaying = true;
                }
            }
        });
        // 
        this.zegoRTC.on("streamExtraInfoUpdate", function (roomID, streamList) {
            streamList.forEach(function (item) {
                var audioSource = _this.audioSourceMap[item.streamID];
                if (audioSource) {
                    var _a = _this.getStreamInfo(item.extraInfo), teamID = _a.teamID, sendMode = _a.sendMode;
                    if (teamID !== audioSource.teamID) {
                        audioSource.teamID = teamID;
                        //  3D 
                        _this.enableSpatializer(_this.isSpatial);
                    }
                    if (sendMode !== undefined) {
                        audioSource.sendMode = sendMode;
                    }
                    _this.playStreamHandler.handlePlayAudioTask();
                }
            });
        });
        // 
        this.zegoRTC.RTM._on("_roomStateUpdate", function (roomID, state) {
            if (state === "CONNECTED") {
                _this.roomID = roomID;
                _this.rangeListener.userID = _this.zegoRTC.RTM.getUserID();
            }
            else if (state === "DISCONNECTED") {
                // 
                _this.roomID = undefined;
                _this.rangeListener.reset();
                _this.audioSourceList = [];
            }
        });
        var AudioContext = window.AudioContext || window.webkitAudioContext;
        this._audioCtx = (this.zegoRTC && this.zegoRTC.ac) || new AudioContext();
        this.rangeListener = RangeListener_1.default.getInstance(this.audioCtx, this.zegoRTC);
        this.playStreamHandler = PlayStreamHandler_1.default.getInstance(this.rangeListener);
        this.eventManager = EventManager_1.default.getInstance();
    }
    Object.defineProperty(ZegoAudioListener.prototype, "audioSourceMap", {
        get: function () {
            return this.audioSourceList.reduce(function (result, item) {
                if (item.userID) {
                    result[item.userID] = item;
                }
                return result;
            }, {});
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ZegoAudioListener.prototype, "speakingAudioSourceList", {
        get: function () {
            var _this = this;
            return this.audioSourceList.filter(function (item) {
                if (!_this.speakingUserIdList.includes(item.userID)) {
                    return false;
                }
                return true;
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ZegoAudioListener.prototype, "playingAudioSourceList", {
        get: function () {
            return this.audioSourceList.filter(function (item) { return item.isPlaying; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ZegoAudioListener.prototype, "audioCtx", {
        get: function () {
            if (!this._audioCtx) {
                var AudioContext_1 = window.AudioContext || window.webkitAudioContext;
                this._audioCtx = new AudioContext_1();
            }
            return this._audioCtx;
        },
        enumerable: false,
        configurable: true
    });
    ZegoAudioListener.getInstance = function (zegoRTC) {
        if (!ZegoAudioListener.instance) {
            ZegoAudioListener.instance = new ZegoAudioListener(zegoRTC);
        }
        return ZegoAudioListener.instance;
    };
    ZegoAudioListener.prototype.resumeAudioContext = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) {
                        _this.audioCtx.onstatechange = function () {
                            if (_this.audioCtx.state === "running") {
                                resolve(true);
                            }
                        };
                        _this.audioCtx.suspend();
                        _this.audioCtx.resume();
                        setTimeout(function () {
                            resolve(false);
                        }, 3000);
                    })];
            });
        });
    };
    ZegoAudioListener.prototype.getAudioContextState = function () {
        return this.audioCtx.state;
    };
    ZegoAudioListener.prototype.getStreamInfo = function (extraInfoStr) {
        var teamID = undefined, sendMode = undefined;
        try {
            var extraInfo = JSON.parse(extraInfoStr);
            teamID = extraInfo.range_audio_team_id;
            if ([ZegoExpressEntity_web_1.ZegoRangeAudioMode.World, ZegoExpressEntity_web_1.ZegoRangeAudioMode.Team].includes(extraInfo.range_audio_mode)) {
                sendMode = extraInfo.range_audio_mode;
            }
        }
        catch (error) { }
        // console.log("", extraInfoStr, teamID, sendMode);
        return {
            teamID: teamID,
            sendMode: sendMode
        };
    };
    // loginRoom(roomID: string, token: string, user: ZegoUser): any {
    //   this.rangeListener.userID = user.userID;
    //   // return this.zegoRTC.loginRoom(roomID, token, user);
    // }
    // logoutRoom(): void {
    //   this.zegoRTC.off("roomStreamUpdate");
    //   this.zegoRTC.off("playerStateUpdate");
    //   if (this.rangeListener.audioStream) {
    //     // 
    //     this.zegoRTC.destroyStream(this.rangeListener.audioStream);
    //   }
    //   // this.zegoRTC.logoutRoom(this.roomID);
    //   // 
    //   this.rangeListener.userID = undefined;
    //   this.audioSourceList = [];
    // }
    ZegoAudioListener.prototype.setAudioReceiveRange = function (range) {
        if (!checkParam_1.checkNumber(range)) {
            throw Error("Failed to execute 'setAudioReceiveRange': Argument 'range' requires to be type number.");
        }
        // 
        range = Number(range);
        if (range < 0) {
            throw Error("Failed to execute 'setAudioReceiveRange': Argument 'range' can not be less than 0.");
        }
        this.rangeListener.recvRange = range;
        this.audioSourceList.forEach(function (item) {
            item.setMaxDistance(range);
        });
    };
    ZegoAudioListener.prototype.updateSelfPosition = function (position, axisForward, axisRight, axisUp) {
        // 
        var getErrorMsg = function (errorKey) {
            return "Failed to execute 'updateSelfPosition': Argument '" + errorKey + "' requires an array of type number.\"";
        };
        if (!checkParam_1.checkCoordinate(position)) {
            throw new Error(getErrorMsg("position"));
        }
        if (!checkParam_1.checkCoordinate(axisForward)) {
            throw new Error(getErrorMsg("axisForward"));
        }
        if (!checkParam_1.checkCoordinate(axisRight)) {
            throw new Error(getErrorMsg("axisRight"));
        }
        if (!checkParam_1.checkCoordinate(axisUp)) {
            throw new Error(getErrorMsg("axisUp"));
        }
        if (this.rangeListener) {
            this.rangeListener.updateSelfPosition(position, axisForward, axisUp);
        }
        this.playStreamHandler.setListener(this.rangeListener);
    };
    ZegoAudioListener.prototype.updateAudioSource = function (userID, position) {
        // 
        userID = String(userID);
        if (!checkParam_1.checkCoordinate(position)) {
            throw new Error("Failed to execute 'updateAudioSource': Arguments 'position' must be an array of type number.");
        }
        var audioSource = this.audioSourceMap[userID];
        if (audioSource) {
            audioSource.setPosition(position);
        }
        else {
            audioSource = new AudioSource_1.default({
                userID: userID,
                position: position
            }, {
                audioCtx: this.audioCtx,
                zegoRTC: this.zegoRTC,
                isSpatial: this.isSpatial,
                maxDistance: this.rangeListener.recvRange
            });
            this.enableSpatializer(this.isSpatial);
            this.audioSourceList.push(audioSource);
        }
        this.playStreamHandler.setAudioSourceList(this.speakingAudioSourceList);
    };
    ZegoAudioListener.prototype.enableMicrophone = function (enable) {
        if (enable === void 0) { enable = true; }
        if (!this.rangeListener.userID) {
            throw new Error("Enable mic failed. Please log in room first.");
        }
        if (enable) {
            return this.rangeListener.startPublishingStream();
        }
        else {
            return this.rangeListener.stopPublishingStream();
        }
    };
    ZegoAudioListener.prototype.enableSpeaker = function (enable) {
        if (enable === void 0) { enable = true; }
        if (!this.roomID) {
            throw new Error("Enable speaker failed. Please log in room first.");
        }
        this.playStreamHandler.isEnable = enable;
        if (enable) {
            this.playStreamHandler.startPlayingAudioStream();
            this.playStreamHandler.handlePlayAudioTask();
        }
        else {
            this.playStreamHandler.stopPlayingAudioStream();
        }
    };
    ZegoAudioListener.prototype.enableSpatializer = function (enable) {
        var _this = this;
        if (enable === void 0) { enable = true; }
        this.isSpatial = !!enable;
        this.audioSourceList.forEach(function (item) {
            // 3D
            var isSpatial = ![item.teamID, _this.rangeListener.teamID].includes(undefined) &&
                _this.rangeListener.teamID === item.teamID
                ? false
                : enable;
            item.enableSpatializer(isSpatial);
        });
        if (enable) {
            this.rangeListener.updateListenerEffect();
        }
    };
    ZegoAudioListener.prototype.setRangeAudioTeamID = function (teamID) {
        // console.log("setRangeAudioTeamID", teamID);
        this.rangeListener.setTeamID(teamID);
        // 3D
        this.enableSpatializer(this.isSpatial);
        this.playStreamHandler.handlePlayAudioTask();
    };
    ZegoAudioListener.prototype.setRangeAudioMode = function (mode) {
        // console.log("setRangeAudioMode", mode);
        this.rangeListener.setSendMode(mode);
        this.rangeListener.setRecvMode(mode);
        this.playStreamHandler.handlePlayAudioTask();
    };
    ZegoAudioListener.prototype.on = function (event, callBack) {
        return this.eventManager.addEventHandler(event, callBack);
    };
    ZegoAudioListener.prototype.off = function (event, callBack) {
        return this.eventManager.removeEventHandler(event, callBack);
    };
    return ZegoAudioListener;
}());
exports["default"] = ZegoAudioListener;


/***/ }),

/***/ "./sdk/src/modules/rangeaudio/index.ts":
/*!*********************************************!*\
  !*** ./sdk/src/modules/rangeaudio/index.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RangeAudio = void 0;
var ZegoExpressRangeAudio_web_1 = __webpack_require__(/*! ../../../code/zh/ZegoExpressRangeAudio.web */ "./sdk/code/zh/ZegoExpressRangeAudio.web.ts");
exports.RangeAudio = {
    type: "RangeAudio",
    install: function (ZegoWebRTC) {
        Object.defineProperty(ZegoWebRTC.prototype, "createRangeAudioInstance", {
            value: function () {
                if (!this.rangeAudio) {
                    this.rangeAudio = ZegoExpressRangeAudio_web_1.ZegoExpressRangeAudio.getInstance(this);
                }
                return this.rangeAudio;
            },
            writable: false
        });
    }
};


/***/ }),

/***/ "./sdk/src/modules/rangeaudio/modules/AudioSource.ts":
/*!***********************************************************!*\
  !*** ./sdk/src/modules/rangeaudio/modules/AudioSource.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ZegoExpressEntity_web_1 = __webpack_require__(/*! ../../../../code/zh/ZegoExpressEntity.web */ "./sdk/code/zh/ZegoExpressEntity.web.ts");
var AudioSource = /** @class */ (function () {
    function AudioSource(userInfo, config) {
        this.panner = null;
        this.isSpatial = false;
        this.autoPlay = true;
        this.position = null;
        this.stream = null;
        this.sourceNode = null;
        this.isPlaying = false;
        this.distance = null;
        this.audioCtx = config.audioCtx;
        this.zegoRTC = config.zegoRTC;
        this.isSpatial = config.isSpatial;
        this.maxDistance = config.maxDistance || 100000;
        this.userID = userInfo.userID;
        this.teamID = userInfo.teamID;
        this.sendMode =
            userInfo.sendMode !== undefined
                ? userInfo.sendMode
                : ZegoExpressEntity_web_1.ZegoRangeAudioMode.World;
        if (userInfo.position) {
            this.position = userInfo.position;
        }
    }
    Object.defineProperty(AudioSource.prototype, "audioWrapper", {
        get: function () {
            var audioWrap = document.getElementById("#zg-audio-source-wrapper");
            if (!audioWrap) {
                audioWrap = document.createElement("div");
                audioWrap.setAttribute("id", "zg-audio-source-wrapper");
                document.body.appendChild(audioWrap);
            }
            return audioWrap;
        },
        enumerable: false,
        configurable: true
    });
    AudioSource.prototype.createPanner = function () {
        // 
        var defaultPosition = this.position || [0, 0, 0];
        // 
        var pannerModel = "HRTF";
        //  distanceModel   linear, inverse,  exponential
        var distanceModel = "linear";
        //  (maxDistance)   10,000
        var maxDistance = this.maxDistance;
        //  (refDistance) 1
        var refDistance = 1;
        // roll-off  (rolloffFactor)  panner1
        var rollOff = 1;
        // 
        var outerGain = 0.4;
        // panner3D
        return new PannerNode(this.audioCtx, {
            panningModel: pannerModel,
            distanceModel: distanceModel,
            refDistance: refDistance,
            maxDistance: maxDistance,
            rolloffFactor: rollOff,
            coneOuterGain: outerGain,
            positionX: defaultPosition[1],
            positionY: defaultPosition[0],
            positionZ: -defaultPosition[0]
        });
    };
    AudioSource.prototype.startPlayingAudio = function () {
        return __awaiter(this, void 0, void 0, function () {
            var audioEl, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        audioEl = document.getElementById("zg-audio-source-" + this.userID);
                        if (!!audioEl) return [3 /*break*/, 2];
                        audioEl = document.createElement("audio");
                        audioEl.setAttribute("autoplay", "autoplay");
                        audioEl.setAttribute("id", "zg-audio-source-" + this.userID);
                        audioEl.setAttribute("crossorigin", "anonymous");
                        _a = this;
                        return [4 /*yield*/, this.zegoRTC.startPlayingStream(this.userID)];
                    case 1:
                        _a.stream = _b.sent();
                        // console.log("", this.userID);
                        // 
                        // audioEl.setAttribute(
                        //   "src",
                        //   "https://zego-public.oss-cn-shanghai.aliyuncs.com/sdk-doc/assets/bike.mp3"
                        // );
                        // audioEl.setAttribute("controls", "controls");
                        // audioEl.setAttribute("muted", "muted");
                        this.audioWrapper.appendChild(audioEl);
                        // 
                        if (this.stream) {
                            audioEl.srcObject = this.stream;
                            this.sourceNode = this.audioCtx.createMediaStreamSource(this.stream);
                        }
                        if (!this.panner) {
                            this.panner = this.createPanner();
                        }
                        if (this.sourceNode) {
                            // 3D,3D
                            this.enableSpatializer(this.isSpatial, true);
                        }
                        if (this.audioCtx.state === "suspended") {
                            this.audioCtx.resume();
                        }
                        _b.label = 2;
                    case 2:
                        // audio
                        if (audioEl && audioEl.parentNode) {
                            audioEl.parentNode.removeChild(audioEl);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    AudioSource.prototype.stopPlayingAudio = function () {
        if (this.isPlaying) {
            this.zegoRTC.stopPlayingStream(this.userID);
        }
        this.stream = null;
        if (this.sourceNode) {
            this.sourceNode.disconnect();
            this.sourceNode = null;
        }
        // console.log("", this.userID);
    };
    AudioSource.prototype.setPosition = function (position) {
        this.position = position;
        if (this.panner) {
            this.panner.positionX.value = position[1];
            this.panner.positionY.value = position[2];
            this.panner.positionZ.value = -position[0];
        }
    };
    AudioSource.prototype.setMaxDistance = function (range) {
        this.maxDistance = range;
        if (this.panner) {
            this.panner.maxDistance = this.maxDistance;
        }
    };
    // 
    AudioSource.prototype.getDistanceFromListener = function (listener) {
        var audioPosition = this.position;
        var listenerPosition = listener.position;
        if (!listenerPosition || !audioPosition)
            return null;
        var diff = [
            audioPosition[0] - listenerPosition[0],
            audioPosition[1] - listenerPosition[1],
            audioPosition[2] - listenerPosition[2]
        ];
        this.distance = Math.sqrt(Math.pow(diff[0], 2) + Math.pow(diff[1], 2) + Math.pow(diff[2], 2));
        return this.distance;
    };
    // 3D
    AudioSource.prototype.enableSpatializer = function (enable, hard) {
        if (hard === void 0) { hard = false; }
        if (!hard && this.isSpatial === enable)
            return;
        this.isSpatial = enable;
        if (this.sourceNode) {
            if (enable && this.panner) {
                this.sourceNode.disconnect();
                this.sourceNode.connect(this.panner).connect(this.audioCtx.destination);
            }
            else if (!enable) {
                this.sourceNode.disconnect();
                this.sourceNode.connect(this.audioCtx.destination);
            }
        }
    };
    return AudioSource;
}());
exports["default"] = AudioSource;


/***/ }),

/***/ "./sdk/src/modules/rangeaudio/modules/EventManager.ts":
/*!************************************************************!*\
  !*** ./sdk/src/modules/rangeaudio/modules/EventManager.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var EventManager = /** @class */ (function () {
    function EventManager() {
        this.handlerListMap = {
            microphoneStateUpdate: []
        };
    }
    EventManager.getInstance = function () {
        if (!EventManager.instance) {
            EventManager.instance = new EventManager();
        }
        return EventManager.instance;
    };
    EventManager.prototype.addEventHandler = function (listener, callBack) {
        if (!this.handlerListMap[listener]) {
            return false;
        }
        if (typeof callBack !== "function") {
            throw new Error("Params callBack is not a Function");
        }
        this.handlerListMap[listener].indexOf(callBack) == -1 &&
            this.handlerListMap[listener].push(callBack);
        return true;
    };
    EventManager.prototype.removeEventHandler = function (listener, callBack) {
        if (!this.handlerListMap[listener]) {
            return false;
        }
        if (callBack) {
            this.handlerListMap[listener] = this.handlerListMap[listener].filter(function (item) { return item !== callBack; });
        }
        else {
            this.handlerListMap[listener] = [];
        }
        return true;
    };
    EventManager.prototype.emit = function (listener) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.handlerListMap[listener] &&
            this.handlerListMap[listener].forEach(function (func) {
                try {
                    setTimeout(function () {
                        func.apply(void 0, args);
                    }, 0);
                }
                catch (error) {
                    console.error("dispatch " + listener + " " + error);
                }
            });
    };
    return EventManager;
}());
exports["default"] = EventManager;


/***/ }),

/***/ "./sdk/src/modules/rangeaudio/modules/PlayStreamHandler.ts":
/*!*****************************************************************!*\
  !*** ./sdk/src/modules/rangeaudio/modules/PlayStreamHandler.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var ZegoExpressEntity_web_1 = __webpack_require__(/*! ../../../../code/zh/ZegoExpressEntity.web */ "./sdk/code/zh/ZegoExpressEntity.web.ts");
var PlayStreamHandler = /** @class */ (function () {
    function PlayStreamHandler(rangeListener) {
        this.isEnable = false;
        this.interval = 3000;
        this.timer = null;
        this.audioSourceList = [];
        this.hasChanged = false;
        this.maxPlayingQuantity = 20;
        this.rangeListener = rangeListener;
    }
    PlayStreamHandler.getInstance = function (rangeListener) {
        if (!PlayStreamHandler.instance) {
            PlayStreamHandler.instance = new PlayStreamHandler(rangeListener);
        }
        return PlayStreamHandler.instance;
    };
    // 
    PlayStreamHandler.prototype.setListener = function (rangeListener) {
        this.rangeListener = rangeListener;
        this.hasChanged = true;
    };
    // 
    PlayStreamHandler.prototype.setAudioSourceList = function (audioSourceList) {
        this.audioSourceList = audioSourceList;
        this.hasChanged = true;
    };
    PlayStreamHandler.prototype.startPlayingAudioStream = function () {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        this.playAudioTask();
    };
    // 
    PlayStreamHandler.prototype.playAudioTask = function () {
        var _this = this;
        if (this.hasChanged) {
            this.hasChanged = false;
            this.handlePlayAudioTask();
        }
        this.timer = window.setTimeout(function () {
            _this.playAudioTask();
        }, this.interval);
    };
    PlayStreamHandler.prototype.handlePlayAudioTask = function () {
        var _this = this;
        if (!this.isEnable) {
            this.stopPlayingAudioStream();
            return;
        }
        var _a = this.getTeamAudioSourceGroup(), teamList = _a.teamList, otherList = _a.otherList;
        // console.log("", teamList, otherList);
        var playingQuantity = 0;
        // 
        teamList.forEach(function (item) {
            if (playingQuantity < _this.maxPlayingQuantity) {
                if (!item.isPlaying) {
                    item.startPlayingAudio();
                }
                playingQuantity++;
            }
        });
        // 
        var listenable = this.rangeListener.recvMode === ZegoExpressEntity_web_1.ZegoRangeAudioMode.World;
        if (listenable) {
            otherList.forEach(function (item) {
                item.distance = item.getDistanceFromListener(_this.rangeListener);
            });
            otherList.sort(function (a, b) {
                if (a.distance === null) {
                    return 1;
                }
                if (b.distance === null) {
                    return -1;
                }
                if (a.distance < b.distance) {
                    return -1;
                }
                if (a.distance > b.distance) {
                    return 1;
                }
                return 0;
            });
        }
        otherList.forEach(function (item) {
            // console.log(
            //   "",
            //   listenable,
            //   item.sendMode !== ZegoRangeAudioMode.Team,
            //   item.distance !== null &&
            //     (this.rangeListener.recvRange === null ||
            //       item.distance <= this.rangeListener.recvRange)
            // );
            if (listenable &&
                playingQuantity < _this.maxPlayingQuantity &&
                item.sendMode !== ZegoExpressEntity_web_1.ZegoRangeAudioMode.Team &&
                item.distance !== null &&
                (_this.rangeListener.recvRange === null ||
                    item.distance <= _this.rangeListener.recvRange)) {
                if (!item.isPlaying) {
                    item.startPlayingAudio();
                }
                playingQuantity++;
            }
            else {
                item.stopPlayingAudio();
            }
        });
        // console.log("", playingQuantity);
    };
    PlayStreamHandler.prototype.getTeamAudioSourceGroup = function () {
        var _this = this;
        var teamList = [];
        var otherList = [];
        this.audioSourceList.forEach(function (item) {
            if (![item.teamID, _this.rangeListener.teamID].includes(undefined) &&
                item.teamID === _this.rangeListener.teamID) {
                teamList.push(item);
            }
            else {
                otherList.push(item);
            }
        });
        return {
            teamList: teamList,
            otherList: otherList
        };
    };
    PlayStreamHandler.prototype.stopPlayingAudioStream = function () {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        this.audioSourceList.forEach(function (item) {
            item.stopPlayingAudio();
        });
    };
    return PlayStreamHandler;
}());
exports["default"] = PlayStreamHandler;


/***/ }),

/***/ "./sdk/src/modules/rangeaudio/modules/RangeListener.ts":
/*!*************************************************************!*\
  !*** ./sdk/src/modules/rangeaudio/modules/RangeListener.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ZegoExpressEntity_web_1 = __webpack_require__(/*! ../../../../code/zh/ZegoExpressEntity.web */ "./sdk/code/zh/ZegoExpressEntity.web.ts");
var EventManager_1 = __importDefault(__webpack_require__(/*! ./EventManager */ "./sdk/src/modules/rangeaudio/modules/EventManager.ts"));
var RangeListener = /** @class */ (function () {
    function RangeListener(audioCtx, zegoRTC) {
        var _this = this;
        this.recvMode = ZegoExpressEntity_web_1.ZegoRangeAudioMode.World;
        this.sendMode = ZegoExpressEntity_web_1.ZegoRangeAudioMode.World;
        // 
        this.recvRange = null;
        // , 
        this.position = null;
        // 
        this.forwardAxis = [1, 0, 0];
        // 
        this.upAxis = [0, 0, 1];
        this.audioStream = null;
        // 
        this.isPublishing = false;
        this.zegoRTC = zegoRTC;
        this.audioCtx = audioCtx;
        this.audioListener = this.audioCtx.listener;
        this.eventHandler = EventManager_1.default.getInstance();
        // 
        this.zegoRTC.on("publisherStateUpdate", function (_a) {
            var streamID = _a.streamID, state = _a.state, errorCode = _a.errorCode, extendedData = _a.extendedData;
            if (streamID === _this.userID) {
                if (state === "NO_PUBLISH") {
                    _this.isPublishing = false;
                    _this.stopPublishingStream();
                }
                else {
                    _this.isPublishing = true;
                }
            }
            // "PUBLISHING" | "NO_PUBLISH" | "PUBLISH_REQUESTING";
            var stateMap = {
                NO_PUBLISH: ZegoExpressEntity_web_1.ZegoRangeAudioMicrophoneState.Off,
                PUBLISH_REQUESTING: ZegoExpressEntity_web_1.ZegoRangeAudioMicrophoneState.TurningOn,
                PUBLISHING: ZegoExpressEntity_web_1.ZegoRangeAudioMicrophoneState.On
            };
            _this.eventHandler.emit("microphoneStateUpdate", stateMap[state], errorCode, extendedData);
        });
    }
    RangeListener.getInstance = function (audioCtx, zegoRTC) {
        if (!RangeListener.instance) {
            RangeListener.instance = new RangeListener(audioCtx, zegoRTC);
        }
        return RangeListener.instance;
    };
    // 
    RangeListener.prototype.updateSelfPosition = function (position, forward, up) {
        this.position = position;
        this.forwardAxis = forward;
        if (Array.isArray(up)) {
            this.upAxis = up;
        }
        this.updateListenerEffect();
    };
    RangeListener.prototype.updateListenerEffect = function () {
        if (!this.position)
            return;
        // audioCtx
        if (this.audioListener.positionX) {
            this.audioListener.positionX.value = this.position[1];
            this.audioListener.positionY.value = this.position[2];
            this.audioListener.positionZ.value = -this.position[0];
        }
        else {
            this.audioListener.setPosition(this.position[1], this.position[2], -this.position[0]);
        }
        // audioCtx
        if (this.audioListener.forwardX) {
            this.audioListener.forwardX.value = this.forwardAxis[1];
            this.audioListener.forwardY.value = this.forwardAxis[2];
            this.audioListener.forwardZ.value = -this.forwardAxis[0];
            this.audioListener.upX.value = this.upAxis[1];
            this.audioListener.upY.value = this.upAxis[2];
            this.audioListener.upZ.value = -this.upAxis[0];
        }
        else {
            this.audioListener.setOrientation(this.forwardAxis[1], this.forwardAxis[2], -this.forwardAxis[0], this.upAxis[1], this.upAxis[2], -this.upAxis[0]);
        }
    };
    RangeListener.prototype.startPublishingStream = function () {
        var _this = this;
        this.zegoRTC
            .createStream({
            camera: { video: false, audio: true, audioBitrate: 30 }
        })
            .then(function (stream) {
            if (!_this.userID) {
                _this.zegoRTC.destroyStream(stream);
                throw Error("Enable mic failed. Please log in room first.");
            }
            else {
                if (_this.audioStream && _this.audioStream !== stream) {
                    _this.zegoRTC.destroyStream(_this.audioStream);
                }
                _this.audioStream = stream;
                var extraInfo = {
                    range_audio_team_id: _this.teamID,
                    range_audio_mode: _this.sendMode
                };
                _this.zegoRTC.startPublishingStream(_this.userID, stream, {
                    extraInfo: JSON.stringify(extraInfo)
                });
            }
        })
            .catch(function (error) {
            throw error;
        });
    };
    RangeListener.prototype.stopPublishingStream = function () {
        if (this.isPublishing && this.userID) {
            this.zegoRTC.stopPublishingStream(this.userID);
        }
        this.isPublishing = false;
        if (this.audioStream) {
            this.zegoRTC.destroyStream(this.audioStream);
            this.audioStream = null;
        }
    };
    RangeListener.prototype.setRecvMode = function (mode) {
        this.recvMode = mode;
    };
    RangeListener.prototype.setSendMode = function (mode) {
        this.sendMode = mode;
        this.updateSteamExtraInfo();
    };
    RangeListener.prototype.setTeamID = function (teamID) {
        this.teamID = teamID;
        this.updateSteamExtraInfo();
    };
    RangeListener.prototype.updateSteamExtraInfo = function () {
        if (this.userID && this.isPublishing) {
            this.zegoRTC.setStreamExtraInfo(this.userID, JSON.stringify({
                range_audio_team_id: this.teamID || undefined,
                range_audio_mode: this.sendMode
            }));
            // console.log("", {
            //   range_audio_team_id: this.teamID || undefined,
            //   range_audio_mode: this.sendMode
            // });
        }
    };
    RangeListener.prototype.reset = function () {
        if (this.audioStream) {
            this.stopPublishingStream();
        }
        this.userID = undefined;
    };
    return RangeListener;
}());
exports["default"] = RangeListener;


/***/ }),

/***/ "./sdk/src/modules/rangeaudio/utils/checkParam.ts":
/*!********************************************************!*\
  !*** ./sdk/src/modules/rangeaudio/utils/checkParam.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkCoordinate = exports.checkBoolean = exports.checkNumber = void 0;
function checkNumber(value) {
    if (!isNaN(Number(value)) &&
        Number.MAX_SAFE_INTEGER >= Number(value) &&
        Number(value) >= -Number.MAX_SAFE_INTEGER) {
        return true;
    }
    return false;
}
exports.checkNumber = checkNumber;
function checkBoolean(value) {
    if (typeof value === "boolean")
        return false;
    return false;
}
exports.checkBoolean = checkBoolean;
function checkCoordinate(position) {
    if (Array.isArray(position)) {
        for (var index = 0; index < 3; index++) {
            var isOK = checkNumber(position[index]);
            if (!isOK)
                return false;
        }
        return true;
    }
    return false;
}
exports.checkCoordinate = checkCoordinate;


/***/ }),

/***/ "./sdk/src/modules/videoEffect/content.ts":
/*!************************************************!*\
  !*** ./sdk/src/modules/videoEffect/content.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.preview = void 0;
//@ts-nocheck
var videoEffect_1 = __importDefault(__webpack_require__(/*! ./videoEffect */ "./sdk/src/modules/videoEffect/videoEffect.ts"));
var PUBLISH_SET_BEAUTY_EFFECT = "zc.p.0.sbe.0";
var error_1 = __webpack_require__(/*! ./error */ "./sdk/src/modules/videoEffect/error.ts");
exports.preview = {
    setBeautyEffect: function (enable, options) {
        return __awaiter(this, void 0, void 0, function () {
            var supportWebGL, _a, code, message;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.videoTrack) {
                            this.logger.error(PUBLISH_SET_BEAUTY_EFFECT + " video track no found");
                            return [2 /*return*/];
                        }
                        supportWebGL = "undefined" != typeof WebGLRenderingContext;
                        if (!supportWebGL) {
                            _a = error_1.errorCodeList.VIDEO_EFFECT_NOT_SUPPORT, code = _a.code, message = _a.message;
                            throw Error({ errorCode: code, extendedData: message });
                        }
                        if (!videoEffect_1.default) return [3 /*break*/, 7];
                        if (!this.videoEffect) return [3 /*break*/, 4];
                        if (!(this.videoTrack !== this.videoEffect.input)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.videoEffect.setInput(this.videoTrack)];
                    case 1:
                        _b.sent();
                        _b.label = 2;
                    case 2: return [4 /*yield*/, this.videoEffect.setBeautyEffectOptions(enable, options)];
                    case 3:
                        _b.sent();
                        return [3 /*break*/, 6];
                    case 4:
                        this.videoEffect = new videoEffect_1.default(this.logger, this.videoTrack);
                        (this.videoEffect.onOverload = function (result) {
                            // 
                            _this.stateCenter.actionListener("beautyEffectOverload", _this.localStream, result);
                        }),
                            (this.videoEffect.onOutputChange = function (outputTrack
                            // enabled: boolean true
                            ) { return __awaiter(_this, void 0, void 0, function () {
                                var activeTrack, currentTrack, publisher;
                                var _a;
                                return __generator(this, function (_b) {
                                    if (this.videoTrack && this.localStream) {
                                        activeTrack = this.videoTrack;
                                        if (!outputTrack) {
                                        }
                                        else {
                                            activeTrack = outputTrack;
                                        }
                                        currentTrack = this.localStream.getVideoTracks()[0];
                                        if (currentTrack !== activeTrack) {
                                            publisher = (_a = this.streamCenter.checkPublish(this.localStream)) === null || _a === void 0 ? void 0 : _a.publisher;
                                            if (publisher && publisher.previewer) {
                                                publisher.replacePublishedTrack(activeTrack, true);
                                            }
                                            else {
                                                this.replacePreviewTrack(activeTrack, !!outputTrack);
                                            }
                                        }
                                    }
                                    return [2 /*return*/];
                                });
                            }); });
                        return [4 /*yield*/, this.videoEffect.setBeautyEffectOptions(enable, options)];
                    case 5:
                        _b.sent();
                        _b.label = 6;
                    case 6: return [3 /*break*/, 8];
                    case 7:
                        this.logger.error(PUBLISH_SET_BEAUTY_EFFECT + " beauty effect module no found");
                        _b.label = 8;
                    case 8: return [2 /*return*/];
                }
            });
        });
    }
};


/***/ }),

/***/ "./sdk/src/modules/videoEffect/effectManager.ts":
/*!******************************************************!*\
  !*** ./sdk/src/modules/videoEffect/effectManager.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PUBLISH_SET_BEAUTY_EFFECT = void 0;
var blurShader_1 = __importDefault(__webpack_require__(/*! ./shaders/blurShader */ "./sdk/src/modules/videoEffect/shaders/blurShader.ts"));
var LightShader_1 = __importDefault(__webpack_require__(/*! ./shaders/LightShader */ "./sdk/src/modules/videoEffect/shaders/LightShader.ts"));
var sharpnessShader_1 = __importDefault(__webpack_require__(/*! ./shaders/sharpnessShader */ "./sdk/src/modules/videoEffect/shaders/sharpnessShader.ts"));
exports.PUBLISH_SET_BEAUTY_EFFECT = "zc.p.0.sbe.2";
var EffectManager = /** @class */ (function () {
    function EffectManager(logger) {
        this.logger = logger;
        this.gl = null;
        this.effectConfig = {
            sharpenIntensity: 0.5,
            whitenIntensity: 0.5,
            rosyIntensity: 0.5,
            smoothIntensity: 0.5
        };
        this.originResolution = {
            width: 0,
            height: 0
        };
        this.shaderList = [];
        this.frameBufferList = [];
        this.outputTextureList = [];
        this.inputTexture = null;
        this.enableBeauty = false;
    }
    EffectManager.prototype.setEnableBeauty = function (enable) {
        this.enableBeauty = !!enable;
    };
    EffectManager.prototype.init = function (width, height, canvasEl) {
        return __awaiter(this, void 0, void 0, function () {
            var supportWebGL, blurShader, lightShader, sharpnessShader;
            return __generator(this, function (_a) {
                supportWebGL = "undefined" != typeof WebGLRenderingContext;
                if (!supportWebGL) {
                    return [2 /*return*/, this.logger.error(exports.PUBLISH_SET_BEAUTY_EFFECT + " not support webgl!")];
                }
                this.gl = canvasEl.getContext("webgl");
                if (!this.gl)
                    return [2 /*return*/, this.logger.error(exports.PUBLISH_SET_BEAUTY_EFFECT + " not get webgl context")];
                this.initGL(width, height);
                if (!this.inputTexture)
                    return [2 /*return*/, this.logger.error(exports.PUBLISH_SET_BEAUTY_EFFECT + " input texture not found")];
                this.canvasEl = canvasEl;
                blurShader = new blurShader_1.default(this.gl, width, height);
                blurShader.setConstUniforms();
                lightShader = new LightShader_1.default(this.gl, width, height);
                lightShader.setConstUniforms();
                sharpnessShader = new sharpnessShader_1.default(this.gl, width, height);
                sharpnessShader.setConstUniforms();
                this.shaderList = [blurShader, lightShader, sharpnessShader];
                this.setEffectConfig(this.effectConfig);
                return [2 /*return*/];
            });
        });
    };
    EffectManager.prototype.render = function (videoEl) {
        return __awaiter(this, void 0, void 0, function () {
            var gl, isResolutionChange, vertex, vertexIndice, triangleTexCoords;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        gl = this.gl;
                        if (!gl || !this.canvasEl) {
                            this.logger.error(exports.PUBLISH_SET_BEAUTY_EFFECT + " video effect manager is not init!");
                            return [2 /*return*/];
                        }
                        isResolutionChange = (this.originResolution.height !== videoEl.videoHeight ||
                            this.originResolution.width !== videoEl.videoWidth) &&
                            // 2 muteVideo context
                            (Math.abs(this.originResolution.height - videoEl.videoHeight) > 2 ||
                                Math.abs(this.originResolution.width - videoEl.videoWidth) > 2);
                        if (!isResolutionChange) return [3 /*break*/, 3];
                        if (0 === videoEl.videoHeight || 0 === videoEl.videoWidth)
                            return [2 /*return*/];
                        this.canvasEl.width = videoEl.videoWidth;
                        this.canvasEl.height = videoEl.videoHeight;
                        videoEl.setAttribute("width", videoEl.videoWidth.toString());
                        videoEl.setAttribute("height", videoEl.videoHeight.toString());
                        if (!(this.gl && !this.gl.isContextLost())) return [3 /*break*/, 1];
                        this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " resolution changed, reset resolution");
                        this.resetResolution(videoEl.videoWidth, videoEl.videoHeight);
                        return [3 /*break*/, 3];
                    case 1:
                        this.logger.warn(exports.PUBLISH_SET_BEAUTY_EFFECT +
                            " resolution changed and gl context lost, restart effect");
                        this.release();
                        return [4 /*yield*/, this.init(videoEl.videoWidth, videoEl.videoHeight, this.canvasEl)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        vertex = [-1, -1, 0.0, 1, -1, 0.0, 1, 1, 0.0, -1, 1, 0.0];
                        vertexIndice = [0, 1, 2, 0, 2, 3];
                        triangleTexCoords = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0];
                        // 
                        gl.viewport(0, 0, videoEl.width, videoEl.height);
                        // 
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, this.inputTexture);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, videoEl);
                        this.shaderList.forEach(function (shaderInfo, index) {
                            var program = shaderInfo.program;
                            if (!program) {
                                // TODO: ;
                                return;
                            }
                            if (shaderInfo.renderPreTextures) {
                                shaderInfo.renderPreTextures(vertex, vertexIndice, triangleTexCoords);
                            }
                            gl.useProgram(program);
                            shaderInfo.render();
                            var uTexture = gl.getUniformLocation(program, "uTexture");
                            // 
                            // vertex data
                            var vertexBuffer = gl.createBuffer();
                            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertex), gl.STATIC_DRAW);
                            // indice data
                            var vertexIndiceBuffer = gl.createBuffer();
                            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndiceBuffer);
                            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertexIndice), gl.STATIC_DRAW);
                            // set position attribute
                            var aVertexPosition = gl.getAttribLocation(program, "aPosition");
                            gl.enableVertexAttribArray(aVertexPosition);
                            gl.vertexAttribPointer(aVertexPosition, 3, gl.FLOAT, false, 0, 0); // float 3 * 4 * 2
                            // texture coordinate data
                            var trianglesTexCoordBuffer = gl.createBuffer();
                            gl.bindBuffer(gl.ARRAY_BUFFER, trianglesTexCoordBuffer);
                            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangleTexCoords), gl.STATIC_DRAW);
                            // set texture coordinate attribute
                            var vertexTexCoordAttribute = gl.getAttribLocation(program, "aTexCoordinate");
                            gl.enableVertexAttribArray(vertexTexCoordAttribute);
                            gl.vertexAttribPointer(vertexTexCoordAttribute, 2, gl.FLOAT, false, 0, 0); // 2 * 4
                            // this.programs[index].setUniforms();
                            //  gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBufferList[b + (index % 2)]);
                            var outputTexture = index === _this.shaderList.length - 1
                                ? null
                                : _this.outputTextureList[index];
                            var outputFrameBuffer = index === _this.shaderList.length - 1
                                ? null
                                : _this.frameBufferList[index];
                            gl.bindFramebuffer(gl.FRAMEBUFFER, outputFrameBuffer);
                            gl.clearColor(0, 0, 0, 1);
                            gl.clear(gl.COLOR_BUFFER_BIT);
                            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                            gl.activeTexture(gl.TEXTURE0);
                            outputTexture && gl.bindTexture(gl.TEXTURE_2D, outputTexture);
                            gl.uniform1i(uTexture, 0);
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    EffectManager.prototype.setEffectConfig = function (options) {
        var _this = this;
        if (!isNaN(options.sharpenIntensity))
            this.effectConfig.sharpenIntensity = options.sharpenIntensity;
        if (!isNaN(options.whitenIntensity))
            this.effectConfig.whitenIntensity = options.whitenIntensity;
        if (!isNaN(options.rosyIntensity))
            this.effectConfig.rosyIntensity = options.rosyIntensity;
        if (!isNaN(options.smoothIntensity))
            this.effectConfig.smoothIntensity = options.smoothIntensity;
        this.shaderList.forEach(function (item) {
            item.setEffectConfig(_this.effectConfig);
        });
    };
    // setSize(width: number, height: number): void {
    //   this.shaderList.forEach(item => {
    //     // item instanceof vc &&
    //     item.setSize(width, height);
    //   });
    // }
    EffectManager.prototype.release = function () {
        var _this = this;
        // if (this.gl) {
        //   const extension = this.gl.getExtension("WEBGL_lose_context");
        //   extension && extension.loseContext();
        // }
        this.shaderList.forEach(function (item) {
            var _a;
            if (item.program) {
                (_a = _this.gl) === null || _a === void 0 ? void 0 : _a.deleteProgram(item.program);
            }
        });
        this.outputTextureList.forEach(function (item) {
            var _a;
            if (item) {
                (_a = _this.gl) === null || _a === void 0 ? void 0 : _a.deleteTexture(item);
            }
        });
        this.frameBufferList.forEach(function (item) {
            var _a;
            if (item) {
                (_a = _this.gl) === null || _a === void 0 ? void 0 : _a.deleteFramebuffer(item);
            }
        });
        this.inputTexture = this.gl = null;
        this.shaderList = [];
        this.outputTextureList = [];
        this.frameBufferList = [];
    };
    EffectManager.prototype.initGL = function (width, height) {
        var gl = this.gl;
        if (!gl)
            return this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " webgl context not found");
        this.inputTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.inputTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        for (var index = 0; 3 > index; index++) {
            var texture = gl.createTexture();
            if (!texture)
                return this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " create texture failed");
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            var frameBuffer = gl.createFramebuffer();
            if (!frameBuffer)
                return this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " create frame buffer failed");
            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            this.outputTextureList.push(texture);
            this.frameBufferList.push(frameBuffer);
        }
        gl.viewport(0, 0, width, height);
        this.originResolution.width = width;
        this.originResolution.height = height;
    };
    EffectManager.prototype.resetResolution = function (width, height) {
        var gl = this.gl;
        if (!gl)
            return this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " can not find webgl context");
        this.outputTextureList.forEach(function (item) {
            gl.bindTexture(gl.TEXTURE_2D, item);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        });
        gl.viewport(0, 0, width, height);
        this.originResolution.width = width;
        this.originResolution.height = height;
    };
    return EffectManager;
}());
exports["default"] = EffectManager;


/***/ }),

/***/ "./sdk/src/modules/videoEffect/error.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/videoEffect/error.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.errorCodeList = void 0;
exports.errorCodeList = {
    VIDEO_EFFECT_NOT_SUPPORT: {
        code: 1103072,
        message: "not support beauty effect"
    }
};


/***/ }),

/***/ "./sdk/src/modules/videoEffect/index.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/videoEffect/index.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeautyEffect = void 0;
//@ts-nocheck
var content_1 = __webpack_require__(/*! ./content */ "./sdk/src/modules/videoEffect/content.ts");
exports.BeautyEffect = {
    type: "BeautyEffect",
    install: function (Preview) {
        for (var key in content_1.preview) {
            Object.defineProperty(Preview.prototype, key, {
                value: content_1.preview[key],
                writable: false
            });
        }
    }
};


/***/ }),

/***/ "./sdk/src/modules/videoEffect/performanceDetector.ts":
/*!************************************************************!*\
  !*** ./sdk/src/modules/videoEffect/performanceDetector.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var PUBLISH_SET_BEAUTY_EFFECT = "zc.p.0.sbe.3";
var PerformanceDetector = /** @class */ (function () {
    function PerformanceDetector(logger) {
        this.logger = logger;
        this.recordedFrameCount = 0;
        this.targetFrameRate = 0;
        this.recordingDuration = 0;
    }
    PerformanceDetector.prototype.startRecordBeautyEffectOutput = function (fps) {
        return __awaiter(this, void 0, void 0, function () {
            var seconds, id, targetFrames, fps_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        seconds = 6;
                        if (this.recordID) {
                            this.logger.warn(PUBLISH_SET_BEAUTY_EFFECT + " detector is already recording");
                            return [2 /*return*/, { result: true }];
                        }
                        id = new Date().getTime();
                        this.recordID = id;
                        this.targetFrameRate = fps;
                        this.recordedFrameCount = 0;
                        this.recordingDuration = seconds;
                        return [4 /*yield*/, new Promise(function (resolve) {
                                window.setTimeout(resolve, 1e3 * _this.recordingDuration);
                            })];
                    case 1:
                        _a.sent();
                        if (this.recordID !== id) {
                            this.recordID = undefined;
                            return [2 /*return*/, { result: true }];
                        }
                        else {
                            this.recordID = undefined;
                            targetFrames = this.targetFrameRate * this.recordingDuration;
                            fps_1 = this.recordedFrameCount / seconds;
                            if (this.recordedFrameCount < targetFrames / 2) {
                                this.logger.warn(PUBLISH_SET_BEAUTY_EFFECT +
                                    " detect effect overload: current fps: " +
                                    fps_1);
                                return [2 /*return*/, {
                                        result: false,
                                        targetFPS: this.targetFrameRate,
                                        currentFPS: fps_1
                                    }];
                            }
                            else {
                                this.logger.info(PUBLISH_SET_BEAUTY_EFFECT + " detect effect current fps: " + fps_1);
                                return [2 /*return*/, {
                                        result: true
                                    }];
                            }
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    PerformanceDetector.prototype.stopRecordBeautyEffectOutput = function () {
        this.recordedFrameCount = this.targetFrameRate = 0;
        this.recordID = undefined;
    };
    PerformanceDetector.prototype.addFrame = function () {
        this.recordID && (this.recordedFrameCount += 1);
    };
    return PerformanceDetector;
}());
exports["default"] = PerformanceDetector;


/***/ }),

/***/ "./sdk/src/modules/videoEffect/shaders/LightShader.ts":
/*!************************************************************!*\
  !*** ./sdk/src/modules/videoEffect/shaders/LightShader.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var baseShader_1 = __importDefault(__webpack_require__(/*! ./baseShader */ "./sdk/src/modules/videoEffect/shaders/baseShader.ts"));
// // eslint-disable-next-line @typescript-eslint/no-var-requires
// const lightVS = require("./glsl/lightVS.glsl").default;
// // eslint-disable-next-line @typescript-eslint/no-var-requires
// const lightFS = require("./glsl/lightFS.glsl").default;
var shadersCodeSourceROT13_1 = __webpack_require__(/*! ./shadersCodeSourceROT13 */ "./sdk/src/modules/videoEffect/shaders/shadersCodeSourceROT13.ts");
var LightShader = /** @class */ (function (_super) {
    __extends(LightShader, _super);
    function LightShader(gl, width, height) {
        var _this = _super.call(this, gl) || this;
        _this.width = width;
        _this.height = height;
        _this.type = "LightShader";
        _this.uLightIntensity = null;
        _this.uRedIntensity = null;
        _this.whitenIntensity = 0.5; // 0-1
        _this.rosyIntensity = 0.5;
        _this.program = _this.makeProgram(shadersCodeSourceROT13_1.lightVS, shadersCodeSourceROT13_1.lightFS);
        return _this;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    LightShader.prototype.setEffectConfig = function (config) {
        if (!isNaN(config.whitenIntensity)) {
            this.whitenIntensity = config.whitenIntensity / 100;
        }
        if (!isNaN(config.rosyIntensity)) {
            this.rosyIntensity = config.rosyIntensity / 100;
        }
    };
    LightShader.prototype.render = function () {
        var gl = this.gl;
        gl.uniform1f(this.uLightIntensity, this.whitenIntensity);
        gl.uniform1f(this.uRedIntensity, this.rosyIntensity);
    };
    LightShader.prototype.setConstUniforms = function () {
        // 
        var identityMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        // y 
        var flipYMatrix = [1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        var program = this.program;
        if (!program)
            return;
        var gl = this.gl;
        gl.useProgram(program);
        this.uLightIntensity = gl.getUniformLocation(program, "intensity");
        gl.uniform1f(this.uLightIntensity, this.whitenIntensity);
        this.uRedIntensity = gl.getUniformLocation(program, "rosyIntensity");
        gl.uniform1f(this.uRedIntensity, this.rosyIntensity);
        // y
        var uPMVMatrix = gl.getUniformLocation(program, "uPMVMatrix");
        gl.uniformMatrix4fv(uPMVMatrix, false, flipYMatrix);
    };
    return LightShader;
}(baseShader_1.default));
exports["default"] = LightShader;


/***/ }),

/***/ "./sdk/src/modules/videoEffect/shaders/baseShader.ts":
/*!***********************************************************!*\
  !*** ./sdk/src/modules/videoEffect/shaders/baseShader.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function rot13(str) {
    var key = 13;
    // console.log(key);
    var ctext = str;
    var plain = "";
    // do the encoding
    for (var i = 0; i < ctext.length; i++) {
        var ccode = ctext.charCodeAt(i);
        var pcode = ccode;
        if (ccode >= 65 && ccode <= 90) {
            pcode = ((ccode - 65 - key * 1 + 26) % 26) + 65;
        }
        if (ccode >= 97 && ccode <= 122) {
            pcode = ((ccode - 97 - key * 1 + 26) % 26) + 97;
        }
        // console.log(ccode + "," + pcode);
        plain += String.fromCharCode(pcode);
    }
    // console.log(-3 % 26);
    return plain;
}
var BaseShader = /** @class */ (function () {
    function BaseShader(gl) {
        this.gl = gl;
        this.program = null;
        this.program = null;
    }
    BaseShader.prototype.setEffectConfig = function (config) { };
    BaseShader.prototype.setConstUniforms = function () { };
    BaseShader.prototype.render = function () { };
    BaseShader.prototype.renderPreTextures = function (vertex, vertexIndice, triangleTexCoords) { };
    BaseShader.prototype.makeProgram = function (vs_source, fs_source) {
        var gl = this.gl;
        //get shader source
        // compile shaders
        var vs = rot13(vs_source);
        var fs = rot13(fs_source);
        var vertexShader = this.makeShader(vs, gl.VERTEX_SHADER);
        var fragmentShader = this.makeShader(fs, gl.FRAGMENT_SHADER);
        // create program
        var glProgram = gl.createProgram();
        // attach and link shaders to the program
        gl.attachShader(glProgram, vertexShader);
        gl.attachShader(glProgram, fragmentShader);
        gl.linkProgram(glProgram);
        if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
            // TODO: alert("Unable to initialize the shader program.");
        }
        return glProgram;
    };
    BaseShader.prototype.makeShader = function (src, type) {
        var gl = this.gl;
        //compile the vertex shader
        var shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            // TODO: alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
        }
        return shader;
    };
    return BaseShader;
}());
exports["default"] = BaseShader;


/***/ }),

/***/ "./sdk/src/modules/videoEffect/shaders/blurShader.ts":
/*!***********************************************************!*\
  !*** ./sdk/src/modules/videoEffect/shaders/blurShader.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var baseShader_1 = __importDefault(__webpack_require__(/*! ./baseShader */ "./sdk/src/modules/videoEffect/shaders/baseShader.ts"));
var shadersCodeSourceROT13_1 = __webpack_require__(/*! ./shadersCodeSourceROT13 */ "./sdk/src/modules/videoEffect/shaders/shadersCodeSourceROT13.ts");
var BlurShader = /** @class */ (function (_super) {
    __extends(BlurShader, _super);
    function BlurShader(gl, width, height) {
        var _this = _super.call(this, gl) || this;
        _this.width = width;
        _this.height = height;
        _this.type = "BlurShader";
        _this.blurXProgram = null;
        _this.blurYProgram = null;
        _this.diffProgram = null;
        _this.uIntensity = null;
        _this.smoothIntensity = 0.5; // 0-1
        _this.blurTextureList = [];
        _this.blurBufferList = [];
        _this.blurXProgram = _this.makeProgram(shadersCodeSourceROT13_1.borderBlurVS, shadersCodeSourceROT13_1.borderBlurFS);
        _this.setBorderBlurProgram(_this.blurXProgram, 1 / (width || 1), 0);
        _this.blurYProgram = _this.makeProgram(shadersCodeSourceROT13_1.borderBlurVS, shadersCodeSourceROT13_1.borderBlurFS);
        _this.setBorderBlurProgram(_this.blurYProgram, 0, 1 / (height || 1));
        _this.diffProgram = _this.makeProgram(shadersCodeSourceROT13_1.diffBlurVS, shadersCodeSourceROT13_1.diffBlurFS);
        _this.setDiffBlurProgram(_this.diffProgram);
        _this.program = _this.makeProgram(shadersCodeSourceROT13_1.mixBlurVS, shadersCodeSourceROT13_1.mixBlurFS);
        _this.initBlurBuffer();
        return _this;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    BlurShader.prototype.setEffectConfig = function (config) {
        if (!isNaN(config.smoothIntensity)) {
            this.smoothIntensity = config.smoothIntensity / 100;
        }
    };
    BlurShader.prototype.render = function () {
        var gl = this.gl;
        gl.uniform1f(this.uIntensity, this.smoothIntensity);
    };
    BlurShader.prototype.initBlurBuffer = function () {
        var gl = this.gl;
        this.blurTextureList = [];
        this.blurTextureList = [];
        for (var index = 0; index < 3; index++) {
            // 
            var texture = gl.createTexture();
            if (!texture)
                return;
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            var frameBuffer = gl.createFramebuffer();
            if (!frameBuffer)
                return;
            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            this.blurTextureList.push(texture);
            this.blurBufferList.push(frameBuffer);
        }
    };
    BlurShader.prototype.renderPreTextures = function (vertex, vertexIndice, triangleTexCoords) {
        var _this = this;
        var gl = this.gl;
        var srcTextureUnits = [0, 1, 0];
        var distTextureUnits = [1, 1, 2];
        [this.blurXProgram, this.blurYProgram, this.diffProgram].forEach(function (program, index) {
            if (!program)
                return;
            gl.useProgram(program);
            var uTexture = gl.getUniformLocation(program, "uTexture");
            gl.uniform1i(uTexture, srcTextureUnits[index]);
            // vertex data
            var vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertex), gl.STATIC_DRAW);
            // indice data
            var vertexIndiceBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndiceBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertexIndice), gl.STATIC_DRAW);
            // set position attribute
            var aVertexPosition = gl.getAttribLocation(program, "aPosition");
            gl.enableVertexAttribArray(aVertexPosition);
            gl.vertexAttribPointer(aVertexPosition, 3, gl.FLOAT, false, 0, 0); // float 3 * 4 * 2
            // texture coordinate data
            var trianglesTexCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, trianglesTexCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangleTexCoords), gl.STATIC_DRAW);
            // set texture coordinate attribute
            var vertexTexCoordAttribute = gl.getAttribLocation(program, "aTexCoordinate");
            gl.enableVertexAttribArray(vertexTexCoordAttribute);
            gl.vertexAttribPointer(vertexTexCoordAttribute, 2, gl.FLOAT, false, 0, 0);
            gl.bindFramebuffer(gl.FRAMEBUFFER, _this.blurBufferList[index]);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            gl.activeTexture(gl.TEXTURE0 + distTextureUnits[index]);
            gl.bindTexture(gl.TEXTURE_2D, _this.blurTextureList[index]);
        });
    };
    BlurShader.prototype.setConstUniforms = function () {
        var width = this.width;
        var height = this.height;
        var program = this.program;
        if (!program)
            return;
        var gl = this.gl;
        gl.useProgram(program);
        var uTexBlurWidthOffset = gl.getUniformLocation(program, "widthOffset");
        gl.uniform1f(uTexBlurWidthOffset, 1 / width);
        var uTexBlurHeightOffset = gl.getUniformLocation(program, "heightOffset");
        gl.uniform1f(uTexBlurHeightOffset, 1 / height);
        this.uIntensity = gl.getUniformLocation(program, "blurAlpha");
        gl.uniform1f(this.uIntensity, this.smoothIntensity);
        var uBlurTexture = gl.getUniformLocation(program, "blurTexture");
        gl.uniform1i(uBlurTexture, 1);
        var uBlurDiffTexture = gl.getUniformLocation(program, "blurDiffTexture");
        gl.uniform1i(uBlurDiffTexture, 2);
    };
    BlurShader.prototype.setBorderBlurProgram = function (program, width, height) {
        var gl = this.gl;
        gl.useProgram(program);
        var uTexBlurWidthOffset = gl.getUniformLocation(program, "texBlurWidthOffset");
        gl.uniform1f(uTexBlurWidthOffset, width);
        var uTexBlurHeightOffset = gl.getUniformLocation(program, "texBlurHeightOffset");
        gl.uniform1f(uTexBlurHeightOffset, height);
    };
    BlurShader.prototype.setDiffBlurProgram = function (program) {
        var gl = this.gl;
        gl.useProgram(program);
        var uBlurTexture = gl.getUniformLocation(program, "blurTexture");
        gl.uniform1i(uBlurTexture, 1);
    };
    return BlurShader;
}(baseShader_1.default));
exports["default"] = BlurShader;


/***/ }),

/***/ "./sdk/src/modules/videoEffect/shaders/shadersCodeSourceROT13.ts":
/*!***********************************************************************!*\
  !*** ./sdk/src/modules/videoEffect/shaders/shadersCodeSourceROT13.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mixBlurFS = exports.mixBlurVS = exports.diffBlurFS = exports.diffBlurVS = exports.borderBlurFS = exports.borderBlurVS = exports.sharpnessFS = exports.sharpnessVS = exports.lightFS = exports.lightVS = void 0;
exports.lightVS = "cerpvfvba uvtuc sybng;\nnggevohgr irp2 nGrkPbbeqvangr;\nnggevohgr irp4 nCbfvgvba;\nhavsbez zng4 hCZIZngevk;\ninelvat irp2 iGrkPbbeq;\nibvq znva() {\n    ty_Cbfvgvba = hCZIZngevk * nCbfvgvba;\n    iGrkPbbeq = nGrkPbbeqvangr;\n}";
exports.lightFS = "cerpvfvba uvtuc sybng;\ninelvat irp2 iGrkPbbeq;\nhavsbez fnzcyre2Q hGrkgher;\nhavsbez sybng vagrafvgl;\nhavsbez sybng ebflVagrafvgl;\nirp3 oevtugarffNaqPbagenfg(irp3 pbybe){\n  sybng v = vagrafvgl * 1.0;\n  sybng CV = 3.1415926;\n  sybng O = 0.12 * v;\n  sybng p = 0.1 * v;\n  sybng x = gna((45. + 44. * p) / 180.0 * CV);\n  pbybe = ((pbybe*255.0 - 127.5 * (1.0 - O)) * x + 127.5 * (1.0 + O)) / 255.0;\n  erghea pbybe;\n}\nibvq znva() {\n  irp4 grkgherPbybe = grkgher2Q(hGrkgher, iGrkPbbeq);\n  grkgherPbybe = irp4(oevtugarffNaqPbagenfg(grkgherPbybe.eto), grkgherPbybe.j);\n  grkgherPbybe.e = zva(grkgherPbybe.e + 0.06 * ebflVagrafvgl, 1.0);\n  ty_SentPbybe = grkgherPbybe;\n}";
exports.sharpnessVS = "\nnggevohgr irp4 nCbfvgvba;\nnggevohgr irp4 nGrkPbbeqvangr;\nhavsbez sybng vzntrJvqguSnpgbe;\nhavsbez sybng vzntrUrvtugSnpgbe;\nhavsbez sybng funecarff; \ninelvat irp2 iGrkPbbeq;\ninelvat irp2 yrsgGrkgherPbbeqvangr;\ninelvat irp2 evtugGrkgherPbbeqvangr;\ninelvat irp2 gbcGrkgherPbbeqvangr;\ninelvat irp2 obggbzGrkgherPbbeqvangr;\ninelvat sybng pragreZhygvcyvre;\ninelvat sybng rqtrZhygvcyvre;\nibvq znva() {\n  ty_Cbfvgvba = nCbfvgvba;\n  irp2 jvqguFgrc = irp2(vzntrJvqguSnpgbe, 0.0);\n  irp2 urvtugFgrc = irp2(0.0, vzntrUrvtugSnpgbe);\n  iGrkPbbeq = nGrkPbbeqvangr.kl;\n  yrsgGrkgherPbbeqvangr = nGrkPbbeqvangr.kl - jvqguFgrc;\n  evtugGrkgherPbbeqvangr = nGrkPbbeqvangr.kl + jvqguFgrc;\n  gbcGrkgherPbbeqvangr = nGrkPbbeqvangr.kl + urvtugFgrc;\n  obggbzGrkgherPbbeqvangr = nGrkPbbeqvangr.kl - urvtugFgrc;\n  pragreZhygvcyvre = 1.0 + 4.0 * funecarff;\n  rqtrZhygvcyvre = funecarff;\n}\n";
exports.sharpnessFS = "\ncerpvfvba uvtuc sybng;\ninelvat uvtuc irp2 iGrkPbbeq;\ninelvat uvtuc irp2 yrsgGrkgherPbbeqvangr;\ninelvat uvtuc irp2 evtugGrkgherPbbeqvangr;\ninelvat uvtuc irp2 gbcGrkgherPbbeqvangr;\ninelvat uvtuc irp2 obggbzGrkgherPbbeqvangr;\ninelvat uvtuc sybng pragreZhygvcyvre;\ninelvat uvtuc sybng rqtrZhygvcyvre;\nhavsbez fnzcyre2Q hGrkgher;\nibvq znva() {\n  zrqvhzc irp4 nPbybe = grkgher2Q(hGrkgher, iGrkPbbeq);\n  zrqvhzc irp3 grkgherPbybe = nPbybe.eto;\n  zrqvhzc irp3 yrsgGrkgherPbybe = grkgher2Q(hGrkgher, yrsgGrkgherPbbeqvangr).eto;\n  zrqvhzc irp3 evtugGrkgherPbybe = grkgher2Q(hGrkgher, evtugGrkgherPbbeqvangr).eto;\n  zrqvhzc irp3 gbcGrkgherPbybe = grkgher2Q(hGrkgher, gbcGrkgherPbbeqvangr).eto;\n  zrqvhzc irp3 obggbzGrkgherPbybe = grkgher2Q(hGrkgher, obggbzGrkgherPbbeqvangr).eto;\n  ty_SentPbybe = irp4((grkgherPbybe * pragreZhygvcyvre - (yrsgGrkgherPbybe * rqtrZhygvcyvre + evtugGrkgherPbybe * rqtrZhygvcyvre + gbcGrkgherPbybe * rqtrZhygvcyvre + obggbzGrkgherPbybe * rqtrZhygvcyvre)), nPbybe.n);\n}";
exports.borderBlurVS = "nggevohgr irp4 nCbfvgvba;\nnggevohgr irp4 nGrkPbbeqvangr;\nhavsbez uvtuc sybng grkOyheJvqguBssfrg;\nhavsbez uvtuc sybng grkOyheUrvtugBssfrg;\ninelvat irp2 i_grkpbbeq0;\ninelvat irp4 grkgherFuvsg_1;\ninelvat irp4 grkgherFuvsg_2;\ninelvat irp4 grkgherFuvsg_3;\ninelvat irp4 grkgherFuvsg_4;\nibvq znva()\n{\n  ty_Cbfvgvba = nCbfvgvba;\n  i_grkpbbeq0 = nGrkPbbeqvangr.kl;\n\n  irp2 fvatyrFgrcBssfrg = irp2(grkOyheJvqguBssfrg, grkOyheUrvtugBssfrg)*2.5;\n\n  grkgherFuvsg_1 = irp4(nGrkPbbeqvangr.kl - fvatyrFgrcBssfrg, nGrkPbbeqvangr.kl + fvatyrFgrcBssfrg);\n  grkgherFuvsg_2 = irp4(nGrkPbbeqvangr.kl - 2.0 * fvatyrFgrcBssfrg, nGrkPbbeqvangr.kl + 2.0 * fvatyrFgrcBssfrg);\n  grkgherFuvsg_3 = irp4(nGrkPbbeqvangr.kl - 3.0 * fvatyrFgrcBssfrg, nGrkPbbeqvangr.kl + 3.0 * fvatyrFgrcBssfrg);\n  grkgherFuvsg_4 = irp4(nGrkPbbeqvangr.kl - 4.0 * fvatyrFgrcBssfrg, nGrkPbbeqvangr.kl + 4.0 * fvatyrFgrcBssfrg);\n}";
exports.borderBlurFS = "cerpvfvba zrqvhzc sybng;\nhavsbez fnzcyre2Q hGrkgher;\ninelvat irp2 i_grkpbbeq0;\ninelvat uvtuc irp4 grkgherFuvsg_1;\ninelvat uvtuc irp4 grkgherFuvsg_2;\ninelvat uvtuc irp4 grkgherFuvsg_3;\ninelvat uvtuc irp4 grkgherFuvsg_4;\nibvq znva(ibvq) { \n  zrqvhzc irp3 fhz = grkgher2Q(hGrkgher, i_grkpbbeq0).eto;\n  fhz += grkgher2Q(hGrkgher, grkgherFuvsg_1.kl).eto;\n  fhz += grkgher2Q(hGrkgher, grkgherFuvsg_1.mj).eto;\n  fhz += grkgher2Q(hGrkgher, grkgherFuvsg_2.kl).eto;\n  fhz += grkgher2Q(hGrkgher, grkgherFuvsg_2.mj).eto;\n  fhz += grkgher2Q(hGrkgher, grkgherFuvsg_3.kl).eto;\n  fhz += grkgher2Q(hGrkgher, grkgherFuvsg_3.mj).eto;\n  fhz += grkgher2Q(hGrkgher, grkgherFuvsg_4.kl).eto;\n  fhz += grkgher2Q(hGrkgher, grkgherFuvsg_4.mj).eto;\n  ty_SentPbybe = irp4(fhz * 0.1111, 1.0); \n}";
exports.diffBlurVS = "nggevohgr irp4 nCbfvgvba;\nnggevohgr irp4 nGrkPbbeqvangr;\nhavsbez zng4 hCZIZngevk;\ninelvat irp2 i_grkpbbeq0;\nibvq znva()\n{\n  // ty_Cbfvgvba = hCZIZngevk * nCbfvgvba;\n  ty_Cbfvgvba = nCbfvgvba;\n  i_grkpbbeq0 = nGrkPbbeqvangr.kl;\n}";
exports.diffBlurFS = "cerpvfvba zrqvhzc sybng;\nhavsbez fnzcyre2Q hGrkgher;\ninelvat irp2 i_grkpbbeq0;\nhavsbez fnzcyre2Q oyheGrkgher;\nibvq znva(ibvq) {\n  irp4 vPbybe = grkgher2Q(oyheGrkgher, i_grkpbbeq0);\n  irp4 zrnaPbybe = grkgher2Q(hGrkgher, i_grkpbbeq0);\n  irp4 qvssPbybe = vPbybe - zrnaPbybe;\n  qvssPbybe.e = zva(qvssPbybe.e * 50.0 * qvssPbybe.e, 1.0);\n  qvssPbybe.t = zva(qvssPbybe.t * 50.0 * qvssPbybe.t, 1.0);\n  qvssPbybe.o = zva(qvssPbybe.o * 50.0 * qvssPbybe.o, 1.0);\n  ty_SentPbybe = irp4(qvssPbybe.eto, 1.0);\n}";
exports.mixBlurVS = "\nnggevohgr irp4 nCbfvgvba;\nnggevohgr irp4 nGrkPbbeqvangr;\ninelvat irp2 i_grkpbbeq0;\nhavsbez sybng jvqguBssfrg;\nhavsbez sybng urvtugBssfrg;\ninelvat irp2 grkgherFuvsg_1;\ninelvat irp2 grkgherFuvsg_2;\ninelvat irp2 grkgherFuvsg_3;\ninelvat irp2 grkgherFuvsg_4;\nibvq znva()\n{\n  ty_Cbfvgvba = nCbfvgvba;\n  i_grkpbbeq0 = nGrkPbbeqvangr.kl;\n  grkgherFuvsg_1 = irp2(i_grkpbbeq0 + 0.5 * irp2(jvqguBssfrg,urvtugBssfrg));\n  grkgherFuvsg_2 = irp2(i_grkpbbeq0 + 0.5 * irp2(-jvqguBssfrg,-urvtugBssfrg));\n  grkgherFuvsg_3 = irp2(i_grkpbbeq0 + 0.5 * irp2(-jvqguBssfrg,urvtugBssfrg));\n  grkgherFuvsg_4 = irp2(i_grkpbbeq0 + 0.5 * irp2(jvqguBssfrg,-urvtugBssfrg));\n}\n";
exports.mixBlurFS = "\ncerpvfvba zrqvhzc sybng;\nhavsbez fnzcyre2Q hGrkgher;\ninelvat irp2 i_grkpbbeq0;\nhavsbez fnzcyre2Q oyheGrkgher;\nhavsbez fnzcyre2Q oyheQvssGrkgher;\nhavsbez ybjc sybng oyheNycun;\nibvq znva(ibvq) {\n  ybjc irp4 vPbybe = grkgher2Q(hGrkgher, i_grkpbbeq0);\n  ybjc irp4 zrnaPbybe = grkgher2Q(oyheGrkgher, i_grkpbbeq0);\n  ybjc irp4 inePbybe = grkgher2Q(oyheQvssGrkgher, i_grkpbbeq0);\n  ybjc sybng nycun = oyheNycun * 1.0;\n  ybjc sybng gurgn = 0.1;\n  zrqvhzc sybng c = pynzc((zva(vPbybe.e, zrnaPbybe.e - 0.1) - 0.2) * 4.0, 0.0, 1.0);\n  zrqvhzc sybng zrnaIne = znk(znk(inePbybe.e, inePbybe.t), inePbybe.o);\n  zrqvhzc sybng xZva = 0.1;\n  ybjc irp3 erfhygPbybe;\n  xZva = (1.0 - zrnaIne / (zrnaIne + gurgn)) * c * nycun;\n  erfhygPbybe = zvk(vPbybe.eto, zrnaPbybe.eto, xZva);\n  erfhygPbybe = zvk(vPbybe.eto, erfhygPbybe, zva(1.0,nycun));\n  ty_SentPbybe = irp4(erfhygPbybe,1.0);\n}";


/***/ }),

/***/ "./sdk/src/modules/videoEffect/shaders/sharpnessShader.ts":
/*!****************************************************************!*\
  !*** ./sdk/src/modules/videoEffect/shaders/sharpnessShader.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var baseShader_1 = __importDefault(__webpack_require__(/*! ./baseShader */ "./sdk/src/modules/videoEffect/shaders/baseShader.ts"));
var shadersCodeSourceROT13_1 = __webpack_require__(/*! ./shadersCodeSourceROT13 */ "./sdk/src/modules/videoEffect/shaders/shadersCodeSourceROT13.ts");
var SharpnessShader = /** @class */ (function (_super) {
    __extends(SharpnessShader, _super);
    function SharpnessShader(gl, width, height) {
        var _this = _super.call(this, gl) || this;
        _this.width = width;
        _this.height = height;
        _this.type = "SharpnessShader";
        _this.uIntensity = null;
        _this.sharpenIntensity = 0.5; // 0-1
        _this.program = _this.makeProgram(shadersCodeSourceROT13_1.sharpnessVS, shadersCodeSourceROT13_1.sharpnessFS);
        return _this;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    SharpnessShader.prototype.setEffectConfig = function (config) {
        if (!isNaN(config.sharpenIntensity)) {
            this.sharpenIntensity = config.sharpenIntensity / 100;
        }
    };
    SharpnessShader.prototype.render = function () {
        var gl = this.gl;
        gl.uniform1f(this.uIntensity, this.sharpenIntensity * 0.5);
    };
    SharpnessShader.prototype.setConstUniforms = function () {
        var width = this.width;
        var height = this.height;
        var program = this.program;
        if (!program)
            return;
        var gl = this.gl;
        gl.useProgram(program);
        var uWidth = gl.getUniformLocation(program, "imageWidthFactor");
        gl.uniform1f(uWidth, 1 / width);
        var uHeight = gl.getUniformLocation(program, "imageHeightFactor");
        gl.uniform1f(uHeight, 1 / height);
        this.uIntensity = gl.getUniformLocation(program, "sharpness");
        gl.uniform1f(this.uIntensity, this.sharpenIntensity * 0.5);
    };
    return SharpnessShader;
}(baseShader_1.default));
exports["default"] = SharpnessShader;


/***/ }),

/***/ "./sdk/src/modules/videoEffect/videoEffect.ts":
/*!****************************************************!*\
  !*** ./sdk/src/modules/videoEffect/videoEffect.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PUBLISH_SET_BEAUTY_EFFECT = void 0;
var performanceDetector_1 = __importDefault(__webpack_require__(/*! ./performanceDetector */ "./sdk/src/modules/videoEffect/performanceDetector.ts"));
var effectManager_1 = __importDefault(__webpack_require__(/*! ./effectManager */ "./sdk/src/modules/videoEffect/effectManager.ts"));
exports.PUBLISH_SET_BEAUTY_EFFECT = "zc.p.0.sbe.1";
var VideoEffectProcessor = /** @class */ (function () {
    function VideoEffectProcessor(logger, input) {
        this.logger = logger;
        this.kind = "video";
        this._enabled = false;
        this.lastRenderTime = 0;
        this.animationFrameId = 0;
        this.backgroundLoop = null;
        this.setInput(input, true);
        this.fps = 15;
        this.detector = new performanceDetector_1.default(logger);
        this.backgroundLoop && clearTimeout(this.backgroundLoop);
        this.backgroundLoop = null;
        this.lastRenderTime = 0;
        this.manager = new effectManager_1.default(logger);
    }
    Object.defineProperty(VideoEffectProcessor.prototype, "enabled", {
        get: function () {
            return this._enabled;
        },
        set: function (val) {
            this._enabled = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VideoEffectProcessor.prototype, "output", {
        get: function () {
            return this._output;
        },
        enumerable: false,
        configurable: true
    });
    VideoEffectProcessor.prototype.setBeautyEffectOptions = function (enable, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        //  options
                        enable && this.manager.setEffectConfig(options);
                        if (!(this.enabled !== enable)) return [3 /*break*/, 6];
                        this.manager.setEnableBeauty(enable);
                        this.enabled !== enable &&
                            this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT +
                                " effect enabled " +
                                enable +
                                "; options: " +
                                JSON.stringify(options));
                        this.enabled = enable;
                        if (!enable) return [3 /*break*/, 3];
                        _b = this.input;
                        if (!_b) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.startEffect()];
                    case 1:
                        _b = (_c.sent());
                        _c.label = 2;
                    case 2:
                        _a = _b;
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, this.stopEffect()];
                    case 4:
                        _a = _c.sent();
                        _c.label = 5;
                    case 5:
                        _a;
                        _c.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    VideoEffectProcessor.prototype.startEffect = function () {
        return __awaiter(this, void 0, void 0, function () {
            var effectTrack, render;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " call start effect");
                        // const a = V();
                        if (!this.input) {
                            this.logger.error(exports.PUBLISH_SET_BEAUTY_EFFECT + " start effect failed, input track is null");
                            return [2 /*return*/];
                        }
                        if (this.input && this.output && this.input !== this.output) {
                            this.logger.warn(exports.PUBLISH_SET_BEAUTY_EFFECT + " video effect is already enabled");
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, this.startWebGLProcessor()];
                    case 1:
                        effectTrack = _a.sent();
                        // this.input.enabled = true;
                        return [4 /*yield*/, this.updateOutput(effectTrack)];
                    case 2:
                        // this.input.enabled = true;
                        _a.sent();
                        this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " start effect success");
                        this.detector.startRecordBeautyEffectOutput(this.fps).then(function (result) {
                            if (!result.result && _this.onOverload) {
                                var targetFPS = result.targetFPS, currentFPS = result.currentFPS;
                                _this.onOverload({
                                    targetFPS: targetFPS,
                                    currentFPS: currentFPS
                                });
                            }
                        });
                        render = function () { return __awaiter(_this, void 0, void 0, function () {
                            var currentTime, interFrameTime, realInterFrameTime;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        this.enabled && (this.animationFrameId = requestAnimationFrame(render));
                                        currentTime = Date.now(), interFrameTime = 1e3 / this.fps, realInterFrameTime = this.lastRenderTime
                                            ? currentTime - this.lastRenderTime
                                            : interFrameTime;
                                        if (!(realInterFrameTime >= interFrameTime)) return [3 /*break*/, 2];
                                        this.lastRenderTime =
                                            currentTime - (realInterFrameTime - interFrameTime);
                                        this.videoEl && this.videoEl.paused && this.videoEl.play();
                                        if (!(this.enabled && this.videoEl)) return [3 /*break*/, 2];
                                        return [4 /*yield*/, this.manager.render(this.videoEl)];
                                    case 1:
                                        _a.sent();
                                        // @ts-ignore
                                        this.output && this.output.requestFrame && this.output.requestFrame();
                                        this.detector.addFrame();
                                        _a.label = 2;
                                    case 2: return [2 /*return*/];
                                }
                            });
                        }); };
                        this.animationFrameId = requestAnimationFrame(render);
                        document.addEventListener("visibilitychange", function () {
                            if (document.hidden) {
                                var activeFrame_1 = function () {
                                    _this.enabled && _this.videoEl && _this.manager.render(_this.videoEl);
                                    _this.output &&
                                        //@ts-ignore
                                        _this.output.requestFrame &&
                                        //@ts-ignore
                                        _this.output.requestFrame();
                                    _this.detector.addFrame();
                                    _this.backgroundLoop = window.setTimeout(activeFrame_1, Math.floor(1e3 / _this.fps));
                                };
                                activeFrame_1();
                            }
                            else {
                                if (_this.backgroundLoop) {
                                    clearTimeout(_this.backgroundLoop);
                                    _this.backgroundLoop = null;
                                }
                            }
                        }, false);
                        return [2 /*return*/];
                }
            });
        });
    };
    VideoEffectProcessor.prototype.stopEffect = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " call stop effect");
                        if (this.animationFrameId) {
                            cancelAnimationFrame(this.animationFrameId);
                            this.animationFrameId = 0;
                        }
                        this.detector.stopRecordBeautyEffectOutput();
                        this.manager.release();
                        return [4 /*yield*/, this.updateOutput()];
                    case 1:
                        _a.sent();
                        if (this.removeDomTimer === undefined) {
                            this.removeDomTimer = window.setTimeout(function () {
                                if (_this.enabled === false) {
                                    _this.destroy();
                                }
                            }, 3 * 60 * 1e3);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    VideoEffectProcessor.prototype.destroy = function () {
        this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " destroy hidden elements");
        this.canvasEl && this.canvasEl.remove();
        this.videoEl && this.videoEl.remove();
        this.videoEl = this.canvasEl = undefined;
        if (this.removeDomTimer) {
            clearTimeout(this.removeDomTimer);
            this.removeDomTimer = undefined;
        }
    };
    VideoEffectProcessor.prototype.startWebGLProcessor = function () {
        return __awaiter(this, void 0, void 0, function () {
            var waitVideoPlaying, videoSettings, width, height;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.input) {
                            this.logger.error(exports.PUBLISH_SET_BEAUTY_EFFECT + " input track is null");
                            return [2 /*return*/];
                        }
                        this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " start webgl processor");
                        //  dom  
                        if (this.removeDomTimer) {
                            clearTimeout(this.removeDomTimer);
                            this.removeDomTimer = undefined;
                        }
                        if (!(!this.canvasEl || !this.videoEl)) return [3 /*break*/, 2];
                        this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " create elements");
                        this.canvasEl && (this.canvasEl.remove(), (this.canvasEl = undefined));
                        this.videoEl && (this.videoEl.remove(), (this.videoEl = undefined));
                        this.canvasEl = document.createElement("canvas");
                        // const warp = document.getElementsByClassName("container-fluid");
                        // warp[0].appendChild(this.canvasEl);
                        this.videoEl = document.createElement("video");
                        // warp[0].appendChild(this.videoEl);
                        this.videoEl.setAttribute("autoplay", "");
                        this.videoEl.setAttribute("muted", "");
                        this.videoEl.muted = !0;
                        this.videoEl.setAttribute("playsinline", "");
                        this.videoEl.setAttribute("style", "display:none");
                        this.videoEl.srcObject = new MediaStream([this.input]);
                        waitVideoPlaying = new Promise(function (resolve) {
                            var playingHandler = function () {
                                _this.videoEl &&
                                    _this.videoEl.removeEventListener("playing", playingHandler);
                                resolve(void 0);
                            };
                            _this.videoEl &&
                                _this.videoEl.addEventListener("playing", playingHandler);
                        });
                        this.videoEl.play();
                        return [4 /*yield*/, waitVideoPlaying];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        videoSettings = this.input.getSettings();
                        width = videoSettings.width || this.videoEl.videoWidth, height = videoSettings.height || this.videoEl.videoHeight;
                        if (videoSettings.frameRate && this.fps !== videoSettings.frameRate) {
                        }
                        if (videoSettings.frameRate && this.fps !== videoSettings.frameRate) {
                            this.fps = videoSettings.frameRate;
                            this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " set target fps: " + this.fps);
                        }
                        this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT +
                            " beauty video processor: width " +
                            videoSettings.width +
                            " height " +
                            videoSettings.height);
                        if (!width || !height) {
                            this.logger.error(exports.PUBLISH_SET_BEAUTY_EFFECT + " resolution of track is wrong");
                            return [2 /*return*/];
                        }
                        this.canvasEl.width = width;
                        this.canvasEl.height = height;
                        this.videoEl.setAttribute("width", width.toString());
                        this.videoEl.setAttribute("height", height.toString());
                        this.manager.init(width, height, this.canvasEl);
                        // @ts-ignore
                        return [2 /*return*/, this.canvasEl.captureStream().getVideoTracks()[0]];
                }
            });
        });
    };
    VideoEffectProcessor.prototype.setInput = function (videoTrack, isFirst) {
        if (isFirst === void 0) { isFirst = false; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!(videoTrack !== this.input)) return [3 /*break*/, 6];
                        if (videoTrack.kind !== this.kind) {
                            this.logger.error(exports.PUBLISH_SET_BEAUTY_EFFECT + " kind of track is not video");
                            return [2 /*return*/];
                        }
                        if (this.output && this.input === this.output) {
                            this.logger.error(exports.PUBLISH_SET_BEAUTY_EFFECT + " input track is same as effect track");
                        }
                        this.logger.info(exports.PUBLISH_SET_BEAUTY_EFFECT + " change input track");
                        if (!isFirst) return [3 /*break*/, 5];
                        _a = this.input;
                        if (!_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.removeInput()];
                    case 1:
                        _a = (_c.sent());
                        _c.label = 2;
                    case 2:
                        _a;
                        this.input = videoTrack;
                        _b = this.enabled && !this.videoEl;
                        if (!_b) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.startEffect()];
                    case 3:
                        _b = (_c.sent());
                        _c.label = 4;
                    case 4:
                        _b;
                        return [3 /*break*/, 6];
                    case 5:
                        this.input = videoTrack;
                        this.videoEl &&
                            (this.videoEl.srcObject = new MediaStream([this.input]));
                        _c.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    VideoEffectProcessor.prototype.removeInput = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.input = undefined;
                        return [4 /*yield*/, this.stopEffect()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    VideoEffectProcessor.prototype.updateOutput = function (track) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(this.output !== track)) return [3 /*break*/, 3];
                        // let enabled = true;
                        // if (track) {
                        //   enabled = track.enabled;
                        // }
                        this._output = track;
                        _a = this.onOutputChange;
                        if (!_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.onOutputChange(this._output)];
                    case 1:
                        _a = (_b.sent());
                        _b.label = 2;
                    case 2:
                        _a;
                        _b.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    VideoEffectProcessor.prototype.onOutputChange = function (track) {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2 /*return*/];
        }); });
    };
    VideoEffectProcessor.prototype.onOverload = function (config) { };
    return VideoEffectProcessor;
}());
exports["default"] = VideoEffectProcessor;


/***/ }),

/***/ "./sdk/src/util/client-util.ts":
/*!*************************************!*\
  !*** ./sdk/src/util/client-util.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientUtil = void 0;
var zego_entity_1 = __webpack_require__(/*! ../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var zego_log_event_1 = __webpack_require__(/*! ../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var checkModule_1 = __webpack_require__(/*! ../webrtc/modules/externModules/checkModule */ "./sdk/src/webrtc/modules/externModules/checkModule.ts");
var ClientUtil = /** @class */ (function () {
    function ClientUtil() {
    }
    ClientUtil.checkIllegalCharacters = function (str) {
        // const reg = /^(?=.*[a-zA-Z\d~!@#$%^&amp;*()_+`\-={}:";'&lt;&gt;?,.\/]).{1,256}$/;
        var reg = /^([0-9a-zA-Z#!$%&()`'+-;<=.>@^_~,\\*])+$/;
        var reg2 = /^[^:/]*$/g;
        return reg.test(str) && reg2.test(str);
    };
    ClientUtil.isUrl = function (str) {
        if (str.startsWith("rtmp://") ||
            (str.startsWith("https://") && str.endsWith(".flv")) ||
            (str.startsWith("https://") && str.endsWith(".m3u8"))) {
            return true;
        }
        return false;
    };
    ClientUtil.registerCallback = function (fName, option, callbackList) {
        var sf, ef;
        if (option.success) {
            sf = option.success;
            callbackList[fName + "SuccessCallback"] = sf;
        }
        if (option.error) {
            ef = option.error;
            callbackList[fName + "ErrorCallback"] = ef;
        }
    };
    ClientUtil.actionErrorCallback = function (fName, callbackList) {
        return callbackList[fName + "ErrorCallback"];
    };
    // 
    ClientUtil.actionSuccessCallback = function (fName, callbackList) {
        return callbackList[fName + "SuccessCallback"];
    };
    ClientUtil.logReportCallback = function (logEvent, dataReport, reportSeq, callbackList) {
        ClientUtil.registerCallback(logEvent, {
            success: function (reportName, eventName) {
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    args[_i - 2] = arguments[_i];
                }
                ClientUtil.dataReportEvent(dataReport, reportSeq, reportName, eventName, args);
            }
        }, callbackList);
    };
    ClientUtil.actionLogReportCallback = function (logEvent, callbackList, reportAction, eventName, args) {
        ClientUtil.actionSuccessCallback(logEvent, callbackList) &&
            ClientUtil.actionSuccessCallback(logEvent, callbackList)(reportAction, eventName);
    };
    ClientUtil.getServerError = function (code) {
        var serverErrorList = {
            1: "parse json error.",
            1001: "login is processing.",
            1002: "liveroom request error.",
            1003: "zpush connect fail.",
            1004: "zpush handshake fail.",
            1005: "zpush login fail.",
            1006: "user login state is wrong.",
            1007: "got no zpush addr",
            1008: "token error",
            1009: "dispatch error",
            1010: "token expired",
            1011: "token format error",
            2002: "biz channel error",
            1000000000: "liveroom cmd error, code:",
            1000002001: "need relogin",
            1000002002: "third token auth error",
            1000002003: "token nonce type should be int64",
            1000002004: "token appid type  should be uint32",
            1000002005: "token timeout type should be int64",
            1000002006: "token user_id type should be string",
            1000002007: "token room_id type should be string",
            1000002008: "token format error",
            1000002009: "token privilege type should be map",
            1000002010: "token expire_time type should be int64",
            1000002011: "token user_id type should be string",
            1000002012: "token not exist",
            1000002013: "token update error",
            1000002014: "token not need to check"
        };
        if (code === 0) {
            return {
                code: 0,
                message: ""
            };
        }
        var err = {
            code: 0,
            message: "liveroom cmd error"
        };
        err.code = code;
        if (code > 1000000000) {
            var errMsg = serverErrorList[code];
            if (errMsg) {
                err.message =
                    "liveroom cmd error, code: " + code + ", message: " + errMsg;
            }
            else {
                err.message = serverErrorList[1000000000] + code;
            }
        }
        else if (serverErrorList[code]) {
            //@ts-ignore
            err.message = serverErrorList[code] + " code:" + code;
        }
        else {
            err.message = "unknown error code:" + code;
        }
        return err;
    };
    ClientUtil.unregisterCallback = function (fName, callbackList) {
        delete callbackList[fName + "SuccessCallback"];
        delete callbackList[fName + "ErrorCallback"];
    };
    ClientUtil.decodeServerError = function (code, msg) {
        var err = {
            code: -1,
            message: "server error"
        };
        if (code > 1000000000) {
            err.code = code - 1000000000 + 52000000;
        }
        msg && (err.message = msg);
        return err;
    };
    ClientUtil.getLiveRoomError = function (code) {
        var prefix = 1000000000;
        var liveRoomErrMap = {
            1105: "ROOM_MAX_USER_COUNT",
            1012: "PUBLISHER_ERROR_REPETITIVE_PUBLISH_STREAM",
            // 2002: 'ROOM_ERROR_AUTHENTICATION_FAILED',
            2002: "TOKEN_ERROR",
            2003: "ROOM_ERROR_LOGIN_TIMEOUT",
            2010: "TOKEN_ERROR" // token expire_time type should be int64
        };
        var accessSvrErrMap = {
            1: "PARSE_JSON_ERROR",
            1001: "LOGIN_PROCESSING",
            1002: "LIVEROMM_REQUEST_ERROR",
            1003: "ZPUSH_REQUEST_FAIL",
            1004: "ZPUSH_REQUEST_FAIL",
            1005: "ZPUSH_REQUEST_FAIL",
            1006: "LOGIN_STATE_WRONG",
            1007: "ZPUSH_REQUEST_FAIL",
            1008: "TOKEN_ERROR",
            1009: "DIAPATCH_ERROR",
            1010: "TOKEN_EXPIRED",
            1011: "TOKEN_ERROR",
            1012: "SUBCMD_ERROR",
            1101: "ZEGO_AUTH_ERROR",
            2001: "BIZ_CHANNEL_ERROR",
            2002: "BIZ_CHANNEL_ERROR"
        };
        if (code > 1000000000) {
            return liveRoomErrMap[code - prefix] || "";
        }
        else {
            return accessSvrErrMap[code] || "ROOM_INNER_ERROR";
        }
    };
    ClientUtil.getKickoutError = function (code) {
        var err = {};
        switch (code) {
            case 1:
                err.code = 63000001;
                err.message = "zpush multiple login kickout";
                err.name = "MULTIPLE_LOGIN_KICKOUT";
                break;
            case 2:
                err.code = 63000002;
                err.message = "zpush manual kickout";
                err.name = "MANUAL_KICKOUT";
                break;
            case 3:
                err.code = 63000003;
                err.message = "kickout reason = " + code;
                break;
            case 4:
                err.code = 63000004;
                err.message = "zpush multiple login kickout";
                err.name = "MULTIPLE_LOGIN_KICKOUT";
                break;
            case 5:
                err.code = 63000005;
                err.message = "zpush token expired";
                err.name = "TOKEN_EXPIRED";
                break;
            default:
                err.code = code;
                err.message = "kickout reason = " + code;
                break;
        }
        return err;
    };
    ClientUtil.dataReportEvent = function (dataReport, reportSeq, reportName, eventName, args) {
        switch (reportName) {
            case "eventStart":
                dataReport.eventStart(reportSeq, eventName);
                break;
            case "eventEndWithMsgInfo":
                dataReport.eventEndWithMsgInfo(reportSeq, eventName, args[0]);
                break;
            case "addEventMsg":
                dataReport.addEventMsg(reportSeq, eventName, args[0], args[1]);
                break;
            case "addEvent":
                dataReport.addEvent(reportSeq, eventName);
                break;
            case "eventEnd":
                dataReport.eventEnd(reportSeq, eventName);
                break;
            case "addMsgInfo":
                dataReport.addMsgInfo(reportSeq, args[0]);
                break;
            default:
                break;
        }
    };
    ClientUtil.isKeepTryLogin = function (code) {
        switch (code) {
            case 1002: //liveroom connect error
            case 1003: //zpush connect error
                return true;
            default:
                return false;
        }
    };
    ClientUtil.mergeStreamList = function (idName, oldStreamList, newStreamList, callbackResult) {
        var addStreamList = [];
        var delStreamList = [];
        var updateStreamList = [];
        var flag;
        if (!newStreamList) {
            newStreamList = [];
        }
        for (var i = 0; i < newStreamList.length; i++) {
            if (newStreamList[i].anchor_id_name == idName ||
                newStreamList[i].id_name == idName ||
                newStreamList[i].user_id == idName) {
                continue;
            }
            flag = false;
            for (var j = 0; j < oldStreamList.length; j++) {
                if (newStreamList[i].stream_id === oldStreamList[j].stream_id) {
                    if (newStreamList[i].extra_info !== oldStreamList[j].extra_info) {
                        updateStreamList.push(newStreamList[i]);
                    }
                    flag = true;
                    break;
                }
            }
            if (!flag) {
                addStreamList.push(newStreamList[i]);
            }
        }
        for (var k = 0; k < oldStreamList.length; k++) {
            flag = false;
            for (var n = 0; n < newStreamList.length; n++) {
                if (oldStreamList[k].stream_id === newStreamList[n].stream_id) {
                    flag = true;
                    break;
                }
            }
            if (!flag) {
                delStreamList.push(oldStreamList[k]);
            }
        }
        oldStreamList.splice(0);
        for (var i = 0; i < newStreamList.length; i++) {
            oldStreamList.push(newStreamList[i]);
        }
        callbackResult(addStreamList, delStreamList, updateStreamList);
    };
    ClientUtil.checkInteger = function (num, positive) {
        if (positive == false)
            return typeof num === "number" && num % 1 === 0 && num >= 0;
        return typeof num === "number" && num % 1 === 0 && num > 0;
    };
    ClientUtil.checkValidNumber = function (param, min, max) {
        min = min || 1;
        max = max || 1 * 1e4;
        return (typeof param === "number" &&
            param % 1 == 0 &&
            param >= min &&
            param <= max);
    };
    //
    ClientUtil.uuid = function (len, radix) {
        var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");
        var uuid = [];
        var i;
        radix = radix || chars.length;
        if (len) {
            // Compact form
            for (i = 0; i < len; i++)
                uuid[i] = chars[0 | (Math.random() * radix)];
        }
        else {
            // rfc4122, version 4 form
            var r = void 0;
            // rfc4122 requires these characters
            uuid[8] = uuid[13] = uuid[18] = uuid[23] = "-";
            uuid[14] = "4";
            // Fill in random data. At i==19 set the high bits of clock sequence as
            // per rfc4122, sec. 4.1.5
            for (i = 0; i < 36; i++) {
                if (!uuid[i]) {
                    r = 0 | (Math.random() * 16);
                    uuid[i] = chars[i == 19 ? (r & 0x3) | 0x8 : r];
                }
            }
        }
        return uuid.join("");
    };
    ClientUtil.supportDetection = function (screenShotReady, success, checkLevel, type) {
        return __awaiter(this, void 0, void 0, function () {
            var result, videoEle, hasGetUserMedia, isOutRule, video, err_1, audio, err_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        result = {
                            webRTC: false,
                            customCapture: false,
                            camera: false,
                            microphone: false,
                            videoCodec: {
                                H264: false,
                                H265: false,
                                VP8: false,
                                VP9: false
                            },
                            screenSharing: screenShotReady,
                            errInfo: {}
                        };
                        if (type && type === "screenSharing") {
                            success({
                                result: screenShotReady,
                                errInfo: result.errInfo
                            });
                            return [2 /*return*/];
                        }
                        if (!type || type === "customCapture") {
                            videoEle = document.createElement("video");
                            // @ts-ignore
                            if (videoEle["captureStream"] || videoEle["mozCaptureStream"]) {
                                result.customCapture = true;
                            }
                            if (type === "customCapture") {
                                success({
                                    result: result.customCapture,
                                    errInfo: result.errInfo
                                });
                                return [2 /*return*/];
                            }
                        }
                        hasGetUserMedia = navigator &&
                            navigator.mediaDevices &&
                            navigator.mediaDevices.getUserMedia;
                        isOutRule = window.location.protocol !== "https:" &&
                            window.location.protocol !== "file:" &&
                            window.location.hostname.indexOf("127.0.0.1") == -1 &&
                            window.location.hostname.indexOf("localhost") == -1;
                        if (!(!type || type === "camera" || type === "microphone")) return [3 /*break*/, 9];
                        if (!!!hasGetUserMedia) return [3 /*break*/, 9];
                        if (!isOutRule) return [3 /*break*/, 1];
                        result.camera = false;
                        console.error("webrtc requires https or localhost");
                        return [3 /*break*/, 9];
                    case 1:
                        if (!(!type || type === "camera")) return [3 /*break*/, 5];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, navigator.mediaDevices.getUserMedia({
                                video: true
                            })];
                    case 3:
                        video = _a.sent();
                        video &&
                            (result.camera = true) &&
                            video.getTracks().forEach(function (track) { return track.stop(); });
                        return [3 /*break*/, 5];
                    case 4:
                        err_1 = _a.sent();
                        result.errInfo.camera = {
                            name: err_1.name,
                            message: err_1.message
                        };
                        console.error("camera devices detect error: ", err_1.name, err_1.message);
                        return [3 /*break*/, 5];
                    case 5:
                        if (!(!type || type === "microphone")) return [3 /*break*/, 9];
                        _a.label = 6;
                    case 6:
                        _a.trys.push([6, 8, , 9]);
                        return [4 /*yield*/, navigator.mediaDevices.getUserMedia({
                                audio: true
                            })];
                    case 7:
                        audio = _a.sent();
                        audio &&
                            (result.microphone = true) &&
                            audio.getTracks().forEach(function (track) { return track.stop(); });
                        return [3 /*break*/, 9];
                    case 8:
                        err_2 = _a.sent();
                        result.errInfo.microphone = {
                            name: err_2.name,
                            message: err_2.message
                        };
                        console.error("microphone devices detect error: ", err_2.name, err_2.message);
                        return [3 /*break*/, 9];
                    case 9:
                        if (type === "camera" || type === "microphone") {
                            success({
                                result: result[type],
                                errInfo: result.errInfo
                            });
                            return [2 /*return*/];
                        }
                        this.supportVideoCodeType(function (rtcCodec, err) {
                            if (!type) {
                                result.videoCodec.H264 = rtcCodec.H264;
                                result.videoCodec.H265 = rtcCodec.H265;
                                result.videoCodec.VP8 = rtcCodec.VP8;
                                result.videoCodec.VP9 = rtcCodec.VP9;
                                result.webRTC = rtcCodec.webRTC;
                            }
                            if (err) {
                                if (typeof err === "string") {
                                    result.errInfo.extendedDate = err;
                                }
                                else {
                                    result.errInfo.webRTC = {
                                        name: err.name,
                                        message: err.message
                                    };
                                }
                                console.error("videoCodec detect error: " + err);
                            }
                            success &&
                                success(!type
                                    ? result
                                    : {
                                        result: rtcCodec[type],
                                        errInfo: result.errInfo
                                    });
                        }, checkLevel, type);
                        return [2 /*return*/];
                }
            });
        });
    };
    ClientUtil.getDevices = function (deviceInfoCallback, error) {
        if (navigator.mediaDevices === undefined ||
            navigator.mediaDevices.enumerateDevices === undefined) {
            if (error) {
                error(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskEnumDevices.error.kBrowserNotSupportError);
            }
            return;
        }
        navigator.mediaDevices
            .enumerateDevices()
            .then(function (deviceInfos) {
            var microphone = [];
            var speaker = [];
            var camera = [];
            for (var i = 0; i < deviceInfos.length; i++) {
                var deviceInfo = deviceInfos[i];
                if (deviceInfo.kind === "audioinput") {
                    microphone.push({
                        deviceName: deviceInfo.label,
                        deviceID: deviceInfo.deviceId
                    });
                }
                if (deviceInfo.kind === "audiooutput") {
                    speaker.push({
                        deviceName: deviceInfo.label,
                        deviceID: deviceInfo.deviceId
                    });
                }
                if (deviceInfo.kind === "videoinput") {
                    camera.push({
                        deviceName: deviceInfo.label,
                        deviceID: deviceInfo.deviceId
                    });
                }
            }
            if (deviceInfoCallback) {
                deviceInfoCallback({
                    microphones: microphone,
                    speakers: speaker,
                    cameras: camera
                });
            }
        })
            .catch(function (err) {
            console.error("enumerate devices wrong " + err);
            error &&
                error(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskEnumDevices.error.kEnumDevicesError);
        });
    };
    ClientUtil.compareVersion = function (v1, v2) {
        v1 = v1.split(".");
        v2 = v2.split(".");
        var len = Math.max(v1.length, v2.length);
        while (v1.length < len) {
            v1.push("0");
        }
        while (v2.length < len) {
            v2.push("0");
        }
        for (var i = 0; i < len; i++) {
            var num1 = parseInt(v1[i]);
            var num2 = parseInt(v2[i]);
            if (num1 > num2) {
                return 1;
            }
            else if (num1 < num2) {
                return -1;
            }
        }
        return 0;
    };
    ClientUtil.isSupportLive = function (sucCall, errCall) {
        var resultList = {
            10001: "",
            10002: ""
        };
        var version = wx.getSystemInfoSync().SDKVersion;
        var res = {
            code: 0,
            msg: ""
        };
        if (this.compareVersion(version, "1.7.0") < 0) {
            res = {
                code: 10001,
                msg: resultList[10001]
            };
            sucCall && sucCall(res);
        }
        wx.getSetting({
            success: function (_a) {
                var authSetting = _a.authSetting;
                if (!authSetting["scope.camera"] || !authSetting["scope.record"]) {
                    res = {
                        code: 10002,
                        msg: resultList[10002]
                    };
                }
                sucCall && sucCall(res);
            },
            fail: function (err) {
                console.error("get setting error", err);
                errCall && errCall(err);
            }
        });
    };
    ClientUtil.supportVideoCodeType = function (sucCall, checkLevel, type) {
        return __awaiter(this, void 0, void 0, function () {
            var rtcCodec, checkModule, res, e_1, errorInfo_1, allType_2, promiseList, _i, allType_1, allTypeItem, checkModule;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        rtcCodec = {
                            webRTC: false,
                            H264: false,
                            VP8: false,
                            VP9: false,
                            H265: false
                        };
                        if (!type) return [3 /*break*/, 2];
                        if (!(checkLevel === 1 && (type === "VP8" || type === "H264"))) return [3 /*break*/, 2];
                        checkModule = new checkModule_1.CheckModule();
                        return [4 /*yield*/, checkModule.checkSupportByType(type)];
                    case 1:
                        res = _a.sent();
                        if (typeof res === "boolean") {
                            rtcCodec[type] = res;
                            return [2 /*return*/, sucCall(rtcCodec)];
                        }
                        else {
                            rtcCodec[type] = false;
                            return [2 /*return*/, sucCall(rtcCodec, res)];
                        }
                        _a.label = 2;
                    case 2:
                        if (!(type === "webRTC" || checkLevel === 1)) return [3 /*break*/, 7];
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, new RTCPeerConnection().createOffer({
                                offerToReceiveAudio: true,
                                offerToReceiveVideo: true
                            })];
                    case 4:
                        _a.sent();
                        rtcCodec.webRTC = true;
                        return [3 /*break*/, 6];
                    case 5:
                        e_1 = _a.sent();
                        sucCall && sucCall(rtcCodec, e_1);
                        return [3 /*break*/, 6];
                    case 6:
                        if (type === "webRTC") {
                            return [2 /*return*/, sucCall(rtcCodec)];
                        }
                        _a.label = 7;
                    case 7:
                        if (checkLevel === 1) {
                            errorInfo_1 = "";
                            allType_2 = ["VP8", "H264"];
                            promiseList = [];
                            for (_i = 0, allType_1 = allType_2; _i < allType_1.length; _i++) {
                                allTypeItem = allType_1[_i];
                                checkModule = new checkModule_1.CheckModule();
                                promiseList.push(checkModule.checkSupportByType(allTypeItem));
                            }
                            Promise.all(promiseList).then(function (resList) {
                                resList.forEach(function (item, index) {
                                    if (typeof item === "boolean") {
                                        rtcCodec[allType_2[index]] = true;
                                    }
                                    else {
                                        rtcCodec[allType_2[index]] = false;
                                        errorInfo_1 = item;
                                    }
                                });
                                !!errorInfo_1 ? sucCall(rtcCodec, errorInfo_1) : sucCall(rtcCodec);
                            });
                            return [2 /*return*/];
                        }
                        try {
                            new RTCPeerConnection()
                                .createOffer({
                                offerToReceiveAudio: true,
                                offerToReceiveVideo: true
                            })
                                .then(function (desc) {
                                rtcCodec.webRTC = true;
                                if (desc && desc.sdp) {
                                    var sdplist = desc.sdp.split("\r\n");
                                    rtcCodec.H264 = sdplist.some(function (item) {
                                        return item.startsWith("a=rtpmap:") && item.indexOf("H264/") > -1;
                                    });
                                    if (type === "H264") {
                                        return sucCall(rtcCodec);
                                    }
                                    rtcCodec.VP8 = sdplist.some(function (item) {
                                        return item.startsWith("a=rtpmap:") && item.indexOf("VP8/") > -1;
                                    });
                                    if (type === "VP8") {
                                        return sucCall(rtcCodec);
                                    }
                                    rtcCodec.VP9 = sdplist.some(function (item) {
                                        return item.startsWith("a=rtpmap:") && item.indexOf("VP9/") > -1;
                                    });
                                    rtcCodec.H265 = sdplist.some(function (item) {
                                        return item.startsWith("a=rtpmap:") && item.indexOf("H265/") > -1;
                                    });
                                    sucCall && sucCall(rtcCodec);
                                }
                            });
                        }
                        catch (error) {
                            sucCall && sucCall(rtcCodec, error);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    ClientUtil.getPublisherStateType = function (type) {
        return type == 0 || type == 1
            ? type == 0
                ? "PUBLISHING"
                : "NO_PUBLISH"
            : "PUBLISH_REQUESTING";
    };
    ClientUtil.getPlayerStateType = function (type) {
        return type == 0 || type == 1
            ? type == 0
                ? "PLAYING"
                : "NO_PLAY"
            : "PLAY_REQUESTING";
    };
    ClientUtil.getSteamUpdateType = function (type) {
        return type == 0 ? "DELETE" : "ADD";
    };
    ClientUtil.checkScreenParams = function (screen, errorCallback) {
        if (typeof screen === "object" && screen.videoQuality !== undefined) {
            if (!ClientUtil.checkInteger(screen.videoQuality)) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " videoQuality must be integer number");
                return false;
            }
        }
        if (typeof screen === "object" && screen.sourceID !== undefined) {
            if (typeof screen.sourceID !== "string") {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " sourceID must be string");
                return false;
            }
        }
        if (typeof screen === "object" && screen.videoQuality === 4) {
            if (screen.bitRate === undefined) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " bitrate is required when videoQuality is 4");
                return false;
            }
            else if (!ClientUtil.checkInteger(screen.bitRate)) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " bitrate must be integer number");
                return false;
            }
            else if (screen.bitRate > 10240) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " bitrate cannot greater than 10 Mbps");
                return false;
            }
            if (screen.frameRate === undefined) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " frameRate is required when videoQuality is 4");
                return false;
            }
            else if (!ClientUtil.checkInteger(screen.frameRate)) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " frameRate must be integer number");
                return false;
            }
            if (screen.width === undefined) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " width is required when videoQuality is 4");
                return false;
            }
            else if (!ClientUtil.checkInteger(screen.width)) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " width must be integer number");
                return false;
            }
            if (screen.height === undefined) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " height is required when videoQuality is 4");
                return false;
            }
            else if (!ClientUtil.checkInteger(screen.height)) {
                errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " height must be integer number");
                return false;
            }
        }
        return true;
    };
    ClientUtil.checkCameraParams = function (cameras, errorCallback) {
        if (!cameras.width || !ClientUtil.checkValidNumber(cameras.width)) {
            errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " width must be integer number");
            return false;
        }
        if (!cameras.height || !ClientUtil.checkValidNumber(cameras.height)) {
            errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " height must be integer number");
            return false;
        }
        if (!cameras.frameRate || !ClientUtil.checkValidNumber(cameras.frameRate)) {
            errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " frameRate must be integer number");
            return false;
        }
        if (!cameras.bitRate || !ClientUtil.checkValidNumber(cameras.bitRate)) {
            errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " bitrate must be integer number");
            return false;
        }
        return true;
    };
    ClientUtil.isParamEmpty = function (param) {
        if (param === undefined || param === null || param === "") {
            return false;
        }
        else {
            return true;
        }
    };
    ClientUtil.isTypeString = function (param) {
        if (typeof param !== "string") {
            return false;
        }
        else {
            return true;
        }
    };
    ClientUtil.isTooLong = function (param, len) {
        if (param.length >= len) {
            return false;
        }
        else {
            return true;
        }
    };
    ClientUtil.isReDispatch = function (error) {
        var result = error.message.match(/action:(\d+)/);
        var action = result ? Number(result[1]) : NaN;
        return ([
            zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kTTLOverTimeError,
            zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kClientIPChangedError,
            zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kTTLOverTimeError,
            zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kClientIPChangedError
        ].includes(error) || [6].includes(action));
    };
    ClientUtil.arrAvg = function (arr, val, shiftLen) {
        arr.push(val);
        if (arr.length > shiftLen) {
            arr.shift();
        }
        var sum = arr.reduce(function (prev, current) {
            return prev + current;
        });
        return sum / arr.length;
    };
    ClientUtil.getNetQuality = function (rtt, lostRate, jitter) {
        if (typeof jitter !== "undefined") {
            var jitterWeight = 0.15;
            var lostRTTWeight = 0.85;
            var jitterQuality = this.calcQualityOfJitter(jitter);
            var lostRTTQuality = Math.min(this.calcQualityOfRtt(rtt), this.calcQualityOfLostRate(lostRate, false));
            var quality = jitterWeight * jitterQuality + lostRTTWeight * lostRTTQuality;
            return quality;
        }
        else {
            return Math.min(this.calcQualityOfRtt(rtt), this.calcQualityOfLostRate(lostRate, true));
        }
    };
    ClientUtil.calcQualityOfRtt = function (rtt) {
        if (rtt < 600) {
            return 97 - Math.pow(9.0e-2 * rtt, 1.1);
        }
        else {
            return 18 * Math.exp(2.0e-3 * (600 - rtt));
        }
    };
    ClientUtil.calcQualityOfJitter = function (jitter) {
        if (jitter <= 50) {
            return 98 - Math.pow(jitter, 1.15);
        }
        else {
            return zego_entity_1.QUALITY_CONSTANT.PoorMinQuality;
        }
    };
    ClientUtil.calcQualityOfLostRate = function (lostRate, isProbe) {
        if (isProbe) {
            var _lossRate = lostRate;
            if (_lossRate <= 55) {
                return 99 - Math.pow(0.8 * _lossRate, 1.18);
            }
            else {
                return zego_entity_1.QUALITY_CONSTANT.PoorMinQuality;
            }
        }
        else {
            var _lostRate = lostRate * 100;
            if (_lostRate <= 40) {
                return 96 - Math.pow(_lostRate, 1.22);
            }
            else {
                return zego_entity_1.QUALITY_CONSTANT.PoorMinQuality;
            }
        }
    };
    ClientUtil.quality2QualityGrade = function (quality) {
        var grade = zego_entity_1.QualityGrade.Unknown;
        if (quality >= zego_entity_1.QUALITY_CONSTANT.ExcellentMinQuality) {
            grade = zego_entity_1.QualityGrade.Excellent;
        }
        else if (quality >= zego_entity_1.QUALITY_CONSTANT.GoodMinQuality) {
            grade = zego_entity_1.QualityGrade.Good;
        }
        else if (quality >= zego_entity_1.QUALITY_CONSTANT.MiddleMinQuality) {
            grade = zego_entity_1.QualityGrade.Middle;
        }
        else if (quality >= zego_entity_1.QUALITY_CONSTANT.PoorMinQuality) {
            grade = zego_entity_1.QualityGrade.Poor;
        }
        else {
            grade = zego_entity_1.QualityGrade.Die;
        }
        return grade;
    };
    return ClientUtil;
}());
exports.ClientUtil = ClientUtil;


/***/ }),

/***/ "./sdk/src/util/retryHandler.ts":
/*!**************************************!*\
  !*** ./sdk/src/util/retryHandler.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RetryHandler = void 0;
var RetryHandler = /** @class */ (function () {
    function RetryHandler() {
        this.RETRY_MAX_TIME = 300;
        this.RETRY_START_TIME_INTERVAL = 4;
        this.RETRY_CONTINUE_COUNT = 2;
        this.RETRY_MAX_TIME_INTERVAL = 32;
        this.retryStartTime = 0;
        this.retryActiveCount = 1;
        this.isOverTime = false;
    }
    //
    RetryHandler.prototype.init = function (retryMaxTime, startTimeInterval, retryContinueCount, maxTimeInterval) {
        this.invalid();
        this.stopMaxTime();
        this.isOverTime = false;
        if (typeof retryMaxTime == "number" && retryMaxTime < 3600) {
            this.RETRY_MAX_TIME = retryMaxTime;
        }
        if (typeof startTimeInterval == "number") {
            this.RETRY_START_TIME_INTERVAL = startTimeInterval;
        }
        if (typeof retryContinueCount == "number") {
            this.RETRY_CONTINUE_COUNT = retryContinueCount;
        }
        if (typeof maxTimeInterval == "number") {
            this.RETRY_MAX_TIME_INTERVAL = maxTimeInterval;
        }
    };
    //
    RetryHandler.prototype.invalid = function () {
        this.retryTimer && clearTimeout(this.retryTimer);
        this.retryTimer = null;
        this.retryStartTime = 0;
        this.retryActiveCount = 1;
    };
    return RetryHandler;
}());
exports.RetryHandler = RetryHandler;


/***/ }),

/***/ "./sdk/src/util/sdpUtil.ts":
/*!*********************************!*\
  !*** ./sdk/src/util/sdpUtil.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SdpUtil = void 0;
var SdpUtil = /** @class */ (function () {
    function SdpUtil() {
    }
    SdpUtil.zegoSdp = function (sdp) {
        var sdpLines = sdp.split("\r\n");
        var h264_id = [], opus_id = [];
        sdpLines.forEach(function (item) {
            var _id = item.match(/a=rtpmap:(\d+)\s+((H264\/90000)|(opus\/48000\/2))/);
            if (_id && _id[1] && _id[2]) {
                //@ts-ignore
                _id[2] === "H264/90000" && h264_id.push(_id[1]);
                //@ts-ignore
                _id[2] === "opus/48000/2" && opus_id.push(_id[1]);
            }
        });
        var newSdpLines = [];
        sdpLines.map(function (item) {
            //h64opus
            var isH264_opus = true;
            var other_needed = true;
            var _matched = item.match(/((a=rtcp-fb:)|(a=rtpmap:)|(a=fmtp:))(\d+)/);
            if (_matched && _matched[5]) {
                if (!__spreadArrays(h264_id, opus_id).some(function (item) { return item == _matched[5]; })) {
                    isH264_opus = false;
                }
            }
            //h64opus m=video
            if (item.indexOf("m=video") > -1) {
                var _videoDesc = item.split(" ");
                item = __spreadArrays([_videoDesc[0], _videoDesc[1], _videoDesc[2]], h264_id).join(" ");
            }
            else if (item.indexOf("m=audio") > -1) {
                var _videoDesc = item.split(" ");
                item = __spreadArrays([_videoDesc[0], _videoDesc[1], _videoDesc[2]], opus_id).join(" ");
            }
            //a=ssrc cname
            // if (item.indexOf ('a=ssrc') > -1 && item.indexOf ('cname') < 0) {
            //         other_needed = false
            // }
            //@ts-ignore
            isH264_opus && other_needed && newSdpLines.push(item);
        });
        return newSdpLines.join("\r\n");
    };
    SdpUtil.getSDPByVideDecodeType = function (sdp, type, isSoft) {
        var videoDecodeTypes = {
            str: "",
            arr: [],
            obj: {
                H264: [],
                H265: [],
                VP8: [],
                VP9: [],
                OTHER: []
            }
        };
        if (!sdp.includes("m=video")) {
            return sdp;
        }
        var videoHead = /m=video.+/.exec(sdp)[0];
        videoHead = videoHead.match(/[\s|\d]+/g)[1].replace(" ", "");
        videoDecodeTypes.str = videoHead;
        videoDecodeTypes.arr = videoDecodeTypes.str.split(" ");
        videoDecodeTypes.arr.forEach(function (decodeType) {
            var reg = new RegExp("a=rtpmap:" + decodeType + ".+");
            var matched = reg.exec(sdp)[0];
            if (matched.includes("H264")) {
                videoDecodeTypes.obj.H264.push(decodeType);
            }
            else if (matched.includes("H265")) {
                videoDecodeTypes.obj.H265.push(decodeType);
            }
            else if (matched.includes("VP8")) {
                videoDecodeTypes.obj.VP8.push(decodeType);
            }
            else if (matched.includes("VP9")) {
                videoDecodeTypes.obj.VP9.push(decodeType);
            }
            else {
                videoDecodeTypes.obj.OTHER.push(decodeType);
            }
        });
        videoDecodeTypes.obj.OTHER.forEach(function (otherType) {
            var reg = new RegExp("a=fmtp:" + otherType + ".+apt=(\\d+)");
            var matchedArr = reg.exec(sdp);
            var matched = matchedArr && matchedArr[1];
            if (matched) {
                if (videoDecodeTypes.obj.H264.includes(matched)) {
                    videoDecodeTypes.obj.H264.push(otherType);
                }
                else if (videoDecodeTypes.obj.H265.includes(matched)) {
                    videoDecodeTypes.obj.H265.push(otherType);
                }
                else if (videoDecodeTypes.obj.VP8.includes(matched)) {
                    videoDecodeTypes.obj.VP8.push(otherType);
                }
                else if (videoDecodeTypes.obj.VP9.includes(matched)) {
                    videoDecodeTypes.obj.VP9.push(otherType);
                }
            }
        });
        var targetArr = [];
        if (type === "VP9") {
            targetArr = __spreadArrays(videoDecodeTypes.obj.H265, videoDecodeTypes.obj.H264, videoDecodeTypes.obj.VP8);
        }
        else if (type === "VP8") {
            targetArr = __spreadArrays(videoDecodeTypes.obj.H265, videoDecodeTypes.obj.H264, videoDecodeTypes.obj.VP9);
        }
        else if (type === "H264") {
            targetArr = __spreadArrays(videoDecodeTypes.obj.H265, videoDecodeTypes.obj.VP8, videoDecodeTypes.obj.VP9);
        }
        else if (type === "H265") {
            targetArr = __spreadArrays(videoDecodeTypes.obj.VP8, videoDecodeTypes.obj.H264, videoDecodeTypes.obj.VP9);
        }
        // targetArr.forEach(itype => {
        //         let currentIndex = videoDecodeTypes.arr.indexOf(itype);
        //         let reg;
        //         if( currentIndex!==(videoDecodeTypes.arr.length - 1)){
        //                 reg = new RegExp('a=rtpmap:' + itype + '[\\s\\S]+a=rtpmap:' + videoDecodeTypes.arr[currentIndex+1])
        //                 sdp = sdp.replace(reg, 'a=rtpmap:' + videoDecodeTypes.arr[currentIndex+1]);
        //         }else{
        //                 reg = new RegExp ('a=rtpmap:' + itype + '[\\s\\S]+a=fmtp:' + itype + '.+\\s\\n')
        //                 sdp = sdp.replace(reg, '');
        //         }
        //         videoDecodeTypes.arr.splice(currentIndex,1)
        //         //console.log('targetArr',reg)
        // });
        if (isSoft && type == "H264") {
            //H264 
            var h264Arr_1 = [];
            videoDecodeTypes.obj.H264.forEach(function (itype) {
                var regFmtp = new RegExp("a=fmtp:" + itype + ".+\\s\\n", "g");
                var fmtpRes = regFmtp.exec(sdp);
                if (!!!(fmtpRes === null || fmtpRes === void 0 ? void 0 : fmtpRes.find(function (str) { return str.includes("profile-level-id=42e01f"); }))) {
                    h264Arr_1.push(itype);
                }
            });
            if (h264Arr_1.length == videoDecodeTypes.obj.H264.length) {
                h264Arr_1 = [];
            }
            targetArr = targetArr.concat(h264Arr_1);
        }
        targetArr.forEach(function (itype) {
            var currentIndex = videoDecodeTypes.arr.indexOf(itype);
            videoDecodeTypes.arr.splice(currentIndex, 1);
            var regRtpmap = new RegExp("a=rtpmap:" + itype + ".+\\s\\n", "g");
            var regRtcpfb = new RegExp("a=rtcp-fb:" + itype + ".+\\s\\n", "g");
            var regFmtp = new RegExp("a=fmtp:" + itype + ".+\\s\\n", "g");
            sdp = sdp.replace(regRtpmap, "");
            sdp = sdp.replace(regRtcpfb, "");
            sdp = sdp.replace(regFmtp, "");
        });
        sdp = sdp.replace(videoHead, videoDecodeTypes.arr.join(" "));
        return sdp;
    };
    return SdpUtil;
}());
exports.SdpUtil = SdpUtil;


/***/ }),

/***/ "./sdk/src/webrtc/index.ts":
/*!*********************************!*\
  !*** ./sdk/src/webrtc/index.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoWebRTC = void 0;
var zego_entity_1 = __webpack_require__(/*! ../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var client_util_1 = __webpack_require__(/*! ../util/client-util */ "./sdk/src/util/client-util.ts");
var stateCenter_1 = __webpack_require__(/*! ../common/stateCenter */ "./sdk/src/common/stateCenter.ts");
var action_1 = __webpack_require__(/*! ../common/action */ "./sdk/src/common/action.ts");
var zego_log_event_1 = __webpack_require__(/*! ../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var modules_1 = __webpack_require__(/*! ./modules */ "./sdk/src/webrtc/modules/index.ts");
var zego_streamCenter_web_1 = __webpack_require__(/*! ./modules/zego.streamCenter.web */ "./sdk/src/webrtc/modules/zego.streamCenter.web.ts");
var streamHandler_1 = __webpack_require__(/*! ../common/streamHandler */ "./sdk/src/common/streamHandler.ts");
var zego_publish_1 = __webpack_require__(/*! ./modules/publishModules/zego.publish */ "./sdk/src/webrtc/modules/publishModules/zego.publish.ts");
// @ts-ignore
var adapter = __importStar(__webpack_require__(/*! ./adapter */ "./sdk/src/webrtc/adapter.js"));
var zego_preview_1 = __webpack_require__(/*! ./modules/publishModules/zego.preview */ "./sdk/src/webrtc/modules/publishModules/zego.preview.ts");
var playModules_1 = __webpack_require__(/*! ./modules/playModules */ "./sdk/src/webrtc/modules/playModules/index.ts");
var publishModules_1 = __webpack_require__(/*! ./modules/publishModules */ "./sdk/src/webrtc/modules/publishModules/index.ts");
var streamSignal_1 = __webpack_require__(/*! ./modules/streamSignal */ "./sdk/src/webrtc/modules/streamSignal.ts");
var setting_config_1 = __webpack_require__(/*! ../common/setting.config */ "./sdk/src/common/setting.config.ts");
var setting_config_2 = __webpack_require__(/*! ../common/setting.config */ "./sdk/src/common/setting.config.ts");
var ZegoWebRTC = /** @class */ (function () {
    function ZegoWebRTC(logger, dataReport, rtm, ENV) {
        var _this = this;
        if (ENV === void 0) { ENV = 0; }
        this.mediaEleSources = [];
        this.logger = logger;
        this.dataReport = dataReport;
        this.ac = new (typeof webkitAudioContext !== "undefined"
            ? webkitAudioContext
            : AudioContext)();
        this.checkAudioContext();
        this.stateCenter = new stateCenter_1.StateCenter(this.logger, this.dataReport);
        this.stateCenter.clientType = "webrtc";
        this.stateCenter.type = ENV === 2 ? "PRIVATE" : "PUBLIC";
        this.RTM = rtm;
        this.streamCenter = new zego_streamCenter_web_1.ZegoStreamCenterWeb(this.logger, this.stateCenter, this.dataReport, this.RTM, this.ac, this.mediaEleSources);
        this.rtcModules = new modules_1.RTCModules(this.logger, this.dataReport, this.stateCenter, this.streamCenter, this.RTM, this.ac);
        this.stateCenter.getSeq = zego_entity_1.getSeq;
        this.stateCenter.getReportSeq = zego_entity_1.getReportSeq;
        this.stateCenter.networkState = navigator
            ? navigator.onLine
                ? zego_entity_1.ENUM_NETWORK_STATE.online
                : zego_entity_1.ENUM_NETWORK_STATE.offline
            : zego_entity_1.ENUM_NETWORK_STATE.online;
        this.stateCenter.browser = adapter.browserDetails.browser;
        this.stateCenter.settingConfig = new setting_config_2.ZegoSettingConfig();
        this.RTM.cloudSetting.setEnvVariable("sdk_version", zego_entity_1.PROTO_VERSION);
        // 
        this.RTM.cloudSetting
            .getSettingCache(setting_config_1.RTC)
            .then(function (streamConfig) {
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.CONSTRUCTOR +
                " streamConfig " +
                JSON.stringify(streamConfig));
            // if (streamConfig) {
            var reportSeq = zego_entity_1.getReportSeq();
            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCloudSettingCache.event);
            _this.dataReport.addMsgInfo(reportSeq, {
                files: [
                    {
                        name: setting_config_1.RTC,
                        content: streamConfig === null || streamConfig === void 0 ? void 0 : streamConfig.setting,
                        versions: streamConfig === null || streamConfig === void 0 ? void 0 : streamConfig.versions
                    }
                ]
            });
            _this.dataReport.uploadReport(reportSeq);
            _this.stateCenter.settingConfig.setSetting(streamConfig === null || streamConfig === void 0 ? void 0 : streamConfig.setting);
            // }
        })
            .catch(function (error) {
            _this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.CONSTRUCTOR +
                " streamConfig " +
                JSON.stringify(error));
        });
    }
    ZegoWebRTC.prototype.checkAudioContext = function () {
        var _this = this;
        if (this.ac && this.ac.state === "suspended") {
            var resumeAudioContext_1 = function () {
                _this.ac.resume();
                window.removeEventListener("click", resumeAudioContext_1);
                window.removeEventListener("touchstart", resumeAudioContext_1);
            };
            window.addEventListener("click", resumeAudioContext_1);
            window.addEventListener("touchstart", resumeAudioContext_1);
        }
    };
    ZegoWebRTC.prototype.mutePublishStreamVideo = function (localStream, mute, retain) {
        return false;
    };
    ZegoWebRTC.prototype.mutePublishStreamAudio = function (localStream, mute) {
        return false;
    };
    ZegoWebRTC.prototype.mutePlayStreamVideo = function (streamID, mute) {
        return new Promise(function (resolve, reject) {
            console.error("should install advanced module");
            resolve(false);
        });
    };
    ZegoWebRTC.prototype.mutePlayStreamAudio = function (streamID, mute) {
        return new Promise(function (resolve, reject) {
            console.error("should install advanced module");
            resolve(false);
        });
    };
    ZegoWebRTC.prototype.muteMicrophone = function (mute) {
        return false;
    };
    ZegoWebRTC.prototype.isMicrophoneMuted = function () {
        return !this.streamCenter.isMicEnabled;
    };
    ZegoWebRTC.prototype.setAudioOutput = function (localVideo, audioOutput) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SET_AUDIO_OUTPUT + " call");
        if (typeof audioOutput !== "string") {
            this.logger.error("audiooutput is not string");
            return false;
        }
        return this.rtcModules.playModule.setStreamAudioOutput(localVideo, audioOutput);
    };
    ZegoWebRTC.prototype.setCustomSignalUrl = function (signalUrl) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SET_CUSTOM_SIGNAL_URL + " call: " + signalUrl);
        if (!signalUrl || signalUrl.length == 0) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_CUSTOM_SIGNAL_URL + " param error");
            return;
        }
        var isUrl = true;
        signalUrl.forEach(function (url) { return url.indexOf("wss://") != 0 && (isUrl = false); });
        if (!isUrl) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SET_CUSTOM_SIGNAL_URL + " url is not correct");
            return;
        }
        this.stateCenter.customUrl = signalUrl;
    };
    ZegoWebRTC.prototype.setGWNode = function (gwNode) {
        if (typeof gwNode == "string" && gwNode.length > 0) {
            this.streamCenter.gwNode = gwNode;
        }
    };
    ZegoWebRTC.prototype.setQualityMonitorCycle = function (timeInMs) {
        if (typeof timeInMs === "number" && timeInMs >= 1000) {
            this.streamCenter.setQualityMonitorCycle(timeInMs);
            return true;
        }
        else {
            this.logger.error("zc.sqmc.0 time must be number and bigger than 1000");
            return false;
        }
    };
    ZegoWebRTC.prototype.startPlayingStream = function (streamID, playOption, isDataChannel) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.START_PLAYING_STREAM + " call by user");
        return this.rtcModules.playModule.startPlayingStream(streamID, playOption, isDataChannel);
    };
    ZegoWebRTC.prototype.stopPlayingStream = function (streamID) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STOP_PLAYING_STREAM + " call by user");
        this.rtcModules.playModule.stopPlayingStream(streamID);
    };
    ZegoWebRTC.prototype.setPlayAccelerate = function (accelerate) {
        this.stateCenter.playAccelerate = accelerate;
    };
    //tcp
    ZegoWebRTC.prototype.setTurnOverTcpOnly = function (bool) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SET_TURN_OVER_TCP_ONLY + " call " + bool);
        if (typeof bool == "boolean") {
            this.stateCenter.turnOverTcpOnly = bool;
        }
        else {
            this.logger.error("zc.p.stoto.0 param must be param");
        }
    };
    ZegoWebRTC.prototype.createStream = function (option) {
        return this.rtcModules.publishModule.createStream(option);
    };
    ZegoWebRTC.prototype.destroyStream = function (localStream) {
        this.rtcModules.publishModule.destroyStream(localStream);
    };
    ZegoWebRTC.prototype.startPublishingStream = function (streamID, localStream, publishOption, isDataChannel) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM + " call by user");
        return this.rtcModules.publishModule.startPublishingStream(streamID, localStream, publishOption, isDataChannel);
    };
    ZegoWebRTC.prototype.activateSEIInsert = function (config) {
        console.error("should install advanced module");
        return false;
    };
    //
    ZegoWebRTC.prototype.stopPublishingStream = function (streamID) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STOP_PUBLISHING_STREAM + " call by user");
        return this.rtcModules.publishModule.stopPublishingStream(streamID);
    };
    //
    ZegoWebRTC.prototype.setVideoConfig = function (localStream, constraints) {
        if (this.rtcModules.advancedModule) {
            return this.rtcModules.advancedModule.setVideoConfig(localStream, constraints);
        }
        else {
            return new Promise(function (resolve, reject) {
                console.error("should install advanced module");
                resolve({
                    errorCode: -1,
                    extendedData: "should install advanced module"
                });
            });
        }
    };
    ZegoWebRTC.prototype.setAudioConfig = function (localStream, constraints) {
        if (this.rtcModules.advancedModule) {
            return this.rtcModules.advancedModule.setAudioConfig(localStream, constraints);
        }
        else {
            return new Promise(function (resolve, reject) {
                console.error("should install advanced module");
                resolve({
                    errorCode: -1,
                    extendedData: "should install advanced module"
                });
            });
        }
    };
    ZegoWebRTC.prototype.replaceTrack = function (localStream, mediaStreamTrack) {
        if (this.rtcModules.advancedModule) {
            return this.rtcModules.advancedModule.replaceTrack(localStream, mediaStreamTrack);
        }
        else {
            return new Promise(function (resolve, reject) {
                console.error("should install advanced module");
                resolve({
                    errorCode: -1,
                    extendedData: "should install advanced module"
                });
            });
        }
    };
    //
    ZegoWebRTC.prototype.preloadEffect = function (id, effectUrl, callBack) {
        if (this.rtcModules.audioMixModule !== undefined) {
            this.rtcModules.audioMixModule.preloadEffect(id, effectUrl, callBack);
        }
        else {
            console.error("");
        }
    };
    ZegoWebRTC.prototype.playEffect = function (audioMixConfig, start, end) {
        if (this.rtcModules.audioMixModule !== undefined) {
            this.rtcModules.audioMixModule.playEffect(audioMixConfig, start, end);
        }
        else {
            console.error("");
        }
    };
    ZegoWebRTC.prototype.pauseEffect = function (streamID, effectID) {
        if (this.rtcModules.audioMixModule !== undefined) {
            return this.rtcModules.audioMixModule.pauseEffect(streamID, effectID);
        }
        else {
            console.error("");
            return false;
        }
    };
    ZegoWebRTC.prototype.resumeEffect = function (streamID, effectID) {
        if (this.rtcModules.audioMixModule !== undefined) {
            return this.rtcModules.audioMixModule.resumeEffect(streamID, effectID);
        }
        else {
            console.error("");
            return false;
        }
    };
    ZegoWebRTC.prototype.stopEffect = function (streamID, effectID) {
        if (this.rtcModules.audioMixModule !== undefined) {
            return this.rtcModules.audioMixModule.stopEffect(streamID, effectID);
        }
        else {
            console.error("");
            return false;
        }
    };
    ZegoWebRTC.prototype.unloadEffect = function (effecId) {
        if (this.rtcModules.audioMixModule !== undefined) {
            return this.rtcModules.audioMixModule.unloadEffect(effecId);
        }
        else {
            console.error("");
            return false;
        }
    };
    ZegoWebRTC.prototype.setEffectVolume = function (streamID, volume, effectID) {
        if (this.rtcModules.audioMixModule !== undefined) {
            return this.rtcModules.audioMixModule.setEffectVolume(streamID, volume, effectID);
        }
        else {
            console.error("");
            return false;
        }
    };
    //
    ZegoWebRTC.prototype.startMixingAudio = function (streamID, audio) {
        if (this.rtcModules.audioMixModule !== undefined) {
            return this.rtcModules.audioMixModule.startMixingAudio(streamID, audio);
        }
        else {
            console.error("");
            return false;
        }
    };
    //
    ZegoWebRTC.prototype.stopMixingAudio = function (streamID, audio) {
        if (this.rtcModules.audioMixModule !== undefined) {
            return this.rtcModules.audioMixModule.stopMixingAudio(streamID, audio);
        }
        else {
            console.error("");
            return false;
        }
    };
    ZegoWebRTC.prototype.mixingBuffer = function (streamID, sourceID, arrayBuffer, callBack) {
        if (this.rtcModules.audioMixModule !== undefined) {
            this.rtcModules.audioMixModule.mixingBuffer(streamID, sourceID, arrayBuffer, callBack);
        }
        else {
            console.error("");
        }
    };
    ZegoWebRTC.prototype.stopMixingBuffer = function (streamID, sourceID) {
        if (this.rtcModules.audioMixModule !== undefined) {
            return this.rtcModules.audioMixModule.stopMixingBuffer(streamID, sourceID);
        }
        else {
            console.error("");
            return false;
        }
    };
    ZegoWebRTC.prototype.setMixingAudioVolume = function (streamID, volume, audio) {
        if (this.rtcModules.audioMixModule !== undefined) {
            return this.rtcModules.audioMixModule.setMixingAudioVolume(streamID, volume, audio);
        }
        else {
            console.error("");
            return false;
        }
    };
    // private voiceChange(mult: number, streamID: string): any {
    //     if (!mult || typeof mult !== 'number') {
    //         this.logger.error('zc.vc.0 mult error');
    //         return false;
    //     }
    //     if (!streamID || typeof streamID !== 'string') {
    //         this.logger.error('zc.vc.0 stream id error');
    //         return false;
    //     }
    //     return this.rtcModules.streamCenter.voiceChange(mult, streamID);
    // }
    // private voiceBack(streamID: string): void {
    //     this.rtcModules.streamCenter.voiceBack(streamID);
    // }
    ZegoWebRTC.prototype.checkSystemRequirements = function (checkLevel, type) {
        var _this = this;
        var flag = navigator &&
            navigator.mediaDevices &&
            (ZegoWebRTC.screenShotReady ||
                "getDisplayMedia" in navigator.mediaDevices);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.CHECK_SUPPORT + " call" + navigator.userAgent);
        return new Promise(function (resolve) {
            var reportSeq = zego_entity_1.getReportSeq();
            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCheckSystemRequirements.event);
            var checkType = !type ? "all" : type;
            var interResolve = function (capability) {
                _this.dataReport.addMsgInfo(reportSeq, {
                    capability: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCheckSystemRequirements.capability(capability)
                });
                _this.dataReport.uploadReport(reportSeq);
                var index = _this.stateCenter.checkList.indexOf(checkType);
                _this.stateCenter.checkList.splice(index, 1);
                resolve(capability);
            };
            if (![
                "webRTC",
                "customCapture",
                "camera",
                "microphone",
                "screenSharing",
                "H264",
                "VP8",
                "all"
            ].includes(checkType) ||
                ![0, 1].includes(checkLevel)) {
                return interResolve({
                    result: false,
                    errInfo: {
                        extendedDate: "param error"
                    }
                });
            }
            if (_this.stateCenter.checkList.includes(checkType) ||
                _this.stateCenter.checkList.includes("all")) {
                return interResolve({
                    result: false,
                    errInfo: {
                        extendedDate: "The last test of the same type has not returned a result "
                    }
                });
            }
            _this.stateCenter.checkList.push(checkType);
            client_util_1.ClientUtil.supportDetection(flag, interResolve, checkLevel, type);
        });
    };
    ZegoWebRTC.prototype.enumDevices = function () {
        var _this = this;
        this.logger.info("zc.ed.0 call");
        return new Promise(function (resolve, reject) {
            var reportSeq = zego_entity_1.getReportSeq();
            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskEnumDevices.event);
            var interResolve = function (res) {
                var dev_list = [];
                res.cameras.forEach(function (info) {
                    return dev_list.push({
                        device: info.deviceName,
                        type: 0
                    });
                });
                res.microphones.forEach(function (info) {
                    return dev_list.push({
                        device: info.deviceName,
                        type: 1
                    });
                });
                res.speakers.forEach(function (info) {
                    return dev_list.push({
                        device: info.deviceName,
                        type: 2
                    });
                });
                _this.dataReport.addMsgInfo(reportSeq, {
                    dev_list: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskEnumDevices.dev_list(dev_list)
                });
                _this.dataReport.uploadReport(reportSeq);
                resolve(res);
            };
            var interReject = function (err) {
                _this.dataReport.addMsgInfo(reportSeq, err);
                _this.dataReport.uploadReport(reportSeq);
                reject(err);
            };
            _this.rtcModules.publishModule.recordDevices(interResolve, interReject);
        });
    };
    ZegoWebRTC.prototype.getAudioInfo = function (localStream, errCallBack, option) { };
    ZegoWebRTC.prototype.getSoundLevel = function (localStream, sucCallBack, errCallBack) {
        if (this.rtcModules.audioMixModule) {
            this.rtcModules.audioMixModule.getSoundLevel(localStream, sucCallBack, errCallBack);
        }
        else {
            console.error("");
        }
    };
    ZegoWebRTC.prototype.stopSoundLevel = function (localStream) {
        if (this.rtcModules.audioMixModule) {
            this.rtcModules.audioMixModule.stopSoundLevel(localStream);
        }
        else {
            console.error("");
        }
    };
    ZegoWebRTC.handleDataAvailable = function (event) {
        if (event.data && event.data.size > 0) {
            ZegoWebRTC.recordedBlobs.push(event.data);
        }
    };
    ZegoWebRTC.prototype.startRecord = function (stream) { };
    ZegoWebRTC.prototype.stopRecord = function () { };
    ZegoWebRTC.prototype.resumeRecord = function () { };
    ZegoWebRTC.prototype.pauseRecord = function () { };
    ZegoWebRTC.prototype.saveRecord = function (name) { };
    ZegoWebRTC.prototype.takeSnapShot = function (el, img) { };
    ZegoWebRTC.prototype.saveSnapShot = function (el, name) { };
    ZegoWebRTC.prototype.useVideoDevice = function (localStream, deviceID) {
        if (this.rtcModules.advancedModule) {
            return this.rtcModules.advancedModule.useVideoDevice(localStream, deviceID);
        }
        else {
            return new Promise(function (resolve, reject) {
                resolve({
                    errorCode: -1,
                    extendedData: "should install advanced module"
                });
            });
        }
    };
    ZegoWebRTC.prototype.useAudioDevice = function (localStream, deviceID) {
        if (this.rtcModules.advancedModule) {
            return this.rtcModules.advancedModule.useAudioDevice(localStream, deviceID);
        }
        else {
            console.error("should use advanced module first");
            return new Promise(function (resolve, reject) {
                resolve({
                    errorCode: -1,
                    extendedData: "should install advanced module"
                });
            });
        }
    };
    ZegoWebRTC.prototype.getElectronScreenSources = function () {
        return this.rtcModules.publishModule.getElectronScreenSources();
    };
    ZegoWebRTC.prototype.setSoundLevelDelegate = function (bool, timeInMs) {
        this.logger.info("zc.ssd.0 call");
        if (typeof bool !== "boolean") {
            this.logger.error("zc.ssd.0 param 1 must be boolean");
            return;
        }
        if (timeInMs &&
            (!this.stateCenter.checkInteger(timeInMs) ||
                timeInMs < 100 ||
                timeInMs > 3000)) {
            this.logger.error("zc.ssd.0 soundLevel interval must be integer number which is between 100 and 3000");
            return;
        }
        this.streamCenter.setSoundLevelDelegate(bool, timeInMs);
    };
    ZegoWebRTC.prototype.on = function (event, callBack) {
        return this.rtcModules.bindListener(event, callBack);
    };
    ZegoWebRTC.prototype.off = function (event, callBack) {
        return this.rtcModules.deleteListener(event, callBack);
    };
    ZegoWebRTC.prototype.getVersion = function () {
        return zego_entity_1.PROTO_VERSION;
    };
    ZegoWebRTC.prototype.setStreamExtraInfo = function (streamID, extraInfo) {
        return new Promise(function (resolve, reject) {
            console.error("should use advanced module first");
            reject();
        });
    };
    ZegoWebRTC.prototype.addPublishCdnUrl = function (streamID, targetURL) {
        this.logger.info("zg.cm.apu call ", streamID, targetURL);
        if (this.rtcModules.advancedModule) {
            return this.rtcModules.advancedModule.publishTarget({
                type: "addpush",
                streamID: streamID,
                pushUrl: targetURL
                // signature: signature,
            });
        }
        else {
            return new Promise(function (resolve, reject) {
                console.error("should install advanced module");
                resolve({
                    errorCode: -1,
                    extendedData: "should install advanced module"
                });
            });
        }
    };
    ZegoWebRTC.prototype.removePublishCdnUrl = function (streamID, targetURL) {
        this.logger.info("zg.cm.apu call ", streamID, targetURL);
        if (this.rtcModules.advancedModule) {
            return this.rtcModules.advancedModule.publishTarget({
                type: "delpush",
                streamID: streamID,
                pushUrl: targetURL
                // signature: signature,
            });
        }
        else {
            return new Promise(function (resolve, reject) {
                console.error("should install advanced module");
                resolve({
                    errorCode: -1,
                    extendedData: "should install advanced module"
                });
            });
        }
    };
    ZegoWebRTC.prototype.startMixerTask = function (mixStreamConfig) {
        return new Promise(function (resolve, reject) {
            console.error("");
            reject();
        });
    };
    ZegoWebRTC.prototype.setMixerTaskConfig = function (config) {
        return new Promise(function (resolve, reject) {
            console.error("");
            reject();
        });
    };
    ZegoWebRTC.prototype.stopMixerTask = function (taskId) {
        return new Promise(function (resolve, reject) {
            console.error("");
            reject();
        });
    };
    ZegoWebRTC.prototype.setCaptureVolume = function (localStream, volume) {
        return this.rtcModules.publishModule.setCaptureVolume(localStream, volume);
    };
    // getRoomInfo(): Promise<{ streamList: StreamInfo[] }> {
    //   const room = this.stateCenter.roomList[0];
    //   return room?.streamHandler.getRoomInfo();
    // }
    ZegoWebRTC.use = function (module) {
        switch (module.type) {
            case "AudioMix":
                module.install(modules_1.RTCModules, zego_publish_1.ZegoPublish);
                break;
            case "MixStream":
                module.install(ZegoWebRTC, streamHandler_1.StreamHandler, modules_1.RTCModules);
                break;
            case "Advance":
                module.install(ZegoWebRTC, modules_1.RTCModules, streamHandler_1.StreamHandler, zego_preview_1.ZegoPreview, playModules_1.PlayModule, publishModules_1.PublishModule, zego_publish_1.ZegoPublish, streamSignal_1.ZegoSignal);
                break;
            case "BeautyEffect":
                module.install(zego_preview_1.ZegoPreview);
                break;
            case "RangeAudio":
                module.install(ZegoWebRTC);
                break;
            case "DataChannel":
                module.install(ZegoWebRTC);
                break;
        }
    };
    ZegoWebRTC.prototype.createRangeAudioInstance = function () {
        throw new Error("should use range audio module");
    };
    ZegoWebRTC.prototype.createRealTimeSequentialDataManager = function (roomID) {
        throw new Error("should use datachannel module");
    };
    ZegoWebRTC.prototype.destroyRealTimeSequentialDataManager = function (manager) {
        throw new Error("should use datachannel module");
    };
    ZegoWebRTC.prototype.enableDataChannel = function (bool) {
        if (typeof bool !== "boolean") {
            return;
        }
        this.streamCenter.isDataChannelEnabled = bool;
    };
    ZegoWebRTC.prototype.addTrack = function (stream, track) {
        return new Promise(function (resolve, reject) {
            throw new Error("use advanced module first");
        });
    };
    ZegoWebRTC.prototype.removeTrack = function (stream, track) {
        return new Promise(function (resolve, reject) {
            throw new Error("use advanced module first");
        });
    };
    ZegoWebRTC.prototype.setBeautyEffect = function (localStream, enable, options) {
        if (this.rtcModules.advancedModule) {
            return this.rtcModules.advancedModule.setBeautyEffect(localStream, enable, options);
        }
        else {
            return new Promise(function (resolve, reject) {
                console.error("should install advanced module");
                resolve({
                    errorCode: -1,
                    extendedData: "should install advanced module"
                });
            });
        }
    };
    ZegoWebRTC.screenShotReady = false;
    return ZegoWebRTC;
}());
exports.ZegoWebRTC = ZegoWebRTC;
// listen for messages from the content-script
window.addEventListener("message", function (event) {
    var type = event.data.type, origin = event.origin;
    // NOTE: you should discard foreign events
    if (origin !== window.location.origin) {
        console.warn("ScreenStream: you should discard foreign event from origin:", origin);
        // return;
    }
    // content-script will send a 'SS_PING' msg if extension is installed
    if (type === "SS_PING") {
        ZegoWebRTC.screenShotReady = true;
    }
});


/***/ }),

/***/ "./sdk/src/webrtc/modules/analogSocket.ts":
/*!************************************************!*\
  !*** ./sdk/src/webrtc/modules/analogSocket.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnalogSocket = void 0;
var zego_express_engine_webrtm_1 = __webpack_require__(/*! zego-express-engine-webrtm */ "../zego_express_web_rtm/dist/ZegoExpressWebRTM.js");
var ServerState;
(function (ServerState) {
    ServerState[ServerState["Connected"] = 0] = "Connected";
    ServerState[ServerState["Disconnected"] = 1] = "Disconnected";
    ServerState[ServerState["Broken"] = 2] = "Broken";
})(ServerState || (ServerState = {}));
/**
 * ws
 */
var AnalogSocket = /** @class */ (function () {
    function AnalogSocket(server, netAgent, signalConfig) {
        var _this = this;
        this.server = server;
        this.netAgent = netAgent;
        this.signalConfig = signalConfig;
        this.readyState = WebSocket.CLOSED;
        this.isActive = false;
        this.accessServerState = ServerState.Disconnected;
        this.originAccessServerState = ServerState.Disconnected;
        this.mediaServerState = ServerState.Disconnected;
        this.originMediaServerState = ServerState.Disconnected;
        this.eventHandler = {
            accessDisconnect: function () {
                _this.setAccessServerState(ServerState.Disconnected);
            },
            accessConnect: function () {
                _this.setAccessServerState(ServerState.Connected);
            },
            accessBroken: function () {
                console.error("accessBroken");
                _this.setAccessServerState(ServerState.Broken);
            },
            mediaDisconnect: function () {
                _this.setMediaServerState(ServerState.Disconnected);
            },
            mediaConnect: function () {
                _this.setMediaServerState(ServerState.Connected);
            },
            mediaBroken: function () {
                console.error("mediaBroken");
                _this.setMediaServerState(ServerState.Broken);
            }
        };
        this.wsHandler = netAgent.getPCRequest(server === "unified_rtc"
            ? zego_express_engine_webrtm_1.BusinessService.SERVICE_WEBRTC_SIGNAL
            : zego_express_engine_webrtm_1.BusinessService.SERVICE_L3_WEBRTC_SIGNAL, signalConfig.path, signalConfig.query);
        // 
        this.setAccessServerState(netAgent.isConnect() ? ServerState.Connected : ServerState.Disconnected);
        this.setMediaServerState(this.wsHandler.connectState === 0
            ? ServerState.Connected
            : ServerState.Disconnected);
    }
    AnalogSocket.prototype.updateAccessReadyState = function () {
        if (this.isActive &&
            this.accessServerState === ServerState.Connected &&
            this.mediaServerState !== ServerState.Connected) {
            this.onreconnnecting && this.onreconnnecting();
            return;
        }
    };
    AnalogSocket.prototype.updateMediaReadyState = function () {
        if (this.mediaServerState === ServerState.Connected) {
            if (this.originMediaServerState === ServerState.Broken) {
                this.onreconnnecting && this.onreconnnecting();
            }
            if (this.readyState !== WebSocket.OPEN) {
                this.readyState = WebSocket.OPEN;
                this.onopen && this.onopen();
            }
            return;
        }
        else if (this.mediaServerState === ServerState.Disconnected) {
            // 
            this.wsHandler.off("connected", this.eventHandler.mediaConnect);
            this.wsHandler.off("disconnected", this.eventHandler.mediaDisconnect);
            this.wsHandler.off("broken", this.eventHandler.mediaBroken);
            //   
            this.netAgent.off("connected", this.eventHandler.accessConnect);
            this.netAgent.off("disconnected", this.eventHandler.accessDisconnect);
            this.netAgent.off("broken", this.eventHandler.accessBroken);
            if (this.readyState !== WebSocket.CLOSED) {
                this.onclose && this.onclose();
                this.readyState = WebSocket.CLOSED;
            }
            return;
        }
        else if (this.mediaServerState === ServerState.Broken) {
            this.onerror && this.onerror(new Event("signal connecting"));
            this.readyState = WebSocket.CONNECTING;
        }
    };
    AnalogSocket.prototype.setMediaServerState = function (val) {
        console.error("1111", val);
        if (this.mediaServerState === val)
            return;
        this.originMediaServerState = this.mediaServerState;
        this.mediaServerState = val;
        this.updateMediaReadyState();
    };
    AnalogSocket.prototype.setAccessServerState = function (val) {
        console.error("1111", val);
        if (this.accessServerState === val)
            return;
        this.originAccessServerState = this.accessServerState;
        this.accessServerState = val;
        this.updateAccessReadyState();
    };
    // 
    AnalogSocket.prototype.open = function () {
        var _this = this;
        this.isActive = true;
        // 
        this.wsHandler.on("connected", this.eventHandler.mediaConnect);
        this.wsHandler.on("disconnected", this.eventHandler.mediaDisconnect);
        this.wsHandler.on("broken", this.eventHandler.mediaBroken);
        //   
        this.netAgent.on("connected", this.eventHandler.accessConnect);
        this.netAgent.on("disconnected", this.eventHandler.accessDisconnect);
        this.netAgent.on("broken", this.eventHandler.accessBroken);
        this.wsHandler.on("downLoadMessage", function (msg) {
            console.warn("11111 downLoadMessage", JSON.parse(msg), new Date());
            _this.onmessage({ data: msg });
        });
    };
    AnalogSocket.prototype.close = function () {
        this.isActive = false;
        // // 
        // this.wsHandler.off("connected", this.eventHandler.mediaConnect);
        // this.wsHandler.off("disconnected", this.eventHandler.mediaDisconnect);
        // this.wsHandler.off("broken", this.eventHandler.mediaBroken);
        // //   
        // this.netAgent.off("connected", this.eventHandler.accessConnect);
        // this.netAgent.off("disconnected", this.eventHandler.accessDisconnect);
        // this.netAgent.off("broken", this.eventHandler.accessBroken);
        // if (this.readyState !== WebSocket.CLOSED) {
        //   this.onclose && this.onclose();
        //   this.readyState = WebSocket.CLOSED;
        // }
        // 
        this.wsHandler.closeRequest();
    };
    AnalogSocket.prototype.send = function (data, ack) {
        console.warn("11111 sendRequest", data, new Date());
        // 
        this.wsHandler.sendRequest({ payload: data, ack: ack }, function (res) {
            console.warn("netAgent res", res);
        }, function (ack) {
            console.warn("netAgent ack", ack);
        });
    };
    // socket 
    AnalogSocket.prototype.onopen = function () { };
    AnalogSocket.prototype.onclose = function (reason) { };
    AnalogSocket.prototype.onerror = function (err) { };
    AnalogSocket.prototype.onmessage = function (e) { };
    /**
     *  login
     */
    AnalogSocket.prototype.onreconnnecting = function () { };
    return AnalogSocket;
}());
exports.AnalogSocket = AnalogSocket;


/***/ }),

/***/ "./sdk/src/webrtc/modules/externModules/checkModule.ts":
/*!*************************************************************!*\
  !*** ./sdk/src/webrtc/modules/externModules/checkModule.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckModule = void 0;
var sdpUtil_1 = __webpack_require__(/*! ../../../util/sdpUtil */ "./sdk/src/util/sdpUtil.ts");
var CheckModule = /** @class */ (function () {
    function CheckModule() {
        var _this = this;
        this.iceconnectionstatechangeTimes = 0;
        this.isCheckAll = false;
        var canvas = document.createElement("canvas");
        var context = canvas.getContext("2d");
        context.fillStyle = "rgba(255, 255, 255, 0)";
        try {
            this.localStream = canvas.captureStream();
        }
        catch (e) {
            console.error("canvas captureStream error", e);
        }
        this.timer = setTimeout(function () {
            _this.resolve("Detection timeout");
            _this.hangup();
        }, 5000);
    }
    CheckModule.prototype.checkSupportByType = function (type) {
        return __awaiter(this, void 0, void 0, function () {
            var configuration, promise, res;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.checkType = type;
                        configuration = {};
                        this.localPc = new RTCPeerConnection(configuration);
                        this.remotePc = new RTCPeerConnection(configuration);
                        promise = new Promise(function (resolve) { return (_this.resolve = resolve); });
                        this.localPc.addEventListener("icecandidate", function (e) {
                            return _this.onIceCandidate(_this.localPc, e);
                        });
                        this.remotePc.addEventListener("icecandidate", function (e) {
                            return _this.onIceCandidate(_this.remotePc, e);
                        });
                        this.remotePc.addEventListener("iceconnectionstatechange", function (e) {
                            if (_this.remotePc.iceConnectionState === "connected") {
                                _this.iceconnectionstatechangeResult = true;
                            }
                            if (++_this.iceconnectionstatechangeTimes === 2 && _this.iceCandidate) {
                                clearTimeout(_this.timer);
                                if (_this.remotePc.iceConnectionState === "connected") {
                                    _this.resolve(true);
                                }
                                else {
                                    _this.resolve("The browser does not support " + type + " format");
                                }
                                _this.hangup();
                            }
                        });
                        this.localStream
                            .getTracks()
                            .forEach(function (track) { return _this.localPc.addTrack(track, _this.localStream); });
                        return [4 /*yield*/, this.check(type)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, promise];
                    case 2:
                        res = _a.sent();
                        return [2 /*return*/, res];
                }
            });
        });
    };
    CheckModule.prototype.check = function (type) {
        return __awaiter(this, void 0, void 0, function () {
            var offer, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.localPc.createOffer({
                                offerToReceiveAudio: true,
                                offerToReceiveVideo: true
                            })];
                    case 1:
                        offer = _a.sent();
                        offer.sdp = sdpUtil_1.SdpUtil.getSDPByVideDecodeType(offer.sdp, type);
                        this.onCreateOfferSuccess(offer);
                        return [3 /*break*/, 3];
                    case 2:
                        e_1 = _a.sent();
                        this.onCreateSessionDescriptionError(e_1);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    CheckModule.prototype.onCreateOfferSuccess = function (desc) {
        return __awaiter(this, void 0, void 0, function () {
            var e_2, e_3, answer, e_4;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.localPc.setLocalDescription(desc)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        e_2 = _a.sent();
                        this.onSetSessionDescriptionError(e_2);
                        return [2 /*return*/];
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, this.remotePc.setRemoteDescription(desc)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        e_3 = _a.sent();
                        this.onSetSessionDescriptionError(e_3);
                        return [2 /*return*/];
                    case 6:
                        _a.trys.push([6, 9, , 10]);
                        return [4 /*yield*/, this.remotePc.createAnswer()];
                    case 7:
                        answer = _a.sent();
                        return [4 /*yield*/, this.onCreateAnswerSuccess(answer)];
                    case 8:
                        _a.sent();
                        return [3 /*break*/, 10];
                    case 9:
                        e_4 = _a.sent();
                        this.onCreateSessionDescriptionError(e_4);
                        return [2 /*return*/];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    CheckModule.prototype.onCreateAnswerSuccess = function (desc) {
        return __awaiter(this, void 0, void 0, function () {
            var e_5, e_6;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.remotePc.setLocalDescription(desc)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        e_5 = _a.sent();
                        this.onSetSessionDescriptionError(e_5);
                        return [2 /*return*/];
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, this.localPc.setRemoteDescription(desc)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        e_6 = _a.sent();
                        this.onSetSessionDescriptionError(e_6);
                        return [2 /*return*/];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    CheckModule.prototype.onIceCandidate = function (pc, event) {
        return __awaiter(this, void 0, void 0, function () {
            var error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.getOtherPc(pc).addIceCandidate(event.candidate)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        error_1 = _a.sent();
                        console.error(this.checkType, this.getPcName(pc) + " addIceCandidate error", error_1);
                        clearTimeout(this.timer);
                        this.hangup();
                        this.resolve(error_1);
                        return [3 /*break*/, 3];
                    case 3:
                        if (this.getPcName(pc) === "remotePc") {
                            if (event.candidate) {
                                this.iceCandidate = true;
                            }
                        }
                        if (this.iceconnectionstatechangeResult &&
                            this.getPcName(pc) === "localPc") {
                            clearTimeout(this.timer);
                            this.hangup();
                            this.resolve(true);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    CheckModule.prototype.getOtherPc = function (pc) {
        return pc === this.localPc ? this.remotePc : this.localPc;
    };
    CheckModule.prototype.getPcName = function (pc) {
        return pc === this.localPc ? "localPc" : "remotePc";
    };
    CheckModule.prototype.onCreateSessionDescriptionError = function (error) {
        console.error("Failed to create session description: " + error.toString());
        clearTimeout(this.timer);
        this.hangup();
        this.resolve(error);
    };
    CheckModule.prototype.onSetSessionDescriptionError = function (error) {
        console.error("Failed to set session description: " + error.toString());
        clearTimeout(this.timer);
        this.hangup();
        this.resolve(error);
    };
    CheckModule.prototype.hangup = function () {
        this.localPc.close();
        this.remotePc.close();
        this.iceconnectionstatechangeTimes = 0;
        this.localStream.getTracks().forEach(function (track) { return track.stop(); });
    };
    return CheckModule;
}());
exports.CheckModule = CheckModule;


/***/ }),

/***/ "./sdk/src/webrtc/modules/externModules/retryDispatchHandler.ts":
/*!**********************************************************************!*\
  !*** ./sdk/src/webrtc/modules/externModules/retryDispatchHandler.ts ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RetryDispatchHandler = void 0;
var retryHandler_1 = __webpack_require__(/*! ../../../util/retryHandler */ "./sdk/src/util/retryHandler.ts");
var zego_entity_1 = __webpack_require__(/*! ../../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var action_1 = __webpack_require__(/*! ../../../common/action */ "./sdk/src/common/action.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var zego_error_1 = __webpack_require__(/*! ../../../common/zego.error */ "./sdk/src/common/zego.error.ts");
var RetryDispatchHandler = /** @class */ (function (_super) {
    __extends(RetryDispatchHandler, _super);
    function RetryDispatchHandler(logger, stateCenter, rtm, streamCenter) {
        var _this = _super.call(this) || this;
        _this.retryActiveCount = 1;
        _this.RETRY_MAX_TIME = 90;
        _this.logger = logger;
        _this.stateCenter = stateCenter;
        _this.rtm = rtm;
        _this.streamCenter = streamCenter;
        return _this;
    }
    RetryDispatchHandler.prototype.initStream = function (streamID, playOption, isPublish) {
        this.streamID = streamID;
        this.playOption = playOption;
        this.isPublish = isPublish;
    };
    //
    RetryDispatchHandler.prototype.active = function (firstInterval) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.RDH_ACTIVE + " retry call " + this.streamID);
        //
        if (this.stateCenter.networkState == zego_entity_1.ENUM_NETWORK_STATE.offline) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.RDH_ACTIVE + " network is broken, stop retry");
            return false;
        }
        //,
        if (this.retryTimer) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.RDH_ACTIVE + " has active, ignore");
            return false;
        }
        //
        if (this.isOverTime) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.RDH_ACTIVE + " retry over time, stop retry");
            return false;
        }
        //
        if (!this.rtm.isLogin()) {
            this.stopMaxTime();
            this.invalid();
            var streamer = this.isPublish
                ? this.streamCenter.publisherList[this.streamID]
                : this.streamCenter.playerList[this.streamID];
            streamer && (streamer.isReDispatch = true);
        }
        var retryCount = this.retryActiveCount - 1;
        var dispatchType = this.playOption && this.playOption.resourceMode == 2
            ? 1
            : 0;
        var body = {
            stream_id: this.streamID,
            ptype: this.isPublish ? "push" : "pull",
            signals: this.streamCenter.getAllInUseUrl(),
            header_kvs: [
                {
                    key: "grpc-metadata-push",
                    value: (this.playOption && this.playOption.cdnUrl) || ""
                }
            ],
            retry: retryCount,
            center_ability: true,
            //l3
            dispatch_type: dispatchType
        };
        this.retryTimer && clearTimeout(this.retryTimer);
        this.retryTimer = setTimeout(function () {
            _this.retryTimer = null;
            _this.retryActiveCount++;
            var room = _this.streamCenter.getRoomByStreamID(_this.streamID);
            var seq = _this.rtm.service.sendMessage("webrtc_url", body, function (msg, seq) {
                _this.handleFetchWebRtcUrlRsp(msg);
            }, function (result, seq) {
                _this.handleFetchWebRtcUrlRsp(result);
            }, undefined, {
                sessionID: room === null || room === void 0 ? void 0 : room.sessionID,
                roomID: room === null || room === void 0 ? void 0 : room.roomID,
                roomSessionID: room === null || room === void 0 ? void 0 : room.roomSessionID
            });
            if (_this.isPublish && seq) {
                if (_this.streamCenter.publisherList[_this.streamID])
                    _this.streamCenter.publisherList[_this.streamID].seq = seq;
            }
            else if (seq) {
                if (_this.streamCenter.playerList[_this.streamID])
                    _this.streamCenter.playerList[_this.streamID].seq = seq;
            }
        }, typeof firstInterval == "number"
            ? firstInterval
            : this.retryActiveInterval * 1000);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.RDH_ACTIVE + " call success");
        return true;
    };
    //
    RetryDispatchHandler.prototype.startMaxTime = function () {
        var _this = this;
        if (this.maxTimer) {
            return;
        }
        this.maxTimer = setTimeout(function () {
            _this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.RDH_MAX_TIME + " " + _this.streamID + " dispatch over max time " + _this.RETRY_MAX_TIME + "s stop retry");
            _this.isOverTime = true;
            _this.invalid();
            var errorData = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayDispatchError;
            errorData.message = errorData.message + " try max limit";
            _this.isPublish
                ? _this.streamCenter.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.error, _this.streamID, errorData)
                : _this.streamCenter.onPlayStateUpdate(zego_entity_1.ENUM_PLAY_STATE_UPDATE.error, _this.streamID, errorData);
        }, this.RETRY_MAX_TIME * 1e3);
    };
    //
    RetryDispatchHandler.prototype.stopMaxTime = function () {
        this.maxTimer && clearTimeout(this.maxTimer);
        this.maxTimer = null;
    };
    RetryDispatchHandler.prototype.onactive = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
    };
    RetryDispatchHandler.prototype.handleFetchWebRtcUrlRsp = function (result) {
        if (result.code && [zego_error_1.errorCodeList.TIMEOUT.code].includes(result.code)) {
            this.active();
            return;
        }
        else if (result.code &&
            [zego_error_1.errorCodeList.SOCKET_CLOSE.code].includes(result.code)) {
            this.stopMaxTime();
            this.invalid();
            if (this.isPublish) {
                this.streamCenter.publisherList[this.streamID].isReDispatch = true;
            }
            else {
                this.streamCenter.playerList[this.streamID].isReDispatch = true;
            }
            return;
        }
        var msg = result;
        var streamID = msg.body.stream_id;
        var foundSignal = false;
        //seq
        if (this.isPublish &&
            (!this.streamCenter.publisherList[streamID] ||
                msg.header.seq !== this.streamCenter.publisherList[this.streamID].seq)) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.RDH_WEBRTC_URL_RSP +
                " seq is not match, ignore " +
                this.streamID);
            this.stopMaxTime();
            this.invalid();
            return;
        }
        else if (!this.isPublish &&
            (!this.streamCenter.playerList[this.streamID] ||
                msg.header.seq !== this.streamCenter.playerList[this.streamID].seq)) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.RDH_WEBRTC_URL_RSP +
                " seq is not match, ignore " +
                this.streamID);
            this.stopMaxTime();
            this.invalid();
            return;
        }
        if (this.stateCenter.type === "PUBLIC") {
            this.stateCenter.clientIP = msg.body.clientip || "";
            //need_action
            if (msg.body.err_code !== 0 && msg.body.need_action == 2) {
                this.retryActiveInterval =
                    msg.body.action_delay / 1000 || Math.floor(Math.random() * 3) + 3;
                if (this.retryActiveCount == 2) {
                    var errorData = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayDispatchError;
                    errorData.message =
                        errorData.message +
                            (msg.body.err_code ? " server error:" + msg.body.err_code : "");
                    msg.body.ptype === "push"
                        ? this.streamCenter.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.retry, streamID, errorData)
                        : this.streamCenter.onPlayStateUpdate(zego_entity_1.ENUM_PLAY_STATE_UPDATE.retry, streamID, errorData);
                }
                this.active();
                return;
            }
            else if (msg.body.err_code !== 0 && msg.body.need_action !== 1) {
                var isRetry = ![3102].includes(msg.body.err_code);
                if (isRetry) {
                    this.retryActiveInterval = Math.floor(Math.random() * 3) + 3;
                    if (this.retryActiveCount == 2) {
                        var errorData = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayDispatchError;
                        errorData.message =
                            errorData.message +
                                (msg.body.err_code ? " server error:" + msg.body.err_code : "");
                        msg.body.ptype === "push"
                            ? this.streamCenter.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.retry, streamID, errorData)
                            : this.streamCenter.onPlayStateUpdate(zego_entity_1.ENUM_PLAY_STATE_UPDATE.retry, streamID, errorData);
                    }
                    this.active();
                    return;
                }
            }
            // 
            this.stopMaxTime();
            this.invalid();
            if (msg.body.urls &&
                Array.isArray(msg.body.urls) &&
                msg.body.urls.length > 0) {
                foundSignal = true;
            }
            else {
                this.logger.error(action_1.ZEGO_WEBRTC_ACTION.RDH_WEBRTC_URL_RSP + " signal url is empty");
            }
            if (msg.body.ptype === "push" &&
                this.streamCenter.publisherList[streamID]) {
                if (!foundSignal) {
                    this.streamCenter.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.error, streamID, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishDispatchError);
                    return;
                }
                var publish = this.streamCenter.publisherList[streamID];
                if (this.stateCenter.publishStreamList[streamID]) {
                    //ms
                    publish.ttl = msg.body.hosts_ttl
                        ? new Date().getTime() + msg.body.hosts_ttl * 1000
                        : 0;
                    //
                    publish.isCenterNode =
                        typeof msg.body.is_center_node == "boolean"
                            ? msg.body.is_center_node
                            : false;
                    publish.serverUrls = msg.body.urls;
                    this.streamCenter.startPublishingStream(streamID);
                }
                else {
                    this.logger.error(action_1.ZEGO_WEBRTC_ACTION.RDH_WEBRTC_URL_RSP + " no streamid to publish");
                }
            }
            else if (msg.body.ptype == "pull" &&
                this.streamCenter.playerList[streamID]) {
                if (!foundSignal) {
                    var errorData = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayDispatchError;
                    errorData.message =
                        errorData.message +
                            (msg.body.err_code ? " server error:" + msg.body.err_code : "");
                    if (msg.body.err_code === 3102) {
                        errorData =
                            zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error
                                .kPlayUnsupportedResourceMode;
                    }
                    this.streamCenter.onPlayStateUpdate(zego_entity_1.ENUM_PLAY_STATE_UPDATE.error, streamID, errorData);
                    return;
                }
                var play = this.streamCenter.playerList[streamID];
                //ms
                play.ttl = msg.body.hosts_ttl
                    ? new Date().getTime() + msg.body.hosts_ttl * 1000
                    : 0;
                //
                play.isCenterNode =
                    typeof msg.body.is_center_node == "boolean"
                        ? msg.body.is_center_node
                        : false;
                play.serverUrls = msg.body.urls;
                this.streamCenter.startPlayingStream(streamID, this.stateCenter.useNetAgent, this.streamCenter.playSuccessCallBackList[streamID]);
            }
        }
    };
    return RetryDispatchHandler;
}(retryHandler_1.RetryHandler));
exports.RetryDispatchHandler = RetryDispatchHandler;


/***/ }),

/***/ "./sdk/src/webrtc/modules/externModules/retryStreamHandler.ts":
/*!********************************************************************!*\
  !*** ./sdk/src/webrtc/modules/externModules/retryStreamHandler.ts ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RetryStreamHandler = void 0;
var zego_entity_1 = __webpack_require__(/*! ../../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var retryHandler_1 = __webpack_require__(/*! ../../../util/retryHandler */ "./sdk/src/util/retryHandler.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var action_1 = __webpack_require__(/*! ../../../common/action */ "./sdk/src/common/action.ts");
var client_util_1 = __webpack_require__(/*! ../../../util/client-util */ "./sdk/src/util/client-util.ts");
var RetryStreamHandler = /** @class */ (function (_super) {
    __extends(RetryStreamHandler, _super);
    function RetryStreamHandler(logger, stateCenter, streamCenter, isPublish) {
        var _this = _super.call(this) || this;
        _this.logger = logger;
        _this.stateCenter = stateCenter;
        _this.streamCenter = streamCenter;
        _this.isPublish = isPublish;
        _this.serverUrls = [];
        return _this;
    }
    RetryStreamHandler.prototype.initStream = function (streamID, serverUrls) {
        this.streamID = streamID;
        this.serverUrls = serverUrls;
    };
    //
    RetryStreamHandler.prototype.activePublish = function (firstInterval) {
        var _this = this;
        this.logger.info("zc.tsh.a retry call " + this.streamID);
        //
        if (this.stateCenter.networkState == zego_entity_1.ENUM_NETWORK_STATE.offline) {
            this.logger.info("zc.tsh.a network is broken, stop retry");
            return false;
        }
        //,
        if (this.retryTimer) {
            this.logger.info("zc.tsh.a has active, ignore");
            return false;
        }
        //
        if (this.isOverTime) {
            this.logger.warn("zc.tsh.a retry over time, stop retry");
            return false;
        }
        //
        if (this.retryActiveCount == 1) {
            this.retryActiveInterval = Math.floor(Math.random() * (1 - this.RETRY_START_TIME_INTERVAL) +
                this.RETRY_START_TIME_INTERVAL);
        }
        else {
            var retryActiveInterval = Math.pow(2, Math.round(this.retryActiveCount / this.RETRY_CONTINUE_COUNT + 1));
            this.retryActiveInterval =
                retryActiveInterval > this.RETRY_MAX_TIME_INTERVAL
                    ? this.RETRY_MAX_TIME_INTERVAL
                    : retryActiveInterval;
        }
        var publish = this.streamCenter.publisherList[this.streamID];
        var publisher = publish.publisher;
        //ttl 
        // if (firstInterval == undefined && publish.ttl < new Date().getTime()) {
        //   this.publishStateHandle(
        //     ENUM_PUBLISH_STATE_UPDATE.error,
        //     this.streamID,
        //     ZegoRTCLogEvent.kZegoTaskPublishStart.error.kTTLOverTimeError
        //   );
        //   return true;
        // }
        var useNetAgent = this.stateCenter.useNetAgent;
        var serverUrl = "";
        if (useNetAgent) {
            serverUrl = this.serverUrls[0];
        }
        else {
            //
            var serverUrls_1 = this.serverUrls;
            var server_1 = publisher.signal ? publisher.signal.server : "";
            serverUrls_1.forEach(function (val, ind) {
                return ind <= serverUrls_1.indexOf(server_1) && _this.serverUrls.push(val);
            });
            serverUrls_1.splice(0, serverUrls_1.indexOf(server_1) + 1);
            serverUrl = this.serverUrls[this.retryActiveCount % this.serverUrls.length == 0
                ? this.serverUrls.length - 1
                : (this.retryActiveCount % this.serverUrls.length) - 1];
        }
        this.retryTimer = setTimeout(function () {
            _this.logger.info("zc.tsh.a stream " + _this.streamID + " : connect to " + (useNetAgent ? "unified signal server" : "signal server " + serverUrl));
            _this.retryTimer && clearTimeout(_this.retryTimer);
            _this.retryTimer = null;
            _this.retryActiveCount++;
            _this.streamCenter.connectPublishServer(_this.streamID, serverUrl);
        }, typeof firstInterval == "number"
            ? firstInterval
            : this.retryActiveInterval * 1000);
        this.logger.info("zc.tsh.a call success");
        return true;
    };
    RetryStreamHandler.prototype.activePull = function (firstInterval, success) {
        var _this = this;
        this.logger.info("zc.tsh.a retry call " + this.streamID);
        if (success) {
            this.playStreamSuccess = success;
        }
        //
        if (this.stateCenter.networkState == zego_entity_1.ENUM_NETWORK_STATE.offline) {
            this.logger.info("zc.tsh.a network is broken, stop retry");
            return false;
        }
        //,
        if (this.retryTimer) {
            this.logger.info("zc.tsh.a has active, ignore");
            return false;
        }
        //
        if (this.isOverTime) {
            this.logger.warn("zc.tsh.a retry over time, stop retry");
            return false;
        }
        //
        if (this.retryActiveCount == 1) {
            this.retryActiveInterval = Math.floor(Math.random() * (1 - this.RETRY_START_TIME_INTERVAL) +
                this.RETRY_START_TIME_INTERVAL);
        }
        else {
            var retryActiveInterval = Math.pow(2, Math.round(this.retryActiveCount / this.RETRY_CONTINUE_COUNT + 1));
            this.retryActiveInterval =
                retryActiveInterval > this.RETRY_MAX_TIME_INTERVAL
                    ? this.RETRY_MAX_TIME_INTERVAL
                    : retryActiveInterval;
        }
        var play = this.streamCenter.playerList[this.streamID];
        var player = play.player;
        //ttl 
        // if (firstInterval == undefined && play.ttl < new Date().getTime()) {
        //   this.playStateHandle(
        //     ENUM_PLAY_STATE_UPDATE.error,
        //     this.streamID,
        //     ZegoRTCLogEvent.kZegoTaskPlayStart.error.kTTLOverTimeError
        //   );
        //   return true;
        // }
        //
        var serverUrls = this.serverUrls;
        var server = player.signal ? player.signal.server : "";
        var useNetAgent = this.stateCenter.useNetAgent;
        var serverUrl = "";
        if (useNetAgent) {
            // serverUrl = player.resourceMode !== 2 ? "unified_rtc" : "unified_l3";
            serverUrl = this.serverUrls[0];
        }
        else {
            // TODO: url serverUrl
            //  const serverUrl = this.serverUrls[this.retryActiveCount % this.serverUrls.length];
            serverUrls.forEach(function (val, ind) {
                return ind <= serverUrls.indexOf(server) && _this.serverUrls.push(val);
            });
            serverUrls.splice(0, serverUrls.indexOf(server) + 1);
            serverUrl = this.serverUrls[this.retryActiveCount % this.serverUrls.length == 0
                ? this.serverUrls.length - 1
                : (this.retryActiveCount % this.serverUrls.length) - 1];
            // end
        }
        this.retryTimer = setTimeout(function () {
            _this.logger.warn("zc.tsh.a stream " + _this.streamID + " : connect to " + (useNetAgent ? "unified signal server" : "signal server " + serverUrl));
            _this.retryTimer && clearTimeout(_this.retryTimer);
            _this.retryTimer = null;
            _this.retryActiveCount++;
            _this.streamCenter.connectPlayServer(_this.streamID, _this.playStreamSuccess, serverUrl);
        }, typeof firstInterval == "number"
            ? firstInterval
            : this.retryActiveInterval * 1000);
        this.logger.info("zc.tsh.a call success");
        return true;
    };
    //
    RetryStreamHandler.prototype.startMaxTime = function () {
        var _this = this;
        if (this.maxTimer) {
            return;
        }
        this.maxTimer = setTimeout(function () {
            _this.logger.warn(_this.streamID + " over max time " + _this.RETRY_MAX_TIME + "s, stop retry");
            _this.isOverTime = true;
            _this.invalid();
            //
            if (_this.isPublish) {
                var publish = _this.streamCenter.publisherList[_this.streamID];
                if (!publish) {
                    _this.logger.info("zc.tsh.smt streamID " + _this.streamID + " publish no found");
                    return;
                }
                _this.publishStateHandle(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.error, _this.streamID, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishRetryTimeoutError, true);
            }
            else {
                var play = _this.streamCenter.playerList[_this.streamID];
                if (!play) {
                    _this.logger.info("zc.tsh.smt streamID " + _this.streamID + " play no found");
                    return;
                }
                _this.playStateHandle(zego_entity_1.ENUM_PLAY_STATE_UPDATE.error, _this.streamID, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayRetryTimeoutError, true);
            }
            //this.onactive();
        }, this.RETRY_MAX_TIME * 1e3);
    };
    //
    RetryStreamHandler.prototype.stopMaxTime = function () {
        this.maxTimer && clearTimeout(this.maxTimer);
        this.maxTimer = null;
    };
    RetryStreamHandler.prototype.onactive = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
    };
    //
    RetryStreamHandler.prototype.retryNextSignal = function (error) {
        var _a, _b;
        if (this.stateCenter.networkState == zego_entity_1.ENUM_NETWORK_STATE.offline) {
            return true;
        }
        if (this.isPublish) {
            var publish = this.streamCenter.publisherList[this.streamID];
            if (publish.publisher.state == zego_entity_1.ENUM_PUBLISH_STATE.stop &&
                [
                    zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kSessionTimeoutError.code,
                    zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishNegoTimeoutError
                        .code
                ].includes(error.code)) {
                return true;
            }
            if (publish.isCenterNode &&
                ((_a = publish.publisher.signal) === null || _a === void 0 ? void 0 : _a.wsReadyState) == WebSocket.OPEN) {
                return false;
            }
            else if (!publish.isCenterNode &&
                [
                    zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishSessionClosedError
                        .code
                ].includes(error.code)) {
                var result = error.message.match(/reason:(\d+)/);
                var reason = result ? result[1] : "";
                return !["26"].includes(reason);
            }
            else {
                return true;
            }
        }
        else {
            var play = this.streamCenter.playerList[this.streamID];
            if (play.player.state == zego_entity_1.ENUM_PLAY_STATE.stop &&
                [
                    zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kSessionTimeoutError.code,
                    zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayNegoTimeoutError.code
                ].includes(error.code)) {
                return true;
            }
            if (play.isCenterNode &&
                ((_b = play.player.signal) === null || _b === void 0 ? void 0 : _b.wsReadyState) == WebSocket.OPEN) {
                return false;
            }
            else if (!play.isCenterNode &&
                [
                    zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlaySessionClosedError.code
                ].includes(error.code)) {
                var result = error.message.match(/reason:(\d+)/);
                var reason = result ? result[1] : "";
                return !["24", "26", "28"].includes(reason);
            }
            else {
                return true;
            }
        }
    };
    RetryStreamHandler.prototype.publishStateHandle = function (type, streamID, error, stopRetry) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISH_STATE_HANDLE +
            " call " +
            streamID +
            " " +
            (error ? error.code + "" : ""));
        //3s
        var isStopRetry = stopRetry || this.RETRY_MAX_TIME < 3;
        // 
        if (!isStopRetry &&
            error &&
            (client_util_1.ClientUtil.isReDispatch(error) || this.serverUrls.length == 0)) {
            this.stopMaxTime();
            this.retryTimer && clearTimeout(this.retryTimer);
            this.retryTimer = null;
            this.streamCenter.onPublishStateUpdate(type, streamID, error);
            return;
        }
        var publish = this.streamCenter.publisherList[streamID];
        var publisher = publish.publisher;
        if (!isStopRetry && error && error.code !== 0) {
            !this.maxTimer && !isStopRetry && this.startMaxTime();
            //retryPublish
            this.stateCenter.publishStreamList[streamID].state =
                zego_entity_1.ENUM_PUBLISH_STREAM_STATE.retryPublish;
            var localStream_1 = publisher.localStream;
            var videoInfo_1 = publisher.videoInfo;
            var mediaStreamConfig_1 = publisher.mediaStreamConfig;
            var publishOption_1 = publisher.publishOption;
            if (publisher.sessionId != 0 &&
                publisher.signal &&
                publisher.shouldSendCloseSession()) {
                //send close session request
                publisher.signal.sendCloseSession(zego_entity_1.getSeq(), publisher.sessionId, 1);
                publisher.signal.removeSession(publisher.sessionId);
                publisher.closeSessionSignal = true;
            }
            publisher.resetPublish();
            //
            if (!isStopRetry && !this.retryNextSignal(error)) {
                //
                if (publish.isCenterNode &&
                    publisher.gwNodeTTL < new Date().getTime() &&
                    publisher.gwNodeList.length !== 0) {
                    publisher.gwNode = "";
                    publisher.gwNodeList = [];
                    publisher.gwNodeTTL = 0;
                }
                else if (publish.isCenterNode) {
                    var index = publisher.gwNodeList.findIndex(function (gwNode) { return gwNode == publisher.gwNode; });
                    publisher.gwNode =
                        publisher.gwNodeList[++index % publisher.gwNodeList.length];
                }
                setTimeout(function () {
                    publisher.startPublish(streamID, localStream_1, videoInfo_1, mediaStreamConfig_1, publishOption_1);
                }, 3000);
                return;
            }
            this.streamCenter.removeStreamFromSignal(true, streamID);
        }
        if (isStopRetry) {
            //
            this.stopMaxTime();
            this.invalid();
            if (type === 1) {
                publisher.resetPublish();
            }
            this.streamCenter.onPublishStateUpdate(type, streamID, error);
            return;
        }
        if (error && error.code !== 0) {
            //
            if (this.activePublish(undefined)) {
                var seq = zego_entity_1.getReportSeq();
                this.streamCenter.dataReport.newReport(seq);
                this.streamCenter.dataReport.addMsgInfo(seq, {
                    stream: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRePublish.stream(this.streamID)
                });
                this.streamCenter.dataReport.uploadReport(seq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRePublish.event);
                this.streamCenter.onPublishStateUpdate(2, streamID, error);
            }
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISH_STATE_HANDLE + " end " + streamID);
    };
    RetryStreamHandler.prototype.playStateHandle = function (type, streamID, error, stopRetry) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAY_STATE_HANDLE +
            " call " +
            streamID +
            " " +
            (error ? error.code + "" : ""));
        //3s
        var isStopRetry = stopRetry || this.RETRY_MAX_TIME < 3;
        if (!isStopRetry &&
            error &&
            (client_util_1.ClientUtil.isReDispatch(error) || this.serverUrls.length == 0)) {
            this.stopMaxTime();
            this.retryTimer && clearTimeout(this.retryTimer);
            this.retryTimer = null;
            this.streamCenter.onPlayStateUpdate(type, streamID, error);
            return;
        }
        if (error && error.code !== 0) {
            !this.maxTimer && !isStopRetry && this.startMaxTime();
            var play = this.streamCenter.playerList[streamID];
            var player_1 = play.player;
            var playOption_1 = player_1.playOption;
            if (player_1.sessionId != 0 &&
                player_1.signal &&
                player_1.shouldSendCloseSession()) {
                //send close session request
                player_1.signal.sendCloseSession(zego_entity_1.getSeq(), player_1.sessionId, 1);
                player_1.signal.removeSession(player_1.sessionId);
                player_1.closeSessionSignal = true;
            }
            player_1.resetPlay();
            //
            if (!isStopRetry && !this.retryNextSignal(error)) {
                if (play.isCenterNode &&
                    player_1.gwNodeTTL < new Date().getTime() &&
                    player_1.gwNodeList.length !== 0) {
                    player_1.gwNode = "";
                    player_1.gwNodeList = [];
                    player_1.gwNodeTTL = 0;
                }
                else if (play.isCenterNode) {
                    var index = player_1.gwNodeList.findIndex(function (gwNode) { return gwNode == player_1.gwNode; });
                    player_1.gwNode = player_1.gwNodeList[++index % player_1.gwNodeList.length];
                }
                setTimeout(function () {
                    player_1.startPlay(streamID, player_1.getRemoteStreamSuc, playOption_1);
                }, 3000);
                return;
            }
            this.streamCenter.removeStreamFromSignal(false, streamID);
        }
        if (isStopRetry) {
            //
            this.stopMaxTime();
            this.invalid();
            this.streamCenter.onPlayStateUpdate(type, streamID, error);
            return;
        }
        if (error && error.code !== 0) {
            //
            if (this.activePull(undefined)) {
                var seq = zego_entity_1.getReportSeq();
                this.streamCenter.dataReport.newReport(seq);
                this.streamCenter.dataReport.addMsgInfo(seq, {
                    stream: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRePlay.stream(this.streamID)
                });
                this.streamCenter.dataReport.uploadReport(seq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRePlay.event);
                this.streamCenter.onPlayStateUpdate(2, streamID, error);
            }
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAY_STATE_HANDLE + " end " + streamID);
    };
    return RetryStreamHandler;
}(retryHandler_1.RetryHandler));
exports.RetryStreamHandler = RetryStreamHandler;


/***/ }),

/***/ "./sdk/src/webrtc/modules/index.ts":
/*!*****************************************!*\
  !*** ./sdk/src/webrtc/modules/index.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RTCModules = void 0;
var zego_entity_1 = __webpack_require__(/*! ../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var zego_entity_2 = __webpack_require__(/*! ../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var client_util_1 = __webpack_require__(/*! ../../util/client-util */ "./sdk/src/util/client-util.ts");
var streamHandler_1 = __webpack_require__(/*! ../../common/streamHandler */ "./sdk/src/common/streamHandler.ts");
var index_1 = __webpack_require__(/*! ./publishModules/index */ "./sdk/src/webrtc/modules/publishModules/index.ts");
var index_2 = __webpack_require__(/*! ./playModules/index */ "./sdk/src/webrtc/modules/playModules/index.ts");
var action_1 = __webpack_require__(/*! ../../common/action */ "./sdk/src/common/action.ts");
var zego_error_1 = __webpack_require__(/*! ../../common/zego.error */ "./sdk/src/common/zego.error.ts");
var setting_config_1 = __webpack_require__(/*! ../../common/setting.config */ "./sdk/src/common/setting.config.ts");
var RTCModules = /** @class */ (function () {
    function RTCModules(logger, dataReport, stateCenter, streamCenter, rtm, ac) {
        this.logger = logger;
        this.dataReport = dataReport;
        this.stateCenter = stateCenter;
        this.streamCenter = streamCenter;
        this.rtm = rtm;
        this.ac = ac;
        this.mediaEleSources = [];
        //
        this.publishModule = new index_1.PublishModule(this.logger, this.dataReport, this.stateCenter, this.streamCenter, this.rtm);
        //
        this.playModule = new index_2.PlayModule(this.logger, this.dataReport, this.stateCenter, this.streamCenter, this.rtm);
        //
        this.initAdvance();
        //
        this.initAudioMix();
        this.init();
    }
    RTCModules.prototype.init = function () {
        this.bindWindowListener();
        //
        this.bindRTMListener();
        this.bindStreamCenterHandler();
    };
    RTCModules.prototype.initAudioMix = function () { };
    RTCModules.prototype.initAdvance = function () { };
    RTCModules.prototype.bindWindowListener = function () {
        var _this = this;
        //
        var isOnIOS = navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPhone/i);
        var browser = this.stateCenter.browser;
        var eventName = isOnIOS
            ? "pagehide"
            : browser === "firefox"
                ? "beforeunload"
                : "unload";
        window.addEventListener(eventName, function () {
            if (window.event)
                window.event.cancelBubble = true; // Don't know if this works on iOS but it might!
            for (var key in _this.streamCenter.publisherList) {
                _this.publishModule.stopPublishingStream(key);
            }
            for (var key in _this.streamCenter.playerList) {
                _this.playModule.stopPlayingStream(key);
            }
        });
        window.addEventListener("message", function (event) {
            var _a = event.data, type = _a.type, streamId = _a.streamId, canRequestAudioTrack = _a.canRequestAudioTrack;
            if (type === "SS_DIALOG_SUCCESS") {
                //user chose a stream
                _this.screenStreamFrom(streamId, canRequestAudioTrack, client_util_1.ClientUtil.actionSuccessCallback("screenShare", _this.stateCenter.callbackList));
            }
            if (type === "SS_DIALOG_CANCEL") {
                client_util_1.ClientUtil.actionSuccessCallback("screenShare", _this.stateCenter.callbackList)(false, null, type);
            }
        });
        //
        window.addEventListener("offline", function () {
            _this.logger.info("zc.off.0 network is broken");
            _this.stateCenter.networkState = zego_entity_2.ENUM_NETWORK_STATE.offline;
            if (_this.stateCenter.useNetAgent) {
                _this.logger.info("zc.off.0 use netAgent");
            }
            else {
                //
                for (var streamid in _this.streamCenter.publisherList) {
                    var tryStreamHandler = _this.streamCenter.publisherList[streamid]
                        .retryStreamHandler;
                    tryStreamHandler.stopMaxTime();
                    tryStreamHandler.invalid();
                }
                for (var streamid in _this.streamCenter.playerList) {
                    var tryStreamHandler = _this.streamCenter.playerList[streamid]
                        .retryStreamHandler;
                    tryStreamHandler.stopMaxTime();
                    tryStreamHandler.invalid();
                }
            }
        });
        //
        window.addEventListener("online", function (event) {
            _this.logger.info("zc.on.0 network is online");
            _this.stateCenter.networkState = zego_entity_2.ENUM_NETWORK_STATE.online;
            // if (this.stateCenter.useNetAgent) {
            //   this.logger.info("zc.on.0 use netAgent");
            // } else {
            //
            for (var streamid in _this.streamCenter.publisherList) {
                var publisher = _this.streamCenter.publisherList[streamid].publisher;
                var retryStreamHandler = _this.streamCenter.publisherList[streamid]
                    .retryStreamHandler;
                if (publisher.state == zego_entity_2.ENUM_PUBLISH_STATE.stop ||
                    publisher.stateNego !== zego_entity_2.ENUM_PUBLISH_STATE_NEGO.iceConnected) {
                    !retryStreamHandler.isOverTime &&
                        retryStreamHandler.publishStateHandle(zego_entity_2.ENUM_PUBLISH_STATE_UPDATE.error, streamid, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error
                            .kPublishNetworkBrokenError);
                }
                else if (publisher.state == zego_entity_2.ENUM_PUBLISH_STATE.publishing) {
                    retryStreamHandler.stopMaxTime();
                }
            }
            for (var streamid in _this.streamCenter.playerList) {
                var player = _this.streamCenter.playerList[streamid].player;
                var retryStreamHandler = _this.streamCenter.playerList[streamid]
                    .retryStreamHandler;
                if (player.state == zego_entity_2.ENUM_PLAY_STATE.stop ||
                    player.stateNego !== zego_entity_2.ENUM_PLAY_STATE_NEGO.iceConnected) {
                    !retryStreamHandler.isOverTime &&
                        retryStreamHandler.playStateHandle(zego_entity_2.ENUM_PLAY_STATE_UPDATE.error, streamid, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayNetworkBrokenError);
                }
                else if (player.state == zego_entity_2.ENUM_PLAY_STATE.playing) {
                    retryStreamHandler.stopMaxTime();
                }
            }
            // }
        });
        //
        window.addEventListener("visibilitychange", function (event) {
            //
            if (Object.keys(_this.streamCenter.publisherList).length > 0 ||
                Object.keys(_this.streamCenter.playerList).length > 0) {
                var seq = zego_entity_2.getReportSeq();
                _this.dataReport.newReport(seq, zego_log_event_1.ZegoRTCLogEvent.kZegoVisibilityChange.event);
                _this.dataReport.uploadReport(seq);
            }
        });
    };
    RTCModules.prototype.bindRTMListener = function () {
        var _this = this;
        var _a, _b;
        this.rtm._on("_settingCanFetch", function (msg) { return __awaiter(_this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                this.rtm.cloudSetting.fetchSetting(setting_config_1.RTC).then(function (settingConfig) {
                    _this.logger.info("zc.scf stream config " + JSON.stringify(settingConfig));
                    // this.stateCenter.cloudSettings[RTC] = settingConfig?.setting;
                    // this.stateCenter.setSetting(RTC, settingConfig?.setting);
                    _this.rtm._on("_cloudSettingNotify", function (file, settingFile) {
                        var reportSeq = zego_entity_2.getReportSeq();
                        _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCloudSettingRefresh.event);
                        var params = _this.rtm.cloudSetting.getEnvVariables();
                        _this.dataReport.addMsgInfo(reportSeq, {
                            params: params,
                            files: [
                                {
                                    name: file,
                                    content: settingFile.setting,
                                    versions: settingFile.versions
                                }
                            ]
                        });
                        _this.dataReport.uploadReport(reportSeq);
                        if (file === setting_config_1.RTC) {
                            // this.stateCenter.cloudSettings[RTC] =
                            //   settingFile?.setting;
                            // this.stateCenter.setSetting(file, settingFile?.setting);
                        }
                    });
                });
                return [2 /*return*/];
            });
        }); });
        this.rtm._on("_appConfigRsp", function () {
            _this.stateCenter.appConfig = _this.rtm.getAppConfig();
            _this.publishModule.startWaitPublish();
            _this.playModule.startWaitPlay();
        });
        this.rtm._on("_roomLogin", function (roomID, token) {
            // debugger;
            _this.stateCenter.appid = _this.rtm.getAppID();
            _this.stateCenter.idName = _this.rtm.getUserID();
            _this.stateCenter.testEnvironment = _this.rtm.isTestEnvironment();
            _this.stateCenter.isMultiRoom = _this.rtm.getMultiRoom();
            _this.stateCenter.useNetAgent = _this.rtm.getUseNetAgent();
            _this.streamCenter.setSessionInfo(_this.stateCenter.appid, _this.stateCenter.idName, _this.stateCenter.testEnvironment);
            var room = _this.stateCenter.getRoomByRoomID(roomID);
            if (!room) {
                var streamHandler = new streamHandler_1.StreamHandler(_this.logger, _this.stateCenter, _this.rtm, _this.streamCenter, roomID);
                _this.bindStreamHandler(streamHandler);
                room = {
                    roomID: roomID,
                    streamHandler: streamHandler,
                    sessionID: "",
                    roomSessionID: "",
                    token: token,
                    isResetRoom: false,
                    streamList: [],
                    streamInfoList: []
                };
                _this.stateCenter.roomList.push(room);
            }
        });
        //todo
        this.rtm._on("roomLoginResponse", function (msg) {
            _this.logger.info("zc.rlr call " + JSON.stringify(msg));
            var roomID = msg.header.room_id || msg.body.room_id;
            _this.stateCenter.appConfig = _this.rtm.getAppConfig();
            //todo anchor_info
            var token = _this.rtm.getToken(roomID);
            var sessionID = _this.rtm.getSessionId(roomID);
            var roomSessionID = _this.rtm.getRoomSessionID(roomID);
            var room = _this.stateCenter.getRoomByRoomID(roomID);
            if (!room) {
                var streamHandler = new streamHandler_1.StreamHandler(_this.logger, _this.stateCenter, _this.rtm, _this.streamCenter, roomID);
                _this.bindStreamHandler(streamHandler);
                room = {
                    roomID: roomID,
                    streamHandler: streamHandler,
                    sessionID: sessionID,
                    roomSessionID: roomSessionID,
                    token: token,
                    isResetRoom: false,
                    streamList: [],
                    streamInfoList: []
                };
                _this.stateCenter.roomList.push(room);
            }
            room.sessionID = sessionID;
            room.roomSessionID = roomSessionID;
            if (msg.body.stream_fetch_flag === 1) {
                // TODO 
                room.streamHandler.fetchStreamList();
            }
            // 
            room.streamHandler.handleStreamStart(msg, room);
            _this.logger.info("zc.rlr end " + roomID);
        });
        this.rtm._on("HBResponse", function (msg) {
            var _a;
            var roomID = (_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id;
            var room = _this.stateCenter.getRoomByRoomID(roomID);
            _this.stateCenter.type === "PUBLIC" && (room === null || room === void 0 ? void 0 : room.streamHandler.patchStreamList(msg));
        });
        this.rtm._on("_roomStateUpdate", function (roomID, state, errorCode, extendedData) {
            if (state == "DISCONNECTED") {
                _this.logger.info("zc.rsu " +
                    roomID +
                    " disconnected " +
                    (errorCode ? errorCode + " " : "") +
                    (extendedData ? extendedData : ""));
                //todo roomid 
                var room = _this.stateCenter.getRoomByRoomID(roomID);
                if (room) {
                    var index = _this.stateCenter.roomList.findIndex(function (room) { return room.roomID == roomID; });
                    room.isResetRoom = true;
                    room.streamHandler.reset();
                    _this.streamCenter.reset(roomID);
                    _this.stateCenter.roomList.splice(index, 1);
                }
            }
            else {
                _this.logger.info("zc.rsu " + roomID + " state: " + state);
            }
        });
        this.rtm._on("_tokenRenewed", function (token, roomID) {
            _this.logger.info("zc.tr roomID:" + roomID + " " + token);
            var room = _this.stateCenter.getRoomByRoomID(roomID);
            room && (room.token = token);
        });
        this.rtm._on("_tokenExpired", function (msg) {
            var _a, _b;
            var stopStreamList = ((_b = (_a = msg === null || msg === void 0 ? void 0 : msg.body) === null || _a === void 0 ? void 0 : _a.stop_stream) === null || _b === void 0 ? void 0 : _b.stream_id_list) || [];
            stopStreamList.forEach(function (streamId) {
                // 
                _this.publishModule.stopPublishingStream(streamId, zego_error_1.errorCodeList.TOKEN_EXPIRED);
            });
        });
        this.rtm.service.on("stream", function (msg) {
            var _a;
            var roomID = ((_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id) || "";
            var room = _this.stateCenter.getRoomByRoomID(roomID);
            if (!room) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.ON_STREAM + " room no found");
                return;
            }
            room.streamHandler.handleStreamUpdateRsp(msg);
        });
        this.rtm.liveRoomHandler.handlePushStreamMsg = function (msg) {
            console.warn("handlePushStreamMsg", msg);
            // @ts-ignore
            var streamCmd = zego_entity_1.streamMap[msg.header.sub_cmd];
            msg.body.stream_cmd = streamCmd;
            _this.handlePushStreamMsg(msg);
        };
        (_a = this.rtm.service) === null || _a === void 0 ? void 0 : _a.on("push_stream_update", function (msg) {
            _this.handlePushStreamMsg(msg);
        });
        //
        (_b = this.rtm.service) === null || _b === void 0 ? void 0 : _b.on("zegochat_js.push_room_stream_update_req", function (msg) {
            var _a;
            var roomID = ((_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id) || "";
            var room = _this.stateCenter.getRoomByRoomID(roomID);
            if (!room) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.ON_STREAM + " room no found");
                return;
            }
            room.streamHandler.handlePriPushStreamUpdateMsg(msg);
        });
    };
    RTCModules.prototype.handlePushStreamMsg = function (msg) {
        var _a;
        var roomID = ((_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id) || "";
        var room = this.stateCenter.getRoomByRoomID(roomID);
        if (!room) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.ON_PUSH_STREAM_UPDATE + " room no found");
            return;
        }
        room.streamHandler.handlePushStreamUpdateMsg(msg);
    };
    RTCModules.prototype.bindStreamCenterHandler = function () {
        var _this = this;
        this.streamCenter.onPlayStateUpdate = function (type, streamID, error) {
            var reportSeq = _this.stateCenter.reportSeqList.startPlay[streamID];
            var play = _this.streamCenter.playerList[streamID];
            // 
            if (type == 1 && play && client_util_1.ClientUtil.isReDispatch(error)) {
                var player = play.player;
                var retryDispatchHandler = play.retryDispatchHandler;
                var playOption = play.playOption;
                if (player.sessionId != 0 &&
                    player.signal &&
                    player.shouldSendCloseSession()) {
                    //send close session request
                    player.signal.sendCloseSession(_this.stateCenter.getSeq(), player.sessionId, 1);
                    player.signal.removeSession(player.sessionId);
                    player.closeSessionSignal = true;
                }
                player.resetPlay();
                retryDispatchHandler.stopMaxTime();
                retryDispatchHandler.invalid();
                retryDispatchHandler.initStream(streamID, playOption, false);
                if (!_this.rtm.isLogin()) {
                    _this.streamCenter.playerList[streamID].isReDispatch = true;
                }
                else {
                    retryDispatchHandler.startMaxTime();
                    retryDispatchHandler.active(0);
                }
                return;
            }
            if (play && play.player && (type == 0 || type == 1) && reportSeq) {
                _this.dataReport.eventEndWithMsgInfo(reportSeq, "PlayState", {
                    type: type
                });
                type == 1 && error && _this.dataReport.addMsgInfo(reportSeq, error);
                _this.dataReport.uploadReport(reportSeq);
                delete _this.stateCenter.reportSeqList.startPlay[streamID];
            }
            if (type === 1 && _this.streamCenter.playErrorCallBackList[streamID]) {
                _this.streamCenter.playErrorCallBackList[streamID]({
                    errorCode: error && error.code,
                    extendedData: error && error.message
                });
                delete _this.streamCenter.playErrorCallBackList[streamID];
                _this.logger.info("zc.opsu.1 " + "stop play called by sdk");
                _this.playModule.stopPlayingStream(streamID, error);
            }
            else {
                _this.stateCenter.actionListener("playerStateUpdate", {
                    state: client_util_1.ClientUtil.getPlayerStateType(type),
                    streamID: streamID,
                    errorCode: error && error.code,
                    extendedData: error && error.message
                });
            }
        };
        this.streamCenter.onPublishStateUpdate = function (type, streamID, error) {
            _this.onPublishStateUpdateHandle(type, streamID, error);
        };
        this.streamCenter.onPublishQualityUpdate = function (streamID, stats) {
            _this.stateCenter.actionListener("publishQualityUpdate", streamID, stats);
        };
        this.streamCenter.onPlayQualityUpdate = function (streamID, stats) {
            _this.stateCenter.actionListener("playQualityUpdate", streamID, stats);
        };
        this.streamCenter.onRemoteCameraStatusUpdate = function (streamID, status, originalStatus) {
            var reportSeq = zego_entity_2.getReportSeq();
            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRemoteCameraUpdate.event);
            _this.dataReport.addMsgInfo(reportSeq, {
                stream: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRemoteCameraUpdate.stream(streamID),
                status: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRemoteCameraUpdate.status(status)
            });
            _this.dataReport.uploadReport(reportSeq);
            _this.stateCenter.actionListener("remoteCameraStatusUpdate", streamID, status);
            _this.stateCenter.actionListener("_remoteCameraStatusUpdate", streamID, originalStatus);
        };
        this.streamCenter.onRemoteMicStatusUpdate = function (streamID, status, originalStatus) {
            var reportSeq = zego_entity_2.getReportSeq();
            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRemoteMicUpdate.event);
            _this.dataReport.addMsgInfo(reportSeq, {
                stream: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRemoteMicUpdate.stream(streamID),
                status: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskRemoteMicUpdate.status(status)
            });
            _this.dataReport.uploadReport(reportSeq);
            _this.stateCenter.actionListener("remoteMicStatusUpdate", streamID, status);
            _this.stateCenter.actionListener("_remoteMicStatusUpdate", streamID, originalStatus);
        };
        this.streamCenter.onSoundLevelUpdate = function (soundLevelList) {
            _this.stateCenter.actionListener("soundLevelUpdate", soundLevelList);
        };
        this.streamCenter.onMicSoundLevelUpdate = function (soundLevel) {
            _this.stateCenter.actionListener("capturedSoundLevelUpdate", soundLevel);
        };
    };
    RTCModules.prototype.bindStreamHandler = function (streamHandler) {
        var _this = this;
        streamHandler.onStreamUpdated = function (roomID, type, streamList) {
            var _streamList;
            if (_this.stateCenter.type === "PRIVATE") {
                _streamList = streamList.map(function (stream) {
                    return {
                        streamID: stream.stream_id,
                        user: {
                            userID: stream.user_id,
                            userName: stream.user_name
                        },
                        extraInfo: stream.extra_info,
                        title: stream.title,
                        streamVer: stream.stream_ver
                    };
                });
            }
            else {
                _streamList = streamList.map(function (stream) {
                    return {
                        streamID: stream.streamID,
                        user: stream.user,
                        extraInfo: stream.extraInfo,
                        urlsFLV: stream.urlFlv,
                        urlsRTMP: stream.urlRtmp,
                        urlsHLS: stream.urlHls,
                        urlsHttpsFLV: stream.urlHttpsFlv,
                        urlsHttpsHLS: stream.urlHttpsHls
                    };
                });
            }
            var extendObject = {};
            if (type === 0) {
                var streamDeleteReason = streamList.map(function (stream) {
                    return {
                        stream_id: stream.streamID,
                        code: (zego_entity_2.STREAM_DELETE_REASON[stream.closeType] &&
                            zego_entity_2.STREAM_DELETE_REASON[stream.closeType].code) ||
                            0,
                        description: (zego_entity_2.STREAM_DELETE_REASON[stream.closeType] &&
                            zego_entity_2.STREAM_DELETE_REASON[stream.closeType].description) ||
                            "unknown"
                    };
                });
                extendObject["stream_delete_reason"] = streamDeleteReason;
            }
            var reportSeq = zego_entity_2.getReportSeq();
            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomGetStreamUpdateInfo.event);
            _this.dataReport.addMsgInfo(reportSeq, {
                stream_update_type: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomGetStreamUpdateInfo.stream_update_type(type === 1 ? "added" : "deleted"),
                update_stream: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomGetStreamUpdateInfo.update_stream(_streamList)
            });
            _this.dataReport.uploadReport(reportSeq);
            _this.stateCenter.actionListener("roomStreamUpdate", roomID, client_util_1.ClientUtil.getSteamUpdateType(type), _streamList, Object.keys(extendObject).length > 0 ? JSON.stringify(extendObject) : "");
            _this.stateCenter.actionListener("_streamUpdated", type, streamList);
            if (type === 1) {
                var filterStreamList_1 = [];
                _streamList.forEach(function (stream) {
                    if (stream.extraInfo) {
                        filterStreamList_1.push({
                            streamID: stream.streamID,
                            user: stream.user,
                            extraInfo: stream.extraInfo
                        });
                    }
                });
                filterStreamList_1.length > 0 &&
                    _this.stateCenter.actionListener("streamExtraInfoUpdate", roomID, filterStreamList_1);
            }
        };
        streamHandler.onPublishStateUpdate = function (type, streamID, error) {
            _this.logger.info("zb.opsu ", streamID);
            var reportSeq = _this.stateCenter.reportSeqList.startPublish[streamID];
            var publish = _this.streamCenter.publisherList[streamID];
            if (publish &&
                publish.publisher &&
                (type == 0 || type == 1) &&
                reportSeq) {
                _this.dataReport.eventEndWithMsgInfo(reportSeq, "PublishState", {
                    type: type
                });
                type == 1 && _this.dataReport.addMsgInfo(reportSeq, error);
                _this.dataReport.uploadReport(reportSeq);
                delete _this.stateCenter.reportSeqList.startPublish[streamID];
            }
            _this.stateCenter.actionListener("publisherStateUpdate", {
                state: client_util_1.ClientUtil.getPublisherStateType(type),
                streamID: streamID,
                errorCode: error.code,
                extendedData: error.message
            });
        };
        streamHandler.onStreamExtraInfoUpdated = function (roomID, streamList) {
            var _streamList;
            if (_this.stateCenter.type === "PUBLIC") {
                _streamList = streamList.map(function (stream) {
                    return {
                        streamID: stream.streamID,
                        user: stream.user,
                        extraInfo: stream.extraInfo
                    };
                });
            }
            else {
                _streamList = streamList.map(function (stream) {
                    return {
                        streamID: stream.stream_id,
                        user: {
                            userID: stream.user_id,
                            userName: stream.user_name
                        },
                        extraInfo: stream.extra_info,
                        title: stream.title,
                        streamVer: stream.stream_ver
                    };
                });
            }
            var reportSeq = zego_entity_2.getReportSeq();
            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomGetStreamExtraInfo.event);
            _this.dataReport.addMsgInfo(reportSeq, {
                update_stream: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskLiveRoomGetStreamExtraInfo.update_stream(_streamList)
            });
            _this.dataReport.uploadReport(reportSeq);
            _this.stateCenter.actionListener("streamExtraInfoUpdate", roomID, _streamList);
        };
    };
    RTCModules.prototype.screenStreamFrom = function (streamID, canRequestAudioTrack, callBack) {
        var config = {};
        config["audio"] = {
            mandatory: {
                chromeMediaSource: "desktop",
                chromeMediaSourceId: streamID
            }
        };
        config["video"] = {
            mandatory: {
                chromeMediaSource: "desktop",
                chromeMediaSourceId: streamID,
                maxWidth: window.screen.width,
                maxHeight: window.screen.height
            }
        };
        !canRequestAudioTrack && (config["audio"] = false);
        navigator.mediaDevices
            .getUserMedia(config)
            .then(function (stream) {
            // this.stateCenter.screenShotStream = stream;
            callBack(true, stream);
        })
            .catch(function (err) {
            //this.logger.error('ze.ssf.0 ' + err);
            callBack(false, null, err);
        });
    };
    RTCModules.prototype.onPublishStateUpdateHandle = function (type, streamID, error) {
        var _this = this;
        this.logger.info("zc.opsuh.0 call");
        var publish = this.streamCenter.publisherList[streamID];
        var room = publish.room;
        if (!room) {
            this.logger.error("zc.opsuh.0 room not exist");
            return;
        }
        if (type == 0) {
            //start publish
            if (this.stateCenter.publishStreamList[streamID]) {
                if ([
                    zego_entity_2.ENUM_PUBLISH_STREAM_STATE.tryPublish,
                    zego_entity_2.ENUM_PUBLISH_STREAM_STATE.retryPublish
                ].includes(this.stateCenter.publishStreamList[streamID].state) &&
                    !room.streamList.find(function (streamInfo) { return streamInfo.stream_id == streamID; })) {
                    this.stateCenter.publishStreamList[streamID].state =
                        zego_entity_2.ENUM_PUBLISH_STREAM_STATE.update_info;
                    var cmd = void 0;
                    this.stateCenter.type === "PUBLIC"
                        ? (cmd = zego_entity_2.ENUM_STREAM_SUB_CMD.liveBegin)
                        : (cmd = zego_entity_2.ENUM_STREAM_CMD_PRI.liveBegin);
                    room.streamHandler.updateStreamInfo(streamID, cmd, this.stateCenter.publishStreamList[streamID].extra_info, function (err) {
                        if (_this.stateCenter.type === "PRIVATE") {
                            if (_this.stateCenter.publishStreamList[streamID] &&
                                _this.stateCenter.publishStreamList[streamID].state ==
                                    zego_entity_2.ENUM_PUBLISH_STREAM_STATE.update_info) {
                                _this.stateCenter.publishStreamList[streamID].state =
                                    zego_entity_2.ENUM_PUBLISH_STREAM_STATE.stop;
                                room.streamHandler.onPublishStateUpdate(1, streamID, err);
                                _this.publishModule.stopPublishingStream(streamID);
                            }
                        }
                    });
                }
                else {
                    this.stateCenter.publishStreamList[streamID].state =
                        zego_entity_2.ENUM_PUBLISH_STREAM_STATE.publishing;
                    this.WebrtcOnPublishStateUpdateHandle(type, streamID, error);
                }
            }
        }
        else {
            //
            if (type == 1 && publish && client_util_1.ClientUtil.isReDispatch(error)) {
                var publisher = publish.publisher;
                var retryDispatchHandler = publish.retryDispatchHandler;
                var publishOption = publish.publishOption;
                if (publisher.sessionId != 0 &&
                    publisher.signal &&
                    publisher.shouldSendCloseSession()) {
                    //send close session request
                    publisher.signal.sendCloseSession(this.stateCenter.getSeq(), publisher.sessionId, 1);
                    publisher.signal.removeSession(publisher.sessionId);
                    publisher.closeSessionSignal = true;
                }
                publisher.resetPublish();
                retryDispatchHandler.stopMaxTime();
                retryDispatchHandler.invalid();
                retryDispatchHandler.initStream(streamID, publishOption, true);
                if (!this.rtm.isLogin()) {
                    this.streamCenter.publisherList[streamID].isReDispatch = true;
                }
                else {
                    retryDispatchHandler.startMaxTime();
                    retryDispatchHandler.active(0);
                }
                return;
            }
            room.streamHandler.onPublishStateUpdate(type, streamID, error);
            if (type == 1) {
                this.logger.info("zc.opsuh.0 " + "stop publish called by sdk");
                this.publishModule.stopPublishingStream(streamID, error);
            }
        }
    };
    // web
    RTCModules.prototype.WebrtcOnPublishStateUpdateHandle = function (type, streamID, error) {
        if (this.stateCenter.publishStreamList[streamID].state ==
            zego_entity_2.ENUM_PUBLISH_STREAM_STATE.publishing) {
            var room = this.streamCenter.getRoomByStreamID(streamID);
            room && room.streamHandler.onPublishStateUpdate(type, streamID, error);
        }
    };
    RTCModules.prototype.bindListener = function (listener, callBack) {
        if (!this.stateCenter.listenerList[listener]) {
            this.logger.error("zc.o.0 event " + listener + " no found");
            return false;
        }
        if (typeof callBack !== "function") {
            this.logger.error("zc.o.0 listener callBack must be funciton");
            return false;
        }
        this.stateCenter.listenerList[listener].indexOf(callBack) == -1 &&
            this.stateCenter.listenerList[listener].push(callBack);
        return true;
    };
    RTCModules.prototype.deleteListener = function (listener, callBack) {
        if (!this.stateCenter.listenerList[listener]) {
            this.logger.error("zc.o.1 listener no found");
            return false;
        }
        var li = this.stateCenter.listenerList[listener];
        if (callBack) {
            li.splice(li.indexOf(callBack), 1);
        }
        else {
            this.stateCenter.listenerList[listener] = [];
        }
        return true;
    };
    return RTCModules;
}());
exports.RTCModules = RTCModules;


/***/ }),

/***/ "./sdk/src/webrtc/modules/playModules/index.ts":
/*!*****************************************************!*\
  !*** ./sdk/src/webrtc/modules/playModules/index.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlayModule = void 0;
var action_1 = __webpack_require__(/*! ../../../common/action */ "./sdk/src/common/action.ts");
var zego_entity_1 = __webpack_require__(/*! ../../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var client_util_1 = __webpack_require__(/*! ../../../util/client-util */ "./sdk/src/util/client-util.ts");
var PlayModule = /** @class */ (function () {
    function PlayModule(logger, dataReport, stateCenter, streamCenter, rtm) {
        this.logger = logger;
        this.dataReport = dataReport;
        this.stateCenter = stateCenter;
        this.streamCenter = streamCenter;
        this.rtm = rtm;
    }
    PlayModule.prototype.startPlayingStream = function (streamID, playOption, isDataChannel) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.START_PLAYING_STREAM + " call ", streamID);
        return new Promise(function (resolve, reject) {
            return _this._handlePlayStream(streamID, playOption, resolve, reject, isDataChannel);
        });
    };
    PlayModule.prototype._handlePlayStream = function (streamID, playOption, successCallback, errorCallback, isDataChannel) {
        var _this = this;
        var reportSeq = zego_entity_1.getReportSeq();
        this.stateCenter.reportSeqList.startPlay[streamID] = reportSeq;
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.event);
        var innerReject = function (err, externMsg) {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PLAYING_STREAM +
                " " +
                (externMsg || err.message));
            _this.dataReport.uploadReport(reportSeq, undefined, err, externMsg);
            delete _this.stateCenter.reportSeqList.startPlay[streamID];
            errorCallback &&
                errorCallback(__assign(__assign({}, err), { errorCode: err.code, extendedData: err.message + (externMsg ? " " + externMsg : "") }));
            return;
        };
        if (streamID === undefined ||
            typeof streamID !== "string" ||
            streamID === "") {
            innerReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayParamError, "stream id type error");
            return false;
        }
        if (streamID.length > zego_entity_1.MAX_STREAM_ID_LENGTH) {
            innerReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayStreamIDToLongError, "stream id length limit " + zego_entity_1.MAX_STREAM_ID_LENGTH);
            return false;
        }
        if (!client_util_1.ClientUtil.checkIllegalCharacters(streamID)) {
            innerReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error
                .kPlayStreamIDInvalidCharacterError);
            return false;
        }
        if (typeof playOption !== "undefined" && typeof playOption !== "object") {
            innerReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayParamError, "playOption must be object");
            return false;
        }
        var signals;
        if (this.stateCenter.customUrl && this.stateCenter.customUrl.length != 0) {
            this.logger.info("zc.p.sps.1 customUrl " + JSON.stringify(this.stateCenter.customUrl));
            signals = this.stateCenter.customUrl;
        }
        else {
            var signalNodes = this.stateCenter.settingConfig.getSetting("signal_nodes", true);
            if (signalNodes &&
                signalNodes instanceof Array &&
                signalNodes.length > 0) {
                signals = signalNodes;
                this.logger.info("zc.p.sps.1 setting config signal_nodes " +
                    JSON.stringify(signalNodes));
            }
        }
        if (signals) {
            if (!this.streamCenter.setPlayStateStart(streamID, playOption, isDataChannel)) {
                innerReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayRepeatedPullError, "cannot start play");
                return false;
            }
            this.streamCenter.onPlayStateUpdate(zego_entity_1.ENUM_PLAY_STATE_UPDATE.retry, streamID, { code: 0, message: "" });
            this.streamCenter.playerList[streamID].serverUrls = signals;
            return this.streamCenter.startPlayingStream(streamID, this.stateCenter.useNetAgent, function (stream) {
                successCallback && successCallback(stream);
            });
        }
        this.dataReport.addMsgInfo(reportSeq, {
            stream: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.stream(streamID),
            playOption: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.playOption(playOption)
        });
        // TODO
        if (this.stateCenter.useNetAgent &&
            this.stateCenter.playAccelerate &&
            this.stateCenter.roomList.length > 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.START_PLAYING_STREAM + " play accelerate");
        }
        else if (this.rtm.isDisConnect()) {
            innerReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayNoLoginError);
            return false;
        }
        //
        if (!this.stateCenter.pullLimited) {
            streamID = +"_" + streamID;
        }
        // playOption videoCodec 
        if (playOption && playOption.videoCodec) {
            playOption.videoCodec = playOption.videoCodec.toUpperCase();
        }
        var _resourceMode = this.stateCenter.settingConfig.getSetting("resource_mode", true);
        if (_resourceMode) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.START_PLAYING_STREAM, " setting resource_mode " + _resourceMode);
            !playOption && (playOption = {});
            playOption.resourceMode = _resourceMode;
        }
        if (!this.streamCenter.setPlayStateStart(streamID, playOption, isDataChannel)) {
            innerReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayRepeatedPullError, "cannot start play");
            return false;
        }
        this.streamCenter.onPlayStateUpdate(zego_entity_1.ENUM_PLAY_STATE_UPDATE.retry, streamID, { code: 0, message: "" });
        this.streamCenter.playSuccessCallBackList[streamID] = function (stream) {
            successCallback && successCallback(stream);
        };
        errorCallback &&
            (this.streamCenter.playErrorCallBackList[streamID] = errorCallback);
        var useNetAgent = this.stateCenter.useNetAgent;
        if (useNetAgent) {
            if (!this.stateCenter.appConfig) {
                this.streamCenter.waitPlayList.push(streamID);
                return true;
            }
            // ,
            this.streamCenter.playerList[streamID].serverUrls =
                (playOption === null || playOption === void 0 ? void 0 : playOption.resourceMode) === 2 ? ["unified_l3"] : ["unified_rtc"];
            this.streamCenter.startPlayingStream(streamID, useNetAgent, this.streamCenter.playSuccessCallBackList[streamID]);
            return true;
        }
        else {
            var tryDispatchHandler = this.streamCenter.playerList[streamID]
                .retryDispatchHandler;
            tryDispatchHandler.stopMaxTime();
            tryDispatchHandler.invalid();
            tryDispatchHandler.initStream(streamID, playOption, false);
            tryDispatchHandler.startMaxTime();
            return tryDispatchHandler.active(0);
        }
    };
    PlayModule.prototype.stopPlayingStream = function (streamID, error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STOP_PLAYING_STREAM + " call", streamID);
        //stop play event start
        var reportSeq = zego_entity_1.getReportSeq();
        this.stateCenter.reportSeqList.stopPlay[streamID] = reportSeq;
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStop.event);
        this.dataReport.addMsgInfo(reportSeq, {
            stream: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStop.stream(streamID)
        });
        if (typeof streamID !== "string" || streamID === "") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.STOP_PLAYING_STREAM +
                " streamid must be string and not empty");
            this.dataReport.uploadReport(reportSeq, undefined, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStop.error.kParamError, "stream id type error");
            delete this.stateCenter.reportSeqList.stopPlay[streamID];
            return;
        }
        var play = this.streamCenter.playerList[streamID];
        // if (!play || play.serverUrls.length == 0) {
        //     play && this.logger.error('zc.p.sps.1.0 stream can not be destroyed');
        //     this.dataReport.uploadReport(reportSeq, undefined, errorList.kIsPlaying, 'can not be destroyed');
        //     delete this.stateCenter.reportSeqList.stopPlay[totalStreamId];
        //     return;
        // }
        var shouldPlayUpdate = play && play.player && play.player.state !== zego_entity_1.ENUM_PLAY_STATE.stop;
        this.streamCenter.stopPlayingStream(streamID);
        for (var seq in this.stateCenter.streamUrlMap) {
            if (this.stateCenter.streamUrlMap[seq] === streamID) {
                delete this.stateCenter.streamUrlMap[seq];
                break;
            }
        }
        this.dataReport.uploadReport(reportSeq);
        shouldPlayUpdate &&
            this.streamCenter.onPlayStateUpdate(zego_entity_1.ENUM_PLAY_STATE_UPDATE.error, streamID, error ? error : { code: 0, message: "" });
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.STOP_PLAYING_STREAM + " call success");
        return;
    };
    PlayModule.prototype.mutePlayStream = function (streamID, type, mute) {
        return new Promise(function (resolve, reject) {
            resolve(false);
        });
    };
    PlayModule.prototype.setStreamAudioOutput = function (localVideo, audioOutput) {
        return false;
    };
    PlayModule.prototype.startWaitPlay = function () {
        var _this = this;
        this.streamCenter.waitPlayList.forEach(function (streamID) {
            _this.streamCenter.startPlayingStream(streamID, _this.stateCenter.useNetAgent, _this.streamCenter.playSuccessCallBackList[streamID]);
        });
        this.streamCenter.waitPlayList = [];
    };
    return PlayModule;
}());
exports.PlayModule = PlayModule;


/***/ }),

/***/ "./sdk/src/webrtc/modules/playModules/playStreamQuality.ts":
/*!*****************************************************************!*\
  !*** ./sdk/src/webrtc/modules/playModules/playStreamQuality.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlayStreamQuality = void 0;
var zego_entity_1 = __webpack_require__(/*! ../../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var action_1 = __webpack_require__(/*! ../../../common/action */ "./sdk/src/common/action.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var client_util_1 = __webpack_require__(/*! ../../../util/client-util */ "./sdk/src/util/client-util.ts");
var PlayStreamQuality = /** @class */ (function () {
    function PlayStreamQuality(qualityTimeInterval, player, logger, dataReport) {
        this.player = player;
        this.logger = logger;
        this.dataReport = dataReport;
        this.playQualityList = [];
        this.maxQualityListCount = 10;
        this.qualityTimer = null;
        this.lastPlayStats = {
            audioPacketsLost: 0,
            videoPacketsLost: 0,
            time: 0,
            audioTime: 0,
            videoTime: 0,
            audioBytesReceived: 0,
            videoBytesReceived: 0,
            audioPacketsReceived: 0,
            videoPacketsReceived: 0,
            framesDecoded: 0,
            framesReceived: 0,
            framesDropped: 0,
            audioBitrate: 0
        };
        this.decodeStartTime = 0;
        // // 
        this.netQuality = 0;
        this.probeTime = 0;
        this.probeInterval = 60000;
        this.probeState = zego_entity_1.ENUM_PROBE_STATE.probed;
        this.probeTimer = null;
        this.probeTimeoutInterval = 30000;
        // 
        this.qualityUpload = false;
        this.qualityUploadInterval = 30 * 1000;
        this.qualityUploadLastTime = 0;
        this.cumulativeQuality = {};
        // 
        this.audioBreakThreshold = 200;
        this.videoBreakThreshold = 500;
        this.videoBreak = {
            breakStartTime: undefined,
            cumulativeBreakDuration: 0,
            cumulativeDecodeDuration: 0,
            decodeStartTime: undefined,
            decodeEndTime: undefined,
            totalDuration: 0,
            noBreakNoDecodeDuration: 0,
            resumeRecv: true
        };
        this.audioBreak = {
            breakStartTime: undefined,
            cumulativeBreakDuration: 0,
            cumulativeDecodeDuration: 0,
            decodeStartTime: undefined,
            decodeEndTime: undefined,
            totalDuration: 0,
            noBreakNoDecodeDuration: 0,
            resumeRecv: true
        };
        this.lastSampleTime = 0;
        // 
        this.videoBreakReport = {
            breakDuration: 0,
            breakCancelDuration: 0,
            decodeTime: 0
        };
        this.audioBreakReport = {
            breakDuration: 0,
            breakCancelDuration: 0,
            decodeTime: 0
        };
        // 
        this.totalQuality = {
            totalSquaredInterFrameDelay: 0,
            totalInterFrameDelay: 0,
            framesDecode: 0,
            totalSamplesReceived: 0,
            concealedSamples: 0,
            audioBytesReceived: 0
        };
        this.currentSecondQuality = {
            totalSquaredInterFrameDelay: 0,
            totalInterFrameDelay: 0,
            framesDecode: 0,
            totalSamplesReceived: 0,
            concealedSamples: 0
        };
        // 
        this.onBreakEnd = function (breakEndTime, breakInfo, breakThreshold, isVideo) {
            if (isVideo === void 0) { isVideo = "video"; }
            if (breakInfo.breakStartTime) {
                var breakDuration = breakEndTime - breakInfo.breakStartTime;
                if (breakDuration >= breakThreshold) {
                    breakInfo.cumulativeBreakDuration += breakDuration;
                }
                breakInfo.breakStartTime = undefined;
                // console.log(
                //   isVideo + "BreakEnd_test 1",
                //   breakEndTime,
                //   breakDuration
                // );
            }
        };
        this.p2pNetStats = {
            p2pLostRate: 0,
            p2pRTT: 0
        };
        // 
        this.sampleTimes = 0;
        this.qualitySampleInterval = 1000;
        this.qualityTimeInterval = qualityTimeInterval;
    }
    Object.defineProperty(PlayStreamQuality.prototype, "streamId", {
        get: function () {
            return this.player.streamId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PlayStreamQuality.prototype, "sessionId", {
        get: function () {
            return this.player.sessionId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PlayStreamQuality.prototype, "peerID", {
        get: function () {
            return this.player.peerID;
        },
        enumerable: false,
        configurable: true
    });
    PlayStreamQuality.prototype.getPlayStats = function (rtcStats, callbackResults) {
        var _this = this;
        if (rtcStats == undefined) {
            return;
        }
        var isToReport = this.sampleTimes %
            parseInt((this.qualityTimeInterval / this.qualitySampleInterval).toString()) ===
            0;
        var isToCallback = this.sampleTimes %
            parseInt((this.qualityTimeInterval / this.qualitySampleInterval).toString()) ===
            0;
        if (isToReport) {
            // 
            this.getP2PNetStats();
        }
        var medias = document.querySelectorAll("video, audio");
        // TODO: 
        // throw new Error("error")
        var streamMedia;
        for (var i = 0; i < medias.length; i++) {
            if (medias[i].srcObject === this.player.playStream) {
                streamMedia = medias[i];
            }
        }
        var playData = {
            sampleTimeWindow: this.qualityTimeInterval,
            audioFractionLost: 0,
            audioPacketsLost: 0,
            audioPacketsLostRate: 0,
            audioBitrate: 0,
            audioLevel: 0,
            audioSendLevel: 0,
            audioSamplingRate: 0,
            audioCodec: "opus",
            audioQuality: 0,
            audioFPS: 0,
            videoQuality: 0,
            videoPacketsLost: 0,
            videoPacketsLostRate: 0,
            videoBitrate: 0,
            videoFPS: 0,
            playData: 0,
            nackCount: 0,
            pliCount: 0,
            //sliCount: 0,
            audioJitter: 0,
            videoFractionLost: 0,
            videoFramesDecoded: 0,
            frameHeight: 0,
            frameWidth: 0,
            videoTransferFPS: 0,
            videoFramesDropped: 0,
            totalRoundTripTime: 0,
            currentRoundTripTime: 0,
            googBandwidthLimitedResolution: undefined,
            videoCodecName: "",
            audioCodecName: "",
            googCpuLimitedResolution: undefined,
            googAvailableSendBandwidth: 0,
            audioMuteState: this.player.audioMuteState,
            videoMuteState: this.player.videoMuteState,
            muted: streamMedia ? streamMedia.muted : undefined,
            paused: streamMedia ? streamMedia.paused : undefined,
            volume: streamMedia ? streamMedia.volume : undefined,
            sinkId: streamMedia ? streamMedia.sinkId : undefined
        };
        var time = this.lastPlayStats.time;
        var rtt = 0;
        var audioLostRate = 0;
        var videoLostRate = 0;
        var audioJitter = 0;
        var videoJitter = 0;
        var audioCurrentDelayMs = 0;
        var videoCurrentDelayMs = 0;
        var videoStats = null;
        var audioStats = null;
        rtcStats.forEach(function (item) {
            if (["ssrc", "inbound-rtp"].includes(item.type) &&
                (item.mediaType == "video" || item.id.indexOf("VideoStream") >= 0)) {
                videoStats = item;
            }
            if ((item.type == "inbound-rtp" ||
                (item.type == "ssrc" && item.bytesReceived != undefined)) &&
                (item.mediaType == "audio" || item.id.indexOf("AudioStream") >= 0)) {
                audioStats = item;
            }
        });
        var recordBreakDuration = function (now, framesCurrentSecond, isMediaEnabled, breakInfo, breakThreshold, breakReport, averageBreakDelay, maxBreakValue, isVideo) {
            if (maxBreakValue === void 0) { maxBreakValue = averageBreakDelay; }
            if (isVideo === void 0) { isVideo = "video"; }
            if (breakThreshold > 1000) {
                breakThreshold = 1000;
            }
            if (breakInfo.breakStartTime) {
                if (!isMediaEnabled) {
                    breakInfo.resumeRecv = false;
                    var breakCancelTime = now - 1000;
                    var breakCancelDuration = breakCancelTime - breakInfo.breakStartTime;
                    if (breakCancelDuration <= 0) {
                        //  
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SET_PLAYER_QUALITY_TIMER +
                            " breakCancelDuration less than 0. " +
                            (" (" + breakInfo.breakStartTime + ", " + breakCancelTime + ")"));
                        breakCancelDuration = 0;
                    }
                    // console.log(
                    //   isVideo + "BreakCancel_test ",
                    //   breakCancelTime,
                    //   breakCancelDuration
                    // );
                    breakInfo.breakStartTime = undefined;
                    breakInfo.noBreakNoDecodeDuration += breakCancelDuration;
                    // if (framesCurrentSecond === 0 && !breakInfo.decodeEndTime) {
                    //   breakInfo.decodeEndTime = now - 1000;
                    // }
                    // 
                    breakReport.breakCancelDuration += breakCancelDuration;
                }
                else {
                    // breakInfo.decodeEndTime = undefined;
                    if (framesCurrentSecond === 0) {
                        if (now - breakInfo.breakStartTime >= 22 * 1000) {
                            // 
                            _this.onBreakEnd(now, breakInfo, breakThreshold, isVideo);
                        }
                        // 
                        breakReport.breakDuration += 1000;
                    }
                    else {
                        if (averageBreakDelay >= breakThreshold) {
                            if (averageBreakDelay < 500) {
                                if (averageBreakDelay + maxBreakValue < 1000) {
                                    var breakEndTime = now - (1000 - maxBreakValue);
                                    _this.onBreakEnd(breakEndTime, breakInfo, breakThreshold, isVideo);
                                    breakInfo.breakStartTime = now - averageBreakDelay;
                                    // console.log(
                                    //   isVideo + "BreakStart_test 1",
                                    //   breakInfo.breakStartTime
                                    // );
                                    // 
                                    breakReport.breakDuration +=
                                        maxBreakValue + averageBreakDelay;
                                    breakReport.decodeTime +=
                                        1000 - (maxBreakValue + averageBreakDelay);
                                }
                                else {
                                    //  averageBreakDelay+maxBreakValue >1000
                                    _this.onBreakEnd(now - 1000 + maxBreakValue, breakInfo, breakThreshold, isVideo);
                                    breakInfo.breakStartTime = now - 1000 + maxBreakValue;
                                    // console.log(
                                    //   isVideo + "BreakStart_test 2",
                                    //   breakInfo.breakStartTime
                                    // );
                                    // 
                                    breakReport.breakDuration += 1000;
                                }
                            }
                            else if (averageBreakDelay >= 500) {
                                _this.onBreakEnd(now - averageBreakDelay, breakInfo, breakThreshold, isVideo);
                                breakInfo.breakStartTime = now - averageBreakDelay;
                                // console.log(
                                //   isVideo + "BreakStart_test 3",
                                //   breakInfo.breakStartTime
                                // );
                                // 
                                breakReport.breakDuration += 1000;
                            }
                        }
                        else {
                            if (maxBreakValue <= breakThreshold) {
                                _this.onBreakEnd(now - 1000 + maxBreakValue, breakInfo, breakThreshold, isVideo);
                                breakInfo.breakStartTime = undefined;
                                // 
                                breakReport.breakDuration += maxBreakValue;
                                // console.log("audiobreakReport ", maxBreakValue);
                                breakReport.decodeTime += 1000 - maxBreakValue;
                            }
                            else {
                                breakReport.breakDuration += 1000;
                            }
                        }
                    }
                }
            }
            else {
                // 
                if (!isMediaEnabled) {
                    if (!breakInfo.decodeStartTime) {
                        // 
                    }
                    else if (framesCurrentSecond === 0) {
                        breakInfo.resumeRecv = false;
                        breakInfo.noBreakNoDecodeDuration += 1000;
                        // console.log(isVideo + "BreakCancel_test ", 1000);
                        // if (!breakInfo.decodeEndTime) {
                        //   breakInfo.decodeEndTime = now - 1000;
                        // }
                    }
                    else {
                        breakReport.decodeTime += 1000;
                    }
                }
                else {
                    if (framesCurrentSecond === 0) {
                        if (!breakInfo.resumeRecv) {
                            // 
                            breakInfo.noBreakNoDecodeDuration += 1000;
                        }
                        else {
                            breakInfo.breakStartTime = now - 1000;
                            // console.log(
                            //   isVideo + "BreakStart_test 4",
                            //   breakInfo.breakStartTime
                            // );
                            // 
                            breakReport.breakDuration += 1000;
                        }
                    }
                    else {
                        if (maxBreakValue > breakThreshold) {
                            if (!breakInfo.resumeRecv) {
                                // 
                                breakInfo.noBreakNoDecodeDuration += 1000;
                            }
                            else {
                                breakInfo.breakStartTime = now - maxBreakValue;
                                // console.log(
                                //   isVideo + "BreakStart_test 5",
                                //   breakInfo.breakStartTime
                                // );
                                // 
                                breakReport.breakDuration += maxBreakValue;
                                breakReport.decodeTime += 1000 - maxBreakValue;
                            }
                        }
                        else {
                            breakReport.decodeTime += 1000;
                        }
                    }
                }
            }
            if (isMediaEnabled && framesCurrentSecond) {
                breakInfo.resumeRecv = true;
            }
        };
        var now = new Date().getTime();
        var getIncrement = function (current, origin) {
            return current > origin ? current - origin : 0;
        };
        if (!this.lastSampleTime) {
            this.lastSampleTime = now - 1000;
        }
        // 
        if (videoStats) {
            // start:  maxInterFrameDelay
            var totalInterFrameDelay = videoStats.totalInterFrameDelay, framesDecoded = videoStats.framesDecoded, totalSquaredInterFrameDelay = videoStats.totalSquaredInterFrameDelay;
            // 
            var framesCurrentSecond = getIncrement(framesDecoded, this.totalQuality.framesDecode);
            this.totalQuality.framesDecode = framesDecoded;
            var interFrameDelayCS = getIncrement(totalInterFrameDelay, this.totalQuality.totalInterFrameDelay);
            this.totalQuality.totalInterFrameDelay = totalInterFrameDelay;
            var squaredInterFrameDelayCS = getIncrement(totalSquaredInterFrameDelay, this.totalQuality.totalSquaredInterFrameDelay);
            this.totalQuality.totalSquaredInterFrameDelay = totalSquaredInterFrameDelay;
            // 
            var interFrameDelayVarianceCS = (squaredInterFrameDelayCS -
                Math.pow(interFrameDelayCS, 2) / (framesCurrentSecond || 1)) /
                (framesCurrentSecond || 1);
            interFrameDelayVarianceCS =
                interFrameDelayVarianceCS > 0
                    ? interFrameDelayVarianceCS
                    : -interFrameDelayVarianceCS;
            //  ( totalInterFrameDelay, totalSquaredInterFrameDelay)
            var averageDelay = parseInt((1000 / (framesCurrentSecond + 1)).toString());
            // 
            var interFrameDelayStDevCS = Math.sqrt(interFrameDelayVarianceCS) * 1000;
            var averageInterFrameDelay = (interFrameDelayCS / (framesCurrentSecond || 1)) * 1000 || averageDelay;
            averageInterFrameDelay = parseInt((averageInterFrameDelay > 1000
                ? 1000
                : averageInterFrameDelay).toString());
            var maxInterFrameDelay = averageInterFrameDelay + interFrameDelayStDevCS;
            maxInterFrameDelay = parseInt((maxInterFrameDelay > 1000 ? 1000 : maxInterFrameDelay).toString());
            // end:  maxInterFrameDelay
            // console.log("videobreak111", averageDelay, maxInterFrameDelay);
            // 
            if (framesCurrentSecond > 0 &&
                this.player.cameraStatus === 0 &&
                !this.videoBreak.decodeStartTime) {
                this.videoBreak.decodeStartTime = now - 1000;
                // console.log( "videoBreakDecodeStart_test 1", this.videoBreak.breakStartTime );
            }
            if (this.videoBreak.decodeStartTime) {
                var isMediaEnabled = this.player.cameraStatus === 0 && this.player.playMediaStatus.video;
                // console.log("videoBreakDelay_test", maxInterFrameDelay, isMediaEnabled);
                recordBreakDuration(now, framesCurrentSecond, isMediaEnabled, this.videoBreak, this.videoBreakThreshold, this.videoBreakReport, averageInterFrameDelay, maxInterFrameDelay);
                // console.log("videobreakReport", this.videoBreakReport);
            }
        }
        // 
        if (audioStats) {
            // start: 
            var totalSamplesReceived = audioStats.totalSamplesReceived, concealedSamples = audioStats.concealedSamples, bytesReceived = audioStats.bytesReceived;
            var samplesCurrentSecond = getIncrement(totalSamplesReceived, this.totalQuality.totalSamplesReceived);
            this.totalQuality.totalSamplesReceived = totalSamplesReceived;
            var concealSamplesCurrentSecond = getIncrement(concealedSamples, this.totalQuality.concealedSamples);
            this.totalQuality.concealedSamples = concealedSamples;
            var bytesReceivedCS = getIncrement(bytesReceived, this.totalQuality.audioBytesReceived);
            this.totalQuality.audioBytesReceived = bytesReceived;
            var concealRatio = concealSamplesCurrentSecond / (samplesCurrentSecond || 1);
            var audioInterrupt = parseInt((concealRatio * 1000).toString());
            // end: 
            // 
            if (bytesReceivedCS > 0 &&
                this.player.micStatus === 0 &&
                !this.audioBreak.decodeStartTime) {
                this.audioBreak.decodeStartTime = now - 1000;
                // console.log(  "audioBreakDecodeStart_test 2", this.audioBreak.breakStartTime  );
            }
            if (this.audioBreak.decodeStartTime) {
                var isMediaEnabled = this.player.micStatus === 0 && this.player.playMediaStatus.audio;
                // console.log("audioBreakDelay_test", audioInterrupt, isMediaEnabled);
                recordBreakDuration(now, bytesReceivedCS, isMediaEnabled, this.audioBreak, this.audioBreakThreshold, this.audioBreakReport, audioInterrupt, audioInterrupt, "audio");
                // console.log("audioBreakReport", this.audioBreakReport);
            }
            if (isToReport) {
                // playData.audioBreakDuration = this.audioBreakDuration;
                // playData.audioBreakRate = parseInt(
                //   (
                //     (this.audioBreakTimes / this.qualitySampleInterval) *
                //     10 *
                //     1000
                //   ).toString()
                // );
                // this.audioBreakDuration = 0;
                // this.audioBreakTimes = 0;
            }
        }
        callbackResults &&
            callbackResults.result().forEach(function (result) {
                // stats
                if (isToReport) {
                    // 
                    if (result.type == "ssrc") {
                        if (result.names().indexOf("googBandwidthLimitedResolution") >= 0) {
                            playData.googBandwidthLimitedResolution = result.stat("googBandwidthLimitedResolution");
                        }
                        if (result.names().indexOf("codecImplementationName") >= 0) {
                            playData.codecImplementationName = result.stat("codecImplementationName");
                        }
                        if (result.stat("mediaType") == "video") {
                            if (result.names().indexOf("googCodecName") >= 0) {
                                playData.videoCodecName = result.stat("googCodecName");
                            }
                            // 
                            if (result.names().indexOf("googCurrentDelayMs") >= 0) {
                                videoCurrentDelayMs = result.stat("googCurrentDelayMs");
                            }
                        }
                        if (result.stat("mediaType") == "audio") {
                            if (result.names().indexOf("googCodecName") >= 0) {
                                playData.audioCodecName = result.stat("googCodecName");
                            }
                            // 
                            if (result.names().indexOf("googCurrentDelayMs") >= 0) {
                                audioCurrentDelayMs = result.stat("googCurrentDelayMs");
                            }
                        }
                        if (result.names().indexOf("googCpuLimitedResolution") >= 0) {
                            playData.googCpuLimitedResolution = result.stat("googCpuLimitedResolution");
                        }
                    }
                    if (result.type == "VideoBwe" &&
                        result.names().indexOf("googAvailableSendBandwidth") >= 0) {
                        playData.googAvailableSendBandwidth = result.stat("googAvailableSendBandwidth");
                    }
                }
            });
        if (isToReport) {
            rtcStats.forEach(function (result) {
                if ((result.type == "inbound-rtp" ||
                    (result.type == "ssrc" && result.bytesReceived != undefined)) &&
                    (result.mediaType == "audio" || result.id.indexOf("AudioStream") >= 0)) {
                    //audio
                    if (time != 0) {
                        // 
                        playData["audioBitrate"] =
                            (8 *
                                (result.bytesReceived -
                                    _this.lastPlayStats["audioBytesReceived"])) /
                                (result.timestamp - time);
                        // 
                        var deltaPacketsLost = result.packetsLost - _this.lastPlayStats.audioPacketsLost;
                        deltaPacketsLost > 0 &&
                            (audioLostRate =
                                deltaPacketsLost /
                                    (deltaPacketsLost +
                                        result.packetsReceived -
                                        _this.lastPlayStats.audioPacketsReceived));
                    }
                    if (playData["audioBitrate"] < 0) {
                        playData["audioBitrate"] = 0;
                    }
                    playData.audioJitter = result.jitter;
                    result.packetsLost > 0 &&
                        (playData.audioPacketsLost = result.packetsLost);
                    playData.audioFractionLost = result.fractionLost;
                    var timePacketsLost = result.packetsLost - _this.lastPlayStats.audioPacketsLost;
                    playData.audioFPS =
                        ((result.packetsReceived -
                            _this.lastPlayStats.audioPacketsReceived) /
                            (result.timestamp - time)) *
                            1000;
                    if (timePacketsLost > 0) {
                        playData.audioPacketsLostRate =
                            timePacketsLost /
                                (result.packetsReceived -
                                    _this.lastPlayStats.audioPacketsReceived +
                                    timePacketsLost);
                    }
                    else {
                        playData.audioPacketsLostRate = 0;
                    }
                    _this.lastPlayStats.audioBytesReceived = result.bytesReceived;
                    result.packetsLost > 0 &&
                        (_this.lastPlayStats.audioPacketsLost = result.packetsLost);
                    _this.lastPlayStats.audioPacketsReceived = result.packetsReceived;
                    _this.lastPlayStats.audioTime = result.timestamp;
                    _this.lastPlayStats.time = result.timestamp;
                    _this.lastPlayStats.audioBitrate = playData["audioBitrate"];
                    audioJitter = result.jitter;
                }
                else if ((result.type == "inbound-rtp" ||
                    (result.type == "ssrc" && result.bytesReceived != undefined)) &&
                    (result.mediaType == "video" || result.id.indexOf("VideoStream") >= 0)) {
                    //video
                    if (time != 0) {
                        playData.videoBitrate =
                            (8 *
                                (result.bytesReceived -
                                    _this.lastPlayStats.videoBytesReceived)) /
                                (result.timestamp - time);
                        playData.videoFPS =
                            (1000 *
                                (result.framesDecoded - _this.lastPlayStats.framesDecoded)) /
                                (result.timestamp - time);
                        var deltaPacketsLost = result.packetsLost - _this.lastPlayStats.videoPacketsLost;
                        deltaPacketsLost > 0 &&
                            (videoLostRate =
                                deltaPacketsLost /
                                    (deltaPacketsLost +
                                        result.packetsReceived -
                                        _this.lastPlayStats.videoPacketsReceived));
                    }
                    if (playData.videoBitrate < 0) {
                        playData.videoBitrate = 0;
                    }
                    if (playData.videoFPS < 0) {
                        playData.videoFPS = 0;
                    }
                    //playData.jitter = result.jitter;
                    playData.nackCount = result.nackCount;
                    playData.pliCount = result.pliCount;
                    //playData.sliCount = result.sliCount;
                    playData.videoFractionLost = result.fractionLost;
                    playData.videoFramesDecoded = result.framesDecoded;
                    result.packetsLost > 0 &&
                        (playData.videoPacketsLost = result.packetsLost);
                    var timePacketsLost = result.packetsLost - _this.lastPlayStats.videoPacketsLost;
                    if (timePacketsLost > 0) {
                        playData.videoPacketsLostRate =
                            timePacketsLost /
                                (result.packetsReceived -
                                    _this.lastPlayStats.videoPacketsReceived +
                                    timePacketsLost);
                    }
                    else {
                        playData.videoPacketsLostRate = 0;
                    }
                    _this.lastPlayStats.videoBytesReceived = result.bytesReceived;
                    _this.lastPlayStats.framesDecoded = result.framesDecoded;
                    result.packetsLost > 0 &&
                        (_this.lastPlayStats.videoPacketsLost = result.packetsLost);
                    _this.lastPlayStats.videoPacketsReceived = result.packetsReceived;
                    _this.lastPlayStats.videoTime = result.timestamp;
                    _this.lastPlayStats.time = result.timestamp;
                    videoJitter = result.jitter;
                }
                else if ((result.type == "track" &&
                    (result.kind == "video" || result.id.indexOf("video") >= 0)) ||
                    result.frameWidth) {
                    playData.frameHeight = result.frameHeight;
                    playData.frameWidth = result.frameWidth;
                    // 
                    if (time !== 0 &&
                        (_this.lastPlayStats.frameHeight !== result.frameHeight ||
                            _this.lastPlayStats.frameWidth !== result.frameWidth)) {
                        var reportSizeSeq = zego_entity_1.getReportSeq();
                        _this.dataReport.newReport(reportSizeSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskVideoPlaySize.event);
                        _this.dataReport.addMsgInfo(reportSizeSeq, {
                            session_id: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskVideoPlaySize.session_id(_this.sessionId),
                            w: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskVideoPlaySize.w(result.frameWidth),
                            h: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskVideoPlaySize.h(result.frameHeight)
                        });
                        !_this.player.isProbe && _this.dataReport.uploadReport(reportSizeSeq);
                        _this.lastPlayStats.frameHeight = result.frameHeight;
                        _this.lastPlayStats.frameWidth = result.frameWidth;
                    }
                    else if (time === 0) {
                        _this.lastPlayStats.frameHeight = result.frameHeight;
                        _this.lastPlayStats.frameWidth = result.frameWidth;
                    }
                    if (time != 0) {
                        playData.videoTransferFPS =
                            (1000 *
                                (result.framesReceived - _this.lastPlayStats.framesReceived)) /
                                (result.timestamp - time);
                        playData.videoFramesDropped =
                            result.framesDropped - _this.lastPlayStats.framesDropped;
                    }
                    if (playData.videoTransferFPS < 0) {
                        playData.videoTransferFPS = 0;
                    }
                    if (playData.videoFramesDropped < 0) {
                        playData.videoFramesDropped = 0;
                    }
                    _this.lastPlayStats.framesReceived = result.framesReceived;
                    _this.lastPlayStats.framesDropped = result.framesDropped;
                }
                else if (result.type == "track" &&
                    (result.kind == "audio" || result.id.indexOf("audio") >= 0)) {
                    playData.audioLevel = result.audioLevel;
                    playData.audioSendLevel = result.totalAudioEnergy;
                    playData.audioSamplingRate = result.totalSamplesDuration;
                }
                else if (result.type == "candidate-pair") {
                    if (result.totalRoundTripTime != undefined) {
                        playData.totalRoundTripTime = result.totalRoundTripTime;
                    }
                    if (result.currentRoundTripTime != undefined) {
                        playData.currentRoundTripTime = result.currentRoundTripTime;
                        rtt = playData.currentRoundTripTime * 1000;
                    }
                }
            });
            // 
            this.lastPlayStats.googCurrentDelayMs =
                Number(audioCurrentDelayMs) || Number(videoCurrentDelayMs) || 0;
            videoLostRate =
                isNaN(videoLostRate) || videoLostRate < 0 ? 0 : videoLostRate;
            videoJitter = isNaN(videoJitter) || videoJitter < 0 ? 0 : videoJitter;
            audioLostRate =
                isNaN(audioLostRate) || audioLostRate < 0 ? 0 : audioLostRate;
            audioJitter = isNaN(audioJitter) || audioJitter < 0 ? 0 : audioJitter;
            var videoQuality = client_util_1.ClientUtil.getNetQuality(rtt, videoLostRate, videoJitter);
            var audioQuality = client_util_1.ClientUtil.getNetQuality(rtt, audioLostRate, audioJitter);
            playData.audioQuality =
                time > 0 ? client_util_1.ClientUtil.quality2QualityGrade(videoQuality) : 0;
            playData.videoQuality =
                time > 0 ? client_util_1.ClientUtil.quality2QualityGrade(audioQuality) : 0;
            var netQuality = Math.min(videoQuality, audioQuality);
            this.netQuality = netQuality;
            playData.peerToPeerDelay = !isNaN(this.p2pNetStats.p2pRTT)
                ? parseInt((this.p2pNetStats.p2pRTT / 2 +
                    this.lastPlayStats.googCurrentDelayMs).toString())
                : 0;
            playData.peerToPeerPacketLostRate =
                (this.p2pNetStats.p2pLostRate * 100) / 256;
            if (time > 0 &&
                netQuality <= zego_entity_1.QUALITY_CONSTANT.MiddleMinQuality &&
                now > this.probeTime + this.probeInterval) {
                this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SET_PLAYER_QUALITY_TIMER +
                    " netQuality " +
                    netQuality +
                    " start net probe");
                this.probeState = zego_entity_1.ENUM_PROBE_STATE.tryProbe;
                this.player.streamCenter.startNetProbe(false, this.player, this.player.gwNodeList);
                this.probeTime = now;
            }
            this.uploadPlayQuality(playData, now);
            var streamQuality = {
                video: {
                    videoBitrate: playData.videoBitrate,
                    videoFPS: playData.videoFPS,
                    videoTransferFPS: playData.videoTransferFPS,
                    videoFramesDecoded: playData.videoFramesDecoded,
                    videoFramesDropped: playData.videoFramesDropped,
                    videoPacketsLost: playData.videoPacketsLost,
                    videoPacketsLostRate: playData.videoPacketsLostRate,
                    videoQuality: playData.videoQuality,
                    frameHeight: playData.frameHeight,
                    frameWidth: playData.frameWidth,
                    muteState: playData.videoMuteState
                    // // 
                    // videoBreakRate: playData.videoBreakRate,
                    // videoBreakDuration: playData.videoBreakDuration
                },
                audio: {
                    audioBitrate: playData.audioBitrate,
                    audioCodec: playData.audioCodec,
                    audioJitter: playData.audioJitter,
                    audioLevel: playData.audioLevel,
                    audioPacketsLost: playData.audioPacketsLost,
                    audioPacketsLostRate: playData.audioPacketsLostRate,
                    audioQuality: playData.audioQuality,
                    audioSamplingRate: playData.audioSamplingRate,
                    audioSendLevel: playData.audioSendLevel,
                    muteState: playData.audioMuteState,
                    audioFPS: playData.audioFPS
                    // // 
                    // audioBreakRate: playData.audioBreakRate,
                    // audioBreakDuration: playData.audioBreakDuration
                },
                //roomId: '',
                nackCount: playData.nackCount,
                pliCount: playData.pliCount,
                totalRoundTripTime: playData.totalRoundTripTime,
                playData: playData.playData,
                currentRoundTripTime: playData.currentRoundTripTime,
                // 
                peerToPeerDelay: playData.peerToPeerDelay,
                peerToPeerPacketLostRate: playData.peerToPeerPacketLostRate,
                sampleTimeWindow: playData.sampleTimeWindow
            };
            if (playData.muted !== undefined) {
                streamQuality.muted = playData.muted;
                streamQuality.paused = playData.paused;
                streamQuality.volume = playData.volume;
                streamQuality.sinkId = playData.sinkId;
            }
            if (playData.videoCodecName !== undefined) {
                // streamQuality.googBandwidthLimitedResolution = playData.googBandwidthLimitedResolution;
                streamQuality.video.googCodecName = playData.videoCodecName;
                streamQuality.audio.googCodecName = playData.audioCodecName;
                // streamQuality.googCpuLimitedResolution = playData.googCpuLimitedResolution;
                streamQuality.codecImplementationName =
                    playData.codecImplementationName;
                streamQuality.googAvailableSendBandwidth =
                    playData.googAvailableSendBandwidth;
            }
            if (time != 0) {
                this.player.onPlayQualityUpdate(this.streamId, streamQuality);
            }
        }
    };
    PlayStreamQuality.prototype.uploadPlayQuality = function (playData, now) {
        var _this = this;
        if (!this.qualityUpload) {
            return;
        }
        var timeStamp = now;
        if (this.qualityUploadLastTime == 0 ||
            timeStamp - this.qualityUploadLastTime >= this.qualityUploadInterval) {
            playData["stream_type"] = "play";
            playData["stream_id"] = this.streamId;
            playData["timeStamp"] = parseInt((timeStamp / 1000).toString());
            // 
            playData.video_break_duration = this.videoBreakReport.breakDuration;
            playData.video_break_cancel_duration = this.videoBreakReport.breakCancelDuration;
            playData.video_decode_time = this.videoBreakReport.decodeTime;
            this.videoBreakReport.breakCancelDuration = 0;
            this.videoBreakReport.breakDuration = 0;
            this.videoBreakReport.decodeTime = 0;
            playData.audio_break_duration = this.audioBreakReport.breakDuration;
            playData.audio_break_cancel_duration = this.audioBreakReport.breakCancelDuration;
            playData.audio_decode_time = this.audioBreakReport.decodeTime;
            this.audioBreakReport.breakCancelDuration = 0;
            this.audioBreakReport.breakDuration = 0;
            this.audioBreakReport.decodeTime = 0;
            playData.real_sampling_interval = timeStamp - this.lastSampleTime;
            // if (
            //   playData.real_sampling_interval -
            //     playData.video_decode_time -
            //     playData.video_break_duration +
            //     100 <
            //     0 ||
            //   playData.real_sampling_interval < 3000
            // ) {
            //   debugger;
            // }
            this.lastSampleTime = timeStamp;
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_UPLOAD_PLAYER_QUALITY +
                " " +
                this.streamId +
                " upload" +
                JSON.stringify(playData));
            this.player.streamCenter.updateQuality(1, playData);
            this.player.signal.QualityReport(zego_entity_1.getSeq(), this.sessionId, playData, function (seq, sessionId, data) {
                if (data.report !== undefined) {
                    _this.qualityUpload = data.report;
                    _this.qualityUploadInterval = data.report_interval_ms;
                }
            }, function (err) {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_UPLOAD_PLAYER_QUALITY +
                    " " +
                    _this.streamId +
                    " upload failed " +
                    err);
            });
            this.qualityUploadLastTime = timeStamp;
        }
    };
    PlayStreamQuality.prototype.getP2PNetStats = function () {
        var _this = this;
        this.player.signal.getP2PNetStats(zego_entity_1.getSeq(), this.sessionId, this.peerID, function (seq, sessionID, body) {
            var p2p_lost_rate = body.p2p_lost_rate, p2p_rtt = body.p2p_rtt;
            _this.p2pNetStats.p2pLostRate = p2p_lost_rate || 0;
            _this.p2pNetStats.p2pRTT = p2p_rtt || 0;
        }, function (errcode) {
            // TODO: 
            // if (SEND_MSG_TIMEOUT === errcode) {
            // }
        });
    };
    PlayStreamQuality.prototype.setPlayQualityTimer = function () {
        var _this = this;
        if (this.qualityTimer != null) {
            return;
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SET_PLAYER_QUALITY_TIMER +
            " " +
            this.streamId +
            " startTimer");
        this.clearPlayQualityTimer();
        this.getP2PNetStats();
        this.qualityTimer = setInterval(function () {
            _this.sampleTimes++;
            var peerConnection = _this.player.peerConnection;
            if (peerConnection) {
                var promiseList = [peerConnection.getStats(null)];
                if (_this.player.stateCenter.browser == "chrome") {
                    promiseList.push(new Promise(function (resolve, reject) {
                        peerConnection.getStats(function (results) { return resolve(results); }, function (err) { return reject(err); });
                    }));
                }
                Promise.all(promiseList)
                    .then(function (values) {
                    var stats = _this.getPlayStats(values[0], values[1]);
                })
                    .catch(function (error) {
                    _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SET_PLAYER_QUALITY_TIMER +
                        " " +
                        _this.streamId +
                        " getStats error " +
                        error.toString());
                });
            }
        }, 1000);
        this.lastPlayStats = {
            audioPacketsLost: 0,
            videoPacketsLost: 0,
            time: 0,
            audioTime: 0,
            videoTime: 0,
            audioBytesReceived: 0,
            videoBytesReceived: 0,
            videoPacketsReceived: 0,
            audioPacketsReceived: 0,
            framesDecoded: 0,
            framesReceived: 0,
            framesDropped: 0,
            audioBitrate: 0
        };
    };
    // 
    PlayStreamQuality.prototype.clearPlayQualityTimer = function () {
        if (this.qualityTimer != null) {
            clearInterval(this.qualityTimer);
            this.qualityTimer = null;
            // 
            var now_1 = new Date().getTime();
            this.lastSampleTime = 0;
            this.sampleTimes = 0;
            // console.log("videobreak ");
            // 
            this.totalQuality = {
                totalSquaredInterFrameDelay: 0,
                totalInterFrameDelay: 0,
                framesDecode: 0,
                totalSamplesReceived: 0,
                concealedSamples: 0,
                audioBytesReceived: 0
            };
            var calculateCumulativeDuration = function (breakInfo, breakReport, breakThreshold, isMediaEnabled, isVideo) {
                if (isVideo === void 0) { isVideo = "video"; }
                breakThreshold = breakThreshold > 1000 ? 1000 : breakThreshold;
                // 
                breakReport.breakDuration = 0;
                breakReport.breakCancelDuration = 0;
                breakReport.decodeTime = 0;
                // isVideo === "video" &&
                //   console.log("videobreak breakReport ", this.videoBreakReport);
                // ;
                if (breakInfo.decodeStartTime) {
                    var playEndTime = now_1;
                    // ,
                    var playDuration = playEndTime - breakInfo.decodeStartTime;
                    breakInfo.decodeStartTime = undefined;
                    // console.log(
                    //   isVideo + "BreakDecodeEnd_test 1",
                    //   playEndTime,
                    //   playDuration
                    // );
                    breakInfo.totalDuration += playDuration;
                    // 
                    if (breakInfo.breakStartTime) {
                        var breakEndTime = playEndTime;
                        var breakDuration = breakEndTime - breakInfo.breakStartTime;
                        breakInfo.breakStartTime = undefined;
                        if (!isMediaEnabled) {
                            breakInfo.noBreakNoDecodeDuration += breakDuration;
                            // console.log(
                            //   isVideo + "BreakEnd_test 2",
                            //   breakEndTime,
                            //   breakDuration
                            // );
                        }
                        else if (breakDuration > breakThreshold) {
                            breakInfo.cumulativeBreakDuration += breakDuration;
                            // console.log(
                            //   isVideo + "BreakEnd_test 2",
                            //   breakEndTime,
                            //   breakDuration
                            // );
                        }
                    }
                    // 
                    //  
                    var cumulativeBreakTime = breakInfo.cumulativeBreakDuration;
                    // 
                    var totalDuration = breakInfo.totalDuration, cumulativeBreakDuration = breakInfo.cumulativeBreakDuration, noBreakNoDecodeDuration = breakInfo.noBreakNoDecodeDuration;
                    var cumulativeDecodeTime = totalDuration - cumulativeBreakDuration - noBreakNoDecodeDuration;
                    breakInfo.cumulativeDecodeDuration = cumulativeDecodeTime;
                    return {
                        cumulativeBreakDuration: cumulativeBreakTime,
                        cumulativeDecodeDuration: cumulativeDecodeTime
                    };
                }
                return {
                    cumulativeBreakDuration: 0,
                    cumulativeDecodeDuration: 0
                };
            };
            var enableVideo = this.player.cameraStatus === 0 && this.player.playMediaStatus.video;
            calculateCumulativeDuration(this.videoBreak, this.videoBreakReport, this.videoBreakThreshold, enableVideo);
            var enableAudio = this.player.micStatus === 0 && this.player.playMediaStatus.audio;
            calculateCumulativeDuration(this.audioBreak, this.audioBreakReport, this.audioBreakThreshold, enableAudio, "audio");
        }
        this.lastPlayStats = {
            audioPacketsLost: 0,
            videoPacketsLost: 0,
            time: 0,
            audioTime: 0,
            videoTime: 0,
            audioBytesReceived: 0,
            videoBytesReceived: 0,
            videoPacketsReceived: 0,
            audioPacketsReceived: 0,
            framesDecoded: 0,
            framesDropped: 0,
            framesReceived: 0,
            audioBitrate: 0
        };
    };
    PlayStreamQuality.prototype.startProbeTimeout = function () {
        var _this = this;
        this.probeTimer = setTimeout(function () {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY + " probe timeout");
            _this.player.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kProbeTimeOutError);
        }, this.probeTimeoutInterval);
    };
    PlayStreamQuality.prototype.stopProbeTimeout = function () {
        if (this.probeTimer) {
            clearTimeout(this.probeTimer);
            this.probeTimer = null;
        }
    };
    return PlayStreamQuality;
}());
exports.PlayStreamQuality = PlayStreamQuality;


/***/ }),

/***/ "./sdk/src/webrtc/modules/playModules/zego.play.web.ts":
/*!*************************************************************!*\
  !*** ./sdk/src/webrtc/modules/playModules/zego.play.web.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoPlayWeb = void 0;
var zego_entity_1 = __webpack_require__(/*! ../../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var sdpUtil_1 = __webpack_require__(/*! ../../../util/sdpUtil */ "./sdk/src/util/sdpUtil.ts");
var client_util_1 = __webpack_require__(/*! ../../../util/client-util */ "./sdk/src/util/client-util.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var action_1 = __webpack_require__(/*! ../../../common/action */ "./sdk/src/common/action.ts");
var playStreamQuality_1 = __webpack_require__(/*! ./playStreamQuality */ "./sdk/src/webrtc/modules/playModules/playStreamQuality.ts");
var MAX_MESSAGE_SIZE = 65536;
var MSG_TIMEOUT = 4000;
var MSG_HEADER_SIZE = 10; //1 + 1 + 2 + 2 + 4
var END_OF_MSG = 0x1;
var TYPE_USER_DATA = 1;
var ZegoPlayWeb = /** @class */ (function () {
    function ZegoPlayWeb(log, signal, dataReport, qualityTimeInterval, streamCenter, ac, stateCenter) {
        this.state = zego_entity_1.ENUM_PLAY_STATE.stop;
        this.candidateInfo = [];
        // waitingAnswerTimer: number;
        // waitingAnswerTimeInterval = 0;
        // qualityTimer: any = null;
        // qualityTimeInterval: number;
        //
        this.broadcasterStatus = zego_entity_1.ENUM_BROADCASTER_STATUS.stop;
        this.playQualityList = [];
        this.maxQualityListCount = 10;
        //seq /sdk/api/play_request
        this.reportSeq = NaN;
        //RTCplayStream
        this.streamReportSeq = zego_entity_1.getSeq();
        this.videoSizeCallback = false;
        this.remoteStream = null;
        this.playStream = null;
        this.playOption = {};
        this.playMediaStatus = {
            video: true,
            audio: true
        };
        this.closeSessionSignal = false;
        this.stateNego = zego_entity_1.ENUM_PLAY_STATE_NEGO.stop;
        this.negoTimer = null;
        this.negoInterval = 25000;
        //, 0   0   2 
        this.cameraStatus = 0;
        this.micStatus = 0;
        this.hasSentStreamStatus = false;
        this.playEvent = false;
        this.gotStreamStatus = false;
        this.soundLevel = 0;
        this.mic = null;
        this.script = null;
        //
        this.beginTime = 0;
        this.firstFrameTime = 0;
        //l3
        this.resourceMode = 0;
        //
        this.gwNode = "";
        this.gwNodeList = [];
        this.gwNodeTTL = 0;
        //peer
        this.isPeer = false;
        this.peerFailCount = 0;
        //
        this.isProbe = false;
        this.peerID = 0;
        // netQuality = 0;
        // probeTime = 0;
        // probeInterval = 60000;
        // probeState = ENUM_PROBE_STATE.probed;
        this.isRecvClientInfo = false;
        /** */
        this.audioMuteState = "0";
        /** */
        this.videoMuteState = "0";
        this.first_pkt = true;
        this.next_sn = [];
        this.pkt_list = [];
        this.onDataChannelList = [];
        this.iceDisconnectedMaxTime = 15000;
        this.logger = log;
        this.signal = signal;
        this.dataReport = dataReport;
        this.streamCenter = streamCenter;
        this.ac = ac;
        this.stateCenter = stateCenter;
        this.dataReport.newReport(this.streamReportSeq);
        this.dataReport.addMsgInfo(this.streamReportSeq, {
            abs_time: Date.now()
        });
        this.qualityHandler = new playStreamQuality_1.PlayStreamQuality(qualityTimeInterval, this, this.logger, this.dataReport);
        this.resourceMode = this.stateCenter.settingConfig.getSetting("resource_mode");
    }
    Object.defineProperty(ZegoPlayWeb.prototype, "probeState", {
        get: function () {
            return this.qualityHandler.probeState;
        },
        set: function (state) {
            this.qualityHandler.probeState = state;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ZegoPlayWeb.prototype, "netQuality", {
        get: function () {
            return this.qualityHandler.netQuality;
        },
        set: function (val) {
            this.qualityHandler.netQuality = val;
        },
        enumerable: false,
        configurable: true
    });
    ZegoPlayWeb.prototype.startPlay = function (streamId, success, playOption) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY + " called ", streamId);
        this.playEvent = false;
        this.signal &&
            this.signal.negoInterval &&
            (this.negoInterval = this.signal.negoInterval);
        if (!streamId) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY + " streamId is null");
            return;
        }
        this.streamId = streamId;
        this.getRemoteStreamSuc = success;
        this.playOption = playOption || {};
        this.playMediaStatus = {
            video: this.playOption.video === undefined ? true : !!this.playOption.video,
            audio: this.playOption.audio === undefined ? true : !!this.playOption.audio
        };
        if (playOption && playOption.videoCodec) {
            this.playOption.videoCodec = playOption.videoCodec;
        }
        var _videoCodec = this.stateCenter.settingConfig.getSetting("play_video_codec", true);
        if (_videoCodec) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY +
                " setting play_video_codec " +
                _videoCodec);
            this.playOption.videoCodec = _videoCodec;
        }
        this.dataReport.addMsgInfo(this.reportSeq, {
            audio_activate: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.audio_activate(this.playOption.audio == true
                ? 1
                : this.playOption.audio == false
                    ? 0
                    : 1),
            video_activate: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.video_activate(this.playOption.video == true
                ? 1
                : this.playOption.video == false
                    ? 0
                    : 1)
        });
        this.isPeer ? this.createOffer() : this.createSession();
        // 
        this.negoTimer = setTimeout(function () {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY + " waiting timeout");
            _this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayNegoTimeoutError);
        }, this.negoInterval);
        // 
        this.isProbe && this.qualityHandler.startProbeTimeout();
        //
        //   (this.qualityHandler.probeTimer = setTimeout(() => {
        //     this.logger.error(
        //       ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY + " probe timeout"
        //     );
        //     this.playStateUpdateError(
        //       ZegoRTCLogEvent.kZegoTaskPlayStart.error.kProbeTimeOutError
        //     );
        //   }, this.qualityHandler.probeTimeoutInterval));
    };
    ZegoPlayWeb.prototype.onCreatePlaySessionSuccess = function (data) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
            " " +
            this.streamId +
            " success");
        var urls = [];
        if (data.turn_server) {
            var turnServer = data.turn_server;
            var _turnToTcp = this.stateCenter.turnOverTcpOnly;
            var udpOrTcp = this.stateCenter.settingConfig.getSetting("udp_or_tcp", true);
            if (udpOrTcp) {
                this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
                    " setting udp_or_tcp " +
                    udpOrTcp);
                _turnToTcp = udpOrTcp === "tcp";
            }
            _turnToTcp && (turnServer = turnServer.replace("udp", "tcp"));
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
                " turn over tcp " +
                turnServer);
            urls.push(turnServer);
        }
        if (data.stun_server)
            urls.push(data.stun_server);
        var configuration = {
            iceTransportPolicy: "relay",
            iceServers: [
                {
                    urls: urls,
                    username: data.turn_username,
                    credential: data.turn_auth_key
                }
            ]
        };
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
            " " +
            this.streamId +
            " username: " +
            data.turn_username);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
            " " +
            this.streamId +
            " credential: " +
            data.turn_auth_key);
        this.createOffer(configuration);
        //register callback
        this.signal.registerPushCallback("MediaDescPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvMediaDesc(seq, sessionId, data);
        });
        this.signal.registerPushCallback("CandidateInfoPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvCandidateInfo(seq, sessionId, data);
        });
        this.signal.registerPushCallback("CloseSessionPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvCloseSession(seq, sessionId, data);
        });
        // this.signal.registerPushCallback("WebSocketDisconnect", this.sessionId, onDisconnect, this);
        this.signal.registerPushCallback("SessionResetPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvResetSession(seq, sessionId, data);
        });
        this.signal.registerPushCallback("StreamStatusNotifyPush", this.sessionId, function (seq, sessionId, data) {
            _this.gotStreamStatus = true;
            _this.streamStatus = data;
            _this.playStream && _this.onRecvStreamStatus(data);
        });
        this.signal.registerPushCallback("PlayEventPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvPlayEvent(seq, sessionId, data);
        });
        this.signal.registerPushCallback("ClientInfoPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvClientInfo(seq, sessionId, data);
        });
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
            " " +
            this.streamId +
            " call success");
    };
    ZegoPlayWeb.prototype.createOffer = function (configuration) {
        var _this = this;
        this.peerConnection = new RTCPeerConnection(configuration);
        this.peerConnection.onicecandidate = function (e) {
            _this.onIceCandidate(e);
        };
        this.peerConnection.onsignalingstatechange = function (e) {
            _this.onConnectionStateChange(e);
        };
        this.peerConnection.oniceconnectionstatechange = function (e) {
            _this.onIceConnectionStateChange(e);
        };
        this.peerConnection.ontrack = function (e) {
            _this.onGotRemoteStream(e.streams[0]);
        };
        if (this.streamCenter.isDataChannelEnabled) {
            this.dataChannel = this.peerConnection.createDataChannel(this.streamId);
            this.dataChannel.binaryType = "arraybuffer";
            this.dataChannel.onopen = function (event) {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
                    " " +
                    _this.streamId +
                    " data channel open");
            };
            this.dataChannel.onmessage = function (event) {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
                    " " +
                    _this.streamId +
                    " data channel onmessage");
                if (event.data instanceof Blob) {
                    var reader_1 = new FileReader();
                    var _event_1 = {};
                    reader_1.readAsArrayBuffer(event.data);
                    reader_1.onload = function () {
                        _event_1.data = reader_1.result;
                        _this.onReceivedDataChannel(_event_1);
                    };
                    // (event.data as Blob).arrayBuffer().then(data => {
                    //   _event.data = data;
                    //   this.onReceivedDataChannel(_event);
                    // });
                }
                else {
                    _this.onReceivedDataChannel(event);
                }
            };
        }
        var offerOptions = {
            offerToReceiveAudio: 1,
            offerToReceiveVideo: 1
        };
        if (this.playOption && this.playOption.video === false) {
            offerOptions.offerToReceiveVideo = 0;
        }
        if (this.playOption && this.playOption.audio === false) {
            offerOptions.offerToReceiveAudio = 0;
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
            " " +
            this.streamId +
            " createOffer: " +
            JSON.stringify(offerOptions));
        //create offer
        this.dataReport.eventStart(this.reportSeq, "CreateOffer");
        this.dataReport.eventStart(this.streamReportSeq, "CreateOffer");
        this.peerConnection.createOffer(offerOptions).then(function (desc) {
            _this.dataReport.eventEnd(_this.reportSeq, "CreateOffer");
            _this.dataReport.eventEnd(_this.streamReportSeq, "CreateOffer");
            _this.onCreateOfferSuccess(desc);
        }, function (error) {
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "CreateOffer", {
                error: error.toString()
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "CreateOffer", {
                error: error.toString()
            });
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_PLAY_SESSION_SUCCESS +
                " " +
                _this.streamId +
                " create offer error " +
                error.toString());
            _this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kCreateOfferError, true);
        });
    };
    ZegoPlayWeb.prototype.createSession = function (desc) {
        var _this = this;
        //create session
        this.sessionSeq = zego_entity_1.getSeq();
        var totalStreamId = this.streamId;
        if (this.streamCenter.testEnvironment == true) {
            totalStreamId =
                "zegotest-" + this.streamCenter.appid + "-" + this.streamId;
        }
        // 
        var gwNodes = this.stateCenter.settingConfig.getSetting("gw_nodes");
        if (gwNodes && gwNodes instanceof Array && gwNodes.length > 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY +
                " setting " +
                JSON.stringify(gwNodes));
            this.gwNodeList = gwNodes;
            this.gwNode = this.gwNodeList[0] || this.gwNode;
        }
        if (this.isPeer) {
            this.dataReport.eventStart(this.reportSeq, "CreateSessionWithSdp");
            this.dataReport.eventStart(this.streamReportSeq, "CreateSessionWithSdp");
            var _bufLevel = this.stateCenter.settingConfig.getSetting("l3_play_buffer_ms");
            this.signal.createSessionWithSdp({
                seq: this.sessionSeq,
                type: this.isProbe ? 2 : 1,
                mode: 0,
                streamId: totalStreamId,
                strAuthParam: this.playOption
                    ? this.playOption.streamParams || ""
                    : "",
                sdp: desc.sdp,
                serverHost: this.gwNode,
                playBufLevel: this.resourceMode == 2 ? _bufLevel : undefined
            }, function (seq, sessionID, msg) {
                _this.handleCreateSessionWithSdpResp(seq, sessionID, msg);
            }, function (err, seq) {
                _this.dataReport.eventEndWithMsg(_this.reportSeq, "CreateSession", {
                    error: err
                });
                _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "CreateSession", {
                    error: err
                });
                //peer,peer
                if (!_this.isProbe &&
                    err == zego_entity_1.SEND_MSG_TIMEOUT &&
                    _this.peerFailCount < 2) {
                    _this.peerFailCount++;
                    _this.createSession(desc);
                }
                else if (!_this.isProbe &&
                    err == zego_entity_1.SEND_MSG_TIMEOUT &&
                    _this.peerFailCount >= 2) {
                    _this.isPeer = false;
                    _this.streamCenter.isPeer = false;
                    _this.createSession();
                }
                else {
                    _this.playStateUpdateError(err == zego_entity_1.SEND_MSG_TIMEOUT
                        ? zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kSessionTimeoutError
                        : zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kSessionRequestError);
                }
            });
        }
        else {
            this.dataReport.eventStart(this.reportSeq, "CreateSession");
            this.dataReport.eventStart(this.streamReportSeq, "CreateSession");
            this.signal.createSession(this.sessionSeq, 1, 0, totalStreamId, this.playOption && this.playOption.streamParams, this.gwNode, function (seq, sessionID, msg) {
                _this.handleCreateSessionResp(seq, sessionID, msg);
            }, function (err, seq) {
                _this.dataReport.eventEndWithMsg(_this.reportSeq, "CreateSession", {
                    error: err
                });
                _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "CreateSession", {
                    error: err
                });
                _this.playStateUpdateError(err == zego_entity_1.SEND_MSG_TIMEOUT
                    ? zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kSessionTimeoutError
                    : zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kSessionRequestError);
            });
        }
        this.state = zego_entity_1.ENUM_PLAY_STATE.waitingSessionRsp;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY +
            " " +
            this.streamId +
            " called success");
        this.stateNego = zego_entity_1.ENUM_PLAY_STATE_NEGO.start;
    };
    ZegoPlayWeb.prototype.handleCreateSessionResp = function (seq, sessionID, msg) {
        var turnServer = msg.turn_server;
        var ip = turnServer.split("?")[0] && turnServer.split("?")[0].slice(5);
        var serverArr = this.streamCenter.server.split("?");
        var app = serverArr[1] && serverArr[1].slice(2);
        this.dataReport.eventEndWithMsg(this.streamReportSeq, "CreateSession", {
            sessionId: msg.session_id,
            url: "webrtc://" + ip + "/" + app + "/" + this.streamId
        });
        this.dataReport.eventEndWithMsg(this.reportSeq, "CreateSession", {
            sessionId: msg.session_id,
            url: "webrtc://" + ip + "/" + app + "/" + this.streamId
        });
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY +
            " " +
            this.streamId +
            " sessionId:" +
            msg.session_id);
        if (this.sessionSeq != seq) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY + " seq is not match.");
            return;
        }
        this.gwNodeList =
            msg.gw_nodes && msg.gw_nodes.length > 0 ? msg.gw_nodes : this.gwNodeList;
        this.gwNode =
            msg.gw_nodes && msg.gw_nodes.length > 0
                ? this.gwNodeList[0]
                : this.gwNode;
        this.gwNodeTTL = msg.gw_nodes_ttl
            ? new Date().getTime() + msg.gw_nodes_ttl * 1000
            : this.gwNodeTTL;
        this.stateCenter.clientIP = msg.clientip
            ? msg.clientip
            : this.stateCenter.clientIP;
        if (msg.result !== 0) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_PLAY +
                " " +
                this.streamId +
                " create error");
            this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kSessionRequestError);
        }
        else {
            this.sessionId = msg.session_id;
            this.sessionToken = msg.session_token;
            this.dataReport.addMsgInfo(this.reportSeq, {
                session_id: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.session_id(this.sessionId)
            });
            this.onCreatePlaySessionSuccess(msg);
        }
    };
    ZegoPlayWeb.prototype.handleCreateSessionWithSdpResp = function (seq, sessionID, msg) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_HANDLE_CREATE_SESSION_WITH_SDP +
            " sessionId:" +
            sessionID);
        if (this.sessionSeq != seq) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_HANDLE_CREATE_SESSION_WITH_SDP +
                " seq is not match.");
            return;
        }
        this.gwNodeList =
            msg.gw_nodes && msg.gw_nodes.length > 0 ? msg.gw_nodes : this.gwNodeList;
        this.gwNode =
            msg.gw_nodes && msg.gw_nodes.length > 0
                ? this.gwNodeList[0]
                : this.gwNode;
        this.gwNodeTTL = msg.gw_nodes_ttl
            ? new Date().getTime() + msg.gw_nodes_ttl * 1000
            : this.gwNodeTTL;
        this.stateCenter.clientIP = msg.clientip
            ? msg.clientip
            : this.stateCenter.clientIP;
        this.dataReport.eventEndWithMsg(this.streamReportSeq, "CreateSessionWithSdp", {
            sessionId: sessionID
        });
        this.dataReport.eventEndWithMsg(this.reportSeq, "CreateSessionWithSdp", {
            sessionId: sessionID
        });
        if (msg.result !== 0) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_HANDLE_CREATE_SESSION_WITH_SDP +
                " create session failed " +
                msg.result);
            this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kSessionRequestError);
        }
        else {
            this.sessionId = sessionID;
            this.sessionToken = msg.session_token;
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_HANDLE_CREATE_SESSION_WITH_SDP +
                " create session success ", this.streamId);
            this.signal.registerPushCallback("CloseSessionPush", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvCloseSession(seq, sessionId, data);
            });
            // this.signal.registerPushCallback("WebSocketDisconnect", this.sessionId, onDisconnect, this);
            this.signal.registerPushCallback("SessionResetPush", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvResetSession(seq, sessionId, data);
            });
            this.signal.registerPushCallback("StreamStatusNotifyPush", this.sessionId, function (seq, sessionId, data) {
                _this.gotStreamStatus = true;
                _this.streamStatus = data;
                _this.playStream && _this.onRecvStreamStatus(data);
            });
            this.signal.registerPushCallback("PlayEventPush", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvPlayEvent(seq, sessionId, data);
            });
            this.signal.registerPushCallback("ClientInfoPush", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvClientInfo(seq, sessionId, data);
            });
            //
            this.signal.registerPushCallback("NetQualityProbeRsp", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvPlayEvent(seq, sessionId, data);
            });
            this.signal.registerPushCallback("NetQualityInfoPush", this.sessionId, function (seq, sessionID, data) {
                _this.onRecvNetQualityInfo(seq, sessionID, data);
            });
            this.onGetRemoteOfferSuccess(msg.sdp);
        }
    };
    ZegoPlayWeb.prototype.onCreateOfferSuccess = function (desc) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_OFFER_SUCCESS +
            " " +
            this.streamId +
            " localSdp1 " +
            desc.sdp.substr(0, desc.sdp.length / 2));
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_OFFER_SUCCESS +
            " " +
            this.streamId +
            " localSdp2 " +
            desc.sdp.substr(desc.sdp.length / 2));
        desc.sdp = desc.sdp.replace(/sendrecv/g, "recvonly");
        desc.sdp = desc.sdp.replace(/useinbandfec=/, "stereo=1;useinbandfec=");
        var dataChannelSdp = desc.sdp.match(/m=application[\s\S]+datachannel[\s\S]+/)
            ? desc.sdp.match(/m=application[\s\S]+datachannel[\s\S]+/)[0]
            : null;
        if (dataChannelSdp) {
            var newDataChannelSdp = dataChannelSdp.replace(/recvonly/, "sendrecv");
            desc.sdp = desc.sdp.replace(dataChannelSdp, newDataChannelSdp);
        }
        // 
        var video_fmtp = desc.sdp.match(/m=video(.|\r|\n)*a=rtpmap(.|\r|\n)*(a=fmtp:(102).*)/);
        if (video_fmtp !== null) {
            var fmtp = video_fmtp[3];
            desc.sdp = desc.sdp.replace(fmtp, fmtp + ";sps-pps-idr-in-keyframe=1");
        }
        if (this.playOption.videoCodec) {
            desc.sdp = sdpUtil_1.SdpUtil.getSDPByVideDecodeType(desc.sdp, this.playOption.videoCodec);
        }
        this.dataReport.eventStart(this.reportSeq, "SetLocalDescription");
        this.dataReport.eventStart(this.streamReportSeq, "SetLocalDescription");
        this.peerConnection.setLocalDescription(desc).then(function () {
            _this.dataReport.eventEnd(_this.reportSeq, "SetLocalDescription");
            _this.dataReport.eventEnd(_this.streamReportSeq, "SetLocalDescription");
            _this.onSetLocalDescriptionSuccess(desc);
        }, function (error) {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CREATE_OFFER_SUCCESS +
                " " +
                _this.streamId +
                " set error " +
                error.toString());
            _this.dataReport.eventEnd(_this.reportSeq, "SetLocalDescription", {
                error: error.toString()
            });
            _this.dataReport.eventEnd(_this.streamReportSeq, "SetLocalDescription", {
                error: error.toString()
            });
            _this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kSetLocalDescError, true);
        });
    };
    ZegoPlayWeb.prototype.onSetLocalDescriptionSuccess = function (desc) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
            " " +
            this.streamId +
            " success");
        if (this.isPeer) {
            this.createSession(desc);
            return;
        }
        var mediaDescription = {
            sdp: desc.sdp
        };
        if (this.resourceMode == 2) {
            mediaDescription["min_play_buf_level_ms"] = 500;
        }
        this.answerSeq = zego_entity_1.getSeq();
        this.dataReport.eventStart(this.reportSeq, "SendMediaDesc");
        this.dataReport.eventStart(this.streamReportSeq, "SendMediaDesc");
        this.signal.sendMediaDesc(this.answerSeq, this.sessionId, 0, mediaDescription, function (seq, sessionId, data) {
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
                " " +
                _this.streamId +
                " sendMediaDesc resp");
            if (_this.answerSeq != seq || _this.sessionId != sessionId) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
                    " " +
                    _this.streamId +
                    " seq or sessionId is not equal " +
                    _this.answerSeq +
                    " " +
                    seq, +" " + _this.sessionId + " " + sessionId);
                return;
            }
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
                " " +
                _this.streamId +
                " send success stateNego:waiterAnswer");
            _this.stateNego = zego_entity_1.ENUM_PLAY_STATE_NEGO.waiterAnswer;
            _this.dataReport.eventEnd(_this.reportSeq, "SendMediaDesc");
            _this.dataReport.eventEnd(_this.streamReportSeq, "SendMediaDesc");
            _this.state = zego_entity_1.ENUM_PLAY_STATE.waitingServerAnswer;
        }, function (err, seq) {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
                " " +
                _this.streamId +
                " failed to send " +
                err);
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "SendMediaDesc", {
                error: err
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "SendMediaDesc", {
                error: err
            });
            _this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kMediaDescError);
        });
        this.state = zego_entity_1.ENUM_PLAY_STATE.waitingOfferRsp;
    };
    ZegoPlayWeb.prototype.onRecvMediaDesc = function (seq, sessionId, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_MEDIA_DESC +
            " " +
            this.streamId +
            " received ", data);
        this.stateNego = zego_entity_1.ENUM_PLAY_STATE_NEGO.waitingCandidate;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_MEDIA_DESC +
            " " +
            this.streamId +
            " received stateNego:waitingCandidate");
        if (this.state !== zego_entity_1.ENUM_PLAY_STATE.waitingServerAnswer) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_MEDIA_DESC +
                " " +
                this.streamId +
                " current state " +
                this.state +
                " not allowed");
            return;
        }
        this.dataReport.addEvent(this.reportSeq, "RecvMediaDesc");
        this.dataReport.addEvent(this.streamReportSeq, "RecvMediaDesc");
        this.signal.sendMediaDescAck(seq, this.sessionId, 0);
        this.onGetRemoteOfferSuccess(data.sdp);
    };
    ZegoPlayWeb.prototype.onGetRemoteOfferSuccess = function (sdp) {
        var _this = this;
        var _a;
        var offerDescription = {
            type: "answer",
            sdp: sdp,
            toJSON: function () { }
        };
        //setRemoteDescritpion
        this.dataReport.eventStart(this.reportSeq, "SetRemoteDescription");
        this.dataReport.eventStart(this.streamReportSeq, "SetRemoteDescription");
        var _turnToTcp = this.stateCenter.turnOverTcpOnly;
        var udpOrTcp = this.stateCenter.settingConfig.getSetting("udp_or_tcp", true);
        if (udpOrTcp) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_MEDIA_DESC +
                " setting udp_or_tcp " +
                udpOrTcp);
            _turnToTcp = udpOrTcp === "tcp";
        }
        if (_turnToTcp) {
            (_a = offerDescription.sdp.match(/candidate.*/g)) === null || _a === void 0 ? void 0 : _a.forEach(function (candStr) {
                var repCandStr = candStr.replace(/udp/, "tcp");
                //@ts-ignore
                offerDescription.sdp = offerDescription.sdp.replace(candStr, repCandStr);
            });
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_MEDIA_DESC +
            " " +
            this.streamId +
            " remoteSdp ", offerDescription.sdp);
        this.peerConnection
            .setRemoteDescription(new RTCSessionDescription(offerDescription))
            .then(function () {
            _this.dataReport.eventEnd(_this.reportSeq, "SetRemoteDescription");
            _this.dataReport.eventEnd(_this.streamReportSeq, "SetRemoteDescription");
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_MEDIA_DESC +
                " " +
                _this.streamId +
                " set success");
        }, function (error) {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_MEDIA_DESC +
                " " +
                _this.streamId +
                " set remote error " +
                error.toString());
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "SetRemoteDescription", {
                error: error.toString()
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "SetRemoteDescription", {
                error: error.toString()
            });
            _this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kSetRemoteDescError, true);
        });
        this.state = zego_entity_1.ENUM_PLAY_STATE.waitingServerICE;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_MEDIA_DESC +
            " " +
            this.streamId +
            " call success");
    };
    ZegoPlayWeb.prototype.onRecvCandidateInfo = function (seq, sessionId, data) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_CANDIDATE_INFO +
            " " +
            this.streamId +
            " received ");
        if (this.state != zego_entity_1.ENUM_PLAY_STATE.waitingServerICE) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_CANDIDATE_INFO +
                " " +
                this.streamId +
                " current state " +
                this.state +
                " not allowed");
            return;
        }
        this.dataReport.addEvent(this.reportSeq, "RecvIceCandidate");
        this.dataReport.addEvent(this.streamReportSeq, "RecvIceCandidate");
        this.signal.sendCandidateInfoAck(seq, this.sessionId, 0);
        //send candidate
        this.sendCandidateInfo(this.candidateInfo);
        this.candidateInfo = [];
        for (var i = 0; i < data.infos.length; i++) {
            var ice = {
                sdpMid: data.infos[i].sdpMid,
                sdpMLineIndex: data.infos[i].sdpMLineIndex,
                candidate: data.infos[i].candidate
            };
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_CANDIDATE_INFO +
                " " +
                this.streamId +
                " candidate " +
                ice.candidate);
            this.peerConnection.addIceCandidate(new RTCIceCandidate(ice)).then(function () {
                _this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_CANDIDATE_INFO +
                    " " +
                    _this.streamId +
                    " add success");
            }, function (error) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_CANDIDATE_INFO +
                    " " +
                    _this.streamId +
                    " add error " +
                    error.toString());
                _this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kCandidateError, true);
            });
        }
        this.state = zego_entity_1.ENUM_PLAY_STATE.connecting;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_CANDIDATE_INFO +
            " " +
            this.streamId +
            " call success");
    };
    ZegoPlayWeb.prototype.onRecvPlayEvent = function (seq, sessionId, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_PLAY_EVENT +
            " " +
            this.streamId +
            " received");
        if (this.playEvent === true && data.event == 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_PLAY_EVENT +
                " " +
                this.streamId +
                " retry: " +
                this.streamId);
            var streamId = this.streamId;
            var playOption = this.playOption;
            this.signal.sendCloseSession(zego_entity_1.getSeq(), this.sessionId, 1);
            this.resetPlay();
            this.startPlay(streamId, this.getRemoteStreamSuc, playOption);
        }
        else {
            this.playEvent = true;
        }
    };
    ZegoPlayWeb.prototype.onRecvClientInfo = function (seq, sessionId, data) {
        //ip
        if (this.stateCenter.clientIP !== data.clientip) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_CLIENT_INFO +
                " " +
                "client ip changed " +
                this.stateCenter.clientIP +
                " " +
                data.clientip);
            // const error = ZegoRTCLogEvent.kZegoTaskPlayStart.error.kClientIPChangedError;
            // this.gwNode = "";
            // this.gwNodeList = [];
            // this.gwNodeTTL = 0;
            // this.playStateUpdateError (error);
        }
        this.stateCenter.clientIP = data.clientip;
        this.peerID = data.peer_id;
        if (this.isProbe && this.stateNego == zego_entity_1.ENUM_PLAY_STATE_NEGO.iceConnected) {
            this.signal.sendNetProbe(zego_entity_1.getSeq(), this.sessionId, this.peerID, function () { }, function () { });
        }
        this.isRecvClientInfo = true;
    };
    ZegoPlayWeb.prototype.onRecvNetQualityInfo = function (seq, sessionID, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_NET_QUALITY_INFO + " call");
        this.qualityHandler.stopProbeTimeout();
        var result = 0;
        var lossrate = data.lossrate;
        var rtt = data.rtt;
        if (this.peerID !== data.peer_id ||
            typeof lossrate == undefined ||
            typeof rtt == undefined) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_NET_QUALITY_INFO +
                " local peerID:" +
                this.peerID +
                " remote peerID:" +
                data.peer_id +
                " lossrate:" +
                lossrate +
                " rtt:" +
                rtt);
            result = 1;
        }
        this.signal.sendNetQualityInfoPushAck(zego_entity_1.getSeq(), this.sessionId, this.peerID, result);
        if (result == 0 && typeof lossrate == "number" && typeof rtt == "number") {
            //todo calculate net quality
            this.onCalNetQualityResult(0, client_util_1.ClientUtil.getNetQuality(rtt, lossrate));
        }
        else {
            this.onCalNetQualityResult(1);
        }
    };
    ZegoPlayWeb.prototype.onIceCandidate = function (event) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_ICE_CANDIDATE +
            " " +
            this.streamId +
            " called");
        //send candidate to other peer
        if (event.candidate == undefined) {
            return;
        }
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_ICE_CANDIDATE +
            " " +
            this.streamId +
            " candidate " +
            event.candidate.candidate);
        if (this.state < zego_entity_1.ENUM_PLAY_STATE.connecting ||
            this.state == zego_entity_1.ENUM_PLAY_STATE.stop) {
            //save candidate Info
            this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_ICE_CANDIDATE +
                " " +
                this.streamId +
                " cached");
            this.candidateInfo.push({
                candidate: event.candidate.candidate,
                sdpMid: event.candidate.sdpMid,
                sdpMLineIndex: event.candidate.sdpMLineIndex
            });
        }
        else {
            this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_ICE_CANDIDATE +
                " " +
                this.streamId +
                " send");
            var candidate = {
                candidate: event.candidate.candidate,
                sdpMid: event.candidate.sdpMid,
                sdpMLineIndex: event.candidate.sdpMLineIndex
            };
            this.sendCandidateInfo([candidate]);
        }
    };
    ZegoPlayWeb.prototype.onConnectionStateChange = function (event) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_CONNECTION_STATE_CHANGE +
            " " +
            this.streamId +
            " called " +
            event.target.signalingState);
    };
    ZegoPlayWeb.prototype.onIceConnectionStateChange = function (event) {
        var _this = this;
        if (this.state == zego_entity_1.ENUM_PLAY_STATE.stop || this.peerConnection == null) {
            return;
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_ICE_CONNECTION_STATE_CHANGE +
            " " +
            this.streamId +
            " stateChanged " +
            this.peerConnection.iceConnectionState);
        if (this.peerConnection.iceConnectionState === "connected") {
            this.stateNego = zego_entity_1.ENUM_PLAY_STATE_NEGO.iceConnected;
            if (this.isProbe && this.isPeer && this.isRecvClientInfo) {
                this.signal.sendNetProbe(zego_entity_1.getSeq(), this.sessionId, this.peerID, function () { }, function () { });
                if (this.negoTimer != null) {
                    clearTimeout(this.negoTimer);
                    this.negoTimer = null;
                }
                return;
            }
            if (this.negoTimer != null) {
                clearTimeout(this.negoTimer);
                this.negoTimer = null;
            }
            if (this.iceDisconnectedTimer != null) {
                clearTimeout(this.iceDisconnectedTimer);
                this.iceDisconnectedTimer = null;
            }
            this.dataReport.addEvent(this.reportSeq, "IceConnected");
            this.dataReport.addEvent(this.streamReportSeq, "IceConnected");
            if (this.state != zego_entity_1.ENUM_PLAY_STATE.playing) {
                this.onPlayStateUpdate(zego_entity_1.ENUM_PLAY_STATE_UPDATE.start, this.streamId, { code: 0, message: "" }, true);
                this.getRemoteStreamSuc && this.getRemoteStreamSuc(this.playStream);
            }
            this.state = zego_entity_1.ENUM_PLAY_STATE.playing;
            //play started
            this.dataReport.eventStart(this.reportSeq, "PlayState");
            this.dataReport.eventStart(this.streamReportSeq, "PlayState");
            //BroadcasterStatusNotify
            for (var i in this.streamCenter.publisherList) {
                var publisher = this.streamCenter.publisherList[i]
                    .publisher;
                if (publisher.state == zego_entity_1.ENUM_PUBLISH_STATE.publishing &&
                    this.broadcasterStatus == zego_entity_1.ENUM_BROADCASTER_STATUS.stop) {
                    this.signal &&
                        this.signal.sendBroadcasterStatus(zego_entity_1.getSeq(), this.sessionId, 1);
                    this.broadcasterStatus = zego_entity_1.ENUM_BROADCASTER_STATUS.start;
                    break;
                }
            }
            //start quality timeInterval
            !this.isProbe && this.qualityHandler.setPlayQualityTimer();
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_ICE_CONNECTION_STATE_CHANGE +
                " " +
                this.streamId +
                " stateNego:iceConnected");
            if (this.isPeer) {
                this.peerFailCount = 0;
            }
            //videoaudivideo
            if (this.firstFrameTime == 0) {
                this.firstFrameTime = new Date().getTime() - this.beginTime;
                var reportSeq = zego_entity_1.getReportSeq();
                this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayDecodeFirstVideoFrame.event);
                this.dataReport.addMsgInfo(reportSeq, {
                    session_id: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayDecodeFirstVideoFrame.session_id(this.sessionId),
                    fft_consumed: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayDecodeFirstVideoFrame.fft_consumed(this.firstFrameTime)
                });
                !this.isProbe && this.dataReport.uploadReport(reportSeq);
            }
        }
        else if (this.peerConnection.iceConnectionState === "closed") {
            this.dataReport.addEvent(this.reportSeq, "IceClosed");
            this.stateNego = zego_entity_1.ENUM_PLAY_STATE_NEGO.iceClosed;
            this.checkPlayConnectionFailedState(this.peerConnection.iceConnectionState);
        }
        else if (this.peerConnection.iceConnectionState === "failed") {
            this.dataReport.addEvent(this.reportSeq, "IceFailed");
            this.stateNego = zego_entity_1.ENUM_PLAY_STATE_NEGO.iceFailed;
            this.checkPlayConnectionFailedState(this.peerConnection.iceConnectionState);
        }
        else if (this.peerConnection.iceConnectionState === "disconnected") {
            this.dataReport.addEvent(this.reportSeq, "IceDisconnected");
            this.stateNego = zego_entity_1.ENUM_PLAY_STATE_NEGO.iceDisconnected;
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_ICE_CONNECTION_STATE_CHANGE +
                " ice disconnected");
            if (!this.iceDisconnectedTimer) {
                this.iceDisconnectedTimer = setTimeout(function () {
                    _this.checkPlayConnectionFailedState("disconnected");
                }, this.iceDisconnectedMaxTime);
            }
        }
    };
    ZegoPlayWeb.prototype.checkPlayConnectionFailedState = function (connectionState) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_ICE_CONNECTION_STATE_CHANGE +
            "  state " +
            this.state +
            " connectionState " +
            connectionState);
        this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kMediaConnectionError);
    };
    // private clearPlayQualityTimer(): void {
    //   if (this.qualityTimer != null) {
    //     clearInterval(this.qualityTimer);
    //     this.qualityTimer = null;
    //   }
    //   this.lastPlayStats = {
    //     audioPacketsLost: 0,
    //     videoPacketsLost: 0,
    //     time: 0,
    //     audioTime: 0,
    //     videoTime: 0,
    //     audioBytesReceived: 0,
    //     videoBytesReceived: 0,
    //     videoPacketsReceived: 0,
    //     audioPacketsReceived: 0,
    //     framesDecoded: 0,
    //     framesDropped: 0,
    //     framesReceived: 0,
    //     audioBitrate: 0
    //   };
    // }
    // p2pNetStats: {
    //   p2pLostRate: number;
    //   p2pRTT: number;
    // } = {
    //   p2pLostRate: 0,
    //   p2pRTT: 0
    // };
    // private getP2PNetStats(): void {
    //   this.signal.getP2PNetStats(
    //     getSeq(),
    //     this.sessionId,
    //     this.peerID,
    //     (seq: number, sessionID: string, body: any) => {
    //       console.log("getP2PNetStats", body);
    //       const { p2p_lost_rate, p2p_rtt } = body;
    //       this.p2pNetStats.p2pLostRate = p2p_lost_rate;
    //       this.p2pNetStats.p2pRTT = p2p_rtt;
    //     },
    //     (errcode: number) => {
    //       // TODO: 
    //       // if (SEND_MSG_TIMEOUT === errcode) {
    //       // }
    //     }
    //   );
    // }
    ZegoPlayWeb.prototype.resetPlay = function () {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_RESET_PLAY + " " + this.streamId + " call");
        this.state = zego_entity_1.ENUM_PLAY_STATE.stop;
        this.playEvent = false;
        this.isRecvClientInfo = false;
        if (this.peerConnection != undefined) {
            this.peerConnection.close();
            this.peerConnection = null;
        }
        if (this.negoTimer != null) {
            clearTimeout(this.negoTimer);
            this.negoTimer = null;
        }
        if (this.iceDisconnectedTimer != null) {
            clearTimeout(this.iceDisconnectedTimer);
            this.iceDisconnectedTimer = null;
        }
        this.qualityHandler.stopProbeTimeout();
        this.qualityHandler.clearPlayQualityTimer();
        if (this.signal) {
            this.signal.unregisterPushCallback("MediaDescPush", this.sessionId);
            this.signal.unregisterPushCallback("CandidateInfoPush", this.sessionId);
            this.signal.unregisterPushCallback("CloseSessionPush", this.sessionId);
            this.signal.unregisterPushCallback("SessionResetPush", this.sessionId);
            this.signal.unregisterPushCallback("PublishEventPush", this.sessionId);
            this.signal.unregisterPushCallback("ClientInfoPush", this.sessionId);
            this.signal.unregisterPushCallback("NetQualityProbeRsp", this.sessionId);
            this.signal.unregisterPushCallback("NetQualityInfoPush", this.sessionId);
        }
        // this.sessionId = 0;
        this.sessionSeq = 0;
        this.answerSeq = 0;
        this.videoSizeCallback = false;
        this.stopSoundLevel();
    };
    // private setPlayQualityTimer(): void {
    //   if (this.qualityTimer != null) {
    //     return;
    //   }
    //   this.logger.info(
    //     ZEGO_WEBRTC_ACTION.PLAYER_SET_PLAYER_QUALITY_TIMER +
    //       " " +
    //       this.streamId +
    //       " startTimer"
    //   );
    //   this.clearPlayQualityTimer();
    //   this.getP2PNetStats();
    //   this.qualityTimer = setInterval(() => {
    //     if (this.peerConnection) {
    //       const promiseList = [this.peerConnection.getStats(null)];
    //       if (this.stateCenter.browser == "chrome") {
    //         promiseList.push(
    //           new Promise((resolve, reject) => {
    //             this.peerConnection.getStats(
    //               (results: any) => resolve(results),
    //               (err: any) => reject(err)
    //             );
    //           })
    //         );
    //       }
    //       Promise.all(promiseList)
    //         .then((values: any) => {
    //           const stats = this.getPlayStats(values[0], values[1]);
    //         })
    //         .catch((error: any) => {
    //           this.logger.info(
    //             ZEGO_WEBRTC_ACTION.PLAYER_SET_PLAYER_QUALITY_TIMER +
    //               " " +
    //               this.streamId +
    //               " getStats error " +
    //               error.toString()
    //           );
    //         });
    //       // 
    //       this.getP2PNetStats();
    //     }
    //   }, this.qualityTimeInterval);
    //   this.lastPlayStats = {
    //     audioPacketsLost: 0,
    //     videoPacketsLost: 0,
    //     time: 0,
    //     audioTime: 0,
    //     videoTime: 0,
    //     audioBytesReceived: 0,
    //     videoBytesReceived: 0,
    //     videoPacketsReceived: 0,
    //     audioPacketsReceived: 0,
    //     framesDecoded: 0,
    //     framesReceived: 0,
    //     framesDropped: 0,
    //     audioBitrate: 0
    //   };
    // }
    // private getPlayStats(
    //   results: { forEach: (arg0: (result: any) => void) => void } | undefined,
    //   callbackResults: any
    // ): void {
    //   if (results == undefined) {
    //     return;
    //   }
    //   const medias: any = document.querySelectorAll("video, audio");
    //   let streamMedia;
    //   for (let i = 0; i < medias.length; i++) {
    //     if (medias[i].srcObject === this.playStream) {
    //       streamMedia = medias[i];
    //     }
    //   }
    //   const playData: any = {
    //     audioFractionLost: 0,
    //     audioPacketsLost: 0,
    //     audioPacketsLostRate: 0,
    //     audioBitrate: 0,
    //     audioLevel: 0,
    //     audioSendLevel: 0,
    //     audioSamplingRate: 0,
    //     audioCodec: "opus",
    //     audioQuality: 0,
    //     audioFPS: 0,
    //     videoQuality: 0,
    //     videoPacketsLost: 0,
    //     videoPacketsLostRate: 0,
    //     videoBitrate: 0,
    //     videoFPS: 0,
    //     playData: 0,
    //     nackCount: 0,
    //     pliCount: 0,
    //     //sliCount: 0,
    //     audioJitter: 0,
    //     videoFractionLost: 0,
    //     videoFramesDecoded: 0,
    //     frameHeight: 0,
    //     frameWidth: 0,
    //     videoTransferFPS: 0,
    //     videoFramesDropped: 0,
    //     totalRoundTripTime: 0,
    //     currentRoundTripTime: 0,
    //     googBandwidthLimitedResolution: undefined,
    //     videoCodecName: "",
    //     audioCodecName: "",
    //     googCpuLimitedResolution: undefined,
    //     googAvailableSendBandwidth: 0,
    //     audioMuteState: this.audioMuteState,
    //     videoMuteState: this.videoMuteState,
    //     muted: streamMedia ? streamMedia.muted : undefined,
    //     paused: streamMedia ? streamMedia.paused : undefined,
    //     volume: streamMedia ? streamMedia.volume : undefined,
    //     sinkId: streamMedia ? streamMedia.sinkId : undefined,
    //     p2p_rtt: this.lastPlayStats.p2p_rtt || undefined,
    //     p2p_lost: this.lastPlayStats.p2p_lost || undefined
    //   };
    //   const time = this.lastPlayStats.time;
    //   let rtt = 0;
    //   let audioLostRate = 0;
    //   let videoLostRate = 0;
    //   let audioJitter = 0;
    //   let videoJitter = 0;
    //   let audioCurrentDelayMs = 0;
    //   let videoCurrentDelayMs = 0;
    //   results.forEach(result => {
    //     if (
    //       (result.type == "inbound-rtp" ||
    //         (result.type == "ssrc" && result.bytesReceived != undefined)) &&
    //       (result.mediaType == "audio" || result.id.indexOf("AudioStream") >= 0)
    //     ) {
    //       //audio
    //       if (time != 0) {
    //         // 
    //         playData["audioBitrate"] =
    //           (8 *
    //             (result.bytesReceived -
    //               this.lastPlayStats["audioBytesReceived"])) /
    //           (result.timestamp - time);
    //         // 
    //         const deltaPacketsLost =
    //           result.packetsLost - this.lastPlayStats.audioPacketsLost;
    //         deltaPacketsLost > 0 &&
    //           (audioLostRate =
    //             deltaPacketsLost /
    //             (deltaPacketsLost +
    //               result.packetsReceived -
    //               this.lastPlayStats.audioPacketsReceived));
    //       }
    //       if (playData["audioBitrate"] < 0) {
    //         playData["audioBitrate"] = 0;
    //       }
    //       playData.audioJitter = result.jitter;
    //       result.packetsLost > 0 &&
    //         (playData.audioPacketsLost = result.packetsLost);
    //       playData.audioFractionLost = result.fractionLost;
    //       const timePacketsLost =
    //         result.packetsLost - this.lastPlayStats.audioPacketsLost;
    //       playData.audioFPS =
    //         ((result.packetsReceived - this.lastPlayStats.audioPacketsReceived) /
    //           (result.timestamp - time)) *
    //         1000;
    //       if (timePacketsLost > 0) {
    //         playData.audioPacketsLostRate =
    //           timePacketsLost /
    //           (result.packetsReceived -
    //             this.lastPlayStats.audioPacketsReceived +
    //             timePacketsLost);
    //       } else {
    //         playData.audioPacketsLostRate = 0;
    //       }
    //       this.lastPlayStats.audioBytesReceived = result.bytesReceived;
    //       result.packetsLost > 0 &&
    //         (this.lastPlayStats.audioPacketsLost = result.packetsLost);
    //       this.lastPlayStats.audioPacketsReceived = result.packetsReceived;
    //       this.lastPlayStats.audioTime = result.timestamp;
    //       this.lastPlayStats.time = result.timestamp;
    //       this.lastPlayStats.audioBitrate = playData["audioBitrate"];
    //       audioJitter = result.jitter;
    //     } else if (
    //       (result.type == "inbound-rtp" ||
    //         (result.type == "ssrc" && result.bytesReceived != undefined)) &&
    //       (result.mediaType == "video" || result.id.indexOf("VideoStream") >= 0)
    //     ) {
    //       //video
    //       if (time != 0) {
    //         playData.videoBitrate =
    //           (8 *
    //             (result.bytesReceived - this.lastPlayStats.videoBytesReceived)) /
    //           (result.timestamp - time);
    //         playData.videoFPS =
    //           (1000 * (result.framesDecoded - this.lastPlayStats.framesDecoded)) /
    //           (result.timestamp - time);
    //         const deltaPacketsLost =
    //           result.packetsLost - this.lastPlayStats.videoPacketsLost;
    //         deltaPacketsLost > 0 &&
    //           (videoLostRate =
    //             deltaPacketsLost /
    //             (deltaPacketsLost +
    //               result.packetsReceived -
    //               this.lastPlayStats.videoPacketsReceived));
    //       }
    //       if (playData.videoBitrate < 0) {
    //         playData.videoBitrate = 0;
    //       }
    //       if (playData.videoFPS < 0) {
    //         playData.videoFPS = 0;
    //       }
    //       //playData.jitter = result.jitter;
    //       playData.nackCount = result.nackCount;
    //       playData.pliCount = result.pliCount;
    //       //playData.sliCount = result.sliCount;
    //       playData.videoFractionLost = result.fractionLost;
    //       playData.videoFramesDecoded = result.framesDecoded;
    //       result.packetsLost > 0 &&
    //         (playData.videoPacketsLost = result.packetsLost);
    //       const timePacketsLost =
    //         result.packetsLost - this.lastPlayStats.videoPacketsLost;
    //       if (timePacketsLost > 0) {
    //         playData.videoPacketsLostRate =
    //           timePacketsLost /
    //           (result.packetsReceived -
    //             this.lastPlayStats.videoPacketsReceived +
    //             timePacketsLost);
    //       } else {
    //         playData.videoPacketsLostRate = 0;
    //       }
    //       this.lastPlayStats.videoBytesReceived = result.bytesReceived;
    //       this.lastPlayStats.framesDecoded = result.framesDecoded;
    //       result.packetsLost > 0 &&
    //         (this.lastPlayStats.videoPacketsLost = result.packetsLost);
    //       this.lastPlayStats.videoPacketsReceived = result.packetsReceived;
    //       this.lastPlayStats.videoTime = result.timestamp;
    //       this.lastPlayStats.time = result.timestamp;
    //       videoJitter = result.jitter;
    //     } else if (
    //       (result.type == "track" &&
    //         (result.kind == "video" || result.id.indexOf("video") >= 0)) ||
    //       result.frameWidth
    //     ) {
    //       playData.frameHeight = result.frameHeight;
    //       playData.frameWidth = result.frameWidth;
    //       // 
    //       if (
    //         time !== 0 &&
    //         (this.lastPlayStats.frameHeight !== result.frameHeight ||
    //           this.lastPlayStats.frameWidth !== result.frameWidth)
    //       ) {
    //         const reportSizeSeq = getReportSeq();
    //         this.dataReport.newReport(
    //           reportSizeSeq,
    //           ZegoRTCLogEvent.kZegoTaskVideoPlaySize.event
    //         );
    //         this.dataReport.addMsgInfo(reportSizeSeq, {
    //           session_id: ZegoRTCLogEvent.kZegoTaskVideoPlaySize.session_id(
    //             this.sessionId
    //           ),
    //           w: ZegoRTCLogEvent.kZegoTaskVideoPlaySize.w(result.frameWidth),
    //           h: ZegoRTCLogEvent.kZegoTaskVideoPlaySize.h(result.frameHeight)
    //         });
    //         !this.isProbe && this.dataReport.uploadReport(reportSizeSeq);
    //         this.lastPlayStats.frameHeight = result.frameHeight;
    //         this.lastPlayStats.frameWidth = result.frameWidth;
    //       } else if (time === 0) {
    //         this.lastPlayStats.frameHeight = result.frameHeight;
    //         this.lastPlayStats.frameWidth = result.frameWidth;
    //       }
    //       if (time != 0) {
    //         playData.videoTransferFPS =
    //           (1000 *
    //             (result.framesReceived - this.lastPlayStats.framesReceived)) /
    //           (result.timestamp - time);
    //         playData.videoFramesDropped =
    //           result.framesDropped - this.lastPlayStats.framesDropped;
    //       }
    //       if (playData.videoTransferFPS < 0) {
    //         playData.videoTransferFPS = 0;
    //       }
    //       if (playData.videoFramesDropped < 0) {
    //         playData.videoFramesDropped = 0;
    //       }
    //       this.lastPlayStats.framesReceived = result.framesReceived;
    //       this.lastPlayStats.framesDropped = result.framesDropped;
    //     } else if (
    //       result.type == "track" &&
    //       (result.kind == "audio" || result.id.indexOf("audio") >= 0)
    //     ) {
    //       playData.audioLevel = result.audioLevel;
    //       playData.audioSendLevel = result.totalAudioEnergy;
    //       playData.audioSamplingRate = result.totalSamplesDuration;
    //     } else if (result.type == "candidate-pair") {
    //       if (result.totalRoundTripTime != undefined) {
    //         playData.totalRoundTripTime = result.totalRoundTripTime;
    //       }
    //       if (result.currentRoundTripTime != undefined) {
    //         playData.currentRoundTripTime = result.currentRoundTripTime;
    //         rtt = playData.currentRoundTripTime * 1000;
    //       }
    //     }
    //   });
    //   callbackResults &&
    //     callbackResults.result().forEach((result: any) => {
    //       if (result.type == "ssrc") {
    //         if (result.names().indexOf("googBandwidthLimitedResolution") >= 0) {
    //           playData.googBandwidthLimitedResolution = result.stat(
    //             "googBandwidthLimitedResolution"
    //           );
    //         }
    //         if (result.names().indexOf("codecImplementationName") >= 0) {
    //           playData.codecImplementationName = result.stat(
    //             "codecImplementationName"
    //           );
    //         }
    //         if (result.stat("mediaType") == "video") {
    //           if (result.names().indexOf("googCodecName") >= 0) {
    //             playData.videoCodecName = result.stat("googCodecName");
    //           }
    //           // 
    //           if (result.names().indexOf("googCurrentDelayMs") >= 0) {
    //             videoCurrentDelayMs = result.stat("googCurrentDelayMs");
    //           }
    //         }
    //         if (result.stat("mediaType") == "audio") {
    //           if (result.names().indexOf("googCodecName") >= 0) {
    //             playData.audioCodecName = result.stat("googCodecName");
    //           }
    //           // 
    //           if (result.names().indexOf("googCurrentDelayMs") >= 0) {
    //             audioCurrentDelayMs = result.stat("googCurrentDelayMs");
    //           }
    //         }
    //         if (result.names().indexOf("googCpuLimitedResolution") >= 0) {
    //           playData.googCpuLimitedResolution = result.stat(
    //             "googCpuLimitedResolution"
    //           );
    //         }
    //       }
    //       if (
    //         result.type == "VideoBwe" &&
    //         result.names().indexOf("googAvailableSendBandwidth") >= 0
    //       ) {
    //         playData.googAvailableSendBandwidth = result.stat(
    //           "googAvailableSendBandwidth"
    //         );
    //       }
    //     });
    //   // 
    //   this.lastPlayStats.googCurrentDelayMs =
    //     Number(audioCurrentDelayMs) || Number(videoCurrentDelayMs) || 0;
    //   videoLostRate =
    //     isNaN(videoLostRate) || videoLostRate < 0 ? 0 : videoLostRate;
    //   videoJitter = isNaN(videoJitter) || videoJitter < 0 ? 0 : videoJitter;
    //   audioLostRate =
    //     isNaN(audioLostRate) || audioLostRate < 0 ? 0 : audioLostRate;
    //   audioJitter = isNaN(audioJitter) || audioJitter < 0 ? 0 : audioJitter;
    //   const videoQuality = ClientUtil.getNetQuality(
    //     rtt,
    //     videoLostRate,
    //     videoJitter
    //   );
    //   const audioQuality = ClientUtil.getNetQuality(
    //     rtt,
    //     audioLostRate,
    //     audioJitter
    //   );
    //   playData.audioQuality =
    //     time > 0 ? ClientUtil.quality2QualityGrade(videoQuality) : 0;
    //   playData.videoQuality =
    //     time > 0 ? ClientUtil.quality2QualityGrade(audioQuality) : 0;
    //   const netQuality = Math.min(videoQuality, audioQuality);
    //   this.netQuality = netQuality;
    //   playData.peerToPeerDelay = this.p2pNetStats.p2pRTT
    //     ? this.p2pNetStats.p2pRTT / 2 + this.lastPlayStats.googCurrentDelayMs
    //     : 0;
    //   playData.peerToPeerPacketsLostRate = this.p2pNetStats.p2pLostRate;
    //   if (
    //     time > 0 &&
    //     netQuality <= QUALITY_CONSTANT.MiddleMinQuality &&
    //     new Date().getTime() > this.probeTime + this.probeInterval
    //   ) {
    //     this.logger.info(
    //       ZEGO_WEBRTC_ACTION.PLAYER_SET_PLAYER_QUALITY_TIMER +
    //         " netQuality " +
    //         netQuality +
    //         " start net probe"
    //     );
    //     this.probeState = ENUM_PROBE_STATE.tryProbe;
    //     this.streamCenter.startNetProbe(false, this, this.gwNodeList);
    //     this.probeTime = new Date().getTime();
    //   }
    //   this.uploadPlayQuality(playData);
    //   const streamQuality: any = {
    //     video: {
    //       videoBitrate: playData.videoBitrate,
    //       videoFPS: playData.videoFPS,
    //       videoTransferFPS: playData.videoTransferFPS,
    //       videoFramesDecoded: playData.videoFramesDecoded,
    //       videoFramesDropped: playData.videoFramesDropped,
    //       videoPacketsLost: playData.videoPacketsLost,
    //       videoPacketsLostRate: playData.videoPacketsLostRate,
    //       videoQuality: playData.videoQuality,
    //       frameHeight: playData.frameHeight,
    //       frameWidth: playData.frameWidth,
    //       muteState: playData.videoMuteState
    //     },
    //     audio: {
    //       audioBitrate: playData.audioBitrate,
    //       audioCodec: playData.audioCodec,
    //       audioJitter: playData.audioJitter,
    //       audioLevel: playData.audioLevel,
    //       audioPacketsLost: playData.audioPacketsLost,
    //       audioPacketsLostRate: playData.audioPacketsLostRate,
    //       audioQuality: playData.audioQuality,
    //       audioSamplingRate: playData.audioSamplingRate,
    //       audioSendLevel: playData.audioSendLevel,
    //       muteState: playData.audioMuteState,
    //       audioFPS: playData.audioFPS
    //     },
    //     //roomId: '',
    //     nackCount: playData.nackCount,
    //     pliCount: playData.pliCount,
    //     totalRoundTripTime: playData.totalRoundTripTime,
    //     playData: playData.playData,
    //     currentRoundTripTime: playData.currentRoundTripTime
    //   };
    //   if (playData.muted !== undefined) {
    //     streamQuality.muted = playData.muted;
    //     streamQuality.paused = playData.paused;
    //     streamQuality.volume = playData.volume;
    //     streamQuality.sinkId = playData.sinkId;
    //   }
    //   if (playData.videoCodecName !== undefined) {
    //     // streamQuality.googBandwidthLimitedResolution = playData.googBandwidthLimitedResolution;
    //     streamQuality.video.googCodecName = playData.videoCodecName;
    //     streamQuality.audio.googCodecName = playData.audioCodecName;
    //     // streamQuality.googCpuLimitedResolution = playData.googCpuLimitedResolution;
    //     streamQuality.codecImplementationName = playData.codecImplementationName;
    //     streamQuality.googAvailableSendBandwidth =
    //       playData.googAvailableSendBandwidth;
    //   }
    //   if (time != 0) {
    //     this.onPlayQualityUpdate(this.streamId as string, streamQuality);
    //   }
    // }
    // private uploadPlayQuality(playData: any): void {
    //   if (!this.qualityUpload) {
    //     return;
    //   }
    //   const timeStamp = new Date().getTime();
    //   if (
    //     this.qualityUploadLastTime == 0 ||
    //     timeStamp - this.qualityUploadLastTime >= this.qualityUploadInterval
    //   ) {
    //     playData["stream_type"] = "play";
    //     playData["stream_id"] = this.streamId;
    //     playData["timeStamp"] = timeStamp / 1000;
    //     this.logger.info(
    //       ZEGO_WEBRTC_ACTION.PLAYER_UPLOAD_PLAYER_QUALITY +
    //         " " +
    //         this.streamId +
    //         " upload" +
    //         JSON.stringify(playData)
    //     );
    //     this.signal.QualityReport(
    //       getSeq(),
    //       this.sessionId,
    //       playData,
    //       (
    //         seq: number,
    //         sessionId: string,
    //         data: { report: boolean | undefined; report_interval_ms: number }
    //       ) => {
    //         if (data.report !== undefined) {
    //           this.qualityUpload = data.report;
    //           this.qualityUploadInterval = data.report_interval_ms;
    //         }
    //       },
    //       (err: string) => {
    //         this.logger.info(
    //           ZEGO_WEBRTC_ACTION.PLAYER_UPLOAD_PLAYER_QUALITY +
    //             " " +
    //             this.streamId +
    //             " upload failed " +
    //             err
    //         );
    //       }
    //     );
    //     this.qualityUploadLastTime = timeStamp;
    //   }
    // }
    ZegoPlayWeb.prototype.onRecvResetSession = function (seq, sessionId, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_RESET_SESSION +
            " " +
            this.streamId +
            " received ");
        if (sessionId != this.sessionId) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_RESET_SESSION +
                " " +
                this.streamId +
                " cannot find session");
            return;
        }
        this.signal.sendCloseSessionAck(seq, this.sessionId, 0);
        var error = JSON.parse(JSON.stringify(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlaySessionClosedError));
        // error.msg += data.reason;
        this.negoTimer && clearTimeout(this.negoTimer);
        this.playStateUpdateError(error);
    };
    ZegoPlayWeb.prototype.onRecvCloseSession = function (seq, sessionId, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_CLOSE_SESSION +
            " " +
            this.streamId +
            " " +
            JSON.stringify(data));
        this.signal.sendCloseSessionAck(seq, this.sessionId, 0);
        var err_info = data.err_info
            ? JSON.parse(data.err_info.toLowerCase())
            : {};
        var action = err_info.action ? err_info.action : null;
        var reason = data.reason * 1;
        var error = JSON.parse(JSON.stringify(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlaySessionClosedError));
        error.message += " reason:" + reason + " " + (action ? " action:" + action : "");
        this.negoTimer && clearTimeout(this.negoTimer);
        var stopRetry = [4, 8, 10, 11, 12, 14, 24, 26, 27, 28].includes(reason) ||
            [2, 5, 6].includes(action)
            ? false
            : true;
        this.playStateUpdateError(error, stopRetry);
    };
    ZegoPlayWeb.prototype.onRecvStreamStatus = function (data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_STREAM_STATUS +
            " " +
            this.streamId +
            " call");
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_STREAM_STATUS + " " + this.streamId + " status camera_status: " + data.camera_status + " mic_status: " + data.mic_status);
        (!this.hasSentStreamStatus || this.cameraStatus !== data.camera_status) &&
            this.onRemoteCameraStatusUpdate(this.streamId, this.getCameraMicStatus(data.camera_status), data.camera_status);
        (!this.hasSentStreamStatus || this.micStatus !== data.mic_status) &&
            this.onRemoteMicStatusUpdate(this.streamId, this.getCameraMicStatus(data.mic_status), data.mic_status);
        this.hasSentStreamStatus = true;
        this.cameraStatus = data.camera_status;
        this.micStatus = data.mic_status;
        // 10
        this.videoMuteState = data.camera_status === 0 ? "0" : "1";
        this.audioMuteState = data.mic_status === 0 ? "0" : "1";
        if (typeof this.playOption.video === "boolean") {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_STREAM_STATUS +
                " " +
                this.streamId +
                " has set video option, ignore stream status");
        }
        else {
            var stream_1 = this.playStream;
            if (data.camera_status !== 0 && data.camera_status !== 20) {
                // videoloading
                // native  web enable video 
                stream_1.getVideoTracks().forEach(function (track) {
                    track.enabled = false;
                    track.stop();
                    stream_1.removeTrack(track);
                });
            }
            else if (stream_1.getVideoTracks().length === 0) {
                stream_1.addTrack(this.remoteStream.clone().getVideoTracks()[0]);
            }
            // Safari
            if (this.stateCenter.browser === "safari") {
                var medias = document.querySelectorAll("video, audio");
                for (var i = 0; i < medias.length; i++) {
                    if (medias[i].srcObject === this.playStream) {
                        medias[i].srcObject = this.playStream;
                    }
                }
            }
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_RECV_STREAM_STATUS +
            " " +
            this.streamId +
            " call success");
    };
    ZegoPlayWeb.prototype.onGotRemoteStream = function (stream) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_GOT_REMOTE_STREAM +
            " " +
            this.streamId +
            " called " +
            stream);
        if (!stream) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_GOT_REMOTE_STREAM +
                " " +
                this.streamId +
                " remote stream is empty");
            return;
        }
        if (!this.playStream) {
            this.playStream = stream.clone();
        }
        else {
            this.playStream
                .getTracks()
                .forEach(function (track) { return _this.playStream.removeTrack(track); });
            stream
                .clone()
                .getTracks()
                .forEach(function (track) { return _this.playStream.addTrack(track); });
        }
        this.audioMuteState =
            this.playStream.getAudioTracks().length > 0 ? "0" : "1";
        this.videoMuteState =
            this.playStream.getVideoTracks().length > 0 ? "0" : "1";
        this.remoteStream = stream;
        this.gotStreamStatus && this.onRecvStreamStatus(this.streamStatus);
        this.dataReport.addEvent(this.reportSeq, "GetRemoteStream");
        this.streamCenter.soundLevelDelegate &&
            !this.isProbe &&
            this.startSoundLevel();
    };
    ZegoPlayWeb.prototype.sendCandidateInfo = function (candidateInfo) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SEND_CANDIDATE_INFO +
            " " +
            this.streamId +
            " called");
        candidateInfo = candidateInfo.filter(function (item) {
            if (item.candidate.indexOf("tcp") > 0) {
                return false;
            }
            else if (item.candidate) {
                return true;
            }
        });
        if (!candidateInfo || candidateInfo.length < 1) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SEND_CANDIDATE_INFO +
                " " +
                this.streamId +
                " cancelled");
            return;
        }
        this.dataReport.eventStart(this.reportSeq, "SendIceCandidate");
        this.dataReport.eventStart(this.streamReportSeq, "SendIceCandidate");
        if (this.stateNego !== zego_entity_1.ENUM_PLAY_STATE_NEGO.iceConnected)
            this.stateNego = zego_entity_1.ENUM_PLAY_STATE_NEGO.sendCandidate;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SEND_CANDIDATE_INFO +
            " " +
            this.streamId +
            " stateNego:sendCandidate");
        this.signal.sendCandidateInfo(zego_entity_1.getSeq(), this.sessionId, candidateInfo, function (seq, sessionId, data) {
            _this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SEND_CANDIDATE_INFO +
                " " +
                _this.streamId +
                " send success");
            _this.dataReport.eventEnd(_this.reportSeq, "SendIceCandidate");
            _this.dataReport.eventEnd(_this.streamReportSeq, "SendIceCandidate");
        }, function (err, seq) {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SEND_CANDIDATE_INFO +
                " " +
                _this.streamId +
                " failed to send: " +
                err.toString());
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "SendIceCandidate", {
                error: err
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "SendIceCandidate", {
                error: err
            });
            _this.playStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kCandidateError);
        });
    };
    ZegoPlayWeb.prototype.shouldSendCloseSession = function () {
        if (this.state != zego_entity_1.ENUM_PLAY_STATE_UPDATE.stop &&
            this.state != zego_entity_1.ENUM_PLAY_STATE.waitingSessionRsp) {
            return true;
        }
        return false;
    };
    ZegoPlayWeb.prototype.playStateUpdateError = function (error, stopRetry) {
        this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_STATE_ERROR + " call ", this.streamId, JSON.stringify(error));
        if (this.isProbe) {
            this.onCalNetQualityResult(1);
        }
        else {
            this.streamId &&
                this.onPlayStateUpdate(zego_entity_1.ENUM_PLAY_STATE_UPDATE.error, this.streamId, error, stopRetry);
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_STATE_ERROR + " " + this.streamId + " ended");
    };
    ZegoPlayWeb.prototype.getCameraMicStatus = function (status) {
        return status == 0 ? "OPEN" : "MUTE";
    };
    ZegoPlayWeb.prototype.onPlayStateUpdate = function (type, streamId, error, stopRetry) { };
    ZegoPlayWeb.prototype.onPlayQualityUpdate = function (streamID, quality) { };
    ZegoPlayWeb.prototype.onRemoteCameraStatusUpdate = function (streamID, status, initialStatus) { };
    ZegoPlayWeb.prototype.onRemoteMicStatusUpdate = function (streamID, status, initialStatus) { };
    ZegoPlayWeb.prototype.stopPlay = function () {
        var _a;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_STOP_PLAY + " " + this.streamId + " called");
        //sendBroadcasterStatusNotify
        for (var i in this.streamCenter.publisherList) {
            var publisher = this.streamCenter.publisherList[i]
                .publisher;
            if (publisher.state == zego_entity_1.ENUM_PUBLISH_STATE.publishing &&
                this.broadcasterStatus == zego_entity_1.ENUM_BROADCASTER_STATUS.start) {
                this.signal &&
                    this.signal.sendBroadcasterStatus(zego_entity_1.getSeq(), this.sessionId, 0);
                this.broadcasterStatus = zego_entity_1.ENUM_BROADCASTER_STATUS.stop;
                break;
            }
        }
        //send to server
        if (this.sessionId && !this.closeSessionSignal) {
            this.signal.sendCloseSession(zego_entity_1.getSeq(), this.sessionId, 0);
        }
        this.dataReport.eventEndWithMsg(this.streamReportSeq, "PlayState", {
            state: this.state + ""
        });
        this.dataReport.addEvent(this.streamReportSeq, "StopPlay");
        this.dataReport.addMsgExt(this.streamReportSeq, {
            stream: this.streamId,
            sessionId: this.sessionId
        });
        this.resetPlay();
        var _b = this.qualityHandler, videoBreak = _b.videoBreak, audioBreak = _b.audioBreak;
        var key = this.resourceMode === 2 ? "l3" : "rtc";
        var reportBreak = (_a = {},
            _a[key + "_a_break_time"] = audioBreak.cumulativeBreakDuration,
            _a[key + "_a_decode_time"] = audioBreak.cumulativeDecodeDuration,
            _a[key + "_v_break_time"] = videoBreak.cumulativeBreakDuration,
            _a[key + "_v_decode_time"] = videoBreak.cumulativeDecodeDuration,
            _a);
        this.dataReport.addMsgInfo(this.streamReportSeq, __assign({ itemtype: "RTCPlayStream", cdn_a_break_time: 0, cdn_a_decode_time: 0, cdn_v_break_time: 0, cdn_v_decode_time: 0, l3_a_break_time: 0, l3_a_decode_time: 0, l3_v_break_time: 0, l3_v_decode_time: 0, rtc_a_break_time: 0, rtc_a_decode_time: 0, rtc_v_break_time: 0, rtc_v_decode_time: 0 }, reportBreak));
        // console.log("videobreak", reportBreak);
        !this.isProbe &&
            this.dataReport.uploadReport(this.streamReportSeq, "RTCPlayStream");
    };
    ZegoPlayWeb.prototype.onDisconnect = function (error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_ON_DISCONNECT + " " + this.streamId + " call");
        this.dataReport.addEvent(this.reportSeq, "OnDisconnect");
        // 
        this.playStateUpdateError(error ||
            zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kWebsocketDisconnectedError, !!error);
    };
    ZegoPlayWeb.prototype.startSoundLevel = function () {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_SOUND_LEVEL +
            " call streamID: " +
            this.streamId);
        //
        if (this.isProbe) {
            return;
        }
        if (!this.remoteStream || this.remoteStream.getAudioTracks().length == 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_SOUND_LEVEL +
                " " +
                this.streamId +
                " remote stream no found");
            return;
        }
        this.script && this.script.disconnect() && (this.script = null);
        this.mic && this.mic.disconnect() && (this.mic = null);
        try {
            this.mic = this.ac.createMediaStreamSource(this.remoteStream);
            this.script = this.ac.createScriptProcessor(4096, 1, 1); //4096
            this.mic.connect(this.script); //
            this.script.connect(this.ac.destination);
            this.script.onaudioprocess = function (e) {
                //
                var buffer = e.inputBuffer.getChannelData(0); //PCM32
                //
                var maxVal = 0;
                for (var i = 0; i < buffer.length; i++) {
                    if (maxVal < buffer[i]) {
                        maxVal = buffer[i];
                    }
                }
                _this.soundLevel = maxVal * 100;
            };
            this.ac.resume();
        }
        catch (err) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PLAYER_START_SOUND_LEVEL +
                " get sound level failed " +
                err);
        }
    };
    ZegoPlayWeb.prototype.stopSoundLevel = function () {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_STOP_SOUND_LEVEL +
            " call streamID: " +
            this.streamId);
        this.script && this.script.disconnect();
        this.mic && this.mic.disconnect();
        this.script = null;
        this.mic = null;
    };
    ZegoPlayWeb.prototype.onCalNetQualityResult = function (result, netQuality) { };
    ZegoPlayWeb.prototype.onReceivedDataChannel = function (event) {
        var _this = this;
        var _a, _b;
        var byteArray = new Uint8Array(event.data, 0, MSG_HEADER_SIZE);
        var payload_len = event.data.byteLength - MSG_HEADER_SIZE;
        var payloadArray = new Uint8Array(event.data, MSG_HEADER_SIZE, payload_len);
        var type = byteArray[0];
        if (type == TYPE_USER_DATA) {
            var flags = byteArray[1];
            var sn = (byteArray[2] << 8) | byteArray[3];
            var sn0_1 = (byteArray[4] << 8) | byteArray[5];
            var recv_ts = new Date().getTime();
            if (this.first_pkt) {
                if (sn == sn0_1) {
                    this.next_sn[0] = sn;
                }
                else {
                    this.next_sn[0] = sn0_1;
                }
                this.first_pkt = false;
            }
            this.pkt_list.push({
                sn: sn,
                sn0: sn0_1,
                recv_ts: recv_ts,
                flags: flags,
                payload_len: payload_len,
                payloadArray: payloadArray
            });
            this.pkt_list.sort(this.compareShort);
            if (sn == this.next_sn[0]) {
                var pkts = this.pkt_list.filter(function (a) { return a.sn0 == sn0_1; });
                pkts.sort(this.compareShort);
                var f = pkts.find(function (a) { return a.flags & END_OF_MSG; });
                if (f != undefined && pkts.length == this.compareShort(sn, sn0_1) + 1) {
                    var copy_len_1 = 0;
                    var copy_buffer_1 = new ArrayBuffer(MAX_MESSAGE_SIZE);
                    for (var i = 0; i < pkts.length; i++) {
                        var chunk = new Uint8Array(copy_buffer_1);
                        chunk.set(pkts[i].payloadArray, copy_len_1);
                        copy_len_1 += pkts[i].payload_len;
                    }
                    (_a = this.onDataChannelList) === null || _a === void 0 ? void 0 : _a.forEach(function (fun) {
                        fun(copy_buffer_1, copy_len_1, _this.streamId);
                    });
                    this.pkt_list = [];
                    this.first_pkt = true;
                }
                this.next_sn[0]++;
            }
            else {
                var _loop_1 = function () {
                    var pkts = this_1.pkt_list.filter(function (a) { return a.sn0 == _this.pkt_list[0].sn0; });
                    pkts.sort(this_1.compareShort);
                    var f = pkts.find(function (a) { return a.flags & END_OF_MSG; });
                    if (f != undefined &&
                        pkts.length ==
                            this_1.compareShort(pkts[pkts.length - 1].sn, pkts[0].sn0) + 1) {
                        var copy_len_2 = 0;
                        var copy_buffer_2 = new ArrayBuffer(MAX_MESSAGE_SIZE);
                        for (var i = 0; i < pkts.length; i++) {
                            var chunk = new Uint8Array(copy_buffer_2);
                            chunk.set(pkts[i].payloadArray, copy_len_2);
                            copy_len_2 += pkts[i].payload_len;
                        }
                        this_1.next_sn[0] = pkts[0].sn0 + pkts.length;
                        (_b = this_1.onDataChannelList) === null || _b === void 0 ? void 0 : _b.forEach(function (fun) {
                            fun(copy_buffer_2, copy_len_2, _this.streamId);
                        });
                        this_1.pkt_list = [];
                        this_1.first_pkt = true;
                    }
                    else {
                        if (recv_ts - pkts[0].ts < MSG_TIMEOUT) {
                            var next_sn = pkts[0].sn0;
                            for (var i = 0; i < pkts.length; i++) {
                                if (next_sn != pkts[i].sn) {
                                    break;
                                }
                                next_sn++;
                            }
                            this_1.next_sn[0] = next_sn;
                            return "break";
                        }
                    }
                    for (var i = 0; i < pkts.length; i++) {
                        this_1.pkt_list.shift();
                    }
                };
                var this_1 = this;
                while (this.pkt_list.length > 0) {
                    var state_1 = _loop_1();
                    if (state_1 === "break")
                        break;
                }
            }
        }
    };
    ZegoPlayWeb.prototype.compareShort = function (a, b) {
        var uint16 = new Uint16Array(1);
        uint16[0] = a - b;
        var int16 = new Int16Array(1);
        int16[0] = uint16[0];
        return int16[0];
    };
    return ZegoPlayWeb;
}());
exports.ZegoPlayWeb = ZegoPlayWeb;


/***/ }),

/***/ "./sdk/src/webrtc/modules/publishModules/index.ts":
/*!********************************************************!*\
  !*** ./sdk/src/webrtc/modules/publishModules/index.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PublishModule = void 0;
var action_1 = __webpack_require__(/*! ../../../common/action */ "./sdk/src/common/action.ts");
var zego_entity_1 = __webpack_require__(/*! ../../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var client_util_1 = __webpack_require__(/*! ../../../util/client-util */ "./sdk/src/util/client-util.ts");
var zego_error_1 = __webpack_require__(/*! ../../../common/zego.error */ "./sdk/src/common/zego.error.ts");
var zego_preview_1 = __webpack_require__(/*! ./zego.preview */ "./sdk/src/webrtc/modules/publishModules/zego.preview.ts");
var index_1 = __webpack_require__(/*! ../../index */ "./sdk/src/webrtc/index.ts");
var PublishModule = /** @class */ (function () {
    function PublishModule(logger, dataReport, stateCenter, streamCenter, rtm) {
        this.logger = logger;
        this.dataReport = dataReport;
        this.stateCenter = stateCenter;
        this.streamCenter = streamCenter;
        this.rtm = rtm;
        //
        this.recordDevices();
    }
    PublishModule.prototype.createStream = function (option) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM + " call");
        // @ts-ignore
        if (option && option.camera && option.camera.audioBitRate) {
            // @ts-ignore
            option.camera.audioBitrate = option.camera.audioBitRate;
        }
        if (option && option.camera && option.camera.bitrate) {
            option.camera.bitRate = option.camera.bitrate;
        }
        if (option &&
            option.screen &&
            typeof option.screen == "object" &&
            option.screen.bitrate) {
            option.screen.bitRate = option.screen.bitrate;
        }
        if (option && option.custom && option.custom.bitrate) {
            option.custom.bitRate = option.custom.bitrate;
        }
        return new Promise(function (resolve, reject) {
            //const code = sdkErrorList.CLIENT + sdkErrorList.PARAM.code;
            var previewType = "camera";
            var reportSeq = zego_entity_1.getReportSeq();
            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.event);
            // 
            var interResolve = function (stream) {
                var preview = _this.streamCenter.checkPreview(stream);
                var _stream = stream;
                //ios 15.1 h264
                if (preview && navigator.userAgent) {
                    var ver = navigator.userAgent
                        .toLowerCase()
                        .match(/cpu iphone os (.*?) like mac os/);
                    if (ver && ver[1] && ver[1].includes("15_1")) {
                        _stream = _this.getStreamThroughCanvas(stream);
                        preview.localStream = _stream;
                    }
                }
                // 
                if (_stream.getAudioTracks().length == 0) {
                    var destination = _this.streamCenter.ac.createMediaStreamDestination();
                    var aStream = destination ? destination.stream : null;
                    var audioTrack = aStream ? aStream.getAudioTracks()[0] : null;
                    if (audioTrack) {
                        // 
                        audioTrack.enabled = false;
                        _stream.addTrack(audioTrack);
                        preview && (preview.hasEmptyAudioTrack = true);
                    }
                }
                _this.dataReport.uploadReport(reportSeq);
                !_this.stateCenter.deviceInfos && _this.recordDevices();
                resolve(_stream);
                _this.streamCenter.activeSoundLevel();
            };
            // 
            var interReject = function (err, externMsg) {
                if (externMsg === void 0) { externMsg = ""; }
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: err.code,
                    message: err.message + externMsg
                });
                _this.dataReport.uploadReport(reportSeq);
                reject({
                    code: err.code,
                    msg: err.message + externMsg
                });
            };
            // webrtc
            if (window.location.protocol !== "https:" &&
                window.location.protocol !== "file:" &&
                window.location.hostname.indexOf("127.0.0.1") == -1 &&
                window.location.hostname.indexOf("localhost") == -1) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM + " https or localhost required ");
                interReject({
                    code: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kBrowserNotSupportError
                        .code,
                    message: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kBrowserNotSupportError
                        .message + " https or localhost required"
                });
                return;
            }
            // 
            if (option && option.screen) {
                previewType = "screen";
                if (!client_util_1.ClientUtil.checkScreenParams(option.screen, interReject))
                    return;
                var bro = _this.stateCenter.browser;
                var screenConfig_1 = _this.streamCenter.getScreenConstrains(option.screen);
                _this.dataReport.addMsgInfo(reportSeq, {
                    stream_type: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.stream_type("screen"),
                    screen: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.screen(screenConfig_1)
                });
                var handleScreenSuccess_1 = function (stream) {
                    _this.streamCenter.createScreenPreviewer(stream, screenConfig_1) &&
                        interResolve(stream);
                    // 
                    stream.getVideoTracks()[0].onended = function () {
                        var innerReportSeq = zego_entity_1.getReportSeq();
                        _this.dataReport.newReport(innerReportSeq);
                        _this.dataReport.uploadReport(innerReportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskScreenSharingEnded);
                        stream && _this.stopPreview(stream);
                        _this.stateCenter.actionListener("screenSharingEnded", stream);
                    };
                };
                if (bro == "firefox" ||
                    // @ts-ignore
                    (typeof option.screen == "object" && option.screen.type == "firefox")) {
                    _this.startScreenShotFirFox("screen", screenConfig_1, function (suc, stream, err) {
                        if (suc) {
                            stream && handleScreenSuccess_1(stream);
                        }
                        else {
                            err && interReject(err);
                        }
                    });
                }
                else if ((bro == "chrome" && index_1.ZegoWebRTC.screenShotReady) ||
                    // @ts-ignore
                    (typeof option.screen == "object" && option.screen.type == "shot")) {
                    _this.startScreenShotChrome(function (suc, stream, err) {
                        if (suc) {
                            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM + " using extension");
                            stream && handleScreenSuccess_1(stream);
                        }
                        else {
                            err &&
                                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM + " extension " + err);
                            if (err !== "SS_DIALOG_CANCEL" &&
                                !(typeof option.screen == "object" &&
                                    // @ts-ignore
                                    option.screen.type == "shot")) {
                                _this.startScreenSharing(screenConfig_1, function (suc, stream, err) {
                                    if (suc) {
                                        stream && handleScreenSuccess_1(stream);
                                    }
                                    else {
                                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM + " " + err);
                                        err && interReject(err);
                                    }
                                });
                            }
                            else {
                                err &&
                                    interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error
                                        .kScreenCancelError);
                            }
                        }
                    });
                }
                else if (bro == "Electron" ||
                    // @ts-ignore
                    (typeof option.screen == "object" && option.screen.type == "Electron")) {
                    _this.startScreenShotElectron(screenConfig_1, function (suc, stream, err) {
                        if (suc) {
                            stream && handleScreenSuccess_1(stream);
                        }
                        else {
                            err && interReject(err);
                        }
                    });
                }
                else {
                    _this.startScreenSharing(screenConfig_1, function (suc, stream, err) {
                        if (suc) {
                            stream && handleScreenSuccess_1(stream);
                        }
                        else {
                            err && interReject(err);
                        }
                    });
                }
            }
            else {
                // 
                if (option &&
                    typeof option.camera === "object" &&
                    option.camera.videoQuality !== undefined) {
                    if (!client_util_1.ClientUtil.checkInteger(option.camera.videoQuality)) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM +
                            " videoQuality must be integer number");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " videoQuality must be integer number");
                        return;
                    }
                }
                // 
                if (option && option.camera && option.camera.audioBitrate) {
                    if (!client_util_1.ClientUtil.checkInteger(option.camera.audioBitrate)) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM +
                            " audioBitrate must be integer number");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " audioBitrate must be integer number");
                        return;
                    }
                    else if (option.camera.audioBitrate < 6) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM +
                            " audioBitrate cannot less 6 kbps");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " audioBitrate cannot less 6 kbps");
                        return;
                    }
                    else if (option.camera.audioBitrate > 510) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM +
                            " audioBitrate cannot greater than 510 kbps");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " audioBitrate cannot greater than 510 kbps");
                        return;
                    }
                    _this.stateCenter.audioBitRate = option.camera.audioBitrate * 1e3;
                }
                // 
                if (option && option.camera && option.camera.bitRate) {
                    if (typeof option.camera.bitRate !== "number") {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM +
                            " bitrate must be integer number");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " bitrate must be integer number");
                        return;
                    }
                    else if (option.camera.bitRate > 10240) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM +
                            " bitrate cannot greater than 10 Mbps");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " bitrate cannot greater than 10 Mbps");
                        return;
                    }
                }
                // 
                if (option &&
                    option.camera &&
                    option.camera.channelCount !== undefined) {
                    if (!client_util_1.ClientUtil.checkInteger(option.camera.channelCount)) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM +
                            " channelCount must be integer number");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " channelCount must be integer number");
                        return;
                    }
                }
                // 
                if (option &&
                    option.camera &&
                    option.camera.videoQuality === 4 &&
                    !client_util_1.ClientUtil.checkCameraParams(option.camera, interReject)) {
                    return;
                }
                if (option && option.custom && option.custom.bitRate) {
                    if (!client_util_1.ClientUtil.checkInteger(option.custom.bitRate)) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM +
                            " bitrate must be integer number");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " bitrate must be integer number");
                        return;
                    }
                    else if (option.custom.bitRate > 10240) {
                        _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.CREATE_STREAM +
                            " bitrate cannot greater than 10 Mbps");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " bitrate cannot greater than 10 Mbps");
                        return;
                    }
                }
                if (option && option.custom && option.custom.audioBitrate) {
                    if (!client_util_1.ClientUtil.checkInteger(option.custom.audioBitrate)) {
                        _this.logger.error("ze.cs.0 audioBitrate must be integer number");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " audioBitrate must be integer number");
                        return;
                    }
                    else if (option.custom.audioBitrate < 6) {
                        _this.logger.error("ze.cs.0 audioBitrate cannot less 6 kbps");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " audioBitrate cannot less 6 kbps");
                        return;
                    }
                    else if (option.custom.audioBitrate > 510) {
                        _this.logger.error("ze.cs.0 audioBitrate cannot greater than 510 kbps");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " audioBitrate cannot greater than 510 kbps");
                        return;
                    }
                }
                if (option &&
                    option.custom &&
                    option.custom.channelCount !== undefined) {
                    if (option.custom.channelCount !== 1 &&
                        option.custom.channelCount !== 2) {
                        _this.logger.error("ze.cs.0 channelCount must number 1 or 2");
                        interReject(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kParamError, " channelCount must number 1 or 2");
                        return;
                    }
                }
                var constraints = {};
                if (option && option.camera) {
                    previewType = "camera";
                    constraints = option.camera;
                    _this.dataReport.addMsgInfo(reportSeq, {
                        stream_type: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.stream_type("camera"),
                        camera: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.camera(option.camera)
                    });
                    if (typeof constraints.video !== "boolean")
                        constraints.video = true;
                    if (typeof constraints.audio !== "boolean")
                        constraints.audio = true;
                }
                else if (option && option.custom) {
                    previewType = "custom";
                    constraints = option.custom;
                    var sourceType = option.custom.source instanceof MediaStream
                        ? "MediaStream"
                        : "HTMLElement";
                    _this.dataReport.addMsgInfo(reportSeq, {
                        stream_type: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.stream_type("custom"),
                        custom: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.custom(__assign(__assign({}, option.custom), { source: sourceType }))
                    });
                }
                _this.startPreview(constraints, previewType, interResolve, interReject);
            }
        });
    };
    PublishModule.prototype.destroyStream = function (localStream) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.DESTROY_STREAM + " call");
        var reportSeq = zego_entity_1.getReportSeq();
        this.dataReport.newReport(reportSeq);
        if (!(localStream instanceof MediaStream)) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.DESTROY_STREAM +
                " localStream is not mediaStream or tracks is null");
            this.dataReport.addMsgInfo(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskDestroyStream.error.kLocalStreamError);
            this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskDestroyStream.event);
            return;
        }
        if (localStream instanceof MediaStream &&
            localStream.getTracks().length == 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.DESTROY_STREAM + " tracks is null");
        }
        this.stopPreview(localStream);
        this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskDestroyStream.event);
    };
    PublishModule.prototype.startPublishingStream = function (streamID, localStream, publishOption, isDataChannel) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM + " call ", streamID);
        //publish Event start
        var result = true;
        var error;
        var externMsg = "";
        var reportSeq = zego_entity_1.getReportSeq();
        this.stateCenter.reportSeqList.startPublish[streamID] = reportSeq;
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.event);
        if (result && streamID === undefined) {
            externMsg = "stream id required";
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM + externMsg);
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
        }
        if (result && (!streamID || typeof streamID !== "string")) {
            externMsg = "stream id type wrong";
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM + " " + externMsg);
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
        }
        if (result && streamID.length > zego_entity_1.MAX_STREAM_ID_LENGTH) {
            externMsg = "stream id length limit";
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM + " " + externMsg);
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
        }
        if (result && !client_util_1.ClientUtil.checkIllegalCharacters(streamID)) {
            externMsg = "stream ID contains illegal characters";
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM + " " + externMsg);
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
        }
        if (result &&
            (!localStream ||
                (localStream instanceof MediaStream &&
                    localStream.getTracks().length == 0))) {
            externMsg = "localStream wrong";
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM + " " + externMsg);
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
        }
        if (result && !this.streamCenter.checkPreview(localStream)) {
            externMsg = "stream is not from zego";
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM + " " + externMsg);
            result = false;
            error =
                zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishNoPreviewError;
        }
        if (result &&
            typeof publishOption !== "undefined" &&
            typeof publishOption !== "object") {
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
            externMsg = "publishOption must be object";
        }
        if (result &&
            publishOption !== undefined &&
            publishOption.streamParams !== undefined &&
            typeof publishOption.streamParams !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM +
                " publishOption streamParams must be string");
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
            externMsg = " publishOption streamParams must be string";
        }
        if (result &&
            publishOption !== undefined &&
            publishOption.extraInfo !== undefined &&
            typeof publishOption.extraInfo !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM +
                " publishOption extraInfo must be string");
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
            externMsg = " publishOption extraInfo must be string";
        }
        if (result &&
            publishOption !== undefined &&
            publishOption.videoCodec !== undefined &&
            typeof publishOption.videoCodec !== "string") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM +
                " publishOption videoCodec must be string");
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
            externMsg = " publishOption videoCodec must be string";
        }
        if (result &&
            this.stateCenter.isMultiRoom &&
            (!publishOption ||
                typeof publishOption.roomID !== "string" ||
                publishOption.roomID == "")) {
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishParamError;
            externMsg = " roomID is need if set multi room";
        }
        // publishOption videoCodec 
        if (publishOption && publishOption.videoCodec) {
            publishOption.videoCodec = publishOption.videoCodec.toUpperCase();
        }
        if (result && this.rtm.isDisConnect()) {
            this.logger.error("zc.p.sps.1 not login");
            result = false;
            error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishNoLoginError;
        }
        if (!result) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.START_PUBLISHING_STREAM + " " + externMsg);
            this.dataReport.uploadReport(reportSeq, undefined, error, externMsg);
            delete this.stateCenter.reportSeqList.startPublish[streamID];
            return false;
        }
        if (!publishOption) {
            publishOption = {};
        }
        this.dataReport.addMsgInfo(reportSeq, {
            stream: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.stream(streamID),
            publishOption: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.publishOption(publishOption)
        });
        publishOption.audioBitRate = this.stateCenter.audioBitRate;
        var roomID = publishOption.roomID
            ? publishOption.roomID
            : this.stateCenter.roomList[0]
                ? this.stateCenter.roomList[0].roomID
                : "";
        var room = this.stateCenter.getRoomByRoomID(roomID);
        if (!room) {
            this.logger.error("zc.p.sps.1 room no found");
            return false;
        }
        this.dataReport.addMsgInfo(reportSeq, {
            publish_room_id: roomID,
            isMulti: this.stateCenter.isMultiRoom
        });
        var signals;
        if (this.stateCenter.customUrl && this.stateCenter.customUrl.length != 0) {
            this.logger.info("zc.p.sps.1 customUrl " + JSON.stringify(this.stateCenter.customUrl));
            signals = this.stateCenter.customUrl;
        }
        else {
            var signalNodes = this.stateCenter.settingConfig.getSetting("signal_nodes", true);
            if (signalNodes &&
                signalNodes instanceof Array &&
                signalNodes.length > 0) {
                signals = signalNodes;
                this.logger.info("zc.p.sps.1 setting config signal_nodes " +
                    JSON.stringify(signalNodes));
            }
        }
        if (signals) {
            this.stateCenter.publishStreamList[streamID] = {
                state: zego_entity_1.ENUM_PUBLISH_STREAM_STATE.tryPublish,
                extra_info: publishOption.extraInfo ? publishOption.extraInfo : null
            };
            if (!this.streamCenter.setPublishStateStart(room, streamID, localStream, publishOption, isDataChannel)) {
                this.logger.info("zc.p.sps.1 cannot start publish");
                return false;
            }
            room.streamHandler.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.retry, streamID, { code: 0, message: "" });
            this.streamCenter.publisherList[streamID].serverUrls = signals;
            return this.streamCenter.startPublishingStream(streamID);
        }
        if (!this.streamCenter.setPublishStateStart(room, streamID, localStream, publishOption, isDataChannel)) {
            this.logger.error("zc.p.sps.1 cannot start publish");
            return false;
        }
        this.stateCenter.publishStreamList[streamID] = {
            state: zego_entity_1.ENUM_PUBLISH_STREAM_STATE.tryPublish,
            extra_info: publishOption.extraInfo ? publishOption.extraInfo : null
        };
        this.logger.info("zc.p.sps.1 start publish");
        room.streamHandler.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.retry, streamID, { code: 0, message: "" });
        // // TODO: test
        // if (this.stateCenter.useNetAgent) {
        //   this.streamCenter.onPublishStateUpdate(0, streamID);
        //   return true;
        // }
        // // TOTO
        var useNetAgent = this.stateCenter.useNetAgent;
        var publisherInfo = this.streamCenter.publisherList[streamID];
        if (useNetAgent) {
            if (!this.stateCenter.appConfig) {
                this.streamCenter.waitPublishList.push(streamID);
                return true;
            }
            // ,
            this.streamCenter.publisherList[streamID].serverUrls = ["unified_rtc"];
            this.streamCenter.startPublishingStream(streamID, useNetAgent);
            return true;
        }
        else {
            var retryDispatchHandler = publisherInfo.retryDispatchHandler;
            retryDispatchHandler.stopMaxTime();
            retryDispatchHandler.invalid();
            retryDispatchHandler.initStream(streamID, publishOption, true);
            retryDispatchHandler.startMaxTime();
            return retryDispatchHandler.active(0);
        }
    };
    PublishModule.prototype.activateSEIInsert = function (stream, action, infoType) {
        if (infoType === void 0) { infoType = 0; }
        return false;
    };
    PublishModule.prototype.stopPublishingStream = function (streamID, serverError) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.STOP_PUBLISHING_STREAM + " call ", streamID + (serverError ? serverError.toString() : ""));
        //stop publish Event start
        var reportSeq = zego_entity_1.getReportSeq();
        this.stateCenter.reportSeqList.stopPublish[streamID] = reportSeq;
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStop.event);
        this.dataReport.addMsgInfo(reportSeq, {
            streamID: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStop.stream(streamID)
        });
        if (typeof streamID !== "string" || streamID == "") {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.STOP_PUBLISHING_STREAM +
                " streamID must be string and not empty");
            this.dataReport.uploadReport(reportSeq, undefined, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStop.error.kParamError, "stream id type error");
            delete this.stateCenter.reportSeqList.stopPublish[streamID];
            return false;
        }
        var publish = this.streamCenter.publisherList[streamID];
        // if (!publish || publish.serverUrls.length == 0 || !publish.publisher.signal) {
        //     publish && this.logger.error('zc.p.sps.1.1 stream can not be destroyed');
        //     this.dataReport.uploadReport(reportSeq, undefined, errorList.kIsPublishing, 'can not be destroyed');
        //     delete this.stateCenter.reportSeqList.stopPublish[totalStreamId];
        //     return false;
        // }
        var room = this.streamCenter.getRoomByStreamID(streamID);
        var shouldPublishUpdate = publish &&
            publish.publisher &&
            publish.publisher.state !== zego_entity_1.ENUM_PUBLISH_STATE.stop;
        this.streamCenter.stopPublishingStream(streamID);
        if (this.stateCenter.publishStreamList[streamID]) {
            if (this.stateCenter.publishStreamList[streamID].state >=
                zego_entity_1.ENUM_PUBLISH_STREAM_STATE.update_info &&
                room) {
                // token
                if (!serverError || serverError.code !== 1102018) {
                    var cmd = void 0;
                    this.stateCenter.type === "PUBLIC"
                        ? (cmd = zego_entity_1.ENUM_STREAM_SUB_CMD.liveEnd)
                        : (cmd = zego_entity_1.ENUM_STREAM_CMD_PRI.liveEnd);
                    room.streamHandler.updateStreamInfo(streamID, cmd);
                }
                //statecenter.streamList
                for (var i = 0; i < room.streamList.length; i++) {
                    if (room.streamList[i].stream_id == streamID) {
                        room.streamList.splice(i--, 1);
                        break;
                    }
                }
            }
            delete this.stateCenter.publishStreamList[streamID];
        }
        this.dataReport.uploadReport(reportSeq);
        // TODO 
        room &&
            shouldPublishUpdate &&
            room.streamHandler.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.error, streamID, serverError || {
                code: 0,
                message: ""
            });
        return true;
    };
    PublishModule.prototype.setCaptureVolume = function (localStream, volume) {
        var _this = this;
        return new Promise(function (resolve) {
            var _a;
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISH_SET_CAPTURE_VOLUME + " call");
            var handleFail = function (msg) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISH_SET_CAPTURE_VOLUME + " " + msg);
                resolve({
                    errorCode: zego_log_event_1.ZegoRTCLogEvent.kZegoSetCaptureVolume.error.kParamError.code,
                    extendedData: JSON.stringify({
                        fail_reason: zego_log_event_1.ZegoRTCLogEvent.kZegoSetCaptureVolume.error.kParamError.message +
                            " " +
                            msg
                    })
                });
            };
            var ac = _this.streamCenter.ac;
            var preview = _this.streamCenter.checkPreview(localStream);
            if (!(localStream instanceof MediaStream) || !preview) {
                handleFail(" stream must be created by zego");
                return;
            }
            if (localStream.getAudioTracks().length == 0) {
                handleFail(" stream audioTrack no found");
                return;
            }
            if (typeof volume !== "number" || volume < 0 || volume > 100) {
                handleFail(" volume must be number between 0 to 100");
                return;
            }
            if (preview.gainNode) {
                preview.gainNode.gain.value = volume / 100;
            }
            else {
                var source = ac.createMediaStreamSource(localStream);
                var gainNode = ac.createGain();
                var destination = ac.createMediaStreamDestination();
                source.connect(gainNode);
                gainNode.connect(destination);
                var audioTrack = destination.stream.getAudioTracks()[0];
                for (var streamID in _this.streamCenter.publisherList) {
                    var publish = _this.streamCenter.publisherList[streamID];
                    if (publish.localStream == localStream) {
                        var sender = (_a = publish.publisher.peerConnection) === null || _a === void 0 ? void 0 : _a.getSenders().find(function (s) { return s.track && s.track.kind === "audio"; });
                        if (sender) {
                            sender.replaceTrack(audioTrack);
                            publish.localStream.removeTrack(publish.publisher.localStream.getAudioTracks()[0]);
                            publish.localStream.addTrack(audioTrack);
                        }
                        break;
                    }
                }
                localStream.removeTrack(localStream.getAudioTracks()[0]);
                localStream.addTrack(audioTrack);
                preview.gainNode = gainNode;
                preview.gainNode.gain.value = volume / 100;
            }
            ac.resume();
            resolve({ errorCode: 0, extendedData: "" });
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISH_SET_CAPTURE_VOLUME + " call success");
        });
    };
    PublishModule.prototype.getElectronScreenSources = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var electron = window.require("electron");
            if (!electron) {
                _this.logger.error("zc.gess.0 Electron is not exist");
                reject({
                    message: "Electron is not exist"
                });
            }
            electron.desktopCapturer
                .getSources({
                types: ["window", "screen"]
            })
                .then(function (sources) {
                var sourceList = sources.map(function (item) {
                    return {
                        id: item.id,
                        name: item.name,
                        thumbnail: item.thumbnail
                    };
                });
                resolve(sourceList);
            })
                .catch(function (err) {
                _this.logger.error("zc.gess.0 " + err);
                reject(err);
            });
        });
    };
    PublishModule.prototype.startScreenShotChrome = function (callBack) {
        if (!index_1.ZegoWebRTC.screenShotReady) {
            var msg = "zc.b.ss Please install the extension:1. Go to chrome://extensions  2. Check: \"Enable Developer mode   3. Click: \"Load the unpacked extension... 4. Choose \"extension\" folder from the repository 5. Reload this page";
            this.logger.error(msg);
            callBack(false, null, {
                code: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError.code,
                message: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError
                    .message +
                    " " +
                    msg
            });
        }
        else {
            window.postMessage({ type: "SS_UI_REQUEST", text: "start" }, "*");
            // listen for messages from the content-script
            client_util_1.ClientUtil.registerCallback("screenShare", { success: callBack }, this.stateCenter.callbackList);
        }
    };
    PublishModule.prototype.startScreenSharing = function (screenConfig, callBack) {
        var _this = this;
        if ("getDisplayMedia" in navigator.mediaDevices) {
            var zegoMediaDevices = navigator.mediaDevices;
            zegoMediaDevices
                .getDisplayMedia({
                audio: screenConfig.audio,
                video: {
                    frameRate: screenConfig.frameRate,
                    width: screenConfig.width,
                    height: screenConfig.height
                }
            })
                .then(function (stream) {
                callBack(true, stream);
            })
                .catch(function (err) {
                _this.logger.error("zc.b.sss " + err);
                if (err.message && err.message.toLowerCase() == "permission denied") {
                    callBack(false, null, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenCancelError);
                }
                else {
                    callBack(false, null, {
                        code: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError
                            .code,
                        message: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError
                            .message +
                            " " +
                            err
                    });
                }
            });
        }
        else {
            this.logger.error("zc.b.sss brower does not support getDisplayMedia");
            callBack(false, null, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kBrowserNotSupportError);
        }
    };
    PublishModule.prototype.startScreenShotFirFox = function (mediaSource, screenConfig, callBack) {
        var _this = this;
        var config = {
            video: {
                frameRate: screenConfig.frameRate,
                bitRate: screenConfig.bitRate,
                width: screenConfig.width,
                height: screenConfig.height,
                mediaSource: mediaSource
            },
            audio: screenConfig.audio
        };
        navigator.mediaDevices
            .getUserMedia(config)
            .then(function (stream) {
            // this.stateCenter.screenShotStream = stream;
            callBack(true, stream);
        })
            .catch(function (err) {
            _this.logger.error("ze.ssf.1 " + err);
            callBack(false, null, {
                code: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError.code,
                message: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError
                    .message +
                    " " +
                    err
            });
        });
    };
    PublishModule.prototype.startScreenShotElectron = function (screenConfig, callBack) {
        var _this = this;
        var electron = window.require("electron");
        if (!electron) {
            this.logger.error("ze.sse.1 Electron is not exist");
            callBack(false, null, {
                code: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError.code,
                message: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError
                    .message + " Electron is not exist"
            });
            return;
        }
        var config = {
            video: {
                mandatory: {
                    chromeMediaSource: "desktop",
                    chromeMediaSourceId: screenConfig.sourceID,
                    maxWidth: window.screen.width,
                    maxHeight: window.screen.height
                }
            },
            audio: false
        };
        navigator.mediaDevices
            .getUserMedia(config)
            .then(function (stream) {
            // this.stateCenter.screenShotStream = stream;
            callBack(true, stream);
        })
            .catch(function (err) {
            _this.logger.error("ze.sse.1 " + err);
            callBack(false, null, {
                code: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError.code,
                message: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kScreenFailedError
                    .message +
                    " " +
                    err
            });
        });
    };
    PublishModule.prototype.startPreview = function (mediaStreamConstraints, previewType, success, error) {
        var _this = this;
        var preview = null;
        preview = new zego_preview_1.ZegoPreview(this.logger, this.streamCenter.ac, this.stateCenter, this.streamCenter, previewType);
        this.streamCenter.previewStreamList.push(preview);
        preview.startPreview(mediaStreamConstraints, function (stream) {
            _this.streamCenter.soundLevelDelegate && (preview === null || preview === void 0 ? void 0 : preview.startSoundLevel());
            if (previewType === "camera") {
                // 
                (preview === null || preview === void 0 ? void 0 : preview.micTrack) &&
                    (preview.micTrack.enabled = _this.streamCenter.isMicEnabled);
            }
            // contentHint
            if (mediaStreamConstraints === null || mediaStreamConstraints === void 0 ? void 0 : mediaStreamConstraints.videoOptimizationMode) {
                _this.streamCenter.setVideoTrackContentHint(stream, mediaStreamConstraints === null || mediaStreamConstraints === void 0 ? void 0 : mediaStreamConstraints.videoOptimizationMode);
            }
            _this.logger.debug("zsc.sp.0 call success");
            !_this.stateCenter.deviceInfos && _this.recordDevices();
            success && success(stream);
        }, function (err) {
            _this.streamCenter.previewStreamList = _this.streamCenter.previewStreamList.filter(function (view) { return view !== preview; });
            error && error(err);
        });
        return true;
    };
    PublishModule.prototype.stopPreview = function (localStream) {
        if (!localStream) {
            this.logger.warn("zsc.sp.0 localStream null");
            return false;
        }
        for (var streamid in this.streamCenter.publisherList) {
            if (this.streamCenter.publisherList[streamid].localStream === localStream) {
                this.streamCenter.publisherList[streamid].localStream = null;
            }
        }
        var preview = this.streamCenter.checkPreview(localStream);
        if (!preview) {
            this.logger.warn("zsc.sp.0 no preview");
            return false;
        }
        if (preview.previewSuc) {
            preview.stopPreview();
            this.streamCenter.removePreview(preview);
        }
        return true;
    };
    PublishModule.prototype.recordDevices = function (suc, fail) {
        var _this = this;
        var _a;
        this.logger.info("zsc.rd.0 call");
        // 
        client_util_1.ClientUtil.getDevices(function (res) {
            _this.stateCenter.deviceInfos = {
                microphones: res.microphones,
                speakers: res.speakers,
                cameras: res.cameras
            };
            suc && suc(res);
        }, function (err) {
            _this.logger.warn("zsc.rd.0 getDevices err:", err);
            fail && fail(err);
        });
        if (((_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.ondevicechange) !== undefined) {
            navigator.mediaDevices.ondevicechange = null;
            navigator.mediaDevices.ondevicechange = function (event) {
                _this.logger.info("zsc.rd.0 devicechange");
                if (_this.stateCenter.deviceChangeTimer) {
                    clearTimeout(_this.stateCenter.deviceChangeTimer);
                    _this.stateCenter.deviceChangeTimer = null;
                }
                _this.stateCenter.deviceChangeTimer = setTimeout(function () {
                    client_util_1.ClientUtil.getDevices(function (res) {
                        var reducedCameras = [];
                        var _loop_1 = function (i) {
                            var camera = _this.stateCenter.deviceInfos.cameras[i];
                            if (!res.cameras.find(function (item) { return item.deviceID === camera.deviceID; })) {
                                reducedCameras.push(camera);
                            }
                        };
                        for (var i = 0; i < _this.stateCenter.deviceInfos.cameras.length; i++) {
                            _loop_1(i);
                        }
                        _this.stateCenter.deviceStateOut = false;
                        var deviceOut = false;
                        reducedCameras.length > 0 && (deviceOut = true);
                        reducedCameras.forEach(function (reducedCamera) {
                            for (var key in _this.streamCenter.publisherList) {
                                var publish = _this.streamCenter.publisherList[key];
                                var publisher = publish.publisher;
                                if (publish.localStream &&
                                    publish.cameraLabel === reducedCamera.deviceName) {
                                    deviceOut = false;
                                    publisher.sendStreamStatus(-6, publisher.mic_status);
                                    _this.stateCenter.actionListener("_deviceError", zego_error_1.errorCodeList.DEVICE_ERROR_TYPE_UNPLUGGED.code, reducedCamera.deviceName, "camera");
                                    _this.stateCenter.actionListener("deviceError", zego_error_1.errorCodeList.DEVICE_ERROR_TYPE_UNPLUGGED.code, reducedCamera.deviceName);
                                }
                                publish.localStream &&
                                    publish.localStream.getAudioTracks().length === 0 &&
                                    (deviceOut = false);
                            }
                            var reportSeq = zego_entity_1.getReportSeq();
                            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskDeviceInterrupt.event);
                            _this.dataReport.addMsgInfo(reportSeq, {
                                interrupt: 0
                            });
                            _this.dataReport.uploadReport(reportSeq);
                            _this.stateCenter.actionListener("videoDeviceStateChanged", "DELETE", reducedCamera);
                        });
                        if (deviceOut) {
                            _this.stateCenter.deviceStateOut = true;
                        }
                        var reduceMicros = _this.stateCenter.deviceInfos.microphones.filter(function (item) {
                            return !res.microphones.find(function (micro) { return micro.deviceID === item.deviceID; });
                        });
                        reduceMicros.forEach(function (reducedCamera) {
                            for (var key in _this.streamCenter.publisherList) {
                                var publish = _this.streamCenter.publisherList[key];
                                var publisher = publish.publisher;
                                if (publish.localStream &&
                                    (publish.microLabel === reducedCamera.deviceName ||
                                        publish.microLabel.includes(reducedCamera.deviceName))) {
                                    publisher.sendStreamStatus(publisher.camera_status, -6);
                                    _this.stateCenter.actionListener("_deviceError", zego_error_1.errorCodeList.DEVICE_ERROR_TYPE_UNPLUGGED.code, _this.streamCenter.publisherList[key].microLabel, "micro");
                                    _this.stateCenter.actionListener("deviceError", zego_error_1.errorCodeList.DEVICE_ERROR_TYPE_UNPLUGGED.code, _this.streamCenter.publisherList[key].microLabel);
                                }
                            }
                            var reportSeq = zego_entity_1.getReportSeq();
                            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskDeviceInterrupt.event);
                            _this.dataReport.addMsgInfo(reportSeq, {
                                interrupt: 0
                            });
                            _this.dataReport.uploadReport(reportSeq);
                            _this.stateCenter.actionListener("audioDeviceStateChanged", "DELETE", "Input", reducedCamera);
                        });
                        var reduceSpeakers = _this.stateCenter.deviceInfos.speakers.filter(function (item) {
                            return !res.speakers.find(function (micro) { return micro.deviceID === item.deviceID; });
                        });
                        var increaseCameras = res.cameras.filter(function (item) {
                            return !_this.stateCenter.deviceInfos.cameras.find(function (camera) { return camera.deviceID === item.deviceID; });
                        });
                        var increaseMicros = res.microphones.filter(function (item) {
                            return !_this.stateCenter.deviceInfos.microphones.find(function (camera) { return camera.deviceID === item.deviceID; });
                        });
                        var increaseSpeakers = res.speakers.filter(function (item) {
                            return !_this.stateCenter.deviceInfos.speakers.find(function (camera) { return camera.deviceID === item.deviceID; });
                        });
                        reduceSpeakers.forEach(function (device) {
                            var reportSeq = zego_entity_1.getReportSeq();
                            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskAudioOutputChanged.event);
                            _this.dataReport.addMsgInfo(reportSeq, {
                                reason: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskAudioOutputChanged.reason("delete"),
                                device: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskAudioOutputChanged.device(device)
                            });
                            _this.dataReport.uploadReport(reportSeq);
                            _this.stateCenter.actionListener("audioDeviceStateChanged", "DELETE", "Output", device);
                        });
                        increaseCameras.forEach(function (device) {
                            var reportSeq = zego_entity_1.getReportSeq();
                            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskDeviceInterrupt.event);
                            _this.dataReport.addMsgInfo(reportSeq, {
                                interrupt: 1
                            });
                            _this.dataReport.uploadReport(reportSeq);
                            _this.stateCenter.actionListener("videoDeviceStateChanged", "ADD", device);
                        });
                        increaseMicros.forEach(function (device) {
                            var reportSeq = zego_entity_1.getReportSeq();
                            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskDeviceInterrupt.event);
                            _this.dataReport.addMsgInfo(reportSeq, {
                                interrupt: 1
                            });
                            _this.dataReport.uploadReport(reportSeq);
                            _this.stateCenter.actionListener("audioDeviceStateChanged", "ADD", "Input", device);
                        });
                        increaseSpeakers.forEach(function (device) {
                            var reportSeq = zego_entity_1.getReportSeq();
                            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskAudioOutputChanged.event);
                            _this.dataReport.addMsgInfo(reportSeq, {
                                reason: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskAudioOutputChanged.reason("add"),
                                device: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskAudioOutputChanged.device(device)
                            });
                            _this.dataReport.uploadReport(reportSeq);
                            _this.stateCenter.actionListener("audioDeviceStateChanged", "ADD", "Output", device);
                        });
                        _this.stateCenter.deviceInfos = {
                            microphones: res.microphones,
                            speakers: res.speakers,
                            cameras: res.cameras
                        };
                    }, function (err) {
                        _this.logger.warn("zsc.rd.0 getDevices err:", err);
                    });
                }, 500);
            };
        }
    };
    PublishModule.prototype.getStreamThroughCanvas = function (stream) {
        if (stream.getVideoTracks().length == 0) {
            return stream;
        }
        var video = document.createElement("video");
        var canvas = document.createElement("canvas");
        var ctx = canvas.getContext("2d");
        video.setAttribute("style", "display:none");
        canvas.setAttribute("style", "display:none");
        video.setAttribute("muted", "");
        video.muted = !0;
        video.setAttribute("autoplay", "");
        video.autoplay = !0;
        video.setAttribute("playsinline", "");
        document.body.append(video);
        document.body.append(canvas);
        video.srcObject = stream;
        var draw = function () {
            ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            window.requestAnimationFrame(draw);
            // track.requestFrame && track.requestFrame();
            video.srcObject = stream;
        };
        video.oncanplay = function () {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            video.play();
            draw();
        };
        //@ts-ignore
        var media = canvas.captureStream(15);
        var track = media.getVideoTracks()[0];
        var q = track.stop;
        track.stop = function () {
            q.call(track);
            draw();
            video.remove();
            canvas.width = 0;
            canvas.remove();
        };
        if (stream instanceof MediaStream && stream.getAudioTracks().length) {
            var micro = stream.getAudioTracks()[0];
            media.addTrack(micro);
        }
        return media;
    };
    PublishModule.prototype.startWaitPublish = function () {
        var _this = this;
        this.streamCenter.waitPublishList.forEach(function (streamID) {
            _this.streamCenter.startPublishingStream(streamID, _this.stateCenter.useNetAgent);
        });
        this.streamCenter.waitPublishList = [];
    };
    return PublishModule;
}());
exports.PublishModule = PublishModule;


/***/ }),

/***/ "./sdk/src/webrtc/modules/publishModules/zego.preview.ts":
/*!***************************************************************!*\
  !*** ./sdk/src/webrtc/modules/publishModules/zego.preview.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoPreview = void 0;
var zego_entity_1 = __webpack_require__(/*! ../../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var action_1 = __webpack_require__(/*! ../../../common/action */ "./sdk/src/common/action.ts");
var ZegoPreview = /** @class */ (function () {
    function ZegoPreview(logger, ac, stateCenter, streamCenter, previewType) {
        var _this = this;
        this.logger = logger;
        this.ac = ac;
        this.stateCenter = stateCenter;
        this.streamCenter = streamCenter;
        this.previewType = previewType;
        this.localStream = null;
        this.videoInfo = {};
        this.previewSuc = false;
        this.soundLevel = 0;
        this.hasEmptyAudioTrack = false;
        this.script = null;
        this.mic = null;
        this._audioTrack = null;
        this._videoTrack = null;
        this.originVideoTrack = null;
        // SEI
        this.activateSEIConfig = null;
        // 
        this.isAudioEnabled = true;
        this.gainNode = null;
        this.cameraMaxResolution = {};
        /*
         *    "zp.emo.2": "enableMicrophoneOnly"
         */
        this.enableMicrophoneOnly = function (enable, streamCenter) {
            var _a;
            if (!_this.localStream) {
                _this.logger.error("zp.em.2 no localStream");
                return false;
            }
            else {
                var publisher = (_a = streamCenter.checkPublish(_this.localStream)) === null || _a === void 0 ? void 0 : _a.publisher;
                if (publisher) {
                    var camera_status = publisher.camera_status;
                    var mic_status = _this.isAudioEnabled && enable ? 0 : 20;
                    if (publisher.camera_status !== camera_status ||
                        publisher.mic_status !== mic_status) {
                        publisher.sendStreamStatus(camera_status, mic_status);
                    }
                }
            }
            if (!_this.micTrack) {
                _this.logger.info("zp.emo.2 no micTrack");
                return true;
            }
            _this.micTrack.enabled = _this.isAudioEnabled && enable;
            _this.logger.debug("zp.emo.2 call success");
            return true;
        };
    }
    Object.defineProperty(ZegoPreview.prototype, "audioTrack", {
        get: function () {
            var _a;
            return this._audioTrack || ((_a = this.localStream) === null || _a === void 0 ? void 0 : _a.getAudioTracks()[0]) || null;
        },
        set: function (val) {
            this._audioTrack = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ZegoPreview.prototype, "videoTrack", {
        get: function () {
            var _a;
            return this._videoTrack || ((_a = this.localStream) === null || _a === void 0 ? void 0 : _a.getVideoTracks()[0]) || null;
        },
        set: function (val) {
            this._videoTrack = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ZegoPreview.prototype, "micTrack", {
        get: function () {
            return (this.previewType === "camera" && this.audioTrack) || null;
        },
        enumerable: false,
        configurable: true
    });
    /*
     *    "zp.gmsc.2": "getMediaStreamConstraints"
     */
    ZegoPreview.prototype.getMediaStreamConstraints = function (mediaStreamConfig, force) {
        var mediaStreamConstraints = {
            audio: null,
            video: null
        };
        mediaStreamConstraints["audio"] = true;
        mediaStreamConstraints["video"] = {
            width: 640,
            height: 480,
            frameRate: 15,
            bitRate: this.stateCenter.settingConfig.getSetting("camera_video_bitrate")
        };
        //audio
        if (mediaStreamConfig.audio) {
            if (mediaStreamConfig.audioInput === undefined &&
                mediaStreamConfig.ANS === undefined &&
                mediaStreamConfig.AGC === undefined &&
                mediaStreamConfig.AEC === undefined &&
                mediaStreamConfig.channelCount === undefined) {
                mediaStreamConstraints.audio = {};
                mediaStreamConstraints.audio.noiseSuppression = this.stateCenter.settingConfig.getSetting("ANS");
                mediaStreamConstraints.audio.autoGainControl = this.stateCenter.settingConfig.getSetting("AGC");
                mediaStreamConstraints.audio.echoCancellation = this.stateCenter.settingConfig.getSetting("AEC");
                mediaStreamConstraints.audio.channelCount = 1;
            }
            else {
                mediaStreamConstraints.audio = {};
                if (mediaStreamConfig.audioInput !== undefined &&
                    mediaStreamConfig.audioInput !== null)
                    mediaStreamConstraints.audio.deviceId = {
                        exact: mediaStreamConfig.audioInput
                    };
                if (mediaStreamConfig.ANS !== undefined)
                    mediaStreamConstraints.audio.noiseSuppression = mediaStreamConfig.ANS;
                if (mediaStreamConfig.AGC !== undefined)
                    mediaStreamConstraints.audio.autoGainControl = mediaStreamConfig.AGC;
                if (mediaStreamConfig.AEC !== undefined)
                    mediaStreamConstraints.audio.echoCancellation = mediaStreamConfig.AEC;
                if (mediaStreamConfig.channelCount !== undefined)
                    mediaStreamConstraints.audio.channelCount =
                        mediaStreamConfig.channelCount;
            }
        }
        else if (mediaStreamConfig.audio === false) {
            mediaStreamConstraints.audio = false;
        }
        //video
        if (mediaStreamConfig.video) {
            var width = 640;
            var height = 480;
            var frameRate = 15;
            var bitRate = this.stateCenter.settingConfig.getSetting("camera_video_bitrate");
            //videoQuality
            //1 QVGA
            if (mediaStreamConfig.videoQuality === 1) {
                width = zego_entity_1.ENUM_RESOLUTION_TYPE.LOW.width;
                height = zego_entity_1.ENUM_RESOLUTION_TYPE.LOW.height;
                frameRate = zego_entity_1.ENUM_RESOLUTION_TYPE.LOW.frameRate;
                bitRate = zego_entity_1.ENUM_RESOLUTION_TYPE.LOW.bitRate;
            }
            //2 VGA
            else if (mediaStreamConfig.videoQuality === 2) {
                width = zego_entity_1.ENUM_RESOLUTION_TYPE.MEDIUM.width;
                height = zego_entity_1.ENUM_RESOLUTION_TYPE.MEDIUM.height;
                frameRate = zego_entity_1.ENUM_RESOLUTION_TYPE.MEDIUM.frameRate;
                bitRate = zego_entity_1.ENUM_RESOLUTION_TYPE.MEDIUM.bitRate;
            }
            //3 HD
            else if (mediaStreamConfig.videoQuality === 3) {
                width = zego_entity_1.ENUM_RESOLUTION_TYPE.HIGH.width;
                height = zego_entity_1.ENUM_RESOLUTION_TYPE.HIGH.height;
                frameRate = zego_entity_1.ENUM_RESOLUTION_TYPE.HIGH.frameRate;
                bitRate = zego_entity_1.ENUM_RESOLUTION_TYPE.HIGH.bitRate;
            }
            //custom
            else if (mediaStreamConfig.videoQuality === 4) {
                width = mediaStreamConfig.width;
                height = mediaStreamConfig.height;
                frameRate = mediaStreamConfig.frameRate;
                bitRate =
                    mediaStreamConfig.bitRate ||
                        this.stateCenter.settingConfig.getSetting("camera_video_bitrate");
            }
            else {
                this.logger.info("zp.gmsc.2 use default");
            }
            if (force) {
                mediaStreamConfig.width && (width = mediaStreamConfig.width);
                mediaStreamConfig.height &&
                    (height = mediaStreamConfig.height);
                mediaStreamConfig.frameRate &&
                    (frameRate = mediaStreamConfig.frameRate);
                mediaStreamConfig.bitRate && (bitRate = mediaStreamConfig.bitRate);
            }
            //switch
            if (mediaStreamConfig.horizontal === false) {
                var temp = height;
                height = width;
                width = temp;
            }
            if (mediaStreamConfig.isSwitch === true) {
                var temp = height;
                height = width;
                width = temp;
            }
            mediaStreamConstraints.video = {
                width: width,
                height: height,
                frameRate: frameRate,
                bitRate: bitRate
            };
            //facingMode
            if (mediaStreamConfig.facingMode != undefined) {
                mediaStreamConstraints.video.facingMode = mediaStreamConfig.facingMode;
            }
            else if (mediaStreamConfig.videoInput != undefined &&
                mediaStreamConfig.videoInput != null &&
                mediaStreamConfig.videoInput != "") {
                mediaStreamConstraints.video.deviceId = {
                    exact: mediaStreamConfig.videoInput
                };
            }
            this.logger.info("zp.gmsc.2 width: " +
                width +
                " height: " +
                height +
                " rate: " +
                frameRate);
        }
        else if (mediaStreamConfig.video === false) {
            if (mediaStreamConfig.audioBitrate) {
                mediaStreamConstraints.video = {};
            }
            mediaStreamConstraints.video = false;
        }
        return mediaStreamConstraints;
    };
    /*
     *    "zp.sv.2": "startPreview"
     */
    ZegoPreview.prototype.startPreview = function (mediaStreamConfig, successCallback, errorCallback) {
        return __awaiter(this, void 0, void 0, function () {
            var videoTracks, videoinfo, result, mediaStreamConstraints, _AEC, _AGC, _ANS;
            var _this = this;
            return __generator(this, function (_a) {
                this.logger.debug("zp.sv.2 called");
                this.mediaStreamConfig = mediaStreamConfig;
                if (navigator.mediaDevices === undefined ||
                    navigator.mediaDevices.getUserMedia == undefined) {
                    if (errorCallback) {
                        errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kBrowserNotSupportError);
                    }
                    return [2 /*return*/];
                }
                //
                if (mediaStreamConfig.source instanceof MediaStream) {
                    videoTracks = mediaStreamConfig.source.getVideoTracks();
                    videoinfo = videoTracks.length > 0
                        ? videoTracks[0].getSettings()
                        : {
                            width: 0,
                            height: 0,
                            frameRate: 0
                        };
                    this.logger.debug("zp.sv.2 use external media stream");
                    this.previewSuc = true;
                    this.localStream = mediaStreamConfig.source;
                    this.initMediaTrack(mediaStreamConfig.source);
                    this.videoInfo = {
                        width: videoinfo.width,
                        height: videoinfo.height,
                        frameRate: videoinfo.frameRate,
                        bitRate: mediaStreamConfig.bitRate ||
                            this.stateCenter.settingConfig.getSetting("custom_video_bitrate"),
                        startBitrate: mediaStreamConfig.startBitrate ||
                            this.stateCenter.settingConfig.getSetting("bitrate_mode"),
                        channelCount: mediaStreamConfig.channelCount ||
                            (this.audioTrack
                                ? this.audioTrack.getSettings
                                    ? //@ts-ignore
                                        this.audioTrack.getSettings().channelCount
                                    : 1
                                : 1),
                        audioBitrate: mediaStreamConfig.audioBitrate * 1e3 || 48000
                    };
                    if (successCallback) {
                        successCallback(this.localStream);
                    }
                    return [2 /*return*/];
                }
                else if (mediaStreamConfig.source instanceof HTMLMediaElement) {
                    result = this.captureStream(mediaStreamConfig.source, mediaStreamConfig);
                    if (result) {
                        this.videoInfo.bitRate =
                            mediaStreamConfig.bitRate ||
                                this.stateCenter.settingConfig.getSetting("custom_video_bitrate");
                        this.previewSuc = true;
                        this.initMediaTrack(result);
                        if (successCallback) {
                            successCallback(result);
                        }
                    }
                    else {
                        if (errorCallback) {
                            errorCallback(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kBrowserNotSupportError);
                        }
                    }
                    return [2 /*return*/];
                }
                mediaStreamConstraints = this.getMediaStreamConstraints(mediaStreamConfig);
                // 
                // 3A
                if (mediaStreamConstraints.audio) {
                    _AEC = this.stateCenter.settingConfig.getSetting("AEC", true);
                    _AGC = this.stateCenter.settingConfig.getSetting("AGC", true);
                    _ANS = this.stateCenter.settingConfig.getSetting("ANS", true);
                    if (typeof _AEC == "boolean") {
                        this.logger.info("zp.sv.2 setting AEC " + _AEC);
                        mediaStreamConstraints.audio.echoCancellation = _AEC;
                    }
                    if (typeof _AGC == "boolean") {
                        this.logger.info("zp.sv.2 setting AGC " + _AGC);
                        mediaStreamConstraints.audio.autoGainControl = _AGC;
                    }
                    if (typeof _ANS == "boolean") {
                        this.logger.info("zp.sv.2 setting ANS " + _ANS);
                        mediaStreamConstraints.audio.noiseSuppression = _ANS;
                    }
                }
                // 
                this.videoInfo = __assign({}, mediaStreamConstraints.video);
                if (this.videoInfo) {
                    this.videoInfo.audioBitrate =
                        mediaStreamConfig.audioBitrate * 1e3 || 48000;
                    this.videoInfo.startBitrate =
                        mediaStreamConfig.startBitrate ||
                            this.stateCenter.settingConfig.getSetting("bitrate_mode");
                }
                else if (mediaStreamConfig.audioBitrate) {
                    this.videoInfo = {
                        audioBitrate: mediaStreamConfig.audioBitrate * 1e3 || 48000
                    };
                }
                this.mediaStreamConfig.video = mediaStreamConstraints.video ? true : false;
                this.mediaStreamConfig.audio = mediaStreamConstraints.audio ? true : false;
                this.logger.info("zp.sv.2 ", JSON.stringify(mediaStreamConstraints));
                // 
                if (mediaStreamConfig.unlimitedCaptureResolution &&
                    mediaStreamConstraints.video.width) {
                    // 
                    mediaStreamConstraints.video.width = { ideal: 4096 };
                    mediaStreamConstraints.video.height = { ideal: 2160 };
                    this.logger.info("zp.sv.2 ", "capture max resolution of camera");
                }
                navigator.mediaDevices.getUserMedia(mediaStreamConstraints).then(function (stream) {
                    _this.logger.info("zp.sv.2 success");
                    //this.localVideo.srcObject = stream;
                    _this.localStream = stream;
                    _this.previewSuc = true;
                    _this.initMediaTrack(stream);
                    if (_this.videoInfo) {
                        _this.videoInfo.channelCount =
                            mediaStreamConfig.channelCount ||
                                (_this.audioTrack
                                    ? _this.audioTrack.getSettings
                                        ? //@ts-ignore
                                            _this.audioTrack.getSettings().channelCount
                                        : 1
                                    : 1);
                    }
                    if (successCallback) {
                        successCallback(stream);
                    }
                }, function (error) {
                    _this.logger.info("zp.sv.2 failed ", error.name, " ", error.message);
                    if (errorCallback) {
                        var throwError = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error.kGetUserMediaError;
                        throwError.message =
                            throwError.message + " " + error.name + " " + error.message;
                        // ;
                        if (error.name === "NotAllowedError" ||
                            error.name === "SecurityError") {
                            throwError = __assign({}, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error
                                .kDeviceNoAllowedError);
                            throwError.message = error.name + ": " + throwError.message;
                        }
                        else if (error.name === "NotReadableError") {
                            throwError = __assign({}, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error
                                .kDeviceNoReadableError);
                            throwError.message = error.name + ": " + throwError.message;
                        }
                        else if (error.name === "OverconstrainedError") {
                            throwError = __assign({}, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskCreateStream.error
                                .kDeviceOverConstrainedError);
                            throwError.message =
                                error.name +
                                    ": " +
                                    throwError.message +
                                    (error.constraint ? ". such as " + error.constraint : "");
                        }
                        errorCallback(throwError);
                    }
                });
                return [2 /*return*/];
            });
        });
    };
    /*
     *    "zp.cs.2": "captureStream"
     */
    ZegoPreview.prototype.captureStream = function (localVideo, mediaStreamConfig) {
        if (!localVideo) {
            this.logger.info("zp.cs.2 no local video");
            return null;
        }
        var stream;
        if (localVideo["captureStream"]) {
            stream = localVideo["captureStream"]();
            this.logger.debug("zp.cs.2 captureStream");
        }
        else if (localVideo["mozCaptureStream"]) {
            stream = localVideo["mozCaptureStream"]();
            this.logger.debug("zp.cs.2 mozCaptureStream");
        }
        else {
            this.logger.info("zp.cs.2 don't support");
            return null;
        }
        if (stream.getTracks().length == 0) {
            this.logger.error("zp.cs.2 external capture tracks no found");
            return null;
        }
        this.localStream = stream;
        this.videoInfo = {
            width: localVideo["videoWidth"],
            height: localVideo["videoHeight"],
            frameRate: 0,
            bitRate: mediaStreamConfig.bitRate ||
                this.stateCenter.settingConfig.getSetting("custom_video_bitrate"),
            channelCount: mediaStreamConfig.channelCount ||
                (this.audioTrack
                    ? this.audioTrack.getSettings
                        ? //@ts-ignore
                            this.audioTrack.getSettings().channelCount
                        : 1
                    : 1),
            audioBitrate: mediaStreamConfig.audioBitrate * 1e3 || 48000,
            startBitrate: mediaStreamConfig.startBitrate ||
                this.stateCenter.settingConfig.getSetting("bitrate_mode")
        };
        this.logger.debug("zp.cs.2 called success");
        return this.localStream;
    };
    /*
     *    "zp.sv.2.1": "stopPreview"
     */
    ZegoPreview.prototype.stopPreview = function () {
        var _a, _b, _c;
        this.logger.info("zp.sv.2.1 called");
        if (!this.localStream) {
            return;
        }
        if (this.videoEffect) {
            this.videoEffect.setBeautyEffectOptions(false);
            this.videoEffect.destroy();
        }
        (_a = this.originVideoTrack) === null || _a === void 0 ? void 0 : _a.stop();
        (_b = this.videoTrack) === null || _b === void 0 ? void 0 : _b.stop();
        (_c = this.audioTrack) === null || _c === void 0 ? void 0 : _c.stop();
        this.localStream
            .getTracks()
            .reverse()
            .forEach(function (track) { return track.stop(); });
        this.localStream = null;
        this.videoInfo = {};
    };
    /*
     *    "zp.em.2": "enableMicrophone"
     */
    ZegoPreview.prototype.enableMicrophone = function (enable, streamCenter) {
        return false;
    };
    /*
     *    "zp.ec.2": "enableCamera"
     */
    ZegoPreview.prototype.enableCamera = function (enable, streamCenter, retain) {
        return false;
    };
    ZegoPreview.prototype.startSoundLevel = function () {
        var _this = this;
        if (!this.localStream || this.localStream.getAudioTracks().length == 0) {
            return;
        }
        this.script && this.script.disconnect() && (this.script = null);
        this.mic && this.mic.disconnect() && (this.mic = null);
        try {
            this.mic = this.ac.createMediaStreamSource(this.localStream);
            this.script = this.ac.createScriptProcessor(4096, 1, 1); //4096
            this.mic.connect(this.script); //
            this.script.connect(this.ac.destination); //  Chrome  bug
            this.script.onaudioprocess = function (e) {
                //
                var buffer = e.inputBuffer.getChannelData(0); //PCM32
                //
                var maxVal = 0;
                for (var i = 0; i < buffer.length; i++) {
                    if (maxVal < buffer[i]) {
                        maxVal = buffer[i];
                    }
                }
                _this.soundLevel = maxVal * 100;
            };
            this.ac.resume();
        }
        catch (err) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_SOUND_LEVEL +
                " get sound level failed " +
                err);
        }
    };
    ZegoPreview.prototype.stopSoundLevel = function () {
        this.soundLevel = 0;
        this.script && this.script.disconnect();
        this.mic && this.mic.disconnect();
        this.script = null;
        this.mic = null;
    };
    ZegoPreview.prototype.restartSoundLevel = function () {
        if (this.streamCenter.soundLevelDelegate) {
            this.stopSoundLevel();
            this.startSoundLevel();
        }
        else {
            this.stopSoundLevel();
        }
    };
    ZegoPreview.prototype.setBeautyEffect = function (enable, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/];
            });
        });
    };
    /**
     * 
     * @param track 
     * @param isEffectTrack 
     * @returns
     */
    ZegoPreview.prototype.replacePreviewTrack = function (track, isEffectTrack) {
        if (isEffectTrack === void 0) { isEffectTrack = false; }
        return;
    };
    ZegoPreview.prototype.initMediaTrack = function (stream) {
        if (stream.getVideoTracks().length > 0) {
            this.videoTrack = stream.getVideoTracks()[0];
            this.originVideoTrack = this.videoTrack;
        }
        stream.getAudioTracks().length > 0 &&
            (this.audioTrack = stream.getAudioTracks()[0]);
    };
    return ZegoPreview;
}());
exports.ZegoPreview = ZegoPreview;


/***/ }),

/***/ "./sdk/src/webrtc/modules/publishModules/zego.publish.ts":
/*!***************************************************************!*\
  !*** ./sdk/src/webrtc/modules/publishModules/zego.publish.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoPublish = void 0;
var zego_entity_1 = __webpack_require__(/*! ../../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var sdpUtil_1 = __webpack_require__(/*! ../../../util/sdpUtil */ "./sdk/src/util/sdpUtil.ts");
var client_util_1 = __webpack_require__(/*! ../../../util/client-util */ "./sdk/src/util/client-util.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var action_1 = __webpack_require__(/*! ../../../common/action */ "./sdk/src/common/action.ts");
var ZegoPublish = /** @class */ (function () {
    function ZegoPublish(streamId, log, dataReport, qualityTimeInterval, streamCenter, ac, mediaEleSources, stateCenter, localStream) {
        this.state = zego_entity_1.ENUM_PUBLISH_STATE.stop;
        this.sessionId = 0;
        this.sessionToken = "";
        // localVideo = null;
        // localStream = null;
        this.candidateInfo = [];
        this.qualityTimer = null;
        this.publishQualityList = [];
        this.maxQualityListCount = 10;
        this.lastPublishStats = {};
        this.reportSeq = NaN;
        this.streamReportSeq = zego_entity_1.getSeq();
        //quality signal
        this.qualityUpload = false;
        this.qualityUploadInterval = 30 * 1000;
        this.qualityUploadLastTime = 0;
        this.qualitySeq = 0;
        this.videoInfo = {
            width: 0,
            height: 0,
            frameRate: 0,
            bitRate: 0,
            channelCount: 1,
            audioBitrate: 48000
        };
        this.mediaStreamConfig = null;
        this.offerSeq = 0;
        this.audioMixList = [];
        this.arrayBufferMap = {};
        this.effectList = [];
        this.peerConnection = null;
        this.qualityCount = 0;
        this.closeSessionSignal = false;
        // playOption:PlayOption;
        this.channelCount = 1;
        this.localSdpOrder = [];
        this.remoteSdpOrder = [];
        this.videoCodec = "H264";
        this.stateNego = zego_entity_1.ENUM_PUBLISH_STATE_NEGO.stop;
        this.negoInterval = 25000;
        this.publishEvent = false;
        // soundLevel = 0;
        // script: ScriptProcessorNode | null = null;
        // mic: any = null;
        this.cameraState = "on";
        this.microState = "on";
        this.gwNode = "";
        this.gwNodeList = [];
        this.gwNodeTTL = 0;
        //
        this.needIncMax = false;
        this.probeCount = 0;
        this.gotMax = false;
        this.initFitCnt = 0;
        this.targetRate = 0;
        this.totalBitrateArray = [];
        this.totalTargetRateArray = [];
        this.totalRetransRateArray = [];
        //peer
        this.isPeer = false;
        this.peerFailCount = 0;
        //
        this.peerID = 0;
        this.netQuality = 0;
        this.probeTime = 0;
        this.probeInterval = 60000;
        this.probeState = zego_entity_1.ENUM_PROBE_STATE.probed;
        this.iceDisconnectedMaxTime = 15000;
        this.isUpdateSDP = false;
        // 
        this.toBeReplacedTracks = {};
        this.send_seq = 0;
        this.dataChannelState = 0;
        this.first_pkt = true;
        this.next_sn = [];
        this.pkt_list = [];
        this.camera_status = 2;
        this.mic_status = 2;
        this.streamId = streamId;
        this.logger = log;
        this.dataReport = dataReport;
        this.qualityTimeInterval = qualityTimeInterval;
        this.ac = ac;
        this.mediaEleSources = mediaEleSources;
        this.streamCenter = streamCenter;
        this.stateCenter = stateCenter;
        this.dataReport.newReport(this.streamReportSeq);
        this.videoCodec = this.stateCenter.settingConfig.getSetting("publish_video_codec");
        this.localStream = localStream;
    }
    Object.defineProperty(ZegoPublish.prototype, "previewer", {
        /**
         *  ZegoPreview 
         */
        get: function () {
            return this.streamCenter.checkPreview(this.localStream);
        },
        enumerable: false,
        configurable: true
    });
    ZegoPublish.prototype.publishStateUpdateError = function (error, stopRetry) {
        this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_STATE_ERROR + "  call ", this.streamId, JSON.stringify(error));
        this.streamId &&
            this.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.error, this.streamId, error, stopRetry);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_STATE_ERROR + "  ended");
    };
    ZegoPublish.prototype.resetPublish = function () {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_RESET_PUBLISH +
            "   " +
            this.streamId +
            " call");
        this.state = zego_entity_1.ENUM_PUBLISH_STATE.stop;
        this.publishEvent = false;
        if (this.peerConnection != undefined || this.peerConnection != null) {
            this.peerConnection.close();
            this.peerConnection = null;
        }
        if (this.negoTimer != null) {
            clearTimeout(this.negoTimer);
            this.negoTimer = null;
        }
        if (this.iceDisconnectedTimer != null) {
            clearTimeout(this.iceDisconnectedTimer);
            this.iceDisconnectedTimer = null;
        }
        this.clearPublishQualityTimer();
        if (this.signal) {
            this.signal.unregisterPushCallback("CandidateInfoPush", this.sessionId);
            this.signal.unregisterPushCallback("MediaDescPush", this.sessionId);
            this.signal.unregisterPushCallback("CloseSessionPush", this.sessionId);
            this.signal.unregisterPushCallback("SessionResetPush", this.sessionId);
            this.signal.unregisterPushCallback("PublishEventPush", this.sessionId);
            this.signal.unregisterPushCallback("ClientInfoPush", this.sessionId);
        }
        // this.sessionId = 0;
        this.sessionSeq = 0;
        this.offerSeq = 0;
        this.candidateInfo = [];
        this.publishQualityList = [];
        this.qualityUploadLastTime = 0;
        // 
        // this.stopSoundLevel();
        this.resetEncBitrate();
        this.isUpdateSDP = false;
    };
    ZegoPublish.prototype.clearPublishQualityTimer = function () {
        if (this.qualityTimer != null) {
            clearInterval(this.qualityTimer);
            this.qualityTimer = null;
        }
        this.lastPublishStats = {};
        this.qualityCount = 0;
        //this.dataReport.uploadReport(this.qualitySeq, "RTCPublishQuality");
    };
    ZegoPublish.prototype.shouldSendCloseSession = function () {
        if (this.state != zego_entity_1.ENUM_PUBLISH_STATE.stop &&
            this.state != zego_entity_1.ENUM_PUBLISH_STATE.waitingSessionRsp) {
            return true;
        }
        return false;
    };
    /*
     *    "zp.sp.0": "ZegoPublish.startPublish"
     */
    ZegoPublish.prototype.startPublish = function (streamId, localStream, videoInfo, mediaStreamConfig, publishOption) {
        var _this = this;
        var _a;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH + " " + streamId + " called");
        this.signal &&
            this.signal.negoInterval &&
            (this.negoInterval = this.signal.negoInterval);
        if (!streamId) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " " +
                streamId +
                " streamId is null");
            return;
        }
        this.localStream = localStream;
        this.mediaStreamConfig = mediaStreamConfig;
        this.channelCount = mediaStreamConfig.channelCount;
        this.publishOption = publishOption || {};
        // firefox
        if (navigator.userAgent.toLowerCase().indexOf("firefox") > -1 &&
            mediaStreamConfig &&
            (mediaStreamConfig.externalCapture ||
                mediaStreamConfig.externalMediaStream)) {
            this.localStream.onaddtrack = function () {
                var _a, _b, _c, _d;
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                    " " +
                    _this.streamId +
                    " Track added");
                //  previewer  videoTrack
                var videoTracks = [];
                ((_a = _this.previewer) === null || _a === void 0 ? void 0 : _a.videoTrack) &&
                    videoTracks.push((_b = _this.previewer) === null || _b === void 0 ? void 0 : _b.videoTrack);
                var audioTracks = _this.localStream.getAudioTracks();
                if (videoTracks.length > 1) {
                    var sender = (_c = _this.peerConnection) === null || _c === void 0 ? void 0 : _c.getSenders().find(function (s) { var _a; return ((_a = s.track) === null || _a === void 0 ? void 0 : _a.kind) === videoTracks[1].kind; });
                    sender === null || sender === void 0 ? void 0 : sender.replaceTrack(videoTracks[1]);
                    _this.localStream.removeTrack(videoTracks[0]);
                }
                else if (audioTracks.length > 1) {
                    var sender = (_d = _this.peerConnection) === null || _d === void 0 ? void 0 : _d.getSenders().find(function (s) { var _a; return ((_a = s.track) === null || _a === void 0 ? void 0 : _a.kind) === audioTracks[1].kind; });
                    sender === null || sender === void 0 ? void 0 : sender.replaceTrack(audioTracks[1]);
                    _this.localStream.removeTrack(audioTracks[0]);
                }
            };
        }
        if (videoInfo) {
            this.videoInfo = videoInfo;
        }
        if (publishOption && publishOption.videoCodec) {
            this.videoCodec = publishOption.videoCodec;
        }
        var _vBitrate;
        var previewType = (_a = this.previewer) === null || _a === void 0 ? void 0 : _a.previewType;
        switch (previewType) {
            case "camera":
                _vBitrate = this.stateCenter.settingConfig.getSetting("camera_video_bitrate", true);
                break;
            case "screen":
                _vBitrate = this.stateCenter.settingConfig.getSetting("screen_video_bitrate", true);
                break;
            case "custom":
                _vBitrate = this.stateCenter.settingConfig.getSetting("custom_video_bitrate", true);
                break;
            default:
                break;
        }
        if (_vBitrate) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " setting " +
                previewType +
                " " +
                _vBitrate);
            this.videoInfo.bitRate = _vBitrate;
        }
        var _startBitrate = this.stateCenter.settingConfig.getSetting("bitrate_mode", true);
        if (_startBitrate) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " setting bitrate_mode " +
                _startBitrate);
            this.videoInfo.startBitrate = _startBitrate;
        }
        var _videoCodec = this.stateCenter.settingConfig.getSetting("publish_video_codec", true);
        if (_videoCodec) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " setting publish_video_codec " +
                _videoCodec);
            this.videoCodec = _videoCodec;
        }
        //
        this.dataReport.addMsgInfo(this.reportSeq, {
            video_en_codec_id: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.video_en_codec_id(this.videoCodec == "VP8" ? 2 : 0),
            audio_c_channel_count: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.audio_c_channel_count(this.channelCount == 2 ? 2 : 1),
            audio_en_bps: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.audio_en_bps(this.videoInfo.audioBitrate),
            aec_level: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.aec_level(mediaStreamConfig.AEC == true
                ? 2
                : mediaStreamConfig.AEC == false
                    ? 0
                    : 2),
            ans_level: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.ans_level(mediaStreamConfig.ANS == true
                ? 2
                : mediaStreamConfig.ANS == false
                    ? 0
                    : 2),
            agc: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.agc(mediaStreamConfig.AGC == true
                ? 2
                : mediaStreamConfig.AGC == false
                    ? 0
                    : 2),
            traffic_control_min_video_bitrate: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.traffic_control_min_video_bitrate(this.videoInfo.bitRate)
        });
        this.isPeer ? this.createOffer() : this.createSession();
        // 
        this.negoTimer = setTimeout(function () {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH + " waiting timeout");
            _this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishNegoTimeoutError);
        }, this.negoInterval);
    };
    ZegoPublish.prototype.activateSEIInsert = function (action, infoType) {
        return new Promise(function (resolve, reject) {
            resolve(false);
        });
    };
    ZegoPublish.prototype.createSession = function (desc) {
        var _this = this;
        //send to server
        this.sessionSeq = zego_entity_1.getSeq();
        var totalStreamId = this.streamId;
        if (this.streamCenter.testEnvironment == true) {
            totalStreamId =
                "zegotest-" + this.streamCenter.appid + "-" + this.streamId;
        }
        // 
        var gwNodes = this.stateCenter.settingConfig.getSetting("gw_nodes");
        if (gwNodes && gwNodes instanceof Array && gwNodes.length > 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " setting " +
                JSON.stringify(gwNodes));
            this.gwNodeList = gwNodes;
            this.gwNode = this.gwNodeList[0] || this.gwNode;
        }
        if (this.isPeer) {
            this.dataReport.eventStart(this.reportSeq, "CreateSessionWithSdp");
            this.dataReport.eventStart(this.streamReportSeq, "CreateSessionWithSdp");
            this.signal.createSessionWithSdp({
                seq: this.sessionSeq,
                type: 0,
                mode: 0,
                streamId: totalStreamId,
                videoInfo: this.videoInfo,
                strAuthParam: this.publishOption
                    ? this.publishOption.streamParams || ""
                    : "",
                sdp: desc.sdp,
                serverHost: this.gwNode
            }, function (seq, sessionID, msg) {
                _this.handleCreateSessionWithSdpResp(seq, sessionID, msg);
            }, function (err, seq) {
                _this.dataReport.eventEndWithMsg(_this.reportSeq, "CreateSession", {
                    error: err
                });
                _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "CreateSession", {
                    error: err
                });
                //peer
                if (err == zego_entity_1.SEND_MSG_TIMEOUT && _this.peerFailCount < 2) {
                    _this.peerFailCount++;
                    _this.createSession(desc);
                }
                else if (err == zego_entity_1.SEND_MSG_TIMEOUT && _this.peerFailCount >= 2) {
                    _this.isPeer = false;
                    _this.streamCenter.isPeer = false;
                    _this.createSession();
                }
                else {
                    _this.publishStateUpdateError(err == zego_entity_1.SEND_MSG_TIMEOUT
                        ? zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error
                            .kSessionTimeoutError
                        : zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error
                            .kSessionRequestError);
                }
            });
        }
        else {
            this.dataReport.eventStart(this.reportSeq, "CreateSession");
            this.dataReport.eventStart(this.streamReportSeq, "CreateSession");
            this.signal.createSession(this.sessionSeq, 0, 0, totalStreamId, this.publishOption && this.publishOption.streamParams, this.gwNode, function (seq, sessionId, msg) {
                _this.handleCreateSessionResp(seq, sessionId, msg);
            }, function (err, seq) {
                _this.reportSeq;
                _this.dataReport.eventEndWithMsg(_this.reportSeq, "CreateSession", {
                    error: err
                });
                _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "CreateSession", {
                    error: err
                });
                _this.publishStateUpdateError(err == zego_entity_1.SEND_MSG_TIMEOUT
                    ? zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kSessionTimeoutError
                    : zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kSessionRequestError);
            });
        }
        this.state = zego_entity_1.ENUM_PUBLISH_STATE.waitingSessionRsp;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
            " " +
            this.streamId +
            " called success");
        this.stateNego = zego_entity_1.ENUM_PUBLISH_STATE_NEGO.start;
    };
    ZegoPublish.prototype.handleCreateSessionResp = function (seq, sessionID, msg) {
        var turnServer = msg.turn_server;
        var ip = turnServer.split("?")[0] && turnServer.split("?")[0].slice(5);
        var serverArr = this.streamCenter.server.split("?");
        var app = serverArr[1] && serverArr[1].slice(2);
        this.dataReport.eventEndWithMsg(this.streamReportSeq, "CreateSession", {
            sessionId: msg.session_id,
            url: "webrtc://" + ip + "/" + app + "/" + this.streamId
        });
        this.dataReport.eventEndWithMsg(this.reportSeq, "CreateSession", {
            sessionId: msg.session_id,
            url: "webrtc://" + ip + "/" + app + "/" + this.streamId
        });
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
            " " +
            this.streamId +
            " sessionId:" +
            msg.session_id);
        if (this.sessionSeq != seq) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " " +
                this.streamId +
                " seq is not match.");
            return;
        }
        this.gwNodeList =
            msg.gw_nodes && msg.gw_nodes.length > 0 ? msg.gw_nodes : this.gwNodeList;
        this.gwNode =
            msg.gw_nodes && msg.gw_nodes.length > 0
                ? this.gwNodeList[0]
                : this.gwNode;
        this.gwNodeTTL = msg.gw_nodes_ttl
            ? new Date().getTime() + msg.gw_nodes_ttl * 1000
            : this.gwNodeTTL;
        this.stateCenter.clientIP = msg.clientip
            ? msg.clientip
            : this.stateCenter.clientIP;
        if (msg.result !== 0) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " " +
                this.streamId +
                " create session failed " +
                msg.result);
            this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kSessionRequestError);
        }
        else {
            this.sessionId = msg.session_id;
            this.sessionToken = msg.session_token;
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " " +
                this.streamId +
                " create session success " +
                this.sessionId);
            this.dataReport.addMsgInfo(this.reportSeq, {
                session_id: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.session_id(this.sessionId)
            });
            this.onCreatePublishSessionSuccess(msg);
        }
    };
    ZegoPublish.prototype.handleCreateSessionWithSdpResp = function (seq, sessionID, msg) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH + " sessionId:" + sessionID);
        if (this.sessionSeq != seq) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH + " seq is not match.");
            return;
        }
        this.gwNodeList =
            msg.gw_nodes && msg.gw_nodes.length > 0 ? msg.gw_nodes : this.gwNodeList;
        this.gwNode =
            msg.gw_nodes && msg.gw_nodes.length > 0
                ? this.gwNodeList[0]
                : this.gwNode;
        this.gwNodeTTL = msg.gw_nodes_ttl
            ? new Date().getTime() + msg.gw_nodes_ttl * 1000
            : this.gwNodeTTL;
        this.stateCenter.clientIP = msg.clientip
            ? msg.clientip
            : this.stateCenter.clientIP;
        this.dataReport.eventEndWithMsg(this.streamReportSeq, "CreateSessionWithSdp", {
            sessionId: sessionID
        });
        this.dataReport.eventEndWithMsg(this.reportSeq, "CreateSessionWithSdp", {
            sessionId: sessionID
        });
        if (msg.result !== 0) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " create session failed " +
                msg.result);
            this.publishStateUpdateError({
                code: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kSessionRequestError.code,
                message: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kSessionRequestError
                    .message +
                    " result:" +
                    msg.result
            });
        }
        else {
            this.sessionId = sessionID;
            this.sessionToken = msg.session_token;
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_PUBLISH +
                " get remote session success " +
                this.streamId);
            //register callback
            this.signal.registerPushCallback("CloseSessionPush", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvCloseSession(seq, sessionId, data);
            });
            // this.signal.registerPushCallback("WebSocketDisconnect", this.sessionId, onDisconnect, this);
            this.signal.registerPushCallback("SessionResetPush", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvResetSession(seq, sessionId, data);
            });
            this.signal.registerPushCallback("PublishEventPush", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvPublishEvent(seq, sessionId, data);
            });
            this.signal.registerPushCallback("ClientInfoPush", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvClientInfo(seq, sessionId, data);
            });
            this.signal.registerPushCallback("MediaDescUpdatePush", this.sessionId, function (seq, sessionId, data) {
                _this.onRecvUpdateMediaDescription(seq, sessionId, data);
            });
            this.onGetRemoteOfferSuccess(msg.sdp);
        }
    };
    ZegoPublish.prototype.onCreatePublishSessionSuccess = function (data) {
        var _this = this;
        //create offer
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
            " " +
            this.streamId +
            " called");
        // this.state = ENUM_PUBLISH_STATE.Start;
        var urls = [];
        if (data.turn_server) {
            var turnServer = data.turn_server;
            var _turnToTcp = this.stateCenter.turnOverTcpOnly;
            var udpOrTcp = this.stateCenter.settingConfig.getSetting("udp_or_tcp", true);
            if (udpOrTcp) {
                this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
                    " setting udp_or_tcp " +
                    udpOrTcp);
                _turnToTcp = udpOrTcp === "tcp";
            }
            _turnToTcp && (turnServer = turnServer.replace("udp", "tcp"));
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
                " over tcp " +
                turnServer);
            urls.push(turnServer);
        }
        if (data.stun_server)
            urls.push(data.stun_server);
        var configuration = {
            iceTransportPolicy: "relay",
            iceServers: [
                {
                    urls: urls,
                    username: data.turn_username,
                    credential: data.turn_auth_key
                }
            ]
        };
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
            " " +
            this.streamId +
            " username: " +
            data.turn_username);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
            " " +
            this.streamId +
            " credential: " +
            data.turn_auth_key);
        this.createOffer(configuration);
        //register callback
        this.signal.registerPushCallback("CandidateInfoPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvCandidateInfo(seq, sessionId, data);
        });
        this.signal.registerPushCallback("CloseSessionPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvCloseSession(seq, sessionId, data);
        });
        this.signal.registerPushCallback("MediaDescPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvMediaDescription(seq, sessionId, data);
        });
        // this.signal.registerPushCallback("WebSocketDisconnect", this.sessionId, onDisconnect, this);
        this.signal.registerPushCallback("SessionResetPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvResetSession(seq, sessionId, data);
        });
        this.signal.registerPushCallback("PublishEventPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvPublishEvent(seq, sessionId, data);
        });
        this.signal.registerPushCallback("ClientInfoPush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvClientInfo(seq, sessionId, data);
        });
        this.signal.registerPushCallback("MediaDescUpdatePush", this.sessionId, function (seq, sessionId, data) {
            _this.onRecvUpdateMediaDescription(seq, sessionId, data);
        });
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
            " " +
            this.streamId +
            " call success");
    };
    ZegoPublish.prototype.createOffer = function (configuration) {
        var _this = this;
        var _a, _b;
        this.peerConnection = new RTCPeerConnection(configuration);
        this.peerConnection.onicecandidate = function (e) {
            _this.onIceCandidate(e);
        };
        this.peerConnection.onsignalingstatechange = function (e) {
            _this.onConnectionStateChange(e);
        };
        this.peerConnection.oniceconnectionstatechange = function (e) {
            _this.onIceConnectionStateChange(e);
        };
        // datachannel
        if (this.streamCenter.isDataChannelEnabled) {
            this.dataChannel = this.peerConnection.createDataChannel(this.streamId);
            this.dataChannel.binaryType = "arraybuffer";
            this.dataChannel.onopen = function (event) {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
                    " " +
                    _this.streamId +
                    " data channel open");
                _this.dataChannelState = 1;
            };
            this.dataChannel.onclose = function (event) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
                    " " +
                    _this.streamId +
                    " data channel close ");
            };
        }
        var videoTracks = [];
        var audioTracks = [];
        if (this.localStream) {
            this.localStream.getTracks().forEach(function (track) {
                var _a;
                // if(track.kind === 'audio'){
                //         // @ts-ignore
                //         track.applyConstraints({noiseSuppression:{exact:true}})
                // }
                (_a = _this.peerConnection) === null || _a === void 0 ? void 0 : _a.addTrack(track, _this.localStream);
            });
            //  previewer  videoTrack
            ((_a = this.previewer) === null || _a === void 0 ? void 0 : _a.videoTrack) &&
                (videoTracks = [(_b = this.previewer) === null || _b === void 0 ? void 0 : _b.videoTrack]);
            audioTracks = this.localStream.getAudioTracks();
            if (videoTracks.length > 0)
                this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
                    " " +
                    this.streamId +
                    " video device: " +
                    videoTracks[0].label);
            if (audioTracks.length > 0)
                this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
                    " " +
                    this.streamId +
                    " audio device: " +
                    audioTracks[0].label);
        }
        var offerOptions = {
            // @ts-ignore
            offerToReceiveAudio: audioTracks.length > 0 ? 1 : 0,
            // @ts-ignore
            offerToReceiveVideo: videoTracks.length > 0 ? 1 : 0
        };
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
            " " +
            this.streamId +
            " createOffer: " +
            JSON.stringify(offerOptions));
        //create offer
        this.dataReport.eventStart(this.reportSeq, "CreateOffer");
        this.dataReport.eventStart(this.streamReportSeq, "CreateOffer");
        this.peerConnection.createOffer(offerOptions).then(function (desc) {
            _this.dataReport.eventEnd(_this.reportSeq, "CreateOffer");
            _this.dataReport.eventEnd(_this.streamReportSeq, "CreateOffer");
            _this.onCreateOfferSuccess(desc);
        }, function (error) {
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "CreateOffer", {
                error: error.toString()
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "CreateOffer", {
                error: error.toString()
            });
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_PUBLISH_SESSION_SUCCESS +
                " " +
                _this.streamId +
                " create offer error " +
                error.toString());
            _this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kCreateOfferError, true);
        });
    };
    ZegoPublish.prototype.onCreateOfferSuccess = function (desc, isUpdate, videoInfo, callBack) {
        var _this = this;
        var _a;
        if (isUpdate) {
            this.isUpdateSDP = true;
            callBack && (this.updateSDPCallBack = callBack);
        }
        //change bandwidth
        if (this.videoInfo.bitRate > 0)
            desc.sdp = this.updateBandwidthRestriction(desc.sdp, this.videoInfo.bitRate);
        desc.sdp = desc.sdp.replace(/sendrecv/g, "sendonly");
        var dataChannelSdp = desc.sdp.match(/m=application[\s\S]+datachannel[\s\S]+/)
            ? desc.sdp.match(/m=application[\s\S]+datachannel[\s\S]+/)[0]
            : null;
        if (dataChannelSdp) {
            var newDataChannelSdp = dataChannelSdp.replace(/sendonly/, "sendrecv");
            desc.sdp = desc.sdp.replace(dataChannelSdp, newDataChannelSdp);
        }
        desc.sdp = desc.sdp.replace(/useinbandfec=\d+/, (this.videoInfo.audioBitrate
            ? "maxaveragebitrate=" + this.videoInfo.audioBitrate
            : "") + (this.videoInfo.channelCount === 2 ? ";stereo=1" : ""));
        //  m-line 
        this.localSdpOrder = desc.sdp.match(/m=(.\w*)\s/g) || [];
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_OFFER_SUCCESS +
            " " +
            this.streamId +
            " local sdp revert " +
            this.localSdpOrder.join(""));
        // desc.sdp = sdpUtil.zegoSdp(desc.sdp);
        desc.sdp = sdpUtil_1.SdpUtil.getSDPByVideDecodeType(desc.sdp, this.videoCodec, true);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_OFFER_SUCCESS +
            " " +
            this.streamId +
            " localSdp1 " +
            desc.sdp.substr(0, desc.sdp.length / 2));
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_OFFER_SUCCESS +
            " " +
            this.streamId +
            " localSdp2 " +
            desc.sdp.substr(desc.sdp.length / 2));
        this.dataReport.eventStart(this.reportSeq, "SetLocalDescription");
        this.dataReport.eventStart(this.streamReportSeq, "SetLocalDescription");
        (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.setLocalDescription(desc).then(function () {
            _this.dataReport.eventEnd(_this.reportSeq, "SetLocalDescription");
            _this.dataReport.eventEnd(_this.streamReportSeq, "SetLocalDescription");
            _this.onSetLocalDescriptionSuccess(desc, videoInfo);
        }, function (error) {
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "SetLocalDescription", {
                error: error.toString()
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "SetLocalDescription", {
                error: error.toString()
            });
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CREATE_OFFER_SUCCESS +
                " " +
                _this.streamId +
                " error " +
                error.toString());
            _this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kSetLocalDescError, true);
        });
    };
    ZegoPublish.prototype.updateBandwidthRestriction = function (sdp, bandwidth) {
        var modifier = "AS";
        if (this.stateCenter.browser === "firefox") {
            bandwidth = (bandwidth >>> 0) * 1000;
            modifier = "TIAS";
        }
        if (sdp.indexOf("b=" + modifier + ":") === -1) {
            // insert b= after c= line.
            sdp = sdp.replace(/(m=video.*\r\nc=IN.*\r\n)/g, "$1b=" + modifier + ":" + bandwidth + "\r\n");
        }
        else {
            // TODO: createOffer  sdp  b=AS: sdp
            sdp = sdp.replace(new RegExp("b=" + modifier + ":.*\r\n", "g"), "b=" + modifier + ":" + bandwidth + "\r\n");
            sdp = sdp.replace("b=" + modifier + ":" + bandwidth + "\r\n", "");
        }
        return sdp;
    };
    ZegoPublish.prototype.onSetLocalDescriptionSuccess = function (desc, videoInfo) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
            " " +
            this.streamId +
            " success");
        !this.isUpdateSDP && (this.state = zego_entity_1.ENUM_PUBLISH_STATE.waitingOfferRsp);
        if (videoInfo)
            this.videoInfo = __assign(__assign({}, this.videoInfo), videoInfo);
        //send offer to other peer
        var mediaDescription = {
            sdp: desc.sdp,
            width: this.videoInfo.width,
            height: this.videoInfo.height,
            frameRate: this.videoInfo.frameRate,
            video_min_kpbs: this.videoInfo.bitRate,
            video_max_kpbs: this.videoInfo.bitRate,
            audio_kpbs: 48,
            keyframe_intv: 2
        };
        this.offerSeq = zego_entity_1.getSeq();
        // sdp
        if (this.isUpdateSDP) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
                " " +
                this.streamId +
                " update sdp");
            var updateMediaDescription = __assign(__assign({}, mediaDescription), { seq: this.sessionSeq, peerID: this.peerID, type: 0 });
            this.dataReport.eventStart(this.reportSeq, "SendMediaDescUpdate");
            this.dataReport.eventStart(this.streamReportSeq, "SendMediaDescUpdate");
            this.signal.sendMediaDescUpdateReq(this.offerSeq, this.sessionId, updateMediaDescription, function (seq, sessionID, msg) { }, function (err, seq) {
                _this.dataReport.eventEndWithMsg(_this.reportSeq, "SendMediaDescUpdate", {
                    error: err
                });
                _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "SendMediaDescUpdate", {
                    error: err
                });
                _this.updateSDPCallBack && _this.updateSDPCallBack(-1);
                _this.publishStateUpdateError(err == zego_entity_1.SEND_MSG_TIMEOUT
                    ? zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error
                        .kUpdateMediaDescriptionTimeOut
                    : zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error
                        .kUpdateMediaDescriptionError);
            });
            return;
        }
        if (this.isPeer) {
            this.createSession(desc);
            return;
        }
        this.dataReport.eventStart(this.reportSeq, "SendMediaDesc");
        this.dataReport.eventStart(this.streamReportSeq, "SendMediaDesc");
        this.signal.sendMediaDesc(this.offerSeq, this.sessionId, 0, mediaDescription, function (seq, sessionId, data) {
            if (_this.offerSeq != seq || _this.sessionId != sessionId) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
                    " " +
                    _this.streamId +
                    " seq or sessionId is not equal");
                return;
            }
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
                " " +
                _this.streamId +
                " send success");
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "SendMediaDesc", {
                mediaDescription: {
                    width: mediaDescription.width,
                    height: mediaDescription.height,
                    frameRate: mediaDescription.frameRate,
                    video_min_kpbs: mediaDescription.video_min_kpbs,
                    video_max_kpbs: mediaDescription.video_max_kpbs,
                    audio_kpbs: mediaDescription.audio_kpbs,
                    keyframe_intv: mediaDescription.keyframe_intv
                }
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "SendMediaDesc", {
                mediaDescription: {
                    width: mediaDescription.width,
                    height: mediaDescription.height,
                    frameRate: mediaDescription.frameRate,
                    video_min_kpbs: mediaDescription.video_min_kpbs,
                    video_max_kpbs: mediaDescription.video_max_kpbs,
                    audio_kpbs: mediaDescription.audio_kpbs,
                    keyframe_intv: mediaDescription.keyframe_intv
                }
            });
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
                " " +
                _this.streamId +
                " send success stateNego:waiterAnswer");
            _this.stateNego = zego_entity_1.ENUM_PUBLISH_STATE_NEGO.waiterAnswer;
            _this.state = zego_entity_1.ENUM_PUBLISH_STATE.waitingServerAnswer;
        }, function (err, seq) {
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "SendMediaDesc", {
                error: err
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "SendMediaDesc", {
                error: err
            });
            _this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kMediaDescError);
        });
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_SET_LOCAL_DESCRIPTION_SUCCESS +
            " " +
            this.streamId +
            " call success");
    };
    ZegoPublish.prototype.onRecvUpdateMediaDescription = function (seq, sessionId, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_UPDATE_MEDIA_DESC +
            " " +
            this.streamId +
            " received");
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_UPDATE_MEDIA_DESC +
            " " +
            this.streamId +
            " received stateNego:waitingCandidate");
        this.dataReport.addEvent(this.reportSeq, "RecvUpdateMediaDesc");
        this.dataReport.addEvent(this.streamReportSeq, "RecvUpdateMediaDesc");
        this.signal.sendUpdateMediaDescAck(seq, this.sessionId, 0, this.peerID);
        //not answer
        if (data.type == 1) {
            this.onGetRemoteOfferSuccess(data.sdp);
        }
        else {
            //server send error
            this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kMediaDescError);
        }
    };
    ZegoPublish.prototype.onRecvMediaDescription = function (seq, sessionId, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_MEDIA_DESC +
            " " +
            this.streamId +
            " received");
        if (this.state != zego_entity_1.ENUM_PUBLISH_STATE.waitingServerAnswer) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_MEDIA_DESC +
                " " +
                this.streamId +
                " current state " +
                this.state +
                " not allowed");
            return;
        }
        this.stateNego = zego_entity_1.ENUM_PUBLISH_STATE_NEGO.waitingCandidate;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_MEDIA_DESC +
            " " +
            this.streamId +
            " received stateNego:waitingCandidate");
        this.dataReport.addEvent(this.reportSeq, "RecvMediaDesc");
        this.dataReport.addEvent(this.streamReportSeq, "RecvMediaDesc");
        this.signal.sendMediaDescAck(seq, this.sessionId, 0);
        //not answer
        if (data.type == 1) {
            this.onGetRemoteOfferSuccess(data.sdp);
        }
        else {
            //server send error
            this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kMediaDescError);
        }
    };
    ZegoPublish.prototype.onGetRemoteOfferSuccess = function (desc) {
        var _this = this;
        var _a, _b, _c, _d, _e, _f;
        if (this.videoInfo.audioBitrate && this.videoInfo.audioBitrate !== 48000) {
            desc = desc.replace(/maxaveragebitrate=(\d+)/, "maxaveragebitrate=" + this.videoInfo.audioBitrate);
        }
        //  m---
        this.remoteSdpOrder = desc.match(/m=(.\w*)\s/g) || [];
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_GET_REMOTE_DESCRIPTION +
            " " +
            this.streamId +
            +" sdp revert " +
            this.remoteSdpOrder.join(""));
        var _turnToTcp = this.stateCenter.turnOverTcpOnly;
        var udpOrTcp = this.stateCenter.settingConfig.getSetting("udp_or_tcp", true);
        if (udpOrTcp) {
            this.logger.info("zp.oro.0 setting udp_or_tcp " + udpOrTcp);
            _turnToTcp = udpOrTcp === "tcp";
        }
        if (_turnToTcp) {
            (_a = desc.match(/candidate.*/g)) === null || _a === void 0 ? void 0 : _a.forEach(function (candStr) {
                var repCandStr = candStr.replace(/udp/, "tcp");
                desc = desc.replace(candStr, repCandStr);
            });
        }
        this.logger.info("zp.oro.0 " +
            this.streamId +
            " sdp revert " +
            this.localSdpOrder.join("") +
            " " +
            this.remoteSdpOrder.join(""));
        if (this.localSdpOrder.join() !== this.remoteSdpOrder.join() &&
            this.localSdpOrder.length == this.remoteSdpOrder.length) {
            var headerSdp = new RegExp("[\\s\\S]*" + this.remoteSdpOrder[0])
                .exec(desc)[0]
                .replace(this.remoteSdpOrder[0], "");
            var midOrder_1 = [];
            var sdp_1 = "";
            this.localSdpOrder.forEach(function (m) {
                var _index = _this.remoteSdpOrder.findIndex(function (_m) { return _m == m; });
                var mSdp = new RegExp(m + "[\\s\\S]*" + (_this.remoteSdpOrder[_index + 1] || ""))
                    .exec(desc)[0]
                    .replace(_this.remoteSdpOrder[_index + 1], "");
                var mid = /a=mid:(\w)/.exec(mSdp)[1];
                midOrder_1.push(mid);
                sdp_1 = sdp_1 + (mSdp || "");
            });
            desc =
                headerSdp.replace(/a=group:BUNDLE.*/, "a=group:BUNDLE " + midOrder_1.join(" ")) + sdp_1;
            this.localSdpOrder = [];
            this.remoteSdpOrder = [];
        }
        var video_fmtp = desc.match(/m=video(.|\r|\n)*a=rtpmap(.|\r|\n)*(a=fmtp:(\d+).*)/);
        // 
        if (this.stateCenter.browser == "chrome") {
            var startBitrate = 0;
            if (this.videoInfo.bitRate && this.videoInfo.startBitrate === "target") {
                startBitrate = this.videoInfo.bitRate;
            }
            if (video_fmtp !== null && startBitrate) {
                var fmtp = video_fmtp[3];
                if (fmtp.indexOf("apt=") !== -1) {
                    desc = desc.replace(fmtp, "a=fmtp:96 x-google-start-bitrate=" + startBitrate + "\n" + fmtp);
                }
                else {
                    desc = desc.replace(fmtp, fmtp + ";x-google-start-bitrate=" + startBitrate);
                }
            }
        }
        // 
        if (this.videoInfo.bitRate > 0) {
            // peerASSDKAS
            var hasAS = /b=AS.*(\r\n|\n)/.test(desc);
            if (hasAS) {
                desc = desc.replace(/AS:(\d+)/, "AS:" + this.videoInfo.bitRate);
            }
            else {
                desc = desc.replace(/m=video.*(\r\n|\n)c=.*(\r\n|\n)/, "$&b=AS:" + this.videoInfo.bitRate + "\n");
            }
            var videoSender = (_b = this.peerConnection) === null || _b === void 0 ? void 0 : _b.getSenders().find(function (s) { return s.track && s.track.kind === "video"; });
            if (videoSender &&
                videoSender.getParameters &&
                videoSender.setParameters) {
                var parameters = videoSender.getParameters();
                if (!parameters.encodings || parameters.encodings.length == 0) {
                    parameters.encodings = [{}];
                }
                // 
                parameters.encodings[0].maxBitrate = this.videoInfo.bitRate * 1e3;
                // 
                //   googBandwidthLimitedResolution  true
                var encodeWidth = this.lastPublishStats.frameWidth;
                var maxWidth = ((_d = (_c = this.previewer) === null || _c === void 0 ? void 0 : _c.cameraMaxResolution) === null || _d === void 0 ? void 0 : _d.maxWidth) || 0;
                var targetWidth = (_e = this.previewer) === null || _e === void 0 ? void 0 : _e.videoInfo.width;
                var realMaxEncodeWidth = encodeWidth
                    ? Math.min(maxWidth, encodeWidth)
                    : maxWidth;
                if (maxWidth && targetWidth) {
                    //  < 11
                    var downBy = Math.max(realMaxEncodeWidth / targetWidth, 1);
                    // :   / 
                    parameters.encodings[0].scaleResolutionDownBy = downBy;
                }
                videoSender.setParameters(parameters);
            }
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_GET_REMOTE_DESCRIPTION +
            " " +
            this.streamId +
            " remoteSdp:", desc);
        var answerDescription = {
            type: "answer",
            sdp: desc,
            toJSON: function () { }
        };
        this.dataReport.eventStart(this.reportSeq, "SetRemoteDescription");
        this.dataReport.eventStart(this.streamReportSeq, "SetRemoteDescription");
        (_f = this.peerConnection) === null || _f === void 0 ? void 0 : _f.setRemoteDescription(new RTCSessionDescription(answerDescription)).then(function () {
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_GET_REMOTE_DESCRIPTION +
                " " +
                _this.streamId +
                " set success");
            _this.dataReport.eventEnd(_this.reportSeq, "SetRemoteDescription");
            _this.dataReport.eventEnd(_this.streamReportSeq, "SetRemoteDescription");
            if (_this.stateNego == zego_entity_1.ENUM_PUBLISH_STATE_NEGO.iceConnected &&
                _this.updateSDPCallBack) {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_GET_REMOTE_DESCRIPTION +
                    " " +
                    _this.streamId +
                    " update sdp success");
                _this.updateSDPCallBack(0);
                _this.updateSDPCallBack = undefined;
                _this.isUpdateSDP = false;
            }
        }, function (error) {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_GET_REMOTE_DESCRIPTION +
                " " +
                _this.streamId +
                " failed: " +
                error.toString());
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "SetRemoteDescription", {
                error: error.toString()
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "SetRemoteDescription", {
                error: error.toString()
            });
            _this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kSetRemoteDescError, true);
        });
        this.state = zego_entity_1.ENUM_PUBLISH_STATE.waitingServerICE;
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_GET_REMOTE_DESCRIPTION +
            " " +
            this.streamId +
            " call success");
    };
    ZegoPublish.prototype.onIceConnectionStateChange = function (event) {
        var _this = this;
        if (this.state == zego_entity_1.ENUM_PUBLISH_STATE.stop || this.peerConnection == null) {
            return;
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_ICE_CONNECTION_STATE_CHANGE +
            " " +
            this.streamId +
            " stateChanged " +
            this.peerConnection.iceConnectionState);
        if (this.peerConnection.iceConnectionState === "connected") {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_ICE_CONNECTION_STATE_CHANGE +
                " " +
                this.streamId +
                " connected state " +
                this.state);
            this.dataReport.eventEnd(this.reportSeq, "IceConnected");
            this.dataReport.eventEnd(this.streamReportSeq, "IceConnected");
            this.stateNego = zego_entity_1.ENUM_PUBLISH_STATE_NEGO.iceConnected;
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_ICE_CONNECTION_STATE_CHANGE +
                " " +
                this.streamId +
                " stateNego:iceConnected");
            if (this.negoTimer) {
                clearTimeout(this.negoTimer);
                this.negoTimer = null;
            }
            if (this.iceDisconnectedTimer != null) {
                clearTimeout(this.iceDisconnectedTimer);
                this.iceDisconnectedTimer = null;
            }
            if (this.publishEvent) {
                this.publishSuccess();
            }
            else {
                this.firstGetStatsTimer && clearTimeout(this.firstGetStatsTimer);
                this.firstGetStatsTimer = null;
                this.firstGetStatsTimer = setTimeout(function () {
                    var _a;
                    _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_ICE_CONNECTION_STATE_CHANGE +
                        " get first stats state " +
                        _this.state);
                    if (_this.state !== zego_entity_1.ENUM_PUBLISH_STATE.publishing) {
                        (_a = _this.peerConnection) === null || _a === void 0 ? void 0 : _a.getStats().then(function (results) {
                            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_ICE_CONNECTION_STATE_CHANGE +
                                " get first stats suc");
                            if (results.size > 0)
                                _this.publishSuccess();
                        });
                    }
                }, 1000);
            }
        }
        else if (this.peerConnection.iceConnectionState === "closed") {
            this.dataReport.addEvent(this.reportSeq, "IceClosed");
            this.stateNego = zego_entity_1.ENUM_PUBLISH_STATE_NEGO.iceClosed;
            this.checkPublishConnectionFailedState(this.peerConnection.iceConnectionState);
        }
        else if (this.peerConnection.iceConnectionState === "failed") {
            this.dataReport.addEvent(this.reportSeq, "IceFailed");
            this.stateNego = zego_entity_1.ENUM_PUBLISH_STATE_NEGO.iceFailed;
            this.checkPublishConnectionFailedState(this.peerConnection.iceConnectionState);
        }
        else if (this.peerConnection.iceConnectionState === "disconnected") {
            this.dataReport.addEvent(this.reportSeq, "IceDisconnected");
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_ICE_CONNECTION_STATE_CHANGE +
                " ice disconnected ");
            this.stateNego = zego_entity_1.ENUM_PUBLISH_STATE_NEGO.iceDisconnected;
            if (!this.iceDisconnectedTimer) {
                this.iceDisconnectedTimer = setTimeout(function () {
                    _this.checkPublishConnectionFailedState("disconnected");
                }, this.iceDisconnectedMaxTime);
            }
        }
    };
    ZegoPublish.prototype.onIceCandidate = function (event) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_ICE_CANDIDATE +
            " " +
            this.streamId +
            " candidate" +
            event.candidate);
        if (!event.candidate) {
            return;
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_ICE_CANDIDATE +
            " " +
            this.streamId +
            " candidate" +
            event.candidate.candidate);
        if (this.state < zego_entity_1.ENUM_PUBLISH_STATE.connecting ||
            this.state == zego_entity_1.ENUM_PUBLISH_STATE.stop) {
            //save candidate Info
            this.candidateInfo.push({
                candidate: event.candidate.candidate,
                sdpMid: event.candidate.sdpMid,
                sdpMLineIndex: event.candidate.sdpMLineIndex
            });
        }
        else {
            var candidate = {
                candidate: event.candidate.candidate,
                sdpMid: event.candidate.sdpMid,
                sdpMLineIndex: event.candidate.sdpMLineIndex
            };
            this.sendCandidateInfo([candidate]);
        }
    };
    ZegoPublish.prototype.sendCandidateInfo = function (candidateInfo) {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SEND_CANDIDATE_INFO +
            " " +
            this.streamId +
            " called");
        candidateInfo = candidateInfo.filter(function (item) {
            if (item.candidate.indexOf("relay") > 0) {
                return true;
            }
            return false;
        });
        if (!candidateInfo || candidateInfo.length < 1) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SEND_CANDIDATE_INFO +
                " " +
                this.streamId +
                " cancelled");
            return;
        }
        this.dataReport.eventStart(this.reportSeq, "SendIceCandidate");
        this.dataReport.eventStart(this.streamReportSeq, "SendIceCandidate");
        if (this.stateNego !== zego_entity_1.ENUM_PUBLISH_STATE_NEGO.iceConnected)
            this.stateNego = zego_entity_1.ENUM_PUBLISH_STATE_NEGO.sendCandidate;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SEND_CANDIDATE_INFO +
            " " +
            this.streamId +
            " stateNego:sendCandidate");
        this.signal.sendCandidateInfo(zego_entity_1.getSeq(), this.sessionId, candidateInfo, function (seq, sessionId, data) {
            _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SEND_CANDIDATE_INFO +
                " " +
                _this.streamId +
                " send success");
            _this.dataReport.eventEnd(_this.reportSeq, "SendIceCandidate");
            _this.dataReport.eventEnd(_this.streamReportSeq, "SendIceCandidate");
        }, function (err, seq) {
            _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SEND_CANDIDATE_INFO +
                " " +
                _this.streamId +
                " failed to send: " +
                err.toString());
            _this.dataReport.eventEndWithMsg(_this.reportSeq, "SendIceCandidate", {
                error: err
            });
            _this.dataReport.eventEndWithMsg(_this.streamReportSeq, "SendIceCandidate", {
                error: err
            });
            _this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kCandidateError);
        });
    };
    ZegoPublish.prototype.onConnectionStateChange = function (event) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_CONNECTION_STATE_CHANGE +
            " " +
            this.streamId +
            " called " +
            event.target.signalingState);
    };
    ZegoPublish.prototype.onRecvCandidateInfo = function (seq, sessionId, data) {
        var _this = this;
        var _a;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_CANDIDATE_INFO +
            " " +
            this.streamId +
            " received " +
            JSON.stringify(data.infos));
        if (this.state != zego_entity_1.ENUM_PUBLISH_STATE.waitingServerICE) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_CANDIDATE_INFO +
                " " +
                this.streamId +
                " current state " +
                this.state +
                " not allowed");
            return;
        }
        this.dataReport.addEvent(this.reportSeq, "RecvIceCandidate");
        this.dataReport.addEvent(this.streamReportSeq, "RecvIceCandidate");
        this.signal.sendCandidateInfoAck(seq, this.sessionId, 0);
        this.sendCandidateInfo(this.candidateInfo);
        this.candidateInfo = [];
        for (var i = 0; i < data.infos.length; i++) {
            var ice = {
                sdpMid: data.infos[i].sdpMid,
                sdpMLineIndex: data.infos[i].sdpMLineIndex,
                candidate: data.infos[i].candidate
            };
            this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_CANDIDATE_INFO +
                "" +
                this.streamId +
                " candidate " +
                ice.candidate);
            (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.addIceCandidate(new RTCIceCandidate(ice)).then(function () {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_CANDIDATE_INFO +
                    " " +
                    _this.streamId +
                    " add success");
            }, function (error) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_CANDIDATE_INFO +
                    " " +
                    _this.streamId +
                    " add error " +
                    error.toString());
                _this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kCandidateError, true);
            });
        }
        this.state = zego_entity_1.ENUM_PUBLISH_STATE.connecting;
        this.dataReport.eventStart(this.reportSeq, "IceConnected");
        this.dataReport.eventStart(this.streamReportSeq, "IceConnected");
    };
    ZegoPublish.prototype.onRecvCloseSession = function (seq, sessionId, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_CLOSE_SESSION +
            "" +
            this.streamId +
            " " +
            JSON.stringify(data));
        this.dataReport.addEvent(this.reportSeq, "RecvCloseSession");
        this.signal.sendCloseSessionAck(seq, this.sessionId, 0);
        var err_info = data.err_info
            ? JSON.parse(data.err_info.toLowerCase())
            : {};
        var action = err_info.action ? err_info.action : null;
        var reason = data.reason * 1;
        var error = JSON.parse(JSON.stringify(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishSessionClosedError));
        error.message += " reason:" + reason + " " + (action ? " action:" + action : "");
        // 
        if (err_info.err === 1011) {
            error =
                zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kMediaServerForbidError;
        }
        //  token 
        if (err_info.err === 1014) {
            error =
                zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishTokenExpiredError;
        }
        this.negoTimer && clearTimeout(this.negoTimer);
        var stopRetry = [4, 8, 10, 11, 12, 14, 26, 27].includes(reason) ||
            [2, 5, 6].includes(action)
            ? false
            : true;
        this.publishStateUpdateError(error, stopRetry);
    };
    ZegoPublish.prototype.onRecvResetSession = function (seq, sessionId, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_RESET_SESSION +
            " " +
            this.streamId +
            " received ");
        if (sessionId != this.sessionId) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_RESET_SESSION +
                " " +
                this.streamId +
                " cannot find session");
            return;
        }
        this.signal.sendCloseSessionAck(seq, this.sessionId, 0);
        var error = zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kPublishSessionClosedError;
        // error.msg += data.reason;
        this.negoTimer && clearTimeout(this.negoTimer);
        this.publishStateUpdateError(error);
    };
    ZegoPublish.prototype.onRecvPublishEvent = function (seq, sessionId, data) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_PUBLISH_EVENT +
            " " +
            this.streamId +
            " received");
        this.publishEvent = true;
        if (this.firstGetStatsTimer) {
            clearTimeout(this.firstGetStatsTimer);
            this.firstGetStatsTimer = null;
        }
        this.stateNego === zego_entity_1.ENUM_PUBLISH_STATE_NEGO.iceConnected &&
            data.event == 0 &&
            this.publishSuccess();
    };
    ZegoPublish.prototype.onRecvClientInfo = function (seq, sessionId, data) {
        //ip
        if (this.stateCenter.clientIP !== data.clientip) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_RECV_CLIENT_INFO +
                " " +
                "client ip changed " +
                this.stateCenter.clientIP +
                " " +
                data.clientip);
            // const error = ZegoRTCLogEvent.kZegoTaskPublishStart.error.kClientIPChangedError;
            // this.gwNode = "";
            // this.gwNodeList = [];
            // this.gwNodeTTL = 0;
            // this.publishStateUpdateError (error);
        }
        this.stateCenter.clientIP = data.clientip;
        this.peerID = data.peer_id;
        // activeteSEIConfigSEI
        var previewer = this.previewer;
        if (previewer && previewer.activateSEIConfig !== null) {
            var _a = previewer === null || previewer === void 0 ? void 0 : previewer.activateSEIConfig, action = _a.action, infoType = _a.infoType;
            this.activateSEIInsert(action, infoType);
        }
    };
    ZegoPublish.prototype.checkPublishConnectionFailedState = function (connectionState) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_ICE_CONNECTION_STATE_CHANGE +
            " streamID " +
            this.streamId, " state " + this.state + " connectionState " + connectionState);
        this.publishStateUpdateError(zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kMediaConnectionError);
    };
    ZegoPublish.prototype.setPublishQualityTimer = function () {
        var _this = this;
        if (this.qualityTimer != null) {
            return;
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SET_PLAYER_QUALITY_TIMER +
            " " +
            this.streamId +
            " called");
        this.clearPublishQualityTimer();
        this.qualityTimer = setInterval(function () {
            _this.peerConnectionGetStats();
        }, this.qualityTimeInterval);
        this.lastPublishStats = {
            audioPacketsLost: 0,
            videoPacketsLost: 0,
            videoPacketsSent: 0,
            audioPacketsSent: 0,
            audioRetransmittedPacketsSent: 0,
            videoTime: new Date().getTime(),
            audioTime: new Date().getTime(),
            time: 0,
            audioBytesSent: 0,
            videoBytesSent: 0,
            framesEncoded: 0,
            framesSent: 0,
            videoRetransmittedPacketsSent: 0
        };
        this.qualitySeq = zego_entity_1.getSeq();
        this.qualityCount = 0;
    };
    ZegoPublish.prototype.peerConnectionGetStats = function (callback) {
        var _this = this;
        if (this.peerConnection) {
            var promiseList = [this.peerConnection.getStats(null)];
            if (this.stateCenter.browser == "chrome") {
                promiseList.push(new Promise(function (resolve, reject) {
                    var _a;
                    (_a = _this.peerConnection) === null || _a === void 0 ? void 0 : _a.getStats(function (results) { return resolve(results); }, 
                    // @ts-ignore
                    function (err) { return reject(err); });
                }));
            }
            Promise.all(promiseList)
                .then(function (values) {
                var stats = _this.getPublishStats(values[0], values[1]);
                callback && callback(stats, values[0], values[1]);
            })
                .catch(function (error) {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_SET_PLAYER_QUALITY_TIMER +
                    " " +
                    _this.streamId +
                    " getStats error " +
                    error.toString());
            });
        }
    };
    ZegoPublish.prototype.getPublishStats = function (results, callbackResults) {
        var _this = this;
        var _a;
        if (!results) {
            return;
        }
        var medias = document.querySelectorAll("video, audio");
        var streamMedia;
        for (var i = 0; i < medias.length; i++) {
            if (medias[i].srcObject === this.localStream) {
                streamMedia = medias[i];
            }
        }
        var previewer = this.streamCenter.checkPreview(this.localStream);
        var publishData = {
            audioCodec: "opus",
            audioTargetBitrate: this.videoInfo.audioBitrate / 1000 || 0,
            audioBitrate: 0,
            videoTargetBitrate: this.videoInfo.bitRate || 0,
            videoTargetFPS: this.videoInfo.frameRate || 0,
            videoBitrate: 0,
            audioFPS: 0,
            audioLevel: 0,
            audioInputLevel: 0,
            audioPacketsLost: 0,
            audioPacketsLostRate: 0,
            sendLevel: 0,
            samplingRate: 0,
            videoFPS: 0,
            nackCount: 0,
            pliCount: 0,
            //sliCount: 0,
            audioQuality: 0,
            videoQuality: 0,
            frameHeight: 0,
            frameWidth: 0,
            videoTransferFPS: 0,
            videoPacketsLost: 0,
            videoPacketsLostRate: 0,
            totalRoundTripTime: 0,
            currentRoundTripTime: 0,
            googBandwidthLimitedResolution: undefined,
            videoCodecName: "",
            audioCodecName: "",
            googCpuLimitedResolution: undefined,
            googAvailableSendBandwidth: 0,
            googActualEncBitrate: 0,
            googTargetEncBitrate: 0,
            googFrameWidthInput: 0,
            googFrameHeightInput: 0,
            googFrameRateInput: 0,
            codecImplementationName: "",
            videoMuteState: ((_a = previewer === null || previewer === void 0 ? void 0 : previewer.videoTrack) === null || _a === void 0 ? void 0 : _a.enabled) ? "0" : "1",
            audioMuteState: this.localStream.getAudioTracks().length > 0
                ? this.localStream.getAudioTracks()[0].enabled
                    ? "0"
                    : "1"
                : "1",
            muted: streamMedia ? streamMedia.muted : undefined,
            paused: streamMedia ? streamMedia.paused : undefined,
            volume: streamMedia ? streamMedia.volume : undefined,
            sinkId: streamMedia ? streamMedia.sinkId : undefined
        };
        var time = this.lastPublishStats.time;
        var aRTT = 0;
        var vRTT = 0;
        var aLostRate = 0;
        var vLostRate = 0;
        var aJitter = 0;
        var vJitter = 0;
        results.forEach(function (result) {
            if ((result.type == "outbound-rtp" ||
                (result.type == "ssrc" && result.bytesSent != undefined)) &&
                result.mediaType == "audio") {
                //audio
                if (time != 0) {
                    publishData.audioBitrate =
                        (8 * (result.bytesSent - _this.lastPublishStats.audioBytesSent)) /
                            (result.timestamp - time);
                    publishData.audioFPS =
                        ((result.packetsSent -
                            (result.retransmittedPacketsSent -
                                _this.lastPublishStats.audioRetransmittedPacketsSent) -
                            _this.lastPublishStats.audioPacketsSent) /
                            (result.timestamp - time)) *
                            1000;
                    aLostRate =
                        (result.retransmittedPacketsSent -
                            _this.lastPublishStats.audioRetransmittedPacketsSent) /
                            (result.packetsSent - _this.lastPublishStats.audioPacketsSent);
                }
                if (publishData.audioBitrate < 0) {
                    publishData.audioBitrate = 0;
                }
                _this.lastPublishStats.audioBytesSent = result.bytesSent;
                _this.lastPublishStats.time = result.timestamp;
                _this.lastPublishStats.audioPacketsSentTimeStamp =
                    result.packetsSent - _this.lastPublishStats.audioPacketsSent;
                _this.lastPublishStats.audioPacketsSent = result.packetsSent;
                _this.lastPublishStats.audioRetransmittedPacketsSent =
                    result.retransmittedPacketsSent;
            }
            else if ((result.type == "outbound-rtp" ||
                (result.type == "ssrc" && result.bytesSent != undefined)) &&
                result.mediaType == "video") {
                //video
                if (time != 0) {
                    publishData.videoBitrate =
                        (8 * (result.bytesSent - _this.lastPublishStats.videoBytesSent)) /
                            (result.timestamp - time);
                    publishData.videoFPS =
                        (1000 *
                            (result.framesEncoded - _this.lastPublishStats.framesEncoded)) /
                            (result.timestamp - time);
                    vLostRate =
                        (result.retransmittedPacketsSent -
                            _this.lastPublishStats.videoRetransmittedPacketsSent) /
                            (result.packetsSent - _this.lastPublishStats.videoPacketsSent);
                }
                if (publishData.videoBitrate < 0) {
                    publishData.videoBitrate = 0;
                }
                if (publishData.videoFPS < 0) {
                    publishData.videoFPS = 0;
                }
                publishData.nackCount = result.nackCount;
                publishData.pliCount = result.pliCount;
                //publishData.sliCount = result.sliCount;
                _this.lastPublishStats.videoBytesSent = result.bytesSent;
                _this.lastPublishStats.framesEncoded = result.framesEncoded;
                _this.lastPublishStats.time = result.timestamp;
                _this.lastPublishStats.videoPacketsSentTimeStamp =
                    result.packetsSent - _this.lastPublishStats.videoPacketsSent;
                _this.lastPublishStats.videoPacketsSent = result.packetsSent;
                _this.lastPublishStats.videoRetransmittedPacketsSent =
                    result.retransmittedPacketsSent;
            }
            else if (result.type == "remote-inbound-rtp" &&
                result.kind == "video") {
                result.packetsLost > 0 &&
                    (publishData.videoPacketsLost = result.packetsLost);
                var videoLostDiff = result.packetsLost - _this.lastPublishStats.videoPacketsLost;
                if (videoLostDiff > 0) {
                    publishData.videoPacketsLostRate =
                        videoLostDiff / _this.lastPublishStats.videoPacketsSentTimeStamp;
                }
                else {
                    publishData.videoPacketsLostRate = 0;
                }
                result.packetsLost > 0 &&
                    (_this.lastPublishStats.videoPacketsLost = result.packetsLost);
                _this.lastPublishStats.videoTime = result.timestamp;
                vRTT = result.roundTripTime * 1000;
                vJitter = result.jitter;
            }
            else if (result.type == "remote-inbound-rtp" &&
                result.kind == "audio") {
                result.packetsLost > 0 &&
                    (publishData.audioPacketsLost = result.packetsLost);
                var audioLostDiff = result.packetsLost - _this.lastPublishStats.audioPacketsLost;
                if (audioLostDiff > 0) {
                    publishData.audioPacketsLostRate =
                        audioLostDiff / _this.lastPublishStats.audioPacketsSentTimeStamp;
                }
                else {
                    publishData.audioPacketsLostRate = 0;
                }
                result.packetsLost > 0 &&
                    (_this.lastPublishStats.audioPacketsLost = result.packetsLost);
                _this.lastPublishStats.audioTime = result.timestamp;
                aRTT = result.roundTripTime * 1000;
                aJitter = result.jitter;
            }
            //safari don't have this type
            else if (result.type == "media-source" &&
                (result.kind == "audio" ||
                    result.id.toLowerCase().indexOf("audio") >= 0)) {
                publishData.audioLevel = result.audioLevel;
                publishData.sendLevel = result.totalAudioEnergy;
                publishData.audioInputLevel = 32767 * result.totalAudioEnergy;
                publishData.samplingRate = result.totalSamplesDuration;
            }
            else if (result.type == "track" &&
                (result.kind == "video" ||
                    result.id.indexOf("video") >= 0 ||
                    result.frameWidth)) {
                publishData.frameHeight = result.frameHeight;
                publishData.frameWidth = result.frameWidth;
                // 
                if (time !== 0 &&
                    (_this.lastPublishStats.frameHeight !== result.frameHeight ||
                        _this.lastPublishStats.frameWidth !== result.frameWidth)) {
                    var reportSizeSeq = zego_entity_1.getReportSeq();
                    _this.dataReport.newReport(reportSizeSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskVideoCaptureSize.event);
                    _this.dataReport.addMsgInfo(reportSizeSeq, {
                        session_id: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskVideoCaptureSize.session_id(_this.sessionId),
                        w: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskVideoCaptureSize.w(result.frameWidth),
                        h: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskVideoCaptureSize.h(result.frameHeight)
                    });
                    _this.dataReport.uploadReport(reportSizeSeq);
                    _this.lastPublishStats.frameHeight = result.frameHeight;
                    _this.lastPublishStats.frameWidth = result.frameWidth;
                }
                else if (time === 0) {
                    _this.lastPublishStats.frameHeight = result.frameHeight;
                    _this.lastPublishStats.frameWidth = result.frameWidth;
                }
                if (time != 0) {
                    publishData.videoTransferFPS =
                        (1000 * (result.framesSent - _this.lastPublishStats.framesSent)) /
                            (result.timestamp - time);
                }
                if (publishData.videoTransferFPS < 0) {
                    publishData.videoTransferFPS = 0;
                }
                _this.lastPublishStats.framesSent = result.framesSent;
            }
            else if (result.type == "candidate-pair") {
                if (result.totalRoundTripTime != undefined) {
                    publishData.totalRoundTripTime = result.totalRoundTripTime;
                }
                if (result.currentRoundTripTime != undefined) {
                    publishData.currentRoundTripTime = result.currentRoundTripTime;
                }
            }
        });
        callbackResults &&
            callbackResults.result().forEach(function (result) {
                // if (result.type == 'ssrc' && result.id.indexOf('send') >=0 && result.stat('mediaType') == 'video' && result.names().indexOf('packetsLost') >= 0) {
                //     const packetsLost = parseInt(result.stat('packetsLost'));
                //     publishData.videoPacketsLost = packetsLost;
                //     const timediff = result.timestamp.getTime() - this.lastPublishStats.videoTime;
                //     publishData.videoPacketsLostRate = (packetsLost - this.lastPublishStats.videoPacketsLost) /
                //         timediff;
                //     this.lastPublishStats.videoTime = result.timestamp.getTime();
                //     this.lastPublishStats.videoPacketsLost = packetsLost;
                // }
                // if (result.type == 'ssrc' && result.id.indexOf('send') >=0 && result.stat('mediaType') == 'audio' && result.names().indexOf('packetsLost') >= 0) {
                //     const packetsLost = parseInt(result.stat('packetsLost'));
                //     publishData.audioPacketsLost = packetsLost;
                //     publishData.audioPacketsLostRate = (packetsLost - this.lastPublishStats.audioPacketsLost) /
                //         (result.timestamp.getTime() - this.lastPublishStats.audioTime);
                //     this.lastPublishStats.audioTime = result.timestamp.getTime();
                //     this.lastPublishStats.audioPacketsLost = packetsLost;
                // }
                if (result.type == "ssrc" &&
                    result.names().indexOf("googBandwidthLimitedResolution") >= 0) {
                    publishData.googBandwidthLimitedResolution = result.stat("googBandwidthLimitedResolution");
                }
                if (result.type == "ssrc" &&
                    result.stat("mediaType") == "video" &&
                    result.names().indexOf("googCodecName") >= 0) {
                    publishData.videoCodecName = result.stat("googCodecName");
                }
                if (result.type == "ssrc" &&
                    result.stat("mediaType") == "audio" &&
                    result.names().indexOf("googCodecName") >= 0) {
                    publishData.audioCodecName = result.stat("googCodecName");
                }
                if (result.type == "ssrc" &&
                    result.names().indexOf("googCpuLimitedResolution") >= 0) {
                    publishData.googCpuLimitedResolution = result.stat("googCpuLimitedResolution");
                }
                if (result.type == "ssrc" &&
                    result.names().indexOf("googFrameWidthInput") >= 0) {
                    publishData.googFrameWidthInput = result.stat("googFrameWidthInput");
                }
                if (result.type == "ssrc" &&
                    result.names().indexOf("googFrameHeightInput") >= 0) {
                    publishData.googFrameHeightInput = result.stat("googFrameHeightInput");
                }
                if (result.type == "ssrc" &&
                    result.names().indexOf("googFrameRateInput") >= 0) {
                    publishData.googFrameRateInput = result.stat("googFrameRateInput");
                }
                if (result.type == "ssrc" &&
                    result.names().indexOf("codecImplementationName") >= 0) {
                    publishData.codecImplementationName = result.stat("codecImplementationName");
                }
                if (result.type == "VideoBwe" &&
                    result.names().indexOf("googAvailableSendBandwidth") >= 0) {
                    publishData.googAvailableSendBandwidth = result.stat("googAvailableSendBandwidth");
                }
                if (result.type == "VideoBwe" &&
                    result.names().indexOf("googActualEncBitrate") >= 0) {
                    publishData.googActualEncBitrate = result.stat("googActualEncBitrate");
                }
                if (result.type == "VideoBwe" &&
                    result.names().indexOf("googTargetEncBitrate") >= 0) {
                    publishData.googTargetEncBitrate = result.stat("googTargetEncBitrate");
                }
                if (result.type == "VideoBwe" &&
                    result.names().indexOf("googRetransmitBitrate") >= 0) {
                    publishData.googRetransmitBitrate = result.stat("googRetransmitBitrate");
                }
            });
        this.stateCenter.browser === "chrome" &&
            this.handleEncBitrate(Number.parseInt(publishData.googTargetEncBitrate), Number.parseInt(publishData.googActualEncBitrate), Number.parseInt(publishData.googRetransmitBitrate));
        vRTT = isNaN(vRTT) || vRTT < 0 ? 0 : vRTT;
        vLostRate = isNaN(vLostRate) || vLostRate < 0 ? 0 : vLostRate;
        vJitter = isNaN(vJitter) || vJitter < 0 ? 0 : vJitter;
        aRTT = isNaN(aRTT) || aRTT < 0 ? 0 : aRTT;
        aLostRate = isNaN(aLostRate) || aLostRate < 0 ? 0 : aLostRate;
        aJitter = isNaN(aJitter) || aJitter < 0 ? 0 : aJitter;
        var videoQuality = client_util_1.ClientUtil.getNetQuality(vRTT, vLostRate, vJitter);
        var audioQuality = client_util_1.ClientUtil.getNetQuality(aRTT, aLostRate, aJitter);
        publishData.videoQuality =
            time > 0 ? client_util_1.ClientUtil.quality2QualityGrade(videoQuality) : 0;
        publishData.audioQuality =
            time > 0 ? client_util_1.ClientUtil.quality2QualityGrade(audioQuality) : 0;
        var netQuality = Math.min(videoQuality, audioQuality);
        this.netQuality = netQuality;
        if (time > 0 &&
            netQuality <= zego_entity_1.QUALITY_CONSTANT.MiddleMinQuality &&
            new Date().getTime() > this.probeTime + this.probeInterval) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PLAYER_SET_PLAYER_QUALITY_TIMER +
                " netQuality " +
                netQuality +
                " start net probe");
            this.probeState = zego_entity_1.ENUM_PROBE_STATE.tryProbe;
            this.streamCenter.startNetProbe(true, this, this.gwNodeList);
            this.probeTime = new Date().getTime();
        }
        var streamQuality = {
            video: {
                videoBitrate: publishData.videoBitrate,
                videoFPS: publishData.videoFPS,
                videoTransferFPS: publishData.videoTransferFPS,
                frameHeight: publishData.frameHeight,
                frameWidth: publishData.frameWidth,
                muteState: publishData.videoMuteState,
                videoQuality: publishData.videoQuality,
                videoPacketsLost: publishData.videoPacketsLost,
                videoPacketsLostRate: publishData.videoPacketsLostRate
            },
            audio: {
                audioBitrate: publishData.audioBitrate,
                audioCodec: publishData.audioCodec,
                muteState: publishData.audioMuteState,
                audioQuality: publishData.audioQuality,
                audioPacketsLost: publishData.audioPacketsLost,
                audioPacketsLostRate: publishData.audioPacketsLostRate,
                audioFPS: publishData.audioFPS
            },
            //roomId: '',
            nackCount: publishData.nackCount,
            pliCount: publishData.pliCount,
            totalRoundTripTime: publishData.totalRoundTripTime,
            currentRoundTripTime: publishData.currentRoundTripTime
        };
        if (publishData.videoPacketsLost !== undefined) {
            streamQuality.video.videoPacketsLost = publishData.videoPacketsLost;
            streamQuality.video.videoPacketsLostRate =
                publishData.videoPacketsLostRate;
            streamQuality.audio.audioPacketsLost = publishData.audioPacketsLost;
            streamQuality.audio.audioPacketsLostRate =
                publishData.audioPacketsLostRate;
        }
        if (publishData.muted !== undefined) {
            streamQuality.muted = publishData.muted;
            streamQuality.paused = publishData.paused;
            streamQuality.volume = publishData.volume;
            streamQuality.sinkId = publishData.sinkId;
        }
        if (publishData.googBandwidthLimitedResolution !== undefined) {
            streamQuality.googBandwidthLimitedResolution =
                publishData.googBandwidthLimitedResolution;
            streamQuality.video.googCodecName = publishData.videoCodecName;
            streamQuality.audio.googCodecName = publishData.audioCodecName;
            streamQuality.googCpuLimitedResolution =
                publishData.googCpuLimitedResolution;
            streamQuality.googFrameWidthInput = publishData.googFrameWidthInput;
            streamQuality.googFrameHeightInput = publishData.googFrameHeightInput;
            streamQuality.googFrameRateInput = publishData.googFrameRateInput;
            streamQuality.codecImplementationName =
                publishData.codecImplementationName;
            streamQuality.googAvailableSendBandwidth =
                publishData.googAvailableSendBandwidth;
            streamQuality.googActualEncBitrate = publishData.googActualEncBitrate;
            streamQuality.googTargetEncBitrate = publishData.googTargetEncBitrate;
        }
        if (time !== 0) {
            this.uploadPublishQuality(publishData);
            this.onPublishQualityUpdate(this.streamId, streamQuality, results, callbackResults);
        }
        return streamQuality;
    };
    ZegoPublish.prototype.uploadPublishQuality = function (publishData) {
        var _this = this;
        if (!this.qualityUpload) {
            return;
        }
        var timeStamp = new Date().getTime();
        if (this.qualityUploadLastTime == 0 ||
            timeStamp - this.qualityUploadLastTime >= this.qualityUploadInterval) {
            publishData["stream_type"] = "publish";
            publishData["stream_id"] = this.streamId;
            publishData["timeStamp"] = Math.round(timeStamp / 1000);
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_UPLOAD_PUBLISH_QUALITY +
                " " +
                this.streamId +
                " upload" +
                JSON.stringify(publishData));
            this.streamCenter.updateQuality(0, publishData);
            this.signal.QualityReport(zego_entity_1.getSeq(), this.sessionId, publishData, function (seq, sessionId, data) {
                console.error("QualityReport suc");
                if (data.report !== undefined) {
                    _this.qualityUpload = data.report;
                    _this.qualityUploadInterval = data.report_interval_ms;
                }
            }, function (err, seq) {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_UPLOAD_PUBLISH_QUALITY +
                    " " +
                    _this.streamId +
                    " upload failed " +
                    err);
            });
            this.qualityUploadLastTime = timeStamp;
        }
    };
    ZegoPublish.prototype.stopPublish = function () {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_STOP_PUBLISH +
            "  .1 " +
            this.streamId +
            " called");
        //sendBroadcasterStatusNotify
        if ((Object.keys(this.streamCenter.publisherList).length = 1)) {
            for (var i in this.streamCenter.playerList) {
                var player = this.streamCenter.playerList[i].player;
                if (player.state == zego_entity_1.ENUM_PLAY_STATE.playing &&
                    player.broadcasterStatus == zego_entity_1.ENUM_BROADCASTER_STATUS.start) {
                    this.signal &&
                        this.signal.sendBroadcasterStatus(zego_entity_1.getSeq(), player.sessionId, 0);
                    player.broadcasterStatus = zego_entity_1.ENUM_BROADCASTER_STATUS.stop;
                }
            }
        }
        //stop Audio Mix
        this.stopMixingAudio();
        this.stopMixingBuffer();
        this.stopEffect();
        //close session
        if (this.sessionId && !this.closeSessionSignal) {
            this.signal.sendCloseSession(zego_entity_1.getSeq(), this.sessionId, 0);
        }
        this.dataReport.eventEndWithMsg(this.streamReportSeq, "PublishState", {
            state: this.state + ""
        });
        this.dataReport.addEvent(this.streamReportSeq, "StopPublish");
        this.dataReport.addMsgExt(this.streamReportSeq, {
            stream: this.streamId,
            sessionId: this.sessionId
        });
        this.dataReport.addMsgInfo(this.streamReportSeq, {
            itemtype: "RTCPublishStream"
        });
        this.dataReport.uploadReport(this.streamReportSeq, "RTCPublishStream");
        this.resetPublish();
    };
    ZegoPublish.prototype.onPublishStateUpdate = function (type, streamId, error, stopRetry) { };
    ZegoPublish.prototype.onPublishQualityUpdate = function (streamId, quality, promiseresults, callbackresults) { };
    ZegoPublish.prototype.onDisconnect = function (error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_DISCONNECT + " " + this.streamId + " call");
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_ON_DISCONNECT +
            " " +
            this.streamId +
            " websocket disconnect");
        this.dataReport.addEvent(this.reportSeq, "OnDisconnect");
        // 
        this.publishStateUpdateError(error ||
            zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kWebsocketDisconnectedError, !!error);
    };
    // 
    ZegoPublish.prototype.playEffect = function (AudioMixConfig, audioBuffer, start, end) { };
    ZegoPublish.prototype.pauseEffect = function (effectID) { };
    ZegoPublish.prototype.resumeEffect = function (effectID) { };
    ZegoPublish.prototype.stopEffect = function (effectID) { };
    ZegoPublish.prototype.setEffectVolume = function (volume, effectID) { };
    ZegoPublish.prototype.startMixingAudio = function (mediaList) { };
    ZegoPublish.prototype.stopMixingAudio = function (media) { };
    ZegoPublish.prototype.mixingBuffer = function (sourceID, arrayBuffer, callBack) { };
    ZegoPublish.prototype.stopMixingBuffer = function (sourceID) { };
    ZegoPublish.prototype.setMixingAudioVolume = function (volume, audio) { };
    ZegoPublish.prototype.publishSuccess = function () {
        var _a;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_PUBLISH_SUCCESS + " call");
        if (this.isUpdateSDP && this.updateSDPCallBack) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_PUBLISH_SUCCESS +
                " " +
                this.streamId +
                " update sdp success");
            this.updateSDPCallBack(0);
            this.updateSDPCallBack = undefined;
            this.isUpdateSDP = false;
            return;
        }
        if (this.state != zego_entity_1.ENUM_PUBLISH_STATE.publishing) {
            this.onPublishStateUpdate(zego_entity_1.ENUM_PUBLISH_STATE_UPDATE.start, this.streamId, { code: 0, message: "" }, true);
        }
        if (this.isPeer) {
            this.peerFailCount = 0;
        }
        this.state = zego_entity_1.ENUM_PUBLISH_STATE.publishing;
        //publish started
        this.dataReport.eventStart(this.reportSeq, "PublishState");
        this.dataReport.eventStart(this.streamReportSeq, "PublishState");
        //BroadcasterStatusNotify
        for (var i in this.streamCenter.playerList) {
            var player = this.streamCenter.playerList[i].player;
            if (player.state == zego_entity_1.ENUM_PLAY_STATE.playing &&
                player.broadcasterStatus == zego_entity_1.ENUM_BROADCASTER_STATUS.stop) {
                this.signal &&
                    this.signal.sendBroadcasterStatus(zego_entity_1.getSeq(), player.sessionId, 1);
                player.broadcasterStatus = zego_entity_1.ENUM_BROADCASTER_STATUS.start;
            }
        }
        //start quality timeInterval
        this.setPublishQualityTimer();
        //report stream status
        var camera = 2;
        var microphone = 2;
        var videoTrack = (_a = this.previewer) === null || _a === void 0 ? void 0 : _a.videoTrack;
        var audioTrack = this.localStream.getAudioTracks().length !== 0 &&
            this.localStream.getAudioTracks()[0];
        if (videoTrack && videoTrack.enabled === true) {
            camera = 0;
        }
        if (audioTrack && audioTrack.enabled === true) {
            microphone = 0;
        }
        this.sendStreamStatus(camera, microphone);
        // this.localStream.onaddtrack = (): void => {
        //   this.restartSoundLevel();
        // };
        // this.localStream.onremovetrack = (): void => {
        //   this.restartSoundLevel();
        // };
        if (this.streamCenter.soundLevelDelegate) {
            this.previewer && this.previewer.startSoundLevel();
        }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_PUBLISH_SUCCESS + " call success");
    };
    ZegoPublish.prototype.startSoundLevel = function () {
        var _a;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_SOUND_LEVEL +
            " call streamID: " +
            this.streamId);
        if (!this.localStream || this.localStream.getAudioTracks().length == 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_SOUND_LEVEL +
                " " +
                this.streamId +
                " local stream no found");
            return;
        }
        // this.script && this.script.disconnect() && (this.script = null);
        // this.mic && this.mic.disconnect() && (this.mic = null);
        try {
            (_a = this.previewer) === null || _a === void 0 ? void 0 : _a.startSoundLevel();
        }
        catch (err) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_START_SOUND_LEVEL +
                " " +
                this.streamId +
                " get sound level failed " +
                err);
        }
    };
    ZegoPublish.prototype.stopSoundLevel = function () {
        var _a;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_STOP_SOUND_LEVEL +
            " call streamID: " +
            this.streamId);
        (_a = this.previewer) === null || _a === void 0 ? void 0 : _a.stopSoundLevel();
    };
    // restartSoundLevel(): void {
    //   this.previewer?.restartSoundLevel;
    // }
    ZegoPublish.prototype.rebackMic = function () {
        var _this = this;
        var _a;
        if (this.peerConnection &&
            this.micTrack instanceof MediaStreamTrack &&
            this.audioMixList.length == 0 &&
            Object.keys(this.arrayBufferMap).length == 0 &&
            this.effectList.length == 0) {
            var sender = (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.getSenders().find(function (s) { var _a, _b; return ((_a = s.track) === null || _a === void 0 ? void 0 : _a.kind) === ((_b = _this.micTrack) === null || _b === void 0 ? void 0 : _b.kind); });
            if (sender) {
                sender.replaceTrack(this.micTrack);
                this.localStream.removeTrack(this.localStream.getAudioTracks()[0]);
                this.localStream.addTrack(this.micTrack);
            }
        }
    };
    ZegoPublish.prototype.handleEncBitrate = function (targetEncBitrate, actEncBitrate, retransBitrate) {
        var _this = this;
        var _a;
        var maxBitrate = this.videoInfo.bitRate * 1000;
        var target_rate = 0;
        if (actEncBitrate > 0) {
            //
            if (!this.needIncMax && !this.gotMax) {
                this.probeCount++;
                if (actEncBitrate >= targetEncBitrate * 0.75) {
                    if (this.probeCount >= 10 &&
                        this.initFitCnt >= this.probeCount * 0.6) {
                        this.gotMax = true;
                        this.targetRate = maxBitrate;
                    }
                    this.initFitCnt++;
                }
                else {
                    if (this.probeCount >= 10 &&
                        this.initFitCnt / this.probeCount < 0.3) {
                        this.needIncMax = true;
                    }
                }
            }
            //,
            var avgActBitrate = client_util_1.ClientUtil.arrAvg(this.totalBitrateArray, actEncBitrate, 10);
            if (this.needIncMax) {
                if (avgActBitrate >= maxBitrate * 1.05) {
                    if (this.targetRate > maxBitrate) {
                        var diff = void 0;
                        if (avgActBitrate > targetEncBitrate) {
                            diff = avgActBitrate - targetEncBitrate;
                            this.targetRate -= diff;
                        }
                        else {
                            diff = avgActBitrate - maxBitrate;
                            this.targetRate -= diff;
                        }
                        this.targetRate = Math.max(this.targetRate, maxBitrate);
                        this.targetRate = Math.min(this.targetRate, maxBitrate * 2);
                        target_rate = this.targetRate;
                    }
                }
                else if (avgActBitrate < maxBitrate * 0.8) {
                    if (this.targetRate === 0) {
                        this.targetRate = targetEncBitrate;
                    }
                    if (this.targetRate >= maxBitrate) {
                        this.targetRate = this.targetRate + maxBitrate * 0.08;
                    }
                    else {
                        this.targetRate = this.targetRate * 1.05;
                    }
                    this.targetRate = Math.min(this.targetRate, maxBitrate * 2);
                    target_rate = this.targetRate;
                }
            }
        }
        //,
        if (retransBitrate > 0 && retransBitrate < maxBitrate) {
            var avgRetrans = client_util_1.ClientUtil.arrAvg(this.totalRetransRateArray, retransBitrate, 5);
            if (this.needIncMax) {
                if (avgRetrans + actEncBitrate > maxBitrate * 1.05) {
                    var diff = avgRetrans + actEncBitrate - maxBitrate;
                    this.targetRate -= diff;
                    this.targetRate = Math.max(this.targetRate, maxBitrate - avgRetrans);
                    target_rate = this.targetRate;
                }
            }
            else {
                target_rate = this.targetRate - avgRetrans;
            }
        }
        else {
            if (this.targetRate < maxBitrate) {
                this.targetRate = maxBitrate;
                target_rate = this.targetRate;
            }
        }
        if (target_rate > 0) {
            //
            target_rate = client_util_1.ClientUtil.arrAvg(this.totalTargetRateArray, target_rate, 5);
            var sender = (_a = this.peerConnection) === null || _a === void 0 ? void 0 : _a.getSenders().find(function (s) { return s.track && s.track.kind === "video"; });
            if (!sender) {
                return;
            }
            var parameters = sender.getParameters();
            if (!parameters.encodings) {
                parameters.encodings = [{}];
            }
            parameters.encodings[0].maxBitrate = target_rate;
            sender.setParameters(parameters).catch(function (err) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.PUBLISHER_HANDLE_ENC_BITRATE + " " + err);
            });
        }
    };
    ZegoPublish.prototype.resetEncBitrate = function () {
        this.needIncMax = false;
        this.probeCount = 0;
        this.gotMax = false;
        this.initFitCnt = 0;
        this.targetRate = 0;
        this.totalBitrateArray = [];
        this.totalTargetRateArray = [];
        this.totalRetransRateArray = [];
    };
    ZegoPublish.prototype.replacePublishedTrack = function (mediaStreamTrack, forStream) {
        if (forStream === void 0) { forStream = false; }
        return {
            errorCode: -1,
            extendedData: "should install advanced module first"
        };
    };
    ZegoPublish.prototype.sendStreamStatus = function (camera_status, mic_status, times) {
        var _this = this;
        if (times === void 0) { times = 0; }
        // 
        this.camera_status = camera_status;
        this.mic_status = mic_status;
        times++;
        // 
        this.signal.sendStreamStatus(zego_entity_1.getSeq(), this.sessionId, camera_status, mic_status, this.streamId, function () {
            if (_this.camera_status === camera_status &&
                _this.mic_status === mic_status) {
                // TODO: 1
                if (times <= 1) {
                    _this.sendStreamStatus(camera_status, mic_status, times);
                }
            }
        });
    };
    return ZegoPublish;
}());
exports.ZegoPublish = ZegoPublish;


/***/ }),

/***/ "./sdk/src/webrtc/modules/streamSignal.ts":
/*!************************************************!*\
  !*** ./sdk/src/webrtc/modules/streamSignal.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoSignal = void 0;
var zego_entity_1 = __webpack_require__(/*! ../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var action_1 = __webpack_require__(/*! ../../common/action */ "./sdk/src/common/action.ts");
var zego_error_1 = __webpack_require__(/*! ../../common/zego.error */ "./sdk/src/common/zego.error.ts");
var analogSocket_1 = __webpack_require__(/*! ./analogSocket */ "./sdk/src/webrtc/modules/analogSocket.ts");
var WEBRTC_PROTO_VERSION = "1.0.1"; //
var ZegoSignal = /** @class */ (function () {
    function ZegoSignal(logger, stateCenter, netAgent, useNetAgent) {
        if (useNetAgent === void 0) { useNetAgent = false; }
        this.netAgent = netAgent;
        this.useNetAgent = useNetAgent;
        this.sendDataMap = {};
        this.sendDataList = new zego_entity_1.LinkedList();
        this.sendDataCheckOnceCount = 100;
        this.signalSeq = 0;
        this.pushCallback = {};
        this.sessionInfos = {};
        //tryheartbeat
        this.tryHeartbeatCount = 0;
        // heartbeatTimer = null;
        this.heartbeatInterval = 10 * 1000;
        this.sendDataTimeout = 5 * 1000; //
        this.sendDataDropTimeout = 10 * 1000; //
        this.sendDataCheckTimer = null;
        this.sendDataCheckInterval = 2000; //
        this.checkMessageList = [
            "ActivateVideoPlayStreamReq",
            "ActivateAudioPlayStreamReq",
            "CreateSessionReq",
            "CreateSessionWithSdpReq",
            "ActivateSEIInsertReq",
            "StreamStatusNotify",
            "MediaDescUpdateReq"
        ];
        this.tryConnectCount = 1;
        this.tryConnectTimer = null;
        this.tryConnectInterval = 3000;
        this.state = zego_entity_1.ENUM_CONNECT_STATE.disconnect;
        //token
        this.tokenType = 0;
        this.browser = this.getBrowserAndVersion();
        this.platform = navigator.platform;
        this._websocket = null;
        this.negoInterval = 25000;
        this.negoTryCount = 1;
        this.negoTryMaxCount = 2;
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.stateCenter.streamConnectTime &&
            (this.tryConnectInterval = this.stateCenter.streamConnectTime);
    }
    Object.defineProperty(ZegoSignal.prototype, "wsReadyState", {
        get: function () {
            var _a;
            return (_a = this.websocket) === null || _a === void 0 ? void 0 : _a.readyState;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ZegoSignal.prototype, "websocket", {
        get: function () {
            return this._websocket;
        },
        set: function (val) {
            // socketnull
            if (val === null && this.useNetAgent) {
                return;
            }
            this._websocket = val;
        },
        enumerable: false,
        configurable: true
    });
    ZegoSignal.prototype.getBrowserAndVersion = function () {
        var ua = navigator.userAgent;
        var tem, M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*([\d\.]+)/i) || [];
        if (/trident/i.test(M[1])) {
            tem = /\brv[ :]+([\d\.]+)/g.exec(ua) || [];
            return { name: "IE", version: tem[1] || "" };
        }
        if (M[1] === "Chrome") {
            tem = ua.match(/\bOPR|Edge\/([\d\.]+)/);
            if (tem != null) {
                return { name: "Opera", version: tem[1] };
            }
        }
        M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, "-?"];
        if ((tem = ua.match(/version\/([\d+\.]+)/i)) != null) {
            M.splice(1, 1, tem[1]);
        }
        return {
            name: M[0],
            version: M[1]
        };
    };
    ZegoSignal.prototype.setSessionInfo = function (appid, userid) {
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SET_SESSION_INFO + " call");
        this.appid = appid + "";
        this.userid = userid;
        // this.server = serverUrl;
    };
    ZegoSignal.prototype.onDisconnect = function (server, error) { };
    ZegoSignal.prototype.onUpdateHeartBeatInterval = function (interval) { };
    ZegoSignal.prototype.resetConnectTimer = function () {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_RESET_CONNECT_TIMER + " call");
        clearTimeout(this.tryConnectTimer);
        this.tryConnectTimer = null;
        this.tryConnectCount = 0;
    };
    /**
     * 
     */
    ZegoSignal.prototype.handleWsMessage = function (e) {
        // json
        var msg = JSON.parse(e.data);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_BIND_WEBSOCKET_HANDLE + " signmsg= ", msg.header.cmd);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_BIND_WEBSOCKET_HANDLE +
            " signmsg= " +
            JSON.stringify(msg));
        if (msg.header.appid != this.appid || msg.header.user_id !== this.userid) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_BIND_WEBSOCKET_HANDLE + " check header failed");
            return;
        }
        this.handleServerPush(msg);
    };
    /**
     *  error  close 
     */
    ZegoSignal.prototype.bindWebSocketEvents = function () {
        var _this = this;
        // 
        this.tryHeartbeatCount = 0;
        this.tryConnectInterval = this.stateCenter.streamConnectTime
            ? this.stateCenter.streamConnectTime
            : 3000;
        if (this.websocket) {
            this.websocket.onclose = function (e) {
                _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_BIND_WEBSOCKET_HANDLE +
                    " close msg = " +
                    JSON.stringify(e.code ? e.code : e));
                // this.onSocketCloseCallBack();
                if (_this.state != zego_entity_1.ENUM_CONNECT_STATE.disconnect) {
                    //try connect
                    _this.resetConnectTimer();
                    _this.startConnectTimer(function (result) {
                        if (result === 1008) {
                            _this.disconnectCallback(zego_error_1.errorCodeList.TOKEN_EXPIRED);
                        }
                    });
                    //all request timeout
                    _this.resetCheckMessage();
                }
            };
            this.websocket.onerror = function (e) {
                _this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_BIND_WEBSOCKET_HANDLE +
                    " msg = " +
                    JSON.stringify(e));
            };
        }
    };
    ZegoSignal.prototype.resetCheckMessage = function () {
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_RESET_CHECK_MESSAGE + " call");
        clearTimeout(this.sendDataCheckTimer);
        this.sendDataCheckTimer = null;
        var head = this.sendDataList.getFirst();
        while (head != null) {
            this.sendDataList.remove(head);
            if (head._data.error)
                head._data.error(zego_entity_1.SEND_MSG_RESET, head._data.seq);
            head = this.sendDataList.getFirst();
        }
        this.sendDataMap = {};
    };
    ZegoSignal.prototype.handleServerPush = function (msg) {
        switch (msg.header.cmd) {
            case "LoginRsp":
                this.handleRespondData("LoginReq", msg);
                break;
            case "CreateSessionRsp":
                this.handleRespondData("CreateSessionReq", msg);
                if (msg.body.result === 0)
                    this.addSession(msg.header.session_id, msg.body.session_token);
                break;
            case "CreateSessionWithSdpRsp":
                this.handleRespondData("CreateSessionWithSdpReq", msg);
                if (msg.body.result === 0)
                    this.addSession(msg.header.session_id, msg.body.session_token);
                break;
            case "MediaDescRsp":
                this.handleRespondData("MediaDescReq", msg);
                break;
            case "CandidateInfoRsp":
                this.handleRespondData("CandidateInfoReq", msg);
                break;
            case "CloseSessionRsp":
                this.handleRespondData("CloseSessionReq", msg);
                this.removeSession(msg.header.session_id);
                break;
            case "ClientHBRsp":
                this.handleRespondData("ClientHBReq", msg);
                break;
            case "MediaDescPush":
                this.handlePushData(msg);
                break;
            case "CandidateInfoPush":
                this.handlePushData(msg);
                break;
            case "CloseSessionPush":
                this.handlePushData(msg);
                this.removeSession(msg.header.session_id);
                break;
            case "QualityReportRsp":
                this.handleRespondData("QualityReportReq", msg);
                break;
            case "SessionResetPush":
                this.handlePushResetSessionData(msg);
                break;
            case "StreamStatusNotifyPush":
                this.handlePushData(msg);
                break;
            case "PublishEventPush":
                this.handlePushData(msg);
                break;
            case "PlayEventPush":
                this.handlePushData(msg);
                break;
            case "ClientInfoPush":
                this.handlePushData(msg);
                break;
            case "ActivateVideoPlayStreamRsp":
                this.handleRespondData("ActivateVideoPlayStreamReq", msg);
                break;
            case "ActivateAudioPlayStreamRsp":
                this.handleRespondData("ActivateAudioPlayStreamReq", msg);
                break;
            case "NetQualityProbeRsp":
                this.handleRespondData("NetQualityProbeReq", msg);
                break;
            case "NetQualityInfoPush":
                this.handlePushData(msg);
                break;
            case "ActivateSEIInsertRsp":
                this.handleRespondData("ActivateSEIInsertReq", msg);
                break;
            case "StreamStatusNotifyAck":
                this.handleRespondData("StreamStatusNotify", msg);
                break;
            case "Peer2PeerNetStatsGetRsp":
                this.handleRespondData("Peer2PeerNetStatsGetReq", msg);
                break;
            case "MediaDescUpdateRsp":
                this.handleRespondData("MediaDescUpdateReq", msg);
            case "MediaDescUpdatePush":
                this.handlePushData(msg);
        }
    };
    ZegoSignal.prototype.disconnectCallback = function (error) {
        if (this.connectCallback) {
            this.connectCallback(-1, this.server, undefined);
            this.connectCallback = null;
        }
        var server = this.server;
        this.disconnectServer();
        this.onDisconnect(server, error);
    };
    ZegoSignal.prototype.updateToken = function () {
        var _this = this;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_UPDATE_TOKEN + " call");
        var cmd = "LoginReq";
        var body = {
            token: this.token,
            tokenType: this.tokenType,
            roomid: this.roomID,
            anchorname: this.stateCenter.anchor_info.anchor_id,
            sdkversion: zego_entity_1.PROTO_VERSION,
            osinfo: navigator.appVersion
        };
        if (Object.keys(this.sessionInfos).length != 0) {
            var sessions = [];
            for (var sessionID in this.sessionInfos) {
                var session_id = parseInt(sessionID);
                sessions.push({
                    session_id: session_id,
                    session_token: this.sessionInfos[session_id].token
                });
            }
            body["sessions"] = sessions;
        }
        this.sendMessageWithCallback(cmd, this.stateCenter.getSeq(), 0, body, function (seq, session_id, data) {
            if (data.result == 0) {
                _this.token = data.token;
                _this.tokenType = data.tokenType;
                var tokenInfo = {
                    report: data.report,
                    report_interval: data.report_interval_ms
                };
                data.negoInterval && (_this.negoInterval = data.negoInterval);
                data.negoTryCount && (_this.negoTryCount = data.negoTryCount);
                data.negoTryMaxCount && (_this.negoTryMaxCount = data.negoTryMaxCount);
                if (_this.connectCallback != null) {
                    _this.connectCallback(0, _this.server, tokenInfo);
                    _this.connectCallback = null;
                }
                _this.checkMessageTimeout();
            }
            else {
                var errorTokenInfo = {
                    error: data.strError
                };
                if (_this.connectCallback != null) {
                    _this.connectCallback(data.result, _this.server, errorTokenInfo);
                    _this.connectCallback = null;
                }
            }
        }, function () {
            if (_this.connectCallback != null) {
                _this.connectCallback(-1, _this.server, undefined);
                _this.connectCallback = null;
            }
        });
    };
    ZegoSignal.prototype.sendMessageWithCallback = function (cmd, seq, sessionID, body, success, error) {
        if (success === void 0) { success = null; }
        if (error === void 0) { error = null; }
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MESSAGE_WITH_CALLBACK + " call " + cmd);
        if (!this.websocket ||
            (cmd !== "LoginReq" && this.websocket.readyState !== WebSocket.OPEN)) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MESSAGE_WITH_CALLBACK +
                " connect not establish");
            if (error) {
                // TODO: socket
                error(zego_entity_1.SEND_MSG_TIMEOUT, seq);
            }
            return;
        }
        var header = this.getHeader(cmd, seq, sessionID);
        var data = {
            header: header,
            body: body
        };
        var cmdData = {
            // data: data,
            seq: seq,
            deleted: false,
            cmd: cmd,
            time: new Date().getTime(),
            success: success,
            error: error
        };
        var cmdDataNode = this.sendDataList.push(cmdData);
        this.sendDataMap[cmdData.seq] = cmdDataNode;
        var dataBuffer = JSON.stringify(data);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MESSAGE_WITH_CALLBACK + " " + dataBuffer);
        this.websocket.send(dataBuffer);
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MESSAGE_WITH_CALLBACK + " success");
    };
    ZegoSignal.prototype.getHeader = function (cmd, seq, sessionID) {
        var globalHeader = {
            version: WEBRTC_PROTO_VERSION,
            cmd: cmd,
            appid: this.appid + "",
            seq: seq,
            user_id: this.userid,
            session_id: sessionID
        };
        return globalHeader;
    };
    //rtc
    ZegoSignal.prototype.connectServer = function (roomID, token, serverUrl, result) {
        var _this = this;
        var _a;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER + " " + serverUrl);
        this.roomID = roomID;
        this.token = token;
        this.server = serverUrl;
        this.state = zego_entity_1.ENUM_CONNECT_STATE.connecting;
        this.connectCallback = result;
        if (!this.isServerConnected) {
            try {
                //connect websocket
                if (this.useNetAgent) {
                    if (!this.stateCenter.appConfig) {
                        console.error("no app config");
                        return;
                    }
                    var resource_info = this.stateCenter.appConfig.media_config.publish_config.resource_info;
                    var rtcs = resource_info.find(function (item) {
                        return item.resource_type === zego_entity_1.ResourceType.RTC;
                    });
                    if (!rtcs) {
                        result && result(zego_error_1.errorCodeList.GET_CONFIG_FAIL);
                        return;
                    }
                    var rtc_webrtc = (_a = rtcs === null || rtcs === void 0 ? void 0 : rtcs.service_info) === null || _a === void 0 ? void 0 : _a.find(function (rtc) {
                        return rtc.protocol === zego_entity_1.ProtocolType.WEBRTC;
                    });
                    if (!rtc_webrtc) {
                        // TODO
                        result && result(zego_error_1.errorCodeList.GET_CONFIG_FAIL);
                        return;
                    }
                    var urlTemplate = rtc_webrtc.url_template;
                    var url = urlTemplate.split("{IP}")[1];
                    var _b = url.split("?"), path = _b[0], query = _b[1];
                    var signalConfig = {
                        path: path,
                        query: query
                    };
                    console.error(signalConfig);
                    if (this.websocket instanceof WebSocket) {
                        this.websocket.onclose = null;
                        this.websocket.onerror = null;
                        this.websocket.close();
                        this.websocket = null;
                    }
                    !this.websocket &&
                        (this.websocket = new analogSocket_1.AnalogSocket(this.server, this.netAgent, signalConfig));
                    this.websocket.open();
                }
                else {
                    this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER + " need new websocket");
                    if (this.websocket) {
                        this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER +
                            " close error websocket");
                        this.websocket.onclose = null;
                        this.websocket.onerror = null;
                        this.websocket.close();
                    }
                    this.websocket = new WebSocket(this.server);
                }
                this.websocket.onclose = function (reason) {
                    console.warn(" socket websocket onclose");
                    _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER +
                        " websocket close call  " +
                        JSON.stringify(reason));
                };
                this.websocket.onerror = function (err) {
                    _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER +
                        " websocket onerror call  " +
                        JSON.stringify(err));
                };
                if (this.useNetAgent && this.websocket instanceof analogSocket_1.AnalogSocket) {
                    // token
                    this.websocket.onopen = function () {
                        console.warn(" socket websocket open");
                        //register onMessage
                        _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER + " websocket open call");
                        _this.bindWebSocketEvents();
                        _this.state = zego_entity_1.ENUM_CONNECT_STATE.connected;
                        _this.websocket &&
                            (_this.websocket.onmessage = _this.handleWsMessage.bind(_this));
                    };
                    this.websocket.onreconnnecting = function () {
                        console.warn(" socket websocket onreconnnecting");
                        _this.updateToken();
                    };
                    //update token
                    this.websocket.onmessage = this.handleWsMessage.bind(this);
                    this.updateToken();
                }
                else {
                    this.websocket.onopen = function () {
                        //reset connect timer
                        _this.resetConnectTimer();
                        //register onMessage
                        _this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER + " websocket open call");
                        _this.websocket &&
                            (_this.websocket.onmessage = _this.handleWsMessage.bind(_this));
                        _this.bindWebSocketEvents();
                        //update token
                        _this.updateToken();
                        _this.state = zego_entity_1.ENUM_CONNECT_STATE.connected;
                    };
                }
            }
            catch (e) {
                this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER + " websocket error " + e);
            }
        }
        else {
            //websocket is already connect
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER + " websocket is connected");
            this.resetConnectTimer();
            this.state = zego_entity_1.ENUM_CONNECT_STATE.connected;
        }
        // SDK
        if (!this.useNetAgent) {
            //
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CONNECT_SERVER + " " + this.tryConnectInterval);
            this.tryConnectTimer = setTimeout(function () {
                _this.startConnectTimer(result);
            }, this.tryConnectInterval);
        }
    };
    ZegoSignal.prototype.startConnectTimer = function (callback) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_START_CONNECT_TIMER + " call");
        if (this.tryConnectCount >= zego_entity_1.MAX_TRY_CONNECT_COUNT) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_START_CONNECT_TIMER +
                " beyond " +
                this.server +
                "max limit");
            this.disconnectCallback();
            return;
        }
        if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
            this.tryConnectCount += 1;
            this.connectServer(this.roomID, this.token, this.server, callback);
        }
        else {
            //already connect
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_START_CONNECT_TIMER +
                " websocket is connected");
            this.resetConnectTimer();
        }
    };
    //rtc
    ZegoSignal.prototype.disconnectServer = function () {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_DISCONNECT_SERVER + " call");
        //this.server = null;
        this.connectCallback = null;
        this.resetCheckMessage();
        this.resetConnectTimer();
        if (this.websocket) {
            this.websocket.onclose = null;
            this.websocket.onerror = null;
            this.websocket.close();
            this.websocket = null;
        }
        this.token = "";
        this.sessionInfos = {};
        this.tokenType = 0;
        this.tryHeartbeatCount = 0;
        this.tryConnectCount = 0;
        this.state = zego_entity_1.ENUM_CONNECT_STATE.disconnect;
    };
    Object.defineProperty(ZegoSignal.prototype, "isServerConnected", {
        get: function () {
            var _a;
            return ((_a = this.websocket) === null || _a === void 0 ? void 0 : _a.readyState) === WebSocket.OPEN;
        },
        enumerable: false,
        configurable: true
    });
    ZegoSignal.prototype.createSession = function (seq, type, mode, streamId, strAuthParam, serverHost, success, error) {
        if (strAuthParam === void 0) { strAuthParam = ""; }
        if (serverHost === void 0) { serverHost = ""; }
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CREATE_SESSION + " call: " + streamId);
        var sdkversion = "";
        zego_entity_1.PROTO_VERSION.split(".").forEach(function (e, ind) {
            return e.length == 1 && ind == 1 ? (sdkversion += "0" + e) : (sdkversion += e);
        });
        var cmd = "CreateSessionReq";
        var body = {
            type: type,
            stream_id: streamId,
            platform: this.platform,
            browser: this.browser.name,
            version: this.browser.version,
            app_id: this.appid,
            negotiate_mode: mode,
            strAuthParam: strAuthParam,
            sdk_version: sdkversion * 1,
            turn_server_host: typeof serverHost == "string" ? serverHost : ""
        };
        // //publish
        // if (type == 0) {
        //         body['negotiate_mode'] = 0;
        // } else {
        //         body['negotiate_mode'] = 1;
        // }
        this.sendMessageWithCallback(cmd, seq, 0, body, success, error);
    };
    ZegoSignal.prototype.createSessionWithSdp = function (options, success, error) {
        var seq = options.seq, type = options.type, streamId = options.streamId, strAuthParam = options.strAuthParam, sdp = options.sdp, serverHost = options.serverHost, playBufLevel = options.playBufLevel;
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CREATE_SESSION + " call: " + streamId);
        var sdkversion = "";
        zego_entity_1.PROTO_VERSION.split(".").forEach(function (e, ind) {
            return e.length == 1 && ind == 1 ? (sdkversion += "0" + e) : (sdkversion += e);
        });
        var cmd = "CreateSessionWithSdpReq";
        var body = {
            type: type,
            app_id: this.appid,
            stream_id: streamId,
            sdp: sdp,
            user_id: this.userid,
            platform: this.platform,
            browser: this.browser.name,
            sdk_vers: parseInt(sdkversion),
            clientIp: "",
            media_server_host: typeof serverHost == "string" ? serverHost : "",
            strAuthParam: strAuthParam
        };
        if (playBufLevel) {
            body.min_play_buf_level_ms = playBufLevel;
        }
        // if (this.stateCenter.gatewayIP) {
        //     body.test_gw_nodeip = this.stateCenter.gatewayIP;
        // }
        this.sendMessageWithCallback(cmd, seq, 0, body, success, error);
    };
    ZegoSignal.prototype.sendMediaDescUpdateReq = function (seq, sessionID, description, success, error) {
        var body = {
            peer_id: description.peerID,
            type: description.type,
            sdp: description.sdp,
            width: description.width,
            height: description.height,
            framerate: description.frameRate,
            video_min_kpbs: description.video_min_kpbs,
            video_max_kpbs: description.video_max_kpbs,
            audio_kpbs: description.audio_kpbs,
            keyframe_intv: description.keyframe_intv
        };
        var cmd = "MediaDescUpdateReq";
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    };
    ZegoSignal.prototype.removeSession = function (sessionID) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_REMOVE_SESSION + " call" + sessionID);
        if (this.sessionInfos[sessionID]) {
            delete this.sessionInfos[sessionID];
        }
    };
    ZegoSignal.prototype.sendCloseSession = function (seq, sessionID, reason, success, error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_REMOVE_SESSION + " call: " + sessionID);
        var cmd = "CloseSessionReq";
        var body = {
            reason: reason
        };
        this.removeSession(sessionID);
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    };
    ZegoSignal.prototype.sendMessage = function (cmd, seq, sessionID, body) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MESSAGE + " call " + cmd);
        if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MESSAGE + " connect not establish");
            return;
        }
        var header = this.getHeader(cmd, seq, sessionID);
        var data = {
            header: header,
            body: body
        };
        var dataBuffer = JSON.stringify(data);
        this.websocket.send(dataBuffer);
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MESSAGE + " success");
    };
    ZegoSignal.prototype.handleRespondData = function (cmd, msg) {
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_HANDLE_RESPOND_DATA + " call");
        //callback
        var sendDataNode = this.sendDataMap[msg.header.seq];
        if (sendDataNode == null) {
            if (msg.header.cmd == "CloseSessionRsp")
                return;
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_HANDLE_RESPOND_DATA +
                " cannot find data " +
                cmd);
            return;
        }
        var sendData = sendDataNode._data;
        if (sendData.cmd !== cmd) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_HANDLE_RESPOND_DATA + " command is not match");
        }
        else if (sendData.success) {
            sendData.success(msg.header.seq, msg.header.session_id, msg.body);
        }
        delete this.sendDataMap[msg.header.seq];
        this.sendDataList.remove(sendDataNode);
    };
    ZegoSignal.prototype.addSession = function (sessionID, token) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_ADD_SESSION + " call" + sessionID);
        this.sessionInfos[sessionID] = {
            token: token
        };
    };
    ZegoSignal.prototype.handlePushData = function (msg) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_HANDLE_PUSH_DATA +
            " call " +
            msg.header.cmd +
            " session " +
            msg.header.session_id);
        var callbackData = this.pushCallback[msg.header.cmd + msg.header.session_id];
        if (!callbackData) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_HANDLE_PUSH_DATA +
                " no callbackData " +
                msg.header.cmd +
                " session: " +
                msg.header.session_id);
            return;
        }
        if (callbackData.callback) {
            callbackData.callback(msg.header.seq, msg.header.session_id, msg.body);
        }
    };
    ZegoSignal.prototype.handlePushResetSessionData = function (msg) {
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_HANDLE_PUSH_RESET_SESSION_DATA + " call ");
        var sessionList = [];
        if (msg.body.cResetType == 0) {
            sessionList = Object.keys(this.sessionInfos);
        }
        else if (msg.body.cResetType == 1) {
            for (var i = 0; i < msg.body.session_ids.length; i++) {
                sessionList.push(msg.body.session_ids[i]);
            }
        }
        //send ack
        this.sendResetSessionAck(msg.header.seq, 0, 0);
        if (sessionList.length == 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_HANDLE_PUSH_RESET_SESSION_DATA +
                " no session to callback");
            return;
        }
        for (var j = 0; j < sessionList.length; j++) {
            var callbackData = this.pushCallback[msg.header.cmd + sessionList[j]];
            if (callbackData == null) {
                this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_HANDLE_PUSH_RESET_SESSION_DATA +
                    " no callbackData " +
                    sessionList[j]);
            }
            else {
                if (callbackData.callback) {
                    callbackData.callback(msg.header.seq, sessionList[j], msg.body);
                }
            }
        }
    };
    ZegoSignal.prototype.sendMediaDesc = function (seq, sessionID, type, desc, success, error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MEDIA_DESC + " call: " + sessionID);
        var cmd = "MediaDescReq";
        var body = {
            type: type,
            sdp: desc.sdp
        };
        if (desc.width != undefined) {
            body["width"] = desc.width;
        }
        if (desc.height != undefined) {
            body["height"] = desc.height;
        }
        if (desc.frameRate != undefined) {
            body["framerate"] = desc.frameRate;
        }
        if (desc.video_min_kpbs != undefined) {
            body["video_min_kpbs"] = desc.video_min_kpbs;
        }
        if (desc.video_max_kpbs != undefined) {
            body["video_max_kpbs"] = desc.video_max_kpbs;
        }
        if (desc.audio_kpbs != undefined) {
            body["audio_kpbs"] = desc.audio_kpbs;
        }
        if (desc.keyframe_intv != undefined) {
            body["keyframe_intv"] = desc.keyframe_intv;
        }
        if (desc.min_play_buf_level_ms != undefined) {
            body["min_play_buf_level_ms"] = desc.min_play_buf_level_ms;
        }
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    };
    ZegoSignal.prototype.sendCandidateInfo = function (seq, sessionID, candidateList, success, error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_CANDIDATE_INFO + " call: " + sessionID);
        var cmd = "CandidateInfoReq";
        var dataList = [];
        for (var i = 0; i < candidateList.length; i++) {
            var info = {
                candidate: candidateList[i].candidate,
                sdpMid: candidateList[i].sdpMid,
                sdpMLineIndex: candidateList[i].sdpMLineIndex
            };
            dataList.push(info);
        }
        var body = {
            infos: dataList
        };
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    };
    ZegoSignal.prototype.sendMediaDescAck = function (seq, sessionID, result) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MEDIA_DESC_ACK + " call: " + sessionID);
        var cmd = "MediaDescAck";
        var body = {
            result: result
        };
        this.sendMessage(cmd, seq, sessionID, body);
    };
    ZegoSignal.prototype.sendUpdateMediaDescAck = function (seq, sessionID, result, peerID) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_MEDIA_DESC_ACK + " call: " + sessionID);
        var cmd = "MediaDescUpdateAck";
        var body = {
            peer_id: peerID,
            result: result
        };
        this.sendMessage(cmd, seq, sessionID, body);
    };
    ZegoSignal.prototype.sendCandidateInfoAck = function (seq, sessionID, result) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_CANDIDATE_INFO_ACK + " call: " + sessionID);
        var cmd = "CandidateInfoAck";
        var body = {
            result: result
        };
        this.sendMessage(cmd, seq, sessionID, body);
    };
    ZegoSignal.prototype.sendCloseSessionAck = function (seq, sessionID, result) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_CLOSE_SESSION_ACK + " call: " + sessionID);
        var cmd = "CloseSessionAck";
        var body = {
            result: result
        };
        this.sendMessage(cmd, seq, sessionID, body);
    };
    ZegoSignal.prototype.sendResetSessionAck = function (seq, sessionID, result) {
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_RESET_SESSION_ACK + " call: " + sessionID);
        var cmd = "SessionResetAck";
        var body = {
            result: result
        };
        this.sendMessage(cmd, seq, sessionID, body);
    };
    ZegoSignal.prototype.registerPushCallback = function (cmd, sessionID, callback) {
        if (callback && typeof callback === "function") {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_REGISTER_PUSH_CALLBACK +
                " set callback " +
                sessionID);
            this.pushCallback[cmd + sessionID] = { callback: callback };
        }
    };
    ZegoSignal.prototype.unregisterPushCallback = function (cmd, sessionID) {
        delete this.pushCallback[cmd + sessionID];
    };
    ZegoSignal.prototype.checkMessageTimeout = function () {
        var _this = this;
        var head = this.sendDataList.getFirst();
        var timestamp = new Date().getTime();
        var checkCount = 0;
        var timeoutMsgCount = 0;
        var dropMsgCount = 0;
        while (head != null) {
            if (head._data.time + this.sendDataTimeout > timestamp) {
                break;
            }
            delete this.sendDataMap[head._data.seq];
            this.sendDataList.remove(head);
            ++timeoutMsgCount;
            if (this.checkMessageList.indexOf(head._data.cmd) == -1) {
                head = this.sendDataList.getFirst();
                continue;
            }
            if (head._data.error == null ||
                (this.sendDataDropTimeout > 0 &&
                    head._data.time + this.sendDataDropTimeout < timestamp)) {
                ++dropMsgCount;
            }
            else {
                this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CHECK_MESSAGE_TIMEOUT +
                    " error cmd = " +
                    head._data.cmd);
                if (head._data.error)
                    head._data.error(zego_entity_1.SEND_MSG_TIMEOUT, head._data.seq);
            }
            ++checkCount;
            if (checkCount >= this.sendDataCheckOnceCount) {
                break;
            }
            head = this.sendDataList.getFirst();
        }
        this.sendDataCheckTimer = setTimeout(function () {
            _this.checkMessageTimeout();
        }, this.sendDataCheckInterval);
        if (timeoutMsgCount != 0 || dropMsgCount != 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_CHECK_MESSAGE_TIMEOUT +
                " call success, state: timeout=" +
                timeoutMsgCount +
                " drop=" +
                dropMsgCount);
        }
    };
    ZegoSignal.prototype.sendHeartbeat = function () {
        var _this = this;
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_HEARTBEAT +
            "call tryHeartbeatCount:" +
            this.tryHeartbeatCount);
        if (Object.keys(this.sessionInfos).length == 0) {
            this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_HEARTBEAT + " no need to heartbeat");
            return;
        }
        if (this.state !== zego_entity_1.ENUM_CONNECT_STATE.connected) {
            this.logger.warn(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_HEARTBEAT + " state error");
            return;
        }
        if (++this.tryHeartbeatCount > zego_entity_1.MAX_TRY_HEARTBEAT_COUNT) {
            this.logger.error(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_HEARTBEAT + " heartbeat try limit");
            this.disconnectCallback();
            return;
        }
        var sessionIdList = [];
        for (var sessionID in this.sessionInfos) {
            sessionIdList.push(parseInt(sessionID));
        }
        var body = {
            session_ids: sessionIdList
        };
        this.sendMessageWithCallback("ClientHBReq", this.stateCenter.getSeq(), 0, body, function (seq, sessionID, data) {
            if (_this.heartbeatInterval != data.hb_interval) {
                _this.heartbeatInterval = data.hb_interval;
                _this.onUpdateHeartBeatInterval(data.hb_interval);
            }
            _this.tryHeartbeatCount = 0;
        }, function (err, seq) {
            // this.tryHeartbeatCount += 1;
        });
    };
    ZegoSignal.prototype.QualityReport = function (seq, sessionID, qualityStat, success, error) {
        this.logger.debug(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_QUALITY_REPORT + " call");
        var cmd = "QualityReportReq";
        var body = {
            streams: [
                __assign(__assign({}, qualityStat), {
                    aid: sessionID
                })
            ]
        };
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    };
    ZegoSignal.prototype.sendStreamStatus = function (seq, sessionID, camera, microphone, streamID, timeoutHandler) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_STREAM_STATUS + " call " + sessionID);
        var cmd = "StreamStatusNotify";
        var body = {
            mic_status: microphone,
            camera_status: camera
        };
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_STREAM_STATUS + " stream " + (streamID ||
            "") + " status " + JSON.stringify(body));
        this.sendMessageWithCallback(cmd, seq, sessionID, body, function () { }, function (error) {
            if (error === zego_entity_1.SEND_MSG_TIMEOUT) {
                timeoutHandler && timeoutHandler();
            }
        });
    };
    ZegoSignal.prototype.ActivatePlayVideoStream = function (seq, sessionID, mute, success, error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_ACTIVE_PLAY_VIDEO_STREAM + " call");
        var cmd = "ActivateVideoPlayStreamReq";
        var body = {
            active: mute ? 0 : 1,
            layer: 0
        };
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_ACTIVE_PLAY_VIDEO_STREAM +
            " activate video " +
            JSON.stringify(body));
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    };
    ZegoSignal.prototype.ActivatePlayAudioStream = function (seq, sessionID, mute, success, error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_ACTIVE_PLAY_AUDIO_STREAM + " call");
        var cmd = "ActivateAudioPlayStreamReq";
        var body = {
            active: mute ? 0 : 1,
            layer: 0
        };
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_ACTIVE_PLAY_AUDIO_STREAM +
            " activate audio " +
            JSON.stringify(body));
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    };
    ZegoSignal.prototype.sendBroadcasterStatus = function (seq, sessionID, status) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_BROADCAST_STATUS + " call " + sessionID);
        var cmd = "BroadcasterStatusNotify";
        var body = {
            status: status
        };
        this.sendMessage(cmd, seq, sessionID, body);
    };
    ZegoSignal.prototype.sendNetProbe = function (seq, sessionID, peerID, success, error) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_NET_PROBE + " call " + sessionID);
        var cmd = "NetQualityProbeReq";
        var body = {
            peer_id: peerID,
            action: 1
        };
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    };
    ZegoSignal.prototype.sendNetQualityInfoPushAck = function (seq, sessionID, peerID, result) {
        this.logger.info(action_1.ZEGO_WEBRTC_ACTION.SIGNAL_SEND_NET_PROBE + " call " + sessionID);
        var cmd = "NetQualityInfoAck";
        var body = {
            peer_id: peerID,
            result: result
        };
        this.sendMessage(cmd, seq, sessionID, body);
    };
    ZegoSignal.prototype.activateSEIInsert = function (seq, sessionID, peerID, action, infoType, success, error) { };
    // 
    // 1 (one-way-delay),sdkp2p_rtt)  p2p_rtt / 2 
    // 2 jitter buffer jitter_delay
    //  jitter_delay =  googCurrentDelayMs()
    //  jitter_delay =  googCurrentDelayMs()
    //  p2p_delay = p2p_rtt / 2 + jitter_delay
    ZegoSignal.prototype.getP2PNetStats = function (seq, sessionID, peerID, success, error) {
        var cmd = "Peer2PeerNetStatsGetReq";
        var body = {
            peer_id: peerID
        };
        this.sendMessageWithCallback(cmd, seq, sessionID, body, success, error);
    };
    return ZegoSignal;
}());
exports.ZegoSignal = ZegoSignal;


/***/ }),

/***/ "./sdk/src/webrtc/modules/zego.streamCenter.web.ts":
/*!*********************************************************!*\
  !*** ./sdk/src/webrtc/modules/zego.streamCenter.web.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ZegoStreamCenterWeb = void 0;
var zego_entity_1 = __webpack_require__(/*! ../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var zego_preview_1 = __webpack_require__(/*! ./publishModules/zego.preview */ "./sdk/src/webrtc/modules/publishModules/zego.preview.ts");
var zego_publish_1 = __webpack_require__(/*! ./publishModules/zego.publish */ "./sdk/src/webrtc/modules/publishModules/zego.publish.ts");
var streamCenter_1 = __webpack_require__(/*! ../../common/streamCenter */ "./sdk/src/common/streamCenter.ts");
var zego_entity_2 = __webpack_require__(/*! ../../common/zego.entity */ "./sdk/src/common/zego.entity.ts");
var streamSignal_1 = __webpack_require__(/*! ./streamSignal */ "./sdk/src/webrtc/modules/streamSignal.ts");
var zego_play_web_1 = __webpack_require__(/*! ./playModules/zego.play.web */ "./sdk/src/webrtc/modules/playModules/zego.play.web.ts");
var retryStreamHandler_1 = __webpack_require__(/*! ./externModules/retryStreamHandler */ "./sdk/src/webrtc/modules/externModules/retryStreamHandler.ts");
var retryDispatchHandler_1 = __webpack_require__(/*! ./externModules/retryDispatchHandler */ "./sdk/src/webrtc/modules/externModules/retryDispatchHandler.ts");
var zego_error_1 = __webpack_require__(/*! ../../common/zego.error */ "./sdk/src/common/zego.error.ts");
var zego_log_event_1 = __webpack_require__(/*! ../../common/zego.log.event */ "./sdk/src/common/zego.log.event.ts");
var speed_log_1 = __webpack_require__(/*! ../../proto/speed_log */ "./sdk/src/proto/speed_log.js");
var ZegoStreamCenterWeb = /** @class */ (function (_super) {
    __extends(ZegoStreamCenterWeb, _super);
    function ZegoStreamCenterWeb(logger, stateCenter, dataReport, rtm, ac, mediaEleSources) {
        var _this = _super.call(this) || this;
        _this.logger = logger;
        _this.stateCenter = stateCenter;
        _this.dataReport = dataReport;
        _this.rtm = rtm;
        _this.ac = ac;
        _this.mediaEleSources = mediaEleSources;
        _this.testEnvironment = false;
        //streamcentersignal
        _this.heartbeatTimer = null;
        _this.heartbeatInterval = 10 * 1000;
        //,3s
        _this.qualityTimerInterval = 3 * 1000;
        _this.previewStreamList = [];
        _this.signalList = {};
        //
        _this.chargeInfos = {
            itemtype: "ChargeInfos",
            timestamp_begin: 0,
            timestamp_end: 0,
            timestamp_diff_flag: 0,
            timestamp_diff: 0,
            infos: []
        };
        _this.chargeInfosTimer = null;
        _this.chargeInfosInterval = 60 * 1000;
        _this.chargeInfoSeq = 0;
        _this.soundLevelDelegate = false;
        _this.soundLevelInterval = 1000;
        //peer
        _this.isPeer = true;
        //
        _this.probeList = {};
        // 
        _this.isMicEnabled = true;
        //datachannel
        _this.isDataChannelEnabled = false;
        //
        _this.publishQualityInfos = [];
        _this.playQualityInfos = [];
        _this.qualityUploadTimestamp = 0;
        _this.qualityHeadTimestamp = 0;
        //gwNode
        _this.gwNode = "";
        _this.playerList = {};
        _this.publisherList = {};
        _this.playSuccessCallBackList = {};
        _this.playErrorCallBackList = {};
        _this.waitPublishList = [];
        _this.waitPlayList = [];
        _this.tryCountConnectInterval = 3000;
        _this.checkMessageTimeout = function () {
            for (var serverUrl in _this.signalList) {
                if (_this.signalList[serverUrl].signal) {
                    _this.signalList[serverUrl].signal.checkMessageTimeout();
                }
            }
        };
        _this.getAllInUseUrl = function () {
            var serverUrls = [];
            for (var serverUrl in _this.signalList) {
                serverUrls.push(serverUrl);
            }
            return serverUrls;
        };
        // 
        _this.onDisconnectHandle = function (server, error) {
            _this.logger.info("zsc.od.0 call");
            if (_this.signalList[server]) {
                var signalInfo = _this.signalList[server];
                for (var i = 0; i < signalInfo.publishConnectedList.length; i++) {
                    var publish = _this.publisherList[signalInfo.publishConnectedList[i]];
                    if (publish && publish.publisher) {
                        publish.publisher.onDisconnect(error);
                    }
                }
                for (var i = 0; i < signalInfo.playConnectedList.length; i++) {
                    var play = _this.playerList[signalInfo.playConnectedList[i]];
                    if (play && play.player) {
                        play.player.onDisconnect(error);
                    }
                }
                delete _this.signalList[server];
                _this.stopSignalHeartbeat();
                _this.stopChargeInfosUpload();
                _this.stopSoundLevel();
            }
        };
        _this.stateCenter.type == "PRIVATE" && (_this.isPeer = false);
        return _this;
    }
    Object.defineProperty(ZegoStreamCenterWeb.prototype, "cameraPreviewStream", {
        /**
         * 
         */
        get: function () {
            return this.previewStreamList.find(function (item) {
                return item.previewType === "camera";
            });
        },
        enumerable: false,
        configurable: true
    });
    ZegoStreamCenterWeb.prototype.onSignalDisconnected = function (server) { };
    /*
     *    "zsc.qmc.0": "ZegoStreamCenter.setQualityMonitorCycle"
     */
    ZegoStreamCenterWeb.prototype.setQualityMonitorCycle = function (timeInMs) {
        var _this = this;
        this.logger.debug("zsc.qmc.0 timeInterval " + timeInMs);
        if (Object.keys(this.publisherList).length == 0) {
            this.qualityTimerInterval = timeInMs;
        }
        else {
            Object.keys(this.publisherList).forEach(function (streamid) {
                _this.publisherList[streamid].publisher.qualityTimeInterval = timeInMs;
                _this.publisherList[streamid].publisher.setPublishQualityTimer();
            });
        }
        return true;
    };
    /*
     *    "zsc.ssi.0": "ZegoStreamCenter.setSessionInfo"
     */
    ZegoStreamCenterWeb.prototype.setSessionInfo = function (appid, userid, testEnvironment) {
        this.logger.debug("zsc.ssi.0 called");
        // this.signal.setSessionInfo(appid, userid, serverUrl);
        this.appid = appid;
        this.userid = userid;
        this.testEnvironment = testEnvironment;
    };
    ZegoStreamCenterWeb.prototype.onPlayStateUpdate = function (type, streamid, error) { };
    ZegoStreamCenterWeb.prototype.onPlayQualityUpdate = function (streamID, streamQuality) { };
    ZegoStreamCenterWeb.prototype.onPublishStateUpdate = function (type, streamid, error) { };
    ZegoStreamCenterWeb.prototype.onPublishQualityUpdate = function (streamID, streamQuality) { };
    ZegoStreamCenterWeb.prototype.onUpdateHeartBeatIntervalHandle = function (interval) {
        if (interval != this.heartbeatInterval) {
            this.logger.debug("zsc.uhb.0 update " + interval);
            if (this.heartbeatTimer) {
                clearTimeout(this.heartbeatTimer);
                this.heartbeatTimer = null;
            }
            this.heartbeatInterval = interval;
            this.startSignalHeartbeat();
        }
    };
    ZegoStreamCenterWeb.prototype.setPublishStateStart = function (room, streamid, localStream, publishOption, isDataChannel) {
        var _this = this;
        var _a, _b;
        this.logger.info("zsc.pss.0 call " + streamid);
        if (this.stateCenter.networkState == zego_entity_1.ENUM_NETWORK_STATE.offline) {
            this.logger.error("zsc.pss.0 network offline");
            return false;
        }
        var publish = this.publisherList[streamid];
        var reportSeq = this.stateCenter.reportSeqList.startPublish[streamid];
        this.dataReport.eventStart(reportSeq, "setPublishState");
        if (publish) {
            this.logger.error("zsc.pss.0 publisher already exist");
            this.dataReport.eventEndWithMsgInfo(reportSeq, "setPublishState", {
                message: "publisher already exist"
            });
            this.dataReport.uploadReport(reportSeq, undefined, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.error.kIsPublishing);
            delete this.stateCenter.reportSeqList.startPublish[streamid];
            return false;
        }
        var publisher = new zego_publish_1.ZegoPublish(streamid, this.logger, this.dataReport, this.qualityTimerInterval, this, this.ac, this.mediaEleSources, this.stateCenter, localStream);
        publisher.state = zego_entity_2.ENUM_PUBLISH_STATE.start;
        publisher.isPeer = this.isPeer;
        publisher.reportSeq = this.stateCenter.reportSeqList.startPublish[streamid];
        var previewer = publisher.previewer;
        var cameraLabel = (_a = previewer === null || previewer === void 0 ? void 0 : previewer.videoTrack) === null || _a === void 0 ? void 0 : _a.label;
        var microLabel = localStream.getAudioTracks()[0] && localStream.getAudioTracks()[0].label;
        var cameraDeviceId = (_b = previewer === null || previewer === void 0 ? void 0 : previewer.videoTrack) === null || _b === void 0 ? void 0 : _b.getSettings().deviceId;
        var microDeviceId = localStream.getAudioTracks()[0] &&
            localStream.getAudioTracks()[0].getSettings().deviceId;
        var retryStreamHandler = new retryStreamHandler_1.RetryStreamHandler(this.logger, this.stateCenter, this, true);
        this.publisherList[streamid] = {
            seq: 0,
            room: room,
            localStream: localStream,
            publisher: publisher,
            serverUrls: [],
            ttl: 0,
            isCenterNode: true,
            streamID: streamid,
            publishOption: publishOption,
            cameraLabel: cameraLabel || "",
            microLabel: microLabel || "",
            cameraDeviceId: cameraDeviceId || "",
            microDeviceId: microDeviceId || "",
            deviceStateCount: 0,
            retryStreamHandler: retryStreamHandler,
            retryDispatchHandler: new retryDispatchHandler_1.RetryDispatchHandler(this.logger, this.stateCenter, this.rtm, this),
            isDataChannel: isDataChannel
        };
        publisher.onPublishStateUpdate = function (type, _streamid, error, stopRetry) {
            var publish = _this.publisherList[_streamid];
            if (publish) {
                retryStreamHandler.publishStateHandle(type, publish.streamID, error, stopRetry);
            }
            else {
                _this.logger.error("zsc.psuh.0 cannot find publish " + streamid);
            }
        };
        publisher.onPublishQualityUpdate = function (_streamid, streamQuality) {
            var publish = _this.publisherList[_streamid];
            if (publish) {
                if (_this.stateCenter.deviceStateOut &&
                    streamQuality.audio.audioBitrate === 0) {
                    publish.deviceStateCount++;
                    if (publish.deviceStateCount >= 2) {
                        publish.deviceStateCount = 0;
                        _this.stateCenter.deviceStateOut = false;
                        _this.logger.warn("zsc.pss.0 publish audio error by device");
                        // this.onPublishStateUpdate(
                        //     ENUM_PUBLISH_STATE_UPDATE.error,
                        //     publish.streamID,
                        //     errorCodeList.PUBLISH_DEVICE_OUT_ERR,
                        // );
                    }
                }
                else {
                    publish.deviceStateCount = 0;
                }
                _this.onPublishQualityUpdate(publish.streamID, streamQuality);
            }
            else {
                _this.logger.error("zsc.psuh.0 cannot find publish " + streamid);
            }
        };
        this.dataReport.eventStart(publisher.reportSeq, "GetSignalUrl");
        this.dataReport.eventStart(publisher.streamReportSeq, "GetSignalUrl");
        return true;
    };
    ZegoStreamCenterWeb.prototype.startPublishingStream = function (streamid, useNetAgent) {
        if (useNetAgent === void 0) { useNetAgent = false; }
        this.logger.info("zsc.sps.0 call");
        //const totalStreamid = this.getTotalStreamId(streamid);
        var publish = this.publisherList[streamid];
        if (!publish) {
            this.logger.error("zsc.sps.0 publisher don't exist");
            return false;
        }
        var publisher = publish.publisher;
        if (useNetAgent) {
            // TODO: 
        }
        else {
            // 
            this.dataReport.eventEndWithMsg(publisher.reportSeq, "GetSignalUrl", {
                urls: publish.serverUrls,
                is_center: publish.isCenterNode
            });
            this.dataReport.eventEndWithMsg(publisher.streamReportSeq, "GetSignalUrl", {
                urls: publish.serverUrls,
                is_center: publish.isCenterNode
            });
            if (!publish.serverUrls || publish.serverUrls.length === 0) {
                publish.retryStreamHandler.publishStateHandle(zego_entity_2.ENUM_PUBLISH_STATE_UPDATE.error, streamid, zego_error_1.errorCodeList.DISPATCH_ERROR);
                this.logger.info("zsc.sps.0 server don't have signal url");
                return true;
            }
            var index = publish.serverUrls.indexOf(this.server);
            if (index !== -1) {
                publish.serverUrls.splice(index, 1);
                publish.serverUrls.unshift(this.server);
            }
        }
        var retryStreamHandler = publish.retryStreamHandler;
        //
        retryStreamHandler.invalid();
        retryStreamHandler.init(this.stateCenter.streamRetryTime);
        retryStreamHandler.initStream(streamid, publish.serverUrls);
        retryStreamHandler.startMaxTime();
        return retryStreamHandler.activePublish(0);
    };
    ZegoStreamCenterWeb.prototype.updateWaitingList = function (signalInfo, isPublish, streamID, success, error) {
        var waitingItem = {
            streamID: streamID,
            success: success,
            error: error
        };
        if (isPublish) {
            signalInfo.publishWaitingList.push(waitingItem);
        }
        else {
            signalInfo.playWaitingList.push(waitingItem);
        }
    };
    ZegoStreamCenterWeb.prototype.publishStream = function (streamid) {
        var publisher = this.publisherList[streamid].publisher;
        if (!publisher) {
            this.logger.info("zsc.ps.0 publisher don't exist");
            return;
        }
        var localStream = null, videoInfo = null;
        var publishOption = this.publisherList[streamid].publishOption;
        var preview = this.checkPreview(this.publisherList[streamid].localStream);
        if (preview) {
            localStream = preview.localStream;
            videoInfo = preview.videoInfo;
            var reportSeq = this.stateCenter.reportSeqList.startPublish[streamid];
            this.dataReport.addMsgInfo(reportSeq, {
                cap_w: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.cap_w(preview.videoInfo.width),
                cap_h: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.cap_h(preview.videoInfo.height),
                w: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.w(preview.videoInfo.width),
                h: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.h(preview.videoInfo.height),
                video_en_fps: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.video_en_fps(preview.videoInfo.frameRate),
                video_en_bps: zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPublishStart.video_en_bps(preview.videoInfo.bitRate)
            });
        }
        else {
            this.logger.error("zsc.ps.0 no preview found");
            return;
        }
        if (!localStream) {
            this.logger.error("zsc.ps.0 no localStream found");
            return;
        }
        this.logger.info("zsc.ps.0 call success");
        if (publisher.gwNodeTTL < new Date().getTime() && !this.gwNode) {
            publisher.gwNode = "";
            publisher.gwNodeList = [];
            publisher.gwNodeTTL = 0;
        }
        else if (this.gwNode) {
            publisher.gwNode = this.gwNode;
        }
        publisher.startPublish(streamid, localStream, videoInfo, preview.mediaStreamConfig, publishOption);
    };
    ZegoStreamCenterWeb.prototype.connectPublishServer = function (streamID, server) {
        var _this = this;
        var publish = this.publisherList[streamID];
        if (!publish) {
            this.logger.error("zsc.cps.0 publisher don't exist");
            return false;
        }
        this.dataReport.eventStart(publish.publisher.reportSeq, "ConnectServer");
        this.dataReport.eventStart(publish.publisher.streamReportSeq, "ConnectServer");
        var useNetAgent = this.stateCenter.useNetAgent;
        this.connectWithReuseSignalServer(streamID, true, server, function (streamid, signalInfo, serverUrl) {
            //check streamid exist
            var checkPublish = _this.publisherList[streamid];
            if (!checkPublish) {
                _this.logger.info("zsc.cps.0 after connect publisher don't exist");
                return;
            }
            var checkPublisher = checkPublish.publisher;
            if (!checkPublisher) {
                _this.logger.info("zsc.cps.1 check publisher don't exist");
                return;
            }
            _this.dataReport.eventEndWithMsg(checkPublisher.reportSeq, "ConnectServer", {
                result: 0,
                server: serverUrl
            });
            _this.dataReport.eventEndWithMsg(checkPublisher.streamReportSeq, "ConnectServer", {
                result: 0,
                server: serverUrl
            });
            var tokenInfo = signalInfo.tokenInfo;
            _this.logger.info("zsc.cps.0 update token success");
            if (tokenInfo && tokenInfo.report) {
                checkPublisher.qualityUpload = tokenInfo.report;
                checkPublisher.qualityUploadInterval = tokenInfo.report_interval;
            }
            checkPublisher.signal = signalInfo.signal;
            _this.server = serverUrl;
            _this.publishStream(streamid);
            _this.getTokenSuccess();
        }, function (streamID, result) {
            _this.logger.error("zsc.cps.0 " + streamID + " connect fail " + result);
            //check streamid exist
            var checkPublish = _this.publisherList[streamID];
            if (!checkPublish) {
                _this.logger.info("zsc.cps.0 after connect publisher don't exist");
                return;
            }
            var checkPublisher = checkPublish.publisher;
            if (!checkPublisher) {
                _this.logger.info("zsc.cps.1 check publisher don't exist");
                return;
            }
            _this.dataReport.eventEndWithMsg(checkPublisher.reportSeq, "ConnectServer", {
                result: result
            });
            _this.dataReport.uploadReport(checkPublisher.reportSeq);
            delete _this.stateCenter.reportSeqList.startPublish[streamID];
            var error;
            var stopRetry = false;
            if (result && result.code === zego_error_1.errorCodeList.GET_CONFIG_FAIL.code) {
                error = zego_error_1.errorCodeList.GET_CONFIG_FAIL;
                stopRetry = true;
            }
            else {
                error = __assign({}, zego_error_1.errorCodeList.CONNECT_FAILED);
                error.message = error.message + " " + result;
                if (result === 1008) {
                    error = zego_error_1.errorCodeList.TOKEN_EXPIRED;
                    stopRetry = true;
                }
            }
            checkPublish.retryStreamHandler.publishStateHandle(zego_entity_2.ENUM_PUBLISH_STATE_UPDATE.error, streamID, error, stopRetry);
        });
        return true;
    };
    /*
     *    "zsc.gts.0": "ZegoStreamCenter.getTokenSuccess"
     */
    ZegoStreamCenterWeb.prototype.getTokenSuccess = function () {
        this.logger.debug("zsc.gts.0 call");
    };
    /*
     *    "zsc.sps.0.1": "ZegoStreamCenter.stopPublishingStream"
     */
    ZegoStreamCenterWeb.prototype.stopPublishingStream = function (streamid) {
        //const totalStreamId = this.getTotalStreamId(streamid);
        var publish = this.publisherList[streamid];
        if (!publish) {
            this.logger.warn("zsc.sps.0.1 publisher don't exist");
            return;
        }
        var retryStreamHandler = publish.retryStreamHandler;
        //
        if (retryStreamHandler) {
            retryStreamHandler.stopMaxTime();
            retryStreamHandler.invalid();
        }
        for (var signalUrl in this.signalList) {
            this.signalList[signalUrl].publishWaitingList = this.signalList[signalUrl].publishWaitingList.filter(function (info) { return info.streamID !== streamid; });
        }
        delete this.publisherList[streamid];
        if (publish.publisher) {
            publish.publisher.stopPublish();
            //@ts-ignore
            delete publish.publisher;
        }
        //update signal
        this.removeStreamFromSignal(true, streamid);
        this.stopSignalHeartbeat();
        this.stopChargeInfosUpload();
        this.stopSoundLevel();
        this.logger.debug("zsc.sps.0.1 call success");
    };
    /*
     *    "zsc.crss.0": "ZegoStreamCenter.connectWithReuseSignalServer"
     */
    ZegoStreamCenterWeb.prototype.connectWithReuseSignalServer = function (streamID, isPublish, serverUrl, success, error) {
        var _this = this;
        this.logger.info("zsc.crss.0 begin " + serverUrl);
        var signalInfo = null;
        if (this.signalList[serverUrl]) {
            signalInfo = this.signalList[serverUrl];
            //already connected
            if (signalInfo.state == zego_entity_2.ENUM_SIGNAL_STATE.connected) {
                this.logger.info("zsc.crss.0 already connected " + serverUrl + " streamId: " + streamID);
                if (isPublish) {
                    signalInfo.publishConnectedList.push(streamID);
                }
                else {
                    signalInfo.playConnectedList.push(streamID);
                }
                success(streamID, signalInfo, serverUrl);
            }
            else if (signalInfo.state == zego_entity_2.ENUM_SIGNAL_STATE.connecting) {
                //isConnecting
                this.logger.info("zsc.crss.0 signal is connecting " +
                    serverUrl +
                    " streamId: " +
                    streamID);
                this.updateWaitingList(signalInfo, isPublish, streamID, success, error);
            }
        }
        else {
            //no connect
            this.logger.info("zsc.crss.0 new signal " + serverUrl + ", streamId: " + streamID);
            var useNetAgent_1 = this.stateCenter.useNetAgent;
            var signal = new streamSignal_1.ZegoSignal(this.logger, this.stateCenter, this.rtm.netAgent, useNetAgent_1);
            signal.setSessionInfo(this.appid, this.userid);
            if (!useNetAgent_1) {
                signal.onUpdateHeartBeatInterval = this.onUpdateHeartBeatIntervalHandle.bind(this);
            }
            // signal.onSocketCloseCallBack = (): void => {
            //     this.stopSignalHeartbeat();
            // };
            // 
            signal.onDisconnect = this.onDisconnectHandle;
            var publishAndPlay = this.publisherList[streamID] || this.playerList[streamID] || null;
            // 
            var streamRetry = publishAndPlay === null || publishAndPlay === void 0 ? void 0 : publishAndPlay.retryStreamHandler;
            if (this.stateCenter.streamConnectTime) {
                signal.tryConnectInterval = this.stateCenter.streamConnectTime;
            }
            else if (streamRetry && streamRetry.retryActiveCount) {
                var _tryConnectInterval = (streamRetry.retryActiveCount * (streamRetry.retryActiveCount - 1)) /
                    2 +
                    2;
                _tryConnectInterval =
                    _tryConnectInterval > zego_entity_2.MAX_RETRY_CONNECT_INTERVAL
                        ? zego_entity_2.MAX_RETRY_CONNECT_INTERVAL
                        : _tryConnectInterval;
                signal.tryConnectInterval = _tryConnectInterval * 1000;
            }
            this.signalList[serverUrl] = {
                signal: signal,
                state: zego_entity_2.ENUM_SIGNAL_STATE.connecting,
                publishWaitingList: [],
                playWaitingList: [],
                publishConnectedList: [],
                playConnectedList: [],
                tokenInfo: null
            };
            this.updateWaitingList(this.signalList[serverUrl], isPublish, streamID, success, error);
            var token = publishAndPlay === null || publishAndPlay === void 0 ? void 0 : publishAndPlay.room.token;
            var roomID = publishAndPlay === null || publishAndPlay === void 0 ? void 0 : publishAndPlay.room.roomID;
            this.logger.info("zsc.crss.0 " + token);
            // 
            signal.connectServer(roomID ? roomID : this.stateCenter.roomList[0].roomID, token ? token : this.stateCenter.roomList[0].token, serverUrl, function (result, server, tokenInfo) {
                signalInfo = _this.signalList[serverUrl];
                if (result != 0) {
                    //connected failed, notify and delete
                    _this.logger.info("zsc.crss.0 connect failed " + server);
                    // 
                    signalInfo.publishWaitingList.forEach(function (item) {
                        if (item.error) {
                            item.error(item.streamID, result);
                        }
                    });
                    signalInfo.playWaitingList.forEach(function (item) {
                        if (item.error) {
                            item.error(item.streamID, result);
                        }
                    });
                    delete _this.signalList[serverUrl];
                }
                else {
                    //connected success, notify and update state
                    _this.logger.debug("zsc.crss.0 connected success " + server);
                    signalInfo.state = zego_entity_2.ENUM_SIGNAL_STATE.connected;
                    signalInfo.tokenInfo = tokenInfo;
                    // 
                    signalInfo.publishWaitingList.forEach(function (item) {
                        if (item.success) {
                            item.success(item.streamID, signalInfo, server);
                        }
                        signalInfo && signalInfo.publishConnectedList.push(item.streamID);
                    });
                    signalInfo.playWaitingList.forEach(function (item) {
                        if (item.success) {
                            item.success(item.streamID, signalInfo, server);
                        }
                        signalInfo && signalInfo.playConnectedList.push(item.streamID);
                    });
                    signalInfo.publishWaitingList = [];
                    signalInfo.playWaitingList = [];
                    // !useNetAgent &&
                    if (!useNetAgent_1 && _this.heartbeatTimer == null)
                        _this.startSignalHeartbeat();
                    // TODO: 
                    if (_this.chargeInfosTimer == null)
                        _this.startChargeInfosUpload();
                    _this.activeSoundLevel();
                }
            });
        }
    };
    ZegoStreamCenterWeb.prototype.setPlayStateStart = function (streamid, playOption, isDataChannel) {
        var _this = this;
        this.logger.info("zsc.pss.1 call " + streamid);
        if (this.stateCenter.networkState == zego_entity_1.ENUM_NETWORK_STATE.offline) {
            this.logger.error("zsc.pss.1 network offline");
            return false;
        }
        var play = this.playerList[streamid];
        var reportSeq = this.stateCenter.reportSeqList.startPlay[streamid];
        this.dataReport.eventStart(reportSeq, "setPlayState");
        if (play) {
            this.logger.error("zsc.pss.1 player already exist");
            this.dataReport.eventEndWithMsgInfo(reportSeq, "setPlayState", {
                message: "player already exist"
            });
            this.dataReport.uploadReport(reportSeq, undefined, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kIsPlaying);
            delete this.stateCenter.reportSeqList.startPlay[streamid];
            return false;
        }
        var room = this.getPlayRoom(streamid) || this.stateCenter.roomList[0];
        // TODO
        // 
        if (!room) {
            this.logger.error("zsc.pss.1 not login room");
            this.dataReport.eventEndWithMsgInfo(reportSeq, "setPlayState", {
                message: "not login room"
            });
            this.dataReport.uploadReport(reportSeq, undefined, zego_log_event_1.ZegoRTCLogEvent.kZegoTaskPlayStart.error.kPlayNoLoginError);
            return false;
        }
        var player = new zego_play_web_1.ZegoPlayWeb(this.logger, null, this.dataReport, this.qualityTimerInterval, this, this.ac, this.stateCenter);
        if (playOption && [0, 2, 3].includes(playOption.resourceMode)) {
            player.resourceMode = playOption.resourceMode;
        }
        this.dataReport.addMsgInfo(reportSeq, {
            resourceMode: player.resourceMode,
            play_room_id: room === null || room === void 0 ? void 0 : room.roomID,
            isMulti: this.stateCenter.isMultiRoom
        });
        player.state = zego_entity_2.ENUM_PLAY_STATE.start;
        player.isPeer = this.isPeer;
        player.reportSeq = this.stateCenter.reportSeqList.startPlay[streamid];
        player.beginTime = new Date().getTime();
        var retryStreamHandler = new retryStreamHandler_1.RetryStreamHandler(this.logger, this.stateCenter, this, false);
        this.playerList[streamid] = {
            seq: 0,
            room: room,
            player: player,
            signal: null,
            serverUrls: [],
            ttl: 0,
            isCenterNode: true,
            streamID: streamid,
            playOption: playOption,
            retryStreamHandler: retryStreamHandler,
            retryDispatchHandler: new retryDispatchHandler_1.RetryDispatchHandler(this.logger, this.stateCenter, this.rtm, this),
            isDataChannel: isDataChannel
        };
        player.onPlayStateUpdate = function (type, _streamid, error, stopRetry) {
            var play = _this.playerList[_streamid];
            if (play) {
                retryStreamHandler.playStateHandle(type, play.streamID, error, stopRetry);
            }
            else {
                _this.logger.error("zsc.pss.1 cannot find play " + _streamid);
            }
        };
        player.onPlayQualityUpdate = function (_streamid, streamQuality) {
            var play = _this.playerList[_streamid];
            if (play) {
                _this.onPlayQualityUpdate(play.streamID, streamQuality);
            }
            else {
                _this.logger.error("zsc.pss.1 cannot find play " + _streamid);
            }
        };
        player.onRemoteCameraStatusUpdate = function (_streamid, status, originalStatus) {
            var play = _this.playerList[_streamid];
            if (play) {
                _this.onRemoteCameraStatusUpdate(play.streamID, status, originalStatus);
            }
            else {
                _this.logger.error("zsc.pss.1 cannot find play " + _streamid);
            }
        };
        player.onRemoteMicStatusUpdate = function (_streamid, status, originalStatus) {
            var play = _this.playerList[_streamid];
            if (play) {
                _this.onRemoteMicStatusUpdate(play.streamID, status, originalStatus);
            }
            else {
                _this.logger.error("zsc.pss.1 cannot find play " + _streamid);
            }
        };
        this.dataReport.eventStart(player.reportSeq, "GetSignalUrl");
        this.dataReport.eventStart(player.streamReportSeq, "GetSignalUrl");
        return true;
    };
    ZegoStreamCenterWeb.prototype.onRemoteMicStatusUpdate = function (streamID, status, initialStatus) { };
    ZegoStreamCenterWeb.prototype.onRemoteCameraStatusUpdate = function (streamID, status, initialStatus) { };
    /*
     *    "zsc.sps.1": "ZegoStreamCenter.startPlayingStream"
     */
    ZegoStreamCenterWeb.prototype.startPlayingStream = function (streamid, useNetAgent, success) {
        if (useNetAgent === void 0) { useNetAgent = false; }
        this.logger.info("zsc.sps.1 start play called");
        //const totalStreamId = this.getTotalStreamId(streamid);
        var play = this.playerList[streamid];
        if (!play) {
            this.logger.error("zsc.sps.1 player don't exist");
            return false;
        }
        var player = play.player;
        if (useNetAgent) {
            // TODO: 
        }
        else {
            // 
            this.dataReport.eventEndWithMsg(player.reportSeq, "GetSignalUrl", {
                urls: play.serverUrls
            });
            this.dataReport.eventEndWithMsg(player.streamReportSeq, "GetSignalUrl", {
                urls: play.serverUrls
            });
            if (play.serverUrls.length == 0) {
                play.retryStreamHandler.playStateHandle(zego_entity_2.ENUM_PLAY_STATE_UPDATE.error, streamid, zego_error_1.errorCodeList.DISPATCH_ERROR);
                this.logger.info("zsc.sps.1 server don't have signal url");
                return false;
            }
            // this.server serverUrls
            var index = play.serverUrls.indexOf(this.server);
            if (index !== -1) {
                play.serverUrls.splice(index, 1);
                play.serverUrls.unshift(this.server);
            }
        }
        var retryStreamHandler = play.retryStreamHandler;
        //
        retryStreamHandler.invalid();
        retryStreamHandler.init(this.stateCenter.streamRetryTime);
        retryStreamHandler.initStream(streamid, play.serverUrls);
        retryStreamHandler.startMaxTime();
        return retryStreamHandler.activePull(0, success);
    };
    /*
     *    "zsc.cps.1": "ZegoStreamCenter.connectPlayServer"
     */
    ZegoStreamCenterWeb.prototype.connectPlayServer = function (streamId, success, server) {
        var _this = this;
        var play = this.playerList[streamId];
        if (!play) {
            this.logger.error("zsc.cps.1 player don't exist");
            return false;
        }
        this.dataReport.eventStart(play.player.reportSeq, "ConnectServer");
        this.dataReport.eventStart(play.player.streamReportSeq, "ConnectServer");
        this.connectWithReuseSignalServer(streamId, false, server, function (streamid, signalInfo, serverUrl) {
            //check streamid exist
            var checkPlay = _this.playerList[streamid];
            if (!checkPlay) {
                _this.logger.error("zsc.cps.1 after connect player don't exist");
                return;
            }
            var checkPlayer = checkPlay.player;
            if (!checkPlayer) {
                _this.logger.error("zsc.cps.1 checkplayer don't exist");
                return;
            }
            _this.dataReport.eventEndWithMsg(checkPlayer.reportSeq, "ConnectServer", {
                result: 0,
                server: serverUrl
            });
            _this.dataReport.eventEndWithMsg(checkPlayer.streamReportSeq, "ConnectServer", {
                result: 0,
                server: serverUrl
            });
            var tokenInfo = signalInfo.tokenInfo;
            _this.logger.info("zsc.cps.1 update token success");
            if (tokenInfo && tokenInfo.report) {
                checkPlayer.qualityHandler.qualityUpload = tokenInfo.report;
                checkPlayer.qualityHandler.qualityUploadInterval =
                    tokenInfo.report_interval;
            }
            checkPlayer.signal = signalInfo.signal;
            _this.server = serverUrl;
            _this.playStream(streamid, success);
            _this.getTokenSuccess();
        }, function (streamid, result) {
            var checkPlay = _this.playerList[streamid];
            if (!checkPlay) {
                _this.logger.error("zsc.cps.1 after connect player don't exist");
                return;
            }
            _this.dataReport.eventEndWithMsg(checkPlay.player.reportSeq, "ConnectServer", {
                result: result
            });
            !checkPlay.player.isProbe &&
                _this.dataReport.uploadReport(checkPlay.player.reportSeq);
            delete _this.stateCenter.reportSeqList.startPlay[streamId];
            var error = __assign({}, zego_error_1.errorCodeList.CONNECT_FAILED);
            error.message = error.message + " " + result;
            if (result === 1008) {
                error = zego_error_1.errorCodeList.TOKEN_EXPIRED;
            }
            checkPlay.retryStreamHandler.playStateHandle(zego_entity_2.ENUM_PLAY_STATE_UPDATE.error, streamid, error, 
            //1008 token 
            result == 1008 ? true : false);
        });
        return true;
    };
    ZegoStreamCenterWeb.prototype.playStream = function (streamid, success) {
        var player = this.playerList[streamid].player;
        if (!player) {
            this.logger.warn("zsc.ps.1 player don't exist");
            return;
        }
        this.logger.info("zsc.ps.1 call success");
        if (player.gwNodeTTL < new Date().getTime() && !this.gwNode) {
            player.gwNode = "";
            player.gwNodeList = [];
            player.gwNodeTTL = 0;
        }
        else if (this.gwNode) {
            player.gwNode = this.gwNode;
        }
        player.startPlay(streamid, success, this.playerList[streamid].playOption);
    };
    ZegoStreamCenterWeb.prototype.stopSignalHeartbeat = function () {
        this.logger.debug("zsc.ssh.1 call");
        var count = 0;
        for (var url in this.signalList) {
            count += 1;
        }
        if (this.heartbeatTimer && count == 0) {
            this.logger.info("zsc.ssh.1 stop");
            clearTimeout(this.heartbeatTimer);
            this.heartbeatTimer = null;
        }
    };
    ZegoStreamCenterWeb.prototype.removeStreamFromSignal = function (isPublish, streamID) {
        var deleteSignal = [];
        for (var serverUrl in this.signalList) {
            var signalInfo = this.signalList[serverUrl];
            if (isPublish) {
                for (var i = 0; i < signalInfo.publishConnectedList.length; i++) {
                    if (signalInfo.publishConnectedList[i] === streamID) {
                        this.logger.debug("zsc.rsfs.0 found from publish");
                        signalInfo.publishConnectedList.splice(i, 1);
                        break;
                    }
                }
                for (var i = 0; i < signalInfo.publishWaitingList.length; i++) {
                    if (signalInfo.publishWaitingList[i].streamID === streamID) {
                        this.logger.debug("zsc.rsfs.0 found from publish");
                        signalInfo.publishWaitingList.splice(i, 1);
                        break;
                    }
                }
            }
            else {
                for (var j = 0; j < signalInfo.playConnectedList.length; j++) {
                    if (signalInfo.playConnectedList[j] === streamID) {
                        this.logger.debug("zsc.rsfs.0 found from play");
                        signalInfo.playConnectedList.splice(j, 1);
                        break;
                    }
                }
                for (var j = 0; j < signalInfo.playWaitingList.length; j++) {
                    if (signalInfo.playWaitingList[j].streamID === streamID) {
                        this.logger.debug("zsc.rsfs.0 found from play");
                        signalInfo.playWaitingList.splice(j, 1);
                        break;
                    }
                }
            }
            if (signalInfo.publishConnectedList.length == 0 &&
                signalInfo.playConnectedList.length == 0 &&
                signalInfo.publishWaitingList.length == 0 &&
                signalInfo.playWaitingList.length == 0) {
                signalInfo.signal.disconnectServer();
                deleteSignal.push(serverUrl);
            }
        }
        for (var k = 0; k < deleteSignal.length; k++) {
            delete this.signalList[deleteSignal[k]];
            this.server == deleteSignal[k] && (this.server = "");
        }
    };
    ZegoStreamCenterWeb.prototype.stopPlayingStream = function (streamid) {
        //const totalStreamId = this.getTotalStreamId(streamid);
        var player = this.playerList[streamid];
        if (!player) {
            this.logger.info("zsc.sps.1.1 player don't exist");
            return;
        }
        var retryStreamHandler = player.retryStreamHandler;
        if (retryStreamHandler) {
            retryStreamHandler.stopMaxTime();
            retryStreamHandler.invalid();
        }
        // 
        // this.checkChargeInfos();
        for (var signalUrl in this.signalList) {
            this.signalList[signalUrl].playWaitingList = this.signalList[signalUrl].playWaitingList.filter(function (info) { return info.streamID !== streamid; });
        }
        delete this.playerList[streamid];
        if (player.player) {
            player.player.stopPlay();
            //@ts-ignore
            delete player.player;
        }
        //update signal
        this.removeStreamFromSignal(false, streamid);
        this.stopSignalHeartbeat();
        this.stopChargeInfosUpload();
        this.stopSoundLevel();
        delete this.playSuccessCallBackList[streamid];
        delete this.playErrorCallBackList[streamid];
        this.logger.debug("zsc.sps.1.1 call success");
    };
    ZegoStreamCenterWeb.prototype.reset = function (roomID) {
        // 
        // this.checkChargeInfos();
        // this.stopChargeInfosUpload();
        for (var publishStreamId in this.publisherList) {
            (this.publisherList[publishStreamId].room.roomID == roomID || !roomID) &&
                this.stopPublishingStream(publishStreamId);
        }
        var _loop_1 = function (playStreamId) {
            var room = this_1.playerList[playStreamId].room;
            if (room.roomID == roomID &&
                (!!room.streamList.find(function (stream) { return stream.stream_id == playStreamId; }) ||
                    this_1.stateCenter.roomList.length == 1)) {
                this_1.stopPlayingStream(playStreamId);
            }
            else if (room.roomID == roomID &&
                this_1.stateCenter.roomList.length > 1) {
                //
                var _room = this_1.stateCenter.roomList.find(function (roomInfo) { return roomInfo.roomID !== roomID; });
                _room
                    ? (this_1.playerList[playStreamId].room = _room)
                    : this_1.stopPlayingStream(playStreamId);
            }
        };
        var this_1 = this;
        for (var playStreamId in this.playerList) {
            _loop_1(playStreamId);
        }
        if (Object.keys(this.publisherList).length == 0 &&
            Object.keys(this.playerList).length == 0) {
            this.probeList = {};
        }
        this.waitPublishList = [];
        this.waitPlayList = [];
        //
        this.publishQualityInfos = [];
        this.playQualityInfos = [];
        this.qualityHeadTimestamp = 0;
        this.qualityUploadTimestamp = 0;
        if (this.qualityWebsocket) {
            this.qualityWebsocket.close();
            this.qualityWebsocket = undefined;
        }
    };
    ZegoStreamCenterWeb.prototype.startSignalHeartbeat = function () {
        var _this = this;
        this.logger.debug("zsc.ssh.0 call");
        if (this.heartbeatTimer) {
            clearTimeout(this.heartbeatTimer);
            this.heartbeatTimer = null;
        }
        this.heartbeatTimer = setTimeout(function () {
            _this.checkSignalHeartbeat();
        }, this.heartbeatInterval);
    };
    ZegoStreamCenterWeb.prototype.startChargeInfosUpload = function () {
        var _this = this;
        this.logger.debug("zsc.sciu.0 call");
        if (this.chargeInfosTimer) {
            clearTimeout(this.chargeInfosTimer);
            this.chargeInfosTimer = null;
        }
        this.chargeInfosTimer = setTimeout(function () {
            _this.checkChargeInfos();
        }, this.chargeInfosInterval);
    };
    ZegoStreamCenterWeb.prototype.checkChargeInfos = function () {
        this.logger.debug("zsc.cci.0 call");
        var chargeinfo = {
            is_publishing: 0,
            play_max_audio_bitrate: 0,
            play_stream_resolution_infos: []
        };
        this.chargeInfos.timestamp_begin = new Date().getTime();
        for (var j in this.publisherList) {
            var publisher = this.publisherList[j].publisher;
            publisher.state === zego_entity_2.ENUM_PUBLISH_STATE.publishing &&
                (chargeinfo.is_publishing = 1);
            break;
        }
        chargeinfo.play_max_audio_bitrate = 0;
        var _loop_2 = function (i) {
            var remoteStream = this_2.playerList[i].player.playStream;
            var videoInfo = remoteStream && remoteStream.getVideoTracks().length !== 0
                ? remoteStream.getVideoTracks()[0].getSettings()
                : undefined;
            var resolutionInfo = {
                video_width: videoInfo ? (videoInfo.width ? videoInfo.width : 0) : 0,
                video_height: videoInfo ? (videoInfo.height ? videoInfo.height : 0) : 0,
                count: 1
            };
            !chargeinfo.play_stream_resolution_infos.find(function (val) {
                if (val.video_width == resolutionInfo.video_width &&
                    val.video_height == resolutionInfo.video_height) {
                    val.count++;
                    return true;
                }
                else {
                    return false;
                }
            }) && chargeinfo.play_stream_resolution_infos.push(resolutionInfo);
            if (resolutionInfo.video_width == 0 && resolutionInfo.video_height == 0) {
                var audioBitrate = this_2.playerList[i].player.qualityHandler.lastPlayStats.audioBitrate *
                    1000;
                audioBitrate > chargeinfo.play_max_audio_bitrate &&
                    (chargeinfo.play_max_audio_bitrate = audioBitrate);
            }
        };
        var this_2 = this;
        for (var i in this.playerList) {
            _loop_2(i);
        }
        if (this.chargeInfos.timestamp_end !== 0) {
            this.chargeInfos.timestamp_diff =
                this.chargeInfos.timestamp_begin - this.chargeInfos.timestamp_end;
            this.chargeInfos.timestamp_diff_flag = 1;
        }
        else {
            this.chargeInfos.timestamp_diff = 0;
            this.chargeInfos.timestamp_diff_flag = 0;
        }
        this.chargeInfos.timestamp_end = new Date().getTime();
        this.chargeInfos.infos = [chargeinfo];
        chargeinfo.play_stream_resolution_infos.length !== 0 &&
            this.logger.report(this.chargeInfos);
        this.chargeInfosTimer && this.startChargeInfosUpload();
    };
    ZegoStreamCenterWeb.prototype.checkSignalHeartbeat = function () {
        this.logger.debug("zsc.csh.0 call");
        for (var streamUrl in this.signalList) {
            if (this.signalList[streamUrl].signal) {
                this.signalList[streamUrl].signal.sendHeartbeat();
            }
        }
        if (this.heartbeatTimer)
            this.startSignalHeartbeat();
    };
    ZegoStreamCenterWeb.prototype.stopChargeInfosUpload = function () {
        this.logger.debug("zsc.sciu.0 call");
        var count = 0;
        for (var url in this.signalList) {
            count += 1;
        }
        if (this.chargeInfosTimer && count == 0) {
            this.logger.info("zsc.sciu.0 stop");
            clearTimeout(this.chargeInfosTimer);
            this.chargeInfosTimer = null;
        }
    };
    ZegoStreamCenterWeb.prototype.getPublisher = function (streamID) {
        var publisher = null;
        //const tototalStreamId = this.getTotalStreamId(streamID);
        if (this.publisherList[streamID] &&
            this.publisherList[streamID].publisher) {
            publisher = this.publisherList[streamID].publisher;
        }
        return publisher;
    };
    ZegoStreamCenterWeb.prototype.checkPreview = function (localStream) {
        for (var i = 0; i < this.previewStreamList.length; i++) {
            if (this.previewStreamList[i].localStream === localStream) {
                return this.previewStreamList[i];
            }
        }
        return null;
    };
    ZegoStreamCenterWeb.prototype.checkPublish = function (localStream) {
        for (var streamID in this.publisherList) {
            if (this.publisherList[streamID].localStream == localStream) {
                return this.publisherList[streamID];
            }
        }
        return null;
    };
    ZegoStreamCenterWeb.prototype.removePreview = function (preview) {
        for (var i = 0; i < this.previewStreamList.length; i++) {
            if (this.previewStreamList[i] === preview) {
                this.previewStreamList.splice(i, 1);
                break;
            }
        }
    };
    ZegoStreamCenterWeb.prototype.onPlayerStreamUrlUpdate = function (streamid, url, type) { };
    // 
    ZegoStreamCenterWeb.prototype.getScreenConstrains = function (screen) {
        var config = {};
        if (typeof screen == "boolean" && screen) {
            config = {
                audio: false,
                frameRate: zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.MEDIUM.frameRate,
                bitRate: this.stateCenter.settingConfig.getSetting("screen_video_bitrate") ||
                    zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.MEDIUM.bitRate
            };
        }
        else if (typeof screen == "object") {
            switch (screen.videoQuality) {
                case 1:
                    config = {
                        frameRate: zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.LOW.frameRate,
                        bitRate: zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.LOW.bitRate
                    };
                    break;
                case 3:
                    config = {
                        frameRate: zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.HIGH.frameRate,
                        bitRate: zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.HIGH.bitRate
                    };
                    break;
                case 4:
                    config = {
                        frameRate: screen.frameRate,
                        bitRate: screen.bitRate,
                        width: screen.width,
                        height: screen.height
                    };
                    break;
                case 2:
                    config = {
                        frameRate: zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.MEDIUM.frameRate,
                        bitRate: zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.MEDIUM.bitRate
                    };
                    break;
                default:
                    config = {
                        frameRate: zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.MEDIUM.frameRate,
                        bitRate: this.stateCenter.settingConfig.getSetting("screen_video_bitrate") || zego_entity_2.ENUM_SCREEM_RESOLUTION_TYPE.MEDIUM.bitRate
                    };
                    break;
            }
            config.audio = typeof screen.audio == "boolean" ? screen.audio : false;
            config = __assign(__assign({}, screen), config);
        }
        return config;
    };
    ZegoStreamCenterWeb.prototype.createScreenPreviewer = function (stream, screenConfig) {
        var preview = new zego_preview_1.ZegoPreview(this.logger, this.ac, this.stateCenter, this, "screen");
        var videoInfo = stream.getVideoTracks()[0].getSettings();
        // this.stateCenter.screenShotStream = stream;
        this.previewStreamList.push(preview);
        preview.mediaStreamConfig = screenConfig;
        if (stream.getAudioTracks().length > 0)
            preview.audioTrack = stream.getAudioTracks()[0];
        preview.localStream = stream;
        preview.videoInfo = {
            width: videoInfo.width,
            height: videoInfo.height,
            frameRate: videoInfo.frameRate || 15,
            bitRate: (screenConfig === null || screenConfig === void 0 ? void 0 : screenConfig.bitRate) || 1000,
            startBitrate: (screenConfig === null || screenConfig === void 0 ? void 0 : screenConfig.startBitrate) ||
                this.stateCenter.settingConfig.getSetting("bitrate_mode")
        };
        preview.previewSuc = true;
        preview.previewType = "screen";
        // contentHint
        if (screenConfig === null || screenConfig === void 0 ? void 0 : screenConfig.videoOptimizationMode) {
            this.setVideoTrackContentHint(stream, screenConfig === null || screenConfig === void 0 ? void 0 : screenConfig.videoOptimizationMode);
        }
        return preview;
    };
    ZegoStreamCenterWeb.prototype.setSoundLevelDelegate = function (bool, timeInMs) {
        this.logger.info("zsc.ssd.0 call");
        timeInMs && (this.soundLevelInterval = timeInMs);
        this.soundLevelDelegate = bool;
        for (var i in this.previewStreamList) {
            var previwer = this.previewStreamList[i];
            if (bool) {
                previwer.startSoundLevel();
            }
            else {
                previwer.stopSoundLevel();
            }
        }
        // for (const i in this.publisherList) {
        //   const publisher = this.publisherList[i].publisher;
        //   if (publisher.previewer?.previewType !== "camera") {
        //     if (bool) {
        //       publisher.startSoundLevel();
        //     } else {
        //       publisher.stopSoundLevel();
        //     }
        //   }
        // }
        for (var i in this.playerList) {
            var player = this.playerList[i].player;
            if (bool) {
                player.startSoundLevel();
            }
            else {
                player.stopSoundLevel();
            }
        }
        if (!bool) {
            this.logger.info("zsc.ssd.0 stop getting sound");
            this.soundLevelTimer && clearTimeout(this.soundLevelTimer);
            this.soundLevelTimer = null;
            this.soundLevelInterval = 1000;
        }
        else {
            this.logger.info("zsc.ssd.0 start getting sound");
            this.activeSoundLevel();
        }
    };
    Object.defineProperty(ZegoStreamCenterWeb.prototype, "hasRemoteStream", {
        get: function () {
            return Object.keys(this.signalList).length > 0;
        },
        enumerable: false,
        configurable: true
    });
    // 
    ZegoStreamCenterWeb.prototype.activeSoundLevel = function () {
        if (!this.soundLevelTimer && this.soundLevelDelegate) {
            this.startSoundLevel();
        }
    };
    ZegoStreamCenterWeb.prototype.startSoundLevel = function () {
        var _this = this;
        if (this.soundLevelTimer) {
            clearTimeout(this.soundLevelTimer);
            this.soundLevelTimer = null;
        }
        if (this.soundLevelDelegate) {
            this.hasRemoteStream && this.checkSoundLevel();
            this.checkMicSoundLevel();
            this.soundLevelTimer = setTimeout(function () {
                _this.startSoundLevel();
            }, this.soundLevelInterval);
        }
    };
    /**
     * 
     */
    ZegoStreamCenterWeb.prototype.checkSoundLevel = function () {
        this.logger.debug("zsc.csl.0 call");
        var soundLevelList = [];
        for (var i in this.publisherList) {
            var soundLevel = 0;
            var publisher = this.publisherList[i].publisher;
            var previewer = publisher.previewer;
            if (previewer) {
                soundLevel = previewer.soundLevel;
            }
            soundLevelList.push({
                streamID: this.getBackStreamId(publisher.streamId),
                soundLevel: soundLevel,
                type: "push"
            });
        }
        for (var i in this.playerList) {
            var player = this.playerList[i].player;
            // 
            if (player.streamId && !player.isProbe) {
                soundLevelList.push({
                    streamID: this.getBackStreamId(player.streamId),
                    soundLevel: player.soundLevel,
                    type: "pull"
                });
            }
        }
        this.soundLevelDelegate &&
            soundLevelList.length > 0 &&
            this.onSoundLevelUpdate(soundLevelList);
    };
    /**
     * 
     */
    ZegoStreamCenterWeb.prototype.checkMicSoundLevel = function () {
        if (this.cameraPreviewStream && this.soundLevelDelegate) {
            var soundLevel = this.cameraPreviewStream.soundLevel;
            this.onMicSoundLevelUpdate(soundLevel);
        }
    };
    ZegoStreamCenterWeb.prototype.getBackStreamId = function (streamid) {
        if (this.testEnvironment && streamid) {
            var backStreamId = streamid.replace("zegotest-" + this.appid + "-", "");
            //this.logger.debug ('zsc.gbs.0 test back streamid ' + backStreamId);
            return backStreamId;
        }
        return streamid;
    };
    /** */
    ZegoStreamCenterWeb.prototype.onSoundLevelUpdate = function (soundLevelList) { };
    /** */
    ZegoStreamCenterWeb.prototype.onMicSoundLevelUpdate = function (soundLevel) { };
    ZegoStreamCenterWeb.prototype.stopSoundLevel = function () {
        // 
        // let count = 0;
        // for (const url in this.signalList) {
        //   count += 1;
        // }
        var count = this.previewStreamList.length;
        if (this.soundLevelTimer && !this.hasRemoteStream && count === 0) {
            this.logger.info("zsc.ssl.0 stop");
            clearTimeout(this.soundLevelTimer);
            this.soundLevelTimer = null;
        }
    };
    ZegoStreamCenterWeb.prototype.startNetProbe = function (isPublish, pushOrPull, nodeList) {
        var _this = this;
        var reportSeq = zego_entity_1.getReportSeq();
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoNetProbe.event);
        if (!this.isPeer) {
            //peer
            this.dataReport.uploadReport(reportSeq, undefined, {
                code: -1,
                message: "not support peer"
            });
            return;
        }
        var isCenter = true;
        if (nodeList.length == 0) {
            //
            isCenter = false;
            if (isPublish) {
                nodeList = this.publisherList[pushOrPull.streamId].serverUrls;
            }
            else {
                nodeList = this.playerList[pushOrPull.streamId].serverUrls;
            }
        }
        nodeList.forEach(function (gwNode) {
            if ((_this.probeList[gwNode] &&
                _this.probeList[gwNode].timeStamp + 15 * 60000 <
                    new Date().getTime()) ||
                pushOrPull.probeState == zego_entity_2.ENUM_PROBE_STATE.probed) {
                return;
            }
            var streamID = "zegoprobe-" + new Date().getTime();
            _this.setPlayStateStart(streamID);
            var prober = _this.playerList[streamID]
                ? _this.playerList[streamID].player
                : null;
            if (!prober) {
                return;
            }
            prober.isProbe = true;
            if (isCenter) {
                //
                prober.gwNode = gwNode;
                prober.signal = pushOrPull.signal;
                prober.startPlay(streamID, function () { });
            }
            else {
                //
                _this.connectPlayServer(streamID, function () { }, gwNode);
            }
            prober.onCalNetQualityResult = function (result, netQuality) {
                _this.logger.info("zc.ocnqr.0 " + prober.gwNode + " " + result + " " + netQuality);
                _this.probeList[gwNode] = {
                    result: result,
                    netQuality: netQuality,
                    timeStamp: new Date().getTime()
                };
                if (pushOrPull.gwNode == gwNode || pushOrPull.signal.server == gwNode) {
                    pushOrPull.netQuality = netQuality;
                }
                else {
                    _this.handleCalNetQualityResult(isPublish, result, netQuality, pushOrPull, gwNode);
                }
                _this.stopPlayingStream(streamID);
            };
        });
        this.dataReport.addMsgInfo(reportSeq, {
            netQuality: pushOrPull.netQuality,
            nodeList: nodeList
        });
        this.dataReport.uploadReport(reportSeq);
    };
    ZegoStreamCenterWeb.prototype.handleCalNetQualityResult = function (isPublish, result, netQuality, pushOrPull, gwNode) {
        this.logger.info("zc.hcqr.0 " +
            pushOrPull.netQuality +
            " probe " +
            netQuality +
            " " +
            gwNode);
        if (result !== 0)
            return;
        var reportSeq = zego_entity_1.getReportSeq();
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTCLogEvent.kZegoNetProbeResult.event);
        var isSwitch = false;
        if (netQuality > Math.max(75, pushOrPull.netQuality + 20) &&
            pushOrPull.probeState == zego_entity_2.ENUM_PROBE_STATE.tryProbe) {
            isSwitch = true;
            if (isPublish) {
                //
                var publisher = pushOrPull;
                var streamID = publisher.streamId;
                var localStream = publisher.localStream;
                var videoInfo = publisher.videoInfo;
                var mediaStreamConfig = publisher.mediaStreamConfig;
                var publishOption = publisher.publishOption;
                if (publisher.sessionId != 0 &&
                    publisher.signal &&
                    publisher.shouldSendCloseSession()) {
                    //send close session request
                    publisher.signal.sendCloseSession(this.stateCenter.getSeq(), publisher.sessionId, 1);
                    publisher.signal.removeSession(publisher.sessionId);
                    publisher.closeSessionSignal = true;
                }
                publisher.resetPublish();
                if (this.publisherList[streamID].isCenterNode) {
                    publisher.gwNode = gwNode;
                    publisher.startPublish(streamID, localStream, videoInfo, mediaStreamConfig, publishOption);
                }
                else {
                    this.connectPublishServer(streamID, gwNode);
                }
            }
            else {
                //
                var player = pushOrPull;
                var streamID = player.streamId;
                var success = player.getRemoteStreamSuc;
                var playOption = player.playOption;
                if (player.sessionId != 0 &&
                    player.signal &&
                    player.shouldSendCloseSession()) {
                    //send close session request
                    player.signal.sendCloseSession(this.stateCenter.getSeq(), player.sessionId, 1);
                    player.signal.removeSession(player.sessionId);
                    player.closeSessionSignal = true;
                }
                player.resetPlay();
                if (this.playerList[streamID].isCenterNode) {
                    player.gwNode = gwNode;
                    player.startPlay(streamID, success, playOption);
                }
                else {
                    this.connectPlayServer(streamID, success, gwNode);
                }
            }
        }
        else {
            isSwitch = false;
            this.logger.warn("zc.hcqr.0 " +
                pushOrPull.netQuality +
                " probe " +
                netQuality +
                " " +
                gwNode);
        }
        this.dataReport.addMsgInfo(reportSeq, {
            isSwitch: isSwitch,
            isPublish: isPublish,
            streamID: pushOrPull.streamId,
            result: result,
            node: gwNode,
            netQuality: pushOrPull.netQuality,
            probeNetQuality: netQuality
        });
        this.dataReport.uploadReport(reportSeq);
        //
        pushOrPull.probeState = zego_entity_2.ENUM_PROBE_STATE.probed;
    };
    ZegoStreamCenterWeb.prototype.getRoomByStreamID = function (streamID) {
        if (this.publisherList[streamID]) {
            return this.publisherList[streamID].room;
        }
        else if (this.playerList[streamID]) {
            return this.playerList[streamID].room;
        }
        else {
            return undefined;
        }
    };
    ZegoStreamCenterWeb.prototype.setVideoTrackContentHint = function (stream, videoOptimizationMode) {
        if (typeof videoOptimizationMode !== "string") {
            this.logger.warn("zc.svtch videoOptimizationMode type wrong");
            return;
        }
        var contentHint = videoOptimizationMode.toLowerCase();
        if (!["default", "motion", "detail", "text"].includes(contentHint)) {
            this.logger.warn("zc.svtch videoOptimizationMode wrong");
            return;
        }
        var videoTrack = stream.getVideoTracks()[0];
        if (!videoTrack) {
            this.logger.warn("zc.svtch" + " video track no found");
            return;
        }
        if ("contentHint" in videoTrack) {
            this.logger.info("zc.svtch " + contentHint);
            videoTrack.contentHint =
                contentHint == "default" ? "" : contentHint;
        }
        else {
            this.logger.warn("zc.svtch mediaStreamTrack contentHint attribute not supported");
        }
    };
    ZegoStreamCenterWeb.prototype.getPlayRoom = function (streamID) {
        return this.stateCenter.roomList.find(function (room) {
            return !!room.streamList.find(function (streamInfo) { return streamInfo.stream_id == streamID; });
        });
    };
    ZegoStreamCenterWeb.prototype.getQualityHead = function (SpeedLogHeadBuffer, QualityEventBuffer) {
        var preHead = new Uint8Array(12);
        preHead[0] = 0;
        preHead[1] = 12;
        preHead[2] = SpeedLogHeadBuffer.length >> 8;
        preHead[3] = SpeedLogHeadBuffer.length - (preHead[2] << 8);
        preHead[4] = QualityEventBuffer.length >> 24;
        preHead[5] = (QualityEventBuffer.length - (preHead[4] << 24)) >> 16;
        preHead[6] =
            (QualityEventBuffer.length - (preHead[4] << 24) - (preHead[5] << 16)) >>
                8;
        preHead[7] =
            QualityEventBuffer.length -
                (preHead[4] << 24) -
                (preHead[5] << 16) -
                (preHead[6] << 8);
        var timestamp = Math.ceil(new Date().getTime() / 1000);
        preHead[8] = timestamp >> 24;
        preHead[9] = (timestamp - (preHead[8] << 24)) >> 16;
        preHead[10] = (timestamp - (preHead[8] << 24) - (preHead[9] << 16)) >> 8;
        preHead[11] =
            timestamp - (preHead[8] << 24) - (preHead[9] << 16) - (preHead[10] << 8);
        return preHead;
    };
    ZegoStreamCenterWeb.prototype.streamQualityUpload = function () {
        var _this = this;
        var _a;
        if (Object.keys(this.publisherList).length > 0 ||
            Object.keys(this.playerList).length > 0) {
            var _SpeedLogHead = {
                version: 0,
                timestamp: new Date().getTime(),
                event: 0,
                app_id: this.stateCenter.appid,
                user_id: this.stateCenter.idName,
                biz_type: 1
            };
            var _QualityEvent = {
                publish_quality_infos: this.publishQualityInfos,
                play_quality_infos: this.playQualityInfos
            };
            var SpeedLogHeadMessage = speed_log_1.logreport.SpeedLogHead.create(_SpeedLogHead);
            var QualityEventMessage = speed_log_1.logreport.QualityEvent.create(_QualityEvent);
            var SpeedLogHeadBuffer = speed_log_1.logreport.SpeedLogHead.encode(SpeedLogHeadMessage).finish();
            var QualityEventBuffer = speed_log_1.logreport.QualityEvent.encode(QualityEventMessage).finish();
            var preHead = this.getQualityHead(SpeedLogHeadBuffer, QualityEventBuffer);
            var unit8_1 = new Uint8Array(12 + SpeedLogHeadBuffer.length + QualityEventBuffer.length);
            unit8_1.set(preHead);
            unit8_1.set(SpeedLogHeadBuffer, 12);
            unit8_1.set(QualityEventBuffer, 12 + SpeedLogHeadBuffer.length);
            var logDomain = (_a = this.logger.url) === null || _a === void 0 ? void 0 : _a.split("/")[2];
            if (!logDomain)
                return;
            if (!this.qualityWebsocket ||
                this.qualityWebsocket.readyState == 2 ||
                this.qualityWebsocket.readyState == 3) {
                var appID = this.stateCenter.appid;
                var userID = this.stateCenter.idName;
                var token = this.stateCenter.roomList[0].token;
                this.qualityWebsocket = new WebSocket("wss://" + logDomain + "/ws/report/stream?appid=" + appID + "&product=rtc&token=" + encodeURIComponent(token) + "&id_name=" + userID);
                this.qualityWebsocket.onopen = function () {
                    var _a;
                    (_a = _this.qualityWebsocket) === null || _a === void 0 ? void 0 : _a.send(unit8_1);
                };
            }
            else if (this.qualityWebsocket.readyState == 1) {
                this.qualityWebsocket.send(unit8_1);
            }
        }
    };
    ZegoStreamCenterWeb.prototype.updateQuality = function (type, qualityData) {
        var _this = this;
        var timeStamp = new Date().getTime();
        if ((this.qualityUploadTimestamp !== 0 &&
            timeStamp - this.qualityUploadTimestamp > 60000) ||
            this.publishQualityInfos.join("").length +
                this.playQualityInfos.join().length >
                8000) {
            //timestamp_offset_end SpeedLogHead.timestamp
            this.publishQualityInfos.forEach(function (info) {
                return (info.timestamp_offset_end =
                    Math.round(timeStamp / 1000) - _this.qualityHeadTimestamp);
            });
            this.playQualityInfos.forEach(function (info) {
                return (info.timestamp_offset_end =
                    Math.round(timeStamp / 1000) - _this.qualityHeadTimestamp);
            });
            this.streamQualityUpload();
            this.publishQualityInfos = [];
            this.playQualityInfos = [];
            this.qualityHeadTimestamp = Math.round(new Date().getTime() / 1000);
            this.qualityUploadTimestamp = timeStamp;
        }
        else if (this.qualityHeadTimestamp == 0) {
            this.qualityHeadTimestamp = Math.round(new Date().getTime() / 1000);
            this.qualityUploadTimestamp = timeStamp;
        }
        //
        if (type == 0) {
            this.handlePublishQualityData(qualityData);
        }
        else {
            //
            this.handlePlayQualityData(qualityData);
        }
    };
    ZegoStreamCenterWeb.prototype.handlePublishQualityData = function (qualityData) {
        var publishQualityInfo = this.publishQualityInfos.find(function (info) {
            return info.stream_id == qualityData.stream_id &&
                info.video_width == qualityData.frameWidth &&
                info.video_height == qualityData.frameHeight;
        });
        if (!publishQualityInfo) {
            var room = this.getRoomByStreamID(qualityData.stream_id);
            publishQualityInfo = {
                //timestamp_offset_beginSpeedLogHead.timestamp
                timestamp_offset_begin: Math.abs(Number(qualityData.timeStamp - this.qualityHeadTimestamp)),
                timestamp_offset_end: 0,
                stream_id: qualityData.stream_id,
                session_id: room ? Number(room.sessionID) : 0,
                video_width: qualityData.frameWidth,
                video_height: qualityData.frameHeight,
                infos: [],
                room_id: room ? room.roomID : "",
                evnvironment: 1,
                room_session_id: room ? Number(room.roomSessionID) : 0
            };
            this.publishQualityInfos.push(publishQualityInfo);
        }
        publishQualityInfo.infos.push({
            audio_bitrate: Math.round(qualityData.audioBitrate) || 0,
            video_bitrate: Math.round(qualityData.videoBitrate) || 0,
            video_capture_fps: Math.round(qualityData.videoFPS * 10) || 0,
            video_network_fps: Math.round(qualityData.videoTransferFPS * 10) || 0,
            uplink_plr: qualityData.audioPacketsLostRate,
            rtt: Math.round(qualityData.currentRoundTripTime),
            audio_network_fps: Math.round(qualityData.audioFPS * 10),
            captured_sound_level: Math.round(qualityData.audioLevel),
            sample_time_window: Math.round(qualityData.timeStamp / 10)
        });
    };
    ZegoStreamCenterWeb.prototype.handlePlayQualityData = function (qualityData) {
        var playQualityInfo = this.playQualityInfos.find(function (info) {
            return info.stream_id == qualityData.stream_id &&
                info.video_width == qualityData.frameWidth &&
                info.video_height == qualityData.frameHeight;
        });
        if (!playQualityInfo) {
            var room = this.getRoomByStreamID(qualityData.stream_id);
            playQualityInfo = {
                //timestamp_offset_beginSpeedLogHead.timestamp
                timestamp_offset_begin: Math.abs(Number(qualityData.timeStamp - this.qualityHeadTimestamp)),
                timestamp_offset_end: 0,
                stream_id: qualityData.stream_id,
                session_id: room ? Number(room.sessionID) : 0,
                video_width: qualityData.frameWidth,
                video_height: qualityData.frameHeight,
                infos: [],
                room_id: room ? room.roomID : "",
                room_session_id: room ? Number(room.roomSessionID) : 0
            };
            this.playQualityInfos.push(playQualityInfo);
        }
        playQualityInfo.infos.push({
            audio_bitrate: Math.round(qualityData.audioBitrate) || 0,
            video_bitrate: Math.round(qualityData.videoBitrate) || 0,
            video_network_fps: Math.round(qualityData.videoFPS * 10) || 0,
            downlink_plr: Math.round(qualityData.audioPacketsLostRate) || 0,
            audio_network_fps: Math.round(qualityData.audioFPS * 10) || 0,
            audio_break_duration: Math.round(qualityData.audio_break_duration / 10),
            video_break_duration: Math.round(qualityData.video_break_duration / 10),
            rtt: qualityData.currentRoundTripTime,
            rendered_sound_level: Math.round(qualityData.audioLevel),
            audio_break_cancel_duration: Math.round(qualityData.audio_break_cancel_duration / 10),
            video_break_cancel_duration: Math.round(qualityData.video_break_cancel_duration / 10),
            audio_decode_time: Math.round(qualityData.audio_decode_time / 10),
            video_decode_time: Math.round(qualityData.video_decode_time / 10),
            real_sampling_interval: Math.round(qualityData.real_sampling_interval / 10),
            video_frames_decoded: Math.round(qualityData.videoFramesDecoded) || 0,
            video_frames_dropped: Math.round(qualityData.videoFramesDropped) || 0,
            sample_time_window: Math.round(qualityData.timeStamp / 10) //10ms
        });
    };
    return ZegoStreamCenterWeb;
}(streamCenter_1.ZegoStreamCenter));
exports.ZegoStreamCenterWeb = ZegoStreamCenterWeb;


/***/ }),

/***/ "./sdk/src/proto/speed_log.js":
/*!************************************!*\
  !*** ./sdk/src/proto/speed_log.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/


var $protobuf = __webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.logreport = (function() {

    /**
     * Namespace logreport.
     * @exports logreport
     * @namespace
     */
    var logreport = {};

    logreport.SpeedLogHead = (function() {

        /**
         * Properties of a SpeedLogHead.
         * @memberof logreport
         * @interface ISpeedLogHead
         * @property {number|null} [version] SpeedLogHead version
         * @property {Uint8Array|null} [signature] SpeedLogHead signature
         * @property {number|null} [timestamp] SpeedLogHead timestamp
         * @property {number|null} [event] SpeedLogHead event
         * @property {number|null} [app_id] SpeedLogHead app_id
         * @property {string|null} [user_id] SpeedLogHead user_id
         * @property {number|null} [biz_type] SpeedLogHead biz_type
         * @property {string|null} [device_id] SpeedLogHead device_id
         */

        /**
         * Constructs a new SpeedLogHead.
         * @memberof logreport
         * @classdesc Represents a SpeedLogHead.
         * @implements ISpeedLogHead
         * @constructor
         * @param {logreport.ISpeedLogHead=} [properties] Properties to set
         */
        function SpeedLogHead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SpeedLogHead version.
         * @member {number} version
         * @memberof logreport.SpeedLogHead
         * @instance
         */
        SpeedLogHead.prototype.version = 0;

        /**
         * SpeedLogHead signature.
         * @member {Uint8Array} signature
         * @memberof logreport.SpeedLogHead
         * @instance
         */
        SpeedLogHead.prototype.signature = $util.newBuffer([]);

        /**
         * SpeedLogHead timestamp.
         * @member {number} timestamp
         * @memberof logreport.SpeedLogHead
         * @instance
         */
        SpeedLogHead.prototype.timestamp = 0;

        /**
         * SpeedLogHead event.
         * @member {number} event
         * @memberof logreport.SpeedLogHead
         * @instance
         */
        SpeedLogHead.prototype.event = 0;

        /**
         * SpeedLogHead app_id.
         * @member {number} app_id
         * @memberof logreport.SpeedLogHead
         * @instance
         */
        SpeedLogHead.prototype.app_id = 0;

        /**
         * SpeedLogHead user_id.
         * @member {string} user_id
         * @memberof logreport.SpeedLogHead
         * @instance
         */
        SpeedLogHead.prototype.user_id = "";

        /**
         * SpeedLogHead biz_type.
         * @member {number} biz_type
         * @memberof logreport.SpeedLogHead
         * @instance
         */
        SpeedLogHead.prototype.biz_type = 0;

        /**
         * SpeedLogHead device_id.
         * @member {string} device_id
         * @memberof logreport.SpeedLogHead
         * @instance
         */
        SpeedLogHead.prototype.device_id = "";

        /**
         * Creates a new SpeedLogHead instance using the specified properties.
         * @function create
         * @memberof logreport.SpeedLogHead
         * @static
         * @param {logreport.ISpeedLogHead=} [properties] Properties to set
         * @returns {logreport.SpeedLogHead} SpeedLogHead instance
         */
        SpeedLogHead.create = function create(properties) {
            return new SpeedLogHead(properties);
        };

        /**
         * Encodes the specified SpeedLogHead message. Does not implicitly {@link logreport.SpeedLogHead.verify|verify} messages.
         * @function encode
         * @memberof logreport.SpeedLogHead
         * @static
         * @param {logreport.ISpeedLogHead} message SpeedLogHead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpeedLogHead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.version);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.timestamp);
            if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.event);
            if (message.app_id != null && Object.hasOwnProperty.call(message, "app_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.app_id);
            if (message.user_id != null && Object.hasOwnProperty.call(message, "user_id"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.user_id);
            if (message.biz_type != null && Object.hasOwnProperty.call(message, "biz_type"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.biz_type);
            if (message.device_id != null && Object.hasOwnProperty.call(message, "device_id"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.device_id);
            return writer;
        };

        /**
         * Encodes the specified SpeedLogHead message, length delimited. Does not implicitly {@link logreport.SpeedLogHead.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.SpeedLogHead
         * @static
         * @param {logreport.ISpeedLogHead} message SpeedLogHead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpeedLogHead.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SpeedLogHead message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.SpeedLogHead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.SpeedLogHead} SpeedLogHead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpeedLogHead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.SpeedLogHead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.version = reader.uint32();
                    break;
                case 2:
                    message.signature = reader.bytes();
                    break;
                case 3:
                    message.timestamp = reader.uint32();
                    break;
                case 4:
                    message.event = reader.uint32();
                    break;
                case 5:
                    message.app_id = reader.uint32();
                    break;
                case 6:
                    message.user_id = reader.string();
                    break;
                case 7:
                    message.biz_type = reader.uint32();
                    break;
                case 8:
                    message.device_id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SpeedLogHead message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.SpeedLogHead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.SpeedLogHead} SpeedLogHead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpeedLogHead.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SpeedLogHead message.
         * @function verify
         * @memberof logreport.SpeedLogHead
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SpeedLogHead.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp))
                    return "timestamp: integer expected";
            if (message.event != null && message.hasOwnProperty("event"))
                if (!$util.isInteger(message.event))
                    return "event: integer expected";
            if (message.app_id != null && message.hasOwnProperty("app_id"))
                if (!$util.isInteger(message.app_id))
                    return "app_id: integer expected";
            if (message.user_id != null && message.hasOwnProperty("user_id"))
                if (!$util.isString(message.user_id))
                    return "user_id: string expected";
            if (message.biz_type != null && message.hasOwnProperty("biz_type"))
                if (!$util.isInteger(message.biz_type))
                    return "biz_type: integer expected";
            if (message.device_id != null && message.hasOwnProperty("device_id"))
                if (!$util.isString(message.device_id))
                    return "device_id: string expected";
            return null;
        };

        /**
         * Creates a SpeedLogHead message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.SpeedLogHead
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.SpeedLogHead} SpeedLogHead
         */
        SpeedLogHead.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.SpeedLogHead)
                return object;
            var message = new $root.logreport.SpeedLogHead();
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            if (object.timestamp != null)
                message.timestamp = object.timestamp >>> 0;
            if (object.event != null)
                message.event = object.event >>> 0;
            if (object.app_id != null)
                message.app_id = object.app_id >>> 0;
            if (object.user_id != null)
                message.user_id = String(object.user_id);
            if (object.biz_type != null)
                message.biz_type = object.biz_type >>> 0;
            if (object.device_id != null)
                message.device_id = String(object.device_id);
            return message;
        };

        /**
         * Creates a plain object from a SpeedLogHead message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.SpeedLogHead
         * @static
         * @param {logreport.SpeedLogHead} message SpeedLogHead
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SpeedLogHead.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.version = 0;
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
                object.timestamp = 0;
                object.event = 0;
                object.app_id = 0;
                object.user_id = "";
                object.biz_type = 0;
                object.device_id = "";
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            if (message.event != null && message.hasOwnProperty("event"))
                object.event = message.event;
            if (message.app_id != null && message.hasOwnProperty("app_id"))
                object.app_id = message.app_id;
            if (message.user_id != null && message.hasOwnProperty("user_id"))
                object.user_id = message.user_id;
            if (message.biz_type != null && message.hasOwnProperty("biz_type"))
                object.biz_type = message.biz_type;
            if (message.device_id != null && message.hasOwnProperty("device_id"))
                object.device_id = message.device_id;
            return object;
        };

        /**
         * Converts this SpeedLogHead to JSON.
         * @function toJSON
         * @memberof logreport.SpeedLogHead
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SpeedLogHead.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ProtoVersion enum.
         * @name logreport.SpeedLogHead.ProtoVersion
         * @enum {number}
         * @property {number} PROTO_VERSION=0 PROTO_VERSION value
         * @property {number} PROTO_VERSION1=1 PROTO_VERSION1 value
         * @property {number} PROTO_VERSION2=2 PROTO_VERSION2 value
         * @property {number} PROTO_VERSION3=3 PROTO_VERSION3 value
         * @property {number} PROTO_VERSION4=4 PROTO_VERSION4 value
         * @property {number} PROTO_VERSION5=5 PROTO_VERSION5 value
         * @property {number} PROTO_VERSION6=6 PROTO_VERSION6 value
         */
        SpeedLogHead.ProtoVersion = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PROTO_VERSION"] = 0;
            values[valuesById[1] = "PROTO_VERSION1"] = 1;
            values[valuesById[2] = "PROTO_VERSION2"] = 2;
            values[valuesById[3] = "PROTO_VERSION3"] = 3;
            values[valuesById[4] = "PROTO_VERSION4"] = 4;
            values[valuesById[5] = "PROTO_VERSION5"] = 5;
            values[valuesById[6] = "PROTO_VERSION6"] = 6;
            return values;
        })();

        /**
         * Event enum.
         * @name logreport.SpeedLogHead.Event
         * @enum {number}
         * @property {number} QUALITY_EVENT=0 QUALITY_EVENT value
         * @property {number} NO_BILLING_EVENT=100 NO_BILLING_EVENT value
         * @property {number} DETECT_QUALITY_EVENT=300 DETECT_QUALITY_EVENT value
         */
        SpeedLogHead.Event = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "QUALITY_EVENT"] = 0;
            values[valuesById[100] = "NO_BILLING_EVENT"] = 100;
            values[valuesById[300] = "DETECT_QUALITY_EVENT"] = 300;
            return values;
        })();

        /**
         * BizType enum.
         * @name logreport.SpeedLogHead.BizType
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} LIVE=1 LIVE value
         * @property {number} RTV=2 RTV value
         */
        SpeedLogHead.BizType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "LIVE"] = 1;
            values[valuesById[2] = "RTV"] = 2;
            return values;
        })();

        return SpeedLogHead;
    })();

    logreport.SpeedLogRsp = (function() {

        /**
         * Properties of a SpeedLogRsp.
         * @memberof logreport
         * @interface ISpeedLogRsp
         * @property {number|null} [code] SpeedLogRsp code
         * @property {string|null} [message] SpeedLogRsp message
         */

        /**
         * Constructs a new SpeedLogRsp.
         * @memberof logreport
         * @classdesc Represents a SpeedLogRsp.
         * @implements ISpeedLogRsp
         * @constructor
         * @param {logreport.ISpeedLogRsp=} [properties] Properties to set
         */
        function SpeedLogRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SpeedLogRsp code.
         * @member {number} code
         * @memberof logreport.SpeedLogRsp
         * @instance
         */
        SpeedLogRsp.prototype.code = 0;

        /**
         * SpeedLogRsp message.
         * @member {string} message
         * @memberof logreport.SpeedLogRsp
         * @instance
         */
        SpeedLogRsp.prototype.message = "";

        /**
         * Creates a new SpeedLogRsp instance using the specified properties.
         * @function create
         * @memberof logreport.SpeedLogRsp
         * @static
         * @param {logreport.ISpeedLogRsp=} [properties] Properties to set
         * @returns {logreport.SpeedLogRsp} SpeedLogRsp instance
         */
        SpeedLogRsp.create = function create(properties) {
            return new SpeedLogRsp(properties);
        };

        /**
         * Encodes the specified SpeedLogRsp message. Does not implicitly {@link logreport.SpeedLogRsp.verify|verify} messages.
         * @function encode
         * @memberof logreport.SpeedLogRsp
         * @static
         * @param {logreport.ISpeedLogRsp} message SpeedLogRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpeedLogRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.code);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            return writer;
        };

        /**
         * Encodes the specified SpeedLogRsp message, length delimited. Does not implicitly {@link logreport.SpeedLogRsp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.SpeedLogRsp
         * @static
         * @param {logreport.ISpeedLogRsp} message SpeedLogRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpeedLogRsp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SpeedLogRsp message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.SpeedLogRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.SpeedLogRsp} SpeedLogRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpeedLogRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.SpeedLogRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.uint32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SpeedLogRsp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.SpeedLogRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.SpeedLogRsp} SpeedLogRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpeedLogRsp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SpeedLogRsp message.
         * @function verify
         * @memberof logreport.SpeedLogRsp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SpeedLogRsp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isInteger(message.code))
                    return "code: integer expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };

        /**
         * Creates a SpeedLogRsp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.SpeedLogRsp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.SpeedLogRsp} SpeedLogRsp
         */
        SpeedLogRsp.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.SpeedLogRsp)
                return object;
            var message = new $root.logreport.SpeedLogRsp();
            if (object.code != null)
                message.code = object.code >>> 0;
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };

        /**
         * Creates a plain object from a SpeedLogRsp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.SpeedLogRsp
         * @static
         * @param {logreport.SpeedLogRsp} message SpeedLogRsp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SpeedLogRsp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.code = 0;
                object.message = "";
            }
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };

        /**
         * Converts this SpeedLogRsp to JSON.
         * @function toJSON
         * @memberof logreport.SpeedLogRsp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SpeedLogRsp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SpeedLogRsp;
    })();

    logreport.QualityEvent = (function() {

        /**
         * Properties of a QualityEvent.
         * @memberof logreport
         * @interface IQualityEvent
         * @property {logreport.IHardwareInfos|null} [hardware_infos] QualityEvent hardware_infos
         * @property {Array.<logreport.IPublishQualityInfos>|null} [publish_quality_infos] QualityEvent publish_quality_infos
         * @property {Array.<logreport.IPlayQualityInfos>|null} [play_quality_infos] QualityEvent play_quality_infos
         * @property {number|null} [network_type] QualityEvent network_type
         * @property {logreport.IChargeInfos|null} [charge_infos] QualityEvent charge_infos
         * @property {number|null} [client_type] QualityEvent client_type
         */

        /**
         * Constructs a new QualityEvent.
         * @memberof logreport
         * @classdesc Represents a QualityEvent.
         * @implements IQualityEvent
         * @constructor
         * @param {logreport.IQualityEvent=} [properties] Properties to set
         */
        function QualityEvent(properties) {
            this.publish_quality_infos = [];
            this.play_quality_infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QualityEvent hardware_infos.
         * @member {logreport.IHardwareInfos|null|undefined} hardware_infos
         * @memberof logreport.QualityEvent
         * @instance
         */
        QualityEvent.prototype.hardware_infos = null;

        /**
         * QualityEvent publish_quality_infos.
         * @member {Array.<logreport.IPublishQualityInfos>} publish_quality_infos
         * @memberof logreport.QualityEvent
         * @instance
         */
        QualityEvent.prototype.publish_quality_infos = $util.emptyArray;

        /**
         * QualityEvent play_quality_infos.
         * @member {Array.<logreport.IPlayQualityInfos>} play_quality_infos
         * @memberof logreport.QualityEvent
         * @instance
         */
        QualityEvent.prototype.play_quality_infos = $util.emptyArray;

        /**
         * QualityEvent network_type.
         * @member {number} network_type
         * @memberof logreport.QualityEvent
         * @instance
         */
        QualityEvent.prototype.network_type = 0;

        /**
         * QualityEvent charge_infos.
         * @member {logreport.IChargeInfos|null|undefined} charge_infos
         * @memberof logreport.QualityEvent
         * @instance
         */
        QualityEvent.prototype.charge_infos = null;

        /**
         * QualityEvent client_type.
         * @member {number} client_type
         * @memberof logreport.QualityEvent
         * @instance
         */
        QualityEvent.prototype.client_type = 0;

        /**
         * Creates a new QualityEvent instance using the specified properties.
         * @function create
         * @memberof logreport.QualityEvent
         * @static
         * @param {logreport.IQualityEvent=} [properties] Properties to set
         * @returns {logreport.QualityEvent} QualityEvent instance
         */
        QualityEvent.create = function create(properties) {
            return new QualityEvent(properties);
        };

        /**
         * Encodes the specified QualityEvent message. Does not implicitly {@link logreport.QualityEvent.verify|verify} messages.
         * @function encode
         * @memberof logreport.QualityEvent
         * @static
         * @param {logreport.IQualityEvent} message QualityEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QualityEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hardware_infos != null && Object.hasOwnProperty.call(message, "hardware_infos"))
                $root.logreport.HardwareInfos.encode(message.hardware_infos, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.publish_quality_infos != null && message.publish_quality_infos.length)
                for (var i = 0; i < message.publish_quality_infos.length; ++i)
                    $root.logreport.PublishQualityInfos.encode(message.publish_quality_infos[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.play_quality_infos != null && message.play_quality_infos.length)
                for (var i = 0; i < message.play_quality_infos.length; ++i)
                    $root.logreport.PlayQualityInfos.encode(message.play_quality_infos[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.network_type != null && Object.hasOwnProperty.call(message, "network_type"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.network_type);
            if (message.charge_infos != null && Object.hasOwnProperty.call(message, "charge_infos"))
                $root.logreport.ChargeInfos.encode(message.charge_infos, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.client_type != null && Object.hasOwnProperty.call(message, "client_type"))
                writer.uint32(/* id 100, wireType 0 =*/800).uint32(message.client_type);
            return writer;
        };

        /**
         * Encodes the specified QualityEvent message, length delimited. Does not implicitly {@link logreport.QualityEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.QualityEvent
         * @static
         * @param {logreport.IQualityEvent} message QualityEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QualityEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QualityEvent message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.QualityEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.QualityEvent} QualityEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QualityEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.QualityEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hardware_infos = $root.logreport.HardwareInfos.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.publish_quality_infos && message.publish_quality_infos.length))
                        message.publish_quality_infos = [];
                    message.publish_quality_infos.push($root.logreport.PublishQualityInfos.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.play_quality_infos && message.play_quality_infos.length))
                        message.play_quality_infos = [];
                    message.play_quality_infos.push($root.logreport.PlayQualityInfos.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.network_type = reader.uint32();
                    break;
                case 5:
                    message.charge_infos = $root.logreport.ChargeInfos.decode(reader, reader.uint32());
                    break;
                case 100:
                    message.client_type = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QualityEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.QualityEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.QualityEvent} QualityEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QualityEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QualityEvent message.
         * @function verify
         * @memberof logreport.QualityEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QualityEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hardware_infos != null && message.hasOwnProperty("hardware_infos")) {
                var error = $root.logreport.HardwareInfos.verify(message.hardware_infos);
                if (error)
                    return "hardware_infos." + error;
            }
            if (message.publish_quality_infos != null && message.hasOwnProperty("publish_quality_infos")) {
                if (!Array.isArray(message.publish_quality_infos))
                    return "publish_quality_infos: array expected";
                for (var i = 0; i < message.publish_quality_infos.length; ++i) {
                    var error = $root.logreport.PublishQualityInfos.verify(message.publish_quality_infos[i]);
                    if (error)
                        return "publish_quality_infos." + error;
                }
            }
            if (message.play_quality_infos != null && message.hasOwnProperty("play_quality_infos")) {
                if (!Array.isArray(message.play_quality_infos))
                    return "play_quality_infos: array expected";
                for (var i = 0; i < message.play_quality_infos.length; ++i) {
                    var error = $root.logreport.PlayQualityInfos.verify(message.play_quality_infos[i]);
                    if (error)
                        return "play_quality_infos." + error;
                }
            }
            if (message.network_type != null && message.hasOwnProperty("network_type"))
                if (!$util.isInteger(message.network_type))
                    return "network_type: integer expected";
            if (message.charge_infos != null && message.hasOwnProperty("charge_infos")) {
                var error = $root.logreport.ChargeInfos.verify(message.charge_infos);
                if (error)
                    return "charge_infos." + error;
            }
            if (message.client_type != null && message.hasOwnProperty("client_type"))
                if (!$util.isInteger(message.client_type))
                    return "client_type: integer expected";
            return null;
        };

        /**
         * Creates a QualityEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.QualityEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.QualityEvent} QualityEvent
         */
        QualityEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.QualityEvent)
                return object;
            var message = new $root.logreport.QualityEvent();
            if (object.hardware_infos != null) {
                if (typeof object.hardware_infos !== "object")
                    throw TypeError(".logreport.QualityEvent.hardware_infos: object expected");
                message.hardware_infos = $root.logreport.HardwareInfos.fromObject(object.hardware_infos);
            }
            if (object.publish_quality_infos) {
                if (!Array.isArray(object.publish_quality_infos))
                    throw TypeError(".logreport.QualityEvent.publish_quality_infos: array expected");
                message.publish_quality_infos = [];
                for (var i = 0; i < object.publish_quality_infos.length; ++i) {
                    if (typeof object.publish_quality_infos[i] !== "object")
                        throw TypeError(".logreport.QualityEvent.publish_quality_infos: object expected");
                    message.publish_quality_infos[i] = $root.logreport.PublishQualityInfos.fromObject(object.publish_quality_infos[i]);
                }
            }
            if (object.play_quality_infos) {
                if (!Array.isArray(object.play_quality_infos))
                    throw TypeError(".logreport.QualityEvent.play_quality_infos: array expected");
                message.play_quality_infos = [];
                for (var i = 0; i < object.play_quality_infos.length; ++i) {
                    if (typeof object.play_quality_infos[i] !== "object")
                        throw TypeError(".logreport.QualityEvent.play_quality_infos: object expected");
                    message.play_quality_infos[i] = $root.logreport.PlayQualityInfos.fromObject(object.play_quality_infos[i]);
                }
            }
            if (object.network_type != null)
                message.network_type = object.network_type >>> 0;
            if (object.charge_infos != null) {
                if (typeof object.charge_infos !== "object")
                    throw TypeError(".logreport.QualityEvent.charge_infos: object expected");
                message.charge_infos = $root.logreport.ChargeInfos.fromObject(object.charge_infos);
            }
            if (object.client_type != null)
                message.client_type = object.client_type >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a QualityEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.QualityEvent
         * @static
         * @param {logreport.QualityEvent} message QualityEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QualityEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.publish_quality_infos = [];
                object.play_quality_infos = [];
            }
            if (options.defaults) {
                object.hardware_infos = null;
                object.network_type = 0;
                object.charge_infos = null;
                object.client_type = 0;
            }
            if (message.hardware_infos != null && message.hasOwnProperty("hardware_infos"))
                object.hardware_infos = $root.logreport.HardwareInfos.toObject(message.hardware_infos, options);
            if (message.publish_quality_infos && message.publish_quality_infos.length) {
                object.publish_quality_infos = [];
                for (var j = 0; j < message.publish_quality_infos.length; ++j)
                    object.publish_quality_infos[j] = $root.logreport.PublishQualityInfos.toObject(message.publish_quality_infos[j], options);
            }
            if (message.play_quality_infos && message.play_quality_infos.length) {
                object.play_quality_infos = [];
                for (var j = 0; j < message.play_quality_infos.length; ++j)
                    object.play_quality_infos[j] = $root.logreport.PlayQualityInfos.toObject(message.play_quality_infos[j], options);
            }
            if (message.network_type != null && message.hasOwnProperty("network_type"))
                object.network_type = message.network_type;
            if (message.charge_infos != null && message.hasOwnProperty("charge_infos"))
                object.charge_infos = $root.logreport.ChargeInfos.toObject(message.charge_infos, options);
            if (message.client_type != null && message.hasOwnProperty("client_type"))
                object.client_type = message.client_type;
            return object;
        };

        /**
         * Converts this QualityEvent to JSON.
         * @function toJSON
         * @memberof logreport.QualityEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QualityEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ResourceType enum.
         * @name logreport.QualityEvent.ResourceType
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} CDN=1 CDN value
         * @property {number} RTC=2 RTC value
         * @property {number} L3=3 L3 value
         */
        QualityEvent.ResourceType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "CDN"] = 1;
            values[valuesById[2] = "RTC"] = 2;
            values[valuesById[3] = "L3"] = 3;
            return values;
        })();

        return QualityEvent;
    })();

    logreport.HardwareInfos = (function() {

        /**
         * Properties of a HardwareInfos.
         * @memberof logreport
         * @interface IHardwareInfos
         * @property {number|null} [timestamp_offset_begin] HardwareInfos timestamp_offset_begin
         * @property {number|null} [timestamp_offset_end] HardwareInfos timestamp_offset_end
         * @property {Array.<logreport.IHardwareInfo>|null} [infos] HardwareInfos infos
         * @property {number|null} [sys_mem_total] HardwareInfos sys_mem_total
         */

        /**
         * Constructs a new HardwareInfos.
         * @memberof logreport
         * @classdesc Represents a HardwareInfos.
         * @implements IHardwareInfos
         * @constructor
         * @param {logreport.IHardwareInfos=} [properties] Properties to set
         */
        function HardwareInfos(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HardwareInfos timestamp_offset_begin.
         * @member {number} timestamp_offset_begin
         * @memberof logreport.HardwareInfos
         * @instance
         */
        HardwareInfos.prototype.timestamp_offset_begin = 0;

        /**
         * HardwareInfos timestamp_offset_end.
         * @member {number} timestamp_offset_end
         * @memberof logreport.HardwareInfos
         * @instance
         */
        HardwareInfos.prototype.timestamp_offset_end = 0;

        /**
         * HardwareInfos infos.
         * @member {Array.<logreport.IHardwareInfo>} infos
         * @memberof logreport.HardwareInfos
         * @instance
         */
        HardwareInfos.prototype.infos = $util.emptyArray;

        /**
         * HardwareInfos sys_mem_total.
         * @member {number} sys_mem_total
         * @memberof logreport.HardwareInfos
         * @instance
         */
        HardwareInfos.prototype.sys_mem_total = 0;

        /**
         * Creates a new HardwareInfos instance using the specified properties.
         * @function create
         * @memberof logreport.HardwareInfos
         * @static
         * @param {logreport.IHardwareInfos=} [properties] Properties to set
         * @returns {logreport.HardwareInfos} HardwareInfos instance
         */
        HardwareInfos.create = function create(properties) {
            return new HardwareInfos(properties);
        };

        /**
         * Encodes the specified HardwareInfos message. Does not implicitly {@link logreport.HardwareInfos.verify|verify} messages.
         * @function encode
         * @memberof logreport.HardwareInfos
         * @static
         * @param {logreport.IHardwareInfos} message HardwareInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HardwareInfos.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp_offset_begin != null && Object.hasOwnProperty.call(message, "timestamp_offset_begin"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timestamp_offset_begin);
            if (message.timestamp_offset_end != null && Object.hasOwnProperty.call(message, "timestamp_offset_end"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.timestamp_offset_end);
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.logreport.HardwareInfo.encode(message.infos[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.sys_mem_total != null && Object.hasOwnProperty.call(message, "sys_mem_total"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.sys_mem_total);
            return writer;
        };

        /**
         * Encodes the specified HardwareInfos message, length delimited. Does not implicitly {@link logreport.HardwareInfos.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.HardwareInfos
         * @static
         * @param {logreport.IHardwareInfos} message HardwareInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HardwareInfos.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HardwareInfos message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.HardwareInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.HardwareInfos} HardwareInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HardwareInfos.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.HardwareInfos();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp_offset_begin = reader.uint32();
                    break;
                case 2:
                    message.timestamp_offset_end = reader.uint32();
                    break;
                case 3:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.logreport.HardwareInfo.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.sys_mem_total = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HardwareInfos message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.HardwareInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.HardwareInfos} HardwareInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HardwareInfos.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HardwareInfos message.
         * @function verify
         * @memberof logreport.HardwareInfos
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HardwareInfos.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                if (!$util.isInteger(message.timestamp_offset_begin))
                    return "timestamp_offset_begin: integer expected";
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                if (!$util.isInteger(message.timestamp_offset_end))
                    return "timestamp_offset_end: integer expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.logreport.HardwareInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            if (message.sys_mem_total != null && message.hasOwnProperty("sys_mem_total"))
                if (!$util.isInteger(message.sys_mem_total))
                    return "sys_mem_total: integer expected";
            return null;
        };

        /**
         * Creates a HardwareInfos message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.HardwareInfos
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.HardwareInfos} HardwareInfos
         */
        HardwareInfos.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.HardwareInfos)
                return object;
            var message = new $root.logreport.HardwareInfos();
            if (object.timestamp_offset_begin != null)
                message.timestamp_offset_begin = object.timestamp_offset_begin >>> 0;
            if (object.timestamp_offset_end != null)
                message.timestamp_offset_end = object.timestamp_offset_end >>> 0;
            if (object.infos) {
                if (!Array.isArray(object.infos))
                    throw TypeError(".logreport.HardwareInfos.infos: array expected");
                message.infos = [];
                for (var i = 0; i < object.infos.length; ++i) {
                    if (typeof object.infos[i] !== "object")
                        throw TypeError(".logreport.HardwareInfos.infos: object expected");
                    message.infos[i] = $root.logreport.HardwareInfo.fromObject(object.infos[i]);
                }
            }
            if (object.sys_mem_total != null)
                message.sys_mem_total = object.sys_mem_total >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a HardwareInfos message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.HardwareInfos
         * @static
         * @param {logreport.HardwareInfos} message HardwareInfos
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HardwareInfos.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.infos = [];
            if (options.defaults) {
                object.timestamp_offset_begin = 0;
                object.timestamp_offset_end = 0;
                object.sys_mem_total = 0;
            }
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                object.timestamp_offset_begin = message.timestamp_offset_begin;
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                object.timestamp_offset_end = message.timestamp_offset_end;
            if (message.infos && message.infos.length) {
                object.infos = [];
                for (var j = 0; j < message.infos.length; ++j)
                    object.infos[j] = $root.logreport.HardwareInfo.toObject(message.infos[j], options);
            }
            if (message.sys_mem_total != null && message.hasOwnProperty("sys_mem_total"))
                object.sys_mem_total = message.sys_mem_total;
            return object;
        };

        /**
         * Converts this HardwareInfos to JSON.
         * @function toJSON
         * @memberof logreport.HardwareInfos
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HardwareInfos.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HardwareInfos;
    })();

    logreport.PublishQualityInfos = (function() {

        /**
         * Properties of a PublishQualityInfos.
         * @memberof logreport
         * @interface IPublishQualityInfos
         * @property {number|null} [timestamp_offset_begin] PublishQualityInfos timestamp_offset_begin
         * @property {number|null} [timestamp_offset_end] PublishQualityInfos timestamp_offset_end
         * @property {string|null} [stream_id] PublishQualityInfos stream_id
         * @property {number|null} [session_id] PublishQualityInfos session_id
         * @property {number|null} [video_width] PublishQualityInfos video_width
         * @property {number|null} [video_height] PublishQualityInfos video_height
         * @property {number|null} [ipv4] PublishQualityInfos ipv4
         * @property {string|null} [ipv6] PublishQualityInfos ipv6
         * @property {number|null} [resource_type] PublishQualityInfos resource_type
         * @property {Array.<logreport.IPublishQualityInfo>|null} [infos] PublishQualityInfos infos
         * @property {string|null} [room_id] PublishQualityInfos room_id
         * @property {number|null} [evnvironment] PublishQualityInfos evnvironment
         * @property {string|null} [ap] PublishQualityInfos ap
         * @property {string|null} [session] PublishQualityInfos session
         * @property {number|Long|null} [room_session_id] PublishQualityInfos room_session_id
         * @property {number|null} [protocol_type] PublishQualityInfos protocol_type
         */

        /**
         * Constructs a new PublishQualityInfos.
         * @memberof logreport
         * @classdesc Represents a PublishQualityInfos.
         * @implements IPublishQualityInfos
         * @constructor
         * @param {logreport.IPublishQualityInfos=} [properties] Properties to set
         */
        function PublishQualityInfos(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublishQualityInfos timestamp_offset_begin.
         * @member {number} timestamp_offset_begin
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.timestamp_offset_begin = 0;

        /**
         * PublishQualityInfos timestamp_offset_end.
         * @member {number} timestamp_offset_end
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.timestamp_offset_end = 0;

        /**
         * PublishQualityInfos stream_id.
         * @member {string} stream_id
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.stream_id = "";

        /**
         * PublishQualityInfos session_id.
         * @member {number} session_id
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.session_id = 0;

        /**
         * PublishQualityInfos video_width.
         * @member {number} video_width
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.video_width = 0;

        /**
         * PublishQualityInfos video_height.
         * @member {number} video_height
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.video_height = 0;

        /**
         * PublishQualityInfos ipv4.
         * @member {number} ipv4
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.ipv4 = 0;

        /**
         * PublishQualityInfos ipv6.
         * @member {string} ipv6
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.ipv6 = "";

        /**
         * PublishQualityInfos resource_type.
         * @member {number} resource_type
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.resource_type = 0;

        /**
         * PublishQualityInfos infos.
         * @member {Array.<logreport.IPublishQualityInfo>} infos
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.infos = $util.emptyArray;

        /**
         * PublishQualityInfos room_id.
         * @member {string} room_id
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.room_id = "";

        /**
         * PublishQualityInfos evnvironment.
         * @member {number} evnvironment
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.evnvironment = 0;

        /**
         * PublishQualityInfos ap.
         * @member {string} ap
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.ap = "";

        /**
         * PublishQualityInfos session.
         * @member {string} session
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.session = "";

        /**
         * PublishQualityInfos room_session_id.
         * @member {number|Long} room_session_id
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.room_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PublishQualityInfos protocol_type.
         * @member {number} protocol_type
         * @memberof logreport.PublishQualityInfos
         * @instance
         */
        PublishQualityInfos.prototype.protocol_type = 0;

        /**
         * Creates a new PublishQualityInfos instance using the specified properties.
         * @function create
         * @memberof logreport.PublishQualityInfos
         * @static
         * @param {logreport.IPublishQualityInfos=} [properties] Properties to set
         * @returns {logreport.PublishQualityInfos} PublishQualityInfos instance
         */
        PublishQualityInfos.create = function create(properties) {
            return new PublishQualityInfos(properties);
        };

        /**
         * Encodes the specified PublishQualityInfos message. Does not implicitly {@link logreport.PublishQualityInfos.verify|verify} messages.
         * @function encode
         * @memberof logreport.PublishQualityInfos
         * @static
         * @param {logreport.IPublishQualityInfos} message PublishQualityInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishQualityInfos.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp_offset_begin != null && Object.hasOwnProperty.call(message, "timestamp_offset_begin"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timestamp_offset_begin);
            if (message.timestamp_offset_end != null && Object.hasOwnProperty.call(message, "timestamp_offset_end"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.timestamp_offset_end);
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.stream_id);
            if (message.session_id != null && Object.hasOwnProperty.call(message, "session_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.session_id);
            if (message.video_width != null && Object.hasOwnProperty.call(message, "video_width"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.video_width);
            if (message.video_height != null && Object.hasOwnProperty.call(message, "video_height"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.video_height);
            if (message.ipv4 != null && Object.hasOwnProperty.call(message, "ipv4"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.ipv4);
            if (message.ipv6 != null && Object.hasOwnProperty.call(message, "ipv6"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.ipv6);
            if (message.resource_type != null && Object.hasOwnProperty.call(message, "resource_type"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.resource_type);
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.logreport.PublishQualityInfo.encode(message.infos[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.room_id);
            if (message.evnvironment != null && Object.hasOwnProperty.call(message, "evnvironment"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.evnvironment);
            if (message.ap != null && Object.hasOwnProperty.call(message, "ap"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.ap);
            if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.session);
            if (message.room_session_id != null && Object.hasOwnProperty.call(message, "room_session_id"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint64(message.room_session_id);
            if (message.protocol_type != null && Object.hasOwnProperty.call(message, "protocol_type"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint32(message.protocol_type);
            return writer;
        };

        /**
         * Encodes the specified PublishQualityInfos message, length delimited. Does not implicitly {@link logreport.PublishQualityInfos.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.PublishQualityInfos
         * @static
         * @param {logreport.IPublishQualityInfos} message PublishQualityInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishQualityInfos.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PublishQualityInfos message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.PublishQualityInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.PublishQualityInfos} PublishQualityInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishQualityInfos.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.PublishQualityInfos();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp_offset_begin = reader.uint32();
                    break;
                case 2:
                    message.timestamp_offset_end = reader.uint32();
                    break;
                case 3:
                    message.stream_id = reader.string();
                    break;
                case 4:
                    message.session_id = reader.uint32();
                    break;
                case 5:
                    message.video_width = reader.uint32();
                    break;
                case 6:
                    message.video_height = reader.uint32();
                    break;
                case 7:
                    message.ipv4 = reader.uint32();
                    break;
                case 8:
                    message.ipv6 = reader.string();
                    break;
                case 9:
                    message.resource_type = reader.uint32();
                    break;
                case 10:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.logreport.PublishQualityInfo.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.room_id = reader.string();
                    break;
                case 13:
                    message.evnvironment = reader.uint32();
                    break;
                case 14:
                    message.ap = reader.string();
                    break;
                case 15:
                    message.session = reader.string();
                    break;
                case 16:
                    message.room_session_id = reader.uint64();
                    break;
                case 17:
                    message.protocol_type = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PublishQualityInfos message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.PublishQualityInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.PublishQualityInfos} PublishQualityInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishQualityInfos.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PublishQualityInfos message.
         * @function verify
         * @memberof logreport.PublishQualityInfos
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PublishQualityInfos.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                if (!$util.isInteger(message.timestamp_offset_begin))
                    return "timestamp_offset_begin: integer expected";
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                if (!$util.isInteger(message.timestamp_offset_end))
                    return "timestamp_offset_end: integer expected";
            if (message.stream_id != null && message.hasOwnProperty("stream_id"))
                if (!$util.isString(message.stream_id))
                    return "stream_id: string expected";
            if (message.session_id != null && message.hasOwnProperty("session_id"))
                if (!$util.isInteger(message.session_id))
                    return "session_id: integer expected";
            if (message.video_width != null && message.hasOwnProperty("video_width"))
                if (!$util.isInteger(message.video_width))
                    return "video_width: integer expected";
            if (message.video_height != null && message.hasOwnProperty("video_height"))
                if (!$util.isInteger(message.video_height))
                    return "video_height: integer expected";
            if (message.ipv4 != null && message.hasOwnProperty("ipv4"))
                if (!$util.isInteger(message.ipv4))
                    return "ipv4: integer expected";
            if (message.ipv6 != null && message.hasOwnProperty("ipv6"))
                if (!$util.isString(message.ipv6))
                    return "ipv6: string expected";
            if (message.resource_type != null && message.hasOwnProperty("resource_type"))
                if (!$util.isInteger(message.resource_type))
                    return "resource_type: integer expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.logreport.PublishQualityInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            if (message.room_id != null && message.hasOwnProperty("room_id"))
                if (!$util.isString(message.room_id))
                    return "room_id: string expected";
            if (message.evnvironment != null && message.hasOwnProperty("evnvironment"))
                if (!$util.isInteger(message.evnvironment))
                    return "evnvironment: integer expected";
            if (message.ap != null && message.hasOwnProperty("ap"))
                if (!$util.isString(message.ap))
                    return "ap: string expected";
            if (message.session != null && message.hasOwnProperty("session"))
                if (!$util.isString(message.session))
                    return "session: string expected";
            if (message.room_session_id != null && message.hasOwnProperty("room_session_id"))
                if (!$util.isInteger(message.room_session_id) && !(message.room_session_id && $util.isInteger(message.room_session_id.low) && $util.isInteger(message.room_session_id.high)))
                    return "room_session_id: integer|Long expected";
            if (message.protocol_type != null && message.hasOwnProperty("protocol_type"))
                if (!$util.isInteger(message.protocol_type))
                    return "protocol_type: integer expected";
            return null;
        };

        /**
         * Creates a PublishQualityInfos message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.PublishQualityInfos
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.PublishQualityInfos} PublishQualityInfos
         */
        PublishQualityInfos.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.PublishQualityInfos)
                return object;
            var message = new $root.logreport.PublishQualityInfos();
            if (object.timestamp_offset_begin != null)
                message.timestamp_offset_begin = object.timestamp_offset_begin >>> 0;
            if (object.timestamp_offset_end != null)
                message.timestamp_offset_end = object.timestamp_offset_end >>> 0;
            if (object.stream_id != null)
                message.stream_id = String(object.stream_id);
            if (object.session_id != null)
                message.session_id = object.session_id >>> 0;
            if (object.video_width != null)
                message.video_width = object.video_width >>> 0;
            if (object.video_height != null)
                message.video_height = object.video_height >>> 0;
            if (object.ipv4 != null)
                message.ipv4 = object.ipv4 >>> 0;
            if (object.ipv6 != null)
                message.ipv6 = String(object.ipv6);
            if (object.resource_type != null)
                message.resource_type = object.resource_type >>> 0;
            if (object.infos) {
                if (!Array.isArray(object.infos))
                    throw TypeError(".logreport.PublishQualityInfos.infos: array expected");
                message.infos = [];
                for (var i = 0; i < object.infos.length; ++i) {
                    if (typeof object.infos[i] !== "object")
                        throw TypeError(".logreport.PublishQualityInfos.infos: object expected");
                    message.infos[i] = $root.logreport.PublishQualityInfo.fromObject(object.infos[i]);
                }
            }
            if (object.room_id != null)
                message.room_id = String(object.room_id);
            if (object.evnvironment != null)
                message.evnvironment = object.evnvironment >>> 0;
            if (object.ap != null)
                message.ap = String(object.ap);
            if (object.session != null)
                message.session = String(object.session);
            if (object.room_session_id != null)
                if ($util.Long)
                    (message.room_session_id = $util.Long.fromValue(object.room_session_id)).unsigned = true;
                else if (typeof object.room_session_id === "string")
                    message.room_session_id = parseInt(object.room_session_id, 10);
                else if (typeof object.room_session_id === "number")
                    message.room_session_id = object.room_session_id;
                else if (typeof object.room_session_id === "object")
                    message.room_session_id = new $util.LongBits(object.room_session_id.low >>> 0, object.room_session_id.high >>> 0).toNumber(true);
            if (object.protocol_type != null)
                message.protocol_type = object.protocol_type >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PublishQualityInfos message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.PublishQualityInfos
         * @static
         * @param {logreport.PublishQualityInfos} message PublishQualityInfos
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PublishQualityInfos.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.infos = [];
            if (options.defaults) {
                object.timestamp_offset_begin = 0;
                object.timestamp_offset_end = 0;
                object.stream_id = "";
                object.session_id = 0;
                object.video_width = 0;
                object.video_height = 0;
                object.ipv4 = 0;
                object.ipv6 = "";
                object.resource_type = 0;
                object.room_id = "";
                object.evnvironment = 0;
                object.ap = "";
                object.session = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.room_session_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.room_session_id = options.longs === String ? "0" : 0;
                object.protocol_type = 0;
            }
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                object.timestamp_offset_begin = message.timestamp_offset_begin;
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                object.timestamp_offset_end = message.timestamp_offset_end;
            if (message.stream_id != null && message.hasOwnProperty("stream_id"))
                object.stream_id = message.stream_id;
            if (message.session_id != null && message.hasOwnProperty("session_id"))
                object.session_id = message.session_id;
            if (message.video_width != null && message.hasOwnProperty("video_width"))
                object.video_width = message.video_width;
            if (message.video_height != null && message.hasOwnProperty("video_height"))
                object.video_height = message.video_height;
            if (message.ipv4 != null && message.hasOwnProperty("ipv4"))
                object.ipv4 = message.ipv4;
            if (message.ipv6 != null && message.hasOwnProperty("ipv6"))
                object.ipv6 = message.ipv6;
            if (message.resource_type != null && message.hasOwnProperty("resource_type"))
                object.resource_type = message.resource_type;
            if (message.infos && message.infos.length) {
                object.infos = [];
                for (var j = 0; j < message.infos.length; ++j)
                    object.infos[j] = $root.logreport.PublishQualityInfo.toObject(message.infos[j], options);
            }
            if (message.room_id != null && message.hasOwnProperty("room_id"))
                object.room_id = message.room_id;
            if (message.evnvironment != null && message.hasOwnProperty("evnvironment"))
                object.evnvironment = message.evnvironment;
            if (message.ap != null && message.hasOwnProperty("ap"))
                object.ap = message.ap;
            if (message.session != null && message.hasOwnProperty("session"))
                object.session = message.session;
            if (message.room_session_id != null && message.hasOwnProperty("room_session_id"))
                if (typeof message.room_session_id === "number")
                    object.room_session_id = options.longs === String ? String(message.room_session_id) : message.room_session_id;
                else
                    object.room_session_id = options.longs === String ? $util.Long.prototype.toString.call(message.room_session_id) : options.longs === Number ? new $util.LongBits(message.room_session_id.low >>> 0, message.room_session_id.high >>> 0).toNumber(true) : message.room_session_id;
            if (message.protocol_type != null && message.hasOwnProperty("protocol_type"))
                object.protocol_type = message.protocol_type;
            return object;
        };

        /**
         * Converts this PublishQualityInfos to JSON.
         * @function toJSON
         * @memberof logreport.PublishQualityInfos
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PublishQualityInfos.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PublishQualityInfos;
    })();

    logreport.PlayQualityInfos = (function() {

        /**
         * Properties of a PlayQualityInfos.
         * @memberof logreport
         * @interface IPlayQualityInfos
         * @property {number|null} [timestamp_offset_begin] PlayQualityInfos timestamp_offset_begin
         * @property {number|null} [timestamp_offset_end] PlayQualityInfos timestamp_offset_end
         * @property {string|null} [stream_id] PlayQualityInfos stream_id
         * @property {number|null} [session_id] PlayQualityInfos session_id
         * @property {number|null} [video_width] PlayQualityInfos video_width
         * @property {number|null} [video_height] PlayQualityInfos video_height
         * @property {number|null} [ipv4] PlayQualityInfos ipv4
         * @property {string|null} [ipv6] PlayQualityInfos ipv6
         * @property {number|null} [resource_type] PlayQualityInfos resource_type
         * @property {Array.<logreport.IPlayQualityInfo>|null} [infos] PlayQualityInfos infos
         * @property {string|null} [room_id] PlayQualityInfos room_id
         * @property {string|null} [session] PlayQualityInfos session
         * @property {number|Long|null} [room_session_id] PlayQualityInfos room_session_id
         * @property {number|null} [protocol_type] PlayQualityInfos protocol_type
         */

        /**
         * Constructs a new PlayQualityInfos.
         * @memberof logreport
         * @classdesc Represents a PlayQualityInfos.
         * @implements IPlayQualityInfos
         * @constructor
         * @param {logreport.IPlayQualityInfos=} [properties] Properties to set
         */
        function PlayQualityInfos(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlayQualityInfos timestamp_offset_begin.
         * @member {number} timestamp_offset_begin
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.timestamp_offset_begin = 0;

        /**
         * PlayQualityInfos timestamp_offset_end.
         * @member {number} timestamp_offset_end
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.timestamp_offset_end = 0;

        /**
         * PlayQualityInfos stream_id.
         * @member {string} stream_id
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.stream_id = "";

        /**
         * PlayQualityInfos session_id.
         * @member {number} session_id
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.session_id = 0;

        /**
         * PlayQualityInfos video_width.
         * @member {number} video_width
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.video_width = 0;

        /**
         * PlayQualityInfos video_height.
         * @member {number} video_height
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.video_height = 0;

        /**
         * PlayQualityInfos ipv4.
         * @member {number} ipv4
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.ipv4 = 0;

        /**
         * PlayQualityInfos ipv6.
         * @member {string} ipv6
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.ipv6 = "";

        /**
         * PlayQualityInfos resource_type.
         * @member {number} resource_type
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.resource_type = 0;

        /**
         * PlayQualityInfos infos.
         * @member {Array.<logreport.IPlayQualityInfo>} infos
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.infos = $util.emptyArray;

        /**
         * PlayQualityInfos room_id.
         * @member {string} room_id
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.room_id = "";

        /**
         * PlayQualityInfos session.
         * @member {string} session
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.session = "";

        /**
         * PlayQualityInfos room_session_id.
         * @member {number|Long} room_session_id
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.room_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PlayQualityInfos protocol_type.
         * @member {number} protocol_type
         * @memberof logreport.PlayQualityInfos
         * @instance
         */
        PlayQualityInfos.prototype.protocol_type = 0;

        /**
         * Creates a new PlayQualityInfos instance using the specified properties.
         * @function create
         * @memberof logreport.PlayQualityInfos
         * @static
         * @param {logreport.IPlayQualityInfos=} [properties] Properties to set
         * @returns {logreport.PlayQualityInfos} PlayQualityInfos instance
         */
        PlayQualityInfos.create = function create(properties) {
            return new PlayQualityInfos(properties);
        };

        /**
         * Encodes the specified PlayQualityInfos message. Does not implicitly {@link logreport.PlayQualityInfos.verify|verify} messages.
         * @function encode
         * @memberof logreport.PlayQualityInfos
         * @static
         * @param {logreport.IPlayQualityInfos} message PlayQualityInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayQualityInfos.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp_offset_begin != null && Object.hasOwnProperty.call(message, "timestamp_offset_begin"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timestamp_offset_begin);
            if (message.timestamp_offset_end != null && Object.hasOwnProperty.call(message, "timestamp_offset_end"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.timestamp_offset_end);
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.stream_id);
            if (message.session_id != null && Object.hasOwnProperty.call(message, "session_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.session_id);
            if (message.video_width != null && Object.hasOwnProperty.call(message, "video_width"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.video_width);
            if (message.video_height != null && Object.hasOwnProperty.call(message, "video_height"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.video_height);
            if (message.ipv4 != null && Object.hasOwnProperty.call(message, "ipv4"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.ipv4);
            if (message.ipv6 != null && Object.hasOwnProperty.call(message, "ipv6"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.ipv6);
            if (message.resource_type != null && Object.hasOwnProperty.call(message, "resource_type"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.resource_type);
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.logreport.PlayQualityInfo.encode(message.infos[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.room_id);
            if (message.session != null && Object.hasOwnProperty.call(message, "session"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.session);
            if (message.room_session_id != null && Object.hasOwnProperty.call(message, "room_session_id"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint64(message.room_session_id);
            if (message.protocol_type != null && Object.hasOwnProperty.call(message, "protocol_type"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.protocol_type);
            return writer;
        };

        /**
         * Encodes the specified PlayQualityInfos message, length delimited. Does not implicitly {@link logreport.PlayQualityInfos.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.PlayQualityInfos
         * @static
         * @param {logreport.IPlayQualityInfos} message PlayQualityInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayQualityInfos.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlayQualityInfos message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.PlayQualityInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.PlayQualityInfos} PlayQualityInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayQualityInfos.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.PlayQualityInfos();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp_offset_begin = reader.uint32();
                    break;
                case 2:
                    message.timestamp_offset_end = reader.uint32();
                    break;
                case 3:
                    message.stream_id = reader.string();
                    break;
                case 4:
                    message.session_id = reader.uint32();
                    break;
                case 5:
                    message.video_width = reader.uint32();
                    break;
                case 6:
                    message.video_height = reader.uint32();
                    break;
                case 7:
                    message.ipv4 = reader.uint32();
                    break;
                case 8:
                    message.ipv6 = reader.string();
                    break;
                case 9:
                    message.resource_type = reader.uint32();
                    break;
                case 10:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.logreport.PlayQualityInfo.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.room_id = reader.string();
                    break;
                case 13:
                    message.session = reader.string();
                    break;
                case 14:
                    message.room_session_id = reader.uint64();
                    break;
                case 15:
                    message.protocol_type = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlayQualityInfos message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.PlayQualityInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.PlayQualityInfos} PlayQualityInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayQualityInfos.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlayQualityInfos message.
         * @function verify
         * @memberof logreport.PlayQualityInfos
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayQualityInfos.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                if (!$util.isInteger(message.timestamp_offset_begin))
                    return "timestamp_offset_begin: integer expected";
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                if (!$util.isInteger(message.timestamp_offset_end))
                    return "timestamp_offset_end: integer expected";
            if (message.stream_id != null && message.hasOwnProperty("stream_id"))
                if (!$util.isString(message.stream_id))
                    return "stream_id: string expected";
            if (message.session_id != null && message.hasOwnProperty("session_id"))
                if (!$util.isInteger(message.session_id))
                    return "session_id: integer expected";
            if (message.video_width != null && message.hasOwnProperty("video_width"))
                if (!$util.isInteger(message.video_width))
                    return "video_width: integer expected";
            if (message.video_height != null && message.hasOwnProperty("video_height"))
                if (!$util.isInteger(message.video_height))
                    return "video_height: integer expected";
            if (message.ipv4 != null && message.hasOwnProperty("ipv4"))
                if (!$util.isInteger(message.ipv4))
                    return "ipv4: integer expected";
            if (message.ipv6 != null && message.hasOwnProperty("ipv6"))
                if (!$util.isString(message.ipv6))
                    return "ipv6: string expected";
            if (message.resource_type != null && message.hasOwnProperty("resource_type"))
                if (!$util.isInteger(message.resource_type))
                    return "resource_type: integer expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.logreport.PlayQualityInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            if (message.room_id != null && message.hasOwnProperty("room_id"))
                if (!$util.isString(message.room_id))
                    return "room_id: string expected";
            if (message.session != null && message.hasOwnProperty("session"))
                if (!$util.isString(message.session))
                    return "session: string expected";
            if (message.room_session_id != null && message.hasOwnProperty("room_session_id"))
                if (!$util.isInteger(message.room_session_id) && !(message.room_session_id && $util.isInteger(message.room_session_id.low) && $util.isInteger(message.room_session_id.high)))
                    return "room_session_id: integer|Long expected";
            if (message.protocol_type != null && message.hasOwnProperty("protocol_type"))
                if (!$util.isInteger(message.protocol_type))
                    return "protocol_type: integer expected";
            return null;
        };

        /**
         * Creates a PlayQualityInfos message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.PlayQualityInfos
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.PlayQualityInfos} PlayQualityInfos
         */
        PlayQualityInfos.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.PlayQualityInfos)
                return object;
            var message = new $root.logreport.PlayQualityInfos();
            if (object.timestamp_offset_begin != null)
                message.timestamp_offset_begin = object.timestamp_offset_begin >>> 0;
            if (object.timestamp_offset_end != null)
                message.timestamp_offset_end = object.timestamp_offset_end >>> 0;
            if (object.stream_id != null)
                message.stream_id = String(object.stream_id);
            if (object.session_id != null)
                message.session_id = object.session_id >>> 0;
            if (object.video_width != null)
                message.video_width = object.video_width >>> 0;
            if (object.video_height != null)
                message.video_height = object.video_height >>> 0;
            if (object.ipv4 != null)
                message.ipv4 = object.ipv4 >>> 0;
            if (object.ipv6 != null)
                message.ipv6 = String(object.ipv6);
            if (object.resource_type != null)
                message.resource_type = object.resource_type >>> 0;
            if (object.infos) {
                if (!Array.isArray(object.infos))
                    throw TypeError(".logreport.PlayQualityInfos.infos: array expected");
                message.infos = [];
                for (var i = 0; i < object.infos.length; ++i) {
                    if (typeof object.infos[i] !== "object")
                        throw TypeError(".logreport.PlayQualityInfos.infos: object expected");
                    message.infos[i] = $root.logreport.PlayQualityInfo.fromObject(object.infos[i]);
                }
            }
            if (object.room_id != null)
                message.room_id = String(object.room_id);
            if (object.session != null)
                message.session = String(object.session);
            if (object.room_session_id != null)
                if ($util.Long)
                    (message.room_session_id = $util.Long.fromValue(object.room_session_id)).unsigned = true;
                else if (typeof object.room_session_id === "string")
                    message.room_session_id = parseInt(object.room_session_id, 10);
                else if (typeof object.room_session_id === "number")
                    message.room_session_id = object.room_session_id;
                else if (typeof object.room_session_id === "object")
                    message.room_session_id = new $util.LongBits(object.room_session_id.low >>> 0, object.room_session_id.high >>> 0).toNumber(true);
            if (object.protocol_type != null)
                message.protocol_type = object.protocol_type >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PlayQualityInfos message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.PlayQualityInfos
         * @static
         * @param {logreport.PlayQualityInfos} message PlayQualityInfos
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayQualityInfos.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.infos = [];
            if (options.defaults) {
                object.timestamp_offset_begin = 0;
                object.timestamp_offset_end = 0;
                object.stream_id = "";
                object.session_id = 0;
                object.video_width = 0;
                object.video_height = 0;
                object.ipv4 = 0;
                object.ipv6 = "";
                object.resource_type = 0;
                object.room_id = "";
                object.session = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.room_session_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.room_session_id = options.longs === String ? "0" : 0;
                object.protocol_type = 0;
            }
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                object.timestamp_offset_begin = message.timestamp_offset_begin;
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                object.timestamp_offset_end = message.timestamp_offset_end;
            if (message.stream_id != null && message.hasOwnProperty("stream_id"))
                object.stream_id = message.stream_id;
            if (message.session_id != null && message.hasOwnProperty("session_id"))
                object.session_id = message.session_id;
            if (message.video_width != null && message.hasOwnProperty("video_width"))
                object.video_width = message.video_width;
            if (message.video_height != null && message.hasOwnProperty("video_height"))
                object.video_height = message.video_height;
            if (message.ipv4 != null && message.hasOwnProperty("ipv4"))
                object.ipv4 = message.ipv4;
            if (message.ipv6 != null && message.hasOwnProperty("ipv6"))
                object.ipv6 = message.ipv6;
            if (message.resource_type != null && message.hasOwnProperty("resource_type"))
                object.resource_type = message.resource_type;
            if (message.infos && message.infos.length) {
                object.infos = [];
                for (var j = 0; j < message.infos.length; ++j)
                    object.infos[j] = $root.logreport.PlayQualityInfo.toObject(message.infos[j], options);
            }
            if (message.room_id != null && message.hasOwnProperty("room_id"))
                object.room_id = message.room_id;
            if (message.session != null && message.hasOwnProperty("session"))
                object.session = message.session;
            if (message.room_session_id != null && message.hasOwnProperty("room_session_id"))
                if (typeof message.room_session_id === "number")
                    object.room_session_id = options.longs === String ? String(message.room_session_id) : message.room_session_id;
                else
                    object.room_session_id = options.longs === String ? $util.Long.prototype.toString.call(message.room_session_id) : options.longs === Number ? new $util.LongBits(message.room_session_id.low >>> 0, message.room_session_id.high >>> 0).toNumber(true) : message.room_session_id;
            if (message.protocol_type != null && message.hasOwnProperty("protocol_type"))
                object.protocol_type = message.protocol_type;
            return object;
        };

        /**
         * Converts this PlayQualityInfos to JSON.
         * @function toJSON
         * @memberof logreport.PlayQualityInfos
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayQualityInfos.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlayQualityInfos;
    })();

    logreport.ChargeInfos = (function() {

        /**
         * Properties of a ChargeInfos.
         * @memberof logreport
         * @interface IChargeInfos
         * @property {number|null} [timestamp_offset_begin] ChargeInfos timestamp_offset_begin
         * @property {number|null} [timestamp_offset_end] ChargeInfos timestamp_offset_end
         * @property {number|null} [timestamp_diff_flag] ChargeInfos timestamp_diff_flag
         * @property {number|null} [timestamp_diff] ChargeInfos timestamp_diff
         * @property {string|null} [room_id] ChargeInfos room_id
         * @property {Array.<logreport.IChargeInfo>|null} [infos] ChargeInfos infos
         */

        /**
         * Constructs a new ChargeInfos.
         * @memberof logreport
         * @classdesc Represents a ChargeInfos.
         * @implements IChargeInfos
         * @constructor
         * @param {logreport.IChargeInfos=} [properties] Properties to set
         */
        function ChargeInfos(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChargeInfos timestamp_offset_begin.
         * @member {number} timestamp_offset_begin
         * @memberof logreport.ChargeInfos
         * @instance
         */
        ChargeInfos.prototype.timestamp_offset_begin = 0;

        /**
         * ChargeInfos timestamp_offset_end.
         * @member {number} timestamp_offset_end
         * @memberof logreport.ChargeInfos
         * @instance
         */
        ChargeInfos.prototype.timestamp_offset_end = 0;

        /**
         * ChargeInfos timestamp_diff_flag.
         * @member {number} timestamp_diff_flag
         * @memberof logreport.ChargeInfos
         * @instance
         */
        ChargeInfos.prototype.timestamp_diff_flag = 0;

        /**
         * ChargeInfos timestamp_diff.
         * @member {number} timestamp_diff
         * @memberof logreport.ChargeInfos
         * @instance
         */
        ChargeInfos.prototype.timestamp_diff = 0;

        /**
         * ChargeInfos room_id.
         * @member {string} room_id
         * @memberof logreport.ChargeInfos
         * @instance
         */
        ChargeInfos.prototype.room_id = "";

        /**
         * ChargeInfos infos.
         * @member {Array.<logreport.IChargeInfo>} infos
         * @memberof logreport.ChargeInfos
         * @instance
         */
        ChargeInfos.prototype.infos = $util.emptyArray;

        /**
         * Creates a new ChargeInfos instance using the specified properties.
         * @function create
         * @memberof logreport.ChargeInfos
         * @static
         * @param {logreport.IChargeInfos=} [properties] Properties to set
         * @returns {logreport.ChargeInfos} ChargeInfos instance
         */
        ChargeInfos.create = function create(properties) {
            return new ChargeInfos(properties);
        };

        /**
         * Encodes the specified ChargeInfos message. Does not implicitly {@link logreport.ChargeInfos.verify|verify} messages.
         * @function encode
         * @memberof logreport.ChargeInfos
         * @static
         * @param {logreport.IChargeInfos} message ChargeInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChargeInfos.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp_offset_begin != null && Object.hasOwnProperty.call(message, "timestamp_offset_begin"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timestamp_offset_begin);
            if (message.timestamp_offset_end != null && Object.hasOwnProperty.call(message, "timestamp_offset_end"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.timestamp_offset_end);
            if (message.timestamp_diff_flag != null && Object.hasOwnProperty.call(message, "timestamp_diff_flag"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.timestamp_diff_flag);
            if (message.timestamp_diff != null && Object.hasOwnProperty.call(message, "timestamp_diff"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.timestamp_diff);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.room_id);
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.logreport.ChargeInfo.encode(message.infos[i], writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChargeInfos message, length delimited. Does not implicitly {@link logreport.ChargeInfos.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.ChargeInfos
         * @static
         * @param {logreport.IChargeInfos} message ChargeInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChargeInfos.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChargeInfos message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.ChargeInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.ChargeInfos} ChargeInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChargeInfos.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.ChargeInfos();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp_offset_begin = reader.uint32();
                    break;
                case 2:
                    message.timestamp_offset_end = reader.uint32();
                    break;
                case 3:
                    message.timestamp_diff_flag = reader.uint32();
                    break;
                case 4:
                    message.timestamp_diff = reader.uint32();
                    break;
                case 5:
                    message.room_id = reader.string();
                    break;
                case 100:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.logreport.ChargeInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChargeInfos message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.ChargeInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.ChargeInfos} ChargeInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChargeInfos.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChargeInfos message.
         * @function verify
         * @memberof logreport.ChargeInfos
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChargeInfos.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                if (!$util.isInteger(message.timestamp_offset_begin))
                    return "timestamp_offset_begin: integer expected";
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                if (!$util.isInteger(message.timestamp_offset_end))
                    return "timestamp_offset_end: integer expected";
            if (message.timestamp_diff_flag != null && message.hasOwnProperty("timestamp_diff_flag"))
                if (!$util.isInteger(message.timestamp_diff_flag))
                    return "timestamp_diff_flag: integer expected";
            if (message.timestamp_diff != null && message.hasOwnProperty("timestamp_diff"))
                if (!$util.isInteger(message.timestamp_diff))
                    return "timestamp_diff: integer expected";
            if (message.room_id != null && message.hasOwnProperty("room_id"))
                if (!$util.isString(message.room_id))
                    return "room_id: string expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.logreport.ChargeInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ChargeInfos message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.ChargeInfos
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.ChargeInfos} ChargeInfos
         */
        ChargeInfos.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.ChargeInfos)
                return object;
            var message = new $root.logreport.ChargeInfos();
            if (object.timestamp_offset_begin != null)
                message.timestamp_offset_begin = object.timestamp_offset_begin >>> 0;
            if (object.timestamp_offset_end != null)
                message.timestamp_offset_end = object.timestamp_offset_end >>> 0;
            if (object.timestamp_diff_flag != null)
                message.timestamp_diff_flag = object.timestamp_diff_flag >>> 0;
            if (object.timestamp_diff != null)
                message.timestamp_diff = object.timestamp_diff >>> 0;
            if (object.room_id != null)
                message.room_id = String(object.room_id);
            if (object.infos) {
                if (!Array.isArray(object.infos))
                    throw TypeError(".logreport.ChargeInfos.infos: array expected");
                message.infos = [];
                for (var i = 0; i < object.infos.length; ++i) {
                    if (typeof object.infos[i] !== "object")
                        throw TypeError(".logreport.ChargeInfos.infos: object expected");
                    message.infos[i] = $root.logreport.ChargeInfo.fromObject(object.infos[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ChargeInfos message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.ChargeInfos
         * @static
         * @param {logreport.ChargeInfos} message ChargeInfos
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChargeInfos.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.infos = [];
            if (options.defaults) {
                object.timestamp_offset_begin = 0;
                object.timestamp_offset_end = 0;
                object.timestamp_diff_flag = 0;
                object.timestamp_diff = 0;
                object.room_id = "";
            }
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                object.timestamp_offset_begin = message.timestamp_offset_begin;
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                object.timestamp_offset_end = message.timestamp_offset_end;
            if (message.timestamp_diff_flag != null && message.hasOwnProperty("timestamp_diff_flag"))
                object.timestamp_diff_flag = message.timestamp_diff_flag;
            if (message.timestamp_diff != null && message.hasOwnProperty("timestamp_diff"))
                object.timestamp_diff = message.timestamp_diff;
            if (message.room_id != null && message.hasOwnProperty("room_id"))
                object.room_id = message.room_id;
            if (message.infos && message.infos.length) {
                object.infos = [];
                for (var j = 0; j < message.infos.length; ++j)
                    object.infos[j] = $root.logreport.ChargeInfo.toObject(message.infos[j], options);
            }
            return object;
        };

        /**
         * Converts this ChargeInfos to JSON.
         * @function toJSON
         * @memberof logreport.ChargeInfos
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChargeInfos.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChargeInfos;
    })();

    logreport.HardwareInfo = (function() {

        /**
         * Properties of a HardwareInfo.
         * @memberof logreport
         * @interface IHardwareInfo
         * @property {number|null} [sys_cpu_used] HardwareInfo sys_cpu_used
         * @property {number|null} [app_cpu_used] HardwareInfo app_cpu_used
         * @property {number|null} [sys_mem_used] HardwareInfo sys_mem_used
         * @property {number|null} [app_mem_used] HardwareInfo app_mem_used
         */

        /**
         * Constructs a new HardwareInfo.
         * @memberof logreport
         * @classdesc Represents a HardwareInfo.
         * @implements IHardwareInfo
         * @constructor
         * @param {logreport.IHardwareInfo=} [properties] Properties to set
         */
        function HardwareInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HardwareInfo sys_cpu_used.
         * @member {number} sys_cpu_used
         * @memberof logreport.HardwareInfo
         * @instance
         */
        HardwareInfo.prototype.sys_cpu_used = 0;

        /**
         * HardwareInfo app_cpu_used.
         * @member {number} app_cpu_used
         * @memberof logreport.HardwareInfo
         * @instance
         */
        HardwareInfo.prototype.app_cpu_used = 0;

        /**
         * HardwareInfo sys_mem_used.
         * @member {number} sys_mem_used
         * @memberof logreport.HardwareInfo
         * @instance
         */
        HardwareInfo.prototype.sys_mem_used = 0;

        /**
         * HardwareInfo app_mem_used.
         * @member {number} app_mem_used
         * @memberof logreport.HardwareInfo
         * @instance
         */
        HardwareInfo.prototype.app_mem_used = 0;

        /**
         * Creates a new HardwareInfo instance using the specified properties.
         * @function create
         * @memberof logreport.HardwareInfo
         * @static
         * @param {logreport.IHardwareInfo=} [properties] Properties to set
         * @returns {logreport.HardwareInfo} HardwareInfo instance
         */
        HardwareInfo.create = function create(properties) {
            return new HardwareInfo(properties);
        };

        /**
         * Encodes the specified HardwareInfo message. Does not implicitly {@link logreport.HardwareInfo.verify|verify} messages.
         * @function encode
         * @memberof logreport.HardwareInfo
         * @static
         * @param {logreport.IHardwareInfo} message HardwareInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HardwareInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sys_cpu_used != null && Object.hasOwnProperty.call(message, "sys_cpu_used"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.sys_cpu_used);
            if (message.app_cpu_used != null && Object.hasOwnProperty.call(message, "app_cpu_used"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.app_cpu_used);
            if (message.sys_mem_used != null && Object.hasOwnProperty.call(message, "sys_mem_used"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.sys_mem_used);
            if (message.app_mem_used != null && Object.hasOwnProperty.call(message, "app_mem_used"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.app_mem_used);
            return writer;
        };

        /**
         * Encodes the specified HardwareInfo message, length delimited. Does not implicitly {@link logreport.HardwareInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.HardwareInfo
         * @static
         * @param {logreport.IHardwareInfo} message HardwareInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HardwareInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HardwareInfo message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.HardwareInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.HardwareInfo} HardwareInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HardwareInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.HardwareInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sys_cpu_used = reader.uint32();
                    break;
                case 2:
                    message.app_cpu_used = reader.uint32();
                    break;
                case 3:
                    message.sys_mem_used = reader.uint32();
                    break;
                case 4:
                    message.app_mem_used = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HardwareInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.HardwareInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.HardwareInfo} HardwareInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HardwareInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HardwareInfo message.
         * @function verify
         * @memberof logreport.HardwareInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HardwareInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sys_cpu_used != null && message.hasOwnProperty("sys_cpu_used"))
                if (!$util.isInteger(message.sys_cpu_used))
                    return "sys_cpu_used: integer expected";
            if (message.app_cpu_used != null && message.hasOwnProperty("app_cpu_used"))
                if (!$util.isInteger(message.app_cpu_used))
                    return "app_cpu_used: integer expected";
            if (message.sys_mem_used != null && message.hasOwnProperty("sys_mem_used"))
                if (!$util.isInteger(message.sys_mem_used))
                    return "sys_mem_used: integer expected";
            if (message.app_mem_used != null && message.hasOwnProperty("app_mem_used"))
                if (!$util.isInteger(message.app_mem_used))
                    return "app_mem_used: integer expected";
            return null;
        };

        /**
         * Creates a HardwareInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.HardwareInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.HardwareInfo} HardwareInfo
         */
        HardwareInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.HardwareInfo)
                return object;
            var message = new $root.logreport.HardwareInfo();
            if (object.sys_cpu_used != null)
                message.sys_cpu_used = object.sys_cpu_used >>> 0;
            if (object.app_cpu_used != null)
                message.app_cpu_used = object.app_cpu_used >>> 0;
            if (object.sys_mem_used != null)
                message.sys_mem_used = object.sys_mem_used >>> 0;
            if (object.app_mem_used != null)
                message.app_mem_used = object.app_mem_used >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a HardwareInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.HardwareInfo
         * @static
         * @param {logreport.HardwareInfo} message HardwareInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HardwareInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sys_cpu_used = 0;
                object.app_cpu_used = 0;
                object.sys_mem_used = 0;
                object.app_mem_used = 0;
            }
            if (message.sys_cpu_used != null && message.hasOwnProperty("sys_cpu_used"))
                object.sys_cpu_used = message.sys_cpu_used;
            if (message.app_cpu_used != null && message.hasOwnProperty("app_cpu_used"))
                object.app_cpu_used = message.app_cpu_used;
            if (message.sys_mem_used != null && message.hasOwnProperty("sys_mem_used"))
                object.sys_mem_used = message.sys_mem_used;
            if (message.app_mem_used != null && message.hasOwnProperty("app_mem_used"))
                object.app_mem_used = message.app_mem_used;
            return object;
        };

        /**
         * Converts this HardwareInfo to JSON.
         * @function toJSON
         * @memberof logreport.HardwareInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HardwareInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HardwareInfo;
    })();

    logreport.PublishQualityInfo = (function() {

        /**
         * Properties of a PublishQualityInfo.
         * @memberof logreport
         * @interface IPublishQualityInfo
         * @property {number|null} [audio_bitrate] PublishQualityInfo audio_bitrate
         * @property {number|null} [video_bitrate] PublishQualityInfo video_bitrate
         * @property {number|null} [video_capture_fps] PublishQualityInfo video_capture_fps
         * @property {number|null} [video_network_fps] PublishQualityInfo video_network_fps
         * @property {number|null} [uplink_plr] PublishQualityInfo uplink_plr
         * @property {number|null} [rtt] PublishQualityInfo rtt
         * @property {number|null} [audio_network_fps] PublishQualityInfo audio_network_fps
         * @property {number|null} [captured_sound_level] PublishQualityInfo captured_sound_level
         * @property {number|null} [sample_time_window] PublishQualityInfo sample_time_window
         */

        /**
         * Constructs a new PublishQualityInfo.
         * @memberof logreport
         * @classdesc Represents a PublishQualityInfo.
         * @implements IPublishQualityInfo
         * @constructor
         * @param {logreport.IPublishQualityInfo=} [properties] Properties to set
         */
        function PublishQualityInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublishQualityInfo audio_bitrate.
         * @member {number} audio_bitrate
         * @memberof logreport.PublishQualityInfo
         * @instance
         */
        PublishQualityInfo.prototype.audio_bitrate = 0;

        /**
         * PublishQualityInfo video_bitrate.
         * @member {number} video_bitrate
         * @memberof logreport.PublishQualityInfo
         * @instance
         */
        PublishQualityInfo.prototype.video_bitrate = 0;

        /**
         * PublishQualityInfo video_capture_fps.
         * @member {number} video_capture_fps
         * @memberof logreport.PublishQualityInfo
         * @instance
         */
        PublishQualityInfo.prototype.video_capture_fps = 0;

        /**
         * PublishQualityInfo video_network_fps.
         * @member {number} video_network_fps
         * @memberof logreport.PublishQualityInfo
         * @instance
         */
        PublishQualityInfo.prototype.video_network_fps = 0;

        /**
         * PublishQualityInfo uplink_plr.
         * @member {number} uplink_plr
         * @memberof logreport.PublishQualityInfo
         * @instance
         */
        PublishQualityInfo.prototype.uplink_plr = 0;

        /**
         * PublishQualityInfo rtt.
         * @member {number} rtt
         * @memberof logreport.PublishQualityInfo
         * @instance
         */
        PublishQualityInfo.prototype.rtt = 0;

        /**
         * PublishQualityInfo audio_network_fps.
         * @member {number} audio_network_fps
         * @memberof logreport.PublishQualityInfo
         * @instance
         */
        PublishQualityInfo.prototype.audio_network_fps = 0;

        /**
         * PublishQualityInfo captured_sound_level.
         * @member {number} captured_sound_level
         * @memberof logreport.PublishQualityInfo
         * @instance
         */
        PublishQualityInfo.prototype.captured_sound_level = 0;

        /**
         * PublishQualityInfo sample_time_window.
         * @member {number} sample_time_window
         * @memberof logreport.PublishQualityInfo
         * @instance
         */
        PublishQualityInfo.prototype.sample_time_window = 0;

        /**
         * Creates a new PublishQualityInfo instance using the specified properties.
         * @function create
         * @memberof logreport.PublishQualityInfo
         * @static
         * @param {logreport.IPublishQualityInfo=} [properties] Properties to set
         * @returns {logreport.PublishQualityInfo} PublishQualityInfo instance
         */
        PublishQualityInfo.create = function create(properties) {
            return new PublishQualityInfo(properties);
        };

        /**
         * Encodes the specified PublishQualityInfo message. Does not implicitly {@link logreport.PublishQualityInfo.verify|verify} messages.
         * @function encode
         * @memberof logreport.PublishQualityInfo
         * @static
         * @param {logreport.IPublishQualityInfo} message PublishQualityInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishQualityInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audio_bitrate != null && Object.hasOwnProperty.call(message, "audio_bitrate"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.audio_bitrate);
            if (message.video_bitrate != null && Object.hasOwnProperty.call(message, "video_bitrate"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.video_bitrate);
            if (message.video_capture_fps != null && Object.hasOwnProperty.call(message, "video_capture_fps"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.video_capture_fps);
            if (message.video_network_fps != null && Object.hasOwnProperty.call(message, "video_network_fps"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.video_network_fps);
            if (message.uplink_plr != null && Object.hasOwnProperty.call(message, "uplink_plr"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.uplink_plr);
            if (message.rtt != null && Object.hasOwnProperty.call(message, "rtt"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.rtt);
            if (message.audio_network_fps != null && Object.hasOwnProperty.call(message, "audio_network_fps"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.audio_network_fps);
            if (message.captured_sound_level != null && Object.hasOwnProperty.call(message, "captured_sound_level"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.captured_sound_level);
            if (message.sample_time_window != null && Object.hasOwnProperty.call(message, "sample_time_window"))
                writer.uint32(/* id 100, wireType 0 =*/800).uint32(message.sample_time_window);
            return writer;
        };

        /**
         * Encodes the specified PublishQualityInfo message, length delimited. Does not implicitly {@link logreport.PublishQualityInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.PublishQualityInfo
         * @static
         * @param {logreport.IPublishQualityInfo} message PublishQualityInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishQualityInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PublishQualityInfo message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.PublishQualityInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.PublishQualityInfo} PublishQualityInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishQualityInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.PublishQualityInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.audio_bitrate = reader.uint32();
                    break;
                case 2:
                    message.video_bitrate = reader.uint32();
                    break;
                case 3:
                    message.video_capture_fps = reader.uint32();
                    break;
                case 4:
                    message.video_network_fps = reader.uint32();
                    break;
                case 5:
                    message.uplink_plr = reader.uint32();
                    break;
                case 6:
                    message.rtt = reader.uint32();
                    break;
                case 7:
                    message.audio_network_fps = reader.uint32();
                    break;
                case 8:
                    message.captured_sound_level = reader.uint32();
                    break;
                case 100:
                    message.sample_time_window = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PublishQualityInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.PublishQualityInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.PublishQualityInfo} PublishQualityInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishQualityInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PublishQualityInfo message.
         * @function verify
         * @memberof logreport.PublishQualityInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PublishQualityInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.audio_bitrate != null && message.hasOwnProperty("audio_bitrate"))
                if (!$util.isInteger(message.audio_bitrate))
                    return "audio_bitrate: integer expected";
            if (message.video_bitrate != null && message.hasOwnProperty("video_bitrate"))
                if (!$util.isInteger(message.video_bitrate))
                    return "video_bitrate: integer expected";
            if (message.video_capture_fps != null && message.hasOwnProperty("video_capture_fps"))
                if (!$util.isInteger(message.video_capture_fps))
                    return "video_capture_fps: integer expected";
            if (message.video_network_fps != null && message.hasOwnProperty("video_network_fps"))
                if (!$util.isInteger(message.video_network_fps))
                    return "video_network_fps: integer expected";
            if (message.uplink_plr != null && message.hasOwnProperty("uplink_plr"))
                if (!$util.isInteger(message.uplink_plr))
                    return "uplink_plr: integer expected";
            if (message.rtt != null && message.hasOwnProperty("rtt"))
                if (!$util.isInteger(message.rtt))
                    return "rtt: integer expected";
            if (message.audio_network_fps != null && message.hasOwnProperty("audio_network_fps"))
                if (!$util.isInteger(message.audio_network_fps))
                    return "audio_network_fps: integer expected";
            if (message.captured_sound_level != null && message.hasOwnProperty("captured_sound_level"))
                if (!$util.isInteger(message.captured_sound_level))
                    return "captured_sound_level: integer expected";
            if (message.sample_time_window != null && message.hasOwnProperty("sample_time_window"))
                if (!$util.isInteger(message.sample_time_window))
                    return "sample_time_window: integer expected";
            return null;
        };

        /**
         * Creates a PublishQualityInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.PublishQualityInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.PublishQualityInfo} PublishQualityInfo
         */
        PublishQualityInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.PublishQualityInfo)
                return object;
            var message = new $root.logreport.PublishQualityInfo();
            if (object.audio_bitrate != null)
                message.audio_bitrate = object.audio_bitrate >>> 0;
            if (object.video_bitrate != null)
                message.video_bitrate = object.video_bitrate >>> 0;
            if (object.video_capture_fps != null)
                message.video_capture_fps = object.video_capture_fps >>> 0;
            if (object.video_network_fps != null)
                message.video_network_fps = object.video_network_fps >>> 0;
            if (object.uplink_plr != null)
                message.uplink_plr = object.uplink_plr >>> 0;
            if (object.rtt != null)
                message.rtt = object.rtt >>> 0;
            if (object.audio_network_fps != null)
                message.audio_network_fps = object.audio_network_fps >>> 0;
            if (object.captured_sound_level != null)
                message.captured_sound_level = object.captured_sound_level >>> 0;
            if (object.sample_time_window != null)
                message.sample_time_window = object.sample_time_window >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PublishQualityInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.PublishQualityInfo
         * @static
         * @param {logreport.PublishQualityInfo} message PublishQualityInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PublishQualityInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.audio_bitrate = 0;
                object.video_bitrate = 0;
                object.video_capture_fps = 0;
                object.video_network_fps = 0;
                object.uplink_plr = 0;
                object.rtt = 0;
                object.audio_network_fps = 0;
                object.captured_sound_level = 0;
                object.sample_time_window = 0;
            }
            if (message.audio_bitrate != null && message.hasOwnProperty("audio_bitrate"))
                object.audio_bitrate = message.audio_bitrate;
            if (message.video_bitrate != null && message.hasOwnProperty("video_bitrate"))
                object.video_bitrate = message.video_bitrate;
            if (message.video_capture_fps != null && message.hasOwnProperty("video_capture_fps"))
                object.video_capture_fps = message.video_capture_fps;
            if (message.video_network_fps != null && message.hasOwnProperty("video_network_fps"))
                object.video_network_fps = message.video_network_fps;
            if (message.uplink_plr != null && message.hasOwnProperty("uplink_plr"))
                object.uplink_plr = message.uplink_plr;
            if (message.rtt != null && message.hasOwnProperty("rtt"))
                object.rtt = message.rtt;
            if (message.audio_network_fps != null && message.hasOwnProperty("audio_network_fps"))
                object.audio_network_fps = message.audio_network_fps;
            if (message.captured_sound_level != null && message.hasOwnProperty("captured_sound_level"))
                object.captured_sound_level = message.captured_sound_level;
            if (message.sample_time_window != null && message.hasOwnProperty("sample_time_window"))
                object.sample_time_window = message.sample_time_window;
            return object;
        };

        /**
         * Converts this PublishQualityInfo to JSON.
         * @function toJSON
         * @memberof logreport.PublishQualityInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PublishQualityInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PublishQualityInfo;
    })();

    logreport.PlayQualityInfo = (function() {

        /**
         * Properties of a PlayQualityInfo.
         * @memberof logreport
         * @interface IPlayQualityInfo
         * @property {number|null} [audio_bitrate] PlayQualityInfo audio_bitrate
         * @property {number|null} [video_bitrate] PlayQualityInfo video_bitrate
         * @property {number|null} [video_network_fps] PlayQualityInfo video_network_fps
         * @property {number|null} [audio_break_count] PlayQualityInfo audio_break_count
         * @property {number|null} [video_break_count] PlayQualityInfo video_break_count
         * @property {number|null} [downlink_plr] PlayQualityInfo downlink_plr
         * @property {number|null} [peer_to_peer_plr] PlayQualityInfo peer_to_peer_plr
         * @property {number|null} [peer_to_peer_delay] PlayQualityInfo peer_to_peer_delay
         * @property {number|null} [audio_network_fps] PlayQualityInfo audio_network_fps
         * @property {number|null} [audio_break_duration] PlayQualityInfo audio_break_duration
         * @property {number|null} [video_break_duration] PlayQualityInfo video_break_duration
         * @property {number|null} [audio_break_rate] PlayQualityInfo audio_break_rate
         * @property {number|null} [video_break_rate] PlayQualityInfo video_break_rate
         * @property {number|null} [audio_break_cancel] PlayQualityInfo audio_break_cancel
         * @property {number|null} [video_break_cancel] PlayQualityInfo video_break_cancel
         * @property {number|null} [rtt] PlayQualityInfo rtt
         * @property {number|null} [rendered_sound_level] PlayQualityInfo rendered_sound_level
         * @property {number|null} [audio_break_cancel_duration] PlayQualityInfo audio_break_cancel_duration
         * @property {number|null} [video_break_cancel_duration] PlayQualityInfo video_break_cancel_duration
         * @property {number|null} [audio_decode_time] PlayQualityInfo audio_decode_time
         * @property {number|null} [video_decode_time] PlayQualityInfo video_decode_time
         * @property {number|null} [real_sampling_interval] PlayQualityInfo real_sampling_interval
         * @property {number|null} [mos] PlayQualityInfo mos
         * @property {number|null} [audio_decode_fps] PlayQualityInfo audio_decode_fps
         * @property {number|null} [video_decode_fps] PlayQualityInfo video_decode_fps
         * @property {number|null} [video_frames_decoded] PlayQualityInfo video_frames_decoded
         * @property {number|null} [video_frames_dropped] PlayQualityInfo video_frames_dropped
         * @property {number|null} [sample_time_window] PlayQualityInfo sample_time_window
         */

        /**
         * Constructs a new PlayQualityInfo.
         * @memberof logreport
         * @classdesc Represents a PlayQualityInfo.
         * @implements IPlayQualityInfo
         * @constructor
         * @param {logreport.IPlayQualityInfo=} [properties] Properties to set
         */
        function PlayQualityInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlayQualityInfo audio_bitrate.
         * @member {number} audio_bitrate
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.audio_bitrate = 0;

        /**
         * PlayQualityInfo video_bitrate.
         * @member {number} video_bitrate
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_bitrate = 0;

        /**
         * PlayQualityInfo video_network_fps.
         * @member {number} video_network_fps
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_network_fps = 0;

        /**
         * PlayQualityInfo audio_break_count.
         * @member {number} audio_break_count
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.audio_break_count = 0;

        /**
         * PlayQualityInfo video_break_count.
         * @member {number} video_break_count
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_break_count = 0;

        /**
         * PlayQualityInfo downlink_plr.
         * @member {number} downlink_plr
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.downlink_plr = 0;

        /**
         * PlayQualityInfo peer_to_peer_plr.
         * @member {number} peer_to_peer_plr
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.peer_to_peer_plr = 0;

        /**
         * PlayQualityInfo peer_to_peer_delay.
         * @member {number} peer_to_peer_delay
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.peer_to_peer_delay = 0;

        /**
         * PlayQualityInfo audio_network_fps.
         * @member {number} audio_network_fps
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.audio_network_fps = 0;

        /**
         * PlayQualityInfo audio_break_duration.
         * @member {number} audio_break_duration
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.audio_break_duration = 0;

        /**
         * PlayQualityInfo video_break_duration.
         * @member {number} video_break_duration
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_break_duration = 0;

        /**
         * PlayQualityInfo audio_break_rate.
         * @member {number} audio_break_rate
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.audio_break_rate = 0;

        /**
         * PlayQualityInfo video_break_rate.
         * @member {number} video_break_rate
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_break_rate = 0;

        /**
         * PlayQualityInfo audio_break_cancel.
         * @member {number} audio_break_cancel
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.audio_break_cancel = 0;

        /**
         * PlayQualityInfo video_break_cancel.
         * @member {number} video_break_cancel
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_break_cancel = 0;

        /**
         * PlayQualityInfo rtt.
         * @member {number} rtt
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.rtt = 0;

        /**
         * PlayQualityInfo rendered_sound_level.
         * @member {number} rendered_sound_level
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.rendered_sound_level = 0;

        /**
         * PlayQualityInfo audio_break_cancel_duration.
         * @member {number} audio_break_cancel_duration
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.audio_break_cancel_duration = 0;

        /**
         * PlayQualityInfo video_break_cancel_duration.
         * @member {number} video_break_cancel_duration
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_break_cancel_duration = 0;

        /**
         * PlayQualityInfo audio_decode_time.
         * @member {number} audio_decode_time
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.audio_decode_time = 0;

        /**
         * PlayQualityInfo video_decode_time.
         * @member {number} video_decode_time
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_decode_time = 0;

        /**
         * PlayQualityInfo real_sampling_interval.
         * @member {number} real_sampling_interval
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.real_sampling_interval = 0;

        /**
         * PlayQualityInfo mos.
         * @member {number} mos
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.mos = 0;

        /**
         * PlayQualityInfo audio_decode_fps.
         * @member {number} audio_decode_fps
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.audio_decode_fps = 0;

        /**
         * PlayQualityInfo video_decode_fps.
         * @member {number} video_decode_fps
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_decode_fps = 0;

        /**
         * PlayQualityInfo video_frames_decoded.
         * @member {number} video_frames_decoded
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_frames_decoded = 0;

        /**
         * PlayQualityInfo video_frames_dropped.
         * @member {number} video_frames_dropped
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.video_frames_dropped = 0;

        /**
         * PlayQualityInfo sample_time_window.
         * @member {number} sample_time_window
         * @memberof logreport.PlayQualityInfo
         * @instance
         */
        PlayQualityInfo.prototype.sample_time_window = 0;

        /**
         * Creates a new PlayQualityInfo instance using the specified properties.
         * @function create
         * @memberof logreport.PlayQualityInfo
         * @static
         * @param {logreport.IPlayQualityInfo=} [properties] Properties to set
         * @returns {logreport.PlayQualityInfo} PlayQualityInfo instance
         */
        PlayQualityInfo.create = function create(properties) {
            return new PlayQualityInfo(properties);
        };

        /**
         * Encodes the specified PlayQualityInfo message. Does not implicitly {@link logreport.PlayQualityInfo.verify|verify} messages.
         * @function encode
         * @memberof logreport.PlayQualityInfo
         * @static
         * @param {logreport.IPlayQualityInfo} message PlayQualityInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayQualityInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audio_bitrate != null && Object.hasOwnProperty.call(message, "audio_bitrate"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.audio_bitrate);
            if (message.video_bitrate != null && Object.hasOwnProperty.call(message, "video_bitrate"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.video_bitrate);
            if (message.video_network_fps != null && Object.hasOwnProperty.call(message, "video_network_fps"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.video_network_fps);
            if (message.audio_break_count != null && Object.hasOwnProperty.call(message, "audio_break_count"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.audio_break_count);
            if (message.video_break_count != null && Object.hasOwnProperty.call(message, "video_break_count"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.video_break_count);
            if (message.downlink_plr != null && Object.hasOwnProperty.call(message, "downlink_plr"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.downlink_plr);
            if (message.peer_to_peer_plr != null && Object.hasOwnProperty.call(message, "peer_to_peer_plr"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.peer_to_peer_plr);
            if (message.peer_to_peer_delay != null && Object.hasOwnProperty.call(message, "peer_to_peer_delay"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.peer_to_peer_delay);
            if (message.audio_network_fps != null && Object.hasOwnProperty.call(message, "audio_network_fps"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.audio_network_fps);
            if (message.audio_break_duration != null && Object.hasOwnProperty.call(message, "audio_break_duration"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.audio_break_duration);
            if (message.video_break_duration != null && Object.hasOwnProperty.call(message, "video_break_duration"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.video_break_duration);
            if (message.audio_break_rate != null && Object.hasOwnProperty.call(message, "audio_break_rate"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.audio_break_rate);
            if (message.video_break_rate != null && Object.hasOwnProperty.call(message, "video_break_rate"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.video_break_rate);
            if (message.audio_break_cancel != null && Object.hasOwnProperty.call(message, "audio_break_cancel"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.audio_break_cancel);
            if (message.video_break_cancel != null && Object.hasOwnProperty.call(message, "video_break_cancel"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.video_break_cancel);
            if (message.rtt != null && Object.hasOwnProperty.call(message, "rtt"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.rtt);
            if (message.rendered_sound_level != null && Object.hasOwnProperty.call(message, "rendered_sound_level"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint32(message.rendered_sound_level);
            if (message.audio_break_cancel_duration != null && Object.hasOwnProperty.call(message, "audio_break_cancel_duration"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.audio_break_cancel_duration);
            if (message.video_break_cancel_duration != null && Object.hasOwnProperty.call(message, "video_break_cancel_duration"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.video_break_cancel_duration);
            if (message.audio_decode_time != null && Object.hasOwnProperty.call(message, "audio_decode_time"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.audio_decode_time);
            if (message.video_decode_time != null && Object.hasOwnProperty.call(message, "video_decode_time"))
                writer.uint32(/* id 21, wireType 0 =*/168).uint32(message.video_decode_time);
            if (message.real_sampling_interval != null && Object.hasOwnProperty.call(message, "real_sampling_interval"))
                writer.uint32(/* id 22, wireType 0 =*/176).uint32(message.real_sampling_interval);
            if (message.mos != null && Object.hasOwnProperty.call(message, "mos"))
                writer.uint32(/* id 23, wireType 0 =*/184).int32(message.mos);
            if (message.audio_decode_fps != null && Object.hasOwnProperty.call(message, "audio_decode_fps"))
                writer.uint32(/* id 24, wireType 0 =*/192).uint32(message.audio_decode_fps);
            if (message.video_decode_fps != null && Object.hasOwnProperty.call(message, "video_decode_fps"))
                writer.uint32(/* id 25, wireType 0 =*/200).uint32(message.video_decode_fps);
            if (message.video_frames_decoded != null && Object.hasOwnProperty.call(message, "video_frames_decoded"))
                writer.uint32(/* id 26, wireType 0 =*/208).uint32(message.video_frames_decoded);
            if (message.video_frames_dropped != null && Object.hasOwnProperty.call(message, "video_frames_dropped"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint32(message.video_frames_dropped);
            if (message.sample_time_window != null && Object.hasOwnProperty.call(message, "sample_time_window"))
                writer.uint32(/* id 100, wireType 0 =*/800).uint32(message.sample_time_window);
            return writer;
        };

        /**
         * Encodes the specified PlayQualityInfo message, length delimited. Does not implicitly {@link logreport.PlayQualityInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.PlayQualityInfo
         * @static
         * @param {logreport.IPlayQualityInfo} message PlayQualityInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayQualityInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlayQualityInfo message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.PlayQualityInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.PlayQualityInfo} PlayQualityInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayQualityInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.PlayQualityInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.audio_bitrate = reader.uint32();
                    break;
                case 2:
                    message.video_bitrate = reader.uint32();
                    break;
                case 3:
                    message.video_network_fps = reader.uint32();
                    break;
                case 4:
                    message.audio_break_count = reader.uint32();
                    break;
                case 5:
                    message.video_break_count = reader.uint32();
                    break;
                case 6:
                    message.downlink_plr = reader.uint32();
                    break;
                case 7:
                    message.peer_to_peer_plr = reader.uint32();
                    break;
                case 8:
                    message.peer_to_peer_delay = reader.uint32();
                    break;
                case 9:
                    message.audio_network_fps = reader.uint32();
                    break;
                case 10:
                    message.audio_break_duration = reader.uint32();
                    break;
                case 11:
                    message.video_break_duration = reader.uint32();
                    break;
                case 12:
                    message.audio_break_rate = reader.uint32();
                    break;
                case 13:
                    message.video_break_rate = reader.uint32();
                    break;
                case 14:
                    message.audio_break_cancel = reader.uint32();
                    break;
                case 15:
                    message.video_break_cancel = reader.uint32();
                    break;
                case 16:
                    message.rtt = reader.uint32();
                    break;
                case 17:
                    message.rendered_sound_level = reader.uint32();
                    break;
                case 18:
                    message.audio_break_cancel_duration = reader.uint32();
                    break;
                case 19:
                    message.video_break_cancel_duration = reader.uint32();
                    break;
                case 20:
                    message.audio_decode_time = reader.uint32();
                    break;
                case 21:
                    message.video_decode_time = reader.uint32();
                    break;
                case 22:
                    message.real_sampling_interval = reader.uint32();
                    break;
                case 23:
                    message.mos = reader.int32();
                    break;
                case 24:
                    message.audio_decode_fps = reader.uint32();
                    break;
                case 25:
                    message.video_decode_fps = reader.uint32();
                    break;
                case 26:
                    message.video_frames_decoded = reader.uint32();
                    break;
                case 27:
                    message.video_frames_dropped = reader.uint32();
                    break;
                case 100:
                    message.sample_time_window = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlayQualityInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.PlayQualityInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.PlayQualityInfo} PlayQualityInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayQualityInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlayQualityInfo message.
         * @function verify
         * @memberof logreport.PlayQualityInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayQualityInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.audio_bitrate != null && message.hasOwnProperty("audio_bitrate"))
                if (!$util.isInteger(message.audio_bitrate))
                    return "audio_bitrate: integer expected";
            if (message.video_bitrate != null && message.hasOwnProperty("video_bitrate"))
                if (!$util.isInteger(message.video_bitrate))
                    return "video_bitrate: integer expected";
            if (message.video_network_fps != null && message.hasOwnProperty("video_network_fps"))
                if (!$util.isInteger(message.video_network_fps))
                    return "video_network_fps: integer expected";
            if (message.audio_break_count != null && message.hasOwnProperty("audio_break_count"))
                if (!$util.isInteger(message.audio_break_count))
                    return "audio_break_count: integer expected";
            if (message.video_break_count != null && message.hasOwnProperty("video_break_count"))
                if (!$util.isInteger(message.video_break_count))
                    return "video_break_count: integer expected";
            if (message.downlink_plr != null && message.hasOwnProperty("downlink_plr"))
                if (!$util.isInteger(message.downlink_plr))
                    return "downlink_plr: integer expected";
            if (message.peer_to_peer_plr != null && message.hasOwnProperty("peer_to_peer_plr"))
                if (!$util.isInteger(message.peer_to_peer_plr))
                    return "peer_to_peer_plr: integer expected";
            if (message.peer_to_peer_delay != null && message.hasOwnProperty("peer_to_peer_delay"))
                if (!$util.isInteger(message.peer_to_peer_delay))
                    return "peer_to_peer_delay: integer expected";
            if (message.audio_network_fps != null && message.hasOwnProperty("audio_network_fps"))
                if (!$util.isInteger(message.audio_network_fps))
                    return "audio_network_fps: integer expected";
            if (message.audio_break_duration != null && message.hasOwnProperty("audio_break_duration"))
                if (!$util.isInteger(message.audio_break_duration))
                    return "audio_break_duration: integer expected";
            if (message.video_break_duration != null && message.hasOwnProperty("video_break_duration"))
                if (!$util.isInteger(message.video_break_duration))
                    return "video_break_duration: integer expected";
            if (message.audio_break_rate != null && message.hasOwnProperty("audio_break_rate"))
                if (!$util.isInteger(message.audio_break_rate))
                    return "audio_break_rate: integer expected";
            if (message.video_break_rate != null && message.hasOwnProperty("video_break_rate"))
                if (!$util.isInteger(message.video_break_rate))
                    return "video_break_rate: integer expected";
            if (message.audio_break_cancel != null && message.hasOwnProperty("audio_break_cancel"))
                if (!$util.isInteger(message.audio_break_cancel))
                    return "audio_break_cancel: integer expected";
            if (message.video_break_cancel != null && message.hasOwnProperty("video_break_cancel"))
                if (!$util.isInteger(message.video_break_cancel))
                    return "video_break_cancel: integer expected";
            if (message.rtt != null && message.hasOwnProperty("rtt"))
                if (!$util.isInteger(message.rtt))
                    return "rtt: integer expected";
            if (message.rendered_sound_level != null && message.hasOwnProperty("rendered_sound_level"))
                if (!$util.isInteger(message.rendered_sound_level))
                    return "rendered_sound_level: integer expected";
            if (message.audio_break_cancel_duration != null && message.hasOwnProperty("audio_break_cancel_duration"))
                if (!$util.isInteger(message.audio_break_cancel_duration))
                    return "audio_break_cancel_duration: integer expected";
            if (message.video_break_cancel_duration != null && message.hasOwnProperty("video_break_cancel_duration"))
                if (!$util.isInteger(message.video_break_cancel_duration))
                    return "video_break_cancel_duration: integer expected";
            if (message.audio_decode_time != null && message.hasOwnProperty("audio_decode_time"))
                if (!$util.isInteger(message.audio_decode_time))
                    return "audio_decode_time: integer expected";
            if (message.video_decode_time != null && message.hasOwnProperty("video_decode_time"))
                if (!$util.isInteger(message.video_decode_time))
                    return "video_decode_time: integer expected";
            if (message.real_sampling_interval != null && message.hasOwnProperty("real_sampling_interval"))
                if (!$util.isInteger(message.real_sampling_interval))
                    return "real_sampling_interval: integer expected";
            if (message.mos != null && message.hasOwnProperty("mos"))
                if (!$util.isInteger(message.mos))
                    return "mos: integer expected";
            if (message.audio_decode_fps != null && message.hasOwnProperty("audio_decode_fps"))
                if (!$util.isInteger(message.audio_decode_fps))
                    return "audio_decode_fps: integer expected";
            if (message.video_decode_fps != null && message.hasOwnProperty("video_decode_fps"))
                if (!$util.isInteger(message.video_decode_fps))
                    return "video_decode_fps: integer expected";
            if (message.video_frames_decoded != null && message.hasOwnProperty("video_frames_decoded"))
                if (!$util.isInteger(message.video_frames_decoded))
                    return "video_frames_decoded: integer expected";
            if (message.video_frames_dropped != null && message.hasOwnProperty("video_frames_dropped"))
                if (!$util.isInteger(message.video_frames_dropped))
                    return "video_frames_dropped: integer expected";
            if (message.sample_time_window != null && message.hasOwnProperty("sample_time_window"))
                if (!$util.isInteger(message.sample_time_window))
                    return "sample_time_window: integer expected";
            return null;
        };

        /**
         * Creates a PlayQualityInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.PlayQualityInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.PlayQualityInfo} PlayQualityInfo
         */
        PlayQualityInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.PlayQualityInfo)
                return object;
            var message = new $root.logreport.PlayQualityInfo();
            if (object.audio_bitrate != null)
                message.audio_bitrate = object.audio_bitrate >>> 0;
            if (object.video_bitrate != null)
                message.video_bitrate = object.video_bitrate >>> 0;
            if (object.video_network_fps != null)
                message.video_network_fps = object.video_network_fps >>> 0;
            if (object.audio_break_count != null)
                message.audio_break_count = object.audio_break_count >>> 0;
            if (object.video_break_count != null)
                message.video_break_count = object.video_break_count >>> 0;
            if (object.downlink_plr != null)
                message.downlink_plr = object.downlink_plr >>> 0;
            if (object.peer_to_peer_plr != null)
                message.peer_to_peer_plr = object.peer_to_peer_plr >>> 0;
            if (object.peer_to_peer_delay != null)
                message.peer_to_peer_delay = object.peer_to_peer_delay >>> 0;
            if (object.audio_network_fps != null)
                message.audio_network_fps = object.audio_network_fps >>> 0;
            if (object.audio_break_duration != null)
                message.audio_break_duration = object.audio_break_duration >>> 0;
            if (object.video_break_duration != null)
                message.video_break_duration = object.video_break_duration >>> 0;
            if (object.audio_break_rate != null)
                message.audio_break_rate = object.audio_break_rate >>> 0;
            if (object.video_break_rate != null)
                message.video_break_rate = object.video_break_rate >>> 0;
            if (object.audio_break_cancel != null)
                message.audio_break_cancel = object.audio_break_cancel >>> 0;
            if (object.video_break_cancel != null)
                message.video_break_cancel = object.video_break_cancel >>> 0;
            if (object.rtt != null)
                message.rtt = object.rtt >>> 0;
            if (object.rendered_sound_level != null)
                message.rendered_sound_level = object.rendered_sound_level >>> 0;
            if (object.audio_break_cancel_duration != null)
                message.audio_break_cancel_duration = object.audio_break_cancel_duration >>> 0;
            if (object.video_break_cancel_duration != null)
                message.video_break_cancel_duration = object.video_break_cancel_duration >>> 0;
            if (object.audio_decode_time != null)
                message.audio_decode_time = object.audio_decode_time >>> 0;
            if (object.video_decode_time != null)
                message.video_decode_time = object.video_decode_time >>> 0;
            if (object.real_sampling_interval != null)
                message.real_sampling_interval = object.real_sampling_interval >>> 0;
            if (object.mos != null)
                message.mos = object.mos | 0;
            if (object.audio_decode_fps != null)
                message.audio_decode_fps = object.audio_decode_fps >>> 0;
            if (object.video_decode_fps != null)
                message.video_decode_fps = object.video_decode_fps >>> 0;
            if (object.video_frames_decoded != null)
                message.video_frames_decoded = object.video_frames_decoded >>> 0;
            if (object.video_frames_dropped != null)
                message.video_frames_dropped = object.video_frames_dropped >>> 0;
            if (object.sample_time_window != null)
                message.sample_time_window = object.sample_time_window >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PlayQualityInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.PlayQualityInfo
         * @static
         * @param {logreport.PlayQualityInfo} message PlayQualityInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayQualityInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.audio_bitrate = 0;
                object.video_bitrate = 0;
                object.video_network_fps = 0;
                object.audio_break_count = 0;
                object.video_break_count = 0;
                object.downlink_plr = 0;
                object.peer_to_peer_plr = 0;
                object.peer_to_peer_delay = 0;
                object.audio_network_fps = 0;
                object.audio_break_duration = 0;
                object.video_break_duration = 0;
                object.audio_break_rate = 0;
                object.video_break_rate = 0;
                object.audio_break_cancel = 0;
                object.video_break_cancel = 0;
                object.rtt = 0;
                object.rendered_sound_level = 0;
                object.audio_break_cancel_duration = 0;
                object.video_break_cancel_duration = 0;
                object.audio_decode_time = 0;
                object.video_decode_time = 0;
                object.real_sampling_interval = 0;
                object.mos = 0;
                object.audio_decode_fps = 0;
                object.video_decode_fps = 0;
                object.video_frames_decoded = 0;
                object.video_frames_dropped = 0;
                object.sample_time_window = 0;
            }
            if (message.audio_bitrate != null && message.hasOwnProperty("audio_bitrate"))
                object.audio_bitrate = message.audio_bitrate;
            if (message.video_bitrate != null && message.hasOwnProperty("video_bitrate"))
                object.video_bitrate = message.video_bitrate;
            if (message.video_network_fps != null && message.hasOwnProperty("video_network_fps"))
                object.video_network_fps = message.video_network_fps;
            if (message.audio_break_count != null && message.hasOwnProperty("audio_break_count"))
                object.audio_break_count = message.audio_break_count;
            if (message.video_break_count != null && message.hasOwnProperty("video_break_count"))
                object.video_break_count = message.video_break_count;
            if (message.downlink_plr != null && message.hasOwnProperty("downlink_plr"))
                object.downlink_plr = message.downlink_plr;
            if (message.peer_to_peer_plr != null && message.hasOwnProperty("peer_to_peer_plr"))
                object.peer_to_peer_plr = message.peer_to_peer_plr;
            if (message.peer_to_peer_delay != null && message.hasOwnProperty("peer_to_peer_delay"))
                object.peer_to_peer_delay = message.peer_to_peer_delay;
            if (message.audio_network_fps != null && message.hasOwnProperty("audio_network_fps"))
                object.audio_network_fps = message.audio_network_fps;
            if (message.audio_break_duration != null && message.hasOwnProperty("audio_break_duration"))
                object.audio_break_duration = message.audio_break_duration;
            if (message.video_break_duration != null && message.hasOwnProperty("video_break_duration"))
                object.video_break_duration = message.video_break_duration;
            if (message.audio_break_rate != null && message.hasOwnProperty("audio_break_rate"))
                object.audio_break_rate = message.audio_break_rate;
            if (message.video_break_rate != null && message.hasOwnProperty("video_break_rate"))
                object.video_break_rate = message.video_break_rate;
            if (message.audio_break_cancel != null && message.hasOwnProperty("audio_break_cancel"))
                object.audio_break_cancel = message.audio_break_cancel;
            if (message.video_break_cancel != null && message.hasOwnProperty("video_break_cancel"))
                object.video_break_cancel = message.video_break_cancel;
            if (message.rtt != null && message.hasOwnProperty("rtt"))
                object.rtt = message.rtt;
            if (message.rendered_sound_level != null && message.hasOwnProperty("rendered_sound_level"))
                object.rendered_sound_level = message.rendered_sound_level;
            if (message.audio_break_cancel_duration != null && message.hasOwnProperty("audio_break_cancel_duration"))
                object.audio_break_cancel_duration = message.audio_break_cancel_duration;
            if (message.video_break_cancel_duration != null && message.hasOwnProperty("video_break_cancel_duration"))
                object.video_break_cancel_duration = message.video_break_cancel_duration;
            if (message.audio_decode_time != null && message.hasOwnProperty("audio_decode_time"))
                object.audio_decode_time = message.audio_decode_time;
            if (message.video_decode_time != null && message.hasOwnProperty("video_decode_time"))
                object.video_decode_time = message.video_decode_time;
            if (message.real_sampling_interval != null && message.hasOwnProperty("real_sampling_interval"))
                object.real_sampling_interval = message.real_sampling_interval;
            if (message.mos != null && message.hasOwnProperty("mos"))
                object.mos = message.mos;
            if (message.audio_decode_fps != null && message.hasOwnProperty("audio_decode_fps"))
                object.audio_decode_fps = message.audio_decode_fps;
            if (message.video_decode_fps != null && message.hasOwnProperty("video_decode_fps"))
                object.video_decode_fps = message.video_decode_fps;
            if (message.video_frames_decoded != null && message.hasOwnProperty("video_frames_decoded"))
                object.video_frames_decoded = message.video_frames_decoded;
            if (message.video_frames_dropped != null && message.hasOwnProperty("video_frames_dropped"))
                object.video_frames_dropped = message.video_frames_dropped;
            if (message.sample_time_window != null && message.hasOwnProperty("sample_time_window"))
                object.sample_time_window = message.sample_time_window;
            return object;
        };

        /**
         * Converts this PlayQualityInfo to JSON.
         * @function toJSON
         * @memberof logreport.PlayQualityInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayQualityInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PlayQualityInfo;
    })();

    logreport.ChargeInfo = (function() {

        /**
         * Properties of a ChargeInfo.
         * @memberof logreport
         * @interface IChargeInfo
         * @property {number|null} [is_publishing] ChargeInfo is_publishing
         * @property {Array.<logreport.IResolutionInfo>|null} [play_stream_resolution_infos] ChargeInfo play_stream_resolution_infos
         * @property {number|null} [play_max_audio_bitrate] ChargeInfo play_max_audio_bitrate
         */

        /**
         * Constructs a new ChargeInfo.
         * @memberof logreport
         * @classdesc Represents a ChargeInfo.
         * @implements IChargeInfo
         * @constructor
         * @param {logreport.IChargeInfo=} [properties] Properties to set
         */
        function ChargeInfo(properties) {
            this.play_stream_resolution_infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChargeInfo is_publishing.
         * @member {number} is_publishing
         * @memberof logreport.ChargeInfo
         * @instance
         */
        ChargeInfo.prototype.is_publishing = 0;

        /**
         * ChargeInfo play_stream_resolution_infos.
         * @member {Array.<logreport.IResolutionInfo>} play_stream_resolution_infos
         * @memberof logreport.ChargeInfo
         * @instance
         */
        ChargeInfo.prototype.play_stream_resolution_infos = $util.emptyArray;

        /**
         * ChargeInfo play_max_audio_bitrate.
         * @member {number} play_max_audio_bitrate
         * @memberof logreport.ChargeInfo
         * @instance
         */
        ChargeInfo.prototype.play_max_audio_bitrate = 0;

        /**
         * Creates a new ChargeInfo instance using the specified properties.
         * @function create
         * @memberof logreport.ChargeInfo
         * @static
         * @param {logreport.IChargeInfo=} [properties] Properties to set
         * @returns {logreport.ChargeInfo} ChargeInfo instance
         */
        ChargeInfo.create = function create(properties) {
            return new ChargeInfo(properties);
        };

        /**
         * Encodes the specified ChargeInfo message. Does not implicitly {@link logreport.ChargeInfo.verify|verify} messages.
         * @function encode
         * @memberof logreport.ChargeInfo
         * @static
         * @param {logreport.IChargeInfo} message ChargeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChargeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.is_publishing != null && Object.hasOwnProperty.call(message, "is_publishing"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.is_publishing);
            if (message.play_stream_resolution_infos != null && message.play_stream_resolution_infos.length)
                for (var i = 0; i < message.play_stream_resolution_infos.length; ++i)
                    $root.logreport.ResolutionInfo.encode(message.play_stream_resolution_infos[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.play_max_audio_bitrate != null && Object.hasOwnProperty.call(message, "play_max_audio_bitrate"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.play_max_audio_bitrate);
            return writer;
        };

        /**
         * Encodes the specified ChargeInfo message, length delimited. Does not implicitly {@link logreport.ChargeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.ChargeInfo
         * @static
         * @param {logreport.IChargeInfo} message ChargeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChargeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChargeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.ChargeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.ChargeInfo} ChargeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChargeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.ChargeInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.is_publishing = reader.uint32();
                    break;
                case 2:
                    if (!(message.play_stream_resolution_infos && message.play_stream_resolution_infos.length))
                        message.play_stream_resolution_infos = [];
                    message.play_stream_resolution_infos.push($root.logreport.ResolutionInfo.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.play_max_audio_bitrate = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChargeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.ChargeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.ChargeInfo} ChargeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChargeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChargeInfo message.
         * @function verify
         * @memberof logreport.ChargeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChargeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.is_publishing != null && message.hasOwnProperty("is_publishing"))
                if (!$util.isInteger(message.is_publishing))
                    return "is_publishing: integer expected";
            if (message.play_stream_resolution_infos != null && message.hasOwnProperty("play_stream_resolution_infos")) {
                if (!Array.isArray(message.play_stream_resolution_infos))
                    return "play_stream_resolution_infos: array expected";
                for (var i = 0; i < message.play_stream_resolution_infos.length; ++i) {
                    var error = $root.logreport.ResolutionInfo.verify(message.play_stream_resolution_infos[i]);
                    if (error)
                        return "play_stream_resolution_infos." + error;
                }
            }
            if (message.play_max_audio_bitrate != null && message.hasOwnProperty("play_max_audio_bitrate"))
                if (!$util.isInteger(message.play_max_audio_bitrate))
                    return "play_max_audio_bitrate: integer expected";
            return null;
        };

        /**
         * Creates a ChargeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.ChargeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.ChargeInfo} ChargeInfo
         */
        ChargeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.ChargeInfo)
                return object;
            var message = new $root.logreport.ChargeInfo();
            if (object.is_publishing != null)
                message.is_publishing = object.is_publishing >>> 0;
            if (object.play_stream_resolution_infos) {
                if (!Array.isArray(object.play_stream_resolution_infos))
                    throw TypeError(".logreport.ChargeInfo.play_stream_resolution_infos: array expected");
                message.play_stream_resolution_infos = [];
                for (var i = 0; i < object.play_stream_resolution_infos.length; ++i) {
                    if (typeof object.play_stream_resolution_infos[i] !== "object")
                        throw TypeError(".logreport.ChargeInfo.play_stream_resolution_infos: object expected");
                    message.play_stream_resolution_infos[i] = $root.logreport.ResolutionInfo.fromObject(object.play_stream_resolution_infos[i]);
                }
            }
            if (object.play_max_audio_bitrate != null)
                message.play_max_audio_bitrate = object.play_max_audio_bitrate >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ChargeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.ChargeInfo
         * @static
         * @param {logreport.ChargeInfo} message ChargeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChargeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.play_stream_resolution_infos = [];
            if (options.defaults) {
                object.is_publishing = 0;
                object.play_max_audio_bitrate = 0;
            }
            if (message.is_publishing != null && message.hasOwnProperty("is_publishing"))
                object.is_publishing = message.is_publishing;
            if (message.play_stream_resolution_infos && message.play_stream_resolution_infos.length) {
                object.play_stream_resolution_infos = [];
                for (var j = 0; j < message.play_stream_resolution_infos.length; ++j)
                    object.play_stream_resolution_infos[j] = $root.logreport.ResolutionInfo.toObject(message.play_stream_resolution_infos[j], options);
            }
            if (message.play_max_audio_bitrate != null && message.hasOwnProperty("play_max_audio_bitrate"))
                object.play_max_audio_bitrate = message.play_max_audio_bitrate;
            return object;
        };

        /**
         * Converts this ChargeInfo to JSON.
         * @function toJSON
         * @memberof logreport.ChargeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChargeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChargeInfo;
    })();

    logreport.ResolutionInfo = (function() {

        /**
         * Properties of a ResolutionInfo.
         * @memberof logreport
         * @interface IResolutionInfo
         * @property {number|null} [video_width] ResolutionInfo video_width
         * @property {number|null} [video_height] ResolutionInfo video_height
         * @property {number|null} [count] ResolutionInfo count
         */

        /**
         * Constructs a new ResolutionInfo.
         * @memberof logreport
         * @classdesc Represents a ResolutionInfo.
         * @implements IResolutionInfo
         * @constructor
         * @param {logreport.IResolutionInfo=} [properties] Properties to set
         */
        function ResolutionInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResolutionInfo video_width.
         * @member {number} video_width
         * @memberof logreport.ResolutionInfo
         * @instance
         */
        ResolutionInfo.prototype.video_width = 0;

        /**
         * ResolutionInfo video_height.
         * @member {number} video_height
         * @memberof logreport.ResolutionInfo
         * @instance
         */
        ResolutionInfo.prototype.video_height = 0;

        /**
         * ResolutionInfo count.
         * @member {number} count
         * @memberof logreport.ResolutionInfo
         * @instance
         */
        ResolutionInfo.prototype.count = 0;

        /**
         * Creates a new ResolutionInfo instance using the specified properties.
         * @function create
         * @memberof logreport.ResolutionInfo
         * @static
         * @param {logreport.IResolutionInfo=} [properties] Properties to set
         * @returns {logreport.ResolutionInfo} ResolutionInfo instance
         */
        ResolutionInfo.create = function create(properties) {
            return new ResolutionInfo(properties);
        };

        /**
         * Encodes the specified ResolutionInfo message. Does not implicitly {@link logreport.ResolutionInfo.verify|verify} messages.
         * @function encode
         * @memberof logreport.ResolutionInfo
         * @static
         * @param {logreport.IResolutionInfo} message ResolutionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResolutionInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.video_width != null && Object.hasOwnProperty.call(message, "video_width"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.video_width);
            if (message.video_height != null && Object.hasOwnProperty.call(message, "video_height"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.video_height);
            if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.count);
            return writer;
        };

        /**
         * Encodes the specified ResolutionInfo message, length delimited. Does not implicitly {@link logreport.ResolutionInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.ResolutionInfo
         * @static
         * @param {logreport.IResolutionInfo} message ResolutionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResolutionInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResolutionInfo message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.ResolutionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.ResolutionInfo} ResolutionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResolutionInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.ResolutionInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.video_width = reader.uint32();
                    break;
                case 2:
                    message.video_height = reader.uint32();
                    break;
                case 3:
                    message.count = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResolutionInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.ResolutionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.ResolutionInfo} ResolutionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResolutionInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResolutionInfo message.
         * @function verify
         * @memberof logreport.ResolutionInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResolutionInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.video_width != null && message.hasOwnProperty("video_width"))
                if (!$util.isInteger(message.video_width))
                    return "video_width: integer expected";
            if (message.video_height != null && message.hasOwnProperty("video_height"))
                if (!$util.isInteger(message.video_height))
                    return "video_height: integer expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        /**
         * Creates a ResolutionInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.ResolutionInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.ResolutionInfo} ResolutionInfo
         */
        ResolutionInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.ResolutionInfo)
                return object;
            var message = new $root.logreport.ResolutionInfo();
            if (object.video_width != null)
                message.video_width = object.video_width >>> 0;
            if (object.video_height != null)
                message.video_height = object.video_height >>> 0;
            if (object.count != null)
                message.count = object.count >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ResolutionInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.ResolutionInfo
         * @static
         * @param {logreport.ResolutionInfo} message ResolutionInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResolutionInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.video_width = 0;
                object.video_height = 0;
                object.count = 0;
            }
            if (message.video_width != null && message.hasOwnProperty("video_width"))
                object.video_width = message.video_width;
            if (message.video_height != null && message.hasOwnProperty("video_height"))
                object.video_height = message.video_height;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };

        /**
         * Converts this ResolutionInfo to JSON.
         * @function toJSON
         * @memberof logreport.ResolutionInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResolutionInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResolutionInfo;
    })();

    logreport.NoBillingEvent = (function() {

        /**
         * Properties of a NoBillingEvent.
         * @memberof logreport
         * @interface INoBillingEvent
         * @property {string|null} [platform_info] NoBillingEvent platform_info
         * @property {string|null} [room_id] NoBillingEvent room_id
         */

        /**
         * Constructs a new NoBillingEvent.
         * @memberof logreport
         * @classdesc Represents a NoBillingEvent.
         * @implements INoBillingEvent
         * @constructor
         * @param {logreport.INoBillingEvent=} [properties] Properties to set
         */
        function NoBillingEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NoBillingEvent platform_info.
         * @member {string} platform_info
         * @memberof logreport.NoBillingEvent
         * @instance
         */
        NoBillingEvent.prototype.platform_info = "";

        /**
         * NoBillingEvent room_id.
         * @member {string} room_id
         * @memberof logreport.NoBillingEvent
         * @instance
         */
        NoBillingEvent.prototype.room_id = "";

        /**
         * Creates a new NoBillingEvent instance using the specified properties.
         * @function create
         * @memberof logreport.NoBillingEvent
         * @static
         * @param {logreport.INoBillingEvent=} [properties] Properties to set
         * @returns {logreport.NoBillingEvent} NoBillingEvent instance
         */
        NoBillingEvent.create = function create(properties) {
            return new NoBillingEvent(properties);
        };

        /**
         * Encodes the specified NoBillingEvent message. Does not implicitly {@link logreport.NoBillingEvent.verify|verify} messages.
         * @function encode
         * @memberof logreport.NoBillingEvent
         * @static
         * @param {logreport.INoBillingEvent} message NoBillingEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoBillingEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.platform_info != null && Object.hasOwnProperty.call(message, "platform_info"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.platform_info);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.room_id);
            return writer;
        };

        /**
         * Encodes the specified NoBillingEvent message, length delimited. Does not implicitly {@link logreport.NoBillingEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.NoBillingEvent
         * @static
         * @param {logreport.INoBillingEvent} message NoBillingEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoBillingEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NoBillingEvent message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.NoBillingEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.NoBillingEvent} NoBillingEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoBillingEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.NoBillingEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.platform_info = reader.string();
                    break;
                case 2:
                    message.room_id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NoBillingEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.NoBillingEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.NoBillingEvent} NoBillingEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoBillingEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NoBillingEvent message.
         * @function verify
         * @memberof logreport.NoBillingEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NoBillingEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.platform_info != null && message.hasOwnProperty("platform_info"))
                if (!$util.isString(message.platform_info))
                    return "platform_info: string expected";
            if (message.room_id != null && message.hasOwnProperty("room_id"))
                if (!$util.isString(message.room_id))
                    return "room_id: string expected";
            return null;
        };

        /**
         * Creates a NoBillingEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.NoBillingEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.NoBillingEvent} NoBillingEvent
         */
        NoBillingEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.NoBillingEvent)
                return object;
            var message = new $root.logreport.NoBillingEvent();
            if (object.platform_info != null)
                message.platform_info = String(object.platform_info);
            if (object.room_id != null)
                message.room_id = String(object.room_id);
            return message;
        };

        /**
         * Creates a plain object from a NoBillingEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.NoBillingEvent
         * @static
         * @param {logreport.NoBillingEvent} message NoBillingEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NoBillingEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.platform_info = "";
                object.room_id = "";
            }
            if (message.platform_info != null && message.hasOwnProperty("platform_info"))
                object.platform_info = message.platform_info;
            if (message.room_id != null && message.hasOwnProperty("room_id"))
                object.room_id = message.room_id;
            return object;
        };

        /**
         * Converts this NoBillingEvent to JSON.
         * @function toJSON
         * @memberof logreport.NoBillingEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NoBillingEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NoBillingEvent;
    })();

    logreport.DynQualityEvent = (function() {

        /**
         * Properties of a DynQualityEvent.
         * @memberof logreport
         * @interface IDynQualityEvent
         * @property {string|null} [seq_no] DynQualityEvent seq_no
         * @property {number|null} [num] DynQualityEvent num
         * @property {Array.<logreport.IDynQualityInfos>|null} [dyn_quality_infos] DynQualityEvent dyn_quality_infos
         * @property {string|null} [device_id] DynQualityEvent device_id
         * @property {number|null} [latitude] DynQualityEvent latitude
         * @property {number|null} [longitude] DynQualityEvent longitude
         * @property {string|null} [country] DynQualityEvent country
         * @property {string|null} [region] DynQualityEvent region
         * @property {string|null} [city] DynQualityEvent city
         * @property {string|null} [isp] DynQualityEvent isp
         * @property {number|null} [ve_mode] DynQualityEvent ve_mode
         */

        /**
         * Constructs a new DynQualityEvent.
         * @memberof logreport
         * @classdesc Represents a DynQualityEvent.
         * @implements IDynQualityEvent
         * @constructor
         * @param {logreport.IDynQualityEvent=} [properties] Properties to set
         */
        function DynQualityEvent(properties) {
            this.dyn_quality_infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DynQualityEvent seq_no.
         * @member {string} seq_no
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.seq_no = "";

        /**
         * DynQualityEvent num.
         * @member {number} num
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.num = 0;

        /**
         * DynQualityEvent dyn_quality_infos.
         * @member {Array.<logreport.IDynQualityInfos>} dyn_quality_infos
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.dyn_quality_infos = $util.emptyArray;

        /**
         * DynQualityEvent device_id.
         * @member {string} device_id
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.device_id = "";

        /**
         * DynQualityEvent latitude.
         * @member {number} latitude
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.latitude = 0;

        /**
         * DynQualityEvent longitude.
         * @member {number} longitude
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.longitude = 0;

        /**
         * DynQualityEvent country.
         * @member {string} country
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.country = "";

        /**
         * DynQualityEvent region.
         * @member {string} region
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.region = "";

        /**
         * DynQualityEvent city.
         * @member {string} city
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.city = "";

        /**
         * DynQualityEvent isp.
         * @member {string} isp
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.isp = "";

        /**
         * DynQualityEvent ve_mode.
         * @member {number} ve_mode
         * @memberof logreport.DynQualityEvent
         * @instance
         */
        DynQualityEvent.prototype.ve_mode = 0;

        /**
         * Creates a new DynQualityEvent instance using the specified properties.
         * @function create
         * @memberof logreport.DynQualityEvent
         * @static
         * @param {logreport.IDynQualityEvent=} [properties] Properties to set
         * @returns {logreport.DynQualityEvent} DynQualityEvent instance
         */
        DynQualityEvent.create = function create(properties) {
            return new DynQualityEvent(properties);
        };

        /**
         * Encodes the specified DynQualityEvent message. Does not implicitly {@link logreport.DynQualityEvent.verify|verify} messages.
         * @function encode
         * @memberof logreport.DynQualityEvent
         * @static
         * @param {logreport.IDynQualityEvent} message DynQualityEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DynQualityEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seq_no != null && Object.hasOwnProperty.call(message, "seq_no"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.seq_no);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.num);
            if (message.dyn_quality_infos != null && message.dyn_quality_infos.length)
                for (var i = 0; i < message.dyn_quality_infos.length; ++i)
                    $root.logreport.DynQualityInfos.encode(message.dyn_quality_infos[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.device_id != null && Object.hasOwnProperty.call(message, "device_id"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.device_id);
            if (message.latitude != null && Object.hasOwnProperty.call(message, "latitude"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.latitude);
            if (message.longitude != null && Object.hasOwnProperty.call(message, "longitude"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.longitude);
            if (message.country != null && Object.hasOwnProperty.call(message, "country"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.country);
            if (message.region != null && Object.hasOwnProperty.call(message, "region"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.region);
            if (message.city != null && Object.hasOwnProperty.call(message, "city"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.city);
            if (message.isp != null && Object.hasOwnProperty.call(message, "isp"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.isp);
            if (message.ve_mode != null && Object.hasOwnProperty.call(message, "ve_mode"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.ve_mode);
            return writer;
        };

        /**
         * Encodes the specified DynQualityEvent message, length delimited. Does not implicitly {@link logreport.DynQualityEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.DynQualityEvent
         * @static
         * @param {logreport.IDynQualityEvent} message DynQualityEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DynQualityEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DynQualityEvent message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.DynQualityEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.DynQualityEvent} DynQualityEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DynQualityEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.DynQualityEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.seq_no = reader.string();
                    break;
                case 2:
                    message.num = reader.uint32();
                    break;
                case 3:
                    if (!(message.dyn_quality_infos && message.dyn_quality_infos.length))
                        message.dyn_quality_infos = [];
                    message.dyn_quality_infos.push($root.logreport.DynQualityInfos.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.device_id = reader.string();
                    break;
                case 5:
                    message.latitude = reader.uint32();
                    break;
                case 6:
                    message.longitude = reader.uint32();
                    break;
                case 7:
                    message.country = reader.string();
                    break;
                case 8:
                    message.region = reader.string();
                    break;
                case 9:
                    message.city = reader.string();
                    break;
                case 10:
                    message.isp = reader.string();
                    break;
                case 11:
                    message.ve_mode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DynQualityEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.DynQualityEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.DynQualityEvent} DynQualityEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DynQualityEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DynQualityEvent message.
         * @function verify
         * @memberof logreport.DynQualityEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DynQualityEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seq_no != null && message.hasOwnProperty("seq_no"))
                if (!$util.isString(message.seq_no))
                    return "seq_no: string expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.dyn_quality_infos != null && message.hasOwnProperty("dyn_quality_infos")) {
                if (!Array.isArray(message.dyn_quality_infos))
                    return "dyn_quality_infos: array expected";
                for (var i = 0; i < message.dyn_quality_infos.length; ++i) {
                    var error = $root.logreport.DynQualityInfos.verify(message.dyn_quality_infos[i]);
                    if (error)
                        return "dyn_quality_infos." + error;
                }
            }
            if (message.device_id != null && message.hasOwnProperty("device_id"))
                if (!$util.isString(message.device_id))
                    return "device_id: string expected";
            if (message.latitude != null && message.hasOwnProperty("latitude"))
                if (!$util.isInteger(message.latitude))
                    return "latitude: integer expected";
            if (message.longitude != null && message.hasOwnProperty("longitude"))
                if (!$util.isInteger(message.longitude))
                    return "longitude: integer expected";
            if (message.country != null && message.hasOwnProperty("country"))
                if (!$util.isString(message.country))
                    return "country: string expected";
            if (message.region != null && message.hasOwnProperty("region"))
                if (!$util.isString(message.region))
                    return "region: string expected";
            if (message.city != null && message.hasOwnProperty("city"))
                if (!$util.isString(message.city))
                    return "city: string expected";
            if (message.isp != null && message.hasOwnProperty("isp"))
                if (!$util.isString(message.isp))
                    return "isp: string expected";
            if (message.ve_mode != null && message.hasOwnProperty("ve_mode"))
                if (!$util.isInteger(message.ve_mode))
                    return "ve_mode: integer expected";
            return null;
        };

        /**
         * Creates a DynQualityEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.DynQualityEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.DynQualityEvent} DynQualityEvent
         */
        DynQualityEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.DynQualityEvent)
                return object;
            var message = new $root.logreport.DynQualityEvent();
            if (object.seq_no != null)
                message.seq_no = String(object.seq_no);
            if (object.num != null)
                message.num = object.num >>> 0;
            if (object.dyn_quality_infos) {
                if (!Array.isArray(object.dyn_quality_infos))
                    throw TypeError(".logreport.DynQualityEvent.dyn_quality_infos: array expected");
                message.dyn_quality_infos = [];
                for (var i = 0; i < object.dyn_quality_infos.length; ++i) {
                    if (typeof object.dyn_quality_infos[i] !== "object")
                        throw TypeError(".logreport.DynQualityEvent.dyn_quality_infos: object expected");
                    message.dyn_quality_infos[i] = $root.logreport.DynQualityInfos.fromObject(object.dyn_quality_infos[i]);
                }
            }
            if (object.device_id != null)
                message.device_id = String(object.device_id);
            if (object.latitude != null)
                message.latitude = object.latitude >>> 0;
            if (object.longitude != null)
                message.longitude = object.longitude >>> 0;
            if (object.country != null)
                message.country = String(object.country);
            if (object.region != null)
                message.region = String(object.region);
            if (object.city != null)
                message.city = String(object.city);
            if (object.isp != null)
                message.isp = String(object.isp);
            if (object.ve_mode != null)
                message.ve_mode = object.ve_mode >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a DynQualityEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.DynQualityEvent
         * @static
         * @param {logreport.DynQualityEvent} message DynQualityEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DynQualityEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.dyn_quality_infos = [];
            if (options.defaults) {
                object.seq_no = "";
                object.num = 0;
                object.device_id = "";
                object.latitude = 0;
                object.longitude = 0;
                object.country = "";
                object.region = "";
                object.city = "";
                object.isp = "";
                object.ve_mode = 0;
            }
            if (message.seq_no != null && message.hasOwnProperty("seq_no"))
                object.seq_no = message.seq_no;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.dyn_quality_infos && message.dyn_quality_infos.length) {
                object.dyn_quality_infos = [];
                for (var j = 0; j < message.dyn_quality_infos.length; ++j)
                    object.dyn_quality_infos[j] = $root.logreport.DynQualityInfos.toObject(message.dyn_quality_infos[j], options);
            }
            if (message.device_id != null && message.hasOwnProperty("device_id"))
                object.device_id = message.device_id;
            if (message.latitude != null && message.hasOwnProperty("latitude"))
                object.latitude = message.latitude;
            if (message.longitude != null && message.hasOwnProperty("longitude"))
                object.longitude = message.longitude;
            if (message.country != null && message.hasOwnProperty("country"))
                object.country = message.country;
            if (message.region != null && message.hasOwnProperty("region"))
                object.region = message.region;
            if (message.city != null && message.hasOwnProperty("city"))
                object.city = message.city;
            if (message.isp != null && message.hasOwnProperty("isp"))
                object.isp = message.isp;
            if (message.ve_mode != null && message.hasOwnProperty("ve_mode"))
                object.ve_mode = message.ve_mode;
            return object;
        };

        /**
         * Converts this DynQualityEvent to JSON.
         * @function toJSON
         * @memberof logreport.DynQualityEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DynQualityEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DynQualityEvent;
    })();

    logreport.DynQualityInfos = (function() {

        /**
         * Properties of a DynQualityInfos.
         * @memberof logreport
         * @interface IDynQualityInfos
         * @property {number|Long|null} [timestamp_offset_begin] DynQualityInfos timestamp_offset_begin
         * @property {number|Long|null} [timestamp_offset_end] DynQualityInfos timestamp_offset_end
         * @property {string|null} [server_ip] DynQualityInfos server_ip
         * @property {Array.<logreport.IDynQualityInfo>|null} [infos] DynQualityInfos infos
         * @property {number|null} [network_type] DynQualityInfos network_type
         * @property {string|null} [stream_id] DynQualityInfos stream_id
         */

        /**
         * Constructs a new DynQualityInfos.
         * @memberof logreport
         * @classdesc Represents a DynQualityInfos.
         * @implements IDynQualityInfos
         * @constructor
         * @param {logreport.IDynQualityInfos=} [properties] Properties to set
         */
        function DynQualityInfos(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DynQualityInfos timestamp_offset_begin.
         * @member {number|Long} timestamp_offset_begin
         * @memberof logreport.DynQualityInfos
         * @instance
         */
        DynQualityInfos.prototype.timestamp_offset_begin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DynQualityInfos timestamp_offset_end.
         * @member {number|Long} timestamp_offset_end
         * @memberof logreport.DynQualityInfos
         * @instance
         */
        DynQualityInfos.prototype.timestamp_offset_end = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DynQualityInfos server_ip.
         * @member {string} server_ip
         * @memberof logreport.DynQualityInfos
         * @instance
         */
        DynQualityInfos.prototype.server_ip = "";

        /**
         * DynQualityInfos infos.
         * @member {Array.<logreport.IDynQualityInfo>} infos
         * @memberof logreport.DynQualityInfos
         * @instance
         */
        DynQualityInfos.prototype.infos = $util.emptyArray;

        /**
         * DynQualityInfos network_type.
         * @member {number} network_type
         * @memberof logreport.DynQualityInfos
         * @instance
         */
        DynQualityInfos.prototype.network_type = 0;

        /**
         * DynQualityInfos stream_id.
         * @member {string} stream_id
         * @memberof logreport.DynQualityInfos
         * @instance
         */
        DynQualityInfos.prototype.stream_id = "";

        /**
         * Creates a new DynQualityInfos instance using the specified properties.
         * @function create
         * @memberof logreport.DynQualityInfos
         * @static
         * @param {logreport.IDynQualityInfos=} [properties] Properties to set
         * @returns {logreport.DynQualityInfos} DynQualityInfos instance
         */
        DynQualityInfos.create = function create(properties) {
            return new DynQualityInfos(properties);
        };

        /**
         * Encodes the specified DynQualityInfos message. Does not implicitly {@link logreport.DynQualityInfos.verify|verify} messages.
         * @function encode
         * @memberof logreport.DynQualityInfos
         * @static
         * @param {logreport.IDynQualityInfos} message DynQualityInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DynQualityInfos.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp_offset_begin != null && Object.hasOwnProperty.call(message, "timestamp_offset_begin"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.timestamp_offset_begin);
            if (message.timestamp_offset_end != null && Object.hasOwnProperty.call(message, "timestamp_offset_end"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp_offset_end);
            if (message.server_ip != null && Object.hasOwnProperty.call(message, "server_ip"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.server_ip);
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.logreport.DynQualityInfo.encode(message.infos[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.network_type != null && Object.hasOwnProperty.call(message, "network_type"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.network_type);
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.stream_id);
            return writer;
        };

        /**
         * Encodes the specified DynQualityInfos message, length delimited. Does not implicitly {@link logreport.DynQualityInfos.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.DynQualityInfos
         * @static
         * @param {logreport.IDynQualityInfos} message DynQualityInfos message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DynQualityInfos.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DynQualityInfos message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.DynQualityInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.DynQualityInfos} DynQualityInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DynQualityInfos.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.DynQualityInfos();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp_offset_begin = reader.uint64();
                    break;
                case 2:
                    message.timestamp_offset_end = reader.uint64();
                    break;
                case 3:
                    message.server_ip = reader.string();
                    break;
                case 4:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.logreport.DynQualityInfo.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.network_type = reader.uint32();
                    break;
                case 6:
                    message.stream_id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DynQualityInfos message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.DynQualityInfos
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.DynQualityInfos} DynQualityInfos
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DynQualityInfos.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DynQualityInfos message.
         * @function verify
         * @memberof logreport.DynQualityInfos
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DynQualityInfos.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                if (!$util.isInteger(message.timestamp_offset_begin) && !(message.timestamp_offset_begin && $util.isInteger(message.timestamp_offset_begin.low) && $util.isInteger(message.timestamp_offset_begin.high)))
                    return "timestamp_offset_begin: integer|Long expected";
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                if (!$util.isInteger(message.timestamp_offset_end) && !(message.timestamp_offset_end && $util.isInteger(message.timestamp_offset_end.low) && $util.isInteger(message.timestamp_offset_end.high)))
                    return "timestamp_offset_end: integer|Long expected";
            if (message.server_ip != null && message.hasOwnProperty("server_ip"))
                if (!$util.isString(message.server_ip))
                    return "server_ip: string expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.logreport.DynQualityInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            if (message.network_type != null && message.hasOwnProperty("network_type"))
                if (!$util.isInteger(message.network_type))
                    return "network_type: integer expected";
            if (message.stream_id != null && message.hasOwnProperty("stream_id"))
                if (!$util.isString(message.stream_id))
                    return "stream_id: string expected";
            return null;
        };

        /**
         * Creates a DynQualityInfos message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.DynQualityInfos
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.DynQualityInfos} DynQualityInfos
         */
        DynQualityInfos.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.DynQualityInfos)
                return object;
            var message = new $root.logreport.DynQualityInfos();
            if (object.timestamp_offset_begin != null)
                if ($util.Long)
                    (message.timestamp_offset_begin = $util.Long.fromValue(object.timestamp_offset_begin)).unsigned = true;
                else if (typeof object.timestamp_offset_begin === "string")
                    message.timestamp_offset_begin = parseInt(object.timestamp_offset_begin, 10);
                else if (typeof object.timestamp_offset_begin === "number")
                    message.timestamp_offset_begin = object.timestamp_offset_begin;
                else if (typeof object.timestamp_offset_begin === "object")
                    message.timestamp_offset_begin = new $util.LongBits(object.timestamp_offset_begin.low >>> 0, object.timestamp_offset_begin.high >>> 0).toNumber(true);
            if (object.timestamp_offset_end != null)
                if ($util.Long)
                    (message.timestamp_offset_end = $util.Long.fromValue(object.timestamp_offset_end)).unsigned = true;
                else if (typeof object.timestamp_offset_end === "string")
                    message.timestamp_offset_end = parseInt(object.timestamp_offset_end, 10);
                else if (typeof object.timestamp_offset_end === "number")
                    message.timestamp_offset_end = object.timestamp_offset_end;
                else if (typeof object.timestamp_offset_end === "object")
                    message.timestamp_offset_end = new $util.LongBits(object.timestamp_offset_end.low >>> 0, object.timestamp_offset_end.high >>> 0).toNumber(true);
            if (object.server_ip != null)
                message.server_ip = String(object.server_ip);
            if (object.infos) {
                if (!Array.isArray(object.infos))
                    throw TypeError(".logreport.DynQualityInfos.infos: array expected");
                message.infos = [];
                for (var i = 0; i < object.infos.length; ++i) {
                    if (typeof object.infos[i] !== "object")
                        throw TypeError(".logreport.DynQualityInfos.infos: object expected");
                    message.infos[i] = $root.logreport.DynQualityInfo.fromObject(object.infos[i]);
                }
            }
            if (object.network_type != null)
                message.network_type = object.network_type >>> 0;
            if (object.stream_id != null)
                message.stream_id = String(object.stream_id);
            return message;
        };

        /**
         * Creates a plain object from a DynQualityInfos message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.DynQualityInfos
         * @static
         * @param {logreport.DynQualityInfos} message DynQualityInfos
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DynQualityInfos.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.infos = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp_offset_begin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp_offset_begin = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.timestamp_offset_end = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp_offset_end = options.longs === String ? "0" : 0;
                object.server_ip = "";
                object.network_type = 0;
                object.stream_id = "";
            }
            if (message.timestamp_offset_begin != null && message.hasOwnProperty("timestamp_offset_begin"))
                if (typeof message.timestamp_offset_begin === "number")
                    object.timestamp_offset_begin = options.longs === String ? String(message.timestamp_offset_begin) : message.timestamp_offset_begin;
                else
                    object.timestamp_offset_begin = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp_offset_begin) : options.longs === Number ? new $util.LongBits(message.timestamp_offset_begin.low >>> 0, message.timestamp_offset_begin.high >>> 0).toNumber(true) : message.timestamp_offset_begin;
            if (message.timestamp_offset_end != null && message.hasOwnProperty("timestamp_offset_end"))
                if (typeof message.timestamp_offset_end === "number")
                    object.timestamp_offset_end = options.longs === String ? String(message.timestamp_offset_end) : message.timestamp_offset_end;
                else
                    object.timestamp_offset_end = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp_offset_end) : options.longs === Number ? new $util.LongBits(message.timestamp_offset_end.low >>> 0, message.timestamp_offset_end.high >>> 0).toNumber(true) : message.timestamp_offset_end;
            if (message.server_ip != null && message.hasOwnProperty("server_ip"))
                object.server_ip = message.server_ip;
            if (message.infos && message.infos.length) {
                object.infos = [];
                for (var j = 0; j < message.infos.length; ++j)
                    object.infos[j] = $root.logreport.DynQualityInfo.toObject(message.infos[j], options);
            }
            if (message.network_type != null && message.hasOwnProperty("network_type"))
                object.network_type = message.network_type;
            if (message.stream_id != null && message.hasOwnProperty("stream_id"))
                object.stream_id = message.stream_id;
            return object;
        };

        /**
         * Converts this DynQualityInfos to JSON.
         * @function toJSON
         * @memberof logreport.DynQualityInfos
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DynQualityInfos.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DynQualityInfos;
    })();

    logreport.DynQualityInfo = (function() {

        /**
         * Properties of a DynQualityInfo.
         * @memberof logreport
         * @interface IDynQualityInfo
         * @property {number|Long|null} [time] DynQualityInfo time
         * @property {number|null} [plr] DynQualityInfo plr
         * @property {number|null} [rtt] DynQualityInfo rtt
         * @property {number|null} [score] DynQualityInfo score
         * @property {number|null} [sample_time] DynQualityInfo sample_time
         */

        /**
         * Constructs a new DynQualityInfo.
         * @memberof logreport
         * @classdesc Represents a DynQualityInfo.
         * @implements IDynQualityInfo
         * @constructor
         * @param {logreport.IDynQualityInfo=} [properties] Properties to set
         */
        function DynQualityInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DynQualityInfo time.
         * @member {number|Long} time
         * @memberof logreport.DynQualityInfo
         * @instance
         */
        DynQualityInfo.prototype.time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DynQualityInfo plr.
         * @member {number} plr
         * @memberof logreport.DynQualityInfo
         * @instance
         */
        DynQualityInfo.prototype.plr = 0;

        /**
         * DynQualityInfo rtt.
         * @member {number} rtt
         * @memberof logreport.DynQualityInfo
         * @instance
         */
        DynQualityInfo.prototype.rtt = 0;

        /**
         * DynQualityInfo score.
         * @member {number} score
         * @memberof logreport.DynQualityInfo
         * @instance
         */
        DynQualityInfo.prototype.score = 0;

        /**
         * DynQualityInfo sample_time.
         * @member {number} sample_time
         * @memberof logreport.DynQualityInfo
         * @instance
         */
        DynQualityInfo.prototype.sample_time = 0;

        /**
         * Creates a new DynQualityInfo instance using the specified properties.
         * @function create
         * @memberof logreport.DynQualityInfo
         * @static
         * @param {logreport.IDynQualityInfo=} [properties] Properties to set
         * @returns {logreport.DynQualityInfo} DynQualityInfo instance
         */
        DynQualityInfo.create = function create(properties) {
            return new DynQualityInfo(properties);
        };

        /**
         * Encodes the specified DynQualityInfo message. Does not implicitly {@link logreport.DynQualityInfo.verify|verify} messages.
         * @function encode
         * @memberof logreport.DynQualityInfo
         * @static
         * @param {logreport.IDynQualityInfo} message DynQualityInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DynQualityInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.time);
            if (message.plr != null && Object.hasOwnProperty.call(message, "plr"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.plr);
            if (message.rtt != null && Object.hasOwnProperty.call(message, "rtt"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.rtt);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.score);
            if (message.sample_time != null && Object.hasOwnProperty.call(message, "sample_time"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.sample_time);
            return writer;
        };

        /**
         * Encodes the specified DynQualityInfo message, length delimited. Does not implicitly {@link logreport.DynQualityInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof logreport.DynQualityInfo
         * @static
         * @param {logreport.IDynQualityInfo} message DynQualityInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DynQualityInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DynQualityInfo message from the specified reader or buffer.
         * @function decode
         * @memberof logreport.DynQualityInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {logreport.DynQualityInfo} DynQualityInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DynQualityInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.logreport.DynQualityInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.uint64();
                    break;
                case 2:
                    message.plr = reader.uint32();
                    break;
                case 3:
                    message.rtt = reader.uint32();
                    break;
                case 4:
                    message.score = reader.uint32();
                    break;
                case 5:
                    message.sample_time = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DynQualityInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof logreport.DynQualityInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {logreport.DynQualityInfo} DynQualityInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DynQualityInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DynQualityInfo message.
         * @function verify
         * @memberof logreport.DynQualityInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DynQualityInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            if (message.plr != null && message.hasOwnProperty("plr"))
                if (!$util.isInteger(message.plr))
                    return "plr: integer expected";
            if (message.rtt != null && message.hasOwnProperty("rtt"))
                if (!$util.isInteger(message.rtt))
                    return "rtt: integer expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.sample_time != null && message.hasOwnProperty("sample_time"))
                if (!$util.isInteger(message.sample_time))
                    return "sample_time: integer expected";
            return null;
        };

        /**
         * Creates a DynQualityInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof logreport.DynQualityInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {logreport.DynQualityInfo} DynQualityInfo
         */
        DynQualityInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.logreport.DynQualityInfo)
                return object;
            var message = new $root.logreport.DynQualityInfo();
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = true;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber(true);
            if (object.plr != null)
                message.plr = object.plr >>> 0;
            if (object.rtt != null)
                message.rtt = object.rtt >>> 0;
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.sample_time != null)
                message.sample_time = object.sample_time >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a DynQualityInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof logreport.DynQualityInfo
         * @static
         * @param {logreport.DynQualityInfo} message DynQualityInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DynQualityInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
                object.plr = 0;
                object.rtt = 0;
                object.score = 0;
                object.sample_time = 0;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber(true) : message.time;
            if (message.plr != null && message.hasOwnProperty("plr"))
                object.plr = message.plr;
            if (message.rtt != null && message.hasOwnProperty("rtt"))
                object.rtt = message.rtt;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.sample_time != null && message.hasOwnProperty("sample_time"))
                object.sample_time = message.sample_time;
            return object;
        };

        /**
         * Converts this DynQualityInfo to JSON.
         * @function toJSON
         * @memberof logreport.DynQualityInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DynQualityInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DynQualityInfo;
    })();

    return logreport;
})();

module.exports = $root;


/***/ }),

/***/ "./sdk/src/webrtc/adapter.js":
/*!***********************************!*\
  !*** ./sdk/src/webrtc/adapter.js ***!
  \***********************************/
/***/ (function(module) {

(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=undefined;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=undefined,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */

  'use strict';

  var _adapter_factory = require('./adapter_factory.js');

  var adapter = (0, _adapter_factory.adapterFactory)({ window: window });
  module.exports = adapter; // this is the difference from adapter_core.

  },{"./adapter_factory.js":2}],2:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.adapterFactory = adapterFactory;

  var _utils = require('./utils');

  var utils = _interopRequireWildcard(_utils);

  var _chrome_shim = require('./chrome/chrome_shim');

  var chromeShim = _interopRequireWildcard(_chrome_shim);

  var _edge_shim = require('./edge/edge_shim');

  var edgeShim = _interopRequireWildcard(_edge_shim);

  var _firefox_shim = require('./firefox/firefox_shim');

  var firefoxShim = _interopRequireWildcard(_firefox_shim);

  var _safari_shim = require('./safari/safari_shim');

  var safariShim = _interopRequireWildcard(_safari_shim);

  var _common_shim = require('./common_shim');

  var commonShim = _interopRequireWildcard(_common_shim);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  // Shimming starts here.
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  function adapterFactory() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        window = _ref.window;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      shimChrome: true,
      shimFirefox: true,
      shimEdge: true,
      shimSafari: true
    };

    // Utils.
    var logging = utils.log;
    var browserDetails = utils.detectBrowser(window);

    var adapter = {
      browserDetails: browserDetails,
      commonShim: commonShim,
      extractVersion: utils.extractVersion,
      disableLog: utils.disableLog,
      disableWarnings: utils.disableWarnings
    };

    // Shim browser if found.
    switch (browserDetails.browser) {
      case 'chrome':
        if (!chromeShim || !chromeShim.shimPeerConnection || !options.shimChrome) {
          logging('Chrome shim is not included in this adapter release.');
          return adapter;
        }
        logging('adapter.js shimming chrome.');
        // Export to the adapter global object visible in the browser.
        adapter.browserShim = chromeShim;

        chromeShim.shimGetUserMedia(window);
        chromeShim.shimMediaStream(window);
        chromeShim.shimPeerConnection(window);
        chromeShim.shimOnTrack(window);
        chromeShim.shimAddTrackRemoveTrack(window);
        chromeShim.shimGetSendersWithDtmf(window);
        chromeShim.shimGetStats(window);
        chromeShim.shimSenderReceiverGetStats(window);
        chromeShim.fixNegotiationNeeded(window);

        commonShim.shimRTCIceCandidate(window);
        commonShim.shimConnectionState(window);
        commonShim.shimMaxMessageSize(window);
        commonShim.shimSendThrowTypeError(window);
        commonShim.removeAllowExtmapMixed(window);
        break;
      case 'firefox':
        if (!firefoxShim || !firefoxShim.shimPeerConnection || !options.shimFirefox) {
          logging('Firefox shim is not included in this adapter release.');
          return adapter;
        }
        logging('adapter.js shimming firefox.');
        // Export to the adapter global object visible in the browser.
        adapter.browserShim = firefoxShim;

        firefoxShim.shimGetUserMedia(window);
        firefoxShim.shimPeerConnection(window);
        firefoxShim.shimOnTrack(window);
        firefoxShim.shimRemoveStream(window);
        firefoxShim.shimSenderGetStats(window);
        firefoxShim.shimReceiverGetStats(window);
        firefoxShim.shimRTCDataChannel(window);

        commonShim.shimRTCIceCandidate(window);
        commonShim.shimConnectionState(window);
        commonShim.shimMaxMessageSize(window);
        commonShim.shimSendThrowTypeError(window);
        break;
      case 'edge':
        if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
          logging('MS edge shim is not included in this adapter release.');
          return adapter;
        }
        logging('adapter.js shimming edge.');
        // Export to the adapter global object visible in the browser.
        adapter.browserShim = edgeShim;

        edgeShim.shimGetUserMedia(window);
        edgeShim.shimGetDisplayMedia(window);
        edgeShim.shimPeerConnection(window);
        edgeShim.shimReplaceTrack(window);

        // the edge shim implements the full RTCIceCandidate object.

        commonShim.shimMaxMessageSize(window);
        commonShim.shimSendThrowTypeError(window);
        break;
      case 'safari':
        if (!safariShim || !options.shimSafari) {
          logging('Safari shim is not included in this adapter release.');
          return adapter;
        }
        logging('adapter.js shimming safari.');
        // Export to the adapter global object visible in the browser.
        adapter.browserShim = safariShim;

        safariShim.shimRTCIceServerUrls(window);
        safariShim.shimCreateOfferLegacy(window);
        safariShim.shimCallbacksAPI(window);
        safariShim.shimLocalStreamsAPI(window);
        safariShim.shimRemoteStreamsAPI(window);
        safariShim.shimTrackEventTransceiver(window);
        safariShim.shimGetUserMedia(window);

        commonShim.shimRTCIceCandidate(window);
        commonShim.shimMaxMessageSize(window);
        commonShim.shimSendThrowTypeError(window);
        commonShim.removeAllowExtmapMixed(window);
        break;
      default:
        logging('Unsupported browser!');
        break;
    }

    return adapter;
  }

  // Browser shims.

  },{"./chrome/chrome_shim":3,"./common_shim":6,"./edge/edge_shim":7,"./firefox/firefox_shim":11,"./safari/safari_shim":14,"./utils":15}],3:[function(require,module,exports){

  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _getusermedia = require('./getusermedia');

  Object.defineProperty(exports, 'shimGetUserMedia', {
    enumerable: true,
    get: function get() {
      return _getusermedia.shimGetUserMedia;
    }
  });

  var _getdisplaymedia = require('./getdisplaymedia');

  Object.defineProperty(exports, 'shimGetDisplayMedia', {
    enumerable: true,
    get: function get() {
      return _getdisplaymedia.shimGetDisplayMedia;
    }
  });
  exports.shimMediaStream = shimMediaStream;
  exports.shimOnTrack = shimOnTrack;
  exports.shimGetSendersWithDtmf = shimGetSendersWithDtmf;
  exports.shimGetStats = shimGetStats;
  exports.shimSenderReceiverGetStats = shimSenderReceiverGetStats;
  exports.shimAddTrackRemoveTrackWithNative = shimAddTrackRemoveTrackWithNative;
  exports.shimAddTrackRemoveTrack = shimAddTrackRemoveTrack;
  exports.shimPeerConnection = shimPeerConnection;
  exports.fixNegotiationNeeded = fixNegotiationNeeded;

  var _utils = require('../utils.js');

  var utils = _interopRequireWildcard(_utils);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function shimMediaStream(window) {
    window.MediaStream = window.MediaStream || window.webkitMediaStream;
  }

  function shimOnTrack(window) {
    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function get() {
          return this._ontrack;
        },
        set: function set(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
          }
          this.addEventListener('track', this._ontrack = f);
        },

        enumerable: true,
        configurable: true
      });
      var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription = function () {
        var _this = this;

        if (!this._ontrackpoly) {
          this._ontrackpoly = function (e) {
            // onaddstream does not fire when a track is added to an existing
            // stream. But stream.onaddtrack is implemented so we use that.
            e.stream.addEventListener('addtrack', function (te) {
              var receiver = void 0;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = _this.getReceivers().find(function (r) {
                  return r.track && r.track.id === te.track.id;
                });
              } else {
                receiver = { track: te.track };
              }

              var event = new Event('track');
              event.track = te.track;
              event.receiver = receiver;
              event.transceiver = { receiver: receiver };
              event.streams = [e.stream];
              _this.dispatchEvent(event);
            });
            e.stream.getTracks().forEach(function (track) {
              var receiver = void 0;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = _this.getReceivers().find(function (r) {
                  return r.track && r.track.id === track.id;
                });
              } else {
                receiver = { track: track };
              }
              var event = new Event('track');
              event.track = track;
              event.receiver = receiver;
              event.transceiver = { receiver: receiver };
              event.streams = [e.stream];
              _this.dispatchEvent(event);
            });
          };
          this.addEventListener('addstream', this._ontrackpoly);
        }
        return origSetRemoteDescription.apply(this, arguments);
      };
    } else {
      // even if RTCRtpTransceiver is in window, it is only used and
      // emitted in unified-plan. Unfortunately this means we need
      // to unconditionally wrap the event.
      utils.wrapPeerConnectionEvent(window, 'track', function (e) {
        if (!e.transceiver) {
          Object.defineProperty(e, 'transceiver', { value: { receiver: e.receiver } });
        }
        return e;
      });
    }
  }

  function shimGetSendersWithDtmf(window) {
    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {
      var shimSenderWithDtmf = function shimSenderWithDtmf(pc, track) {
        return {
          track: track,
          get dtmf() {
            if (this._dtmf === undefined) {
              if (track.kind === 'audio') {
                this._dtmf = pc.createDTMFSender(track);
              } else {
                this._dtmf = null;
              }
            }
            return this._dtmf;
          },
          _pc: pc
        };
      };

      // augment addTrack when getSenders is not available.
      if (!window.RTCPeerConnection.prototype.getSenders) {
        window.RTCPeerConnection.prototype.getSenders = function () {
          this._senders = this._senders || [];
          return this._senders.slice(); // return a copy of the internal state.
        };
        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
        window.RTCPeerConnection.prototype.addTrack = function (track, stream) {
          var sender = origAddTrack.apply(this, arguments);
          if (!sender) {
            sender = shimSenderWithDtmf(this, track);
            this._senders.push(sender);
          }
          return sender;
        };

        var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
        window.RTCPeerConnection.prototype.removeTrack = function (sender) {
          origRemoveTrack.apply(this, arguments);
          var idx = this._senders.indexOf(sender);
          if (idx !== -1) {
            this._senders.splice(idx, 1);
          }
        };
      }
      var origAddStream = window.RTCPeerConnection.prototype.addStream;
      window.RTCPeerConnection.prototype.addStream = function (stream) {
        var _this2 = this;

        this._senders = this._senders || [];
        origAddStream.apply(this, [stream]);
        stream.getTracks().forEach(function (track) {
          _this2._senders.push(shimSenderWithDtmf(_this2, track));
        });
      };

      var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
      window.RTCPeerConnection.prototype.removeStream = function (stream) {
        var _this3 = this;

        this._senders = this._senders || [];
        origRemoveStream.apply(this, [stream]);

        stream.getTracks().forEach(function (track) {
          var sender = _this3._senders.find(function (s) {
            return s.track === track;
          });
          if (sender) {
            // remove sender
            _this3._senders.splice(_this3._senders.indexOf(sender), 1);
          }
        });
      };
    } else if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      window.RTCPeerConnection.prototype.getSenders = function () {
        var _this4 = this;

        var senders = origGetSenders.apply(this, []);
        senders.forEach(function (sender) {
          return sender._pc = _this4;
        });
        return senders;
      };

      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get: function get() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = this._pc.createDTMFSender(this.track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
  }

  function shimGetStats(window) {
    if (!window.RTCPeerConnection) {
      return;
    }

    var origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function (selector, successCallback, errorCallback) {
      var _this5 = this;

      var args = arguments;

      // If selector is a function then we are in the old style stats so just
      // pass back the original getStats format to avoid breaking old users.
      if (arguments.length > 0 && typeof selector === 'function') {
        return origGetStats.apply(this, arguments);
      }

      // When spec-style getStats is supported, return those when called with
      // either no arguments or the selector argument is null.
      if (origGetStats.length === 0 && (arguments.length === 0 || typeof arguments[0] !== 'function')) {
        return origGetStats.apply(this, []);
      }

      var fixChromeStats_ = function fixChromeStats_(response) {
        var standardReport = {};
        var reports = response.result();
        reports.forEach(function (report) {
          var standardStats = {
            id: report.id,
            timestamp: report.timestamp,
            type: {
              localcandidate: 'local-candidate',
              remotecandidate: 'remote-candidate'
            }[report.type] || report.type
          };
          report.names().forEach(function (name) {
            standardStats[name] = report.stat(name);
          });
          standardReport[standardStats.id] = standardStats;
        });

        return standardReport;
      };

      // shim getStats with maplike support
      var makeMapStats = function makeMapStats(stats) {
        return new Map(Object.keys(stats).map(function (key) {
          return [key, stats[key]];
        }));
      };

      if (arguments.length >= 2) {
        var successCallbackWrapper_ = function successCallbackWrapper_(response) {
          args[1](makeMapStats(fixChromeStats_(response)));
        };

        return origGetStats.apply(this, [successCallbackWrapper_, arguments[0]]);
      }

      // promise-support
      return new Promise(function (resolve, reject) {
        origGetStats.apply(_this5, [function (response) {
          resolve(makeMapStats(fixChromeStats_(response)));
        }, reject]);
      }).then(successCallback, errorCallback);
    };
  }

  function shimSenderReceiverGetStats(window) {
    if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {
      return;
    }

    // shim sender stats.
    if (!('getStats' in window.RTCRtpSender.prototype)) {
      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      if (origGetSenders) {
        window.RTCPeerConnection.prototype.getSenders = function () {
          var _this6 = this;

          var senders = origGetSenders.apply(this, []);
          senders.forEach(function (sender) {
            return sender._pc = _this6;
          });
          return senders;
        };
      }

      var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
      if (origAddTrack) {
        window.RTCPeerConnection.prototype.addTrack = function () {
          var sender = origAddTrack.apply(this, arguments);
          sender._pc = this;
          return sender;
        };
      }
      window.RTCRtpSender.prototype.getStats = function () {
        var sender = this;
        return this._pc.getStats().then(function (result) {
          return (
            /* Note: this will include stats of all senders that
             *   send a track with the same id as sender.track as
             *   it is not possible to identify the RTCRtpSender.
             */
            utils.filterStats(result, sender.track, true)
          );
        });
      };
    }

    // shim receiver stats.
    if (!('getStats' in window.RTCRtpReceiver.prototype)) {
      var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
      if (origGetReceivers) {
        window.RTCPeerConnection.prototype.getReceivers = function () {
          var _this7 = this;

          var receivers = origGetReceivers.apply(this, []);
          receivers.forEach(function (receiver) {
            return receiver._pc = _this7;
          });
          return receivers;
        };
      }
      utils.wrapPeerConnectionEvent(window, 'track', function (e) {
        e.receiver._pc = e.srcElement;
        return e;
      });
      window.RTCRtpReceiver.prototype.getStats = function () {
        var receiver = this;
        return this._pc.getStats().then(function (result) {
          return utils.filterStats(result, receiver.track, false);
        });
      };
    }

    if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {
      return;
    }

    // shim RTCPeerConnection.getStats(track).
    var origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function () {
      if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {
        var track = arguments[0];
        var sender = void 0;
        var receiver = void 0;
        var err = void 0;
        this.getSenders().forEach(function (s) {
          if (s.track === track) {
            if (sender) {
              err = true;
            } else {
              sender = s;
            }
          }
        });
        this.getReceivers().forEach(function (r) {
          if (r.track === track) {
            if (receiver) {
              err = true;
            } else {
              receiver = r;
            }
          }
          return r.track === track;
        });
        if (err || sender && receiver) {
          return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));
        } else if (sender) {
          return sender.getStats();
        } else if (receiver) {
          return receiver.getStats();
        }
        return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));
      }
      return origGetStats.apply(this, arguments);
    };
  }

  function shimAddTrackRemoveTrackWithNative(window) {
    // shim addTrack/removeTrack with native variants in order to make
    // the interactions with legacy getLocalStreams behave as in other browsers.
    // Keeps a mapping stream.id => [stream, rtpsenders...]
    window.RTCPeerConnection.prototype.getLocalStreams = function () {
      var _this8 = this;

      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      return Object.keys(this._shimmedLocalStreams).map(function (streamId) {
        return _this8._shimmedLocalStreams[streamId][0];
      });
    };

    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    window.RTCPeerConnection.prototype.addTrack = function (track, stream) {
      if (!stream) {
        return origAddTrack.apply(this, arguments);
      }
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};

      var sender = origAddTrack.apply(this, arguments);
      if (!this._shimmedLocalStreams[stream.id]) {
        this._shimmedLocalStreams[stream.id] = [stream, sender];
      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
        this._shimmedLocalStreams[stream.id].push(sender);
      }
      return sender;
    };

    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function (stream) {
      var _this9 = this;

      this._shimmedLocalStreams = this._shimmedLocalStreams || {};

      stream.getTracks().forEach(function (track) {
        var alreadyExists = _this9.getSenders().find(function (s) {
          return s.track === track;
        });
        if (alreadyExists) {
          throw new DOMException('Track already exists.', 'InvalidAccessError');
        }
      });
      var existingSenders = this.getSenders();
      origAddStream.apply(this, arguments);
      var newSenders = this.getSenders().filter(function (newSender) {
        return existingSenders.indexOf(newSender) === -1;
      });
      this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function (stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      delete this._shimmedLocalStreams[stream.id];
      return origRemoveStream.apply(this, arguments);
    };

    var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
    window.RTCPeerConnection.prototype.removeTrack = function (sender) {
      var _this10 = this;

      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      if (sender) {
        Object.keys(this._shimmedLocalStreams).forEach(function (streamId) {
          var idx = _this10._shimmedLocalStreams[streamId].indexOf(sender);
          if (idx !== -1) {
            _this10._shimmedLocalStreams[streamId].splice(idx, 1);
          }
          if (_this10._shimmedLocalStreams[streamId].length === 1) {
            delete _this10._shimmedLocalStreams[streamId];
          }
        });
      }
      return origRemoveTrack.apply(this, arguments);
    };
  }

  function shimAddTrackRemoveTrack(window) {
    if (!window.RTCPeerConnection) {
      return;
    }
    var browserDetails = utils.detectBrowser(window);
    // shim addTrack and removeTrack.
    if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
      return shimAddTrackRemoveTrackWithNative(window);
    }

    // also shim pc.getLocalStreams when addTrack is shimmed
    // to return the original streams.
    var origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;
    window.RTCPeerConnection.prototype.getLocalStreams = function () {
      var _this11 = this;

      var nativeStreams = origGetLocalStreams.apply(this);
      this._reverseStreams = this._reverseStreams || {};
      return nativeStreams.map(function (stream) {
        return _this11._reverseStreams[stream.id];
      });
    };

    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function (stream) {
      var _this12 = this;

      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};

      stream.getTracks().forEach(function (track) {
        var alreadyExists = _this12.getSenders().find(function (s) {
          return s.track === track;
        });
        if (alreadyExists) {
          throw new DOMException('Track already exists.', 'InvalidAccessError');
        }
      });
      // Add identity mapping for consistency with addTrack.
      // Unless this is being used with a stream from addTrack.
      if (!this._reverseStreams[stream.id]) {
        var newStream = new window.MediaStream(stream.getTracks());
        this._streams[stream.id] = newStream;
        this._reverseStreams[newStream.id] = stream;
        stream = newStream;
      }
      origAddStream.apply(this, [stream]);
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function (stream) {
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};

      origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
      delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
      delete this._streams[stream.id];
    };

    window.RTCPeerConnection.prototype.addTrack = function (track, stream) {
      var _this13 = this;

      if (this.signalingState === 'closed') {
        throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
      }
      var streams = [].slice.call(arguments, 1);
      if (streams.length !== 1 || !streams[0].getTracks().find(function (t) {
        return t === track;
      })) {
        // this is not fully correct but all we can manage without
        // [[associated MediaStreams]] internal slot.
        throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');
      }

      var alreadyExists = this.getSenders().find(function (s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException('Track already exists.', 'InvalidAccessError');
      }

      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
      var oldStream = this._streams[stream.id];
      if (oldStream) {
        // this is using odd Chrome behaviour, use with caution:
        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
        // Note: we rely on the high-level addTrack/dtmf shim to
        // create the sender with a dtmf sender.
        oldStream.addTrack(track);

        // Trigger ONN async.
        Promise.resolve().then(function () {
          _this13.dispatchEvent(new Event('negotiationneeded'));
        });
      } else {
        var newStream = new window.MediaStream([track]);
        this._streams[stream.id] = newStream;
        this._reverseStreams[newStream.id] = stream;
        this.addStream(newStream);
      }
      return this.getSenders().find(function (s) {
        return s.track === track;
      });
    };

    // replace the internal stream id with the external one and
    // vice versa.
    function replaceInternalStreamId(pc, description) {
      var sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
        var externalStream = pc._reverseStreams[internalId];
        var internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp
      });
    }
    function replaceExternalStreamId(pc, description) {
      var sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
        var externalStream = pc._reverseStreams[internalId];
        var internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp
      });
    }
    ['createOffer', 'createAnswer'].forEach(function (method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      window.RTCPeerConnection.prototype[method] = function () {
        var _this14 = this;

        var args = arguments;
        var isLegacyCall = arguments.length && typeof arguments[0] === 'function';
        if (isLegacyCall) {
          return nativeMethod.apply(this, [function (description) {
            var desc = replaceInternalStreamId(_this14, description);
            args[0].apply(null, [desc]);
          }, function (err) {
            if (args[1]) {
              args[1].apply(null, err);
            }
          }, arguments[2]]);
        }
        return nativeMethod.apply(this, arguments).then(function (description) {
          return replaceInternalStreamId(_this14, description);
        });
      };
    });

    var origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;
    window.RTCPeerConnection.prototype.setLocalDescription = function () {
      if (!arguments.length || !arguments[0].type) {
        return origSetLocalDescription.apply(this, arguments);
      }
      arguments[0] = replaceExternalStreamId(this, arguments[0]);
      return origSetLocalDescription.apply(this, arguments);
    };

    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

    var origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');
    Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {
      get: function get() {
        var description = origLocalDescription.get.apply(this);
        if (description.type === '') {
          return description;
        }
        return replaceInternalStreamId(this, description);
      }
    });

    window.RTCPeerConnection.prototype.removeTrack = function (sender) {
      var _this15 = this;

      if (this.signalingState === 'closed') {
        throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
      }
      // We can not yet check for sender instanceof RTCRtpSender
      // since we shim RTPSender. So we check if sender._pc is set.
      if (!sender._pc) {
        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');
      }
      var isLocal = sender._pc === this;
      if (!isLocal) {
        throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');
      }

      // Search for the native stream the senders track belongs to.
      this._streams = this._streams || {};
      var stream = void 0;
      Object.keys(this._streams).forEach(function (streamid) {
        var hasTrack = _this15._streams[streamid].getTracks().find(function (track) {
          return sender.track === track;
        });
        if (hasTrack) {
          stream = _this15._streams[streamid];
        }
      });

      if (stream) {
        if (stream.getTracks().length === 1) {
          // if this is the last track of the stream, remove the stream. This
          // takes care of any shimmed _senders.
          this.removeStream(this._reverseStreams[stream.id]);
        } else {
          // relying on the same odd chrome behaviour as above.
          stream.removeTrack(sender.track);
        }
        this.dispatchEvent(new Event('negotiationneeded'));
      }
    };
  }

  function shimPeerConnection(window) {
    if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
      // very basic support for old versions.
      window.RTCPeerConnection = window.webkitRTCPeerConnection;
    }
    if (!window.RTCPeerConnection) {
      return;
    }

    // shim implicit creation of RTCSessionDescription/RTCIceCandidate
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      window.RTCPeerConnection.prototype[method] = function () {
        arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      };
    });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function () {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  }

  function fixNegotiationNeeded(window) {
    utils.wrapPeerConnectionEvent(window, 'negotiationneeded', function (e) {
      var pc = e.target;
      if (pc.signalingState !== 'stable') {
        return;
      }
      return e;
    });
  }

  },{"../utils.js":15,"./getdisplaymedia":4,"./getusermedia":5}],4:[function(require,module,exports){
  /*
   *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.shimGetDisplayMedia = shimGetDisplayMedia;
  function shimGetDisplayMedia(window, getSourceId) {
    if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
      return;
    }
    if (!window.navigator.mediaDevices) {
      return;
    }
    // getSourceId is a function that returns a promise resolving with
    // the sourceId of the screen/window/tab to be shared.
    if (typeof getSourceId !== 'function') {
      console.error('shimGetDisplayMedia: getSourceId argument is not ' + 'a function');
      return;
    }
    window.navigator.mediaDevices.getDisplayMedia = function (constraints) {
      return getSourceId(constraints).then(function (sourceId) {
        var widthSpecified = constraints.video && constraints.video.width;
        var heightSpecified = constraints.video && constraints.video.height;
        var frameRateSpecified = constraints.video && constraints.video.frameRate;
        constraints.video = {
          mandatory: {
            chromeMediaSource: 'desktop',
            chromeMediaSourceId: sourceId,
            maxFrameRate: frameRateSpecified || 3
          }
        };
        if (widthSpecified) {
          constraints.video.mandatory.maxWidth = widthSpecified;
        }
        if (heightSpecified) {
          constraints.video.mandatory.maxHeight = heightSpecified;
        }
        return window.navigator.mediaDevices.getUserMedia(constraints);
      });
    };
  }

  },{}],5:[function(require,module,exports){
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  exports.shimGetUserMedia = shimGetUserMedia;

  var _utils = require('../utils.js');

  var utils = _interopRequireWildcard(_utils);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  var logging = utils.log;

  function shimGetUserMedia(window) {
    var navigator = window && window.navigator;

    if (!navigator.mediaDevices) {
      return;
    }

    var browserDetails = utils.detectBrowser(window);

    var constraintsToChrome_ = function constraintsToChrome_(c) {
      if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) !== 'object' || c.mandatory || c.optional) {
        return c;
      }
      var cc = {};
      Object.keys(c).forEach(function (key) {
        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
          return;
        }
        var r = _typeof(c[key]) === 'object' ? c[key] : { ideal: c[key] };
        if (r.exact !== undefined && typeof r.exact === 'number') {
          r.min = r.max = r.exact;
        }
        var oldname_ = function oldname_(prefix, name) {
          if (prefix) {
            return prefix + name.charAt(0).toUpperCase() + name.slice(1);
          }
          return name === 'deviceId' ? 'sourceId' : name;
        };
        if (r.ideal !== undefined) {
          cc.optional = cc.optional || [];
          var oc = {};
          if (typeof r.ideal === 'number') {
            oc[oldname_('min', key)] = r.ideal;
            cc.optional.push(oc);
            oc = {};
            oc[oldname_('max', key)] = r.ideal;
            cc.optional.push(oc);
          } else {
            oc[oldname_('', key)] = r.ideal;
            cc.optional.push(oc);
          }
        }
        if (r.exact !== undefined && typeof r.exact !== 'number') {
          cc.mandatory = cc.mandatory || {};
          cc.mandatory[oldname_('', key)] = r.exact;
        } else {
          ['min', 'max'].forEach(function (mix) {
            if (r[mix] !== undefined) {
              cc.mandatory = cc.mandatory || {};
              cc.mandatory[oldname_(mix, key)] = r[mix];
            }
          });
        }
      });
      if (c.advanced) {
        cc.optional = (cc.optional || []).concat(c.advanced);
      }
      return cc;
    };

    var shimConstraints_ = function shimConstraints_(constraints, func) {
      if (browserDetails.version >= 61) {
        return func(constraints);
      }
      constraints = JSON.parse(JSON.stringify(constraints));
      if (constraints && _typeof(constraints.audio) === 'object') {
        var remap = function remap(obj, a, b) {
          if (a in obj && !(b in obj)) {
            obj[b] = obj[a];
            delete obj[a];
          }
        };
        constraints = JSON.parse(JSON.stringify(constraints));
        remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
        remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
        constraints.audio = constraintsToChrome_(constraints.audio);
      }
      if (constraints && _typeof(constraints.video) === 'object') {
        // Shim facingMode for mobile & surface pro.
        var face = constraints.video.facingMode;
        face = face && ((typeof face === 'undefined' ? 'undefined' : _typeof(face)) === 'object' ? face : { ideal: face });
        var getSupportedFacingModeLies = browserDetails.version < 66;

        if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
          delete constraints.video.facingMode;
          var matches = void 0;
          if (face.exact === 'environment' || face.ideal === 'environment') {
            matches = ['back', 'rear'];
          } else if (face.exact === 'user' || face.ideal === 'user') {
            matches = ['front'];
          }
          if (matches) {
            // Look for matches in label, or use last cam for back (typical).
            return navigator.mediaDevices.enumerateDevices().then(function (devices) {
              devices = devices.filter(function (d) {
                return d.kind === 'videoinput';
              });
              var dev = devices.find(function (d) {
                return matches.some(function (match) {
                  return d.label.toLowerCase().includes(match);
                });
              });
              if (!dev && devices.length && matches.includes('back')) {
                dev = devices[devices.length - 1]; // more likely the back cam
              }
              if (dev) {
                constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };
              }
              constraints.video = constraintsToChrome_(constraints.video);
              logging('chrome: ' + JSON.stringify(constraints));
              return func(constraints);
            });
          }
        }
        constraints.video = constraintsToChrome_(constraints.video);
      }
      logging('chrome: ' + JSON.stringify(constraints));
      return func(constraints);
    };

    var shimError_ = function shimError_(e) {
      if (browserDetails.version >= 64) {
        return e;
      }
      return {
        name: {
          PermissionDeniedError: 'NotAllowedError',
          PermissionDismissedError: 'NotAllowedError',
          InvalidStateError: 'NotAllowedError',
          DevicesNotFoundError: 'NotFoundError',
          ConstraintNotSatisfiedError: 'OverconstrainedError',
          TrackStartError: 'NotReadableError',
          MediaDeviceFailedDueToShutdown: 'NotAllowedError',
          MediaDeviceKillSwitchOn: 'NotAllowedError',
          TabCaptureError: 'AbortError',
          ScreenCaptureError: 'AbortError',
          DeviceCaptureError: 'AbortError'
        }[e.name] || e.name,
        message: e.message,
        constraint: e.constraint || e.constraintName,
        toString: function toString() {
          return this.name + (this.message && ': ') + this.message;
        }
      };
    };

    var getUserMedia_ = function getUserMedia_(constraints, onSuccess, onError) {
      shimConstraints_(constraints, function (c) {
        navigator.webkitGetUserMedia(c, onSuccess, function (e) {
          if (onError) {
            onError(shimError_(e));
          }
        });
      });
    };
    navigator.getUserMedia = getUserMedia_.bind(navigator);

    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
    // function which returns a Promise, it does not accept spec-style
    // constraints.
    if (navigator.mediaDevices.getUserMedia) {
      var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
      navigator.mediaDevices.getUserMedia = function (cs) {
        return shimConstraints_(cs, function (c) {
          return origGetUserMedia(c).then(function (stream) {
            if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
              stream.getTracks().forEach(function (track) {
                track.stop();
              });
              throw new DOMException('', 'NotFoundError');
            }
            return stream;
          }, function (e) {
            return Promise.reject(shimError_(e));
          });
        });
      };
    }
  }

  },{"../utils.js":15}],6:[function(require,module,exports){
  /*
   *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  exports.shimRTCIceCandidate = shimRTCIceCandidate;
  exports.shimMaxMessageSize = shimMaxMessageSize;
  exports.shimSendThrowTypeError = shimSendThrowTypeError;
  exports.shimConnectionState = shimConnectionState;
  exports.removeAllowExtmapMixed = removeAllowExtmapMixed;

  var _sdp = require('sdp');

  var _sdp2 = _interopRequireDefault(_sdp);

  var _utils = require('./utils');

  var utils = _interopRequireWildcard(_utils);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function shimRTCIceCandidate(window) {
    // foundation is arbitrarily chosen as an indicator for full support for
    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
    if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {
      return;
    }

    var NativeRTCIceCandidate = window.RTCIceCandidate;
    window.RTCIceCandidate = function (args) {
      // Remove the a= which shouldn't be part of the candidate string.
      if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {
        args = JSON.parse(JSON.stringify(args));
        args.candidate = args.candidate.substr(2);
      }

      if (args.candidate && args.candidate.length) {
        // Augment the native candidate with the parsed fields.
        var nativeCandidate = new NativeRTCIceCandidate(args);
        var parsedCandidate = _sdp2.default.parseCandidate(args.candidate);
        var augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate);

        // Add a serializer that does not serialize the extra attributes.
        augmentedCandidate.toJSON = function () {
          return {
            candidate: augmentedCandidate.candidate,
            sdpMid: augmentedCandidate.sdpMid,
            sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
            usernameFragment: augmentedCandidate.usernameFragment
          };
        };
        return augmentedCandidate;
      }
      return new NativeRTCIceCandidate(args);
    };
    window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

    // Hook up the augmented candidate in onicecandidate and
    // addEventListener('icecandidate', ...)
    utils.wrapPeerConnectionEvent(window, 'icecandidate', function (e) {
      if (e.candidate) {
        Object.defineProperty(e, 'candidate', {
          value: new window.RTCIceCandidate(e.candidate),
          writable: 'false'
        });
      }
      return e;
    });
  }

  function shimMaxMessageSize(window) {
    if (window.RTCSctpTransport || !window.RTCPeerConnection) {
      return;
    }
    var browserDetails = utils.detectBrowser(window);

    if (!('sctp' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
        get: function get() {
          return typeof this._sctp === 'undefined' ? null : this._sctp;
        }
      });
    }

    var sctpInDescription = function sctpInDescription(description) {
      if (!description || !description.sdp) {
        return false;
      }
      var sections = _sdp2.default.splitSections(description.sdp);
      sections.shift();
      return sections.some(function (mediaSection) {
        var mLine = _sdp2.default.parseMLine(mediaSection);
        return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;
      });
    };

    var getRemoteFirefoxVersion = function getRemoteFirefoxVersion(description) {
      // TODO: Is there a better solution for detecting Firefox?
      var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
      if (match === null || match.length < 2) {
        return -1;
      }
      var version = parseInt(match[1], 10);
      // Test for NaN (yes, this is ugly)
      return version !== version ? -1 : version;
    };

    var getCanSendMaxMessageSize = function getCanSendMaxMessageSize(remoteIsFirefox) {
      // Every implementation we know can send at least 64 KiB.
      // Note: Although Chrome is technically able to send up to 256 KiB, the
      //       data does not reach the other peer reliably.
      //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
      var canSendMaxMessageSize = 65536;
      if (browserDetails.browser === 'firefox') {
        if (browserDetails.version < 57) {
          if (remoteIsFirefox === -1) {
            // FF < 57 will send in 16 KiB chunks using the deprecated PPID
            // fragmentation.
            canSendMaxMessageSize = 16384;
          } else {
            // However, other FF (and RAWRTC) can reassemble PPID-fragmented
            // messages. Thus, supporting ~2 GiB when sending.
            canSendMaxMessageSize = 2147483637;
          }
        } else if (browserDetails.version < 60) {
          // Currently, all FF >= 57 will reset the remote maximum message size
          // to the default value when a data channel is created at a later
          // stage. :(
          // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
          canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
        } else {
          // FF >= 60 supports sending ~2 GiB
          canSendMaxMessageSize = 2147483637;
        }
      }
      return canSendMaxMessageSize;
    };

    var getMaxMessageSize = function getMaxMessageSize(description, remoteIsFirefox) {
      // Note: 65536 bytes is the default value from the SDP spec. Also,
      //       every implementation we know supports receiving 65536 bytes.
      var maxMessageSize = 65536;

      // FF 57 has a slightly incorrect default remote max message size, so
      // we need to adjust it here to avoid a failure when sending.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
      if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {
        maxMessageSize = 65535;
      }

      var match = _sdp2.default.matchPrefix(description.sdp, 'a=max-message-size:');
      if (match.length > 0) {
        maxMessageSize = parseInt(match[0].substr(19), 10);
      } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {
        // If the maximum message size is not present in the remote SDP and
        // both local and remote are Firefox, the remote peer can receive
        // ~2 GiB.
        maxMessageSize = 2147483637;
      }
      return maxMessageSize;
    };

    var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function () {
      this._sctp = null;

      if (sctpInDescription(arguments[0])) {
        // Check if the remote is FF.
        var isFirefox = getRemoteFirefoxVersion(arguments[0]);

        // Get the maximum message size the local peer is capable of sending
        var canSendMMS = getCanSendMaxMessageSize(isFirefox);

        // Get the maximum message size of the remote peer.
        var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

        // Determine final maximum message size
        var maxMessageSize = void 0;
        if (canSendMMS === 0 && remoteMMS === 0) {
          maxMessageSize = Number.POSITIVE_INFINITY;
        } else if (canSendMMS === 0 || remoteMMS === 0) {
          maxMessageSize = Math.max(canSendMMS, remoteMMS);
        } else {
          maxMessageSize = Math.min(canSendMMS, remoteMMS);
        }

        // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
        // attribute.
        var sctp = {};
        Object.defineProperty(sctp, 'maxMessageSize', {
          get: function get() {
            return maxMessageSize;
          }
        });
        this._sctp = sctp;
      }

      return origSetRemoteDescription.apply(this, arguments);
    };
  }

  function shimSendThrowTypeError(window) {
    if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {
      return;
    }

    // Note: Although Firefox >= 57 has a native implementation, the maximum
    //       message size can be reset for all data channels at a later stage.
    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

    function wrapDcSend(dc, pc) {
      var origDataChannelSend = dc.send;
      dc.send = function () {
        var data = arguments[0];
        var length = data.length || data.size || data.byteLength;
        if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {
          throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');
        }
        return origDataChannelSend.apply(dc, arguments);
      };
    }
    var origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;
    window.RTCPeerConnection.prototype.createDataChannel = function () {
      var dataChannel = origCreateDataChannel.apply(this, arguments);
      wrapDcSend(dataChannel, this);
      return dataChannel;
    };
    utils.wrapPeerConnectionEvent(window, 'datachannel', function (e) {
      wrapDcSend(e.channel, e.target);
      return e;
    });
  }

  /* shims RTCConnectionState by pretending it is the same as iceConnectionState.
   * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12
   * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect
   * since DTLS failures would be hidden. See
   * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827
   * for the Firefox tracking bug.
   */
  function shimConnectionState(window) {
    if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {
      return;
    }
    var proto = window.RTCPeerConnection.prototype;
    Object.defineProperty(proto, 'connectionState', {
      get: function get() {
        return {
          completed: 'connected',
          checking: 'connecting'
        }[this.iceConnectionState] || this.iceConnectionState;
      },

      enumerable: true,
      configurable: true
    });
    Object.defineProperty(proto, 'onconnectionstatechange', {
      get: function get() {
        return this._onconnectionstatechange || null;
      },
      set: function set(cb) {
        if (this._onconnectionstatechange) {
          this.removeEventListener('connectionstatechange', this._onconnectionstatechange);
          delete this._onconnectionstatechange;
        }
        if (cb) {
          this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);
        }
      },

      enumerable: true,
      configurable: true
    });

    ['setLocalDescription', 'setRemoteDescription'].forEach(function (method) {
      var origMethod = proto[method];
      proto[method] = function () {
        if (!this._connectionstatechangepoly) {
          this._connectionstatechangepoly = function (e) {
            var pc = e.target;
            if (pc._lastConnectionState !== pc.connectionState) {
              pc._lastConnectionState = pc.connectionState;
              var newEvent = new Event('connectionstatechange', e);
              pc.dispatchEvent(newEvent);
            }
            return e;
          };
          this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);
        }
        return origMethod.apply(this, arguments);
      };
    });
  }

  function removeAllowExtmapMixed(window) {
    /* remove a=extmap-allow-mixed for Chrome < M71 */
    if (!window.RTCPeerConnection) {
      return;
    }
    var browserDetails = utils.detectBrowser(window);
    if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {
      return;
    }
    var nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function (desc) {
      if (desc && desc.sdp && desc.sdp.indexOf('\na=extmap-allow-mixed') !== -1) {
        desc.sdp = desc.sdp.split('\n').filter(function (line) {
          return line.trim() !== 'a=extmap-allow-mixed';
        }).join('\n');
      }
      return nativeSRD.apply(this, arguments);
    };
  }

  },{"./utils":15,"sdp":17}],7:[function(require,module,exports){
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

  var _getusermedia = require('./getusermedia');

  Object.defineProperty(exports, 'shimGetUserMedia', {
    enumerable: true,
    get: function get() {
      return _getusermedia.shimGetUserMedia;
    }
  });

  var _getdisplaymedia = require('./getdisplaymedia');

  Object.defineProperty(exports, 'shimGetDisplayMedia', {
    enumerable: true,
    get: function get() {
      return _getdisplaymedia.shimGetDisplayMedia;
    }
  });
  exports.shimPeerConnection = shimPeerConnection;
  exports.shimReplaceTrack = shimReplaceTrack;

  var _utils = require('../utils');

  var utils = _interopRequireWildcard(_utils);

  var _filtericeservers = require('./filtericeservers');

  var _rtcpeerconnectionShim = require('rtcpeerconnection-shim');

  var _rtcpeerconnectionShim2 = _interopRequireDefault(_rtcpeerconnectionShim);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function shimPeerConnection(window) {
    var browserDetails = utils.detectBrowser(window);

    if (window.RTCIceGatherer) {
      if (!window.RTCIceCandidate) {
        window.RTCIceCandidate = function (args) {
          return args;
        };
      }
      if (!window.RTCSessionDescription) {
        window.RTCSessionDescription = function (args) {
          return args;
        };
      }
      // this adds an additional event listener to MediaStrackTrack that signals
      // when a tracks enabled property was changed. Workaround for a bug in
      // addStream, see below. No longer required in 15025+
      if (browserDetails.version < 15025) {
        var origMSTEnabled = Object.getOwnPropertyDescriptor(window.MediaStreamTrack.prototype, 'enabled');
        Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {
          set: function set(value) {
            origMSTEnabled.set.call(this, value);
            var ev = new Event('enabled');
            ev.enabled = value;
            this.dispatchEvent(ev);
          }
        });
      }
    }

    // ORTC defines the DTMF sender a bit different.
    // https://github.com/w3c/ortc/issues/714
    if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get: function get() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = new window.RTCDtmfSender(this);
            } else if (this.track.kind === 'video') {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
    // Edge currently only implements the RTCDtmfSender, not the
    // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*
    if (window.RTCDtmfSender && !window.RTCDTMFSender) {
      window.RTCDTMFSender = window.RTCDtmfSender;
    }

    var RTCPeerConnectionShim = (0, _rtcpeerconnectionShim2.default)(window, browserDetails.version);
    window.RTCPeerConnection = function (config) {
      if (config && config.iceServers) {
        config.iceServers = (0, _filtericeservers.filterIceServers)(config.iceServers, browserDetails.version);
        utils.log('ICE servers after filtering:', config.iceServers);
      }
      return new RTCPeerConnectionShim(config);
    };
    window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;
  }

  function shimReplaceTrack(window) {
    // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
    if (window.RTCRtpSender && !('replaceTrack' in window.RTCRtpSender.prototype)) {
      window.RTCRtpSender.prototype.replaceTrack = window.RTCRtpSender.prototype.setTrack;
    }
  }

  },{"../utils":15,"./filtericeservers":8,"./getdisplaymedia":9,"./getusermedia":10,"rtcpeerconnection-shim":16}],8:[function(require,module,exports){
  /*
   *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.filterIceServers = filterIceServers;

  var _utils = require('../utils');

  var utils = _interopRequireWildcard(_utils);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  // Edge does not like
  // 1) stun: filtered after 14393 unless ?transport=udp is present
  // 2) turn: that does not have all of turn:host:port?transport=udp
  // 3) turn: with ipv6 addresses
  // 4) turn: occurring muliple times
  function filterIceServers(iceServers, edgeVersion) {
    var hasTurn = false;
    iceServers = JSON.parse(JSON.stringify(iceServers));
    return iceServers.filter(function (server) {
      if (server && (server.urls || server.url)) {
        var urls = server.urls || server.url;
        if (server.url && !server.urls) {
          utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
        }
        var isString = typeof urls === 'string';
        if (isString) {
          urls = [urls];
        }
        urls = urls.filter(function (url) {
          // filter STUN unconditionally.
          if (url.indexOf('stun:') === 0) {
            return false;
          }

          var validTurn = url.startsWith('turn') && !url.startsWith('turn:[') && url.includes('transport=udp');
          if (validTurn && !hasTurn) {
            hasTurn = true;
            return true;
          }
          return validTurn && !hasTurn;
        });

        delete server.url;
        server.urls = isString ? urls[0] : urls;
        return !!urls.length;
      }
    });
  }

  },{"../utils":15}],9:[function(require,module,exports){
  /*
   *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.shimGetDisplayMedia = shimGetDisplayMedia;
  function shimGetDisplayMedia(window) {
    if (!('getDisplayMedia' in window.navigator)) {
      return;
    }
    if (!window.navigator.mediaDevices) {
      return;
    }
    if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
      return;
    }
    window.navigator.mediaDevices.getDisplayMedia = window.navigator.getDisplayMedia.bind(window.navigator);
  }

  },{}],10:[function(require,module,exports){
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.shimGetUserMedia = shimGetUserMedia;
  function shimGetUserMedia(window) {
    var navigator = window && window.navigator;

    var shimError_ = function shimError_(e) {
      return {
        name: { PermissionDeniedError: 'NotAllowedError' }[e.name] || e.name,
        message: e.message,
        constraint: e.constraint,
        toString: function toString() {
          return this.name;
        }
      };
    };

    // getUserMedia error shim.
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function (c) {
      return origGetUserMedia(c).catch(function (e) {
        return Promise.reject(shimError_(e));
      });
    };
  }

  },{}],11:[function(require,module,exports){
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _getusermedia = require('./getusermedia');

  Object.defineProperty(exports, 'shimGetUserMedia', {
    enumerable: true,
    get: function get() {
      return _getusermedia.shimGetUserMedia;
    }
  });

  var _getdisplaymedia = require('./getdisplaymedia');

  Object.defineProperty(exports, 'shimGetDisplayMedia', {
    enumerable: true,
    get: function get() {
      return _getdisplaymedia.shimGetDisplayMedia;
    }
  });
  exports.shimOnTrack = shimOnTrack;
  exports.shimPeerConnection = shimPeerConnection;
  exports.shimSenderGetStats = shimSenderGetStats;
  exports.shimReceiverGetStats = shimReceiverGetStats;
  exports.shimRemoveStream = shimRemoveStream;
  exports.shimRTCDataChannel = shimRTCDataChannel;

  var _utils = require('../utils');

  var utils = _interopRequireWildcard(_utils);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function shimOnTrack(window) {
    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get: function get() {
          return { receiver: this.receiver };
        }
      });
    }
  }

  function shimPeerConnection(window) {
    var browserDetails = utils.detectBrowser(window);

    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
      return; // probably media.peerconnection.enabled=false in about:config
    }
    if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {
      // very basic support for old versions.
      window.RTCPeerConnection = window.mozRTCPeerConnection;
    }

    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      window.RTCPeerConnection.prototype[method] = function () {
        arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      };
    });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function () {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };

    var modernStatsTypes = {
      inboundrtp: 'inbound-rtp',
      outboundrtp: 'outbound-rtp',
      candidatepair: 'candidate-pair',
      localcandidate: 'local-candidate',
      remotecandidate: 'remote-candidate'
    };

    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function (selector, onSucc, onErr) {
      return nativeGetStats.apply(this, [selector || null]).then(function (stats) {
        if (browserDetails.version < 53 && !onSucc) {
          // Shim only promise getStats with spec-hyphens in type names
          // Leave callback version alone; misc old uses of forEach before Map
          try {
            stats.forEach(function (stat) {
              stat.type = modernStatsTypes[stat.type] || stat.type;
            });
          } catch (e) {
            if (e.name !== 'TypeError') {
              throw e;
            }
            // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
            stats.forEach(function (stat, i) {
              stats.set(i, Object.assign({}, stat, {
                type: modernStatsTypes[stat.type] || stat.type
              }));
            });
          }
        }
        return stats;
      }).then(onSucc, onErr);
    };
  }

  function shimSenderGetStats(window) {
    if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
      return;
    }
    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window.RTCPeerConnection.prototype.getSenders = function () {
        var _this = this;

        var senders = origGetSenders.apply(this, []);
        senders.forEach(function (sender) {
          return sender._pc = _this;
        });
        return senders;
      };
    }

    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window.RTCPeerConnection.prototype.addTrack = function () {
        var sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window.RTCRtpSender.prototype.getStats = function () {
      return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());
    };
  }

  function shimReceiverGetStats(window) {
    if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
      return;
    }
    var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window.RTCPeerConnection.prototype.getReceivers = function () {
        var _this2 = this;

        var receivers = origGetReceivers.apply(this, []);
        receivers.forEach(function (receiver) {
          return receiver._pc = _this2;
        });
        return receivers;
      };
    }
    utils.wrapPeerConnectionEvent(window, 'track', function (e) {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window.RTCRtpReceiver.prototype.getStats = function () {
      return this._pc.getStats(this.track);
    };
  }

  function shimRemoveStream(window) {
    if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {
      return;
    }
    window.RTCPeerConnection.prototype.removeStream = function (stream) {
      var _this3 = this;

      utils.deprecated('removeStream', 'removeTrack');
      this.getSenders().forEach(function (sender) {
        if (sender.track && stream.getTracks().includes(sender.track)) {
          _this3.removeTrack(sender);
        }
      });
    };
  }

  function shimRTCDataChannel(window) {
    // rename DataChannel to RTCDataChannel (native fix in FF60):
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
    if (window.DataChannel && !window.RTCDataChannel) {
      window.RTCDataChannel = window.DataChannel;
    }
  }

  },{"../utils":15,"./getdisplaymedia":12,"./getusermedia":13}],12:[function(require,module,exports){
  /*
   *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.shimGetDisplayMedia = shimGetDisplayMedia;
  function shimGetDisplayMedia(window, preferredMediaSource) {
    if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
      return;
    }
    if (!window.navigator.mediaDevices) {
      return;
    }
    window.navigator.mediaDevices.getDisplayMedia = function (constraints) {
      if (!(constraints && constraints.video)) {
        var err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');
        err.name = 'NotFoundError';
        // from https://heycam.github.io/webidl/#idl-DOMException-error-names
        err.code = 8;
        return Promise.reject(err);
      }
      if (constraints.video === true) {
        constraints.video = { mediaSource: preferredMediaSource };
      } else {
        constraints.video.mediaSource = preferredMediaSource;
      }
      return window.navigator.mediaDevices.getUserMedia(constraints);
    };
  }

  },{}],13:[function(require,module,exports){
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  exports.shimGetUserMedia = shimGetUserMedia;

  var _utils = require('../utils');

  var utils = _interopRequireWildcard(_utils);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function shimGetUserMedia(window) {
    var browserDetails = utils.detectBrowser(window);
    var navigator = window && window.navigator;
    var MediaStreamTrack = window && window.MediaStreamTrack;

    navigator.getUserMedia = function (constraints, onSuccess, onError) {
      // Replace Firefox 44+'s deprecation warning with unprefixed version.
      utils.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');
      navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
    };

    if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
      var remap = function remap(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };

      var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
      navigator.mediaDevices.getUserMedia = function (c) {
        if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object' && _typeof(c.audio) === 'object') {
          c = JSON.parse(JSON.stringify(c));
          remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
          remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
        }
        return nativeGetUserMedia(c);
      };

      if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
        var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
        MediaStreamTrack.prototype.getSettings = function () {
          var obj = nativeGetSettings.apply(this, arguments);
          remap(obj, 'mozAutoGainControl', 'autoGainControl');
          remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
          return obj;
        };
      }

      if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
        var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
        MediaStreamTrack.prototype.applyConstraints = function (c) {
          if (this.kind === 'audio' && (typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object') {
            c = JSON.parse(JSON.stringify(c));
            remap(c, 'autoGainControl', 'mozAutoGainControl');
            remap(c, 'noiseSuppression', 'mozNoiseSuppression');
          }
          return nativeApplyConstraints.apply(this, [c]);
        };
      }
    }
  }

  },{"../utils":15}],14:[function(require,module,exports){
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  exports.shimLocalStreamsAPI = shimLocalStreamsAPI;
  exports.shimRemoteStreamsAPI = shimRemoteStreamsAPI;
  exports.shimCallbacksAPI = shimCallbacksAPI;
  exports.shimGetUserMedia = shimGetUserMedia;
  exports.shimConstraints = shimConstraints;
  exports.shimRTCIceServerUrls = shimRTCIceServerUrls;
  exports.shimTrackEventTransceiver = shimTrackEventTransceiver;
  exports.shimCreateOfferLegacy = shimCreateOfferLegacy;

  var _utils = require('../utils');

  var utils = _interopRequireWildcard(_utils);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function shimLocalStreamsAPI(window) {
    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getLocalStreams = function () {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        return this._localStreams;
      };
    }
    if (!('addStream' in window.RTCPeerConnection.prototype)) {
      var _addTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addStream = function (stream) {
        var _this = this;

        if (!this._localStreams) {
          this._localStreams = [];
        }
        if (!this._localStreams.includes(stream)) {
          this._localStreams.push(stream);
        }
        stream.getTracks().forEach(function (track) {
          return _addTrack.call(_this, track, stream);
        });
      };

      window.RTCPeerConnection.prototype.addTrack = function (track, stream) {
        if (stream) {
          if (!this._localStreams) {
            this._localStreams = [stream];
          } else if (!this._localStreams.includes(stream)) {
            this._localStreams.push(stream);
          }
        }
        return _addTrack.call(this, track, stream);
      };
    }
    if (!('removeStream' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.removeStream = function (stream) {
        var _this2 = this;

        if (!this._localStreams) {
          this._localStreams = [];
        }
        var index = this._localStreams.indexOf(stream);
        if (index === -1) {
          return;
        }
        this._localStreams.splice(index, 1);
        var tracks = stream.getTracks();
        this.getSenders().forEach(function (sender) {
          if (tracks.includes(sender.track)) {
            _this2.removeTrack(sender);
          }
        });
      };
    }
  }

  function shimRemoteStreamsAPI(window) {
    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getRemoteStreams = function () {
        return this._remoteStreams ? this._remoteStreams : [];
      };
    }
    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
        get: function get() {
          return this._onaddstream;
        },
        set: function set(f) {
          var _this3 = this;

          if (this._onaddstream) {
            this.removeEventListener('addstream', this._onaddstream);
            this.removeEventListener('track', this._onaddstreampoly);
          }
          this.addEventListener('addstream', this._onaddstream = f);
          this.addEventListener('track', this._onaddstreampoly = function (e) {
            e.streams.forEach(function (stream) {
              if (!_this3._remoteStreams) {
                _this3._remoteStreams = [];
              }
              if (_this3._remoteStreams.includes(stream)) {
                return;
              }
              _this3._remoteStreams.push(stream);
              var event = new Event('addstream');
              event.stream = stream;
              _this3.dispatchEvent(event);
            });
          });
        }
      });
      var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription = function () {
        var pc = this;
        if (!this._onaddstreampoly) {
          this.addEventListener('track', this._onaddstreampoly = function (e) {
            e.streams.forEach(function (stream) {
              if (!pc._remoteStreams) {
                pc._remoteStreams = [];
              }
              if (pc._remoteStreams.indexOf(stream) >= 0) {
                return;
              }
              pc._remoteStreams.push(stream);
              var event = new Event('addstream');
              event.stream = stream;
              pc.dispatchEvent(event);
            });
          });
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
    }
  }

  function shimCallbacksAPI(window) {
    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    var prototype = window.RTCPeerConnection.prototype;
    var createOffer = prototype.createOffer;
    var createAnswer = prototype.createAnswer;
    var setLocalDescription = prototype.setLocalDescription;
    var setRemoteDescription = prototype.setRemoteDescription;
    var addIceCandidate = prototype.addIceCandidate;

    prototype.createOffer = function (successCallback, failureCallback) {
      var options = arguments.length >= 2 ? arguments[2] : arguments[0];
      var promise = createOffer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    prototype.createAnswer = function (successCallback, failureCallback) {
      var options = arguments.length >= 2 ? arguments[2] : arguments[0];
      var promise = createAnswer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    var withCallback = function withCallback(description, successCallback, failureCallback) {
      var promise = setLocalDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setLocalDescription = withCallback;

    withCallback = function withCallback(description, successCallback, failureCallback) {
      var promise = setRemoteDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setRemoteDescription = withCallback;

    withCallback = function withCallback(candidate, successCallback, failureCallback) {
      var promise = addIceCandidate.apply(this, [candidate]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.addIceCandidate = withCallback;
  }

  function shimGetUserMedia(window) {
    var navigator = window && window.navigator;

    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      // shim not needed in Safari 12.1
      var mediaDevices = navigator.mediaDevices;
      var _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
      navigator.mediaDevices.getUserMedia = function (constraints) {
        return _getUserMedia(shimConstraints(constraints));
      };
    }

    if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      navigator.getUserMedia = function (constraints, cb, errcb) {
        navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);
      }.bind(navigator);
    }
  }

  function shimConstraints(constraints) {
    if (constraints && constraints.video !== undefined) {
      return Object.assign({}, constraints, { video: utils.compactObject(constraints.video) });
    }

    return constraints;
  }

  function shimRTCIceServerUrls(window) {
    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
    var OrigPeerConnection = window.RTCPeerConnection;
    window.RTCPeerConnection = function (pcConfig, pcConstraints) {
      if (pcConfig && pcConfig.iceServers) {
        var newIceServers = [];
        for (var i = 0; i < pcConfig.iceServers.length; i++) {
          var server = pcConfig.iceServers[i];
          if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {
            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
            server = JSON.parse(JSON.stringify(server));
            server.urls = server.url;
            delete server.url;
            newIceServers.push(server);
          } else {
            newIceServers.push(pcConfig.iceServers[i]);
          }
        }
        pcConfig.iceServers = newIceServers;
      }
      return new OrigPeerConnection(pcConfig, pcConstraints);
    };
    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
    // wrap static methods. Currently just generateCertificate.
    if ('generateCertificate' in window.RTCPeerConnection) {
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function get() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }
  }

  function shimTrackEventTransceiver(window) {
    // Add event.transceiver member over deprecated event.receiver
    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && 'receiver' in window.RTCTrackEvent.prototype &&
    // can't check 'transceiver' in window.RTCTrackEvent.prototype, as it is
    // defined for some reason even when window.RTCTransceiver is not.
    !window.RTCTransceiver) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get: function get() {
          return { receiver: this.receiver };
        }
      });
    }
  }

  function shimCreateOfferLegacy(window) {
    var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
    window.RTCPeerConnection.prototype.createOffer = function (offerOptions) {
      if (offerOptions) {
        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
        }
        var audioTransceiver = this.getTransceivers().find(function (transceiver) {
          return transceiver.receiver.track.kind === 'audio';
        });
        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
          if (audioTransceiver.direction === 'sendrecv') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('sendonly');
            } else {
              audioTransceiver.direction = 'sendonly';
            }
          } else if (audioTransceiver.direction === 'recvonly') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('inactive');
            } else {
              audioTransceiver.direction = 'inactive';
            }
          }
        } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
          this.addTransceiver('audio');
        }

        if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
        }
        var videoTransceiver = this.getTransceivers().find(function (transceiver) {
          return transceiver.receiver.track.kind === 'video';
        });
        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
          if (videoTransceiver.direction === 'sendrecv') {
            if (videoTransceiver.setDirection) {
              videoTransceiver.setDirection('sendonly');
            } else {
              videoTransceiver.direction = 'sendonly';
            }
          } else if (videoTransceiver.direction === 'recvonly') {
            if (videoTransceiver.setDirection) {
              videoTransceiver.setDirection('inactive');
            } else {
              videoTransceiver.direction = 'inactive';
            }
          }
        } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
          this.addTransceiver('video');
        }
      }
      return origCreateOffer.apply(this, arguments);
    };
  }

  },{"../utils":15}],15:[function(require,module,exports){
  /*
   *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
  /* eslint-env node */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  exports.extractVersion = extractVersion;
  exports.wrapPeerConnectionEvent = wrapPeerConnectionEvent;
  exports.disableLog = disableLog;
  exports.disableWarnings = disableWarnings;
  exports.log = log;
  exports.deprecated = deprecated;
  exports.detectBrowser = detectBrowser;
  exports.compactObject = compactObject;
  exports.walkStats = walkStats;
  exports.filterStats = filterStats;

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  var logDisabled_ = true;
  var deprecationWarnings_ = true;

  /**
   * Extract browser version out of the provided user agent string.
   *
   * @param {!string} uastring userAgent string.
   * @param {!string} expr Regular expression used as match criteria.
   * @param {!number} pos position in the version string to be returned.
   * @return {!number} browser version.
   */
  function extractVersion(uastring, expr, pos) {
    var match = uastring.match(expr);
    return match && match.length >= pos && parseInt(match[pos], 10);
  }

  // Wraps the peerconnection event eventNameToWrap in a function
  // which returns the modified event object (or false to prevent
  // the event).
  function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
    if (!window.RTCPeerConnection) {
      return;
    }
    var proto = window.RTCPeerConnection.prototype;
    var nativeAddEventListener = proto.addEventListener;
    proto.addEventListener = function (nativeEventName, cb) {
      if (nativeEventName !== eventNameToWrap) {
        return nativeAddEventListener.apply(this, arguments);
      }
      var wrappedCallback = function wrappedCallback(e) {
        var modifiedEvent = wrapper(e);
        if (modifiedEvent) {
          cb(modifiedEvent);
        }
      };
      this._eventMap = this._eventMap || {};
      this._eventMap[cb] = wrappedCallback;
      return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
    };

    var nativeRemoveEventListener = proto.removeEventListener;
    proto.removeEventListener = function (nativeEventName, cb) {
      if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[cb]) {
        return nativeRemoveEventListener.apply(this, arguments);
      }
      var unwrappedCb = this._eventMap[cb];
      delete this._eventMap[cb];
      return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
    };

    Object.defineProperty(proto, 'on' + eventNameToWrap, {
      get: function get() {
        return this['_on' + eventNameToWrap];
      },
      set: function set(cb) {
        if (this['_on' + eventNameToWrap]) {
          this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);
          delete this['_on' + eventNameToWrap];
        }
        if (cb) {
          this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);
        }
      },

      enumerable: true,
      configurable: true
    });
  }

  function disableLog(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
    }
    logDisabled_ = bool;
    return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';
  }

  /**
   * Disable or enable deprecation warnings
   * @param {!boolean} bool set to true to disable warnings.
   */
  function disableWarnings(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
    }
    deprecationWarnings_ = !bool;
    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
  }

  function log() {
    if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object') {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== 'undefined' && typeof console.log === 'function') {
        console.log.apply(console, arguments);
      }
    }
  }

  /**
   * Shows a deprecation warning suggesting the modern and spec-compatible API.
   */
  function deprecated(oldMethod, newMethod) {
    if (!deprecationWarnings_) {
      return;
    }
    console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');
  }

  /**
   * Browser detector.
   *
   * @return {object} result containing browser and version
   *     properties.
   */
  function detectBrowser(window) {
    var navigator = window.navigator;

    // Returned result object.

    var result = { browser: null, version: null };

    // Fail early if it's not a browser
    if (typeof window === 'undefined' || !window.navigator) {
      result.browser = 'Not a browser.';
      return result;
    }

    if (navigator.mozGetUserMedia) {
      // Firefox.
      result.browser = 'firefox';
      result.version = extractVersion(navigator.userAgent, /Firefox\/(\d+)\./, 1);
    } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection && !window.RTCIceGatherer) {
      // Chrome, Chromium, Webview, Opera.
      // Version matches Chrome/WebRTC version.
      // Chrome 74 removed webkitGetUserMedia on http as well so we need the
      // more complicated fallback to webkitRTCPeerConnection.
      result.browser = 'chrome';
      result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
    } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
      // Edge.
      result.browser = 'edge';
      result.version = extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);
    } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
      // Safari.
      result.browser = 'safari';
      result.version = extractVersion(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
    } else {
      // Default fallthrough: not supported.
      result.browser = 'Not a supported browser.';
      return result;
    }

    return result;
  }

  /**
   * Remove all empty objects and undefined values
   * from a nested object -- an enhanced and vanilla version
   * of Lodash's `compact`.
   */
  function compactObject(data) {
    if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
      return data;
    }

    return Object.keys(data).reduce(function (accumulator, key) {
      var isObject = _typeof(data[key]) === 'object';
      var value = isObject ? compactObject(data[key]) : data[key];
      var isEmptyObject = isObject && !Object.keys(value).length;
      if (value === undefined || isEmptyObject) {
        return accumulator;
      }

      return Object.assign(accumulator, _defineProperty({}, key, value));
    }, {});
  }

  /* iterates the stats graph recursively. */
  function walkStats(stats, base, resultSet) {
    if (!base || resultSet.has(base.id)) {
      return;
    }
    resultSet.set(base.id, base);
    Object.keys(base).forEach(function (name) {
      if (name.endsWith('Id')) {
        walkStats(stats, stats.get(base[name]), resultSet);
      } else if (name.endsWith('Ids')) {
        base[name].forEach(function (id) {
          walkStats(stats, stats.get(id), resultSet);
        });
      }
    });
  }

  /* filter getStats for a sender/receiver track. */
  function filterStats(result, track, outbound) {
    var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
    var filteredResult = new Map();
    if (track === null) {
      return filteredResult;
    }
    var trackStats = [];
    result.forEach(function (value) {
      if (value.type === 'track' && value.trackIdentifier === track.id) {
        trackStats.push(value);
      }
    });
    trackStats.forEach(function (trackStat) {
      result.forEach(function (stats) {
        if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
          walkStats(result, stats, filteredResult);
        }
      });
    });
    return filteredResult;
  }

  },{}],16:[function(require,module,exports){
  /*
   *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
   */
   /* eslint-env node */
  'use strict';

  var SDPUtils = require('sdp');

  function fixStatsType(stat) {
    return {
      inboundrtp: 'inbound-rtp',
      outboundrtp: 'outbound-rtp',
      candidatepair: 'candidate-pair',
      localcandidate: 'local-candidate',
      remotecandidate: 'remote-candidate'
    }[stat.type] || stat.type;
  }

  function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
    var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

    // Map ICE parameters (ufrag, pwd) to SDP.
    sdp += SDPUtils.writeIceParameters(
        transceiver.iceGatherer.getLocalParameters());

    // Map DTLS parameters to SDP.
    sdp += SDPUtils.writeDtlsParameters(
        transceiver.dtlsTransport.getLocalParameters(),
        type === 'offer' ? 'actpass' : dtlsRole || 'active');

    sdp += 'a=mid:' + transceiver.mid + '\r\n';

    if (transceiver.rtpSender && transceiver.rtpReceiver) {
      sdp += 'a=sendrecv\r\n';
    } else if (transceiver.rtpSender) {
      sdp += 'a=sendonly\r\n';
    } else if (transceiver.rtpReceiver) {
      sdp += 'a=recvonly\r\n';
    } else {
      sdp += 'a=inactive\r\n';
    }

    if (transceiver.rtpSender) {
      var trackId = transceiver.rtpSender._initialTrackId ||
          transceiver.rtpSender.track.id;
      transceiver.rtpSender._initialTrackId = trackId;
      // spec.
      var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +
          trackId + '\r\n';
      sdp += 'a=' + msid;
      // for Chrome. Legacy should no longer be required.
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
          ' ' + msid;

      // RTX
      if (transceiver.sendEncodingParameters[0].rtx) {
        sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
            ' ' + msid;
        sdp += 'a=ssrc-group:FID ' +
            transceiver.sendEncodingParameters[0].ssrc + ' ' +
            transceiver.sendEncodingParameters[0].rtx.ssrc +
            '\r\n';
      }
    }
    // FIXME: this should be written by writeRtpDescription.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
    if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' cname:' + SDPUtils.localCName + '\r\n';
    }
    return sdp;
  }

  // Edge does not like
  // 1) stun: filtered after 14393 unless ?transport=udp is present
  // 2) turn: that does not have all of turn:host:port?transport=udp
  // 3) turn: with ipv6 addresses
  // 4) turn: occurring muliple times
  function filterIceServers(iceServers, edgeVersion) {
    var hasTurn = false;
    iceServers = JSON.parse(JSON.stringify(iceServers));
    return iceServers.filter(function(server) {
      if (server && (server.urls || server.url)) {
        var urls = server.urls || server.url;
        if (server.url && !server.urls) {
          console.warn('RTCIceServer.url is deprecated! Use urls instead.');
        }
        var isString = typeof urls === 'string';
        if (isString) {
          urls = [urls];
        }
        urls = urls.filter(function(url) {
          var validTurn = url.indexOf('turn:') === 0 &&
              url.indexOf('transport=udp') !== -1 &&
              url.indexOf('turn:[') === -1 &&
              !hasTurn;

          if (validTurn) {
            hasTurn = true;
            return true;
          }
          return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
              url.indexOf('?transport=udp') === -1;
        });

        delete server.url;
        server.urls = isString ? urls[0] : urls;
        return !!urls.length;
      }
    });
  }

  // Determines the intersection of local and remote capabilities.
  function getCommonCapabilities(localCapabilities, remoteCapabilities) {
    var commonCapabilities = {
      codecs: [],
      headerExtensions: [],
      fecMechanisms: []
    };

    var findCodecByPayloadType = function(pt, codecs) {
      pt = parseInt(pt, 10);
      for (var i = 0; i < codecs.length; i++) {
        if (codecs[i].payloadType === pt ||
            codecs[i].preferredPayloadType === pt) {
          return codecs[i];
        }
      }
    };

    var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {
      var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
      var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
      return lCodec && rCodec &&
          lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
    };

    localCapabilities.codecs.forEach(function(lCodec) {
      for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
        var rCodec = remoteCapabilities.codecs[i];
        if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
            lCodec.clockRate === rCodec.clockRate) {
          if (lCodec.name.toLowerCase() === 'rtx' &&
              lCodec.parameters && rCodec.parameters.apt) {
            // for RTX we need to find the local rtx that has a apt
            // which points to the same local codec as the remote one.
            if (!rtxCapabilityMatches(lCodec, rCodec,
                localCapabilities.codecs, remoteCapabilities.codecs)) {
              continue;
            }
          }
          rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
          // number of channels is the highest common number of channels
          rCodec.numChannels = Math.min(lCodec.numChannels,
              rCodec.numChannels);
          // push rCodec so we reply with offerer payload type
          commonCapabilities.codecs.push(rCodec);

          // determine common feedback mechanisms
          rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
            for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
              if (lCodec.rtcpFeedback[j].type === fb.type &&
                  lCodec.rtcpFeedback[j].parameter === fb.parameter) {
                return true;
              }
            }
            return false;
          });
          // FIXME: also need to determine .parameters
          //  see https://github.com/openpeer/ortc/issues/569
          break;
        }
      }
    });

    localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
      for (var i = 0; i < remoteCapabilities.headerExtensions.length;
           i++) {
        var rHeaderExtension = remoteCapabilities.headerExtensions[i];
        if (lHeaderExtension.uri === rHeaderExtension.uri) {
          commonCapabilities.headerExtensions.push(rHeaderExtension);
          break;
        }
      }
    });

    // FIXME: fecMechanisms
    return commonCapabilities;
  }

  // is action=setLocalDescription with type allowed in signalingState
  function isActionAllowedInSignalingState(action, type, signalingState) {
    return {
      offer: {
        setLocalDescription: ['stable', 'have-local-offer'],
        setRemoteDescription: ['stable', 'have-remote-offer']
      },
      answer: {
        setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
        setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']
      }
    }[type][action].indexOf(signalingState) !== -1;
  }

  function maybeAddCandidate(iceTransport, candidate) {
    // Edge's internal representation adds some fields therefore
    // not all field are taken into account.
    var alreadyAdded = iceTransport.getRemoteCandidates()
        .find(function(remoteCandidate) {
          return candidate.foundation === remoteCandidate.foundation &&
              candidate.ip === remoteCandidate.ip &&
              candidate.port === remoteCandidate.port &&
              candidate.priority === remoteCandidate.priority &&
              candidate.protocol === remoteCandidate.protocol &&
              candidate.type === remoteCandidate.type;
        });
    if (!alreadyAdded) {
      iceTransport.addRemoteCandidate(candidate);
    }
    return !alreadyAdded;
  }


  function makeError(name, description) {
    var e = new Error(description);
    e.name = name;
    // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names
    e.code = {
      NotSupportedError: 9,
      InvalidStateError: 11,
      InvalidAccessError: 15,
      TypeError: undefined,
      OperationError: undefined
    }[name];
    return e;
  }

  module.exports = function(window, edgeVersion) {
    // https://w3c.github.io/mediacapture-main/#mediastream
    // Helper function to add the track to the stream and
    // dispatch the event ourselves.
    function addTrackToStreamAndFireEvent(track, stream) {
      stream.addTrack(track);
      stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',
          {track: track}));
    }

    function removeTrackFromStreamAndFireEvent(track, stream) {
      stream.removeTrack(track);
      stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',
          {track: track}));
    }

    function fireAddTrack(pc, track, receiver, streams) {
      var trackEvent = new Event('track');
      trackEvent.track = track;
      trackEvent.receiver = receiver;
      trackEvent.transceiver = {receiver: receiver};
      trackEvent.streams = streams;
      window.setTimeout(function() {
        pc._dispatchEvent('track', trackEvent);
      });
    }

    var RTCPeerConnection = function(config) {
      var pc = this;

      var _eventTarget = document.createDocumentFragment();
      ['addEventListener', 'removeEventListener', 'dispatchEvent']
          .forEach(function(method) {
            pc[method] = _eventTarget[method].bind(_eventTarget);
          });

      this.canTrickleIceCandidates = null;

      this.needNegotiation = false;

      this.localStreams = [];
      this.remoteStreams = [];

      this._localDescription = null;
      this._remoteDescription = null;

      this.signalingState = 'stable';
      this.iceConnectionState = 'new';
      this.connectionState = 'new';
      this.iceGatheringState = 'new';

      config = JSON.parse(JSON.stringify(config || {}));

      this.usingBundle = config.bundlePolicy === 'max-bundle';
      if (config.rtcpMuxPolicy === 'negotiate') {
        throw(makeError('NotSupportedError',
            'rtcpMuxPolicy \'negotiate\' is not supported'));
      } else if (!config.rtcpMuxPolicy) {
        config.rtcpMuxPolicy = 'require';
      }

      switch (config.iceTransportPolicy) {
        case 'all':
        case 'relay':
          break;
        default:
          config.iceTransportPolicy = 'all';
          break;
      }

      switch (config.bundlePolicy) {
        case 'balanced':
        case 'max-compat':
        case 'max-bundle':
          break;
        default:
          config.bundlePolicy = 'balanced';
          break;
      }

      config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);

      this._iceGatherers = [];
      if (config.iceCandidatePoolSize) {
        for (var i = config.iceCandidatePoolSize; i > 0; i--) {
          this._iceGatherers.push(new window.RTCIceGatherer({
            iceServers: config.iceServers,
            gatherPolicy: config.iceTransportPolicy
          }));
        }
      } else {
        config.iceCandidatePoolSize = 0;
      }

      this._config = config;

      // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
      // everything that is needed to describe a SDP m-line.
      this.transceivers = [];

      this._sdpSessionId = SDPUtils.generateSessionId();
      this._sdpSessionVersion = 0;

      this._dtlsRole = undefined; // role for a=setup to use in answers.

      this._isClosed = false;
    };

    Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {
      configurable: true,
      get: function() {
        return this._localDescription;
      }
    });
    Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {
      configurable: true,
      get: function() {
        return this._remoteDescription;
      }
    });

    // set up event handlers on prototype
    RTCPeerConnection.prototype.onicecandidate = null;
    RTCPeerConnection.prototype.onaddstream = null;
    RTCPeerConnection.prototype.ontrack = null;
    RTCPeerConnection.prototype.onremovestream = null;
    RTCPeerConnection.prototype.onsignalingstatechange = null;
    RTCPeerConnection.prototype.oniceconnectionstatechange = null;
    RTCPeerConnection.prototype.onconnectionstatechange = null;
    RTCPeerConnection.prototype.onicegatheringstatechange = null;
    RTCPeerConnection.prototype.onnegotiationneeded = null;
    RTCPeerConnection.prototype.ondatachannel = null;

    RTCPeerConnection.prototype._dispatchEvent = function(name, event) {
      if (this._isClosed) {
        return;
      }
      this.dispatchEvent(event);
      if (typeof this['on' + name] === 'function') {
        this['on' + name](event);
      }
    };

    RTCPeerConnection.prototype._emitGatheringStateChange = function() {
      var event = new Event('icegatheringstatechange');
      this._dispatchEvent('icegatheringstatechange', event);
    };

    RTCPeerConnection.prototype.getConfiguration = function() {
      return this._config;
    };

    RTCPeerConnection.prototype.getLocalStreams = function() {
      return this.localStreams;
    };

    RTCPeerConnection.prototype.getRemoteStreams = function() {
      return this.remoteStreams;
    };

    // internal helper to create a transceiver object.
    // (which is not yet the same as the WebRTC 1.0 transceiver)
    RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {
      var hasBundleTransport = this.transceivers.length > 0;
      var transceiver = {
        track: null,
        iceGatherer: null,
        iceTransport: null,
        dtlsTransport: null,
        localCapabilities: null,
        remoteCapabilities: null,
        rtpSender: null,
        rtpReceiver: null,
        kind: kind,
        mid: null,
        sendEncodingParameters: null,
        recvEncodingParameters: null,
        stream: null,
        associatedRemoteMediaStreams: [],
        wantReceive: true
      };
      if (this.usingBundle && hasBundleTransport) {
        transceiver.iceTransport = this.transceivers[0].iceTransport;
        transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
      } else {
        var transports = this._createIceAndDtlsTransports();
        transceiver.iceTransport = transports.iceTransport;
        transceiver.dtlsTransport = transports.dtlsTransport;
      }
      if (!doNotAdd) {
        this.transceivers.push(transceiver);
      }
      return transceiver;
    };

    RTCPeerConnection.prototype.addTrack = function(track, stream) {
      if (this._isClosed) {
        throw makeError('InvalidStateError',
            'Attempted to call addTrack on a closed peerconnection.');
      }

      var alreadyExists = this.transceivers.find(function(s) {
        return s.track === track;
      });

      if (alreadyExists) {
        throw makeError('InvalidAccessError', 'Track already exists.');
      }

      var transceiver;
      for (var i = 0; i < this.transceivers.length; i++) {
        if (!this.transceivers[i].track &&
            this.transceivers[i].kind === track.kind) {
          transceiver = this.transceivers[i];
        }
      }
      if (!transceiver) {
        transceiver = this._createTransceiver(track.kind);
      }

      this._maybeFireNegotiationNeeded();

      if (this.localStreams.indexOf(stream) === -1) {
        this.localStreams.push(stream);
      }

      transceiver.track = track;
      transceiver.stream = stream;
      transceiver.rtpSender = new window.RTCRtpSender(track,
          transceiver.dtlsTransport);
      return transceiver.rtpSender;
    };

    RTCPeerConnection.prototype.addStream = function(stream) {
      var pc = this;
      if (edgeVersion >= 15025) {
        stream.getTracks().forEach(function(track) {
          pc.addTrack(track, stream);
        });
      } else {
        // Clone is necessary for local demos mostly, attaching directly
        // to two different senders does not work (build 10547).
        // Fixed in 15025 (or earlier)
        var clonedStream = stream.clone();
        stream.getTracks().forEach(function(track, idx) {
          var clonedTrack = clonedStream.getTracks()[idx];
          track.addEventListener('enabled', function(event) {
            clonedTrack.enabled = event.enabled;
          });
        });
        clonedStream.getTracks().forEach(function(track) {
          pc.addTrack(track, clonedStream);
        });
      }
    };

    RTCPeerConnection.prototype.removeTrack = function(sender) {
      if (this._isClosed) {
        throw makeError('InvalidStateError',
            'Attempted to call removeTrack on a closed peerconnection.');
      }

      if (!(sender instanceof window.RTCRtpSender)) {
        throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +
            'does not implement interface RTCRtpSender.');
      }

      var transceiver = this.transceivers.find(function(t) {
        return t.rtpSender === sender;
      });

      if (!transceiver) {
        throw makeError('InvalidAccessError',
            'Sender was not created by this connection.');
      }
      var stream = transceiver.stream;

      transceiver.rtpSender.stop();
      transceiver.rtpSender = null;
      transceiver.track = null;
      transceiver.stream = null;

      // remove the stream from the set of local streams
      var localStreams = this.transceivers.map(function(t) {
        return t.stream;
      });
      if (localStreams.indexOf(stream) === -1 &&
          this.localStreams.indexOf(stream) > -1) {
        this.localStreams.splice(this.localStreams.indexOf(stream), 1);
      }

      this._maybeFireNegotiationNeeded();
    };

    RTCPeerConnection.prototype.removeStream = function(stream) {
      var pc = this;
      stream.getTracks().forEach(function(track) {
        var sender = pc.getSenders().find(function(s) {
          return s.track === track;
        });
        if (sender) {
          pc.removeTrack(sender);
        }
      });
    };

    RTCPeerConnection.prototype.getSenders = function() {
      return this.transceivers.filter(function(transceiver) {
        return !!transceiver.rtpSender;
      })
      .map(function(transceiver) {
        return transceiver.rtpSender;
      });
    };

    RTCPeerConnection.prototype.getReceivers = function() {
      return this.transceivers.filter(function(transceiver) {
        return !!transceiver.rtpReceiver;
      })
      .map(function(transceiver) {
        return transceiver.rtpReceiver;
      });
    };


    RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,
        usingBundle) {
      var pc = this;
      if (usingBundle && sdpMLineIndex > 0) {
        return this.transceivers[0].iceGatherer;
      } else if (this._iceGatherers.length) {
        return this._iceGatherers.shift();
      }
      var iceGatherer = new window.RTCIceGatherer({
        iceServers: this._config.iceServers,
        gatherPolicy: this._config.iceTransportPolicy
      });
      Object.defineProperty(iceGatherer, 'state',
          {value: 'new', writable: true}
      );

      this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
      this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {
        var end = !event.candidate || Object.keys(event.candidate).length === 0;
        // polyfill since RTCIceGatherer.state is not implemented in
        // Edge 10547 yet.
        iceGatherer.state = end ? 'completed' : 'gathering';
        if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {
          pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
        }
      };
      iceGatherer.addEventListener('localcandidate',
        this.transceivers[sdpMLineIndex].bufferCandidates);
      return iceGatherer;
    };

    // start gathering from an RTCIceGatherer.
    RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {
      var pc = this;
      var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
      if (iceGatherer.onlocalcandidate) {
        return;
      }
      var bufferedCandidateEvents =
        this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
      this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
      iceGatherer.removeEventListener('localcandidate',
        this.transceivers[sdpMLineIndex].bufferCandidates);
      iceGatherer.onlocalcandidate = function(evt) {
        if (pc.usingBundle && sdpMLineIndex > 0) {
          // if we know that we use bundle we can drop candidates with
          // dpMLineIndex > 0. If we don't do this then our state gets
          // confused since we dispose the extra ice gatherer.
          return;
        }
        var event = new Event('icecandidate');
        event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

        var cand = evt.candidate;
        // Edge emits an empty object for RTCIceCandidateComplete
        var end = !cand || Object.keys(cand).length === 0;
        if (end) {
          // polyfill since RTCIceGatherer.state is not implemented in
          // Edge 10547 yet.
          if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
            iceGatherer.state = 'completed';
          }
        } else {
          if (iceGatherer.state === 'new') {
            iceGatherer.state = 'gathering';
          }
          // RTCIceCandidate doesn't have a component, needs to be added
          cand.component = 1;
          // also the usernameFragment. TODO: update SDP to take both variants.
          cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;

          var serializedCandidate = SDPUtils.writeCandidate(cand);
          event.candidate = Object.assign(event.candidate,
              SDPUtils.parseCandidate(serializedCandidate));

          event.candidate.candidate = serializedCandidate;
          event.candidate.toJSON = function() {
            return {
              candidate: event.candidate.candidate,
              sdpMid: event.candidate.sdpMid,
              sdpMLineIndex: event.candidate.sdpMLineIndex,
              usernameFragment: event.candidate.usernameFragment
            };
          };
        }

        // update local description.
        var sections = SDPUtils.getMediaSections(pc._localDescription.sdp);
        if (!end) {
          sections[event.candidate.sdpMLineIndex] +=
              'a=' + event.candidate.candidate + '\r\n';
        } else {
          sections[event.candidate.sdpMLineIndex] +=
              'a=end-of-candidates\r\n';
        }
        pc._localDescription.sdp =
            SDPUtils.getDescription(pc._localDescription.sdp) +
            sections.join('');
        var complete = pc.transceivers.every(function(transceiver) {
          return transceiver.iceGatherer &&
              transceiver.iceGatherer.state === 'completed';
        });

        if (pc.iceGatheringState !== 'gathering') {
          pc.iceGatheringState = 'gathering';
          pc._emitGatheringStateChange();
        }

        // Emit candidate. Also emit null candidate when all gatherers are
        // complete.
        if (!end) {
          pc._dispatchEvent('icecandidate', event);
        }
        if (complete) {
          pc._dispatchEvent('icecandidate', new Event('icecandidate'));
          pc.iceGatheringState = 'complete';
          pc._emitGatheringStateChange();
        }
      };

      // emit already gathered candidates.
      window.setTimeout(function() {
        bufferedCandidateEvents.forEach(function(e) {
          iceGatherer.onlocalcandidate(e);
        });
      }, 0);
    };

    // Create ICE transport and DTLS transport.
    RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {
      var pc = this;
      var iceTransport = new window.RTCIceTransport(null);
      iceTransport.onicestatechange = function() {
        pc._updateIceConnectionState();
        pc._updateConnectionState();
      };

      var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
      dtlsTransport.ondtlsstatechange = function() {
        pc._updateConnectionState();
      };
      dtlsTransport.onerror = function() {
        // onerror does not set state to failed by itself.
        Object.defineProperty(dtlsTransport, 'state',
            {value: 'failed', writable: true});
        pc._updateConnectionState();
      };

      return {
        iceTransport: iceTransport,
        dtlsTransport: dtlsTransport
      };
    };

    // Destroy ICE gatherer, ICE transport and DTLS transport.
    // Without triggering the callbacks.
    RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(
        sdpMLineIndex) {
      var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
      if (iceGatherer) {
        delete iceGatherer.onlocalcandidate;
        delete this.transceivers[sdpMLineIndex].iceGatherer;
      }
      var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
      if (iceTransport) {
        delete iceTransport.onicestatechange;
        delete this.transceivers[sdpMLineIndex].iceTransport;
      }
      var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
      if (dtlsTransport) {
        delete dtlsTransport.ondtlsstatechange;
        delete dtlsTransport.onerror;
        delete this.transceivers[sdpMLineIndex].dtlsTransport;
      }
    };

    // Start the RTP Sender and Receiver for a transceiver.
    RTCPeerConnection.prototype._transceive = function(transceiver,
        send, recv) {
      var params = getCommonCapabilities(transceiver.localCapabilities,
          transceiver.remoteCapabilities);
      if (send && transceiver.rtpSender) {
        params.encodings = transceiver.sendEncodingParameters;
        params.rtcp = {
          cname: SDPUtils.localCName,
          compound: transceiver.rtcpParameters.compound
        };
        if (transceiver.recvEncodingParameters.length) {
          params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
        }
        transceiver.rtpSender.send(params);
      }
      if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
        // remove RTX field in Edge 14942
        if (transceiver.kind === 'video'
            && transceiver.recvEncodingParameters
            && edgeVersion < 15019) {
          transceiver.recvEncodingParameters.forEach(function(p) {
            delete p.rtx;
          });
        }
        if (transceiver.recvEncodingParameters.length) {
          params.encodings = transceiver.recvEncodingParameters;
        } else {
          params.encodings = [{}];
        }
        params.rtcp = {
          compound: transceiver.rtcpParameters.compound
        };
        if (transceiver.rtcpParameters.cname) {
          params.rtcp.cname = transceiver.rtcpParameters.cname;
        }
        if (transceiver.sendEncodingParameters.length) {
          params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
        }
        transceiver.rtpReceiver.receive(params);
      }
    };

    RTCPeerConnection.prototype.setLocalDescription = function(description) {
      var pc = this;

      // Note: pranswer is not supported.
      if (['offer', 'answer'].indexOf(description.type) === -1) {
        return Promise.reject(makeError('TypeError',
            'Unsupported type "' + description.type + '"'));
      }

      if (!isActionAllowedInSignalingState('setLocalDescription',
          description.type, pc.signalingState) || pc._isClosed) {
        return Promise.reject(makeError('InvalidStateError',
            'Can not set local ' + description.type +
            ' in state ' + pc.signalingState));
      }

      var sections;
      var sessionpart;
      if (description.type === 'offer') {
        // VERY limited support for SDP munging. Limited to:
        // * changing the order of codecs
        sections = SDPUtils.splitSections(description.sdp);
        sessionpart = sections.shift();
        sections.forEach(function(mediaSection, sdpMLineIndex) {
          var caps = SDPUtils.parseRtpParameters(mediaSection);
          pc.transceivers[sdpMLineIndex].localCapabilities = caps;
        });

        pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
          pc._gather(transceiver.mid, sdpMLineIndex);
        });
      } else if (description.type === 'answer') {
        sections = SDPUtils.splitSections(pc._remoteDescription.sdp);
        sessionpart = sections.shift();
        var isIceLite = SDPUtils.matchPrefix(sessionpart,
            'a=ice-lite').length > 0;
        sections.forEach(function(mediaSection, sdpMLineIndex) {
          var transceiver = pc.transceivers[sdpMLineIndex];
          var iceGatherer = transceiver.iceGatherer;
          var iceTransport = transceiver.iceTransport;
          var dtlsTransport = transceiver.dtlsTransport;
          var localCapabilities = transceiver.localCapabilities;
          var remoteCapabilities = transceiver.remoteCapabilities;

          // treat bundle-only as not-rejected.
          var rejected = SDPUtils.isRejected(mediaSection) &&
              SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;

          if (!rejected && !transceiver.rejected) {
            var remoteIceParameters = SDPUtils.getIceParameters(
                mediaSection, sessionpart);
            var remoteDtlsParameters = SDPUtils.getDtlsParameters(
                mediaSection, sessionpart);
            if (isIceLite) {
              remoteDtlsParameters.role = 'server';
            }

            if (!pc.usingBundle || sdpMLineIndex === 0) {
              pc._gather(transceiver.mid, sdpMLineIndex);
              if (iceTransport.state === 'new') {
                iceTransport.start(iceGatherer, remoteIceParameters,
                    isIceLite ? 'controlling' : 'controlled');
              }
              if (dtlsTransport.state === 'new') {
                dtlsTransport.start(remoteDtlsParameters);
              }
            }

            // Calculate intersection of capabilities.
            var params = getCommonCapabilities(localCapabilities,
                remoteCapabilities);

            // Start the RTCRtpSender. The RTCRtpReceiver for this
            // transceiver has already been started in setRemoteDescription.
            pc._transceive(transceiver,
                params.codecs.length > 0,
                false);
          }
        });
      }

      pc._localDescription = {
        type: description.type,
        sdp: description.sdp
      };
      if (description.type === 'offer') {
        pc._updateSignalingState('have-local-offer');
      } else {
        pc._updateSignalingState('stable');
      }

      return Promise.resolve();
    };

    RTCPeerConnection.prototype.setRemoteDescription = function(description) {
      var pc = this;

      // Note: pranswer is not supported.
      if (['offer', 'answer'].indexOf(description.type) === -1) {
        return Promise.reject(makeError('TypeError',
            'Unsupported type "' + description.type + '"'));
      }

      if (!isActionAllowedInSignalingState('setRemoteDescription',
          description.type, pc.signalingState) || pc._isClosed) {
        return Promise.reject(makeError('InvalidStateError',
            'Can not set remote ' + description.type +
            ' in state ' + pc.signalingState));
      }

      var streams = {};
      pc.remoteStreams.forEach(function(stream) {
        streams[stream.id] = stream;
      });
      var receiverList = [];
      var sections = SDPUtils.splitSections(description.sdp);
      var sessionpart = sections.shift();
      var isIceLite = SDPUtils.matchPrefix(sessionpart,
          'a=ice-lite').length > 0;
      var usingBundle = SDPUtils.matchPrefix(sessionpart,
          'a=group:BUNDLE ').length > 0;
      pc.usingBundle = usingBundle;
      var iceOptions = SDPUtils.matchPrefix(sessionpart,
          'a=ice-options:')[0];
      if (iceOptions) {
        pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')
            .indexOf('trickle') >= 0;
      } else {
        pc.canTrickleIceCandidates = false;
      }

      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var lines = SDPUtils.splitLines(mediaSection);
        var kind = SDPUtils.getKind(mediaSection);
        // treat bundle-only as not-rejected.
        var rejected = SDPUtils.isRejected(mediaSection) &&
            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
        var protocol = lines[0].substr(2).split(' ')[2];

        var direction = SDPUtils.getDirection(mediaSection, sessionpart);
        var remoteMsid = SDPUtils.parseMsid(mediaSection);

        var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();

        // Reject datachannels which are not implemented yet.
        if (rejected || (kind === 'application' && (protocol === 'DTLS/SCTP' ||
            protocol === 'UDP/DTLS/SCTP'))) {
          // TODO: this is dangerous in the case where a non-rejected m-line
          //     becomes rejected.
          pc.transceivers[sdpMLineIndex] = {
            mid: mid,
            kind: kind,
            protocol: protocol,
            rejected: true
          };
          return;
        }

        if (!rejected && pc.transceivers[sdpMLineIndex] &&
            pc.transceivers[sdpMLineIndex].rejected) {
          // recycle a rejected transceiver.
          pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
        }

        var transceiver;
        var iceGatherer;
        var iceTransport;
        var dtlsTransport;
        var rtpReceiver;
        var sendEncodingParameters;
        var recvEncodingParameters;
        var localCapabilities;

        var track;
        // FIXME: ensure the mediaSection has rtcp-mux set.
        var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
        var remoteIceParameters;
        var remoteDtlsParameters;
        if (!rejected) {
          remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
              sessionpart);
          remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
              sessionpart);
          remoteDtlsParameters.role = 'client';
        }
        recvEncodingParameters =
            SDPUtils.parseRtpEncodingParameters(mediaSection);

        var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);

        var isComplete = SDPUtils.matchPrefix(mediaSection,
            'a=end-of-candidates', sessionpart).length > 0;
        var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
            .map(function(cand) {
              return SDPUtils.parseCandidate(cand);
            })
            .filter(function(cand) {
              return cand.component === 1;
            });

        // Check if we can use BUNDLE and dispose transports.
        if ((description.type === 'offer' || description.type === 'answer') &&
            !rejected && usingBundle && sdpMLineIndex > 0 &&
            pc.transceivers[sdpMLineIndex]) {
          pc._disposeIceAndDtlsTransports(sdpMLineIndex);
          pc.transceivers[sdpMLineIndex].iceGatherer =
              pc.transceivers[0].iceGatherer;
          pc.transceivers[sdpMLineIndex].iceTransport =
              pc.transceivers[0].iceTransport;
          pc.transceivers[sdpMLineIndex].dtlsTransport =
              pc.transceivers[0].dtlsTransport;
          if (pc.transceivers[sdpMLineIndex].rtpSender) {
            pc.transceivers[sdpMLineIndex].rtpSender.setTransport(
                pc.transceivers[0].dtlsTransport);
          }
          if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
            pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(
                pc.transceivers[0].dtlsTransport);
          }
        }
        if (description.type === 'offer' && !rejected) {
          transceiver = pc.transceivers[sdpMLineIndex] ||
              pc._createTransceiver(kind);
          transceiver.mid = mid;

          if (!transceiver.iceGatherer) {
            transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
                usingBundle);
          }

          if (cands.length && transceiver.iceTransport.state === 'new') {
            if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
              transceiver.iceTransport.setRemoteCandidates(cands);
            } else {
              cands.forEach(function(candidate) {
                maybeAddCandidate(transceiver.iceTransport, candidate);
              });
            }
          }

          localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

          // filter RTX until additional stuff needed for RTX is implemented
          // in adapter.js
          if (edgeVersion < 15019) {
            localCapabilities.codecs = localCapabilities.codecs.filter(
                function(codec) {
                  return codec.name !== 'rtx';
                });
          }

          sendEncodingParameters = transceiver.sendEncodingParameters || [{
            ssrc: (2 * sdpMLineIndex + 2) * 1001
          }];

          // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
          var isNewTrack = false;
          if (direction === 'sendrecv' || direction === 'sendonly') {
            isNewTrack = !transceiver.rtpReceiver;
            rtpReceiver = transceiver.rtpReceiver ||
                new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);

            if (isNewTrack) {
              var stream;
              track = rtpReceiver.track;
              // FIXME: does not work with Plan B.
              if (remoteMsid && remoteMsid.stream === '-') {
                // no-op. a stream id of '-' means: no associated stream.
              } else if (remoteMsid) {
                if (!streams[remoteMsid.stream]) {
                  streams[remoteMsid.stream] = new window.MediaStream();
                  Object.defineProperty(streams[remoteMsid.stream], 'id', {
                    get: function() {
                      return remoteMsid.stream;
                    }
                  });
                }
                Object.defineProperty(track, 'id', {
                  get: function() {
                    return remoteMsid.track;
                  }
                });
                stream = streams[remoteMsid.stream];
              } else {
                if (!streams.default) {
                  streams.default = new window.MediaStream();
                }
                stream = streams.default;
              }
              if (stream) {
                addTrackToStreamAndFireEvent(track, stream);
                transceiver.associatedRemoteMediaStreams.push(stream);
              }
              receiverList.push([track, rtpReceiver, stream]);
            }
          } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
            transceiver.associatedRemoteMediaStreams.forEach(function(s) {
              var nativeTrack = s.getTracks().find(function(t) {
                return t.id === transceiver.rtpReceiver.track.id;
              });
              if (nativeTrack) {
                removeTrackFromStreamAndFireEvent(nativeTrack, s);
              }
            });
            transceiver.associatedRemoteMediaStreams = [];
          }

          transceiver.localCapabilities = localCapabilities;
          transceiver.remoteCapabilities = remoteCapabilities;
          transceiver.rtpReceiver = rtpReceiver;
          transceiver.rtcpParameters = rtcpParameters;
          transceiver.sendEncodingParameters = sendEncodingParameters;
          transceiver.recvEncodingParameters = recvEncodingParameters;

          // Start the RTCRtpReceiver now. The RTPSender is started in
          // setLocalDescription.
          pc._transceive(pc.transceivers[sdpMLineIndex],
              false,
              isNewTrack);
        } else if (description.type === 'answer' && !rejected) {
          transceiver = pc.transceivers[sdpMLineIndex];
          iceGatherer = transceiver.iceGatherer;
          iceTransport = transceiver.iceTransport;
          dtlsTransport = transceiver.dtlsTransport;
          rtpReceiver = transceiver.rtpReceiver;
          sendEncodingParameters = transceiver.sendEncodingParameters;
          localCapabilities = transceiver.localCapabilities;

          pc.transceivers[sdpMLineIndex].recvEncodingParameters =
              recvEncodingParameters;
          pc.transceivers[sdpMLineIndex].remoteCapabilities =
              remoteCapabilities;
          pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

          if (cands.length && iceTransport.state === 'new') {
            if ((isIceLite || isComplete) &&
                (!usingBundle || sdpMLineIndex === 0)) {
              iceTransport.setRemoteCandidates(cands);
            } else {
              cands.forEach(function(candidate) {
                maybeAddCandidate(transceiver.iceTransport, candidate);
              });
            }
          }

          if (!usingBundle || sdpMLineIndex === 0) {
            if (iceTransport.state === 'new') {
              iceTransport.start(iceGatherer, remoteIceParameters,
                  'controlling');
            }
            if (dtlsTransport.state === 'new') {
              dtlsTransport.start(remoteDtlsParameters);
            }
          }

          // If the offer contained RTX but the answer did not,
          // remove RTX from sendEncodingParameters.
          var commonCapabilities = getCommonCapabilities(
            transceiver.localCapabilities,
            transceiver.remoteCapabilities);

          var hasRtx = commonCapabilities.codecs.filter(function(c) {
            return c.name.toLowerCase() === 'rtx';
          }).length;
          if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
            delete transceiver.sendEncodingParameters[0].rtx;
          }

          pc._transceive(transceiver,
              direction === 'sendrecv' || direction === 'recvonly',
              direction === 'sendrecv' || direction === 'sendonly');

          // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
          if (rtpReceiver &&
              (direction === 'sendrecv' || direction === 'sendonly')) {
            track = rtpReceiver.track;
            if (remoteMsid) {
              if (!streams[remoteMsid.stream]) {
                streams[remoteMsid.stream] = new window.MediaStream();
              }
              addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
              receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
            } else {
              if (!streams.default) {
                streams.default = new window.MediaStream();
              }
              addTrackToStreamAndFireEvent(track, streams.default);
              receiverList.push([track, rtpReceiver, streams.default]);
            }
          } else {
            // FIXME: actually the receiver should be created later.
            delete transceiver.rtpReceiver;
          }
        }
      });

      if (pc._dtlsRole === undefined) {
        pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
      }

      pc._remoteDescription = {
        type: description.type,
        sdp: description.sdp
      };
      if (description.type === 'offer') {
        pc._updateSignalingState('have-remote-offer');
      } else {
        pc._updateSignalingState('stable');
      }
      Object.keys(streams).forEach(function(sid) {
        var stream = streams[sid];
        if (stream.getTracks().length) {
          if (pc.remoteStreams.indexOf(stream) === -1) {
            pc.remoteStreams.push(stream);
            var event = new Event('addstream');
            event.stream = stream;
            window.setTimeout(function() {
              pc._dispatchEvent('addstream', event);
            });
          }

          receiverList.forEach(function(item) {
            var track = item[0];
            var receiver = item[1];
            if (stream.id !== item[2].id) {
              return;
            }
            fireAddTrack(pc, track, receiver, [stream]);
          });
        }
      });
      receiverList.forEach(function(item) {
        if (item[2]) {
          return;
        }
        fireAddTrack(pc, item[0], item[1], []);
      });

      // check whether addIceCandidate({}) was called within four seconds after
      // setRemoteDescription.
      window.setTimeout(function() {
        if (!(pc && pc.transceivers)) {
          return;
        }
        pc.transceivers.forEach(function(transceiver) {
          if (transceiver.iceTransport &&
              transceiver.iceTransport.state === 'new' &&
              transceiver.iceTransport.getRemoteCandidates().length > 0) {
            console.warn('Timeout for addRemoteCandidate. Consider sending ' +
                'an end-of-candidates notification');
            transceiver.iceTransport.addRemoteCandidate({});
          }
        });
      }, 4000);

      return Promise.resolve();
    };

    RTCPeerConnection.prototype.close = function() {
      this.transceivers.forEach(function(transceiver) {
        /* not yet
        if (transceiver.iceGatherer) {
          transceiver.iceGatherer.close();
        }
        */
        if (transceiver.iceTransport) {
          transceiver.iceTransport.stop();
        }
        if (transceiver.dtlsTransport) {
          transceiver.dtlsTransport.stop();
        }
        if (transceiver.rtpSender) {
          transceiver.rtpSender.stop();
        }
        if (transceiver.rtpReceiver) {
          transceiver.rtpReceiver.stop();
        }
      });
      // FIXME: clean up tracks, local streams, remote streams, etc
      this._isClosed = true;
      this._updateSignalingState('closed');
    };

    // Update the signaling state.
    RTCPeerConnection.prototype._updateSignalingState = function(newState) {
      this.signalingState = newState;
      var event = new Event('signalingstatechange');
      this._dispatchEvent('signalingstatechange', event);
    };

    // Determine whether to fire the negotiationneeded event.
    RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
      var pc = this;
      if (this.signalingState !== 'stable' || this.needNegotiation === true) {
        return;
      }
      this.needNegotiation = true;
      window.setTimeout(function() {
        if (pc.needNegotiation) {
          pc.needNegotiation = false;
          var event = new Event('negotiationneeded');
          pc._dispatchEvent('negotiationneeded', event);
        }
      }, 0);
    };

    // Update the ice connection state.
    RTCPeerConnection.prototype._updateIceConnectionState = function() {
      var newState;
      var states = {
        'new': 0,
        closed: 0,
        checking: 0,
        connected: 0,
        completed: 0,
        disconnected: 0,
        failed: 0
      };
      this.transceivers.forEach(function(transceiver) {
        if (transceiver.iceTransport && !transceiver.rejected) {
          states[transceiver.iceTransport.state]++;
        }
      });

      newState = 'new';
      if (states.failed > 0) {
        newState = 'failed';
      } else if (states.checking > 0) {
        newState = 'checking';
      } else if (states.disconnected > 0) {
        newState = 'disconnected';
      } else if (states.new > 0) {
        newState = 'new';
      } else if (states.connected > 0) {
        newState = 'connected';
      } else if (states.completed > 0) {
        newState = 'completed';
      }

      if (newState !== this.iceConnectionState) {
        this.iceConnectionState = newState;
        var event = new Event('iceconnectionstatechange');
        this._dispatchEvent('iceconnectionstatechange', event);
      }
    };

    // Update the connection state.
    RTCPeerConnection.prototype._updateConnectionState = function() {
      var newState;
      var states = {
        'new': 0,
        closed: 0,
        connecting: 0,
        connected: 0,
        completed: 0,
        disconnected: 0,
        failed: 0
      };
      this.transceivers.forEach(function(transceiver) {
        if (transceiver.iceTransport && transceiver.dtlsTransport &&
            !transceiver.rejected) {
          states[transceiver.iceTransport.state]++;
          states[transceiver.dtlsTransport.state]++;
        }
      });
      // ICETransport.completed and connected are the same for this purpose.
      states.connected += states.completed;

      newState = 'new';
      if (states.failed > 0) {
        newState = 'failed';
      } else if (states.connecting > 0) {
        newState = 'connecting';
      } else if (states.disconnected > 0) {
        newState = 'disconnected';
      } else if (states.new > 0) {
        newState = 'new';
      } else if (states.connected > 0) {
        newState = 'connected';
      }

      if (newState !== this.connectionState) {
        this.connectionState = newState;
        var event = new Event('connectionstatechange');
        this._dispatchEvent('connectionstatechange', event);
      }
    };

    RTCPeerConnection.prototype.createOffer = function() {
      var pc = this;

      if (pc._isClosed) {
        return Promise.reject(makeError('InvalidStateError',
            'Can not call createOffer after close'));
      }

      var numAudioTracks = pc.transceivers.filter(function(t) {
        return t.kind === 'audio';
      }).length;
      var numVideoTracks = pc.transceivers.filter(function(t) {
        return t.kind === 'video';
      }).length;

      // Determine number of audio and video tracks we need to send/recv.
      var offerOptions = arguments[0];
      if (offerOptions) {
        // Reject Chrome legacy constraints.
        if (offerOptions.mandatory || offerOptions.optional) {
          throw new TypeError(
              'Legacy mandatory/optional constraints not supported.');
        }
        if (offerOptions.offerToReceiveAudio !== undefined) {
          if (offerOptions.offerToReceiveAudio === true) {
            numAudioTracks = 1;
          } else if (offerOptions.offerToReceiveAudio === false) {
            numAudioTracks = 0;
          } else {
            numAudioTracks = offerOptions.offerToReceiveAudio;
          }
        }
        if (offerOptions.offerToReceiveVideo !== undefined) {
          if (offerOptions.offerToReceiveVideo === true) {
            numVideoTracks = 1;
          } else if (offerOptions.offerToReceiveVideo === false) {
            numVideoTracks = 0;
          } else {
            numVideoTracks = offerOptions.offerToReceiveVideo;
          }
        }
      }

      pc.transceivers.forEach(function(transceiver) {
        if (transceiver.kind === 'audio') {
          numAudioTracks--;
          if (numAudioTracks < 0) {
            transceiver.wantReceive = false;
          }
        } else if (transceiver.kind === 'video') {
          numVideoTracks--;
          if (numVideoTracks < 0) {
            transceiver.wantReceive = false;
          }
        }
      });

      // Create M-lines for recvonly streams.
      while (numAudioTracks > 0 || numVideoTracks > 0) {
        if (numAudioTracks > 0) {
          pc._createTransceiver('audio');
          numAudioTracks--;
        }
        if (numVideoTracks > 0) {
          pc._createTransceiver('video');
          numVideoTracks--;
        }
      }

      var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
          pc._sdpSessionVersion++);
      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
        // For each track, create an ice gatherer, ice transport,
        // dtls transport, potentially rtpsender and rtpreceiver.
        var track = transceiver.track;
        var kind = transceiver.kind;
        var mid = transceiver.mid || SDPUtils.generateIdentifier();
        transceiver.mid = mid;

        if (!transceiver.iceGatherer) {
          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
              pc.usingBundle);
        }

        var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
        // filter RTX until additional stuff needed for RTX is implemented
        // in adapter.js
        if (edgeVersion < 15019) {
          localCapabilities.codecs = localCapabilities.codecs.filter(
              function(codec) {
                return codec.name !== 'rtx';
              });
        }
        localCapabilities.codecs.forEach(function(codec) {
          // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
          // by adding level-asymmetry-allowed=1
          if (codec.name === 'H264' &&
              codec.parameters['level-asymmetry-allowed'] === undefined) {
            codec.parameters['level-asymmetry-allowed'] = '1';
          }

          // for subsequent offers, we might have to re-use the payload
          // type of the last offer.
          if (transceiver.remoteCapabilities &&
              transceiver.remoteCapabilities.codecs) {
            transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {
              if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&
                  codec.clockRate === remoteCodec.clockRate) {
                codec.preferredPayloadType = remoteCodec.payloadType;
              }
            });
          }
        });
        localCapabilities.headerExtensions.forEach(function(hdrExt) {
          var remoteExtensions = transceiver.remoteCapabilities &&
              transceiver.remoteCapabilities.headerExtensions || [];
          remoteExtensions.forEach(function(rHdrExt) {
            if (hdrExt.uri === rHdrExt.uri) {
              hdrExt.id = rHdrExt.id;
            }
          });
        });

        // generate an ssrc now, to be used later in rtpSender.send
        var sendEncodingParameters = transceiver.sendEncodingParameters || [{
          ssrc: (2 * sdpMLineIndex + 1) * 1001
        }];
        if (track) {
          // add RTX
          if (edgeVersion >= 15019 && kind === 'video' &&
              !sendEncodingParameters[0].rtx) {
            sendEncodingParameters[0].rtx = {
              ssrc: sendEncodingParameters[0].ssrc + 1
            };
          }
        }

        if (transceiver.wantReceive) {
          transceiver.rtpReceiver = new window.RTCRtpReceiver(
              transceiver.dtlsTransport, kind);
        }

        transceiver.localCapabilities = localCapabilities;
        transceiver.sendEncodingParameters = sendEncodingParameters;
      });

      // always offer BUNDLE and dispose on return if not supported.
      if (pc._config.bundlePolicy !== 'max-compat') {
        sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
          return t.mid;
        }).join(' ') + '\r\n';
      }
      sdp += 'a=ice-options:trickle\r\n';

      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
        sdp += writeMediaSection(transceiver, transceiver.localCapabilities,
            'offer', transceiver.stream, pc._dtlsRole);
        sdp += 'a=rtcp-rsize\r\n';

        if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&
            (sdpMLineIndex === 0 || !pc.usingBundle)) {
          transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {
            cand.component = 1;
            sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\r\n';
          });

          if (transceiver.iceGatherer.state === 'completed') {
            sdp += 'a=end-of-candidates\r\n';
          }
        }
      });

      var desc = new window.RTCSessionDescription({
        type: 'offer',
        sdp: sdp
      });
      return Promise.resolve(desc);
    };

    RTCPeerConnection.prototype.createAnswer = function() {
      var pc = this;

      if (pc._isClosed) {
        return Promise.reject(makeError('InvalidStateError',
            'Can not call createAnswer after close'));
      }

      if (!(pc.signalingState === 'have-remote-offer' ||
          pc.signalingState === 'have-local-pranswer')) {
        return Promise.reject(makeError('InvalidStateError',
            'Can not call createAnswer in signalingState ' + pc.signalingState));
      }

      var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
          pc._sdpSessionVersion++);
      if (pc.usingBundle) {
        sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
          return t.mid;
        }).join(' ') + '\r\n';
      }
      sdp += 'a=ice-options:trickle\r\n';

      var mediaSectionsInOffer = SDPUtils.getMediaSections(
          pc._remoteDescription.sdp).length;
      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
        if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
          return;
        }
        if (transceiver.rejected) {
          if (transceiver.kind === 'application') {
            if (transceiver.protocol === 'DTLS/SCTP') { // legacy fmt
              sdp += 'm=application 0 DTLS/SCTP 5000\r\n';
            } else {
              sdp += 'm=application 0 ' + transceiver.protocol +
                  ' webrtc-datachannel\r\n';
            }
          } else if (transceiver.kind === 'audio') {
            sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\r\n' +
                'a=rtpmap:0 PCMU/8000\r\n';
          } else if (transceiver.kind === 'video') {
            sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\r\n' +
                'a=rtpmap:120 VP8/90000\r\n';
          }
          sdp += 'c=IN IP4 0.0.0.0\r\n' +
              'a=inactive\r\n' +
              'a=mid:' + transceiver.mid + '\r\n';
          return;
        }

        // FIXME: look at direction.
        if (transceiver.stream) {
          var localTrack;
          if (transceiver.kind === 'audio') {
            localTrack = transceiver.stream.getAudioTracks()[0];
          } else if (transceiver.kind === 'video') {
            localTrack = transceiver.stream.getVideoTracks()[0];
          }
          if (localTrack) {
            // add RTX
            if (edgeVersion >= 15019 && transceiver.kind === 'video' &&
                !transceiver.sendEncodingParameters[0].rtx) {
              transceiver.sendEncodingParameters[0].rtx = {
                ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
              };
            }
          }
        }

        // Calculate intersection of capabilities.
        var commonCapabilities = getCommonCapabilities(
            transceiver.localCapabilities,
            transceiver.remoteCapabilities);

        var hasRtx = commonCapabilities.codecs.filter(function(c) {
          return c.name.toLowerCase() === 'rtx';
        }).length;
        if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
          delete transceiver.sendEncodingParameters[0].rtx;
        }

        sdp += writeMediaSection(transceiver, commonCapabilities,
            'answer', transceiver.stream, pc._dtlsRole);
        if (transceiver.rtcpParameters &&
            transceiver.rtcpParameters.reducedSize) {
          sdp += 'a=rtcp-rsize\r\n';
        }
      });

      var desc = new window.RTCSessionDescription({
        type: 'answer',
        sdp: sdp
      });
      return Promise.resolve(desc);
    };

    RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
      var pc = this;
      var sections;
      if (candidate && !(candidate.sdpMLineIndex !== undefined ||
          candidate.sdpMid)) {
        return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));
      }

      // TODO: needs to go into ops queue.
      return new Promise(function(resolve, reject) {
        if (!pc._remoteDescription) {
          return reject(makeError('InvalidStateError',
              'Can not add ICE candidate without a remote description'));
        } else if (!candidate || candidate.candidate === '') {
          for (var j = 0; j < pc.transceivers.length; j++) {
            if (pc.transceivers[j].rejected) {
              continue;
            }
            pc.transceivers[j].iceTransport.addRemoteCandidate({});
            sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
            sections[j] += 'a=end-of-candidates\r\n';
            pc._remoteDescription.sdp =
                SDPUtils.getDescription(pc._remoteDescription.sdp) +
                sections.join('');
            if (pc.usingBundle) {
              break;
            }
          }
        } else {
          var sdpMLineIndex = candidate.sdpMLineIndex;
          if (candidate.sdpMid) {
            for (var i = 0; i < pc.transceivers.length; i++) {
              if (pc.transceivers[i].mid === candidate.sdpMid) {
                sdpMLineIndex = i;
                break;
              }
            }
          }
          var transceiver = pc.transceivers[sdpMLineIndex];
          if (transceiver) {
            if (transceiver.rejected) {
              return resolve();
            }
            var cand = Object.keys(candidate.candidate).length > 0 ?
                SDPUtils.parseCandidate(candidate.candidate) : {};
            // Ignore Chrome's invalid candidates since Edge does not like them.
            if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
              return resolve();
            }
            // Ignore RTCP candidates, we assume RTCP-MUX.
            if (cand.component && cand.component !== 1) {
              return resolve();
            }
            // when using bundle, avoid adding candidates to the wrong
            // ice transport. And avoid adding candidates added in the SDP.
            if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&
                transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {
              if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
                return reject(makeError('OperationError',
                    'Can not add ICE candidate'));
              }
            }

            // update the remoteDescription.
            var candidateString = candidate.candidate.trim();
            if (candidateString.indexOf('a=') === 0) {
              candidateString = candidateString.substr(2);
            }
            sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
            sections[sdpMLineIndex] += 'a=' +
                (cand.type ? candidateString : 'end-of-candidates')
                + '\r\n';
            pc._remoteDescription.sdp =
                SDPUtils.getDescription(pc._remoteDescription.sdp) +
                sections.join('');
          } else {
            return reject(makeError('OperationError',
                'Can not add ICE candidate'));
          }
        }
        resolve();
      });
    };

    RTCPeerConnection.prototype.getStats = function(selector) {
      if (selector && selector instanceof window.MediaStreamTrack) {
        var senderOrReceiver = null;
        this.transceivers.forEach(function(transceiver) {
          if (transceiver.rtpSender &&
              transceiver.rtpSender.track === selector) {
            senderOrReceiver = transceiver.rtpSender;
          } else if (transceiver.rtpReceiver &&
              transceiver.rtpReceiver.track === selector) {
            senderOrReceiver = transceiver.rtpReceiver;
          }
        });
        if (!senderOrReceiver) {
          throw makeError('InvalidAccessError', 'Invalid selector.');
        }
        return senderOrReceiver.getStats();
      }

      var promises = [];
      this.transceivers.forEach(function(transceiver) {
        ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
            'dtlsTransport'].forEach(function(method) {
              if (transceiver[method]) {
                promises.push(transceiver[method].getStats());
              }
            });
      });
      return Promise.all(promises).then(function(allStats) {
        var results = new Map();
        allStats.forEach(function(stats) {
          stats.forEach(function(stat) {
            results.set(stat.id, stat);
          });
        });
        return results;
      });
    };

    // fix low-level stat names and return Map instead of object.
    var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',
      'RTCIceTransport', 'RTCDtlsTransport'];
    ortcObjects.forEach(function(ortcObjectName) {
      var obj = window[ortcObjectName];
      if (obj && obj.prototype && obj.prototype.getStats) {
        var nativeGetstats = obj.prototype.getStats;
        obj.prototype.getStats = function() {
          return nativeGetstats.apply(this)
          .then(function(nativeStats) {
            var mapStats = new Map();
            Object.keys(nativeStats).forEach(function(id) {
              nativeStats[id].type = fixStatsType(nativeStats[id]);
              mapStats.set(id, nativeStats[id]);
            });
            return mapStats;
          });
        };
      }
    });

    // legacy callback shims. Should be moved to adapter.js some days.
    var methods = ['createOffer', 'createAnswer'];
    methods.forEach(function(method) {
      var nativeMethod = RTCPeerConnection.prototype[method];
      RTCPeerConnection.prototype[method] = function() {
        var args = arguments;
        if (typeof args[0] === 'function' ||
            typeof args[1] === 'function') { // legacy
          return nativeMethod.apply(this, [arguments[2]])
          .then(function(description) {
            if (typeof args[0] === 'function') {
              args[0].apply(null, [description]);
            }
          }, function(error) {
            if (typeof args[1] === 'function') {
              args[1].apply(null, [error]);
            }
          });
        }
        return nativeMethod.apply(this, arguments);
      };
    });

    methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];
    methods.forEach(function(method) {
      var nativeMethod = RTCPeerConnection.prototype[method];
      RTCPeerConnection.prototype[method] = function() {
        var args = arguments;
        if (typeof args[1] === 'function' ||
            typeof args[2] === 'function') { // legacy
          return nativeMethod.apply(this, arguments)
          .then(function() {
            if (typeof args[1] === 'function') {
              args[1].apply(null);
            }
          }, function(error) {
            if (typeof args[2] === 'function') {
              args[2].apply(null, [error]);
            }
          });
        }
        return nativeMethod.apply(this, arguments);
      };
    });

    // getStats is special. It doesn't have a spec legacy method yet we support
    // getStats(something, cb) without error callbacks.
    ['getStats'].forEach(function(method) {
      var nativeMethod = RTCPeerConnection.prototype[method];
      RTCPeerConnection.prototype[method] = function() {
        var args = arguments;
        if (typeof args[1] === 'function') {
          return nativeMethod.apply(this, arguments)
          .then(function() {
            if (typeof args[1] === 'function') {
              args[1].apply(null);
            }
          });
        }
        return nativeMethod.apply(this, arguments);
      };
    });

    return RTCPeerConnection;
  };

  },{"sdp":17}],17:[function(require,module,exports){
   /* eslint-env node */
  'use strict';

  // SDP helpers.
  var SDPUtils = {};

  // Generate an alphanumeric identifier for cname or mids.
  // TODO: use UUIDs instead? https://gist.github.com/jed/982883
  SDPUtils.generateIdentifier = function() {
    return Math.random().toString(36).substr(2, 10);
  };

  // The RTCP CNAME used by all peerconnections from the same JS.
  SDPUtils.localCName = SDPUtils.generateIdentifier();

  // Splits SDP into lines, dealing with both CRLF and LF.
  SDPUtils.splitLines = function(blob) {
    return blob.trim().split('\n').map(function(line) {
      return line.trim();
    });
  };
  // Splits SDP into sessionpart and mediasections. Ensures CRLF.
  SDPUtils.splitSections = function(blob) {
    var parts = blob.split('\nm=');
    return parts.map(function(part, index) {
      return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
    });
  };

  // returns the session description.
  SDPUtils.getDescription = function(blob) {
    var sections = SDPUtils.splitSections(blob);
    return sections && sections[0];
  };

  // returns the individual media sections.
  SDPUtils.getMediaSections = function(blob) {
    var sections = SDPUtils.splitSections(blob);
    sections.shift();
    return sections;
  };

  // Returns lines that start with a certain prefix.
  SDPUtils.matchPrefix = function(blob, prefix) {
    return SDPUtils.splitLines(blob).filter(function(line) {
      return line.indexOf(prefix) === 0;
    });
  };

  // Parses an ICE candidate line. Sample input:
  // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
  // rport 55996"
  SDPUtils.parseCandidate = function(line) {
    var parts;
    // Parse both variants.
    if (line.indexOf('a=candidate:') === 0) {
      parts = line.substring(12).split(' ');
    } else {
      parts = line.substring(10).split(' ');
    }

    var candidate = {
      foundation: parts[0],
      component: parseInt(parts[1], 10),
      protocol: parts[2].toLowerCase(),
      priority: parseInt(parts[3], 10),
      ip: parts[4],
      address: parts[4], // address is an alias for ip.
      port: parseInt(parts[5], 10),
      // skip parts[6] == 'typ'
      type: parts[7]
    };

    for (var i = 8; i < parts.length; i += 2) {
      switch (parts[i]) {
        case 'raddr':
          candidate.relatedAddress = parts[i + 1];
          break;
        case 'rport':
          candidate.relatedPort = parseInt(parts[i + 1], 10);
          break;
        case 'tcptype':
          candidate.tcpType = parts[i + 1];
          break;
        case 'ufrag':
          candidate.ufrag = parts[i + 1]; // for backward compability.
          candidate.usernameFragment = parts[i + 1];
          break;
        default: // extension handling, in particular ufrag
          candidate[parts[i]] = parts[i + 1];
          break;
      }
    }
    return candidate;
  };

  // Translates a candidate object into SDP candidate attribute.
  SDPUtils.writeCandidate = function(candidate) {
    var sdp = [];
    sdp.push(candidate.foundation);
    sdp.push(candidate.component);
    sdp.push(candidate.protocol.toUpperCase());
    sdp.push(candidate.priority);
    sdp.push(candidate.address || candidate.ip);
    sdp.push(candidate.port);

    var type = candidate.type;
    sdp.push('typ');
    sdp.push(type);
    if (type !== 'host' && candidate.relatedAddress &&
        candidate.relatedPort) {
      sdp.push('raddr');
      sdp.push(candidate.relatedAddress);
      sdp.push('rport');
      sdp.push(candidate.relatedPort);
    }
    if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
      sdp.push('tcptype');
      sdp.push(candidate.tcpType);
    }
    if (candidate.usernameFragment || candidate.ufrag) {
      sdp.push('ufrag');
      sdp.push(candidate.usernameFragment || candidate.ufrag);
    }
    return 'candidate:' + sdp.join(' ');
  };

  // Parses an ice-options line, returns an array of option tags.
  // a=ice-options:foo bar
  SDPUtils.parseIceOptions = function(line) {
    return line.substr(14).split(' ');
  };

  // Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
  // a=rtpmap:111 opus/48000/2
  SDPUtils.parseRtpMap = function(line) {
    var parts = line.substr(9).split(' ');
    var parsed = {
      payloadType: parseInt(parts.shift(), 10) // was: id
    };

    parts = parts[0].split('/');

    parsed.name = parts[0];
    parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
    parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
    // legacy alias, got renamed back to channels in ORTC.
    parsed.numChannels = parsed.channels;
    return parsed;
  };

  // Generate an a=rtpmap line from RTCRtpCodecCapability or
  // RTCRtpCodecParameters.
  SDPUtils.writeRtpMap = function(codec) {
    var pt = codec.payloadType;
    if (codec.preferredPayloadType !== undefined) {
      pt = codec.preferredPayloadType;
    }
    var channels = codec.channels || codec.numChannels || 1;
    return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
        (channels !== 1 ? '/' + channels : '') + '\r\n';
  };

  // Parses an a=extmap line (headerextension from RFC 5285). Sample input:
  // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
  // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
  SDPUtils.parseExtmap = function(line) {
    var parts = line.substr(9).split(' ');
    return {
      id: parseInt(parts[0], 10),
      direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
      uri: parts[1]
    };
  };

  // Generates a=extmap line from RTCRtpHeaderExtensionParameters or
  // RTCRtpHeaderExtension.
  SDPUtils.writeExtmap = function(headerExtension) {
    return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
        (headerExtension.direction && headerExtension.direction !== 'sendrecv'
            ? '/' + headerExtension.direction
            : '') +
        ' ' + headerExtension.uri + '\r\n';
  };

  // Parses an ftmp line, returns dictionary. Sample input:
  // a=fmtp:96 vbr=on;cng=on
  // Also deals with vbr=on; cng=on
  SDPUtils.parseFmtp = function(line) {
    var parsed = {};
    var kv;
    var parts = line.substr(line.indexOf(' ') + 1).split(';');
    for (var j = 0; j < parts.length; j++) {
      kv = parts[j].trim().split('=');
      parsed[kv[0].trim()] = kv[1];
    }
    return parsed;
  };

  // Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
  SDPUtils.writeFmtp = function(codec) {
    var line = '';
    var pt = codec.payloadType;
    if (codec.preferredPayloadType !== undefined) {
      pt = codec.preferredPayloadType;
    }
    if (codec.parameters && Object.keys(codec.parameters).length) {
      var params = [];
      Object.keys(codec.parameters).forEach(function(param) {
        if (codec.parameters[param]) {
          params.push(param + '=' + codec.parameters[param]);
        } else {
          params.push(param);
        }
      });
      line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
    }
    return line;
  };

  // Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
  // a=rtcp-fb:98 nack rpsi
  SDPUtils.parseRtcpFb = function(line) {
    var parts = line.substr(line.indexOf(' ') + 1).split(' ');
    return {
      type: parts.shift(),
      parameter: parts.join(' ')
    };
  };
  // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
  SDPUtils.writeRtcpFb = function(codec) {
    var lines = '';
    var pt = codec.payloadType;
    if (codec.preferredPayloadType !== undefined) {
      pt = codec.preferredPayloadType;
    }
    if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
      // FIXME: special handling for trr-int?
      codec.rtcpFeedback.forEach(function(fb) {
        lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
        (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
            '\r\n';
      });
    }
    return lines;
  };

  // Parses an RFC 5576 ssrc media attribute. Sample input:
  // a=ssrc:3735928559 cname:something
  SDPUtils.parseSsrcMedia = function(line) {
    var sp = line.indexOf(' ');
    var parts = {
      ssrc: parseInt(line.substr(7, sp - 7), 10)
    };
    var colon = line.indexOf(':', sp);
    if (colon > -1) {
      parts.attribute = line.substr(sp + 1, colon - sp - 1);
      parts.value = line.substr(colon + 1);
    } else {
      parts.attribute = line.substr(sp + 1);
    }
    return parts;
  };

  SDPUtils.parseSsrcGroup = function(line) {
    var parts = line.substr(13).split(' ');
    return {
      semantics: parts.shift(),
      ssrcs: parts.map(function(ssrc) {
        return parseInt(ssrc, 10);
      })
    };
  };

  // Extracts the MID (RFC 5888) from a media section.
  // returns the MID or undefined if no mid line was found.
  SDPUtils.getMid = function(mediaSection) {
    var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
    if (mid) {
      return mid.substr(6);
    }
  };

  SDPUtils.parseFingerprint = function(line) {
    var parts = line.substr(14).split(' ');
    return {
      algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
      value: parts[1]
    };
  };

  // Extracts DTLS parameters from SDP media section or sessionpart.
  // FIXME: for consistency with other functions this should only
  //   get the fingerprint line as input. See also getIceParameters.
  SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
    var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
        'a=fingerprint:');
    // Note: a=setup line is ignored since we use the 'auto' role.
    // Note2: 'algorithm' is not case sensitive except in Edge.
    return {
      role: 'auto',
      fingerprints: lines.map(SDPUtils.parseFingerprint)
    };
  };

  // Serializes DTLS parameters to SDP.
  SDPUtils.writeDtlsParameters = function(params, setupType) {
    var sdp = 'a=setup:' + setupType + '\r\n';
    params.fingerprints.forEach(function(fp) {
      sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
    });
    return sdp;
  };
  // Parses ICE information from SDP media section or sessionpart.
  // FIXME: for consistency with other functions this should only
  //   get the ice-ufrag and ice-pwd lines as input.
  SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
    var lines = SDPUtils.splitLines(mediaSection);
    // Search in session part, too.
    lines = lines.concat(SDPUtils.splitLines(sessionpart));
    var iceParameters = {
      usernameFragment: lines.filter(function(line) {
        return line.indexOf('a=ice-ufrag:') === 0;
      })[0].substr(12),
      password: lines.filter(function(line) {
        return line.indexOf('a=ice-pwd:') === 0;
      })[0].substr(10)
    };
    return iceParameters;
  };

  // Serializes ICE parameters to SDP.
  SDPUtils.writeIceParameters = function(params) {
    return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
        'a=ice-pwd:' + params.password + '\r\n';
  };

  // Parses the SDP media section and returns RTCRtpParameters.
  SDPUtils.parseRtpParameters = function(mediaSection) {
    var description = {
      codecs: [],
      headerExtensions: [],
      fecMechanisms: [],
      rtcp: []
    };
    var lines = SDPUtils.splitLines(mediaSection);
    var mline = lines[0].split(' ');
    for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
      var pt = mline[i];
      var rtpmapline = SDPUtils.matchPrefix(
          mediaSection, 'a=rtpmap:' + pt + ' ')[0];
      if (rtpmapline) {
        var codec = SDPUtils.parseRtpMap(rtpmapline);
        var fmtps = SDPUtils.matchPrefix(
            mediaSection, 'a=fmtp:' + pt + ' ');
        // Only the first a=fmtp:<pt> is considered.
        codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
        codec.rtcpFeedback = SDPUtils.matchPrefix(
            mediaSection, 'a=rtcp-fb:' + pt + ' ')
          .map(SDPUtils.parseRtcpFb);
        description.codecs.push(codec);
        // parse FEC mechanisms from rtpmap lines.
        switch (codec.name.toUpperCase()) {
          case 'RED':
          case 'ULPFEC':
            description.fecMechanisms.push(codec.name.toUpperCase());
            break;
          default: // only RED and ULPFEC are recognized as FEC mechanisms.
            break;
        }
      }
    }
    SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
      description.headerExtensions.push(SDPUtils.parseExtmap(line));
    });
    // FIXME: parse rtcp.
    return description;
  };

  // Generates parts of the SDP media section describing the capabilities /
  // parameters.
  SDPUtils.writeRtpDescription = function(kind, caps) {
    var sdp = '';

    // Build the mline.
    sdp += 'm=' + kind + ' ';
    sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
    sdp += ' UDP/TLS/RTP/SAVPF ';
    sdp += caps.codecs.map(function(codec) {
      if (codec.preferredPayloadType !== undefined) {
        return codec.preferredPayloadType;
      }
      return codec.payloadType;
    }).join(' ') + '\r\n';

    sdp += 'c=IN IP4 0.0.0.0\r\n';
    sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

    // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
    caps.codecs.forEach(function(codec) {
      sdp += SDPUtils.writeRtpMap(codec);
      sdp += SDPUtils.writeFmtp(codec);
      sdp += SDPUtils.writeRtcpFb(codec);
    });
    var maxptime = 0;
    caps.codecs.forEach(function(codec) {
      if (codec.maxptime > maxptime) {
        maxptime = codec.maxptime;
      }
    });
    if (maxptime > 0) {
      sdp += 'a=maxptime:' + maxptime + '\r\n';
    }
    sdp += 'a=rtcp-mux\r\n';

    if (caps.headerExtensions) {
      caps.headerExtensions.forEach(function(extension) {
        sdp += SDPUtils.writeExtmap(extension);
      });
    }
    // FIXME: write fecMechanisms.
    return sdp;
  };

  // Parses the SDP media section and returns an array of
  // RTCRtpEncodingParameters.
  SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
    var encodingParameters = [];
    var description = SDPUtils.parseRtpParameters(mediaSection);
    var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
    var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

    // filter a=ssrc:... cname:, ignore PlanB-msid
    var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(function(line) {
      return SDPUtils.parseSsrcMedia(line);
    })
    .filter(function(parts) {
      return parts.attribute === 'cname';
    });
    var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
    var secondarySsrc;

    var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
    .map(function(line) {
      var parts = line.substr(17).split(' ');
      return parts.map(function(part) {
        return parseInt(part, 10);
      });
    });
    if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
      secondarySsrc = flows[0][1];
    }

    description.codecs.forEach(function(codec) {
      if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
        var encParam = {
          ssrc: primarySsrc,
          codecPayloadType: parseInt(codec.parameters.apt, 10)
        };
        if (primarySsrc && secondarySsrc) {
          encParam.rtx = {ssrc: secondarySsrc};
        }
        encodingParameters.push(encParam);
        if (hasRed) {
          encParam = JSON.parse(JSON.stringify(encParam));
          encParam.fec = {
            ssrc: primarySsrc,
            mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
          };
          encodingParameters.push(encParam);
        }
      }
    });
    if (encodingParameters.length === 0 && primarySsrc) {
      encodingParameters.push({
        ssrc: primarySsrc
      });
    }

    // we support both b=AS and b=TIAS but interpret AS as TIAS.
    var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
    if (bandwidth.length) {
      if (bandwidth[0].indexOf('b=TIAS:') === 0) {
        bandwidth = parseInt(bandwidth[0].substr(7), 10);
      } else if (bandwidth[0].indexOf('b=AS:') === 0) {
        // use formula from JSEP to convert b=AS to TIAS value.
        bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
            - (50 * 40 * 8);
      } else {
        bandwidth = undefined;
      }
      encodingParameters.forEach(function(params) {
        params.maxBitrate = bandwidth;
      });
    }
    return encodingParameters;
  };

  // parses http://draft.ortc.org/#rtcrtcpparameters*
  SDPUtils.parseRtcpParameters = function(mediaSection) {
    var rtcpParameters = {};

    // Gets the first SSRC. Note tha with RTX there might be multiple
    // SSRCs.
    var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
        .map(function(line) {
          return SDPUtils.parseSsrcMedia(line);
        })
        .filter(function(obj) {
          return obj.attribute === 'cname';
        })[0];
    if (remoteSsrc) {
      rtcpParameters.cname = remoteSsrc.value;
      rtcpParameters.ssrc = remoteSsrc.ssrc;
    }

    // Edge uses the compound attribute instead of reducedSize
    // compound is !reducedSize
    var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
    rtcpParameters.reducedSize = rsize.length > 0;
    rtcpParameters.compound = rsize.length === 0;

    // parses the rtcp-mux attrbute.
    // Note that Edge does not support unmuxed RTCP.
    var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
    rtcpParameters.mux = mux.length > 0;

    return rtcpParameters;
  };

  // parses either a=msid: or a=ssrc:... msid lines and returns
  // the id of the MediaStream and MediaStreamTrack.
  SDPUtils.parseMsid = function(mediaSection) {
    var parts;
    var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
    if (spec.length === 1) {
      parts = spec[0].substr(7).split(' ');
      return {stream: parts[0], track: parts[1]};
    }
    var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
    .map(function(line) {
      return SDPUtils.parseSsrcMedia(line);
    })
    .filter(function(msidParts) {
      return msidParts.attribute === 'msid';
    });
    if (planB.length > 0) {
      parts = planB[0].value.split(' ');
      return {stream: parts[0], track: parts[1]};
    }
  };

  // Generate a session ID for SDP.
  // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
  // recommends using a cryptographically random +ve 64-bit value
  // but right now this should be acceptable and within the right range
  SDPUtils.generateSessionId = function() {
    return Math.random().toString().substr(2, 21);
  };

  // Write boilder plate for start of SDP
  // sessId argument is optional - if not supplied it will
  // be generated randomly
  // sessVersion is optional and defaults to 2
  // sessUser is optional and defaults to 'thisisadapterortc'
  SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
    var sessionId;
    var version = sessVer !== undefined ? sessVer : 2;
    if (sessId) {
      sessionId = sessId;
    } else {
      sessionId = SDPUtils.generateSessionId();
    }
    var user = sessUser || 'thisisadapterortc';
    // FIXME: sess-id should be an NTP timestamp.
    return 'v=0\r\n' +
        'o=' + user + ' ' + sessionId + ' ' + version +
          ' IN IP4 127.0.0.1\r\n' +
        's=-\r\n' +
        't=0 0\r\n';
  };

  SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
    var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

    // Map ICE parameters (ufrag, pwd) to SDP.
    sdp += SDPUtils.writeIceParameters(
        transceiver.iceGatherer.getLocalParameters());

    // Map DTLS parameters to SDP.
    sdp += SDPUtils.writeDtlsParameters(
        transceiver.dtlsTransport.getLocalParameters(),
        type === 'offer' ? 'actpass' : 'active');

    sdp += 'a=mid:' + transceiver.mid + '\r\n';

    if (transceiver.direction) {
      sdp += 'a=' + transceiver.direction + '\r\n';
    } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
      sdp += 'a=sendrecv\r\n';
    } else if (transceiver.rtpSender) {
      sdp += 'a=sendonly\r\n';
    } else if (transceiver.rtpReceiver) {
      sdp += 'a=recvonly\r\n';
    } else {
      sdp += 'a=inactive\r\n';
    }

    if (transceiver.rtpSender) {
      // spec.
      var msid = 'msid:' + stream.id + ' ' +
          transceiver.rtpSender.track.id + '\r\n';
      sdp += 'a=' + msid;

      // for Chrome.
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
          ' ' + msid;
      if (transceiver.sendEncodingParameters[0].rtx) {
        sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
            ' ' + msid;
        sdp += 'a=ssrc-group:FID ' +
            transceiver.sendEncodingParameters[0].ssrc + ' ' +
            transceiver.sendEncodingParameters[0].rtx.ssrc +
            '\r\n';
      }
    }
    // FIXME: this should be written by writeRtpDescription.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
    if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' cname:' + SDPUtils.localCName + '\r\n';
    }
    return sdp;
  };

  // Gets the direction from the mediaSection or the sessionpart.
  SDPUtils.getDirection = function(mediaSection, sessionpart) {
    // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
    var lines = SDPUtils.splitLines(mediaSection);
    for (var i = 0; i < lines.length; i++) {
      switch (lines[i]) {
        case 'a=sendrecv':
        case 'a=sendonly':
        case 'a=recvonly':
        case 'a=inactive':
          return lines[i].substr(2);
        default:
          // FIXME: What should happen here?
      }
    }
    if (sessionpart) {
      return SDPUtils.getDirection(sessionpart);
    }
    return 'sendrecv';
  };

  SDPUtils.getKind = function(mediaSection) {
    var lines = SDPUtils.splitLines(mediaSection);
    var mline = lines[0].split(' ');
    return mline[0].substr(2);
  };

  SDPUtils.isRejected = function(mediaSection) {
    return mediaSection.split(' ', 2)[1] === '0';
  };

  SDPUtils.parseMLine = function(mediaSection) {
    var lines = SDPUtils.splitLines(mediaSection);
    var parts = lines[0].substr(2).split(' ');
    return {
      kind: parts[0],
      port: parseInt(parts[1], 10),
      protocol: parts[2],
      fmt: parts.slice(3).join(' ')
    };
  };

  SDPUtils.parseOLine = function(mediaSection) {
    var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
    var parts = line.substr(2).split(' ');
    return {
      username: parts[0],
      sessionId: parts[1],
      sessionVersion: parseInt(parts[2], 10),
      netType: parts[3],
      addressType: parts[4],
      address: parts[5]
    };
  };

  // a very naive interpretation of a valid SDP.
  SDPUtils.isValidSDP = function(blob) {
    if (typeof blob !== 'string' || blob.length === 0) {
      return false;
    }
    var lines = SDPUtils.splitLines(blob);
    for (var i = 0; i < lines.length; i++) {
      if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
        return false;
      }
      // TODO: check the modifier a bit more.
    }
    return true;
  };

  // Expose public methods.
  if (typeof module === 'object') {
    module.exports = SDPUtils;
  }

  },{}]},{},[1])(1)
  });

/***/ }),

/***/ "../zego_express_web_rtm/dist/ZegoExpressWebRTM.js":
/*!*********************************************************!*\
  !*** ../zego_express_web_rtm/dist/ZegoExpressWebRTM.js ***!
  \*********************************************************/
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_573__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_573__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_573__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_573__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_573__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_573__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_573__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__nested_webpack_require_573__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __nested_webpack_require_573__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__nested_webpack_require_573__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_573__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_573__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_573__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_573__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_573__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_573__(__nested_webpack_require_573__.s = "./sdk/code/zh/zego.client.web.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/zego-express-logger/ZegoExpressLogger.js":
/*!****************************************************************!*\
  !*** ../node_modules/zego-express-logger/ZegoExpressLogger.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){if(true)module.exports=t();else { var n, o; }}("undefined"!=typeof self?self:this,(function(){return function(e){var t={};function o(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,o),i.l=!0,i.exports}return o.m=e,o.c=t,o.d=function(e,t,n){o.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},o.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,t){if(1&t&&(e=o(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(o.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)o.d(n,i,function(t){return e[t]}.bind(null,i));return n},o.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return o.d(t,"a",t),t},o.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},o.p="",o(o.s=3)}([function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.E_CLIENT_TYPE=t.ENUM_LOG_LEVEL=t.ENUM_REMOTE_TYPE=t.ZEGO_ENV=t.ZEGO_BROWSER_TYPE=void 0,function(e){e[e.IE=0]="IE",e[e.FIREFOX=1]="FIREFOX",e[e.CHROME=2]="CHROME",e[e.SAFARI=3]="SAFARI",e[e.OPERA=4]="OPERA",e[e.WEIXIN=5]="WEIXIN",e[e.WEIXINMINI=6]="WEIXINMINI",e[e.UNKOWN=7]="UNKOWN"}(t.ZEGO_BROWSER_TYPE||(t.ZEGO_BROWSER_TYPE={})),function(e){e[e.BROWSER=0]="BROWSER",e[e.WEIXINMINI=1]="WEIXINMINI"}(t.ZEGO_ENV||(t.ZEGO_ENV={})),function(e){e[e.DISABLE=0]="DISABLE",e[e.WEBSOCKET=1]="WEBSOCKET",e[e.HTTPS=2]="HTTPS"}(t.ENUM_REMOTE_TYPE||(t.ENUM_REMOTE_TYPE={})),t.ENUM_LOG_LEVEL={DEBUG:0,INFO:1,WARN:2,ERROR:3,REPORT:99,DISABLE:100,debug:0,info:1,warn:2,error:3,report:99,disable:100},function(e){e[e.ClientType_None=0]="ClientType_None",e[e.ClientType_H5=1]="ClientType_H5",e[e.ClientType_SmallPragram=2]="ClientType_SmallPragram",e[e.ClientType_Webrtc=3]="ClientType_Webrtc"}(t.E_CLIENT_TYPE||(t.E_CLIENT_TYPE={}))},function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.LoggerStateCenter=void 0;var n=function(){function e(){this._testEnvironment=!0,this._ENV=0,this._debug=!0}return e.getInstance=function(){return e.instance||(e.instance=new e,e.instance.init()),e.instance},e.prototype.init=function(){},Object.defineProperty(e.prototype,"testEnvironment",{get:function(){return this._testEnvironment},set:function(e){this._testEnvironment=e},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"ENV",{get:function(){return this._ENV},set:function(e){this._ENV=e},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"debug",{get:function(){return this._debug},set:function(e){this._debug=e},enumerable:!1,configurable:!0}),e.instance=new e,e}();t.LoggerStateCenter=n},function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createZegoWebSocket=t.ZegoWeiXinMiniWebSocket=void 0;var n=o(0),i=function(){function e(e,t){this.url=e,this.readyState=3,this._websocket=wx.connectSocket({url:e}),this.init()}return e.prototype.init=function(){var e=this;this._websocket&&(this.readyState=0,this._websocket.onOpen((function(t){e.readyState=e._websocket.readyState,"function"==typeof e.onopen&&(e.onopen(t),e._websocket.onClose((function(t){e.readyState=e._websocket.readyState,"function"==typeof e.onclose&&e.onclose(t)})),e._websocket.onMessage((function(t){"function"==typeof e.onmessage&&e.onmessage(t)})))})),this._websocket.onError((function(t){e.readyState=e._websocket.readyState,"function"==typeof e.onerror&&e.onerror(t)})))},e.prototype.onopen=function(e){},e.prototype.onerror=function(e){},e.prototype.onclose=function(e){},e.prototype.onmessage=function(e){},e.prototype.send=function(e){this._websocket&&this._websocket.send({data:e})},e.prototype.close=function(){this._websocket&&this._websocket.close()},e}();t.ZegoWeiXinMiniWebSocket=i,t.createZegoWebSocket=function(e,t){return t%2===n.ZEGO_ENV.BROWSER?new WebSocket(e):new i(e)}},function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.LoggerStateCenter=t.createZegoWebSocket=t.ZegoDataReport=t.ZegoLogger=void 0;var n=o(1);Object.defineProperty(t,"LoggerStateCenter",{enumerable:!0,get:function(){return n.LoggerStateCenter}});var i=o(2);Object.defineProperty(t,"createZegoWebSocket",{enumerable:!0,get:function(){return i.createZegoWebSocket}});var s=o(4);Object.defineProperty(t,"ZegoDataReport",{enumerable:!0,get:function(){return s.ZegoDataReport}});var r=o(5);Object.defineProperty(t,"ZegoLogger",{enumerable:!0,get:function(){return r.ZegoLogger}})},function(e,t,o){"use strict";var n=this&&this.__assign||function(){return(n=Object.assign||function(e){for(var t,o=1,n=arguments.length;o<n;o++)for(var i in t=arguments[o])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.ZegoDataReport=void 0;var i=function(){function e(e){this.dataStatistics={},this.logger=e}return e.prototype.newReport=function(e,t){this.dataStatistics[e]={event_time:Date.now(),time_consumed:0,seq:e,error:0,message:"success",event:t,events:[]}},e.prototype.addMsgExt=function(e,t){this.dataStatistics[e]?this.dataStatistics[e].msg_ext=t:console.warn(e+" not exist")},e.prototype.addMsgInfo=function(e,t){this.dataStatistics[e]?Object.assign(this.dataStatistics[e],t):console.warn(e+" not exist")},e.prototype.eventStart=function(e,t){this.dataStatistics[e]?null!=this.dataStatistics[e].events?this.dataStatistics[e].events.push({event:t,event_time:Date.now(),time_consumed:0}):this.logger.warn("zd.es.0 no events"):this.logger.warn("zd.es.0 no seq match")},e.prototype.eventEnd=function(e,t,o){if(this.dataStatistics[e]){var n=this.dataStatistics[e].events;if(n&&0!==n.length){for(var i=n.length-1;i>=0;i--)if(n[i].event==t&&0==n[i].time_consumed){n[i].time_consumed=Date.now()-n[i].event_time;break}}else this.logger.info("zd.ee.0 no events")}else this.logger.info("zd.ee.0 no seq match")},e.prototype.eventEndWithMsg=function(e,t,o){if(this.dataStatistics[e]){var i=this.dataStatistics[e].events;if(i){for(var s=i.length-1;s>=0;s--)if(i[s].event==t&&0==i[s].time_consumed){i[s].time_consumed=Date.now()-i[s].event_time,null==i[s].msg_ext&&(i[s].msg_ext={}),i[s].msg_ext=n({},o);break}}else this.logger.warn("zd.ee.0 no events")}else this.logger.warn("zd.ee.0 no seq match")},e.prototype.eventEndWithMsgInfo=function(e,t,o){if(this.dataStatistics[e]){var n=this.dataStatistics[e].events;if(n){for(var i=n.length-1;i>=0;i--)if(n[i].event==t&&0==n[i].time_consumed){n[i].time_consumed=Date.now()-n[i].event_time,Object.assign(n[i],o);break}}else this.logger.warn("zd.ee.0 no events")}else this.logger.warn("zd.ee.0 no seq match")},e.prototype.addEventInfo=function(e,t,o,n){if(this.dataStatistics[e]){var i=this.dataStatistics[e].events;if(null!=i){for(var s=i.length-1;s>=0;s--)if(i[s].event==t&&null!=i[s].time_consumed){null==i[s].msg_ext?i[s].msg_ext={}:i[s].msg_ext&&(i[s].msg_ext[o]=n);break}}else this.logger.warn("zd.aei.0 no events")}else this.logger.warn("zd.aei.0 no seq match")},e.prototype.addEventMsg=function(e,t,o,n){if(this.dataStatistics[e]){var i=this.dataStatistics[e].events;if(null!=i){for(var s=i.length-1;s>=0;s--)if(i[s].event==t){i[s][o]=n;break}}else this.logger.warn("zd.aem.0 no events")}else this.logger.warn("zd.aem.0 no seq match")},e.prototype.addEvent=function(e,t,o){this.dataStatistics[e]?this.dataStatistics[e].events&&(o?this.dataStatistics[e].events.push({event:t,event_time:Date.now(),msg_ext:o}):this.dataStatistics[e].events.push({event:t,event_time:Date.now()})):this.logger.warn("zd.ae.0 no seq match")},e.prototype.uploadReport=function(e,t,o,n){var i=this.dataStatistics[e];null!=i&&(t&&(i.event=t),i.time_consumed=Date.now()-i.event_time,o&&this.addMsgInfo(e,{error:o.code,message:o.message||o.msg+" "+(n||"")}),this.logger.report(i),delete this.dataStatistics[e])},e}();t.ZegoDataReport=i},function(e,t,o){"use strict";var n=this&&this.__assign||function(){return(n=Object.assign||function(e){for(var t,o=1,n=arguments.length;o<n;o++)for(var i in t=arguments[o])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.ZegoLogger=void 0;var i=o(0),s=o(2),r=o(1),a=o(6),c=function(){function e(e){this.logLevel=i.ENUM_LOG_LEVEL.INFO,this.logRemoteLevel=0,this.websocket=null,this.logUploadTimer=null,this.logUploadInterval=1e4,this.logCache=[],this.logCacheSend=[],this.logCacheMax=100,this.existUserID=!1,this.stateCenter=r.LoggerStateCenter.getInstance(),this.env=e}return e.prototype.setLogLevel=function(e){var t=i.ENUM_LOG_LEVEL[e];return void 0!==t&&(this.logLevel=t,!0)},e.prototype.setRemoteLogLevel=function(e){var t=i.ENUM_LOG_LEVEL[e];return void 0!==t&&(this.logRemoteLevel=t,!0)},e.prototype.setSessionInfo=function(e,t,o,n,i,s){this.appid=e,this.roomid=t,this.sessionid=o,this.userid=n,this.userName=i,this.version=s},e.prototype.report=function(e){var t=this.logReportParamList(i.ENUM_LOG_LEVEL.REPORT,e);this.logLevel!==i.ENUM_LOG_LEVEL.DISABLE&&this.logLevel<=i.ENUM_LOG_LEVEL.REPORT&&console.debug(t),this.RemoteLog(i.ENUM_LOG_LEVEL.REPORT,t,!0)},e.prototype.debug=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var o=this.logParamList(i.ENUM_LOG_LEVEL.DEBUG,e.join(""));this.logLevel!==i.ENUM_LOG_LEVEL.DISABLE&&this.logLevel<=i.ENUM_LOG_LEVEL.DEBUG&&console.debug(o),this.log(i.ENUM_LOG_LEVEL.DEBUG,o)},e.prototype.info=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var o=this.logParamList(i.ENUM_LOG_LEVEL.INFO,e.join(""));this.logLevel!==i.ENUM_LOG_LEVEL.DISABLE&&this.logLevel<=i.ENUM_LOG_LEVEL.INFO&&console.info(o),this.log(i.ENUM_LOG_LEVEL.INFO,o)},e.prototype.warn=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var o=this.logParamList(i.ENUM_LOG_LEVEL.WARN,e.join(""));this.logLevel!==i.ENUM_LOG_LEVEL.DISABLE&&this.logLevel<=i.ENUM_LOG_LEVEL.WARN&&console.warn(o),this.log(i.ENUM_LOG_LEVEL.WARN,o)},e.prototype.error=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var o=this.logParamList(i.ENUM_LOG_LEVEL.ERROR,e.join(""));this.logLevel!==i.ENUM_LOG_LEVEL.DISABLE&&this.logLevel<=i.ENUM_LOG_LEVEL.ERROR&&(console.error(o),window?this.stateCenter.debug&&window.alert(e.join("").substr(e.join("").indexOf(" ")+1,4500)):wx&&this.stateCenter.debug&&wx.showModal({title:"",content:e.join("").substr(e.join("").indexOf(" ")+1,4500)})),this.log(i.ENUM_LOG_LEVEL.ERROR,o)},e.prototype.log=function(e,t){this.logRemoteLevel!==i.ENUM_LOG_LEVEL.DISABLE&&this.logRemoteLevel<=e&&this.RemoteLog(e,t)},e.prototype.setLogServer=function(e){try{return e.startsWith("wss:")?(this.logType=i.ENUM_REMOTE_TYPE.WEBSOCKET,this.openWebSocketLogServer(e)):e.startsWith("https:")?(this.logType=i.ENUM_REMOTE_TYPE.HTTPS,this.openHttpsLogServer(e)):this.logType=i.ENUM_REMOTE_TYPE.DISABLE,!0}catch(e){return this.error(JSON.stringify(e)),!1}},e.prototype.stopLogServer=function(){this.logType==i.ENUM_REMOTE_TYPE.WEBSOCKET?this.stopWebSocketServer():this.logType==i.ENUM_REMOTE_TYPE.HTTPS&&(this.SendHttpsLog(),this.stopHttpsServer()),this.logType=i.ENUM_REMOTE_TYPE.DISABLE},e.prototype.stopWebSocketServer=function(){this.websocket&&(this.websocket.onclose=null,this.websocket.onerror=null,this.websocket.close(),this.websocket=null)},e.prototype.openHttpsLogServer=function(e){var t=this;this.url=e,e&&(this.stopHttpsServer(),this.logUploadTimer||(this.logUploadTimer=setInterval((function(){t.SendHttpsLog()}),this.logUploadInterval)))},e.prototype.stopHttpsServer=function(){this.logUploadTimer&&(clearInterval(this.logUploadTimer),this.logUploadTimer=null)},e.prototype.RemoteLog=function(e,t,o){if(void 0===o&&(o=!1),""!=this.url)if(this.logType==i.ENUM_REMOTE_TYPE.WEBSOCKET)this.RemoteWebSocketLog(e,t);else if(this.logType==i.ENUM_REMOTE_TYPE.HTTPS)this.RemoteHttpsLog(e,t,o);else if(this.logLevel!==i.ENUM_LOG_LEVEL.DISABLE&&this.logLevel<=e)for(this.logCacheSend.push(t);this.logCacheSend.length>this.logCacheMax;)this.logCacheSend.shift()},e.prototype.RemoteWebSocketLog=function(e,t){if("string"==typeof t&&t.length>4e3)console.info("log over maximum, ignore");else if(null==this.websocket||2==this.websocket.readyState||3==this.websocket.readyState){var o=this.url;this.url="",this.setLogServer(o),this.logCacheSend.length<this.logCacheMax&&this.logCacheSend.push(t)}else if(0==this.websocket.readyState)this.logCacheSend.length<this.logCacheMax&&this.logCacheSend.push(t);else if(1==this.websocket.readyState)if(this.logCacheSend.length>0){for(var i="",s=0;s<this.logCacheSend.length;s++){(i+this.logCacheSend[s]).length>4e3&&(this.websocket.send(i),i="");var r=JSON.parse(this.logCacheSend[s]);r=n(n({},r),{userid:r.userid||this.userid,roomid:r.roomid||this.roomid,userName:r.roomid||this.userName}),i=i+JSON.stringify(r)+"\n"}t=i+t,this.logCacheSend=[],this.websocket.send(t)}else this.websocket.send(t);else console.warn("wrong socket state:"+this.websocket.readyState),this.logCacheSend.length<this.logCacheMax&&this.logCacheSend.push(t)},e.prototype.RemoteHttpsLog=function(e,t,o){this.logCacheSend.push(t),(this.logCacheSend.length>=this.logCacheMax||!0===o)&&this.SendHttpsLog()},e.prototype.logParamList=function(e,t){var o=a.getCurrentTime(),n=[t.substr(0,t.indexOf(" "))||t,t.substr(t.indexOf(" ")+1,4500)||t],i={time:o,level:e,action:n[0],content:n[1],appid:this.appid,roomid:this.roomid,userid:this.userid,userName:this.userName,sessionid:this.sessionid};return JSON.stringify(i)},e.prototype.logReportParamList=function(e,t){var o=a.getCurrentTime();return t=n(n({},t),{time:o,level:e,console:this.env%2===i.ZEGO_ENV.BROWSER?"rtc":"xcx",appid:this.appid,room_id:this.roomid,roomid:this.roomid,userid:this.userid,id_name:this.userid,userName:this.userName,sessionid:this.sessionid,sdk_version:this.version,test_environment:this.stateCenter.testEnvironment,version:this.version,event_id:this.appid+"_"+this.userid+"_"+t.event_time+"_"+t.seq}),JSON.stringify(t)},e.prototype.openWebSocketLogServer=function(e){if(this.url!=e){if(this.url=e,!e)return;this.stopWebSocketServer(),this.websocket=s.createZegoWebSocket(e,this.env),this.websocket.onopen=function(){},this.websocket.onclose=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];console.warn("onclose   websocket error:",e)},this.websocket.onmessage=function(){},this.websocket.onerror=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];console.warn("open log websocket error:",e)}}},e.prototype.SendHttpsLog=function(){0!=this.logCacheSend.length&&(this.env%2===i.ZEGO_ENV.BROWSER?this.SendHttpsLogWeb():this.SendHttpsLogWeChatMini())},e.prototype.SendHttpsLogWeb=function(){var e=this,t=this.logCacheSend.join("\n"),o=new XMLHttpRequest;o.onreadystatechange=function(){if(4==o.readyState)if(200==o.status){if(0==o.responseText.length)return;try{var t=JSON.parse(o.responseText).interval;"number"==typeof t&&e.logUploadInterval!==t&&(e.timeInterval=t,e.openHttpsLogServer(e.url))}catch(e){console.log("send result failed "+e)}}else console.log("send failed "+o.status)},o.open("POST",this.url,!0),0==this.env?o.send(t):2==this.env&&(o.setRequestHeader("content-type","application/json"),o.send(JSON.stringify({user_id:this.userid,log:t}))),this.logCacheSend=[]},e.prototype.SendHttpsLogWeChatMini=function(){var e=this;!this.existUserID&&this.userid&&this.logCacheSend.forEach((function(t){Array.isArray(t)&&t.forEach((function(o,n){var i=JSON.parse(o);i&&""==JSON.parse(o).userid?(i.userid=e.userid,i.id_name=e.userid,t[n]=JSON.stringify(i)):e.existUserID=!0}))}));var t=this.logCacheSend.join("\n"),o=1==this.env?t:JSON.stringify({user_id:this.userid,log:t});wx.request({url:this.url,data:o,method:"POST",success:function(t){if(0!=t.data.length){var o=t&&t.data&&t.data.interval;"number"==typeof o&&e.logUploadInterval!==o&&(e.timeInterval=o,e.openHttpsLogServer(e.url))}},fail:function(e){console.log("send failed "+e.statusCode)}}),this.logCacheSend=[]},e}();t.ZegoLogger=c},function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getCurrentTime=t.getCurrentEnv=t.getBrowser=void 0;var n=o(0);t.getBrowser=function(){var e=window.navigator.userAgent,t=null!=window.ActiveXObject&&-1!=e.indexOf("MSIE"),o=-1!=e.indexOf("Firefox"),i=null!=window.opr,s=e.indexOf("Chrome")&&window.chrome,r=-1!=e.indexOf("Safari")&&-1!=e.indexOf("Version"),a=e.toLowerCase().match(/MicroMessenger/i)&&"micromessenger"===e.toLowerCase().match(/MicroMessenger/i)[0];return t?n.ZEGO_BROWSER_TYPE.IE:o?n.ZEGO_BROWSER_TYPE.FIREFOX:i?n.ZEGO_BROWSER_TYPE.OPERA:s?n.ZEGO_BROWSER_TYPE.CHROME:r?n.ZEGO_BROWSER_TYPE.SAFARI:a?n.ZEGO_BROWSER_TYPE.WEIXIN:n.ZEGO_BROWSER_TYPE.UNKOWN},t.getCurrentEnv=function(){var e=window.navigator.userAgent;return new Promise((function(t){-1==e.indexOf("MicroMessage")?t(n.ZEGO_ENV.BROWSER):wx.miniProgram.getEnv((function(e){e.miniprogram}))}))};var i=["00","01","02","03","04","05","06","07","08","09"];t.getCurrentTime=function(){var e=new Date;return[e.getFullYear()+"/",(i[e.getMonth()+1]||e.getMonth()+1)+"/",(i[e.getDate()]||e.getDate())+" ",(i[e.getHours()]||e.getHours())+":",(i[e.getMinutes()]||e.getMinutes())+":",i[e.getSeconds()]||e.getSeconds(),"."+e.getTime()%1e3].join("")}}])}));

/***/ }),

/***/ "./node_modules/@protobufjs/aspromise/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}


/***/ }),

/***/ "./node_modules/@protobufjs/base64/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};


/***/ }),

/***/ "./node_modules/@protobufjs/eventemitter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};


/***/ }),

/***/ "./node_modules/@protobufjs/float/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}


/***/ }),

/***/ "./node_modules/@protobufjs/inquire/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}


/***/ }),

/***/ "./node_modules/@protobufjs/pool/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}


/***/ }),

/***/ "./node_modules/@protobufjs/utf8/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};


/***/ }),

/***/ "./node_modules/crypto-js/aes.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/aes.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_48460__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_48460__(/*! ./core */ "./node_modules/crypto-js/core.js"), __nested_webpack_require_48460__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __nested_webpack_require_48460__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __nested_webpack_require_48460__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __nested_webpack_require_48460__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            var t;

	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));

/***/ }),

/***/ "./node_modules/crypto-js/cipher-core.js":
/*!***********************************************!*\
  !*** ./node_modules/crypto-js/cipher-core.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_57465__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_57465__(/*! ./core */ "./node_modules/crypto-js/core.js"), __nested_webpack_require_57465__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            var block;

	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            var modeCreator;

	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            var finalProcessedBlocks;

	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            var wordArray;

	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            var salt;

	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));

/***/ }),

/***/ "./node_modules/crypto-js/core.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/core.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_87317__) {

/* WEBPACK VAR INJECTION */(function(global) {;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native crypto in web worker (Browser)
	    if (typeof self !== 'undefined' && self.crypto) {
	        crypto = self.crypto;
	    }

	    // Native crypto from worker
	    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
	        crypto = globalThis.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof global !== 'undefined' && global.crypto) {
	        crypto = global.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __nested_webpack_require_87317__(/*! crypto */ 0);
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }());

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var j = 0; j < thatSigBytes; j += 4) {
	                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_87317__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/crypto-js/enc-base64.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-js/enc-base64.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_111288__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_111288__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              var bitsCombined = bits1 | bits2;
	              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),

/***/ "./node_modules/crypto-js/enc-hex.js":
/*!*******************************************!*\
  !*** ./node_modules/crypto-js/enc-hex.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_115541__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_115541__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Hex;

}));

/***/ }),

/***/ "./node_modules/crypto-js/enc-utf8.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/enc-utf8.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_116076__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_116076__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Utf8;

}));

/***/ }),

/***/ "./node_modules/crypto-js/evpkdf.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/evpkdf.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_116604__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_116604__(/*! ./core */ "./node_modules/crypto-js/core.js"), __nested_webpack_require_116604__(/*! ./sha1 */ "./node_modules/crypto-js/sha1.js"), __nested_webpack_require_116604__(/*! ./hmac */ "./node_modules/crypto-js/hmac.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            var block;

	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));

/***/ }),

/***/ "./node_modules/crypto-js/hmac.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/hmac.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_120841__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_120841__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),

/***/ "./node_modules/crypto-js/lib-typedarrays.js":
/*!***************************************************!*\
  !*** ./node_modules/crypto-js/lib-typedarrays.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_125029__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_125029__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));

/***/ }),

/***/ "./node_modules/crypto-js/md5.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/md5.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_127413__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_127413__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),

/***/ "./node_modules/crypto-js/sha1.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/sha1.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_136991__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_136991__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));

/***/ }),

/***/ "./node_modules/js-base64/base64.mjs":
/*!*******************************************!*\
  !*** ./node_modules/js-base64/base64.mjs ***!
  \*******************************************/
/*! exports provided: version, VERSION, atob, atobPolyfill, btoa, btoaPolyfill, fromBase64, toBase64, utob, encode, encodeURI, encodeURL, btou, decode, isValid, fromUint8Array, toUint8Array, extendString, extendUint8Array, extendBuiltins, Base64 */
/***/ (function(__webpack_module__, __webpack_exports__, __nested_webpack_require_141468__) {

"use strict";
__nested_webpack_require_141468__.r(__webpack_exports__);
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "version", function() { return version; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "atob", function() { return _atob; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "atobPolyfill", function() { return atobPolyfill; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "btoa", function() { return _btoa; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "btoaPolyfill", function() { return btoaPolyfill; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "fromBase64", function() { return decode; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "toBase64", function() { return encode; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "utob", function() { return utob; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "encode", function() { return encode; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "encodeURI", function() { return encodeURI; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "encodeURL", function() { return encodeURI; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "btou", function() { return btou; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "decode", function() { return decode; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "isValid", function() { return isValid; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "fromUint8Array", function() { return fromUint8Array; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "toUint8Array", function() { return toUint8Array; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "extendString", function() { return extendString; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "extendUint8Array", function() { return extendUint8Array; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "extendBuiltins", function() { return extendBuiltins; });
/* harmony export (binding) */ __nested_webpack_require_141468__.d(__webpack_exports__, "Base64", function() { return gBase64; });
/**
 *  base64.ts
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 *
 * @author Dan Kogai (https://github.com/dankogai)
 */
const version = '3.6.0';
/**
 * @deprecated use lowercase `version`.
 */
const VERSION = version;
const _hasatob = typeof atob === 'function';
const _hasbtoa = typeof btoa === 'function';
const _hasBuffer = typeof Buffer === 'function';
const _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;
const _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;
const b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
const b64chs = [...b64ch];
const b64tab = ((a) => {
    let tab = {};
    a.forEach((c, i) => tab[c] = i);
    return tab;
})(b64chs);
const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
const _fromCC = String.fromCharCode.bind(String);
const _U8Afrom = typeof Uint8Array.from === 'function'
    ? Uint8Array.from.bind(Uint8Array)
    : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
const _mkUriSafe = (src) => src
    .replace(/[+\/]/g, (m0) => m0 == '+' ? '-' : '_')
    .replace(/=+$/m, '');
const _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, '');
/**
 * polyfill version of `btoa`
 */
const btoaPolyfill = (bin) => {
    // console.log('polyfilled');
    let u32, c0, c1, c2, asc = '';
    const pad = bin.length % 3;
    for (let i = 0; i < bin.length;) {
        if ((c0 = bin.charCodeAt(i++)) > 255 ||
            (c1 = bin.charCodeAt(i++)) > 255 ||
            (c2 = bin.charCodeAt(i++)) > 255)
            throw new TypeError('invalid character found');
        u32 = (c0 << 16) | (c1 << 8) | c2;
        asc += b64chs[u32 >> 18 & 63]
            + b64chs[u32 >> 12 & 63]
            + b64chs[u32 >> 6 & 63]
            + b64chs[u32 & 63];
    }
    return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
/**
 * does what `window.btoa` of web browsers do.
 * @param {String} bin binary string
 * @returns {string} Base64-encoded string
 */
const _btoa = _hasbtoa ? (bin) => btoa(bin)
    : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')
        : btoaPolyfill;
const _fromUint8Array = _hasBuffer
    ? (u8a) => Buffer.from(u8a).toString('base64')
    : (u8a) => {
        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
        const maxargs = 0x1000;
        let strs = [];
        for (let i = 0, l = u8a.length; i < l; i += maxargs) {
            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
        }
        return _btoa(strs.join(''));
    };
/**
 * converts a Uint8Array to a Base64 string.
 * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 5
 * @returns {string} Base64 string
 */
const fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const utob = (src: string) => unescape(encodeURIComponent(src));
// reverting good old fationed regexp
const cb_utob = (c) => {
    if (c.length < 2) {
        var cc = c.charCodeAt(0);
        return cc < 0x80 ? c
            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))
                + _fromCC(0x80 | (cc & 0x3f)))
                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))
                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
                    + _fromCC(0x80 | (cc & 0x3f)));
    }
    else {
        var cc = 0x10000
            + (c.charCodeAt(0) - 0xD800) * 0x400
            + (c.charCodeAt(1) - 0xDC00);
        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))
            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))
            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
            + _fromCC(0x80 | (cc & 0x3f)));
    }
};
const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-8 string
 * @returns {string} UTF-16 string
 */
const utob = (u) => u.replace(re_utob, cb_utob);
//
const _encode = _hasBuffer
    ? (s) => Buffer.from(s, 'utf8').toString('base64')
    : _TE
        ? (s) => _fromUint8Array(_TE.encode(s))
        : (s) => _btoa(utob(s));
/**
 * converts a UTF-8-encoded string to a Base64 string.
 * @param {boolean} [urlsafe] if `true` make the result URL-safe
 * @returns {string} Base64 string
 */
const encode = (src, urlsafe = false) => urlsafe
    ? _mkUriSafe(_encode(src))
    : _encode(src);
/**
 * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 5.
 * @returns {string} Base64 string
 */
const encodeURI = (src) => encode(src, true);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const btou = (src: string) => decodeURIComponent(escape(src));
// reverting good old fationed regexp
const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
const cb_btou = (cccc) => {
    switch (cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                | ((0x3f & cccc.charCodeAt(1)) << 12)
                | ((0x3f & cccc.charCodeAt(2)) << 6)
                | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;
            return (_fromCC((offset >>> 10) + 0xD800)
                + _fromCC((offset & 0x3FF) + 0xDC00));
        case 3:
            return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)
                | ((0x3f & cccc.charCodeAt(1)) << 6)
                | (0x3f & cccc.charCodeAt(2)));
        default:
            return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)
                | (0x3f & cccc.charCodeAt(1)));
    }
};
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-16 string
 * @returns {string} UTF-8 string
 */
const btou = (b) => b.replace(re_btou, cb_btou);
/**
 * polyfill version of `atob`
 */
const atobPolyfill = (asc) => {
    // console.log('polyfilled');
    asc = asc.replace(/\s+/g, '');
    if (!b64re.test(asc))
        throw new TypeError('malformed base64.');
    asc += '=='.slice(2 - (asc.length & 3));
    let u24, bin = '', r1, r2;
    for (let i = 0; i < asc.length;) {
        u24 = b64tab[asc.charAt(i++)] << 18
            | b64tab[asc.charAt(i++)] << 12
            | (r1 = b64tab[asc.charAt(i++)]) << 6
            | (r2 = b64tab[asc.charAt(i++)]);
        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)
            : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)
                : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
    }
    return bin;
};
/**
 * does what `window.atob` of web browsers do.
 * @param {String} asc Base64-encoded string
 * @returns {string} binary string
 */
const _atob = _hasatob ? (asc) => atob(_tidyB64(asc))
    : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')
        : atobPolyfill;
//
const _toUint8Array = _hasBuffer
    ? (a) => _U8Afrom(Buffer.from(a, 'base64'))
    : (a) => _U8Afrom(_atob(a), c => c.charCodeAt(0));
/**
 * converts a Base64 string to a Uint8Array.
 */
const toUint8Array = (a) => _toUint8Array(_unURI(a));
//
const _decode = _hasBuffer
    ? (a) => Buffer.from(a, 'base64').toString('utf8')
    : _TD
        ? (a) => _TD.decode(_toUint8Array(a))
        : (a) => btou(_atob(a));
const _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));
/**
 * converts a Base64 string to a UTF-8 string.
 * @param {String} src Base64 string.  Both normal and URL-safe are supported
 * @returns {string} UTF-8 string
 */
const decode = (src) => _decode(_unURI(src));
/**
 * check if a value is a valid Base64 string
 * @param {String} src a value to check
  */
const isValid = (src) => {
    if (typeof src !== 'string')
        return false;
    const s = src.replace(/\s+/g, '').replace(/=+$/, '');
    return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
//
const _noEnum = (v) => {
    return {
        value: v, enumerable: false, writable: true, configurable: true
    };
};
/**
 * extend String.prototype with relevant methods
 */
const extendString = function () {
    const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
    _add('fromBase64', function () { return decode(this); });
    _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });
    _add('toBase64URI', function () { return encode(this, true); });
    _add('toBase64URL', function () { return encode(this, true); });
    _add('toUint8Array', function () { return toUint8Array(this); });
};
/**
 * extend Uint8Array.prototype with relevant methods
 */
const extendUint8Array = function () {
    const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
    _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });
    _add('toBase64URI', function () { return fromUint8Array(this, true); });
    _add('toBase64URL', function () { return fromUint8Array(this, true); });
};
/**
 * extend Builtin prototypes with relevant methods
 */
const extendBuiltins = () => {
    extendString();
    extendUint8Array();
};
const gBase64 = {
    version: version,
    VERSION: VERSION,
    atob: _atob,
    atobPolyfill: atobPolyfill,
    btoa: _btoa,
    btoaPolyfill: btoaPolyfill,
    fromBase64: decode,
    toBase64: encode,
    encode: encode,
    encodeURI: encodeURI,
    encodeURL: encodeURI,
    utob: utob,
    btou: btou,
    decode: decode,
    isValid: isValid,
    fromUint8Array: fromUint8Array,
    toUint8Array: toUint8Array,
    extendString: extendString,
    extendUint8Array: extendUint8Array,
    extendBuiltins: extendBuiltins,
};
// makecjs:CUT //




















// and finally,



/***/ }),

/***/ "./node_modules/localforage/dist/localforage.js":
/*!******************************************************!*\
  !*** ./node_modules/localforage/dist/localforage.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_154248__) {

/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/*!
    localForage -- Offline Storage, Improved
    Version 1.9.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw (f.code="MODULE_NOT_FOUND", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
'use strict';
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],2:[function(_dereq_,module,exports){
'use strict';
var immediate = _dereq_(1);

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
    typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"1":1}],3:[function(_dereq_,module,exports){
(function (global){
'use strict';
if (typeof global.Promise !== 'function') {
  global.Promise = _dereq_(2);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"2":2}],4:[function(_dereq_,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getIDB() {
    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */
    try {
        if (typeof indexedDB !== 'undefined') {
            return indexedDB;
        }
        if (typeof webkitIndexedDB !== 'undefined') {
            return webkitIndexedDB;
        }
        if (typeof mozIndexedDB !== 'undefined') {
            return mozIndexedDB;
        }
        if (typeof OIndexedDB !== 'undefined') {
            return OIndexedDB;
        }
        if (typeof msIndexedDB !== 'undefined') {
            return msIndexedDB;
        }
    } catch (e) {
        return;
    }
}

var idb = getIDB();

function isIndexedDBValid() {
    try {
        // Initialize IndexedDB; fall back to vendor-prefixed versions
        // if needed.
        if (!idb || !idb.open) {
            return false;
        }
        // We mimic PouchDB here;
        //
        // We test for openDatabase because IE Mobile identifies itself
        // as Safari. Oh the lulz...
        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);

        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;

        // Safari <10.1 does not meet our requirements for IDB support
        // (see: https://github.com/pouchdb/pouchdb/issues/5572).
        // Safari 10.1 shipped with fetch, we can use that to detect it.
        // Note: this creates issues with `window.fetch` polyfills and
        // overrides; see:
        // https://github.com/localForage/localForage/issues/856
        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&
        // some outdated implementations of IDB that appear on Samsung
        // and HTC Android devices <4.4 are missing IDBKeyRange
        // See: https://github.com/mozilla/localForage/issues/128
        // See: https://github.com/mozilla/localForage/issues/272
        typeof IDBKeyRange !== 'undefined';
    } catch (e) {
        return false;
    }
}

// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor. (i.e.
// old QtWebKit versions, at least).
// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor. (i.e.
// old QtWebKit versions, at least).
function createBlob(parts, properties) {
    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
    parts = parts || [];
    properties = properties || {};
    try {
        return new Blob(parts, properties);
    } catch (e) {
        if (e.name !== 'TypeError') {
            throw e;
        }
        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;
        var builder = new Builder();
        for (var i = 0; i < parts.length; i += 1) {
            builder.append(parts[i]);
        }
        return builder.getBlob(properties.type);
    }
}

// This is CommonJS because lie is an external dependency, so Rollup
// can just ignore it.
if (typeof Promise === 'undefined') {
    // In the "nopromises" build this will just throw if you don't have
    // a global promise object, but it would throw anyway later.
    _dereq_(3);
}
var Promise$1 = Promise;

function executeCallback(promise, callback) {
    if (callback) {
        promise.then(function (result) {
            callback(null, result);
        }, function (error) {
            callback(error);
        });
    }
}

function executeTwoCallbacks(promise, callback, errorCallback) {
    if (typeof callback === 'function') {
        promise.then(callback);
    }

    if (typeof errorCallback === 'function') {
        promise["catch"](errorCallback);
    }
}

function normalizeKey(key) {
    // Cast the key to a string, as that's all we can set as a key.
    if (typeof key !== 'string') {
        console.warn(key + ' used as a key, but it is not a string.');
        key = String(key);
    }

    return key;
}

function getCallback() {
    if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {
        return arguments[arguments.length - 1];
    }
}

// Some code originally from async_storage.js in
// [Gaia](https://github.com/mozilla-b2g/gaia).

var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';
var supportsBlobs = void 0;
var dbContexts = {};
var toString = Object.prototype.toString;

// Transaction Modes
var READ_ONLY = 'readonly';
var READ_WRITE = 'readwrite';

// Transform a binary string to an array buffer, because otherwise
// weird stuff happens when you try to work with the binary string directly.
// It is known.
// From http://stackoverflow.com/questions/14967647/ (continues on next line)
// encode-decode-image-with-base64-breaks-image (2013-04-21)
function _binStringToArrayBuffer(bin) {
    var length = bin.length;
    var buf = new ArrayBuffer(length);
    var arr = new Uint8Array(buf);
    for (var i = 0; i < length; i++) {
        arr[i] = bin.charCodeAt(i);
    }
    return buf;
}

//
// Blobs are not supported in all versions of IndexedDB, notably
// Chrome <37 and Android <5. In those versions, storing a blob will throw.
//
// Various other blob bugs exist in Chrome v37-42 (inclusive).
// Detecting them is expensive and confusing to users, and Chrome 37-42
// is at very low usage worldwide, so we do a hacky userAgent check instead.
//
// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
//
// Code borrowed from PouchDB. See:
// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js
//
function _checkBlobSupportWithoutCaching(idb) {
    return new Promise$1(function (resolve) {
        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
        var blob = createBlob(['']);
        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');

        txn.onabort = function (e) {
            // If the transaction aborts now its due to not being able to
            // write to the database, likely due to the disk being full
            e.preventDefault();
            e.stopPropagation();
            resolve(false);
        };

        txn.oncomplete = function () {
            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
            var matchedEdge = navigator.userAgent.match(/Edge\//);
            // MS Edge pretends to be Chrome 42:
            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
        };
    })["catch"](function () {
        return false; // error, so assume unsupported
    });
}

function _checkBlobSupport(idb) {
    if (typeof supportsBlobs === 'boolean') {
        return Promise$1.resolve(supportsBlobs);
    }
    return _checkBlobSupportWithoutCaching(idb).then(function (value) {
        supportsBlobs = value;
        return supportsBlobs;
    });
}

function _deferReadiness(dbInfo) {
    var dbContext = dbContexts[dbInfo.name];

    // Create a deferred object representing the current database operation.
    var deferredOperation = {};

    deferredOperation.promise = new Promise$1(function (resolve, reject) {
        deferredOperation.resolve = resolve;
        deferredOperation.reject = reject;
    });

    // Enqueue the deferred operation.
    dbContext.deferredOperations.push(deferredOperation);

    // Chain its promise to the database readiness.
    if (!dbContext.dbReady) {
        dbContext.dbReady = deferredOperation.promise;
    } else {
        dbContext.dbReady = dbContext.dbReady.then(function () {
            return deferredOperation.promise;
        });
    }
}

function _advanceReadiness(dbInfo) {
    var dbContext = dbContexts[dbInfo.name];

    // Dequeue a deferred operation.
    var deferredOperation = dbContext.deferredOperations.pop();

    // Resolve its promise (which is part of the database readiness
    // chain of promises).
    if (deferredOperation) {
        deferredOperation.resolve();
        return deferredOperation.promise;
    }
}

function _rejectReadiness(dbInfo, err) {
    var dbContext = dbContexts[dbInfo.name];

    // Dequeue a deferred operation.
    var deferredOperation = dbContext.deferredOperations.pop();

    // Reject its promise (which is part of the database readiness
    // chain of promises).
    if (deferredOperation) {
        deferredOperation.reject(err);
        return deferredOperation.promise;
    }
}

function _getConnection(dbInfo, upgradeNeeded) {
    return new Promise$1(function (resolve, reject) {
        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();

        if (dbInfo.db) {
            if (upgradeNeeded) {
                _deferReadiness(dbInfo);
                dbInfo.db.close();
            } else {
                return resolve(dbInfo.db);
            }
        }

        var dbArgs = [dbInfo.name];

        if (upgradeNeeded) {
            dbArgs.push(dbInfo.version);
        }

        var openreq = idb.open.apply(idb, dbArgs);

        if (upgradeNeeded) {
            openreq.onupgradeneeded = function (e) {
                var db = openreq.result;
                try {
                    db.createObjectStore(dbInfo.storeName);
                    if (e.oldVersion <= 1) {
                        // Added when support for blob shims was added
                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                    }
                } catch (ex) {
                    if (ex.name === 'ConstraintError') {
                        console.warn('The database "' + dbInfo.name + '"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                    } else {
                        throw ex;
                    }
                }
            };
        }

        openreq.onerror = function (e) {
            e.preventDefault();
            reject(openreq.error);
        };

        openreq.onsuccess = function () {
            resolve(openreq.result);
            _advanceReadiness(dbInfo);
        };
    });
}

function _getOriginalConnection(dbInfo) {
    return _getConnection(dbInfo, false);
}

function _getUpgradedConnection(dbInfo) {
    return _getConnection(dbInfo, true);
}

function _isUpgradeNeeded(dbInfo, defaultVersion) {
    if (!dbInfo.db) {
        return true;
    }

    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
    var isDowngrade = dbInfo.version < dbInfo.db.version;
    var isUpgrade = dbInfo.version > dbInfo.db.version;

    if (isDowngrade) {
        // If the version is not the default one
        // then warn for impossible downgrade.
        if (dbInfo.version !== defaultVersion) {
            console.warn('The database "' + dbInfo.name + '"' + " can't be downgraded from version " + dbInfo.db.version + ' to version ' + dbInfo.version + '.');
        }
        // Align the versions to prevent errors.
        dbInfo.version = dbInfo.db.version;
    }

    if (isUpgrade || isNewStore) {
        // If the store is new then increment the version (if needed).
        // This will trigger an "upgradeneeded" event which is required
        // for creating a store.
        if (isNewStore) {
            var incVersion = dbInfo.db.version + 1;
            if (incVersion > dbInfo.version) {
                dbInfo.version = incVersion;
            }
        }

        return true;
    }

    return false;
}

// encode a blob for indexeddb engines that don't support blobs
function _encodeBlob(blob) {
    return new Promise$1(function (resolve, reject) {
        var reader = new FileReader();
        reader.onerror = reject;
        reader.onloadend = function (e) {
            var base64 = btoa(e.target.result || '');
            resolve({
                __local_forage_encoded_blob: true,
                data: base64,
                type: blob.type
            });
        };
        reader.readAsBinaryString(blob);
    });
}

// decode an encoded blob
function _decodeBlob(encodedBlob) {
    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
    return createBlob([arrayBuff], { type: encodedBlob.type });
}

// is this one of our fancy encoded blobs?
function _isEncodedBlob(value) {
    return value && value.__local_forage_encoded_blob;
}

// Specialize the default `ready()` function by making it dependent
// on the current database operations. Thus, the driver will be actually
// ready when it's been initialized (default) *and* there are no pending
// operations on the database (initiated by some other instances).
function _fullyReady(callback) {
    var self = this;

    var promise = self._initReady().then(function () {
        var dbContext = dbContexts[self._dbInfo.name];

        if (dbContext && dbContext.dbReady) {
            return dbContext.dbReady;
        }
    });

    executeTwoCallbacks(promise, callback, callback);
    return promise;
}

// Try to establish a new db connection to replace the
// current one which is broken (i.e. experiencing
// InvalidStateError while creating a transaction).
function _tryReconnect(dbInfo) {
    _deferReadiness(dbInfo);

    var dbContext = dbContexts[dbInfo.name];
    var forages = dbContext.forages;

    for (var i = 0; i < forages.length; i++) {
        var forage = forages[i];
        if (forage._dbInfo.db) {
            forage._dbInfo.db.close();
            forage._dbInfo.db = null;
        }
    }
    dbInfo.db = null;

    return _getOriginalConnection(dbInfo).then(function (db) {
        dbInfo.db = db;
        if (_isUpgradeNeeded(dbInfo)) {
            // Reopen the database for upgrading.
            return _getUpgradedConnection(dbInfo);
        }
        return db;
    }).then(function (db) {
        // store the latest db reference
        // in case the db was upgraded
        dbInfo.db = dbContext.db = db;
        for (var i = 0; i < forages.length; i++) {
            forages[i]._dbInfo.db = db;
        }
    })["catch"](function (err) {
        _rejectReadiness(dbInfo, err);
        throw err;
    });
}

// FF doesn't like Promises (micro-tasks) and IDDB store operations,
// so we have to do it with callbacks
function createTransaction(dbInfo, mode, callback, retries) {
    if (retries === undefined) {
        retries = 1;
    }

    try {
        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
        callback(null, tx);
    } catch (err) {
        if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {
            return Promise$1.resolve().then(function () {
                if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                    // increase the db version, to create the new ObjectStore
                    if (dbInfo.db) {
                        dbInfo.version = dbInfo.db.version + 1;
                    }
                    // Reopen the database for upgrading.
                    return _getUpgradedConnection(dbInfo);
                }
            }).then(function () {
                return _tryReconnect(dbInfo).then(function () {
                    createTransaction(dbInfo, mode, callback, retries - 1);
                });
            })["catch"](callback);
        }

        callback(err);
    }
}

function createDbContext() {
    return {
        // Running localForages sharing a database.
        forages: [],
        // Shared database.
        db: null,
        // Database readiness (promise).
        dbReady: null,
        // Deferred operations on the database.
        deferredOperations: []
    };
}

// Open the IndexedDB database (automatically creates one if one didn't
// previously exist), using any options set in the config.
function _initStorage(options) {
    var self = this;
    var dbInfo = {
        db: null
    };

    if (options) {
        for (var i in options) {
            dbInfo[i] = options[i];
        }
    }

    // Get the current context of the database;
    var dbContext = dbContexts[dbInfo.name];

    // ...or create a new context.
    if (!dbContext) {
        dbContext = createDbContext();
        // Register the new context in the global container.
        dbContexts[dbInfo.name] = dbContext;
    }

    // Register itself as a running localForage in the current context.
    dbContext.forages.push(self);

    // Replace the default `ready()` function with the specialized one.
    if (!self._initReady) {
        self._initReady = self.ready;
        self.ready = _fullyReady;
    }

    // Create an array of initialization states of the related localForages.
    var initPromises = [];

    function ignoreErrors() {
        // Don't handle errors here,
        // just makes sure related localForages aren't pending.
        return Promise$1.resolve();
    }

    for (var j = 0; j < dbContext.forages.length; j++) {
        var forage = dbContext.forages[j];
        if (forage !== self) {
            // Don't wait for itself...
            initPromises.push(forage._initReady()["catch"](ignoreErrors));
        }
    }

    // Take a snapshot of the related localForages.
    var forages = dbContext.forages.slice(0);

    // Initialize the connection process only when
    // all the related localForages aren't pending.
    return Promise$1.all(initPromises).then(function () {
        dbInfo.db = dbContext.db;
        // Get the connection or open a new one without upgrade.
        return _getOriginalConnection(dbInfo);
    }).then(function (db) {
        dbInfo.db = db;
        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {
            // Reopen the database for upgrading.
            return _getUpgradedConnection(dbInfo);
        }
        return db;
    }).then(function (db) {
        dbInfo.db = dbContext.db = db;
        self._dbInfo = dbInfo;
        // Share the final connection amongst related localForages.
        for (var k = 0; k < forages.length; k++) {
            var forage = forages[k];
            if (forage !== self) {
                // Self is already up-to-date.
                forage._dbInfo.db = dbInfo.db;
                forage._dbInfo.version = dbInfo.version;
            }
        }
    });
}

function getItem(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.get(key);

                    req.onsuccess = function () {
                        var value = req.result;
                        if (value === undefined) {
                            value = null;
                        }
                        if (_isEncodedBlob(value)) {
                            value = _decodeBlob(value);
                        }
                        resolve(value);
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Iterate over all items stored in database.
function iterate(iterator, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.openCursor();
                    var iterationNumber = 1;

                    req.onsuccess = function () {
                        var cursor = req.result;

                        if (cursor) {
                            var value = cursor.value;
                            if (_isEncodedBlob(value)) {
                                value = _decodeBlob(value);
                            }
                            var result = iterator(value, cursor.key, iterationNumber++);

                            // when the iterator callback returns any
                            // (non-`undefined`) value, then we stop
                            // the iteration immediately
                            if (result !== void 0) {
                                resolve(result);
                            } else {
                                cursor["continue"]();
                            }
                        } else {
                            resolve();
                        }
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);

    return promise;
}

function setItem(key, value, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        var dbInfo;
        self.ready().then(function () {
            dbInfo = self._dbInfo;
            if (toString.call(value) === '[object Blob]') {
                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {
                    if (blobSupport) {
                        return value;
                    }
                    return _encodeBlob(value);
                });
            }
            return value;
        }).then(function (value) {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);

                    // The reason we don't _save_ null is because IE 10 does
                    // not support saving the `null` type in IndexedDB. How
                    // ironic, given the bug below!
                    // See: https://github.com/mozilla/localForage/issues/161
                    if (value === null) {
                        value = undefined;
                    }

                    var req = store.put(value, key);

                    transaction.oncomplete = function () {
                        // Cast to undefined so the value passed to
                        // callback/promise is the same as what one would get out
                        // of `getItem()` later. This leads to some weirdness
                        // (setItem('foo', undefined) will return `null`), but
                        // it's not my fault localStorage is our baseline and that
                        // it's weird.
                        if (value === undefined) {
                            value = null;
                        }

                        resolve(value);
                    };
                    transaction.onabort = transaction.onerror = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function removeItem(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    // We use a Grunt task to make this safe for IE and some
                    // versions of Android (including those used by Cordova).
                    // Normally IE won't like `.delete()` and will insist on
                    // using `['delete']()`, but we have a build step that
                    // fixes this for us now.
                    var req = store["delete"](key);
                    transaction.oncomplete = function () {
                        resolve();
                    };

                    transaction.onerror = function () {
                        reject(req.error);
                    };

                    // The request will be also be aborted if we've exceeded our storage
                    // space.
                    transaction.onabort = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function clear(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.clear();

                    transaction.oncomplete = function () {
                        resolve();
                    };

                    transaction.onabort = transaction.onerror = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function length(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.count();

                    req.onsuccess = function () {
                        resolve(req.result);
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function key(n, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        if (n < 0) {
            resolve(null);

            return;
        }

        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var advanced = false;
                    var req = store.openKeyCursor();

                    req.onsuccess = function () {
                        var cursor = req.result;
                        if (!cursor) {
                            // this means there weren't enough keys
                            resolve(null);

                            return;
                        }

                        if (n === 0) {
                            // We have the first key, return it if that's what they
                            // wanted.
                            resolve(cursor.key);
                        } else {
                            if (!advanced) {
                                // Otherwise, ask the cursor to skip ahead n
                                // records.
                                advanced = true;
                                cursor.advance(n);
                            } else {
                                // When we get here, we've got the nth key.
                                resolve(cursor.key);
                            }
                        }
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function keys(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.openKeyCursor();
                    var keys = [];

                    req.onsuccess = function () {
                        var cursor = req.result;

                        if (!cursor) {
                            resolve(keys);
                            return;
                        }

                        keys.push(cursor.key);
                        cursor["continue"]();
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function dropInstance(options, callback) {
    callback = getCallback.apply(this, arguments);

    var currentConfig = this.config();
    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;

        var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {
            var dbContext = dbContexts[options.name];
            var forages = dbContext.forages;
            dbContext.db = db;
            for (var i = 0; i < forages.length; i++) {
                forages[i]._dbInfo.db = db;
            }
            return db;
        });

        if (!options.storeName) {
            promise = dbPromise.then(function (db) {
                _deferReadiness(options);

                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;

                db.close();
                for (var i = 0; i < forages.length; i++) {
                    var forage = forages[i];
                    forage._dbInfo.db = null;
                }

                var dropDBPromise = new Promise$1(function (resolve, reject) {
                    var req = idb.deleteDatabase(options.name);

                    req.onerror = req.onblocked = function (err) {
                        var db = req.result;
                        if (db) {
                            db.close();
                        }
                        reject(err);
                    };

                    req.onsuccess = function () {
                        var db = req.result;
                        if (db) {
                            db.close();
                        }
                        resolve(db);
                    };
                });

                return dropDBPromise.then(function (db) {
                    dbContext.db = db;
                    for (var i = 0; i < forages.length; i++) {
                        var _forage = forages[i];
                        _advanceReadiness(_forage._dbInfo);
                    }
                })["catch"](function (err) {
                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                    throw err;
                });
            });
        } else {
            promise = dbPromise.then(function (db) {
                if (!db.objectStoreNames.contains(options.storeName)) {
                    return;
                }

                var newVersion = db.version + 1;

                _deferReadiness(options);

                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;

                db.close();
                for (var i = 0; i < forages.length; i++) {
                    var forage = forages[i];
                    forage._dbInfo.db = null;
                    forage._dbInfo.version = newVersion;
                }

                var dropObjectPromise = new Promise$1(function (resolve, reject) {
                    var req = idb.open(options.name, newVersion);

                    req.onerror = function (err) {
                        var db = req.result;
                        db.close();
                        reject(err);
                    };

                    req.onupgradeneeded = function () {
                        var db = req.result;
                        db.deleteObjectStore(options.storeName);
                    };

                    req.onsuccess = function () {
                        var db = req.result;
                        db.close();
                        resolve(db);
                    };
                });

                return dropObjectPromise.then(function (db) {
                    dbContext.db = db;
                    for (var j = 0; j < forages.length; j++) {
                        var _forage2 = forages[j];
                        _forage2._dbInfo.db = db;
                        _advanceReadiness(_forage2._dbInfo);
                    }
                })["catch"](function (err) {
                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                    throw err;
                });
            });
        }
    }

    executeCallback(promise, callback);
    return promise;
}

var asyncStorage = {
    _driver: 'asyncStorage',
    _initStorage: _initStorage,
    _support: isIndexedDBValid(),
    iterate: iterate,
    getItem: getItem,
    setItem: setItem,
    removeItem: removeItem,
    clear: clear,
    length: length,
    key: key,
    keys: keys,
    dropInstance: dropInstance
};

function isWebSQLValid() {
    return typeof openDatabase === 'function';
}

// Sadly, the best way to save binary data in WebSQL/localStorage is serializing
// it to Base64, so this is how we store it to prevent very strange errors with less
// verbose ways of binary <-> string data storage.
var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

var BLOB_TYPE_PREFIX = '~~local_forage_type~';
var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;

var SERIALIZED_MARKER = '__lfsc__:';
var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;

// OMG the serializations!
var TYPE_ARRAYBUFFER = 'arbf';
var TYPE_BLOB = 'blob';
var TYPE_INT8ARRAY = 'si08';
var TYPE_UINT8ARRAY = 'ui08';
var TYPE_UINT8CLAMPEDARRAY = 'uic8';
var TYPE_INT16ARRAY = 'si16';
var TYPE_INT32ARRAY = 'si32';
var TYPE_UINT16ARRAY = 'ur16';
var TYPE_UINT32ARRAY = 'ui32';
var TYPE_FLOAT32ARRAY = 'fl32';
var TYPE_FLOAT64ARRAY = 'fl64';
var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;

var toString$1 = Object.prototype.toString;

function stringToBuffer(serializedString) {
    // Fill the string into a ArrayBuffer.
    var bufferLength = serializedString.length * 0.75;
    var len = serializedString.length;
    var i;
    var p = 0;
    var encoded1, encoded2, encoded3, encoded4;

    if (serializedString[serializedString.length - 1] === '=') {
        bufferLength--;
        if (serializedString[serializedString.length - 2] === '=') {
            bufferLength--;
        }
    }

    var buffer = new ArrayBuffer(bufferLength);
    var bytes = new Uint8Array(buffer);

    for (i = 0; i < len; i += 4) {
        encoded1 = BASE_CHARS.indexOf(serializedString[i]);
        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);

        /*jslint bitwise: true */
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return buffer;
}

// Converts a buffer to a string to store, serialized, in the backend
// storage library.
function bufferToString(buffer) {
    // base64-arraybuffer
    var bytes = new Uint8Array(buffer);
    var base64String = '';
    var i;

    for (i = 0; i < bytes.length; i += 3) {
        /*jslint bitwise: true */
        base64String += BASE_CHARS[bytes[i] >> 2];
        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
        base64String += BASE_CHARS[bytes[i + 2] & 63];
    }

    if (bytes.length % 3 === 2) {
        base64String = base64String.substring(0, base64String.length - 1) + '=';
    } else if (bytes.length % 3 === 1) {
        base64String = base64String.substring(0, base64String.length - 2) + '==';
    }

    return base64String;
}

// Serialize a value, afterwards executing a callback (which usually
// instructs the `setItem()` callback/promise to be executed). This is how
// we store binary data with localStorage.
function serialize(value, callback) {
    var valueType = '';
    if (value) {
        valueType = toString$1.call(value);
    }

    // Cannot use `value instanceof ArrayBuffer` or such here, as these
    // checks fail when running the tests using casper.js...
    //
    // TODO: See why those tests fail and use a better solution.
    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {
        // Convert binary arrays to a string and prefix the string with
        // a special marker.
        var buffer;
        var marker = SERIALIZED_MARKER;

        if (value instanceof ArrayBuffer) {
            buffer = value;
            marker += TYPE_ARRAYBUFFER;
        } else {
            buffer = value.buffer;

            if (valueType === '[object Int8Array]') {
                marker += TYPE_INT8ARRAY;
            } else if (valueType === '[object Uint8Array]') {
                marker += TYPE_UINT8ARRAY;
            } else if (valueType === '[object Uint8ClampedArray]') {
                marker += TYPE_UINT8CLAMPEDARRAY;
            } else if (valueType === '[object Int16Array]') {
                marker += TYPE_INT16ARRAY;
            } else if (valueType === '[object Uint16Array]') {
                marker += TYPE_UINT16ARRAY;
            } else if (valueType === '[object Int32Array]') {
                marker += TYPE_INT32ARRAY;
            } else if (valueType === '[object Uint32Array]') {
                marker += TYPE_UINT32ARRAY;
            } else if (valueType === '[object Float32Array]') {
                marker += TYPE_FLOAT32ARRAY;
            } else if (valueType === '[object Float64Array]') {
                marker += TYPE_FLOAT64ARRAY;
            } else {
                callback(new Error('Failed to get type for BinaryArray'));
            }
        }

        callback(marker + bufferToString(buffer));
    } else if (valueType === '[object Blob]') {
        // Conver the blob to a binaryArray and then to a string.
        var fileReader = new FileReader();

        fileReader.onload = function () {
            // Backwards-compatible prefix for the blob type.
            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);

            callback(SERIALIZED_MARKER + TYPE_BLOB + str);
        };

        fileReader.readAsArrayBuffer(value);
    } else {
        try {
            callback(JSON.stringify(value));
        } catch (e) {
            console.error("Couldn't convert value into a JSON string: ", value);

            callback(null, e);
        }
    }
}

// Deserialize data we've inserted into a value column/field. We place
// special markers into our strings to mark them as encoded; this isn't
// as nice as a meta field, but it's the only sane thing we can do whilst
// keeping localStorage support intact.
//
// Oftentimes this will just deserialize JSON content, but if we have a
// special marker (SERIALIZED_MARKER, defined above), we will extract
// some kind of arraybuffer/binary data/typed array out of the string.
function deserialize(value) {
    // If we haven't marked this string as being specially serialized (i.e.
    // something other than serialized JSON), we can just return it and be
    // done with it.
    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
        return JSON.parse(value);
    }

    // The following code deals with deserializing some kind of Blob or
    // TypedArray. First we separate out the type of data we're dealing
    // with from the data itself.
    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);

    var blobType;
    // Backwards-compatible blob type serialization strategy.
    // DBs created with older versions of localForage will simply not have the blob type.
    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
        blobType = matcher[1];
        serializedString = serializedString.substring(matcher[0].length);
    }
    var buffer = stringToBuffer(serializedString);

    // Return the right type based on the code/type set during
    // serialization.
    switch (type) {
        case TYPE_ARRAYBUFFER:
            return buffer;
        case TYPE_BLOB:
            return createBlob([buffer], { type: blobType });
        case TYPE_INT8ARRAY:
            return new Int8Array(buffer);
        case TYPE_UINT8ARRAY:
            return new Uint8Array(buffer);
        case TYPE_UINT8CLAMPEDARRAY:
            return new Uint8ClampedArray(buffer);
        case TYPE_INT16ARRAY:
            return new Int16Array(buffer);
        case TYPE_UINT16ARRAY:
            return new Uint16Array(buffer);
        case TYPE_INT32ARRAY:
            return new Int32Array(buffer);
        case TYPE_UINT32ARRAY:
            return new Uint32Array(buffer);
        case TYPE_FLOAT32ARRAY:
            return new Float32Array(buffer);
        case TYPE_FLOAT64ARRAY:
            return new Float64Array(buffer);
        default:
            throw new Error('Unkown type: ' + type);
    }
}

var localforageSerializer = {
    serialize: serialize,
    deserialize: deserialize,
    stringToBuffer: stringToBuffer,
    bufferToString: bufferToString
};

/*
 * Includes code from:
 *
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */

function createDbTable(t, dbInfo, callback, errorCallback) {
    t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);
}

// Open the WebSQL database (automatically creates one if one didn't
// previously exist), using any options set in the config.
function _initStorage$1(options) {
    var self = this;
    var dbInfo = {
        db: null
    };

    if (options) {
        for (var i in options) {
            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];
        }
    }

    var dbInfoPromise = new Promise$1(function (resolve, reject) {
        // Open the database; the openDatabase API will automatically
        // create it for us if it doesn't exist.
        try {
            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
        } catch (e) {
            return reject(e);
        }

        // Create our key/value table if it doesn't exist.
        dbInfo.db.transaction(function (t) {
            createDbTable(t, dbInfo, function () {
                self._dbInfo = dbInfo;
                resolve();
            }, function (t, error) {
                reject(error);
            });
        }, reject);
    });

    dbInfo.serializer = localforageSerializer;
    return dbInfoPromise;
}

function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
    t.executeSql(sqlStatement, args, callback, function (t, error) {
        if (error.code === error.SYNTAX_ERR) {
            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name = ?", [dbInfo.storeName], function (t, results) {
                if (!results.rows.length) {
                    // if the table is missing (was deleted)
                    // re-create it table and retry
                    createDbTable(t, dbInfo, function () {
                        t.executeSql(sqlStatement, args, callback, errorCallback);
                    }, errorCallback);
                } else {
                    errorCallback(t, error);
                }
            }, errorCallback);
        } else {
            errorCallback(t, error);
        }
    }, errorCallback);
}

function getItem$1(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {
                    var result = results.rows.length ? results.rows.item(0).value : null;

                    // Check to see if this is serialized content we need to
                    // unpack.
                    if (result) {
                        result = dbInfo.serializer.deserialize(result);
                    }

                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function iterate$1(iterator, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;

            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {
                    var rows = results.rows;
                    var length = rows.length;

                    for (var i = 0; i < length; i++) {
                        var item = rows.item(i);
                        var result = item.value;

                        // Check to see if this is serialized content
                        // we need to unpack.
                        if (result) {
                            result = dbInfo.serializer.deserialize(result);
                        }

                        result = iterator(result, item.key, i + 1);

                        // void(0) prevents problems with redefinition
                        // of `undefined`.
                        if (result !== void 0) {
                            resolve(result);
                            return;
                        }
                    }

                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function _setItem(key, value, callback, retriesLeft) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            // The localStorage API doesn't return undefined values in an
            // "expected" way, so undefined is always cast to null in all
            // drivers. See: https://github.com/mozilla/localForage/pull/42
            if (value === undefined) {
                value = null;
            }

            // Save the original value to pass to the callback.
            var originalValue = value;

            var dbInfo = self._dbInfo;
            dbInfo.serializer.serialize(value, function (value, error) {
                if (error) {
                    reject(error);
                } else {
                    dbInfo.db.transaction(function (t) {
                        tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {
                            resolve(originalValue);
                        }, function (t, error) {
                            reject(error);
                        });
                    }, function (sqlError) {
                        // The transaction failed; check
                        // to see if it's a quota error.
                        if (sqlError.code === sqlError.QUOTA_ERR) {
                            // We reject the callback outright for now, but
                            // it's worth trying to re-run the transaction.
                            // Even if the user accepts the prompt to use
                            // more storage on Safari, this error will
                            // be called.
                            //
                            // Try to re-run the transaction.
                            if (retriesLeft > 0) {
                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));
                                return;
                            }
                            reject(sqlError);
                        }
                    });
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function setItem$1(key, value, callback) {
    return _setItem.apply(this, [key, value, callback, 1]);
}

function removeItem$1(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {
                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Deletes every item in the table.
// TODO: Find out if this resets the AUTO_INCREMENT number.
function clear$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {
                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Does a simple `COUNT(key)` to get the number of items stored in
// localForage.
function length$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                // Ahhh, SQL makes this one soooooo easy.
                tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {
                    var result = results.rows.item(0).c;
                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Return the key located at key index X; essentially gets the key from a
// `WHERE id = ?`. This is the most efficient way I can think to implement
// this rarely-used (in my experience) part of the API, but it can seem
// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so
// the ID of each key will change every time it's updated. Perhaps a stored
// procedure for the `setItem()` SQL would solve this problem?
// TODO: Don't change ID on `setItem()`.
function key$1(n, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {
                    var result = results.rows.length ? results.rows.item(0).key : null;
                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function keys$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {
                    var keys = [];

                    for (var i = 0; i < results.rows.length; i++) {
                        keys.push(results.rows.item(i).key);
                    }

                    resolve(keys);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// https://www.w3.org/TR/webdatabase/#databases
// > There is no way to enumerate or delete the databases available for an origin from this API.
function getAllStoreNames(db) {
    return new Promise$1(function (resolve, reject) {
        db.transaction(function (t) {
            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (t, results) {
                var storeNames = [];

                for (var i = 0; i < results.rows.length; i++) {
                    storeNames.push(results.rows.item(i).name);
                }

                resolve({
                    db: db,
                    storeNames: storeNames
                });
            }, function (t, error) {
                reject(error);
            });
        }, function (sqlError) {
            reject(sqlError);
        });
    });
}

function dropInstance$1(options, callback) {
    callback = getCallback.apply(this, arguments);

    var currentConfig = this.config();
    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        promise = new Promise$1(function (resolve) {
            var db;
            if (options.name === currentConfig.name) {
                // use the db reference of the current instance
                db = self._dbInfo.db;
            } else {
                db = openDatabase(options.name, '', '', 0);
            }

            if (!options.storeName) {
                // drop all database tables
                resolve(getAllStoreNames(db));
            } else {
                resolve({
                    db: db,
                    storeNames: [options.storeName]
                });
            }
        }).then(function (operationInfo) {
            return new Promise$1(function (resolve, reject) {
                operationInfo.db.transaction(function (t) {
                    function dropTable(storeName) {
                        return new Promise$1(function (resolve, reject) {
                            t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {
                                resolve();
                            }, function (t, error) {
                                reject(error);
                            });
                        });
                    }

                    var operations = [];
                    for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                        operations.push(dropTable(operationInfo.storeNames[i]));
                    }

                    Promise$1.all(operations).then(function () {
                        resolve();
                    })["catch"](function (e) {
                        reject(e);
                    });
                }, function (sqlError) {
                    reject(sqlError);
                });
            });
        });
    }

    executeCallback(promise, callback);
    return promise;
}

var webSQLStorage = {
    _driver: 'webSQLStorage',
    _initStorage: _initStorage$1,
    _support: isWebSQLValid(),
    iterate: iterate$1,
    getItem: getItem$1,
    setItem: setItem$1,
    removeItem: removeItem$1,
    clear: clear$1,
    length: length$1,
    key: key$1,
    keys: keys$1,
    dropInstance: dropInstance$1
};

function isLocalStorageValid() {
    try {
        return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&
        // in IE8 typeof localStorage.setItem === 'object'
        !!localStorage.setItem;
    } catch (e) {
        return false;
    }
}

function _getKeyPrefix(options, defaultConfig) {
    var keyPrefix = options.name + '/';

    if (options.storeName !== defaultConfig.storeName) {
        keyPrefix += options.storeName + '/';
    }
    return keyPrefix;
}

// Check if localStorage throws when saving an item
function checkIfLocalStorageThrows() {
    var localStorageTestKey = '_localforage_support_test';

    try {
        localStorage.setItem(localStorageTestKey, true);
        localStorage.removeItem(localStorageTestKey);

        return false;
    } catch (e) {
        return true;
    }
}

// Check if localStorage is usable and allows to save an item
// This method checks if localStorage is usable in Safari Private Browsing
// mode, or in any other case where the available quota for localStorage
// is 0 and there wasn't any saved items yet.
function _isLocalStorageUsable() {
    return !checkIfLocalStorageThrows() || localStorage.length > 0;
}

// Config the localStorage backend, using options set in the config.
function _initStorage$2(options) {
    var self = this;
    var dbInfo = {};
    if (options) {
        for (var i in options) {
            dbInfo[i] = options[i];
        }
    }

    dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);

    if (!_isLocalStorageUsable()) {
        return Promise$1.reject();
    }

    self._dbInfo = dbInfo;
    dbInfo.serializer = localforageSerializer;

    return Promise$1.resolve();
}

// Remove all keys from the datastore, effectively destroying all data in
// the app's key/value store!
function clear$2(callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var keyPrefix = self._dbInfo.keyPrefix;

        for (var i = localStorage.length - 1; i >= 0; i--) {
            var key = localStorage.key(i);

            if (key.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key);
            }
        }
    });

    executeCallback(promise, callback);
    return promise;
}

// Retrieve an item from the store. Unlike the original async_storage
// library in Gaia, we don't modify return values at all. If a key's value
// is `undefined`, we pass that value to the callback function.
function getItem$2(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var result = localStorage.getItem(dbInfo.keyPrefix + key);

        // If a result was found, parse it from the serialized
        // string into a JS object. If result isn't truthy, the key
        // is likely undefined and we'll pass it straight to the
        // callback.
        if (result) {
            result = dbInfo.serializer.deserialize(result);
        }

        return result;
    });

    executeCallback(promise, callback);
    return promise;
}

// Iterate over all items in the store.
function iterate$2(iterator, callback) {
    var self = this;

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var keyPrefix = dbInfo.keyPrefix;
        var keyPrefixLength = keyPrefix.length;
        var length = localStorage.length;

        // We use a dedicated iterator instead of the `i` variable below
        // so other keys we fetch in localStorage aren't counted in
        // the `iterationNumber` argument passed to the `iterate()`
        // callback.
        //
        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530
        var iterationNumber = 1;

        for (var i = 0; i < length; i++) {
            var key = localStorage.key(i);
            if (key.indexOf(keyPrefix) !== 0) {
                continue;
            }
            var value = localStorage.getItem(key);

            // If a result was found, parse it from the serialized
            // string into a JS object. If result isn't truthy, the
            // key is likely undefined and we'll pass it straight
            // to the iterator.
            if (value) {
                value = dbInfo.serializer.deserialize(value);
            }

            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);

            if (value !== void 0) {
                return value;
            }
        }
    });

    executeCallback(promise, callback);
    return promise;
}

// Same as localStorage's key() method, except takes a callback.
function key$2(n, callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var result;
        try {
            result = localStorage.key(n);
        } catch (error) {
            result = null;
        }

        // Remove the prefix from the key, if a key is found.
        if (result) {
            result = result.substring(dbInfo.keyPrefix.length);
        }

        return result;
    });

    executeCallback(promise, callback);
    return promise;
}

function keys$2(callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var length = localStorage.length;
        var keys = [];

        for (var i = 0; i < length; i++) {
            var itemKey = localStorage.key(i);
            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                keys.push(itemKey.substring(dbInfo.keyPrefix.length));
            }
        }

        return keys;
    });

    executeCallback(promise, callback);
    return promise;
}

// Supply the number of keys in the datastore to the callback function.
function length$2(callback) {
    var self = this;
    var promise = self.keys().then(function (keys) {
        return keys.length;
    });

    executeCallback(promise, callback);
    return promise;
}

// Remove an item from the store, nice and simple.
function removeItem$2(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        localStorage.removeItem(dbInfo.keyPrefix + key);
    });

    executeCallback(promise, callback);
    return promise;
}

// Set a key's value and run an optional callback once the value is set.
// Unlike Gaia's implementation, the callback function is passed the value,
// in case you want to operate on that value only after you're sure it
// saved, or something like that.
function setItem$2(key, value, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        // Convert undefined values to null.
        // https://github.com/mozilla/localForage/pull/42
        if (value === undefined) {
            value = null;
        }

        // Save the original value to pass to the callback.
        var originalValue = value;

        return new Promise$1(function (resolve, reject) {
            var dbInfo = self._dbInfo;
            dbInfo.serializer.serialize(value, function (value, error) {
                if (error) {
                    reject(error);
                } else {
                    try {
                        localStorage.setItem(dbInfo.keyPrefix + key, value);
                        resolve(originalValue);
                    } catch (e) {
                        // localStorage capacity exceeded.
                        // TODO: Make this a specific error/event.
                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                            reject(e);
                        }
                        reject(e);
                    }
                }
            });
        });
    });

    executeCallback(promise, callback);
    return promise;
}

function dropInstance$2(options, callback) {
    callback = getCallback.apply(this, arguments);

    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        var currentConfig = this.config();
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        promise = new Promise$1(function (resolve) {
            if (!options.storeName) {
                resolve(options.name + '/');
            } else {
                resolve(_getKeyPrefix(options, self._defaultConfig));
            }
        }).then(function (keyPrefix) {
            for (var i = localStorage.length - 1; i >= 0; i--) {
                var key = localStorage.key(i);

                if (key.indexOf(keyPrefix) === 0) {
                    localStorage.removeItem(key);
                }
            }
        });
    }

    executeCallback(promise, callback);
    return promise;
}

var localStorageWrapper = {
    _driver: 'localStorageWrapper',
    _initStorage: _initStorage$2,
    _support: isLocalStorageValid(),
    iterate: iterate$2,
    getItem: getItem$2,
    setItem: setItem$2,
    removeItem: removeItem$2,
    clear: clear$2,
    length: length$2,
    key: key$2,
    keys: keys$2,
    dropInstance: dropInstance$2
};

var sameValue = function sameValue(x, y) {
    return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);
};

var includes = function includes(array, searchElement) {
    var len = array.length;
    var i = 0;
    while (i < len) {
        if (sameValue(array[i], searchElement)) {
            return true;
        }
        i++;
    }

    return false;
};

var isArray = Array.isArray || function (arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
};

// Drivers are stored here when `defineDriver()` is called.
// They are shared across all instances of localForage.
var DefinedDrivers = {};

var DriverSupport = {};

var DefaultDrivers = {
    INDEXEDDB: asyncStorage,
    WEBSQL: webSQLStorage,
    LOCALSTORAGE: localStorageWrapper
};

var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];

var OptionalDriverMethods = ['dropInstance'];

var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);

var DefaultConfig = {
    description: '',
    driver: DefaultDriverOrder.slice(),
    name: 'localforage',
    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
    // we can use without a prompt.
    size: 4980736,
    storeName: 'keyvaluepairs',
    version: 1.0
};

function callWhenReady(localForageInstance, libraryMethod) {
    localForageInstance[libraryMethod] = function () {
        var _args = arguments;
        return localForageInstance.ready().then(function () {
            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
        });
    };
}

function extend() {
    for (var i = 1; i < arguments.length; i++) {
        var arg = arguments[i];

        if (arg) {
            for (var _key in arg) {
                if (arg.hasOwnProperty(_key)) {
                    if (isArray(arg[_key])) {
                        arguments[0][_key] = arg[_key].slice();
                    } else {
                        arguments[0][_key] = arg[_key];
                    }
                }
            }
        }
    }

    return arguments[0];
}

var LocalForage = function () {
    function LocalForage(options) {
        _classCallCheck(this, LocalForage);

        for (var driverTypeKey in DefaultDrivers) {
            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                var driver = DefaultDrivers[driverTypeKey];
                var driverName = driver._driver;
                this[driverTypeKey] = driverName;

                if (!DefinedDrivers[driverName]) {
                    // we don't need to wait for the promise,
                    // since the default drivers can be defined
                    // in a blocking manner
                    this.defineDriver(driver);
                }
            }
        }

        this._defaultConfig = extend({}, DefaultConfig);
        this._config = extend({}, this._defaultConfig, options);
        this._driverSet = null;
        this._initDriver = null;
        this._ready = false;
        this._dbInfo = null;

        this._wrapLibraryMethodsWithReady();
        this.setDriver(this._config.driver)["catch"](function () {});
    }

    // Set any config values for localForage; can be called anytime before
    // the first API call (e.g. `getItem`, `setItem`).
    // We loop through options so we don't overwrite existing config
    // values.


    LocalForage.prototype.config = function config(options) {
        // If the options argument is an object, we use it to set values.
        // Otherwise, we return either a specified config value or all
        // config values.
        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
            // If localforage is ready and fully initialized, we can't set
            // any new configuration values. Instead, we return an error.
            if (this._ready) {
                return new Error("Can't call config() after localforage " + 'has been used.');
            }

            for (var i in options) {
                if (i === 'storeName') {
                    options[i] = options[i].replace(/\W/g, '_');
                }

                if (i === 'version' && typeof options[i] !== 'number') {
                    return new Error('Database version must be a number.');
                }

                this._config[i] = options[i];
            }

            // after all config options are set and
            // the driver option is used, try setting it
            if ('driver' in options && options.driver) {
                return this.setDriver(this._config.driver);
            }

            return true;
        } else if (typeof options === 'string') {
            return this._config[options];
        } else {
            return this._config;
        }
    };

    // Used to define a custom driver, shared across all instances of
    // localForage.


    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
        var promise = new Promise$1(function (resolve, reject) {
            try {
                var driverName = driverObject._driver;
                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');

                // A driver name should be defined and not overlap with the
                // library-defined, default drivers.
                if (!driverObject._driver) {
                    reject(complianceError);
                    return;
                }

                var driverMethods = LibraryMethods.concat('_initStorage');
                for (var i = 0, len = driverMethods.length; i < len; i++) {
                    var driverMethodName = driverMethods[i];

                    // when the property is there,
                    // it should be a method even when optional
                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {
                        reject(complianceError);
                        return;
                    }
                }

                var configureMissingMethods = function configureMissingMethods() {
                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {
                        return function () {
                            var error = new Error('Method ' + methodName + ' is not implemented by the current driver');
                            var promise = Promise$1.reject(error);
                            executeCallback(promise, arguments[arguments.length - 1]);
                            return promise;
                        };
                    };

                    for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                        var optionalDriverMethod = OptionalDriverMethods[_i];
                        if (!driverObject[optionalDriverMethod]) {
                            driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                        }
                    }
                };

                configureMissingMethods();

                var setDriverSupport = function setDriverSupport(support) {
                    if (DefinedDrivers[driverName]) {
                        console.info('Redefining LocalForage driver: ' + driverName);
                    }
                    DefinedDrivers[driverName] = driverObject;
                    DriverSupport[driverName] = support;
                    // don't use a then, so that we can define
                    // drivers that have simple _support methods
                    // in a blocking manner
                    resolve();
                };

                if ('_support' in driverObject) {
                    if (driverObject._support && typeof driverObject._support === 'function') {
                        driverObject._support().then(setDriverSupport, reject);
                    } else {
                        setDriverSupport(!!driverObject._support);
                    }
                } else {
                    setDriverSupport(true);
                }
            } catch (e) {
                reject(e);
            }
        });

        executeTwoCallbacks(promise, callback, errorCallback);
        return promise;
    };

    LocalForage.prototype.driver = function driver() {
        return this._driver || null;
    };

    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));

        executeTwoCallbacks(getDriverPromise, callback, errorCallback);
        return getDriverPromise;
    };

    LocalForage.prototype.getSerializer = function getSerializer(callback) {
        var serializerPromise = Promise$1.resolve(localforageSerializer);
        executeTwoCallbacks(serializerPromise, callback);
        return serializerPromise;
    };

    LocalForage.prototype.ready = function ready(callback) {
        var self = this;

        var promise = self._driverSet.then(function () {
            if (self._ready === null) {
                self._ready = self._initDriver();
            }

            return self._ready;
        });

        executeTwoCallbacks(promise, callback, callback);
        return promise;
    };

    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
        var self = this;

        if (!isArray(drivers)) {
            drivers = [drivers];
        }

        var supportedDrivers = this._getSupportedDrivers(drivers);

        function setDriverToConfig() {
            self._config.driver = self.driver();
        }

        function extendSelfWithDriver(driver) {
            self._extend(driver);
            setDriverToConfig();

            self._ready = self._initStorage(self._config);
            return self._ready;
        }

        function initDriver(supportedDrivers) {
            return function () {
                var currentDriverIndex = 0;

                function driverPromiseLoop() {
                    while (currentDriverIndex < supportedDrivers.length) {
                        var driverName = supportedDrivers[currentDriverIndex];
                        currentDriverIndex++;

                        self._dbInfo = null;
                        self._ready = null;

                        return self.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                    }

                    setDriverToConfig();
                    var error = new Error('No available storage method found.');
                    self._driverSet = Promise$1.reject(error);
                    return self._driverSet;
                }

                return driverPromiseLoop();
            };
        }

        // There might be a driver initialization in progress
        // so wait for it to finish in order to avoid a possible
        // race condition to set _dbInfo
        var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function () {
            return Promise$1.resolve();
        }) : Promise$1.resolve();

        this._driverSet = oldDriverSetDone.then(function () {
            var driverName = supportedDrivers[0];
            self._dbInfo = null;
            self._ready = null;

            return self.getDriver(driverName).then(function (driver) {
                self._driver = driver._driver;
                setDriverToConfig();
                self._wrapLibraryMethodsWithReady();
                self._initDriver = initDriver(supportedDrivers);
            });
        })["catch"](function () {
            setDriverToConfig();
            var error = new Error('No available storage method found.');
            self._driverSet = Promise$1.reject(error);
            return self._driverSet;
        });

        executeTwoCallbacks(this._driverSet, callback, errorCallback);
        return this._driverSet;
    };

    LocalForage.prototype.supports = function supports(driverName) {
        return !!DriverSupport[driverName];
    };

    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {
        extend(this, libraryMethodsAndProperties);
    };

    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
        var supportedDrivers = [];
        for (var i = 0, len = drivers.length; i < len; i++) {
            var driverName = drivers[i];
            if (this.supports(driverName)) {
                supportedDrivers.push(driverName);
            }
        }
        return supportedDrivers;
    };

    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
        // Add a stub for each driver API method that delays the call to the
        // corresponding driver method until localForage is ready. These stubs
        // will be replaced by the driver methods as soon as the driver is
        // loaded, so there is no performance impact.
        for (var i = 0, len = LibraryMethods.length; i < len; i++) {
            callWhenReady(this, LibraryMethods[i]);
        }
    };

    LocalForage.prototype.createInstance = function createInstance(options) {
        return new LocalForage(options);
    };

    return LocalForage;
}();

// The actual localForage object that we expose as a module or via a
// global. It's extended by pulling in one of our other libraries.


var localforage_js = new LocalForage();

module.exports = localforage_js;

},{"3":3}]},{},[4])(4)
});

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_154248__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};


/***/ }),

/***/ "./node_modules/protobufjs/minimal.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_287605__) {

"use strict";
// minimal library entry point.


module.exports = __nested_webpack_require_287605__(/*! ./src/index-minimal */ "./node_modules/protobufjs/src/index-minimal.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_288104__) {

"use strict";

var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = __nested_webpack_require_288104__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
protobuf.BufferWriter = __nested_webpack_require_288104__(/*! ./writer_buffer */ "./node_modules/protobufjs/src/writer_buffer.js");
protobuf.Reader       = __nested_webpack_require_288104__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
protobuf.BufferReader = __nested_webpack_require_288104__(/*! ./reader_buffer */ "./node_modules/protobufjs/src/reader_buffer.js");

// Utility
protobuf.util         = __nested_webpack_require_288104__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");
protobuf.rpc          = __nested_webpack_require_288104__(/*! ./rpc */ "./node_modules/protobufjs/src/rpc.js");
protobuf.roots        = __nested_webpack_require_288104__(/*! ./roots */ "./node_modules/protobufjs/src/roots.js");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_289767__) {

"use strict";

module.exports = Reader;

var util      = __nested_webpack_require_289767__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};


/***/ }),

/***/ "./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_301432__) {

"use strict";

module.exports = BufferReader;

// extends Reader
var Reader = __nested_webpack_require_301432__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = __nested_webpack_require_301432__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_303865__) {

"use strict";


/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = __nested_webpack_require_303865__(/*! ./rpc/service */ "./node_modules/protobufjs/src/rpc/service.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_305462__) {

"use strict";

module.exports = Service;

var util = __nested_webpack_require_305462__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_310627__) {

"use strict";

module.exports = LongBits;

var util = __nested_webpack_require_310627__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_316418__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = __nested_webpack_require_316418__(/*! @protobufjs/aspromise */ "./node_modules/@protobufjs/aspromise/index.js");

// converts to / from base64 encoded strings
util.base64 = __nested_webpack_require_316418__(/*! @protobufjs/base64 */ "./node_modules/@protobufjs/base64/index.js");

// base class of rpc.Service
util.EventEmitter = __nested_webpack_require_316418__(/*! @protobufjs/eventemitter */ "./node_modules/@protobufjs/eventemitter/index.js");

// float handling accross browsers
util.float = __nested_webpack_require_316418__(/*! @protobufjs/float */ "./node_modules/@protobufjs/float/index.js");

// requires modules optionally and hides the call from bundlers
util.inquire = __nested_webpack_require_316418__(/*! @protobufjs/inquire */ "./node_modules/@protobufjs/inquire/index.js");

// converts to / from utf8 encoded strings
util.utf8 = __nested_webpack_require_316418__(/*! @protobufjs/utf8 */ "./node_modules/@protobufjs/utf8/index.js");

// provides a node-like buffer pool in the browser
util.pool = __nested_webpack_require_316418__(/*! @protobufjs/pool */ "./node_modules/@protobufjs/pool/index.js");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = __nested_webpack_require_316418__(/*! ./longbits */ "./node_modules/protobufjs/src/util/longbits.js");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_316418__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_330123__) {

"use strict";

module.exports = Writer;

var util      = __nested_webpack_require_330123__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};


/***/ }),

/***/ "./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_342597__) {

"use strict";

module.exports = BufferWriter;

// extends Writer
var Writer = __nested_webpack_require_342597__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = __nested_webpack_require_342597__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/zego-setting/ZegoSetting.js":
/*!**************************************************!*\
  !*** ./node_modules/zego-setting/ZegoSetting.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_346122__) {

!function(e,t){if(true)module.exports=t(__nested_webpack_require_346122__(/*! localforage */ "./node_modules/localforage/dist/localforage.js"));else { var n, i; }}("undefined"!=typeof self?self:this,(function(e){return i={},t.m=n=[function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ZEGO_SETTING_ACTION=void 0,(t=t.ZEGO_SETTING_ACTION||(t.ZEGO_SETTING_ACTION={})).CONSTRUCTOR="zs.0",t.SETTING_INIT="zs.ii.0",t.SETTING_FETCH_SETTING="zs.fs.0",t.SETTING__FETCH_SETTING="zs.fs.1",t.SETTING_GET_CLOUD_SETTING="zs.gcs.0",t.SETTING_POLLING_SETTING="zs.ps.0",t.SETTINGCACHEHANDLER_GET_CACHE_SETTING="zs.sch.gcs.0",t.SETTINGCACHEHANDLER_STORE_SETTING="zs.sch.ss.0",t.SETTINGFETCHHANDLER_FETCHSETTING="zs.sfh.fs.0"},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.errorList=void 0,t.errorList={NOT_INIT:{code:1001,msg:"not init"},FILE_REQUEST_FAIL:{code:1002,msg:"fetch request fail"},INFLATE_DATA_FAIL:{code:1003,msg:"inflate fail"},MULTI_FILE_NOT_EXIST:{code:1004,msg:"get multi file fail"}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.generateUUID=t.checkValidNumber=t.analyzeKey=t.getCurrentTime=t.getBrowser=void 0,t.getBrowser=function(){var e=window.navigator.userAgent,t=null!=window.ActiveXObject&&-1!=e.indexOf("MSIE"),n=-1!=e.indexOf("Firefox"),i=null!=window.opr,r=e.indexOf("Chrome")&&window.chrome,o=-1!=e.indexOf("Safari")&&-1!=e.indexOf("Version");e=e.toLowerCase().match(/MicroMessenger/i)&&"micromessenger"===e.toLowerCase().match(/MicroMessenger/i)[0];return t?"IE":n?"FIREFOX":i?"OPERA":r?"CHROME":o?"SAFARI":e?"WEIXIN":"UNKOWN"};var i=["00","01","02","03","04","05","06","07","08","09"];t.getCurrentTime=function(){var e=new Date;return[e.getFullYear()+"/",(i[e.getMonth()+1]||e.getMonth()+1)+"/",(i[e.getDate()]||e.getDate())+" ",(i[e.getHours()]||e.getHours())+":",(i[e.getMinutes()]||e.getMinutes())+":",i[e.getSeconds()]||e.getSeconds(),"."+e.getTime()%1e3].join("")},t.analyzeKey=function(e){return e=e.split("_"),{level:Number(e[0]),timestamp:e[1],seq:e[2]}},t.checkValidNumber=function(e,t,n){return t=t||1,n=n||1e4,"number"==typeof e&&e%1==0&&t<=e&&e<=n},t.generateUUID=function(e){if(0===(e=void 0===e?0:e)?n=localStorage.getItem("z_deviceID"):wx.getStorageSync("z_deviceID"),n)return n;var t=(new Date).getTime(),n="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(function(e){var n=(t+16*Math.random())%16|0;return t=Math.floor(t/16),("x"==e?n:3&n|8).toString(36)}));return 0===e?localStorage.setItem("z_deviceID",n):wx.setStorageSync("z_deviceID",n),n}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ZegoSetting=void 0;var i=n(4);Object.defineProperty(t,"ZegoSetting",{enumerable:!0,get:function(){return i.ZegoSetting}})},function(e,t,n){"use strict";var i=this&&this.__assign||function(){return(i=Object.assign||function(e){for(var t,n=1,i=arguments.length;n<i;n++)for(var r in t=arguments[n])Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e}).apply(this,arguments)},r=this&&this.__awaiter||function(e,t,n,i){return new(n=n||Promise)((function(r,o){function s(e){try{l(i.next(e))}catch(e){o(e)}}function a(e){try{l(i.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?r(e.value):((t=e.value)instanceof n?t:new n((function(e){e(t)}))).then(s,a)}l((i=i.apply(e,t||[])).next())}))},o=this&&this.__generator||function(e,t){var n,i,r,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]},s={next:a(0),throw:a(1),return:a(2)};return"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function a(s){return function(a){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,i&&(r=2&s[0]?i.return:s[0]?i.throw||((r=i.return)&&r.call(i),0):i.next)&&!(r=r.call(i,s[1])).done)return r;switch(i=0,(s=r?[2&s[0],r.value]:s)[0]){case 0:case 1:r=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,i=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(r=0<(r=o.trys).length&&r[r.length-1])&&(6===s[0]||2===s[0])){o=0;continue}if(3===s[0]&&(!r||s[1]>r[0]&&s[1]<r[3])){o.label=s[1];break}if(6===s[0]&&o.label<r[1]){o.label=r[1],r=s;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(s);break}r[2]&&o.ops.pop(),o.trys.pop();continue}s=t.call(e,o)}catch(e){s=[6,e],i=0}finally{n=r=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,a])}}};Object.defineProperty(t,"__esModule",{value:!0}),t.ZegoSetting=void 0;var s=n(5),a=n(6),l=n(10),c=n(0),u=n(12),f=n(1),h=n(2);Object.defineProperty(g.prototype,"envVariable",{get:function(){return Object.assign({},this.publicEnvVariable,this.proEnvVariable)},enumerable:!1,configurable:!0}),g.prototype.init=function(e){var t=this;return e.pollingFreq&&!h.checkValidNumber(e.pollingFreq)?(this.log.error(c.ZEGO_SETTING_ACTION.SETTING_INIT+" pollingFreq must be integer number"),!1):(this.options=Object.assign({},u.INIT_CONFIG,e),this.getPublicEnvVariable(),this.settingFetchHandler=new l.SettingFetchHandler(this.options,this.log),this.settingFetchHandler.setDataReport(this.options.reportNotify),e=Math.round(60*Math.random()),this.log.info(c.ZEGO_SETTING_ACTION.SETTING_INIT+" delay "+e),this.delayTimer&&(clearTimeout(this.delayTimer),this.delayTimer=null),this.options.pollingFreq&&60<=this.options.pollingFreq&&(this.pollingInterval=this.options.pollingFreq),this.delayTimer=setTimeout((function(){t.pollingSetting(1e3*t.pollingInterval)}),1e3*e),this.settingCacheHandler=new a.SettingCacheHandler("setting_"+(this.options.online?"online_":"test_")+this.options.product+"_"+this.options.appID,this.log,this.options.env),this.inited=!0)},g.prototype.uninit=function(){this.pollingTimer&&(clearTimeout(this.pollingTimer),this.pollingTimer=null)},g.prototype.setEnvVariable=function(e,t){this.proEnvVariable[e]=String(t)},g.prototype.getEnvVariable=function(e){return this.envVariable[e]},g.prototype.setEnvVariables=function(e){var t=this;Object.keys(e).forEach((function(n){"string"!=typeof e[n]&&"number"!=typeof e[n]&&t.log.error("zs.sev env "+n+" type error"),t.proEnvVariable[n]=String(e[n])}))},g.prototype.getEnvVariables=function(){return this.envVariable},g.prototype.enablePolling=function(e,t){var n=this;t?t.forEach((function(t){var i=n.fileList.find((function(e){return e.fileName===t}));i&&(i.needPolling=e)})):this.fileList.forEach((function(t){return t.needPolling=e}))},g.prototype.setToken=function(e){this.token=e},g.prototype.setUserID=function(e){this.userID=e},g.prototype.getSettingCache=function(e){return r(this,void 0,void 0,(function(){var t,n,i;return o(this,(function(r){switch(r.label){case 0:return this.inited?(t=this.fileList.find((function(t){return t.fileName===e})))?[2,Promise.resolve({setting:t.setting,versions:t.versions})]:[3,1]:[2,Promise.reject(f.errorList.NOT_INIT)];case 1:return n=this._getFileName(e),[4,this.settingCacheHandler.getCacheSetting(n)];case 2:return(n=r.sent())&&(this.fileList.find((function(t){return t.fileName===e}))||this.fileList.push({fileName:e,fetchedTime:0,needPolling:!1,setting:n.setting,versions:n.versions}),i={setting:n.setting,versions:n.versions}),[2,Promise.resolve(i)]}}))}))},g.prototype.fetchSetting=function(e,t,n){return void 0===t&&(t={}),void 0===n&&(n=!0),this.log.info(c.ZEGO_SETTING_ACTION.SETTING_FETCH_SETTING+" call "+e),this.inited?(this.activePolling(),0<Object.keys(t).length?(this.log.info(c.ZEGO_SETTING_ACTION.SETTING_FETCH_SETTING+" get file with params"),this._getCloudSetting(e,i(i({},this.envVariable),t))):(t=this.fileList.find((function(t){return t.fileName===e})))?(this.log.info(c.ZEGO_SETTING_ACTION.SETTING_FETCH_SETTING+" file exist"),(new Date).getTime()-t.fetchedTime<1e3*this.pollingInterval?(this.log.info(c.ZEGO_SETTING_ACTION.SETTING_FETCH_SETTING+" fetch time interval in freq"),t.needPolling=n,Promise.resolve({setting:t.setting,versions:t.versions})):this._fetchSetting(e,t,n)):(this.log.info(c.ZEGO_SETTING_ACTION.SETTING_FETCH_SETTING+" file not found"),this._fetchSetting(e,t,n))):Promise.reject(f.errorList.NOT_INIT)},g.prototype.fetchMultiSetting=function(e,t,n){var s=this;return void 0===t&&(t={}),void 0===n&&(n=!0),this.inited?(this.activePolling(),0<Object.keys(t).length?(this.log.info(c.ZEGO_SETTING_ACTION.SETTING_FETCH_SETTING+" get file with params"),this._getCloudSetting(e,i(i({},this.envVariable),t))):new Promise((function(t,i){var a={},l=[];if(e.forEach((function(e){return r(s,void 0,void 0,(function(){var t;return o(this,(function(n){return(t=this.fileList.find((function(t){return t.fileName===e})))?(new Date).getTime()-t.fetchedTime<1e3*this.pollingInterval?(this.log.info(c.ZEGO_SETTING_ACTION.SETTING_FETCH_SETTING+" fetch time interval in freq"),a[e]={setting:t.setting,versions:t.versions}):l.push(e):l.push(e),[2]}))}))})),!(0<l.length))return t(a);s._getCloudSetting(l,s.envVariable).then((function(e){return s.handleFetchFiles(e,n),Object.assign(a,e),t(a)})).catch((function(e){l.forEach((function(e){return r(s,void 0,void 0,(function(){var t;return o(this,(function(i){switch(i.label){case 0:return(t=this.fileList.find((function(t){return t.fileName==e})))?t.fetchedTime=(new Date).getTime():this.fileList.find((function(t){return t.fileName===e}))||this.fileList.push({fileName:e,fetchedTime:(new Date).getTime(),needPolling:n,setting:{},versions:{}}),[4,this.settingCacheHandler.getCacheSetting(e)];case 1:return t=i.sent(),a[e]={setting:t.setting,versions:t.versions},[2]}}))}))})),0<Object.keys(a).length?t(a):i(e)}))}))):Promise.reject(f.errorList.NOT_INIT)},g.prototype.setLog=function(e){this.log=e},g.prototype._getCloudSetting=function(e,t){var n=this;return new Promise((function(i,s){return r(n,void 0,void 0,(function(){var n,r,a,l,u,h;return o(this,(function(o){switch(o.label){case 0:return o.trys.push([0,2,,3]),l=e instanceof Array,[4,this.settingFetchHandler.fetchSetting(l?e:[e],t,this.token,this.userID)];case 1:return r=o.sent(),n=r.data,"number"==typeof(r=r.polling_interval)&&5<=r&&this.pollingInterval!==60*r&&(this.log.warn(c.ZEGO_SETTING_ACTION.SETTING_GET_CLOUD_SETTING+" polling interval change"),this.pollingInterval=60*r,this.uninit(),this.activePolling()),l?(a={},e.forEach((function(e){var t,i;0==(null===(t=n[e])||void 0===t?void 0:t.code)&&void 0!==(null===(i=n[e])||void 0===i?void 0:i.data)&&(a[e]={setting:null===(i=n[e])||void 0===i?void 0:i.data,versions:null===(e=n[e])||void 0===e?void 0:e.versions})})),0<Object.keys(a).length?i(a):s(f.errorList.MULTI_FILE_NOT_EXIST)):0===(null===(l=n[e])||void 0===l?void 0:l.code)&&null!==(u=n[e])&&void 0!==u&&u.data?i({setting:null===(u=n[e])||void 0===u?void 0:u.data,versions:null===(u=n[e])||void 0===u?void 0:u.versions}):s({code:null===(h=n[e])||void 0===h?void 0:h.code,msg:null===(h=n[e])||void 0===h?void 0:h.message}),[3,3];case 2:return h=o.sent(),s(h),this.log.info(c.ZEGO_SETTING_ACTION.SETTING_GET_CLOUD_SETTING+" fail"),[3,3];case 3:return[2]}}))}))}))},g.prototype.handleFetchFiles=function(e,t){var n=this;Object.keys(e).forEach((function(i){var r=n.fileList.find((function(e){return e.fileName==i}));r?(r.fetchedTime=(new Date).getTime(),r.setting=e[i].setting,r.versions=e[i].versions,r.needPolling=t):n.fileList.find((function(e){return e.fileName===i}))||n.fileList.push({fileName:i,fetchedTime:(new Date).getTime(),needPolling:t,setting:e[i].setting,versions:e[i].versions}),r=n._getFileName(i),n.settingCacheHandler.storeSetting(r,e[i])}))},g.prototype._fetchSetting=function(e,t,n){var i=this;return new Promise((function(s,a){i.log.info(c.ZEGO_SETTING_ACTION.SETTING__FETCH_SETTING+" call"),i._getCloudSetting(e,i.envVariable).then((function(r){t?(t.fetchedTime=(new Date).getTime(),t.setting=r.setting,t.versions=r.versions,t.needPolling=n):i.fileList.find((function(t){return t.fileName===e}))||i.fileList.push({fileName:e,fetchedTime:(new Date).getTime(),needPolling:n,setting:r.setting,versions:r.versions});var o=i._getFileName(e);i.settingCacheHandler.storeSetting(o,r),s(r),i.log.info(c.ZEGO_SETTING_ACTION.SETTING__FETCH_SETTING+" call suc")})).catch((function(l){return r(i,void 0,void 0,(function(){var i;return o(this,(function(r){switch(r.label){case 0:t?t.fetchedTime=(new Date).getTime():this.fileList.find((function(t){return t.fileName===e}))||this.fileList.push({fileName:e,fetchedTime:(new Date).getTime(),needPolling:n,setting:{},versions:{}}),i=this._getFileName(e),r.label=1;case 1:return r.trys.push([1,3,,4]),[4,this.settingCacheHandler.getCacheSetting(i)];case 2:return i=r.sent(),s(i),[3,4];case 3:return r.sent(),a(l),[3,4];case 4:return this.log.info(c.ZEGO_SETTING_ACTION.SETTING__FETCH_SETTING+" setting not contain or fetch file fail"),[2]}}))}))}))}))},g.prototype.getPublicEnvVariable=function(){var e;0==this.options.env?(this.publicEnvVariable.userAgent=navigator.userAgent,this.publicEnvVariable.platform=navigator.platform,this.publicEnvVariable.browser=h.getBrowser(),this.publicEnvVariable.deviceid=h.generateUUID()):1==this.options.env&&(e=wx.getSystemInfoSync(),this.publicEnvVariable.brand=e.brand,this.publicEnvVariable.model=e.model,this.publicEnvVariable.system=e.system,this.publicEnvVariable.platform=e.platform,this.publicEnvVariable.wechatVersion=e.version,this.publicEnvVariable.wechatSDKVersion=e.SDKVersion,this.publicEnvVariable.deviceid=h.generateUUID(this.options.env))},g.prototype.pollingSetting=function(e){return r(this,void 0,void 0,(function(){var t,n,i,s,a=this;return o(this,(function(l){switch(l.label){case 0:if(this.log.info(c.ZEGO_SETTING_ACTION.SETTING_POLLING_SETTING+" call "+e),t=[],this.fileList.forEach((function(e){e.fileName,e.needPolling&&t.push(e.fileName)})),n=e,!(0<t.length))return[3,5];l.label=1;case 1:return l.trys.push([1,3,,4]),[4,this.settingFetchHandler.fetchSetting(t,this.envVariable,this.token,this.userID)];case 2:return s=l.sent(),i=s.data,"number"==typeof(s=s.polling_interval)&&5<=s&&this.pollingInterval!==60*s&&(this.log.warn(c.ZEGO_SETTING_ACTION.SETTING_POLLING_SETTING+" polling interval change"),this.pollingInterval=60*s,n=1e3*this.pollingInterval),this.fileList.forEach((function(e){return r(a,void 0,void 0,(function(){var t,n,r,s;return o(this,(function(o){switch(o.label){case 0:return e.fetchedTime=(new Date).getTime(),t=this._getFileName(e.fileName),i[e.fileName]&&0===i[e.fileName].code&&i[e.fileName].data?(n=JSON.stringify(i[e.fileName].data),r=JSON.stringify(e.setting),s={setting:i[e.fileName].data,versions:null===(s=i[e.fileName])||void 0===s?void 0:s.versions},r!==n&&(this.log.info(c.ZEGO_SETTING_ACTION.SETTING_POLLING_SETTING+" "+e.fileName+" setting changed"),e.setting=s.setting,e.versions=s.versions,this.options.pollingNotify(e.fileName,s)),[4,this.settingCacheHandler.getCacheSetting(t)]):[3,2];case 1:r=o.sent(),n=JSON.stringify(r),r=JSON.stringify(s),n!==r&&this.settingCacheHandler.storeSetting(t,s),o.label=2;case 2:return[2]}}))}))})),[3,4];case 3:return s=l.sent(),this.log.error(c.ZEGO_SETTING_ACTION.SETTING_POLLING_SETTING+" fetch fail "+JSON.stringify(s)),[3,4];case 4:return[3,6];case 5:this.log.info(c.ZEGO_SETTING_ACTION.SETTING_POLLING_SETTING+" polling no file"),l.label=6;case 6:return this.pollingTimer&&clearTimeout(this.pollingTimer),this.pollingTimer=setTimeout((function(){a.pollingSetting(n)}),n),[2]}}))}))},g.prototype._getFileName=function(e){return e},g.prototype.activePolling=function(){this.pollingTimer||this.pollingSetting(1e3*this.pollingInterval)},n=g;function g(){this.fileList=[],this.publicEnvVariable={},this.proEnvVariable={},this.pollingTimer=null,this.pollingInterval=300,this.inited=!1,this.log=new s.ZegoLog}t.ZegoSetting=n},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ZegoLog=void 0;var i=(r.prototype.log=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];e.join(" ")},r.prototype.debug=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];e.join(" ")},r.prototype.info=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];e.join(" ")},r.prototype.warn=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];e.join(" ")},r.prototype.error=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];e.join(" ")},r);function r(){}t.ZegoLog=i},function(e,t,n){"use strict";var i=this&&this.__awaiter||function(e,t,n,i){return new(n=n||Promise)((function(r,o){function s(e){try{l(i.next(e))}catch(e){o(e)}}function a(e){try{l(i.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?r(e.value):((t=e.value)instanceof n?t:new n((function(e){e(t)}))).then(s,a)}l((i=i.apply(e,t||[])).next())}))},r=this&&this.__generator||function(e,t){var n,i,r,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]},s={next:a(0),throw:a(1),return:a(2)};return"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function a(s){return function(a){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,i&&(r=2&s[0]?i.return:s[0]?i.throw||((r=i.return)&&r.call(i),0):i.next)&&!(r=r.call(i,s[1])).done)return r;switch(i=0,(s=r?[2&s[0],r.value]:s)[0]){case 0:case 1:r=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,i=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(r=0<(r=o.trys).length&&r[r.length-1])&&(6===s[0]||2===s[0])){o=0;continue}if(3===s[0]&&(!r||s[1]>r[0]&&s[1]<r[3])){o.label=s[1];break}if(6===s[0]&&o.label<r[1]){o.label=r[1],r=s;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(s);break}r[2]&&o.ops.pop(),o.trys.pop();continue}s=t.call(e,o)}catch(e){s=[6,e],i=0}finally{n=r=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,a])}}};Object.defineProperty(t,"__esModule",{value:!0}),t.SettingCacheHandler=void 0;var o=n(0),s=n(7);a.prototype.getCacheSetting=function(e){return i(this,void 0,void 0,(function(){return r(this,(function(t){switch(t.label){case 0:return this.log.info(o.ZEGO_SETTING_ACTION.SETTINGCACHEHANDLER_GET_CACHE_SETTING+" call"),[4,this.store.getItem(e)];case 1:return[2,t.sent()||""]}}))}))},a.prototype.storeSetting=function(e,t){return i(this,void 0,void 0,(function(){return r(this,(function(n){switch(n.label){case 0:return this.log.info(o.ZEGO_SETTING_ACTION.SETTINGCACHEHANDLER_STORE_SETTING+" call"),[4,this.store.setItem(e,t)];case 1:return n.sent(),[2]}}))}))},n=a;function a(e,t,n){void 0===n&&(n=0),this.storeName=e,this.log=t,this.store=s.createZegoStore(e,n)}t.SettingCacheHandler=n},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createZegoStore=t.ZegoWechatMiniStore=void 0;var i=n(8),r=n(9),o=(s.prototype.getItem=function(e){var t=this;return new Promise((function(n,i){try{n(wx.getStorageSync(t.keyPrefix+e))}catch(n){i(n)}}))},s.prototype.setItem=function(e,t){var n=this;return new Promise((function(i,r){try{wx.setStorageSync(n.keyPrefix+e,t),i()}catch(i){r(i)}}))},s.prototype.removeItem=function(e){var t=this;return new Promise((function(n,i){try{n(wx.removeStorageSync(t.keyPrefix+e))}catch(n){i(n)}}))},s.prototype.clear=function(){return new Promise((function(e,t){try{wx.clearStorageSync(),e()}catch(e){t(e)}}))},s.prototype.keys=function(){var e=this;return new Promise((function(t,n){try{var i=wx.getStorageInfoSync().keys,r=[];i.forEach((function(t){0==t.indexOf(e.keyPrefix)&&r.push(t.replace(e.keyPrefix,""))})),r.sort(),t(r)}catch(t){n(t)}}))},s);function s(e){this.storeName=e,this.keyPrefix=e+"/",this.storeName}t.ZegoWechatMiniStore=o,t.createZegoStore=function(e,t){return t===r.ZEGO_ENV.BROWSER?i.createInstance({name:e}):new o(e)}},function(t,n){t.exports=e},function(e,t,n){"use strict";var i;Object.defineProperty(t,"__esModule",{value:!0}),t.SOCKET_DISCONNECT=t.ENUM_REMOTE_TYPE=t.ZEGO_BROWSER_TYPE=t.ZEGO_ENV=t.PROTO_VERSION=void 0,t.PROTO_VERSION="1.0.3",(i=t.ZEGO_ENV||(t.ZEGO_ENV={}))[i.BROWSER=0]="BROWSER",i[i.WEIXINMINI=1]="WEIXINMINI",(i=t.ZEGO_BROWSER_TYPE||(t.ZEGO_BROWSER_TYPE={}))[i.IE=0]="IE",i[i.FIREFOX=1]="FIREFOX",i[i.CHROME=2]="CHROME",i[i.SAFARI=3]="SAFARI",i[i.OPERA=4]="OPERA",i[i.WEIXIN=5]="WEIXIN",i[i.WEIXINMINI=6]="WEIXINMINI",i[i.UNKOWN=7]="UNKOWN",(i=t.ENUM_REMOTE_TYPE||(t.ENUM_REMOTE_TYPE={}))[i.DISABLE=0]="DISABLE",i[i.WEBSOCKET=1]="WEBSOCKET",i[i.HTTPS=2]="HTTPS",t.SOCKET_DISCONNECT=-1},function(e,t,n){"use strict";var i=this&&this.__assign||function(){return(i=Object.assign||function(e){for(var t,n=1,i=arguments.length;n<i;n++)for(var r in t=arguments[n])Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e}).apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.SettingFetchHandler=void 0;var r=n(0),o=n(11),s=n(2);a.prototype.setOptions=function(e){this.options=e},a.prototype.setDataReport=function(e){this.reportFunc=e},a.prototype.fetchSetting=function(e,t,n,a){var l=this;return new Promise((function(c,u){var f={product:l.options.product,files:e,param:i(i({},t),{deviceid:void 0}),appid:l.options.appID,token:n,id_name:a,timestamp:(new Date).getTime(),biztype:0,deviceid:t.deviceid||s.generateUUID(l.options.env),compress:!1,mode:l.options.online?"online":"test"},h=l.seq++;l.reportFunc&&l.reportFunc(h,"request_start"),o.fetch(l.options.urls,f,l.options.env||0).then((function(e){var t,n=e.code,i=(e.msg,e.data),o=e.polling_interval;e=e.reportData;l.log.info(r.ZEGO_SETTING_ACTION.SETTINGFETCHHANDLER_FETCHSETTING+" "+n),i&&(t=[],Object.keys(i).forEach((function(e){t.push({name:e,error:i[e].code})}))),l.reportFunc&&l.reportFunc(h,"request_end",{code:n,reportData:e,params:f,files:t}),c({data:i,polling_interval:o})})).catch((function(e){var t=e.code,n=e.msg;e.data,e=e.reportData;l.log.warn(r.ZEGO_SETTING_ACTION.SETTINGFETCHHANDLER_FETCHSETTING+" "+t),l.reportFunc&&l.reportFunc(h,"request_end",{code:t,params:f,reportData:e}),u({code:t,msg:n})}))}))},n=a;function a(e,t){this.options=e,this.log=t,this.seq=0}t.SettingFetchHandler=n},function(e,t,n){"use strict";var i=this&&this.__assign||function(){return(i=Object.assign||function(e){for(var t,n=1,i=arguments.length;n<i;n++)for(var r in t=arguments[n])Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e}).apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.fetch=void 0;var r=n(1);t.fetch=function e(t,n,o,s,a,l){return void 0===s&&(s=5),void 0===a&&(a=0),void 0===l&&(l=[]),new Promise((function(c,u){a=a||(new Date).getTime();var f,h,g,T=(new Date).getTime();0===o?(f=new XMLHttpRequest,h=t[(s+1)%2]||t[0],f.open("post",h),1==n.compress&&(f.responseType="arraybuffer"),f.ontimeout=function(){},f.onreadystatechange=function(){var g,p,d,v,E;4==f.readyState&&(200<=f.status&&f.status<300||304==f.status?(p=void 0,1==n.compress||(p=f.responseText),E=(new Date).getTime()-T,g=(d=JSON.parse(p)).code,v=d.message,p=d.data,d=d.polling_interval,l.push({timestamp:T,url:h,error:g,duration:E}),0===g?c({code:g,msg:v,data:p,polling_interval:d,reportData:l}):u({code:g,msg:v,reportData:l})):(v=(new Date).getTime()-T,l.push({timestamp:T,url:h,error:f.status,duration:v}),E=(new Date).getTime()-a,0<s&&E<8e3?e(t,n,o,--s,a,l).then((function(e){c(e)})).catch((function(e){u(e)})):u(i(i({},r.errorList.FILE_REQUEST_FAIL),{reportData:l}))))},f.timeout=8e3,f.send(JSON.stringify(n))):(g=t[(s+1)%2]||t[0],wx.request({url:g,data:n,method:"POST",success:function(f){var h=(v=f.data).code,p=v.message,d=v.data,v=v.polling_interval;void 0!==h?0===h?c({code:h,msg:p,data:d,polling_interval:v,reportData:l}):u({code:h,msg:p,reportData:l}):(p=(new Date).getTime()-T,l.push({timestamp:T,url:g,error:r.errorList.FILE_REQUEST_FAIL.code,msg:f.data,duration:p}),0<s?e(t,n,o,--s,a,l).then((function(e){c(e)})).catch((function(e){u(e)})):u(i(i({},r.errorList.FILE_REQUEST_FAIL),{reportData:l})))},fail:function(f){var h=(new Date).getTime()-T;l.push({timestamp:T,url:g,error:r.errorList.FILE_REQUEST_FAIL.code,msg:f.errMsg,duration:h}),0<s?e(t,n,o,--s,a,l).then((function(e){c(e)})).catch((function(e){u(e)})):u(i(i({},r.errorList.FILE_REQUEST_FAIL),{reportData:l}))}}))}))}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.INIT_CONFIG=void 0,t.INIT_CONFIG={env:0}}],t.c=i,t.d=function(e,n,i){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:i})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(t.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)t.d(i,r,function(t){return e[t]}.bind(null,r));return i},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=3);function t(e){if(i[e])return i[e].exports;var r=i[e]={i:e,l:!1,exports:{}};return n[e].call(r.exports,r,r.exports,t),r.l=!0,r.exports}var n,i}));

/***/ }),

/***/ "./sdk/code/zh/zego.client.web.ts":
/*!****************************************!*\
  !*** ./sdk/code/zh/zego.client.web.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_371329__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BusinessService = exports.NetAgentHttpRequest = exports.NetAgentPCRequest = exports.NetAgentConnect = exports.ZegoExpressWebRTM = exports.ZegoDataReport = exports.ZegoLogger = exports.getSeq = exports.getReportSeq = exports.ZegoExpressWebRTMEngine = void 0;
var src_1 = __nested_webpack_require_371329__(/*! ../../src */ "./sdk/src/index.ts");
Object.defineProperty(exports, "ZegoExpressWebRTM", { enumerable: true, get: function () { return src_1.ZegoExpressWebRTM; } });
var zego_setting_1 = __nested_webpack_require_371329__(/*! zego-setting */ "./node_modules/zego-setting/ZegoSetting.js");
var zego_entity_1 = __nested_webpack_require_371329__(/*! ../../src/zego.entity */ "./sdk/src/zego.entity.ts");
var net_1 = __nested_webpack_require_371329__(/*! ../../src/modules/net */ "./sdk/src/modules/net/index.ts");
Object.defineProperty(exports, "NetAgentConnect", { enumerable: true, get: function () { return net_1.NetAgentConnect; } });
Object.defineProperty(exports, "NetAgentPCRequest", { enumerable: true, get: function () { return net_1.NetAgentPCRequest; } });
Object.defineProperty(exports, "NetAgentHttpRequest", { enumerable: true, get: function () { return net_1.NetAgentHttpRequest; } });
Object.defineProperty(exports, "BusinessService", { enumerable: true, get: function () { return net_1.BusinessService; } });
var ZegoExpressWebRTMEngine = /** @class */ (function () {
    /**
     * Engine
     *
     * Note: 1.0.0
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: server 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * @param appID number; appIDappID ;appID,
     *              
     * @param server SDK;SDK ; appIDserver; 
     * @param ENV sdk rtc
     */
    function ZegoExpressWebRTMEngine(appID, server, ENV, options) {
        if (ENV === void 0) { ENV = 0; }
        this.logger = new zego_entity_1.ZegoLogger(ENV);
        this.dataReport = new zego_entity_1.ZegoDataReport(this.logger);
        this.cloudSetting = new zego_setting_1.ZegoSetting();
        this.zegoWebRTM = new src_1.ZegoExpressWebRTM(appID, server, this.logger, this.dataReport, this.cloudSetting, ZegoExpressWebRTMEngine.version, ENV, options);
    }
    /**
     * 
     *
     * 2.8.0 
     *
     * 
     *
     * 
     *
     * 
     *
     *  SDK  loginRoom 
     *
     * 
     *
     *  loginRoom   logoutRoom  startPublishingStream 
     *
     * @param enable true false 
     */
    ZegoExpressWebRTMEngine.prototype.enableMultiRoom = function (enable) {
        return this.zegoWebRTM.enableMultiRoom(enable);
    };
    /**
     * 
     *
     * Note: 1.0.0 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  token 
     *
     * Note: 
     * 1. token  token [](https://doc-zh.zego.im/article/7646)
     * 2.  userID 
     * 3.  config  userUpdate  true
     *
     * Note: :  
     *
     * Note: 
     *
     * Note:  roomStateUpdate
     *
     * Note:  logoutRoom 
     *
     * @param roomID  ID 128   '~', '!', '@', '#', '$', '', '^', '&', '*', '(', ')', '_', '+', '=', '-', ', ';', '', ',', '.', '<', '>', '/',
     * @param token  token ZEGO 
     * @param user 
     * @param config? 
     *
     * @return promise true false 
     */
    ZegoExpressWebRTMEngine.prototype.loginRoom = function (roomID, token, user, config) {
        return this.zegoWebRTM.loginRoom(roomID, token, user, config);
    };
    /**
     * 
     *
     * Note: 1.0.0
     *
     * Note: ,
     *
     * Note:  ZEGO  ZEGO  websocket 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  
     *
     * Note: 
     *
     * Note:  roomStateUpdate
     *
     * Note:  loginRoom 
     *
     * Note: 
     *
     * @param roomID? roomID
     */
    ZegoExpressWebRTMEngine.prototype.logoutRoom = function (roomID) {
        return this.zegoWebRTM.logoutRoom(roomID);
    };
    /**
     * token
     *
     * 2.6.0
     *
     * token,token,token
     *
     * , token
     *
     * 
     *
     * ,; ,token;
     *
     * 
     *
     * token, ,,token
     *
     * token,30stokenWillExpire
     *
     * tokentokenWillExpire
     *
     * 
     *
     * Note: 
     *
     * @param token token, tokenSDK;
     * @param roomID  ID 128   '~', '!', '@', '#', '$', '', '^', '&', '*', '(', ')', '_', '+', '=', '-', ', ';', '', ',', '.', '<', '>', '/',
     *
     * @return true: , false:  (SDK )
     */
    ZegoExpressWebRTMEngine.prototype.renewToken = function (token, roomID) {
        return this.zegoWebRTM.renewToken(token, roomID);
    };
    /**
     * 
     *
     * Note: 1.0.0 
     *
     * Note:  roomID 
     *
     * Note: 
     *
     * Note:  loginRoom 
     *
     * Note:  https://doc-zh.zego.im/article/7584  ZEGO 
     *
     * Note: 
     *
     * Note:  IMRecvBarrageMessage 
     *
     * @param roomID Id
     * @param message 1024
     */
    ZegoExpressWebRTMEngine.prototype.sendBarrageMessage = function (roomID, message) {
        return this.zegoWebRTM.sendBarrageMessage(roomID, message);
    };
    /**
     * 
     *
     * Note: 1.0.0 
     *
     * Note:  roomID 
     *
     * Note: 
     *
     * Note:  loginRoom 
     *
     * Note:  https://doc-zh.zego.im/article/7584  ZEGO 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  IMRecvBroadcastMessage 
     *
     * @param roomID  ID
     * @param message 1024 
     */
    ZegoExpressWebRTMEngine.prototype.sendBroadcastMessage = function (roomID, message) {
        return this.zegoWebRTM.sendBroadcastMessage(roomID, message);
    };
    /**
     * 
     *
     * Note: 1.0.0 
     *
     * Note:  roomID 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  https://doc-zh.zego.im/article/7584  ZEGO 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  IMRecvCustomCommand 
     *
     * @param roomID  ID
     * @param message  1024 
     * @param toUserIDList uerId 
     */
    ZegoExpressWebRTMEngine.prototype.sendCustomCommand = function (roomID, message, toUserIDList) {
        return this.zegoWebRTM.sendCustomCommand(roomID, message, toUserIDList);
    };
    /**
     * 
     *
     * Note: 1.0.0
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  https://doc-zh.zego.im/article/7584   ZEGO 
     *
     * Note:   key  10 value  100 
     *
     * Note: :  
     *
     * Note: 
     *
     * Note:  roomExtraInfoUpdate
     *
     * Note: 
     *
     * Note: 
     *
     * @param roomID  ID
     * @param key 
     * @param value 
     */
    ZegoExpressWebRTMEngine.prototype.setRoomExtraInfo = function (roomID, key, value) {
        return this.zegoWebRTM.setRoomExtraInfo(roomID, key, value);
    };
    /**
     * 
     *
     * Note: 1.0.0
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  info
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * @param config 
     *
     * @return ; : 
     */
    ZegoExpressWebRTMEngine.prototype.setLogConfig = function (config) {
        return this.zegoWebRTM.setLogConfig(config);
    };
    /**
     *  alert 
     *
     * Note: 1.0.0
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  true 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  SDK 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * @param enable  debug ;sdk
     */
    ZegoExpressWebRTMEngine.prototype.setDebugVerbose = function (enable) {
        return this.zegoWebRTM.setDebugVerbose(enable);
    };
    /**
     * 
     *
     * Note: 1.0.0 
     *
     * Note:  SDK  event 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note:  off 
     *
     * @param event 
     * @param callBack 
     *
     * @return 
     */
    ZegoExpressWebRTMEngine.prototype.on = function (event, callBack) {
        return this.zegoWebRTM.on(event, callBack);
    };
    /**
     * SDK
     *
     * Note: 1.0.0
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * @return  string 1.0.0.
     */
    ZegoExpressWebRTMEngine.prototype.getVersion = function () {
        return this.zegoWebRTM.getVersion();
    };
    /**
     * 
     *
     * Note: 1.0.0
     *
     * Note: SDK
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * @param event 
     * @param callBack? 
     */
    ZegoExpressWebRTMEngine.prototype.off = function (event, callBack) {
        return this.zegoWebRTM.off(event, callBack);
    };
    /**
     * 
     *
     * Note:   , )
     *
     * Note: ,token
     *
     * Note: 
     *
     * Note:  roomStateUpdate, roomUserUpdate, roomOnlineUserCountUpdate
     *
     * Note: 
     *        token, ,,token;
     *        userID;
     *        configuserUpdatetrue
     * Note: 1.0.0
     *
     * Note: 
     *
     * @param roomID  ID 128   '~', '!', '@', '#', '$', '', '^', '&', '*', '(', ')', '_', '+', '=', '-', ', ';', '', ',', '.', '<', '>', '/',
     * @param token  token, ,; , 
     * @param user 
     * @param config? 
     */
    ZegoExpressWebRTMEngine.prototype.loginHall = function (token, user, config) {
        return this.zegoWebRTM.loginHall(token, user, config);
    };
    /**
     * 
     *
     * Note: ;  Zego  Zego  websocket 
     *
     * Note: ,
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 1.0.0
     *
     * Note: 
     *
     * @param roomID roomID
     */
    ZegoExpressWebRTMEngine.prototype.logoutHall = function () {
        return this.zegoWebRTM.logoutHall();
    };
    /**
     * 
     *
     * Note:   , )
     *
     * Note: ,token
     *
     * Note: 
     *
     * Note:  roomStateUpdate, roomUserUpdate, roomOnlineUserCountUpdate
     *
     * Note: 
     *        token, ,,token;
     *        userID;
     *        configuserUpdatetrue
     * Note: 1.0.0
     *
     * Note: 
     *
     * @param roomID  ID 128   '~', '!', '@', '#', '$', '', '^', '&', '*', '(', ')', '_', '+', '=', '-', ', ';', '', ',', '.', '<', '>', '/',
     * @param token  token, ,; , 
     * @param user 
     * @param config? 
     */
    ZegoExpressWebRTMEngine.prototype.enterRoom = function (roomID, role) {
        return this.zegoWebRTM.enterRoom(roomID, role);
    };
    /**
     * 
     *
     * Note: ;  Zego  Zego  websocket 
     *
     * Note: ,
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 
     *
     * Note: 1.0.0
     *
     * Note: 
     *
     * @param roomID roomID
     */
    ZegoExpressWebRTMEngine.prototype.leaveRoom = function () {
        return this.zegoWebRTM.leaveRoom();
    };
    ZegoExpressWebRTMEngine.use = function (module) {
        src_1.ZegoExpressWebRTM.use(module);
    };
    ZegoExpressWebRTMEngine.version = zego_entity_1.PROTO_VERSION;
    return ZegoExpressWebRTMEngine;
}());
exports.ZegoExpressWebRTMEngine = ZegoExpressWebRTMEngine;
var zego_entity_2 = __nested_webpack_require_371329__(/*! ../../src/zego.entity */ "./sdk/src/zego.entity.ts");
Object.defineProperty(exports, "getReportSeq", { enumerable: true, get: function () { return zego_entity_2.getReportSeq; } });
Object.defineProperty(exports, "getSeq", { enumerable: true, get: function () { return zego_entity_2.getSeq; } });
Object.defineProperty(exports, "ZegoLogger", { enumerable: true, get: function () { return zego_entity_2.ZegoLogger; } });
Object.defineProperty(exports, "ZegoDataReport", { enumerable: true, get: function () { return zego_entity_2.ZegoDataReport; } });


/***/ }),

/***/ "./sdk/src/index.ts":
/*!**************************!*\
  !*** ./sdk/src/index.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_387581__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZegoExpressWebRTM = void 0;
var zego_entity_1 = __nested_webpack_require_387581__(/*! ./zego.entity */ "./sdk/src/zego.entity.ts");
var zego_externalError_1 = __nested_webpack_require_387581__(/*! ./zego.externalError */ "./sdk/src/zego.externalError.ts");
var client_util_1 = __nested_webpack_require_387581__(/*! ../util/client-util */ "./sdk/util/client-util.ts");
var zego_entity_2 = __nested_webpack_require_387581__(/*! ./zego.entity */ "./sdk/src/zego.entity.ts");
var zego_config_1 = __nested_webpack_require_387581__(/*! ./zego.config */ "./sdk/src/zego.config.ts");
var retryRoomHandler_1 = __nested_webpack_require_387581__(/*! ./modules/retryRoomHandler */ "./sdk/src/modules/retryRoomHandler.ts");
var param_util_1 = __nested_webpack_require_387581__(/*! ../util/param-util */ "./sdk/util/param-util.ts");
var stateCenter_1 = __nested_webpack_require_387581__(/*! ./stateCenter */ "./sdk/src/stateCenter.ts");
var modules_1 = __nested_webpack_require_387581__(/*! ./modules */ "./sdk/src/modules/index.ts");
var index_private_1 = __nested_webpack_require_387581__(/*! ./modules/index.private */ "./sdk/src/modules/index.private.ts");
var zego_action_1 = __nested_webpack_require_387581__(/*! ./zego.action */ "./sdk/src/zego.action.ts");
var zego_log_event_1 = __nested_webpack_require_387581__(/*! ./zego.log.event */ "./sdk/src/zego.log.event.ts");
var service_1 = __nested_webpack_require_387581__(/*! ./service */ "./sdk/src/service.ts");
var service_private_1 = __nested_webpack_require_387581__(/*! ./service.private */ "./sdk/src/service.private.ts");
var setting_config_1 = __nested_webpack_require_387581__(/*! ./setting.config */ "./sdk/src/setting.config.ts");
var net_1 = __nested_webpack_require_387581__(/*! ./modules/net */ "./sdk/src/modules/net/index.ts");
var AccessHubDefine_1 = __nested_webpack_require_387581__(/*! ./modules/net/entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var AccessHubDefine_2 = __nested_webpack_require_387581__(/*! ./modules/net/entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var liveroomHandler_1 = __nested_webpack_require_387581__(/*! ./modules/liveroomHandler */ "./sdk/src/modules/liveroomHandler.ts");
var net_config_1 = __nested_webpack_require_387581__(/*! ./modules/net/net.config */ "./sdk/src/modules/net/net.config.ts");
// 
var ZegoExpressWebRTM = /** @class */ (function () {
    // static getReportSeq = getReportSeq;
    // static getSeq = getSeq;
    function ZegoExpressWebRTM(appID, server, logger, dataReport, cloudSetting, version, ENV, options) {
        var _this = this;
        this.logger = logger;
        this.dataReport = dataReport;
        this.cloudSetting = cloudSetting;
        this.version = version;
        this.options = options;
        this.stateCenter = new stateCenter_1.StateCenter(this.logger, this.dataReport);
        this.stateCenter.ENV = ENV;
        //  getReportSeq
        this.getReportSeq = zego_entity_2.getReportSeq;
        this.getSeq = zego_entity_1.getSeq;
        this.initCallback();
        // 
        var seq = zego_entity_2.getReportSeq();
        this.dataReport.newReport(seq);
        (ENV == 0 || ENV == 1) && this.setDebug(server);
        if (!client_util_1.ClientUtil.checkConfigParam(appID, server, this.logger)) {
            //
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CONSTRUCTOR + " init sdk error");
            this.dataReport.addMsgInfo(seq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskInitSetting.error.kInvalidParamError);
        }
        else {
            //
            this.stateCenter.appid = appID;
            this.stateCenter.configOK = true;
            this.stateCenter.sdKVersion = this.version;
            this.netAgent = new net_1.NetAgentConnect(this.stateCenter.appid, this.stateCenter.ENV, this.logger, this.stateCenter);
            this.liveRoomHandler = new liveroomHandler_1.LiveRoomHandler(this.logger, this.stateCenter, this.netAgent, this);
            this.service = new service_1.LiveRoomService(this.stateCenter, this.logger, this);
            this.stateCenter.deviceID = client_util_1.ClientUtil.generateUUID();
            // 
            this.stateCenter.settingConfig = new setting_config_1.ZegoSettingConfig();
            // @ts-ignore
            this.cloudSetting.setLog(this.logger);
            this.cloudSetting.init({
                product: zego_config_1.CLOUD_SETTING.product,
                appID: appID,
                urls: zego_config_1.CLOUD_SETTING.URL,
                pollingFreq: zego_config_1.CLOUD_SETTING.POLLING_FREQ,
                env: ENV,
                pollingNotify: function (file, settingJson) {
                    _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CONSTRUCTOR, ' setting file changed ' + file + ' ' + JSON.stringify(settingJson));
                    _this.stateCenter.actionListener('_cloudSettingNotify', file, settingJson);
                },
                reportNotify: this.cloudReportNotify.bind(this),
                online: !this.stateCenter.testEnvironment,
            });
            var env = '';
            if (ENV === 0) {
                env = 'rtc';
            }
            else if (ENV === 1) {
                env = 'xcx';
            }
            this.cloudSetting.setEnvVariable('environment', env);
            var promise1 = this.cloudSetting.getSettingCache(zego_config_1.INIT);
            var promise2 = this.cloudSetting.getSettingCache(zego_config_1.ROOM_BASIC);
            Promise.all([promise1, promise2])
                .then(function (values) {
                var initConfig = values === null || values === void 0 ? void 0 : values[0];
                _this.stateCenter.settingConfig.setSetting(initConfig === null || initConfig === void 0 ? void 0 : initConfig.setting);
                var unify = _this.stateCenter.settingConfig.getSetting('unify');
                if (unify) {
                    var enable = unify.enable, sdk_conn_ver = unify.sdk_conn_ver;
                    if (enable && sdk_conn_ver >= net_1.NET_ACCESS_CONFIG.connectVer) {
                        _this.stateCenter.useNetAgent = true;
                    }
                    else {
                        _this.stateCenter.useNetAgent = false;
                    }
                }
                if (_this.stateCenter.useNetAgent) {
                    _this.createNetAgent();
                    _this.getStoreAppConfig();
                }
                var level = _this.stateCenter.settingConfig.getSetting('remote_log_level', true);
                if (level) {
                    _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CONSTRUCTOR + "  setting remote_log_level " + level);
                    _this.logger.setRemoteLogLevel(level);
                }
                var roomConfig = values === null || values === void 0 ? void 0 : values[1];
                _this.stateCenter.settingConfig.setSetting(roomConfig === null || roomConfig === void 0 ? void 0 : roomConfig.setting);
                var reportSeq = zego_entity_2.getReportSeq();
                _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskCloudSettingCache.event);
                _this.dataReport.addMsgInfo(reportSeq, {
                    files: [
                        {
                            name: zego_config_1.INIT,
                            content: initConfig === null || initConfig === void 0 ? void 0 : initConfig.setting,
                            versions: initConfig === null || initConfig === void 0 ? void 0 : initConfig.versions,
                        },
                        {
                            name: zego_config_1.ROOM_BASIC,
                            content: roomConfig === null || roomConfig === void 0 ? void 0 : roomConfig.setting,
                            versions: roomConfig === null || roomConfig === void 0 ? void 0 : roomConfig.versions,
                        },
                    ],
                });
                _this.dataReport.uploadReport(reportSeq);
            })
                .catch(function (err) {
                _this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CONSTRUCTOR + "  initConfig " + JSON.stringify(err));
            });
            if (typeof server === 'string') {
                this.stateCenter.server = server;
                this.stateCenter.serverBak = server;
            }
            else if (Array.isArray(server) && server.length > 0) {
                this.stateCenter.server = server[0];
                this.stateCenter.serverBak = server[1] || server[0];
            }
            if (ENV == 0 || ENV == 2) {
                this.bindWindowListener();
                this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CONSTRUCTOR + "  " + navigator.appVersion);
                this.stateCenter.networkState = navigator
                    ? navigator.onLine
                        ? zego_entity_1.ENUM_NETWORK_STATE.online
                        : zego_entity_1.ENUM_NETWORK_STATE.offline
                    : zego_entity_1.ENUM_NETWORK_STATE.online;
                this.dataReport.addMsgInfo(seq, {
                    system_info: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskInitSetting.system_info,
                });
            }
            else if (ENV == 1 || ENV == 3) {
                this.bindWxListener();
                try {
                    var res = wx.getSystemInfoSync();
                    var systemInfo = {
                        brand: res.brand,
                        model: res.model,
                        system: res.system,
                        platform: res.platform,
                        version: res.version,
                        SDKVersion: res.SDKVersion,
                    };
                    this.dataReport.addMsgInfo(seq, {
                        system_info: systemInfo,
                    });
                }
                catch (e) {
                    this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CONSTRUCTOR + ' get system info error');
                }
            }
            this.logger.setSessionInfo(this.stateCenter.appid, '', '', '', '', this.version);
        }
        this.dataReport.uploadReport(seq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskInitSetting.event);
    }
    Object.defineProperty(ZegoExpressWebRTM.prototype, "modules", {
        //  modules.service SDK
        get: function () {
            return { service: this.service };
        },
        enumerable: false,
        configurable: true
    });
    ZegoExpressWebRTM.prototype.initCallback = function () {
        this.proxyRes = client_util_1.ClientUtil.proxyRes;
        this.actionSuccessCallback = client_util_1.ClientUtil.actionSuccessCallback;
        this.actionErrorCallback = client_util_1.ClientUtil.actionErrorCallback;
        this.getServerError = client_util_1.ClientUtil.getServerError;
        this.generateRandumNumber = client_util_1.ClientUtil.generateRandumNumber;
        this.unregisterCallback = client_util_1.ClientUtil.unregisterCallback;
        this.logReportCallback = client_util_1.ClientUtil.logReportCallback;
        this.registerCallback = client_util_1.ClientUtil.registerCallback;
    };
    ZegoExpressWebRTM.prototype.getStoreAppConfig = function () {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_GETSTOREAPPCONFIG + ' call');
        var ciphertext = localStorage.getItem(net_config_1.APP_CONFIG_KEY + '_' + this.getAppID() + '_' + net_1.NET_ACCESS_CONFIG.modeNo);
        if (!ciphertext) {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_GETSTOREAPPCONFIG + ' no store config');
            return;
        }
        try {
            var originalText = client_util_1.ClientUtil.decryptStores(ciphertext, zego_config_1.STORE_SECRET);
            if (originalText) {
                this.stateCenter.appConfig = JSON.parse(originalText);
                this.stateCenter.actionListener('_appConfigRsp');
                this.handleLogUpload();
            }
        }
        catch (error) {
            this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_GETSTOREAPPCONFIG + ' ' + JSON.stringify(error));
        }
    };
    ZegoExpressWebRTM.prototype.createNetAgent = function () {
        var _this = this;
        var _a, _b, _c;
        //  start
        this.netAgent.on('disconnected', function () {
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CREATENETAGENT + " netAgent disconnect");
            __spreadArrays(_this.stateCenter.roomModulesList).forEach(function (room) { return room.roomHandler.resetRoom(); });
        });
        this.netAgent.on('connected', function () {
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CREATENETAGENT + " netAgent connect");
            _this.fetchAppConfig();
            //
            _this.stateCenter.roomModulesList.forEach(function (roomModules) {
                if (roomModules.roomTryHandler &&
                    _this.netAgent.isConnect()
                // @ts-ignore
                // roomModules.runState !== ENUM_RUN_STATE.trylogin
                ) {
                    roomModules.roomTryHandler.active(true);
                }
            });
        });
        this.netAgent.on('broken', function () {
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CREATENETAGENT + " netAgent broken");
        });
        var _domains;
        if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.accessDomains) && ((_b = this.options) === null || _b === void 0 ? void 0 : _b.accessDomains.length) > 0) {
            _domains = (_c = this.options) === null || _c === void 0 ? void 0 : _c.accessDomains;
        }
        else {
            _domains = net_1.NET_ACCESS_CONFIG.domains;
        }
        var servers = _domains.map(function (item) { return "wss://" + item + "/accesshub"; });
        this.netAgent.connect(servers);
        //  end
    };
    ZegoExpressWebRTM.prototype.bindWindowListener = function () {
        var _this = this;
        //
        var isOnIOS = navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPhone/i);
        var browser = client_util_1.ClientUtil.getBrowser();
        var eventName = isOnIOS ? 'pagehide' : browser === 'Firefox' ? 'beforeunload' : 'unload';
        window.addEventListener(eventName, function () {
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_BIND_WINDOW_LISTENER + ' ' + eventName);
            if (_this.stateCenter.type === 'PUBLIC') {
                _this.logoutRoom();
            }
            else {
                _this.leaveRoom();
                // TODO
                // this.logoutHall();
            }
            _this.logoutRoom();
        });
        //
        window.addEventListener('offline', function () {
            _this.netOffLineHandle();
        });
        //
        window.addEventListener('online', function () {
            _this.netOnLineHandle();
        });
    };
    ZegoExpressWebRTM.prototype.bindWxListener = function () {
        var _this = this;
        //
        wx.onNetworkStatusChange(function (res) {
            if (res.isConnected) {
                _this.netOnLineHandle();
            }
            else {
                _this.netOffLineHandle();
            }
        });
    };
    ZegoExpressWebRTM.prototype.retryRoom = function () {
        var _this = this;
        this.stateCenter.roomModulesList.forEach(function (roomModules) {
            if (roomModules.roomTryHandler &&
                _this.netAgent.isConnect()
            // @ts-ignore
            // roomModules.runState !== ENUM_RUN_STATE.trylogin
            ) {
                roomModules.resetSessionInfo();
                roomModules.roomTryHandler.active(true);
            }
        });
    };
    ZegoExpressWebRTM.prototype.netOnLineHandle = function () {
        var _this = this;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_BIND_WINDOW_LISTENER + 'network is online');
        this.stateCenter.networkState = zego_entity_1.ENUM_NETWORK_STATE.online;
        if (this.stateCenter.useNetAgent) {
            // 
            this.netAgent.netOnLineHandler();
        }
        else {
            //
            this.stateCenter.roomModulesList.forEach(function (roomModules) {
                if (roomModules.roomTryHandler && _this.service.isDisConnect()) {
                    roomModules.roomTryHandler.active();
                }
                else if (roomModules.roomTryHandler) {
                    roomModules.roomTryHandler.stopMaxTime();
                    roomModules.roomHandler.roomStateHandle('CONNECTED', { code: 0, msg: '' });
                }
            });
        }
    };
    ZegoExpressWebRTM.prototype.netOffLineHandle = function () {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_BIND_WINDOW_LISTENER + ' network is broken');
        this.stateCenter.networkState = zego_entity_1.ENUM_NETWORK_STATE.offline;
        if (this.stateCenter.useNetAgent) {
            // 
            this.netAgent.netOffLineHandler();
        }
        else {
            //
            this.stateCenter.roomModulesList.forEach(function (roomModules) {
                if (roomModules.roomTryHandler) {
                    //
                    roomModules.roomTryHandler.invalid();
                    roomModules.roomTryHandler.onactive = function (success, error) {
                        roomModules.roomHandler.disconnectedHandle(error);
                    };
                    //
                    roomModules.roomTryHandler.startMaxTime();
                    roomModules.roomHandler.roomStateHandle('CONNECTING', zego_externalError_1.errorCodeList.NETWORK_BROKEN);
                }
            });
        }
    };
    ZegoExpressWebRTM.prototype.setLogConfig = function (option) {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SET_LOG_CONFIG + ' call');
        var reportSeq = zego_entity_2.getReportSeq();
        this.dataReport.newReport(reportSeq);
        if (option.logLevel && ['debug', 'info', 'warn', 'error', 'report', 'disable'].includes(option.logLevel)) {
            this.logger.setLogLevel(option.logLevel);
            this.dataReport.addMsgInfo(reportSeq, {
                log_level: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskSetLog.log_level(option.logLevel),
            });
        }
        if (option.remoteLogLevel &&
            ['debug', 'info', 'warn', 'error', 'report', 'disable'].includes(option.remoteLogLevel)) {
            // this.logger.setRemoteLogLevel(option.remoteLogLevel);
            this.dataReport.addMsgInfo(reportSeq, {
                remote_log_level: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskSetLog.remote_log_level(option.remoteLogLevel),
            });
        }
        if (typeof option.logURL == 'string' &&
            (option.logURL.startsWith('wss://') || option.logURL.startsWith('https://'))) {
            this.logger.setLogServer(option.logURL);
            this.dataReport.addMsgInfo(reportSeq, {
                log_url: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskSetLog.log_url(option.logURL),
            });
            this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskSetLog.event);
        }
        else if (option.logURL) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SET_LOG_CONFIG + 'log url must be a wss or https url');
            this.dataReport.addMsgInfo(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskSetLog.error.kInvalidParamError);
            this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskSetLog.event);
            return false;
        }
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SET_LOG_CONFIG + ' call success');
        return true;
    };
    ZegoExpressWebRTM.prototype.setDebugVerbose = function (enable) {
        var reportSeq = zego_entity_2.getReportSeq();
        this.dataReport.newReport(reportSeq);
        if (typeof enable == 'boolean') {
            this.stateCenter.debug = enable;
            this.stateCenter.debugCustom = true;
            this.dataReport.addMsgInfo(reportSeq, {
                debug: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskSetDebug.debug(enable ? 'true' : 'false'),
            });
        }
        this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskSetDebug.event);
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SET_DEBUG_VERBOSE + ' call success');
    };
    ZegoExpressWebRTM.prototype.setDebug = function (server) {
        if (typeof server === 'string' && server.indexOf('wss') > -1) {
            this.stateCenter.debug = client_util_1.ClientUtil.isTestEnv(server);
        }
        else if (Array.isArray(server) &&
            server.length > 0 &&
            server.every(function (v) { return typeof v === 'string' && v.indexOf('wss') > -1; })) {
            this.stateCenter.debug = client_util_1.ClientUtil.isTestEnv(server[0]);
            // TODO
            // !this.stateCenter.debug && server[1] && (this.stateCenter.debug = ClientUtil.isTestEnv(server[1]));
        }
        else {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CONSTRUCTOR + ' server wrong');
        }
        this.stateCenter.testEnvironment = this.stateCenter.debug;
    };
    ZegoExpressWebRTM.prototype.renewToken = function (token, roomID) {
        var _this = this;
        var _a, _b;
        var reportSeq = zego_entity_2.getReportSeq();
        this.dataReport.newReport(reportSeq);
        if (typeof roomID !== 'undefined' && (typeof roomID !== 'string' || roomID == '')) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_RENEWTOKEN + ' roomID must be string and no empty');
            return false;
        }
        var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
        if (!room) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_RENEWTOKEN + ' calling must after loginRoom');
            this.dataReport.addMsgInfo(reportSeq, {
                error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.error.NOT_LOGIN.code,
                message: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.error.NOT_LOGIN.msg,
            });
            this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.event);
            return false;
        }
        if (typeof token === 'string' && room.roomTryHandler) {
            if (token === room.roomTryHandler.token) {
                this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_RENEWTOKEN + ' token has not changed');
            }
            else {
                (_a = room.roomTryHandler) === null || _a === void 0 ? void 0 : _a.renewLocalToken(token);
                this.cloudSetting.setToken(token);
                var sucCallBack = function (msg) {
                    var _a, _b;
                    (_a = room.roomTryHandler) === null || _a === void 0 ? void 0 : _a.renewLocalToken(token, (_b = msg === null || msg === void 0 ? void 0 : msg.body) === null || _b === void 0 ? void 0 : _b.token_remain_time);
                    _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_RENEWTOKEN + ' ' + JSON.stringify(msg));
                };
                var failCallBack = function (error) {
                    //  token
                    _this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_RENEWTOKEN + ' ' + JSON.stringify(error));
                };
                if (this.stateCenter.useNetAgent) {
                    (_b = this.liveRoomHandler) === null || _b === void 0 ? void 0 : _b.renewToken({ token: token }, sucCallBack, failCallBack, room);
                }
                else {
                    this.service.sendMessage('renew_token', { token: token }, sucCallBack, failCallBack, undefined, {
                        sessionID: room.sessionID,
                        roomID: roomID,
                        roomSessionID: room.roomSessionID,
                    });
                }
            }
            this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.event);
            return true;
        }
        else if (typeof token === 'string' && !room.roomTryHandler) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_RENEWTOKEN + ' calling must after loginRoom');
            this.dataReport.addMsgInfo(reportSeq, {
                error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.error.NOT_LOGIN.code,
                message: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.error.NOT_LOGIN.msg,
            });
            this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.event);
            return false;
        }
        else {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_RENEWTOKEN + ' token must be string and not empty');
            this.dataReport.addMsgInfo(reportSeq, {
                error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.error.INPUT_PARAM.code,
                message: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.error.INPUT_PARAM.msg + ' param token error',
            });
            this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReNewToken.event);
            return false;
        }
    };
    ZegoExpressWebRTM.prototype.setCloudSettingURLs = function (urls) {
        var _this = this;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SET_CLOUD_SETTING_URLS + ' call ');
        if (Array.isArray(urls) &&
            urls.length > 0 &&
            urls.every(function (v) { return typeof v === 'string' && v.indexOf('http') > -1; })) {
            this.cloudSetting.init({
                product: zego_config_1.CLOUD_SETTING.product,
                appID: this.stateCenter.appid,
                urls: urls,
                pollingFreq: zego_config_1.CLOUD_SETTING.POLLING_FREQ,
                env: this.stateCenter.ENV,
                pollingNotify: function (file, settingJson) {
                    _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SET_CLOUD_SETTING_URLS, ' setting file changed ' + file + ' ' + JSON.stringify(settingJson));
                    _this.stateCenter.actionListener('_cloudSettingNotify', file, settingJson);
                },
                reportNotify: this.cloudReportNotify.bind(this),
                online: !this.stateCenter.testEnvironment,
            });
        }
    };
    //---
    ZegoExpressWebRTM.prototype.loginRoom = function (roomID, token, user, config) {
        var _this = this;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM + ' call by user ' + (user === null || user === void 0 ? void 0 : user.userID) + ' ' + roomID);
        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
            var _a, interResolve, interReject, res, roomModules, roomServer;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(this.stateCenter.ENV === 1)) return [3 /*break*/, 2];
                        return [4 /*yield*/, new Promise(function (resolveNetWoke) {
                                wx.getNetworkType({
                                    success: function (res) {
                                        _this.stateCenter.networkState =
                                            res.networkType === 'none' ? zego_entity_1.ENUM_NETWORK_STATE.offline : zego_entity_1.ENUM_NETWORK_STATE.online;
                                        resolveNetWoke();
                                    },
                                    fail: function (err) {
                                        _this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_CONSTRUCTOR + ' network ' + JSON.stringify(err));
                                        _this.stateCenter.networkState = zego_entity_1.ENUM_NETWORK_STATE.online;
                                        resolveNetWoke();
                                    },
                                });
                            })];
                    case 1:
                        _b.sent();
                        _b.label = 2;
                    case 2:
                        _a = this.loginReport(resolve, reject, token, config), interResolve = _a.interResolve, interReject = _a.interReject;
                        config = config || {};
                        !config.maxMemberCount && (config.maxMemberCount = 0);
                        res = param_util_1.checkParams({
                            roomID: {
                                order: 0,
                                value: roomID,
                                rules: [
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.NOT_EMPTY,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.ROOM_ID_NULL,
                                    },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.TYPE_STRING,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.INPUT_PARAM,
                                        extMsg: 'roomID must be string',
                                    },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.MAX_LENGTH_128,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.ROOM_ID_TOO_LONG,
                                    },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.ILLEGAL_CHARACTERS,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.ROOM_ID_INVALID_CHARACTER,
                                    },
                                ],
                            },
                            token: {
                                order: 1,
                                value: token,
                                rules: [
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.NOT_EMPTY,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.INPUT_PARAM,
                                    },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.TYPE_STRING,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.INPUT_PARAM,
                                    },
                                ],
                            },
                            user: {
                                order: 2,
                                value: user,
                                rules: [
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.NOT_EMPTY,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.INPUT_PARAM,
                                        extMsg: ' param user error.',
                                    },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.TYPE_OBJECT,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.INPUT_PARAM,
                                        extMsg: ' param user error.',
                                    },
                                ],
                            },
                            'user.userID': {
                                order: 3,
                                value: user.userID,
                                rules: [
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.NOT_EMPTY,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.USER_ID_NULL,
                                        extMsg: ' param user error.',
                                    },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.TYPE_STRING,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.INPUT_PARAM,
                                        extMsg: ' param userID error.',
                                    },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.MAX_LENGTH_100,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.USER_ID_TOO_LONG,
                                    },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.ILLEGAL_CHARACTERS,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.USER_ID_INVALID_CHARACTER,
                                    },
                                ],
                            },
                            'user.userName': {
                                order: 4,
                                value: user.userName,
                                rules: [
                                    // {
                                    //     name: RULE_PARAM_NAME.NOT_EMPTY,
                                    //     error: ZegoRTMLogEvent.kZegoTaskLoginRoom.error.USER_NAME_NULL,
                                    // },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.TYPE_STRING,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.INPUT_PARAM,
                                        extMsg: ' userName must be string.',
                                    },
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.MAX_LENGTH_256,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.USER_NAME_TOO_LONG,
                                    },
                                ],
                            },
                            config: {
                                order: 5,
                                value: config,
                                rules: [],
                            },
                            'config.maxMemberCount': {
                                order: 6,
                                value: config.maxMemberCount,
                                rules: [
                                    {
                                        name: param_util_1.RULE_PARAM_NAME.TYPE_INTEGER,
                                        error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.INPUT_PARAM,
                                        extMsg: ' maxMemberCount must be integer number.',
                                    },
                                ],
                            },
                        }, {
                            action: zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM,
                            logger: this.logger,
                        });
                        if (res !== param_util_1.RULE_SUCCESS) {
                            interReject(res.error, res.extMsg);
                            return [2 /*return*/];
                        }
                        if (this.netAgent) {
                            this.stateCenter.idName = user.userID;
                            this.stateCenter.actionListener('_roomLogin', roomID, token);
                            if (this.netAgent.isConnect()) {
                                this.fetchAppConfig(token);
                            }
                        }
                        // 
                        this.cloudSetting.setUserID(user.userID);
                        this.cloudSetting.setToken(token);
                        this.cloudSetting.activePolling();
                        this.stateCenter.onListener('roomLoginResponse', function (msg) {
                            if (!_this.stateCenter.settingFetched) {
                                _this.getCloudSetting();
                                _this.stateCenter.actionListener('_settingCanFetch');
                                _this.stateCenter.settingFetched = true;
                            }
                        });
                        roomModules = this.getRoomModules(roomID);
                        if (!roomModules) {
                            roomModules = new modules_1.LiveRoomModules(roomID, this.stateCenter, this.logger, this.dataReport, this.service, this, this.liveRoomHandler);
                            if (this.stateCenter.roomModulesList.length > 0 && this.stateCenter.isMultiRoom == true) {
                                //
                                roomModules.isMulti = true;
                            }
                            else {
                                __spreadArrays(this.stateCenter.roomModulesList).forEach(function (room) { return room.roomHandler.logout(); });
                            }
                            this.stateCenter.roomModulesList.push(roomModules);
                        }
                        else {
                            //
                            interReject(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.REPEATEDLY_LOGIN);
                            return [2 /*return*/];
                        }
                        if (!roomModules.roomTryHandler) {
                            roomModules.roomTryHandler = new retryRoomHandler_1.RetryRoomHandler(this.logger, this.stateCenter, roomModules);
                        }
                        roomServer = this.stateCenter.settingConfig.getSetting('room_server', true);
                        if (Array.isArray(roomServer) && roomServer.length > 0) {
                            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM, ' setting room_server ' + roomServer);
                            this.stateCenter.server = roomServer[0];
                            this.stateCenter.serverBak = roomServer[1] || roomServer[0];
                        }
                        roomModules.roomTryHandler.init(this.stateCenter.roomRetryTime);
                        roomModules.roomTryHandler.initRoom(roomModules.roomHandler, roomID, token, user, this.stateCenter.server, this.stateCenter.serverBak, config);
                        roomModules.roomTryHandler.setLoginRoomCallback(interResolve, interReject);
                        //multiRoom
                        this.stateCenter.setMultiRoom = true;
                        if (this.stateCenter.useNetAgent && !this.netAgent.isConnect()) {
                            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM, ' us is not connected');
                            this.netAgent.connectUa();
                            return [2 /*return*/];
                        }
                        roomModules.roomTryHandler.active(true);
                        return [2 /*return*/];
                }
            });
        }); });
    };
    ZegoExpressWebRTM.prototype.handleLogUpload = function () {
        var domain = this.stateCenter.appConfig.app_config.domain;
        //  appid 
        if (!domain) {
            return;
        }
        this.stateCenter.logDomain = "weblogger" + this.stateCenter.appid + "-api." + domain;
        var logUrl = '';
        if (this.stateCenter.ENV === 0) {
            logUrl = "wss://" + this.stateCenter.logDomain + "/log";
        }
        else {
            logUrl = "https://" + this.stateCenter.logDomain + "/httplog";
        }
        this.logger.setLogServer(logUrl);
    };
    ZegoExpressWebRTM.prototype.fetchAppConfig = function (token) {
        return __awaiter(this, void 0, void 0, function () {
            var userID, _token, _a, code, data, app_config, _b, publish_config, play_config, configString, ciphertext, error_1;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (this.stateCenter.appConfigFetched) {
                            this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_FETCH_APP_CONFIG + ' config fetched');
                            return [2 /*return*/];
                        }
                        userID = this.getUserID();
                        if (!userID) {
                            this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_FETCH_APP_CONFIG + ' user not exist');
                            return [2 /*return*/];
                        }
                        _token = '';
                        if (token) {
                            _token = token;
                        }
                        else if (this.stateCenter.roomModulesList.length > 0) {
                            _token = this.getToken();
                        }
                        else {
                            this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_FETCH_APP_CONFIG + ' token not exist');
                            return [2 /*return*/];
                        }
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.netAgent.getAppConfig(userID, _token)];
                    case 2:
                        _a = _c.sent(), code = _a.code, data = _a.data;
                        this.stateCenter.appConfigFetched = true;
                        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM + ' initConfig code:' + code + ' data: ' + JSON.stringify(data));
                        app_config = data.app_config, _b = data.media_config, publish_config = _b.publish_config, play_config = _b.play_config;
                        this.stateCenter.appConfig = { app_config: app_config, media_config: { publish_config: publish_config, play_config: play_config } };
                        configString = JSON.stringify(this.stateCenter.appConfig);
                        ciphertext = client_util_1.ClientUtil.encryptStores(configString, zego_config_1.STORE_SECRET);
                        localStorage.setItem(net_config_1.APP_CONFIG_KEY + '_' + this.getAppID() + '_' + net_1.NET_ACCESS_CONFIG.modeNo, ciphertext);
                        if (!this.stateCenter.appConfig) {
                            this.stateCenter.actionListener('_appConfigRsp');
                            this.handleLogUpload();
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _c.sent();
                        this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM + ' fail ' + JSON.stringify(error_1));
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    ZegoExpressWebRTM.prototype.getHttpRequest = function () {
        var mixRequest = this.netAgent.getHttpRequest(AccessHubDefine_1.BusinessService.SERVICE_MIX);
        mixRequest &&
            mixRequest.sendRequest({
                headers: [],
                body: {},
                idName: this.stateCenter.idName,
                method_no: AccessHubDefine_2.Method.METHOD_POST,
                ack: true,
                location: '',
            }, function () { }, function () { }, function () { });
    };
    ZegoExpressWebRTM.prototype.getLiveRoomPCRequest = function () {
        var liveroomRequest = this.netAgent.getPCRequest(AccessHubDefine_1.BusinessService.SERVICE_SWITCH4LIVEROOM);
        // if (liveroomRequest) {
        liveroomRequest.on('connected', function () { });
        liveroomRequest.on('broken', function () { });
        liveroomRequest.on('disconnected', function () { });
        liveroomRequest.on('downLoadMessage', function (payload) { });
        liveroomRequest.sendRequest({ payload: '' }, function () { }, function (err) { });
        // }
    };
    ZegoExpressWebRTM.prototype.getCloudSetting = function () {
        var _this = this;
        this.cloudSetting
            .fetchMultiSetting([zego_config_1.INIT, zego_config_1.ROOM_BASIC])
            .then(function (settingConfig) {
            var _a;
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM, ' settingConfig ' + JSON.stringify(settingConfig));
            _this.stateCenter.settingConfig.setSetting((_a = settingConfig === null || settingConfig === void 0 ? void 0 : settingConfig[zego_config_1.INIT]) === null || _a === void 0 ? void 0 : _a.setting, ['remote_log_level']);
            var level = _this.stateCenter.settingConfig.getSetting('remote_log_level', true);
            if (level) {
                _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM + "  setting remote_log_level " + level);
                _this.logger.setRemoteLogLevel(level);
            }
        })
            .catch(function (err) {
            _this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM, ' settingConfig ' + JSON.stringify(err));
        });
        this.stateCenter.onListener('_cloudSettingNotify', function (file, settingFile) {
            var reportSeq = zego_entity_2.getReportSeq();
            _this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskCloudSettingRefresh.event);
            var params = _this.cloudSetting.getEnvVariables();
            _this.dataReport.addMsgInfo(reportSeq, {
                params: params,
                files: [
                    {
                        name: file,
                        content: settingFile.setting,
                        versions: settingFile.versions,
                    },
                ],
            });
            _this.dataReport.uploadReport(reportSeq);
            if (file === zego_config_1.INIT) {
                _this.stateCenter.settingConfig.setSetting(settingFile === null || settingFile === void 0 ? void 0 : settingFile.setting, ['remote_log_level']);
                var level = _this.stateCenter.settingConfig.getSetting('remote_log_level');
                if (level) {
                    _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGIN_ROOM, " setting remote_log_level " + level);
                    _this.logger.setRemoteLogLevel(level);
                }
            }
        });
    };
    ZegoExpressWebRTM.prototype.cloudReportNotify = function (seq, event, extData) {
        // console.warn(seq, event, reportData);
        if (event === 'request_start') {
            var requestSeq = zego_entity_2.getReportSeq();
            this.dataReport.newReport(requestSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskCloudSettingRequest.event);
            this.stateCenter.settingConfig.requestList[seq] = requestSeq;
        }
        else if (event === 'request_end') {
            var rseq = this.stateCenter.settingConfig.requestList[seq];
            if (rseq) {
                this.dataReport.addMsgInfo(rseq, {
                    request_detail: extData === null || extData === void 0 ? void 0 : extData.reportData,
                    files: extData === null || extData === void 0 ? void 0 : extData.files,
                    error: extData === null || extData === void 0 ? void 0 : extData.code,
                    request_params: extData === null || extData === void 0 ? void 0 : extData.params,
                });
                this.dataReport.uploadReport(rseq);
            }
        }
    };
    // 
    ZegoExpressWebRTM.prototype.loginReport = function (resolve, reject, token, config) {
        var _this = this;
        // 
        if (this.stateCenter.reportSeqList.login !== 0) {
            this.dataReport.uploadReport(this.stateCenter.reportSeqList.login);
            this.stateCenter.reportSeqList.login = 0;
            client_util_1.ClientUtil.unregisterCallback(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.event, this.stateCenter.reportList);
        }
        // 
        var reportSeq = zego_entity_2.getReportSeq();
        this.stateCenter.reportSeqList.login = reportSeq;
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.event);
        var deviceid = this.cloudSetting.getEnvVariable('deviceid');
        this.dataReport.addMsgInfo(reportSeq, {
            deviceid: deviceid,
        });
        typeof token === 'string' &&
            this.dataReport.addMsgInfo(reportSeq, {
                token: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.token(token),
                isMulti: this.stateCenter.isMultiRoom,
            });
        if (config) {
            if (config.userUpdate && typeof config.userUpdate == 'boolean') {
                this.dataReport.addMsgInfo(reportSeq, {
                    user_update: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.user_update(config.userUpdate + ''),
                });
            }
            if (config.maxMemberCount && typeof config.maxMemberCount == 'number') {
                this.dataReport.addMsgInfo(reportSeq, {
                    max_member_count: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.max_member_count(config.maxMemberCount + ''),
                });
            }
        }
        // register event trigger, can add report event by actionSuccessCallback
        client_util_1.ClientUtil.logReportCallback(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.event, this.dataReport, reportSeq, this.stateCenter.reportList);
        var interResolve = function (suc) {
            _this.dataReport.uploadReport(reportSeq);
            _this.stateCenter.reportSeqList.login = 0;
            client_util_1.ClientUtil.unregisterCallback(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.event, _this.stateCenter.reportList);
            resolve(suc);
        };
        var interReject = function (err, exterMsg) {
            if (exterMsg === void 0) { exterMsg = ''; }
            var reportErr, exterErr;
            //  liveroom 
            if ((err.code < 2000000000 && err.code > 1000000000) || err.code < 1000000) {
                reportErr = client_util_1.ClientUtil.decodeServerError(err.code, err.msg);
                exterErr = client_util_1.ClientUtil.getLiveRoomError(err.code, _this.stateCenter.useNetAgent);
            }
            else {
                reportErr = {
                    code: err.code,
                    message: err.msg,
                };
            }
            reportErr &&
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: reportErr.code,
                    message: reportErr.message + exterMsg,
                });
            _this.dataReport.uploadReport(reportSeq);
            _this.stateCenter.reportSeqList.login = 0;
            client_util_1.ClientUtil.unregisterCallback(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.event, _this.stateCenter.reportList);
            // @ts-ignore
            if (exterErr && zego_externalError_1.errorCodeList[exterErr]) {
                // @ts-ignore
                err.code = zego_externalError_1.errorCodeList[exterErr].code;
                // @ts-ignore
                // err.msg = errorCodeList[exterErr].msg + exterMsg;
            }
            if (err.code && err.msg && exterMsg !== '') {
                reject({
                    code: err.code,
                    msg: err.msg + exterMsg,
                });
            }
            else {
                reject(err);
            }
        };
        return { interResolve: interResolve, interReject: interReject };
    };
    ZegoExpressWebRTM.prototype.logoutRoom = function (roomID) {
        this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGOUT_ROOM + ' call by user ' + roomID);
        var reportSeq = zego_entity_2.getReportSeq();
        this.dataReport.newReport(reportSeq);
        this.dataReport.addMsgInfo(reportSeq, {
            roomid: roomID,
            isMulti: this.stateCenter.isMultiRoom,
        });
        if (roomID === undefined) {
            //roomID,
            __spreadArrays(this.stateCenter.roomModulesList).forEach(function (room) { return room.roomHandler.logout(true); });
            this.cloudSetting.uninit();
        }
        else {
            if (typeof roomID !== 'string' || roomID == '') {
                this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGOUT_ROOM + ' roomID must be string and not empty');
                this.dataReport.addMsgInfo(reportSeq, {
                    error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLogoutRoom.error.INPUT_PARAM.code,
                    message: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLogoutRoom.error.INPUT_PARAM.msg + ' param roomID error',
                });
                this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLogoutRoom.event);
                return;
            }
            var room = this.getRoomModules(roomID);
            if (room) {
                room.roomHandler.logout();
                if (this.stateCenter.roomModulesList.length === 0) {
                    this.cloudSetting.uninit();
                }
                this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLogoutRoom.event);
            }
            else {
                this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_LOGOUT_ROOM + ' room not exist');
                this.dataReport.addMsgInfo(reportSeq, {
                    error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLogoutRoom.error.ROOM_NOT_EXIST.code,
                    message: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLogoutRoom.error.ROOM_NOT_EXIST.msg,
                });
                this.dataReport.uploadReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLogoutRoom.event);
            }
        }
    };
    //
    ZegoExpressWebRTM.prototype.loginHall = function (token, user, config) {
        var _this = this;
        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2 /*return*/];
        }); }); });
    };
    ZegoExpressWebRTM.prototype.loginHallReport = function (resolve, reject, token, config) { };
    //
    ZegoExpressWebRTM.prototype.logoutHall = function () { };
    //---
    ZegoExpressWebRTM.prototype.enterRoom = function (roomID, role) {
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    ZegoExpressWebRTM.prototype.leaveRoom = function () {
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    // public getRoomInfo(callBack: Function): void {
    //     (this.module as LiveRoomPriModules).roomPrivateHandler.getRoomInfo();
    // }
    ZegoExpressWebRTM.prototype.sendCustomCommand = function (roomID, command, toUserList) {
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    ZegoExpressWebRTM.prototype._sendCustomCommand = function (roomID, command, toUserList) {
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    ZegoExpressWebRTM.prototype.sendBroadcastMessage = function (roomID, message) {
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    ZegoExpressWebRTM.prototype._sendBroadcastMessage = function (roomID, message, category, type) {
        if (category === void 0) { category = 1; }
        if (type === void 0) { type = 1; }
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    ZegoExpressWebRTM.prototype.setRoomExtraInfo = function (roomID, type, data) {
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    ZegoExpressWebRTM.prototype._setRoomExtraInfo = function (roomID, type, data) {
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    ZegoExpressWebRTM.prototype.sendBarrageMessage = function (roomID, message) {
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    ZegoExpressWebRTM.prototype._sendBarrageMessage = function (roomID, message, category, type) {
        if (category === void 0) { category = 1; }
        if (type === void 0) { type = 1; }
        return new Promise(function (resolve, reject) {
            console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
            reject();
        });
    };
    ZegoExpressWebRTM.prototype.sendRelayMessage = function (type, data, success, error, roomID) {
        console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
    };
    ZegoExpressWebRTM.prototype.requestJoinLive = function (destIdName, success, error, resultCallback, roomID) {
        console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
        return false;
    };
    ZegoExpressWebRTM.prototype.inviteJoinLive = function (destIdName, success, error, resultCallback, roomID) {
        console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
        return false;
    };
    ZegoExpressWebRTM.prototype.endJoinLive = function (destIdName, success, error, roomID) {
        console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
        return false;
    };
    ZegoExpressWebRTM.prototype.respondJoinLive = function (requestId, respondResult, success, error, roomID) {
        console.error(zego_entity_1.MODULE_TIPS.MESSAGE);
        return false;
    };
    ZegoExpressWebRTM.prototype.getVersion = function () {
        return this.version;
    };
    ZegoExpressWebRTM.prototype.setSdkBizVersion = function (bizVersion) {
        if (typeof bizVersion === 'string' && bizVersion !== '') {
            this.stateCenter.bizVersion = bizVersion;
        }
    };
    ZegoExpressWebRTM.prototype.on = function (event, callBack) {
        if (!this.stateCenter.listenerList[event]) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_ON + ' event ' + event + ' no found');
            return false;
        }
        if (typeof callBack !== 'function') {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_ON + ' listener callBack must be funciton');
            return false;
        }
        this.stateCenter.listenerList[event].indexOf(callBack) == -1 &&
            this.stateCenter.listenerList[event].push(callBack);
        return true;
    };
    ZegoExpressWebRTM.prototype.off = function (event, callBack) {
        if (!this.stateCenter.listenerList[event]) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_OFF + ' listener no found');
            return false;
        }
        var li = this.stateCenter.listenerList[event];
        if (callBack) {
            li.splice(li.indexOf(callBack), 1);
        }
        else {
            this.stateCenter.listenerList[event] = [];
        }
        return true;
    };
    ZegoExpressWebRTM.prototype._on = function (event, callBack) {
        if (!this.stateCenter.listenerList[event]) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_ON + ' event ' + event + ' no found');
            return false;
        }
        if (typeof callBack !== 'function') {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_ON + ' listener callBack must be funciton');
            return false;
        }
        this.stateCenter.listenerList[event].indexOf(callBack) == -1 &&
            this.stateCenter.listenerList[event].push(callBack);
        return true;
    };
    ZegoExpressWebRTM.prototype._off = function (event, callBack) {
        if (!this.stateCenter.listenerList[event]) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_OFF + ' listener no found');
            return false;
        }
        var li = this.stateCenter.listenerList[event];
        if (callBack) {
            li.splice(li.indexOf(callBack), 1);
        }
        else {
            this.stateCenter.listenerList[event] = [];
        }
        return true;
    };
    ZegoExpressWebRTM.prototype.isTestEnvironment = function () {
        return this.stateCenter.testEnvironment;
    };
    ZegoExpressWebRTM.prototype.isLogin = function (roomID) {
        var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
        return room ? room.isLogin() : false;
    };
    ZegoExpressWebRTM.prototype.getMultiRoom = function () {
        return this.stateCenter.isMultiRoom;
    };
    ZegoExpressWebRTM.prototype.getAppID = function () {
        return this.stateCenter.appid;
    };
    ZegoExpressWebRTM.prototype.getUserID = function () {
        return this.stateCenter.idName;
    };
    ZegoExpressWebRTM.prototype.getUseNetAgent = function () {
        return this.stateCenter.useNetAgent;
    };
    ZegoExpressWebRTM.prototype.getToken = function (roomID) {
        var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
        return room.token;
    };
    // public getAnType(): number {
    //     return (this.module as LiveRoomPriModules).anType;
    // }
    // public getRoomSid(): string {
    //     return (this.module as LiveRoomPriModules).roomSid;
    // }
    ZegoExpressWebRTM.prototype.setRoomCreateFlag = function (flag) {
        this.stateCenter.roomCreateFlag = flag;
    };
    ZegoExpressWebRTM.prototype.setRole = function (role) {
        this.stateCenter.role = role;
    };
    ZegoExpressWebRTM.prototype.getSessionId = function (roomID) {
        var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
        return room ? room.sessionID : '0';
    };
    ZegoExpressWebRTM.prototype.getRoomSessionID = function (roomID) {
        var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
        return room ? room.roomSessionID : '0';
    };
    ZegoExpressWebRTM.prototype.getAppConfig = function () {
        return this.stateCenter.appConfig;
    };
    ZegoExpressWebRTM.prototype.enableMultiRoom = function (isMulti) {
        var reportSeq = zego_entity_2.getReportSeq();
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoEnableMultiRoom.event);
        this.dataReport.addMsgInfo(reportSeq, {
            isMulti: isMulti,
        });
        if (typeof isMulti !== 'boolean') {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_ENABLE_MULTI_ROOM + ' param must be boolean');
            this.dataReport.uploadReport(reportSeq, undefined, zego_log_event_1.ZegoRTMLogEvent.kZegoEnableMultiRoom.error.kAlreadyLoginError);
            return false;
        }
        if (this.stateCenter.roomModulesList.length > 0 || this.stateCenter.setMultiRoom) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_ENABLE_MULTI_ROOM +
                ' multi room can only be set once before first login');
            this.dataReport.uploadReport(reportSeq, undefined, zego_log_event_1.ZegoRTMLogEvent.kZegoEnableMultiRoom.error.kAlreadyLoginError);
            return false;
        }
        this.dataReport.uploadReport(reportSeq);
        this.stateCenter.isMultiRoom = isMulti;
        this.stateCenter.setMultiRoom = true;
        return true;
    };
    ZegoExpressWebRTM.prototype.getRoomModules = function (roomID) {
        return this.stateCenter.roomModulesList.find(function (roomModules) { return roomModules.roomID == roomID; });
    };
    // private dispatchBodyData() {
    //     return {
    //         seq: 1,
    //         timestamp: new Date().getTime,
    //         app_id: this.stateCenter.appid,
    //         user_id: this.stateCenter.idName,
    //         user_name: this.stateCenter.nickName,
    //         net_type: 2,
    //         device_id: (this.module as LiveRoomPriModules).deviceID,
    //         login_token: (this.module as LiveRoomPriModules).hallToken,
    //         an_type: (this.module as LiveRoomPriModules).anType,
    //     };
    // }
    ZegoExpressWebRTM.use = function (module) {
        switch (module.type) {
            case 'message':
                module.install(ZegoExpressWebRTM, modules_1.LiveRoomModules, service_1.LiveRoomService, liveroomHandler_1.LiveRoomHandler, index_private_1.LiveRoomModules, service_private_1.LiveRoomPrivateService);
                break;
            case 'live':
                module.install(ZegoExpressWebRTM, modules_1.LiveRoomModules, service_1.LiveRoomService, liveroomHandler_1.LiveRoomHandler);
                break;
            case 'privates':
                module.install(ZegoExpressWebRTM, index_private_1.LiveRoomModules, service_private_1.LiveRoomPrivateService);
                break;
        }
    };
    // support RTC
    ZegoExpressWebRTM.prototype.resetRoomTokenTimer = function (roomID, remainTime) {
        var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
        if (room && remainTime && remainTime > 0) {
            room.roomHandler.resetTokenTimer(remainTime * 1000 - this.stateCenter.local_time_deviation);
        }
    };
    ZegoExpressWebRTM.prototype.isDisConnect = function () {
        if (this.stateCenter.useNetAgent) {
            return this.liveRoomHandler.isDisConnect();
        }
        else {
            return this.service.isDisConnect();
        }
    };
    ZegoExpressWebRTM.prototype.sendMessage = function (cmd, body, suc, err) {
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.sendMessage(cmd, body, suc, err);
    };
    // support whiteborad 
    //  jsonpb
    ZegoExpressWebRTM.prototype.setProtoFormat = function (format) {
        if (format === void 0) { format = 'json'; }
        if (['json', 'pb'].includes(format)) {
            this.stateCenter.protoFormat = format;
        }
        else {
            throw new Error("Failed to execute 'setProtoFormat': Arguments 'format' must be 'json' or 'pb'.");
        }
    };
    // 
    ZegoExpressWebRTM.prototype.setSdkLoginRelateService = function (relateService) {
        if (Array.isArray(relateService) && relateService.every(function (v) { return typeof v === 'string'; })) {
            this.stateCenter.relateService = relateService;
        }
    };
    // JSON
    ZegoExpressWebRTM.prototype.sendMessageByService = function (cmd, body, suc, err, theHeader, customRoom) {
        return this.service.sendMessage(cmd, body, suc, err, theHeader, customRoom);
    };
    // PB
    ZegoExpressWebRTM.prototype.getHeader = function (cmd) {
        var room = this.stateCenter.roomModulesList[0];
        if (!room || !room.isLogin()) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_GET_HEADER + ' room no found or no login');
            return;
        }
        var roomID = room.roomID;
        var sessionID = room.sessionID;
        var roomSessionID = room.roomSessionID;
        return this.service.getHeader(cmd, sessionID, roomID, roomSessionID);
    };
    // PB
    ZegoExpressWebRTM.prototype.sendPB = function (msg) {
        if (!(msg instanceof Uint8Array)) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_PB + ' type error');
            return false;
        }
        return this.service.sendPB(msg);
    };
    //  biz_channel 
    ZegoExpressWebRTM.prototype.onPushBizChannel = function (callback) {
        callback && this.service.on('push_biz_channel', callback);
    };
    // 
    ZegoExpressWebRTM.prototype.getRoomID = function () {
        return this.stateCenter.roomid;
    };
    ZegoExpressWebRTM.prototype.getServerTimeOffset = function () {
        return this.stateCenter.serverTimeOffset;
    };
    // 
    ZegoExpressWebRTM.prototype.isUseNetAgent = function () {
        return this.stateCenter.useNetAgent;
    };
    ZegoExpressWebRTM.prototype.getReqHead = function (roomID) {
        var room;
        if (typeof roomID === 'string' && roomID !== '') {
            room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
        }
        else {
            room = this.stateCenter.roomModulesList[0];
        }
        return this.liveRoomHandler.getReqHead(room);
    };
    ZegoExpressWebRTM.prototype.sendSwitchMessage = function (cmd, body) {
        if (typeof cmd !== 'string' || !body) {
            return -1;
        }
        return this.liveRoomHandler.sendMessage(cmd, body, undefined, undefined, undefined, false);
    };
    ZegoExpressWebRTM.prototype.onSwitchMessage = function (callback) {
        console.error('onSwitchMessage', callback, this.liveRoomHandler);
        callback && this.liveRoomHandler && (this.liveRoomHandler.onSwitchMessage = callback);
    };
    return ZegoExpressWebRTM;
}());
exports.ZegoExpressWebRTM = ZegoExpressWebRTM;


/***/ }),

/***/ "./sdk/src/modules/EventManager.ts":
/*!*****************************************!*\
  !*** ./sdk/src/modules/EventManager.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EventManager = void 0;
var EventManager = /** @class */ (function () {
    function EventManager() {
        this.handlerListMap = {};
    }
    EventManager.prototype.addEventHandler = function (listener, callBack) {
        if (!this.handlerListMap[listener]) {
            // return false;
            this.handlerListMap[listener] = [];
        }
        if (typeof callBack !== 'function') {
            throw new Error('Params callBack is not a Function');
        }
        this.handlerListMap[listener] &&
            this.handlerListMap[listener].indexOf(callBack) == -1 &&
            this.handlerListMap[listener].push(callBack);
        return true;
    };
    EventManager.prototype.removeEventHandler = function (listener, callBack) {
        if (!this.handlerListMap[listener]) {
            return false;
        }
        if (callBack) {
            this.handlerListMap[listener] = this.handlerListMap[listener].filter(function (item) { return item !== callBack; });
        }
        else {
            this.handlerListMap[listener] = [];
        }
        return true;
    };
    EventManager.prototype.emit = function (listener) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.handlerListMap[listener] &&
            this.handlerListMap[listener].forEach(function (func) {
                try {
                    setTimeout(function () {
                        func.apply(void 0, args);
                    }, 0);
                }
                catch (error) {
                    console.error('dispatch ' + listener + ' ' + error);
                }
            });
    };
    return EventManager;
}());
exports.EventManager = EventManager;


/***/ }),

/***/ "./sdk/src/modules/heartBeatHandler.ts":
/*!*********************************************!*\
  !*** ./sdk/src/modules/heartBeatHandler.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_463726__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HeartBeatHandler = void 0;
var zego_entity_1 = __nested_webpack_require_463726__(/*! ../zego.entity */ "./sdk/src/zego.entity.ts");
var client_util_1 = __nested_webpack_require_463726__(/*! ../../util/client-util */ "./sdk/util/client-util.ts");
var zego_externalError_1 = __nested_webpack_require_463726__(/*! ../zego.externalError */ "./sdk/src/zego.externalError.ts");
var zego_action_1 = __nested_webpack_require_463726__(/*! ../zego.action */ "./sdk/src/zego.action.ts");
var zego_log_event_1 = __nested_webpack_require_463726__(/*! ../zego.log.event */ "./sdk/src/zego.log.event.ts");
var MAX_TRY_HEARTBEAT_COUNT = 3; //
var HeartBeatHandler = /** @class */ (function () {
    function HeartBeatHandler(logger, stateCenter, dataReport, service, liveRoomHandler, room) {
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.dataReport = dataReport;
        this.service = service;
        this.liveRoomHandler = liveRoomHandler;
        this.room = room;
        this.tryHeartbeatCount = 0;
        this.heartbeatTimer = null;
        this.loginHeartbeatTimer = null;
        this.initCount = 0;
    }
    //
    HeartBeatHandler.prototype.init = function (msg) {
        var _this = this;
        var heartbeatInterval;
        // if (this.stateCenter.type == 'PRIVATE') {
        //     heartbeatInterval =
        //         msg.body.hb_interval < MINIUM_HEARTBEAT_INTERVAL ? MINIUM_HEARTBEAT_INTERVAL : msg.body.hb_interval;
        //     const heartbeatTimeout = msg.body.hb_timeout || 40000;
        //     MAX_TRY_HEARTBEAT_COUNT = heartbeatTimeout / heartbeatInterval + 1;
        // } else {
        heartbeatInterval =
            msg.body.hearbeat_interval < zego_entity_1.MINIUM_HEARTBEAT_INTERVAL
                ? zego_entity_1.MINIUM_HEARTBEAT_INTERVAL
                : msg.body.hearbeat_interval;
        // }
        this.tryHeartbeatCount = 0;
        this.heartbeatTimer && clearTimeout(this.heartbeatTimer);
        this.loginHeartbeatTimer = setTimeout(function () {
            _this.start(heartbeatInterval);
        }, heartbeatInterval);
        this.initCount++;
    };
    HeartBeatHandler.prototype.start = function (heartbeatInterval) {
        var _this = this;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.HEARTBEAT_START + ' call');
        var reportSeq = zego_entity_1.getReportSeq();
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomHB.event);
        this.dataReport.addMsgInfo(reportSeq, {
            room_sid: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomHB.room_sid(this.room.sessionID),
        });
        // login
        if (!this.room.isLogin()) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.HEARTBEAT_START + ' state error');
            this.dataReport.addMsgInfo(reportSeq, {
                error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomHB.error.NOT_LOGIN.code,
                message: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomHB.error.NOT_LOGIN.msg,
            });
            this.dataReport.uploadReport(reportSeq);
            return;
        }
        // 
        if (++this.tryHeartbeatCount > MAX_TRY_HEARTBEAT_COUNT) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.HEARTBEAT_START + ' come to try limit');
            this.dataReport.addMsgInfo(reportSeq, {
                error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomHB.error.HB_TIMEOUT.code,
                message: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomHB.error.HB_TIMEOUT.msg,
            });
            this.dataReport.uploadReport(reportSeq);
            this.hbLogout(zego_externalError_1.errorCodeList.HEARTBEAT_TIMEOUT);
            return;
        }
        var heartBeatCallBack = function (msg) {
            var code = _this.stateCenter.type == 'PRIVATE' ? msg.body && msg.body.code : msg.body && msg.body.err_code;
            if (!msg.header || !msg.body) {
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: msg.code > 0 ? msg.code : zego_externalError_1.errorCodeList.ROOM_INNER_ERROR.code,
                    message: msg.msg ? msg.msg : zego_externalError_1.errorCodeList.ROOM_INNER_ERROR,
                });
            }
            else if (code !== 0) {
                var err = client_util_1.ClientUtil.decodeServerError(msg.body.err_code || msg.body.code, msg.body.err_message || msg.body.message);
                _this.dataReport.addMsgInfo(reportSeq, {
                    error: err.code,
                    message: err.message + msg.body.err_code,
                });
            }
            _this.dataReport.uploadReport(reportSeq);
            // this.stateCenter.type == 'PRIVATE' ? this.handlePrivateHeartbeatRsp(msg) : 
            _this.handleHeartbeatRsp(msg);
        };
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.heartBeat(heartBeatCallBack, heartBeatCallBack, this.room);
        this.heartbeatInterval = heartbeatInterval;
        // heartbeatInterval
        var _heartbeatInterval = this.heartbeatInterval;
        if (this.initCount >= 2) {
            _heartbeatInterval = Math.round(Math.random() * (this.heartbeatInterval + 1));
            this.initCount = 1;
        }
        else {
            _heartbeatInterval = this.heartbeatInterval;
        }
        this.heartbeatTimer = setTimeout(function () {
            _this.start(_this.heartbeatInterval);
        }, _heartbeatInterval);
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.HEARTBEAT_START + ' call success');
    };
    /*
     *    "hhbr.0": "ZegoExpressEngine.handleHeartbeatRsp",
     */
    HeartBeatHandler.prototype.handleHeartbeatRsp = function (msg) {
        if (msg.body && msg.body.err_code && msg.body.err_code !== 0) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.HEARTBEAT_HEARTBEAT_RSP + ' disconnect, server error=', msg.body.err_code);
            // TODO
            if (msg.body.err_code == zego_entity_1.ERROR_CODES.ROOM_SESSION_ID_ERR) {
                this.hbLogout(zego_externalError_1.errorCodeList.HEARTBEAT_TIMEOUT);
                return;
            }
            // TODO room_session_id error
            this.hbLogout(client_util_1.ClientUtil.getServerError(msg.body.err_code));
            return;
        }
        else if (!msg.header || !msg.body) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.HEARTBEAT_HEARTBEAT_RSP + ' disconnect, error=', JSON.stringify(msg));
            // TODO room_session_id error
            this.hbLogout(msg);
            return;
        }
        //reset heartbeat fail count
        this.tryHeartbeatCount = 0;
        // 0  interval
        if (msg.body.hearbeat_interval !== 0) {
            this.heartbeatInterval = msg.body.hearbeat_interval;
            if (this.heartbeatInterval < zego_entity_1.MINIUM_HEARTBEAT_INTERVAL) {
                this.heartbeatInterval = zego_entity_1.MINIUM_HEARTBEAT_INTERVAL;
            }
        }
        this.heartbeatRspNotiFy(msg);
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.HEARTBEAT_HEARTBEAT_RSP + ' call success');
    };
    // ,
    HeartBeatHandler.prototype.heartbeatRspNotiFy = function (msg) { };
    // 
    HeartBeatHandler.prototype.hbLogout = function (err) { };
    HeartBeatHandler.prototype.resetHeartbeat = function () {
        clearTimeout(this.heartbeatTimer);
        this.heartbeatTimer = null;
        clearTimeout(this.loginHeartbeatTimer);
        this.loginHeartbeatTimer = null;
        this.tryHeartbeatCount = 0;
        this.initCount = 0;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.HEARTBEAT_RESET + ' call success');
    };
    return HeartBeatHandler;
}());
exports.HeartBeatHandler = HeartBeatHandler;


/***/ }),

/***/ "./sdk/src/modules/index.private.ts":
/*!******************************************!*\
  !*** ./sdk/src/modules/index.private.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_471953__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveRoomModules = void 0;
var zego_entity_1 = __nested_webpack_require_471953__(/*! ../zego.entity */ "./sdk/src/zego.entity.ts");
var heartBeatHandler_1 = __nested_webpack_require_471953__(/*! ./heartBeatHandler */ "./sdk/src/modules/heartBeatHandler.ts");
var userHandler_1 = __nested_webpack_require_471953__(/*! ./userHandler */ "./sdk/src/modules/userHandler.ts");
var LiveRoomModules = /** @class */ (function () {
    function LiveRoomModules(stateCenter, logger, dataReport, service, rtm) {
        this.stateCenter = stateCenter;
        this.logger = logger;
        this.dataReport = dataReport;
        this.service = service;
        this.rtm = rtm;
        this.roomID = '';
        this._dispatchServer = '';
        this.deviceID = '';
        this.deviceType = '';
        this.anType = 0;
        this.sessionExpire = '';
        this.pri_roomID = '';
        this.roomSid = '0';
        this.roomFlag = 1;
        this.timeStamp = 0;
        this.netType = 2;
        this.userSeq = 0;
        this.hallRunState = zego_entity_1.ENUM_RUN_STATE.logout;
        this.hallToken = '';
        this.roomSessionID = '';
        this.lastHallRunState = zego_entity_1.ENUM_RUN_STATE.logout;
        this.runRoomState = zego_entity_1.ENUM_RUN_STATE.logout;
        this.lastRunRoomState = zego_entity_1.ENUM_RUN_STATE.logout;
        this.lastHallState = 'DISCONNECTED';
        this.hallState = 'DISCONNECTED';
        this.lastRoomState = 'DISCONNECTED';
        this.roomState = 'DISCONNECTED';
        this.sessionID = '';
        this.initHandler();
        this.heartBeatHandler = new heartBeatHandler_1.HeartBeatHandler(this.logger, this.stateCenter, this.dataReport, this.service, 
        // TODO
        // @ts-ignore
        undefined, this);
        this.userHandler = new userHandler_1.UserHandler(this.logger, this.stateCenter, this.dataReport, this.service, 
        // @ts-ignore
        undefined, this);
        this.initMessageHandler();
        this.init();
    }
    // install 
    LiveRoomModules.prototype.initMessageHandler = function () { };
    LiveRoomModules.prototype.initHandler = function () { };
    LiveRoomModules.prototype.init = function () {
        this.bindSocketHandler();
        this.bindHeatBeatHandler();
        // this.bindHallHandler();
        this.bindMessageHandler();
        this.bindLiveHandler();
        // this.bindRoomHandler();
    };
    /*
     *    "zb.cm.bsh.0": "ZegoClient.base.bindSocketHandler",
     */
    LiveRoomModules.prototype.bindSocketHandler = function () {
        var _this = this;
        this.service.handlePushUserStateUpdateMsg = function (msg) {
            _this.userHandler.handlePushUserStateUpdateMsg(msg);
        };
    };
    LiveRoomModules.prototype.bindHeatBeatHandler = function () {
        var _this = this;
        this.heartBeatHandler.hbLogout = function (err) { };
        //  ,
        this.heartBeatHandler.heartbeatRspNotiFy = function (msg) {
            // this.messageHandler.loginRsp(msg);
            //this.userHandler.patchUserList(msg);
            // sdk
            _this.HBResponse(msg);
        };
    };
    /*
     *    "zb.cm.brh": "ZegoClient.base.bindHallHandler",
     */
    LiveRoomModules.prototype.bindHallHandler = function () { };
    LiveRoomModules.prototype.bindUserHandler = function () { };
    LiveRoomModules.prototype.bindMessageHandler = function () { };
    LiveRoomModules.prototype.bindLiveHandler = function () { };
    LiveRoomModules.prototype.bindRoomHandler = function () { };
    LiveRoomModules.prototype.handleHbLogout = function (err) { };
    LiveRoomModules.prototype.HBResponse = function (msg) {
        this.stateCenter.actionListener('HBResponse', msg);
    };
    LiveRoomModules.prototype.roomLoginResponse = function (msg) {
        this.stateCenter.actionListener('roomLoginResponse', msg);
    };
    //
    LiveRoomModules.prototype.isLogin = function () {
        return this.hallRunState === zego_entity_1.ENUM_RUN_STATE.login;
    };
    return LiveRoomModules;
}());
exports.LiveRoomModules = LiveRoomModules;


/***/ }),

/***/ "./sdk/src/modules/index.ts":
/*!**********************************!*\
  !*** ./sdk/src/modules/index.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_476366__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveRoomModules = void 0;
var zego_entity_1 = __nested_webpack_require_476366__(/*! ../zego.entity */ "./sdk/src/zego.entity.ts");
var heartBeatHandler_1 = __nested_webpack_require_476366__(/*! ./heartBeatHandler */ "./sdk/src/modules/heartBeatHandler.ts");
// import { LiveHandler } from '../../live/liveHandler';
var roomHandler_1 = __nested_webpack_require_476366__(/*! ./roomHandler */ "./sdk/src/modules/roomHandler.ts");
var userHandler_1 = __nested_webpack_require_476366__(/*! ./userHandler */ "./sdk/src/modules/userHandler.ts");
var client_util_1 = __nested_webpack_require_476366__(/*! ../../util/client-util */ "./sdk/util/client-util.ts");
var zego_externalError_1 = __nested_webpack_require_476366__(/*! ../zego.externalError */ "./sdk/src/zego.externalError.ts");
var LiveRoomModules = /** @class */ (function () {
    function LiveRoomModules(roomID, stateCenter, logger, dataReport, service, rtm, liveRoomHandler) {
        this.roomID = roomID;
        this.stateCenter = stateCenter;
        this.logger = logger;
        this.dataReport = dataReport;
        this.service = service;
        this.rtm = rtm;
        this.liveRoomHandler = liveRoomHandler;
        this.runState = zego_entity_1.ENUM_RUN_STATE.logout;
        this.lastRunState = zego_entity_1.ENUM_RUN_STATE.logout;
        this.lastRoomState = 'DISCONNECTED';
        this.roomState = 'DISCONNECTED';
        this.roomSessionID = '0';
        this.sessionID = '0';
        this.isMulti = false;
        this.token = '';
        this.thirdToken = '';
        this.maxMemberCount = 0;
        this.lvKey = '';
        // uint64SessionID: Long = Long.fromInt(0);
        // uint64RoomSessionID: Long = Long.fromInt(0);
        this.roomName = '';
        this.roomHandler = new roomHandler_1.RoomHandler(this.logger, this.stateCenter, this.dataReport, this.service, this, liveRoomHandler);
        this.heartBeatHandler = new heartBeatHandler_1.HeartBeatHandler(this.logger, this.stateCenter, this.dataReport, this.service, this.liveRoomHandler, this);
        this.userHandler = new userHandler_1.UserHandler(this.logger, this.stateCenter, this.dataReport, this.service, this.liveRoomHandler, this);
        this.initMessageHandler();
        this.initLiveHandler();
        this.init();
    }
    // install 
    LiveRoomModules.prototype.initMessageHandler = function () { };
    LiveRoomModules.prototype.initLiveHandler = function () { };
    LiveRoomModules.prototype.init = function () {
        this.bindHeatBeatHandler();
        this.bindRoomHandler();
        this.bindMessageHandler();
        this.bindLiveHandler();
    };
    LiveRoomModules.prototype.bindHeatBeatHandler = function () {
        var _this = this;
        this.heartBeatHandler.hbLogout = function (err) {
            _this.roomHandler.handleHbLogout(err);
        };
        //  ,
        this.heartBeatHandler.heartbeatRspNotiFy = function (msg) {
            _this.messageHandler && _this.messageHandler.loginRsp(msg);
            _this.userHandler.patchUserList(msg);
            // sdk
            _this.HBResponse(msg);
        };
    };
    /*
     *    "zb.cm.brh": "ZegoClient.base.bindRoomHandler",
     */
    LiveRoomModules.prototype.bindRoomHandler = function () {
        var _this = this;
        this.roomHandler.loginSuccessCallBack = function (lastRunState, msg) {
            _this.heartBeatHandler.init(msg);
            // ;
            if (_this.stateCenter.useNetAgent) {
                _this.liveRoomHandler.startCheck();
            }
            else {
                _this.service.startCheck();
            }
            _this.userHandler.loginRsp(msg, lastRunState);
            _this.messageHandler && _this.messageHandler.loginRsp(msg);
            //  
            if (!_this.isMulti) {
                _this.handleMultiRoom();
            }
            // sdk
            _this.roomLoginResponse(msg);
        };
        this.roomHandler.resetRoomCallBack = function () {
            // 
            _this.heartBeatHandler.resetHeartbeat();
            // 
            _this.liveHandler && _this.liveHandler.resetLiveHandler();
            // 
            _this.messageHandler && _this.messageHandler.resetMessageInfo();
            // 
            _this.userHandler.resetUserHandler();
            //
            if (_this.roomTryHandler) {
                _this.roomTryHandler.invalid();
                _this.roomTryHandler.stopMaxTime();
                _this.roomTryHandler = undefined;
            }
        };
    };
    LiveRoomModules.prototype.bindUserHandler = function () { };
    LiveRoomModules.prototype.bindMessageHandler = function () { };
    LiveRoomModules.prototype.bindLiveHandler = function () { };
    LiveRoomModules.prototype.HBResponse = function (msg) {
        this.stateCenter.actionListener('HBResponse', msg);
    };
    LiveRoomModules.prototype.roomLoginResponse = function (msg) {
        this.stateCenter.actionListener('roomLoginResponse', msg);
    };
    LiveRoomModules.prototype.handleMultiRoom = function () {
        var _this = this;
        //
        //
        this.stateCenter.roomModulesList.forEach(function (room) {
            if (room.runState !== zego_entity_1.ENUM_RUN_STATE.login && room.roomTryHandler && room.isMulti == true) {
                room.roomTryHandler.onactive = function (success, error) {
                    if (error && error.code !== 0) {
                        //  liveroom 
                        if (error.code !== 0) {
                            var errorKey = client_util_1.ClientUtil.getLiveRoomError(error.code, _this.stateCenter.useNetAgent);
                            // @ts-ignore
                            if (errorKey && zego_externalError_1.errorCodeList[errorKey]) {
                                // @ts-ignore
                                error = zego_externalError_1.errorCodeList[errorKey];
                            }
                        }
                        room.roomHandler.roomStateHandle('DISCONNECTED', error, error.msg);
                    }
                    else {
                        room.roomHandler.roomStateHandle('CONNECTED', error);
                    }
                };
                room.roomTryHandler.startMaxTime();
                room.roomTryHandler.active();
            }
        });
    };
    //
    LiveRoomModules.prototype.isLogin = function () {
        return this.runState === zego_entity_1.ENUM_RUN_STATE.login;
    };
    LiveRoomModules.prototype.isDisConnect = function () {
        if (this.stateCenter.useNetAgent) {
            return this.liveRoomHandler.isDisConnect();
        }
        else {
            return this.service.isDisConnect();
        }
    };
    LiveRoomModules.prototype.resetSessionInfo = function () {
        var _a;
        this.sessionID = '0';
        this.roomSessionID = '0';
        (_a = this.liveRoomHandler) === null || _a === void 0 ? void 0 : _a.reset();
    };
    return LiveRoomModules;
}());
exports.LiveRoomModules = LiveRoomModules;


/***/ }),

/***/ "./sdk/src/modules/liveroomHandler.ts":
/*!********************************************!*\
  !*** ./sdk/src/modules/liveroomHandler.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_483826__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveRoomHandler = exports.LIVEROOM_STATE = void 0;
var zego_entity_1 = __nested_webpack_require_483826__(/*! ../zego.entity */ "./sdk/src/zego.entity.ts");
var liveroom_1 = __nested_webpack_require_483826__(/*! ./proto/liveroom */ "./sdk/src/modules/proto/liveroom.js");
var liveroom_2 = __importDefault(__nested_webpack_require_483826__(/*! ./proto/liveroom */ "./sdk/src/modules/proto/liveroom.js"));
var liveroom_3 = __nested_webpack_require_483826__(/*! ./proto/liveroom */ "./sdk/src/modules/proto/liveroom.js");
var zego_externalError_1 = __nested_webpack_require_483826__(/*! ../zego.externalError */ "./sdk/src/zego.externalError.ts");
var crypto_1 = __nested_webpack_require_483826__(/*! ../../util/crypto */ "./sdk/util/crypto.ts");
var AccessHubDefine_1 = __nested_webpack_require_483826__(/*! ./net/entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var string_1 = __nested_webpack_require_483826__(/*! ../../util/string */ "./sdk/util/string.ts");
var switchCmd_1 = __nested_webpack_require_483826__(/*! ./switchCmd */ "./sdk/src/modules/switchCmd.ts");
var long_1 = __importDefault(__nested_webpack_require_483826__(/*! long */ "./node_modules/long/src/long.js"));
var client_util_1 = __nested_webpack_require_483826__(/*! ../../util/client-util */ "./sdk/util/client-util.ts");
var zego_config_1 = __nested_webpack_require_483826__(/*! ../zego.config */ "./sdk/src/zego.config.ts");
var zego_action_1 = __nested_webpack_require_483826__(/*! ../zego.action */ "./sdk/src/zego.action.ts");
// import Long from 'long';
// import * as $protobuf from 'protobufjs/minimal';
// $protobuf.util.Long = Long;
// $protobuf.configure();
var ENUM_SIGNAL_SUB_CMD = {
    none: 0,
    joinLiveRequest: 1001,
    joinLiveResult: 1002,
    joinLiveInvite: 1003,
    joinLiveStop: 1004,
};
// LIVEROOM 
var LIVEROOM_STATE;
(function (LIVEROOM_STATE) {
    LIVEROOM_STATE[LIVEROOM_STATE["disconnected"] = 0] = "disconnected";
    LIVEROOM_STATE[LIVEROOM_STATE["broken"] = 1] = "broken";
    LIVEROOM_STATE[LIVEROOM_STATE["connected"] = 2] = "connected";
})(LIVEROOM_STATE = exports.LIVEROOM_STATE || (exports.LIVEROOM_STATE = {}));
var LiveRoomHandler = /** @class */ (function () {
    function LiveRoomHandler(logger, stateCenter, ua, rtm) {
        var _this = this;
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.ua = ua;
        this.rtm = rtm;
        this.seq = 0;
        this.controls = new Uint8Array(1);
        this.flags = new Uint8Array(1);
        this.sendCommandList = new zego_entity_1.LinkedList();
        this.sendCommandMap = {};
        this.isEncrypt = false;
        this.switchSessionID = long_1.default.fromInt(0);
        // 
        this.sendDataCheckOnceCount = 100;
        // ,
        this.sendDataDropTimeout = 10 * 1000;
        // 
        this.sendDataCheckInterval = 2000;
        this.protoInstance = liveroom_2.default;
        this.swPushCmdList = ['/sw/push', '/sw/merge_push', '/sw/push_kickout', '/sw/push_redirect'];
        this.onSwitchCmdList = ['/lr/login_room_rsp', '/lr/logout_room_rsp', '/sw/push_kickout', '/sw/push', '/sw/merge_push'];
        this.unEncryptCmdList = ['/lr/login_room', '/lr/login_room_rsp'];
        this.whiteboardPushCmdList = [
            '/edu/push/set_room',
            '/edu/push/set_user',
            '/edu/push/joinlive',
            '/edu/push/set_mod',
            '/edu/push/draw_graphics',
            '/edu/push/clear_graphics',
            '/edu/push/draw_page_graphics',
            '/edu/push/clear_page_graphics',
            '/edu/push/clear_user_graphic_list',
            '/edu/push/qaa',
            '/edu/push/set_user_auth',
            '/edu/push/set_room_auth',
        ];
        this.state = LIVEROOM_STATE.disconnected;
        this.unStructCmdList = [
            '/lr/push/joinlive_request',
            '/lr/push/joinlive_result',
            '/lr/push/joinlive_invite',
            '/lr/push/joinlive_stop',
        ];
        this.joinLiveMap = {
            '/lr/push/joinlive_request': 11001,
            '/lr/push/joinlive_result': 11002,
            '/lr/push/joinlive_invite': 11003,
            '/lr/push/joinlive_stop': 11004,
        };
        this.reloginToken = '';
        this.crypto = new crypto_1.Crypto();
        this.liveroom = this.ua.getPCRequest(AccessHubDefine_1.BusinessService.SERVICE_SWITCH4LIVEROOM);
        this.liveroom.on('connected', function () {
            _this.handleConnected();
        });
        this.liveroom.on('broken', function () {
            _this.handleBroken();
        });
        this.liveroom.on('disconnected', function () {
            _this.handleDisconnected();
        });
        this.liveroom.on('downLoadMessage', function (payload) {
            _this.handlePush(payload);
        });
    }
    Object.defineProperty(LiveRoomHandler.prototype, "nickName", {
        // protoMap = {
        //     '/lr/logout_room_rsp':
        // }
        get: function () {
            return string_1.encodeString(this.stateCenter.nickName);
        },
        enumerable: false,
        configurable: true
    });
    LiveRoomHandler.prototype.isDisConnect = function () {
        return this.state !== LIVEROOM_STATE.connected;
    };
    LiveRoomHandler.prototype.getHeader = function (cmd) {
        var header = {
            cmd: cmd,
            seq: ++this.seq,
            timestamp: new Date().getTime(),
            session_id: this.switchSessionID,
            controls: this.controls,
            flags: this.flags,
        };
        console.warn('header', header);
        var headerMessage = liveroom_1.proto_switch.Header.create(header);
        var headerBuffer = liveroom_1.proto_switch.Header.encode(headerMessage).finish();
        return [header.seq, headerBuffer];
    };
    LiveRoomHandler.prototype.isUaConnect = function () {
        return this.ua.isConnect();
    };
    LiveRoomHandler.prototype.sendMessage = function (cmd, body, success, error, option, isInSendMap) {
        var _this = this;
        var _a;
        if (option === void 0) { option = { timeout: 6 * 1000 }; }
        if (isInSendMap === void 0) { isInSendMap = true; }
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_SENDMESSAGE + ' call');
        if (cmd !== '/lr/login_room' && this.state !== LIVEROOM_STATE.connected) {
            this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_SENDMESSAGE + ' state ');
            return -1;
        }
        var _header = this.getHeader(cmd);
        var header = _header[1];
        var encryptBody = body;
        if (!this.unEncryptCmdList.includes(cmd) && this.isEncrypt) {
            encryptBody = this.crypto.encrypt(body);
        }
        var head = this.getHead(header.length, encryptBody.length);
        var message = new Uint8Array(Array.from(head)
            .concat(Array.from(header))
            .concat(Array.from(encryptBody)));
        if (isInSendMap) {
            var _err = function (msg, seq) {
                var _a, _b;
                if (((_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.cmd) !== '/lr/login_room_rsp' && [1002, 105].indexOf((_b = msg === null || msg === void 0 ? void 0 : msg.body) === null || _b === void 0 ? void 0 : _b.err_code) > -1) {
                    _this.rtm.retryRoom();
                    return;
                }
                error && error(msg, seq);
            };
            var cmdData = {
                seq: this.seq,
                deleted: false,
                sendTime: Date.parse(new Date() + ''),
                timeout: option.timeout,
                success: success,
                error: _err,
            };
            var cmdDataNode = this.sendCommandList.push(cmdData);
            this.sendCommandMap[cmdData.seq] = cmdDataNode;
        }
        //this.ua.(message);
        console.warn('sendMessage', cmd);
        (_a = this.liveroom) === null || _a === void 0 ? void 0 : _a.sendRequest({ payload: message, ack: true }, function (err) {
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_SENDMESSAGE + ' fail');
        }, function () {
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_SENDMESSAGE + ' ack');
        });
        return _header[0];
    };
    LiveRoomHandler.prototype.getHead = function (headerLen, bodyLen) {
        var head = new Uint8Array(7);
        head[0] = 0x21;
        head[1] = headerLen >> 8;
        head[2] = headerLen - (head[1] << 8);
        head.set(new Uint8Array(Int32Array.from([bodyLen]).buffer).reverse(), 3);
        return head;
    };
    LiveRoomHandler.prototype.handlePush = function (data) {
        var type = data[0];
        if (type !== 0x21) {
            return;
        }
        var headerLen = (data[1] << 8) + data[2];
        var header = liveroom_1.proto_switch.Header.decode(data.slice(7, 7 + headerLen));
        var bodyData = data.slice(7 + headerLen);
        var decryptBody = bodyData;
        if (!this.unEncryptCmdList.includes(header.cmd) && this.isEncrypt) {
            decryptBody = this.crypto.decrypt(bodyData);
        }
        // @ts-ignore
        if (!switchCmd_1.LiveroomProMap[header.cmd]) {
            console.warn('cmd not rtc');
            // 
            this.onSwitchMessage(header, decryptBody);
            return;
        }
        var originBody = this.decodeResponseBody(header, decryptBody);
        if (this.swPushCmdList.includes(header.cmd)) {
            this.handleSwitchPush(header, originBody);
            return;
        }
        var msg = {
            header: this.transHeader(header),
            body: this.transRsp(originBody),
        };
        console.warn(JSON.stringify(msg));
        this.handleSendCommandMsgRsp(msg);
    };
    LiveRoomHandler.prototype.handleSwitchPush = function (header, body) {
        if (header.cmd === '/sw/push') {
            var _header = this.transRsp(body.head);
            var _body = void 0;
            if (this.unStructCmdList.includes(body.head.sub_cmd)) {
                _body = { signal_msg: string_1.decodeString(body.msg_body), sub_cmd: this.joinLiveMap[body.head.sub_cmd] };
            }
            else if (body.head.sub_cmd === '/lr/push/signal_custom') {
                _body = { custommsg: string_1.decodeString(body.msg_body) };
            }
            else {
                // @ts-ignore
                if (switchCmd_1.LiveroomProMap[body.head.sub_cmd]) {
                    // @ts-ignore
                    _body = this.transRsp(this.decode(liveroom_3.liveroom_cs[switchCmd_1.LiveroomProMap[body.head.sub_cmd]], body.msg_body));
                }
                else {
                    _body = {};
                }
            }
            var pushReq = {
                header: _header,
                body: _body,
            };
            if (this.whiteboardPushCmdList.includes(body.head.sub_cmd)) {
                console.error('onSwitchMessage push ', JSON.stringify(body));
                this.onSwitchMessage(header, body);
            }
            else {
                switch (body.head.sub_cmd) {
                    case '/lr/push/user_updated':
                        this.handlePushUserStateUpdateMsg(pushReq);
                        break;
                    case '/lr/push/user_kickout':
                        this.handlePushKickout(pushReq, false);
                        break;
                    case '/lr/push/trans':
                        this.handlePushTransMsg(pushReq);
                        break;
                    case '/lr/push/im_chat':
                        this.handlePushRoomMsg(pushReq);
                        break;
                    case '/lr/push/signal_custom':
                        this.handlePushCustomMsg(pushReq);
                        break;
                    case '/lr/push/stream_add':
                    case '/lr/push/stream_delete':
                    case '/lr/push/stream_update':
                        this.handlePushStreamMsg(pushReq);
                        break;
                    case '/lr/push/joinlive_request':
                    case '/lr/push/joinlive_result':
                    case '/lr/push/joinlive_invite':
                    case '/lr/push/joinlive_stop':
                        this.handlePushSignalMsg(pushReq);
                        break;
                }
            }
            if (body.head.qos_flag == 1) {
                var reqBody = {
                    code: 0,
                    message: '',
                    sub_cmd: body.head.sub_cmd,
                    msg_id: body.head.msg_id,
                    server_send_time: body.head.send_time,
                };
                var bodyMessage = liveroom_1.proto_switch.PushRsp.create(reqBody);
                var bodyBuffer = liveroom_1.proto_switch.PushRsp.encode(bodyMessage).finish();
                this.sendMessage('/sw/push_rsp', bodyBuffer, void 0, void 0);
            }
        }
        else if (header.cmd === '/sw/merge_push') {
            var rspInfo_1 = [];
            body.messages.forEach(function (item) {
                var _msg_body;
                rspInfo_1.push({
                    sub_cmd: item.sub_cmd,
                    sub_seq: item.sub_seq,
                    msg_id: item.msg_id,
                });
                if (item.sub_cmd === '/lr/push/bigim_chat') {
                    _msg_body = liveroom_3.liveroom_cs.PushBigImChat.decode(item.msg_body);
                    item.msg_body = _msg_body;
                }
            });
            var _body = this.transRsp(body);
            var _msg = {
                header: _body.head,
                body: _body,
            };
            delete _msg.body.head;
            console.warn(_msg);
            this.handlePushMergeMsg(_msg);
            if (body.head.qos_flag == 1) {
                var reqBody = {
                    messages: rspInfo_1,
                };
                var bodyMessage = liveroom_1.proto_switch.CmdMergePushRsp.create(reqBody);
                var bodyBuffer = liveroom_1.proto_switch.CmdMergePushRsp.encode(bodyMessage).finish();
                this.sendMessage('/sw/merge_push_rsp', bodyBuffer, void 0, void 0);
            }
        }
        else if (header.cmd === '/sw/push_kickout') {
            console.warn(header, body);
            var _body = {
                // TODO
                reason: body.reason > 900 ? body.reason - 900 : body.reason,
                msg: body.message,
                need_relogin: body.need_relogin !== undefined ? body.need_relogin : 0,
            };
            this.handlePushKickout({ header: header, body: _body }, true);
        }
    };
    LiveRoomHandler.prototype.handlePushKickout = function (msg, isSwitch) {
        var _a, _b;
        if (isSwitch) {
            __spreadArrays(this.stateCenter.roomModulesList).forEach(function (room) {
                room.roomHandler.handlePushKickout(msg, true, true);
            });
        }
        else {
            var roomID_1 = (_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id;
            var room = this.stateCenter.roomModulesList.find(function (roomModules) { return roomModules.roomID == roomID_1; });
            this.longToStringNumber(msg.body, ['session_id'], 'toString');
            // Long.isLong(msg.body.session_id) && (msg.body.session_id = msg.body.session_id.toString());
            if (!room) {
                this.logger.error(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_PUSHKICKOUT +
                    ' room no found ignore ' +
                    JSON.stringify((_b = msg.header) === null || _b === void 0 ? void 0 : _b.room_id));
                return;
            }
            room.roomHandler.handlePushKickout(msg);
        }
    };
    LiveRoomHandler.prototype.handlePushStreamMsg = function (msg) { };
    LiveRoomHandler.prototype.handlePushSignalMsg = function (msg) { };
    LiveRoomHandler.prototype.handlePushMergeMsg = function (msg) { };
    LiveRoomHandler.prototype.handlePushCustomMsg = function (pushReq) { };
    LiveRoomHandler.prototype.handlePushRoomMsg = function (msg) { };
    LiveRoomHandler.prototype.handlePushTransMsg = function (pushReq) { };
    LiveRoomHandler.prototype.onSwitchMessage = function (header, decryptBody) { };
    LiveRoomHandler.prototype.decodeResponseBody = function (header, bodyData) {
        var nameSpace = this.onSwitchCmdList.includes(header.cmd) ? 'proto_switch' : 'liveroom_cs';
        // TODO
        // @ts-ignore
        return this.decode(this.protoInstance[nameSpace][switchCmd_1.LiveroomProMap[header.cmd]], bodyData);
    };
    LiveRoomHandler.prototype.handlePushUserStateUpdateMsg = function (msg) {
        var _a;
        // console.error('handlePushUserStateUpdateMsg')
        var roomID = (_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id;
        var room = this.stateCenter.roomModulesList.find(function (roomModules) { return roomModules.roomID == roomID; });
        if (!room) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_PUSHUSERUPDATE + ' room no found ignore ' + JSON.stringify(msg));
            return;
        }
        var user_actions = msg.body.user_list.map(function (item) {
            return {
                Action: item.action,
                IdName: item.id_name,
                NickName: item.nick_name,
                Role: item.role,
                LoginTime: item.login_time.toString(),
            };
        });
        var _msg = {
            body: { user_actions: user_actions, user_list_seq: msg.body.server_user_seq.toNumber(), room_id: msg.body.room_id },
        };
        room.userHandler.handlePushUserStateUpdateMsg(_msg);
    };
    LiveRoomHandler.prototype.login = function (room, suc, err) {
        var _this = this;
        if (room.isMulti) {
            var enterBody = {
                req_head: this.getReqHead(room),
                switch_session_id: this.switchSessionID,
                nick_name: this.nickName,
                role: this.stateCenter.role,
                net_type: client_util_1.ClientUtil.getNetTypeNum(),
                config: {
                    room_create_flag: this.stateCenter.roomCreateFlag,
                    user_state_flag: this.stateCenter.userStateUpdate ? 1 : 0,
                },
                lv_key: room.lvKey,
                third_token: string_1.encodeString(room.token),
                user_count_limit: room.maxMemberCount,
                relate_service: this.stateCenter.relateService.join() || '',
                conn_type: 2,
                room_name: string_1.encodeString(room.roomName),
            };
            var bodyMessage = liveroom_3.liveroom_cs.EnterReq.create(enterBody);
            var bodyBuffer = liveroom_3.liveroom_cs.EnterReq.encode(bodyMessage).finish();
            this.sendMessage('/lr/room/enter', bodyBuffer, function (msg, seq) {
                console.warn('enter suc ', msg);
                _this.longToStringNumber(msg.body, ['liveroom_session_id', 'room_session_id', 'ret_timestamp'], 'toString');
                _this.transKeysName(msg.body, [['liveroom_session_id', 'session_id'], ['hb_interval', 'hearbeat_interval']]);
                _this.keysExist(msg.body, ['token_remain_time', 'stream_seq']);
                suc && suc(msg, seq);
            }, function (err) {
                err && err(err);
            });
        }
        else {
            var body = {
                app_id: this.stateCenter.appid,
                id_name: string_1.encodeString(this.stateCenter.idName),
                device_id: this.stateCenter.deviceID,
                term_type: this.stateCenter.ENV % 2 === 0 ? zego_entity_1.TermType.TT_WEB : zego_entity_1.TermType.TT_MINIPROGRAM,
                net_type: client_util_1.ClientUtil.getNetTypeNum(),
                // TODO
                sdk_ver: zego_entity_1.PROTO_VERSION,
                proto_ver: zego_config_1.PROTO_VER,
                nick_name: this.nickName,
                client_stamp: string_1.encodeString(new Date().getTime() + ''),
                crypt_version: zego_config_1.CRYPT_VERSION,
                k1_sign: this.crypto.generateK1Sign(),
                login_token: string_1.encodeString(room.token),
                relogin_token: this.switchSessionID.notEquals(long_1.default.fromInt(0)) ? string_1.encodeString(this.reloginToken) : '',
                role: this.stateCenter.role,
                liveroom_session_id: long_1.default.fromString(room.roomSessionID),
                room_id: string_1.encodeString(room.roomID),
                room_name: string_1.encodeString(room.roomName),
                biz_type: zego_config_1.BIZ_TYPE,
                room_create_flag: this.stateCenter.roomCreateFlag,
                user_state_flag: this.stateCenter.userStateUpdate ? 1 : 0,
                lv_key: room.lvKey,
                third_token: string_1.encodeString(room.token),
                user_count_limit: room.maxMemberCount,
                relate_service: this.stateCenter.relateService.join() || '',
                biz_version: this.stateCenter.bizVersion || '',
                login_logic: this.stateCenter.isMultiRoom ? 3 : 1,
                sdk_conn_type: zego_config_1.SDK_CONN_TYPE,
            };
            console.error('login ' + this.stateCenter.idName + ' ' + JSON.stringify(body));
            this.k1SignLogoutBuffer = this.crypto.md5Bytes(body.k1_sign);
            // @ts-ignore
            var bodyMessage = liveroom_1.proto_switch.LoginRoomReq.create(body);
            var bodyBuffer = liveroom_1.proto_switch.LoginRoomReq.encode(bodyMessage).finish();
            this.sendMessage('/lr/login_room', bodyBuffer, function (msg, seq) {
                _this.switchSessionID = msg.header.session_id;
                _this.reloginToken = msg.body.relogin_token;
                // console.error('switch', this.switchSessionID.notEquals(Long.fromInt(0)));
                _this.crypto.decryptK2Sign(msg.body.k2_sign);
                if (msg.crypt_option === 1) {
                    _this.isEncrypt = false;
                }
                else if (msg.crypt_option === undefined) {
                    _this.isEncrypt = true;
                }
                _this.longToStringNumber(msg.body, ['liveroom_session_id', 'room_session_id', 'ret_timestamp'], 'toString');
                delete msg.body.heartbeat_interval;
                delete msg.body.heartbeat_timeout;
                _this.transKeysName(msg.body, [['liveroom_session_id', 'session_id'], ['liveroom_hb_interval', 'hearbeat_interval']]);
                _this.keysExist(msg.body, ['token_remain_time', 'stream_seq']);
                console.error('login suc', JSON.stringify(msg));
                suc && suc(msg, seq);
            }, function (e, seq) {
                console.error('login fail', JSON.stringify(e));
                err && err(e, seq);
            });
        }
    };
    LiveRoomHandler.prototype.transKeysName = function (obj, keys) {
        keys.forEach(function (key) {
            obj[key[1]] = obj[key[0]];
            delete obj[key[0]];
        });
    };
    LiveRoomHandler.prototype.keysExist = function (obj, keys) {
        keys.forEach(function (key) {
            if (obj[key] === undefined) {
                obj[key] = 0;
            }
        });
    };
    LiveRoomHandler.prototype.longToStringNumber = function (obj, keys, type) {
        keys.forEach(function (key) {
            if (long_1.default.isLong(obj[key])) {
                obj[key] = obj[key][type]();
            }
        });
    };
    LiveRoomHandler.prototype.logout = function (room, suc, err) {
        if (room.isMulti) {
            var reqBody = {
                req_head: this.getReqHead(room),
                switch_session_id: this.switchSessionID,
                nick_name: this.nickName,
                role: this.stateCenter.role,
                config_list: {
                    room_create_flag: this.stateCenter.roomCreateFlag,
                    user_state_flag: this.stateCenter.userStateUpdate ? 1 : 0,
                },
            };
            var bodyMessage = liveroom_3.liveroom_cs.QuitReq.create(reqBody);
            var bodyBuffer = liveroom_3.liveroom_cs.QuitReq.encode(bodyMessage).finish();
            return this.sendMessage('/lr/room/quit', bodyBuffer, suc, err);
        }
        else {
            if (!room.token || !room.sessionID || !room.roomID) {
                console.error('empty ', room);
            }
            var reqBody = {
                logout_code: 0,
                logout_check: this.crypto.md5Bytes(string_1.encodeString(room.token)),
                liveroom_session_id: long_1.default.fromString(room.sessionID),
                room_id: string_1.encodeString(room.roomID),
                role: this.stateCenter.role,
                nickname: this.nickName,
                logout_logic: this.stateCenter.isMultiRoom ? 3 : 1,
            };
            console.error('logout', this.stateCenter.idName);
            var bodyMessage = liveroom_1.proto_switch.LogoutRoomReq.create(reqBody);
            var bodyBuffer = liveroom_1.proto_switch.LogoutRoomReq.encode(bodyMessage).finish();
            return this.sendMessage('/lr/logout_room', bodyBuffer, suc, err);
        }
    };
    // 
    LiveRoomHandler.prototype.checkSendMessageList = function (messageList) {
        var head = messageList.getFirst();
        while (head != null) {
            messageList.remove(head);
            if (head._data && head._data.error) {
                setTimeout(function () {
                    head && head._data && head._data.error && head._data.error(zego_externalError_1.errorCodeList.TIMEOUT);
                }, 0);
            }
            head = messageList.getFirst();
        }
    };
    // ,
    LiveRoomHandler.prototype.checkMessageListTimeout = function (messageList, messageMap) {
        var head = messageList.getFirst();
        var timestamp = Date.parse(new Date() + '');
        var checkCount = 0;
        var timeoutMsgCount = 0;
        var dropMsgCount = 0;
        while (head != null) {
            //  
            if (head._data && head._data.sendTime + head._data.timeout > timestamp) {
                break;
            }
            //  ,
            head._data && delete messageMap[head._data.seq];
            messageList.remove(head);
            ++timeoutMsgCount;
            //  ,
            if ((head._data && head._data.error == null) ||
                (head._data && head._data.sendTime + this.sendDataDropTimeout < timestamp)) {
                ++dropMsgCount;
            }
            else {
                setTimeout(function () {
                    head && head._data && head._data.error && head._data.error(zego_externalError_1.errorCodeList.TIMEOUT);
                }, 0);
            }
            ++checkCount;
            if (checkCount >= this.sendDataCheckOnceCount) {
                break;
            }
            head = messageList.getFirst();
        }
    };
    // ,
    LiveRoomHandler.prototype.startCheck = function () {
        var _this = this;
        this.checkMessageListTimeout(this.sendCommandList, this.sendCommandMap);
        this.sendDataCheckTimer = setTimeout(function () {
            _this.startCheck();
        }, this.sendDataCheckInterval);
    };
    // 
    LiveRoomHandler.prototype.stopCheck = function () {
        this.checkSendMessageList(this.sendCommandList);
        clearTimeout(this.sendDataCheckTimer);
    };
    LiveRoomHandler.prototype.handleSendCommandMsgRsp = function (msg) {
        var _this = this;
        var sendDataNode = this.sendCommandMap[msg.header.seq];
        if (sendDataNode != null) {
            var sendData_1 = sendDataNode._data;
            delete this.sendCommandMap[msg.header.seq];
            this.sendCommandList.remove(sendDataNode);
            if (msg.body.err_code === 0) {
                setTimeout(function () {
                    sendData_1 && sendData_1.success != null && sendData_1.success(msg, _this.seq);
                }, 0);
            }
            else {
                setTimeout(function () {
                    sendData_1 && sendData_1.error != null && sendData_1.error(msg, _this.seq);
                }, 0);
            }
        }
    };
    LiveRoomHandler.prototype.getReqHead = function (room) {
        var reqHead = {
            room_id: room.roomID,
            user_session_id: long_1.default.fromString(room.sessionID),
            room_session_id: long_1.default.fromString(room.roomSessionID),
        };
        return reqHead;
    };
    LiveRoomHandler.prototype.heartBeat = function (suc, err, room) {
        var _this = this;
        var reqHead = this.getReqHead(room);
        var reqBody = {
            req_head: reqHead,
            role: this.stateCenter.role,
            lv_key: room.lvKey,
        };
        var bodyMessage = liveroom_3.liveroom_cs.HbReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.HbReq.encode(bodyMessage).finish();
        console.warn('/lr/room/hb');
        this.sendMessage('/lr/room/hb', bodyBuffer, function (msg) {
            _this.transKeysName(msg.body, [['hb_interval', 'hearbeat_interval'], ['hb_timeout', 'hearbeat_timeout']]);
            msg.body.server_user_seq = msg.body.user_seq.toNumber();
            _this.longToStringNumber(msg.body, ['dati_time_window'], 'toNumber');
            suc && suc(msg);
        }, err);
    };
    LiveRoomHandler.prototype.fetchUserList = function (body, suc, err, room) {
        var _this = this;
        var reqHead = this.getReqHead(room);
        var reqBody = __assign({ req_head: reqHead }, body);
        var bodyMessage = liveroom_3.liveroom_cs.UserlistReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.UserlistReq.encode(bodyMessage).finish();
        return this.sendMessage('/lr/userlist/userlist', bodyBuffer, function (msg, seq) {
            console.error('fetchUserList');
            _this.transKeysName(msg.body, [['user_basic_list', 'user_baseinfos']]);
            _this.longToStringNumber(msg.body, ['server_user_seq', 'server_user_index', 'ret_user_index'], 'toNumber');
            suc && suc(msg, seq);
        }, err);
    };
    LiveRoomHandler.prototype.sendRoomMsg = function (body, suc, err, room) {
        var _this = this;
        var reqHead = this.getReqHead(room);
        var reqBody = {
            req_head: reqHead,
            msg_category: body.msg_category,
            msg_priority: body.msg_priority,
            msg_type: body.msg_type,
            msg_content: string_1.encodeString(body.msg_content),
        };
        var bodyMessage = liveroom_3.liveroom_cs.ImChatReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.ImChatReq.encode(bodyMessage).finish();
        return this.sendMessage('/lr/im/chat', bodyBuffer, function (res) {
            _this.longToStringNumber(res.body, ['msg_id'], 'toNumber');
            suc && suc(res);
        }, err);
    };
    LiveRoomHandler.prototype.sendReliableMessage = function (body, suc, err, room) {
        var reqHead = this.getReqHead(room);
        var reqBody = {
            req_head: reqHead,
            role: this.stateCenter.role,
            nick_name: this.nickName,
            trans_type: string_1.encodeString(body.trans_type),
            trans_data: string_1.encodeString(body.trans_data),
            trans_local_seq: body.trans_local_seq,
            trans_channel: string_1.encodeString(body.trans_channel),
        };
        var bodyMessage = liveroom_3.liveroom_cs.TransReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.TransReq.encode(bodyMessage).finish();
        return this.sendMessage('/lr/trans/trans', bodyBuffer, suc, err);
    };
    LiveRoomHandler.prototype.fetchReliableMessage = function (body, suc, err, room) {
        var reqHead = this.getReqHead(room);
        var _fetch_array = body.fetch_array.map(function (item) {
            return { trans_type: string_1.encodeString(item.trans_type), trans_local_seq: item.trans_seq };
        });
        var reqBody = {
            req_head: reqHead,
            trans_channel: string_1.encodeString(body.trans_channel),
            fetch_array: _fetch_array,
        };
        var bodyMessage = liveroom_3.liveroom_cs.TransFetchReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.TransFetchReq.encode(bodyMessage).finish();
        return this.sendMessage('/lr/trans/transfetch', bodyBuffer, suc, err);
    };
    LiveRoomHandler.prototype.sendCustomCommand = function (body, suc, err, room) {
        var _this = this;
        var reqHead = this.getReqHead(room);
        var dstUserList = body.dest_id_name.map(function (item) {
            return { id_name: string_1.encodeString(item) };
        });
        var reqBody = __assign({ req_head: reqHead, dst_userlist: dstUserList, push_message: string_1.encodeString(body.custom_msg) }, body);
        var bodyMessage = liveroom_3.liveroom_cs.SignalLiveReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.SignalLiveReq.encode(bodyMessage).finish();
        return this.sendMessage('/lr/signal/livescustom', bodyBuffer, function (res) {
            suc && suc(_this.transRsp(res));
        }, function (e) {
            err && err(_this.transRspHead(e.rsp_head));
        });
    };
    LiveRoomHandler.prototype.sendBigRoomMessage = function (body, suc, err, room) {
        var reqHead = this.getReqHead(room);
        var _msgs = body.msgs.map(function (item) {
            return {
                msg_category: item.msg_category,
                msg_type: item.msg_type,
                msg_timestamp: long_1.default.fromNumber(Date.now()),
                msg_content: string_1.encodeString(item.msg_content),
                bigmsg_client_id: string_1.encodeString(item.bigmsg_client_id),
            };
        });
        var reqBody = {
            req_head: reqHead,
            nick_name: this.nickName,
            role: this.stateCenter.role,
            msgs: _msgs,
        };
        var bodyMessage = liveroom_3.liveroom_cs.BigimChatReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.BigimChatReq.encode(bodyMessage).finish();
        return this.sendMessage('/lr/bigim/chat', bodyBuffer, suc, err);
    };
    LiveRoomHandler.prototype.sendRelayMessage = function (body, suc, err, room) {
        var reqHead = this.getReqHead(room);
        var reqBody = {
            req_head: reqHead,
            nick_name: this.nickName,
            role: this.stateCenter.role,
            relay_type: string_1.encodeString(body.relay_type),
            relay_data: string_1.encodeString(body.relay_data),
        };
        var bodyMessage = liveroom_3.liveroom_cs.RelayReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.RelayReq.encode(bodyMessage).finish();
        return this.sendMessage('/lr/relay', bodyBuffer, suc, err);
    };
    LiveRoomHandler.prototype.sendSignalCmd = function (body, suc, err, room) {
        var cmd = '';
        var bean = '';
        switch (body.sub_cmd) {
            case ENUM_SIGNAL_SUB_CMD.joinLiveInvite:
                cmd = '/lr/signal/liveinvite';
                bean = 'SignalLiveInviteReq';
                break;
            case ENUM_SIGNAL_SUB_CMD.joinLiveRequest:
                cmd = '/lr/signal/liverequest';
                bean = 'SignalLiveReq';
                break;
            case ENUM_SIGNAL_SUB_CMD.joinLiveResult:
                cmd = '/lr/signal/liverresult';
                bean = 'SignalLiveResultReq';
                break;
            case ENUM_SIGNAL_SUB_CMD.joinLiveStop:
                cmd = '/lr/signal/livestop';
                bean = 'SignalLiveStopReq';
                break;
        }
        var reqHead = this.getReqHead(room);
        var dstUserlist = body.dest_id_name.map(function (item) {
            return { id_name: string_1.encodeString(item) };
        });
        var reqBody = {
            req_head: reqHead,
            push_message: string_1.encodeString(body.signal_msg),
            dst_userlist: dstUserlist,
        };
        // @ts-ignore
        var bodyMessage = liveroom_3.liveroom_cs[bean].create(reqBody);
        // @ts-ignore
        var bodyBuffer = liveroom_3.liveroom_cs[bean].encode(bodyMessage).finish();
        // @ts-ignore
        var decodeReq = liveroom_3.liveroom_cs[bean].decode(bodyBuffer);
        console.warn('signal', this.transRsp(decodeReq));
        return this.sendMessage(cmd, bodyBuffer, suc, err);
    };
    LiveRoomHandler.prototype.sendStreamUpdate = function (body, suc, err, room) {
        var streamInfo;
        try {
            streamInfo = JSON.parse(body.stream_msg);
        }
        catch (error) { }
        var streamCmd = '';
        var bean;
        var reqBody;
        var _room = this.stateCenter.roomModulesList.find(function (roomModules) { return roomModules.roomID == room.roomID; });
        if (!_room) {
            // TODO
            // this.logger.error(
            //     ZEGO_RTM_ACTION.LIVEROOMHANDLER_PUSHUSERUPDATE + ' room no found ignore ' + JSON.stringify(msg),
            // );
            return;
        }
        switch (body.sub_cmd) {
            case 2001:
                streamCmd = '/lr/stream/add';
                bean = 'StreamAddReq';
                reqBody = {
                    req_head: this.getReqHead(_room),
                    stream_id: string_1.encodeString(streamInfo.stream_id),
                    extra_info: string_1.encodeString(streamInfo.extra_info),
                    // TODO
                    // title: '',
                    client_req_seq: this.seq + 1,
                    login_mode: 1,
                    third_token: string_1.encodeString(body.third_token || ''),
                };
                break;
            case 2002:
                streamCmd = '/lr/stream/delete';
                bean = 'StreamDeleteReq';
                reqBody = {
                    req_head: this.getReqHead(_room),
                    stream_id: string_1.encodeString(streamInfo.stream_id),
                    stream_sid: streamInfo.stream_sid,
                    client_req_seq: this.seq + 1,
                };
                break;
            case 2003:
                streamCmd = '/lr/stream/update';
                bean = 'StreamUpdateReq';
                reqBody = {
                    req_head: this.getReqHead(_room),
                    stream_id: string_1.encodeString(streamInfo.stream_id),
                    stream_sid: streamInfo.stream_sid,
                    client_req_seq: this.seq + 1,
                };
                break;
        }
        // @ts-ignore
        var bodyMessage = liveroom_3.liveroom_cs[bean].create(reqBody);
        // @ts-ignore
        var bodyBuffer = liveroom_3.liveroom_cs[bean].encode(bodyMessage).finish();
        this.sendMessage(streamCmd, bodyBuffer, function (r) {
            console.warn('stream', r);
            r.header.room_id = _room.roomID;
            suc && suc(r);
        }, function (e) {
            console.warn('stream', e);
            err && err(e);
        });
    };
    LiveRoomHandler.prototype.getStreamList = function (body, suc, err, room) {
        var reqBody;
        var _room = this.stateCenter.roomModulesList.find(function (roomModules) { return roomModules.roomID == room.roomID; });
        if (!_room) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_GETSTREAMLIST + ' room no found ignore ' + room.roomID);
            return;
        }
        reqBody = {
            req_head: this.getReqHead(_room),
        };
        var bodyMessage = liveroom_3.liveroom_cs.StreamListReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.StreamListReq.encode(bodyMessage).finish();
        this.sendMessage('/lr/stream/list', bodyBuffer, function (r) {
            suc && suc(r);
        }, function (e) {
            err && err(e);
        });
    };
    LiveRoomHandler.prototype.transHeader = function (msg) {
        msg.timestamp = long_1.default.isLong(msg.timestamp) ? msg.timestamp.toString() : msg.timestamp;
        // msg.session_id = Long.isLong(msg.session_id) ? msg.session_id.toString() : msg.session_id;
        return msg;
    };
    LiveRoomHandler.prototype.transRsp = function (res) {
        var _this = this;
        var _head = res && res.rsp_head ? this.transRspHead(res.rsp_head) : {};
        var response = __assign(__assign({}, res), _head);
        delete response.rsp_head;
        var transResponse = {};
        Object.keys(response).forEach(function (item) {
            if (item === 'k2_sign') {
                transResponse[item] = response[item];
            }
            else {
                _this.transBytes(transResponse, response, item);
            }
        });
        return transResponse;
    };
    LiveRoomHandler.prototype.transBytes = function (transObj, obj, key) {
        var _this = this;
        if (long_1.default.isLong(obj[key])) {
            transObj[key] = obj[key];
        }
        else if (Object.prototype.toString.call(obj[key]) === '[object Object]') {
            transObj[key] = {};
            Object.keys(obj[key]).forEach(function (item) { return _this.transBytes(transObj[key], obj[key], item); });
        }
        else if (Object.prototype.toString.call(obj[key]) === '[object Array]' &&
            Object.prototype.toString.call(obj[key][0]) === '[object Object]') {
            transObj[key] = [];
            var _loop_1 = function (i) {
                var _obj = {};
                Object.keys(obj[key][i]).forEach(function (item) {
                    _this.transBytes(_obj, obj[key][i], item);
                });
                transObj[key].push(_obj);
            };
            for (var i = 0; i < obj[key].length; i++) {
                _loop_1(i);
            }
        }
        else if (Object.prototype.toString.call(obj[key]) === '[object Uint8Array]') {
            transObj[key] = string_1.decodeString(obj[key]);
        }
        else {
            transObj[key] = obj[key];
        }
    };
    LiveRoomHandler.prototype.transRspHead = function (rspHead) {
        if (rspHead) {
            return {
                err_code: rspHead.code || 0,
                err_message: rspHead.message,
            };
        }
        else {
            return {};
        }
    };
    LiveRoomHandler.prototype.decode = function (instance, buffer) {
        return __assign({}, instance.decode(buffer));
    };
    LiveRoomHandler.prototype.handleDisconnected = function () {
        var _this = this;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_HANDLEDISCONNECTED + ' call');
        this.state = LIVEROOM_STATE.disconnected;
        //
        this.stateCenter.roomModulesList.forEach(function (roomModules) {
            if (roomModules.roomTryHandler && _this.ua.isConnect()) {
                roomModules.roomTryHandler.active();
            }
        });
    };
    LiveRoomHandler.prototype.handleBroken = function () {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_HANDLEBROKEN + ' call');
        this.state = LIVEROOM_STATE.broken;
        //
        this.stateCenter.roomModulesList.forEach(function (roomModules) {
            if (roomModules.roomTryHandler) {
                //
                roomModules.roomTryHandler.invalid();
                roomModules.roomTryHandler.onactive = function (success, error) {
                    roomModules.roomHandler.disconnectedHandle(error);
                };
                //
                roomModules.roomTryHandler.startMaxTime();
                roomModules.roomHandler.roomStateHandle('CONNECTING', zego_externalError_1.errorCodeList.NETWORK_BROKEN);
            }
        });
    };
    LiveRoomHandler.prototype.handleConnected = function () {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.LIVEROOMHANDLER_HANDLECONNECTED + ' call');
        //
        this.state = LIVEROOM_STATE.connected;
        this.stateCenter.roomModulesList.forEach(function (roomModules) {
            if (roomModules.roomTryHandler) {
                //
                //
                roomModules.roomTryHandler.stopMaxTime();
                roomModules.roomTryHandler.invalid();
            }
        });
    };
    LiveRoomHandler.prototype.renewToken = function (body, sucCallBack, failCallBack, room) {
        var reqHead = this.getReqHead(room);
        var reqBody = {
            req_head: reqHead,
            token: body.token,
        };
        var bodyMessage = liveroom_3.liveroom_cs.RenewTokenReq.create(reqBody);
        var bodyBuffer = liveroom_3.liveroom_cs.RenewTokenReq.encode(bodyMessage).finish();
        this.sendMessage('/lr/token/renew_token', bodyBuffer, sucCallBack, failCallBack);
    };
    LiveRoomHandler.prototype.reset = function () {
        var _a;
        // this.seq = 0;
        // TODO
        // this.isEncrypt = false;
        this.state = LIVEROOM_STATE.disconnected;
        this.switchSessionID = long_1.default.fromInt(0);
        if (this.sendDataCheckTimer) {
            clearTimeout(this.sendDataCheckTimer);
        }
        (_a = this.liveroom) === null || _a === void 0 ? void 0 : _a.closeRequest();
    };
    LiveRoomHandler.prototype.resetSessionInfo = function () {
        this.switchSessionID = long_1.default.fromInt(0);
    };
    return LiveRoomHandler;
}());
exports.LiveRoomHandler = LiveRoomHandler;


/***/ }),

/***/ "./sdk/src/modules/net/entity/AccessHubDefine.ts":
/*!*******************************************************!*\
  !*** ./sdk/src/modules/net/entity/AccessHubDefine.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Method = exports.ConnectionClosedAction = exports.NetWorkState = exports.externalErrorList = exports.Stick = exports.PcConnectState = exports.StreamType = exports.Mode = exports.ZegoconnRunEnv = exports.BusinessService = exports.AccessHub_Error_Code = exports.AccessHubMessageType = void 0;
var AccessHubMessageType;
(function (AccessHubMessageType) {
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_STREAM_CLOSED"] = 2] = "MSG_TYPE_STREAM_CLOSED";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_CLOSE_CONNECTION"] = 3] = "MSG_TYPE_CLOSE_CONNECTION";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_HTTP_REQUEST"] = 4] = "MSG_TYPE_HTTP_REQUEST";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_HTTP_RESPONSE"] = 5] = "MSG_TYPE_HTTP_RESPONSE";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_HB_REQUEST"] = 12] = "MSG_TYPE_HB_REQUEST";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_HB_RESPONSE"] = 13] = "MSG_TYPE_HB_RESPONSE";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_GET_CONFIG_REQUEST"] = 14] = "MSG_TYPE_GET_CONFIG_REQUEST";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_GET_CONFIG_RESPONSE"] = 15] = "MSG_TYPE_GET_CONFIG_RESPONSE";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_HTTP_REQUEST_ACK"] = 16] = "MSG_TYPE_HTTP_REQUEST_ACK";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_PC_UPWARD_MESSAGE"] = 17] = "MSG_TYPE_PC_UPWARD_MESSAGE";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_PC_UPWARD_MESSAGE_ACK"] = 18] = "MSG_TYPE_PC_UPWARD_MESSAGE_ACK";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_PC_ESTABLISHED"] = 19] = "MSG_TYPE_PC_ESTABLISHED";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_PC_BROKEN"] = 20] = "MSG_TYPE_PC_BROKEN";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_PC_DOWNWARD_MESSAGE"] = 21] = "MSG_TYPE_PC_DOWNWARD_MESSAGE";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_REDIRECT"] = 22] = "MSG_TYPE_REDIRECT";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_GET_APPCONFIG_REQUEST"] = 23] = "MSG_TYPE_GET_APPCONFIG_REQUEST";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_GET_APPCONFIG_RESPONSE"] = 24] = "MSG_TYPE_GET_APPCONFIG_RESPONSE";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_PUSH_APPCONFIG"] = 25] = "MSG_TYPE_PUSH_APPCONFIG";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_ACCESSHUB_DISPATCH_REQUEST"] = 26] = "MSG_TYPE_ACCESSHUB_DISPATCH_REQUEST";
    AccessHubMessageType[AccessHubMessageType["MSG_TYPE_ACCESSHUB_DISPATCH_RESPONSE"] = 27] = "MSG_TYPE_ACCESSHUB_DISPATCH_RESPONSE";
})(AccessHubMessageType = exports.AccessHubMessageType || (exports.AccessHubMessageType = {}));
var AccessHub_Error_Code;
(function (AccessHub_Error_Code) {
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_INVALID_FRAME"] = 20000] = "ACCESSHUB_INVALID_FRAME";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_NEED_ENCRYPT"] = 20001] = "ACCESSHUB_NEED_ENCRYPT";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_DECRYPT"] = 20002] = "ACCESSHUB_DECRYPT";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_MSGTYPE"] = 20003] = "ACCESSHUB_MSGTYPE";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_UNMARSHAL"] = 20004] = "ACCESSHUB_UNMARSHAL";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_TIMEOUT"] = 20005] = "ACCESSHUB_TIMEOUT";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_CONNECT"] = 20006] = "ACCESSHUB_CONNECT";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_BROKEN"] = 20007] = "ACCESSHUB_BROKEN";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_INTERNAL_ERROR"] = 20008] = "ACCESSHUB_INTERNAL_ERROR";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_MARSHAL"] = 20009] = "ACCESSHUB_MARSHAL";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_UNSUPPORTED_SERVICE"] = 20010] = "ACCESSHUB_UNSUPPORTED_SERVICE";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_TOO_FREQUENTLY"] = 20011] = "ACCESSHUB_TOO_FREQUENTLY";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_INVALID_APPID"] = 20012] = "ACCESSHUB_INVALID_APPID";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_HB_TIMEOUT"] = 20013] = "ACCESSHUB_HB_TIMEOUT";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_INVALID_SIGNATURE"] = 20014] = "ACCESSHUB_INVALID_SIGNATURE";
    AccessHub_Error_Code[AccessHub_Error_Code["ACCESSHUB_AUTH_FAILED"] = 20015] = "ACCESSHUB_AUTH_FAILED";
})(AccessHub_Error_Code = exports.AccessHub_Error_Code || (exports.AccessHub_Error_Code = {}));
var BusinessService;
(function (BusinessService) {
    BusinessService[BusinessService["SERVICE_UNSET"] = 0] = "SERVICE_UNSET";
    BusinessService[BusinessService["SERVICE_MEDIAGW"] = 1] = "SERVICE_MEDIAGW";
    BusinessService[BusinessService["SERVICE_LIVEROOM"] = 2] = "SERVICE_LIVEROOM";
    BusinessService[BusinessService["SERVICE_MIX"] = 3] = "SERVICE_MIX";
    BusinessService[BusinessService["SERVICE_ZEUS"] = 4] = "SERVICE_ZEUS";
    BusinessService[BusinessService["SERVICE_ZPUSH"] = 5] = "SERVICE_ZPUSH";
    BusinessService[BusinessService["SERVICE_L3"] = 6] = "SERVICE_L3";
    BusinessService[BusinessService["SERVICE_TALKLINE"] = 7] = "SERVICE_TALKLINE";
    BusinessService[BusinessService["SERVICE_EDUSUITE"] = 8] = "SERVICE_EDUSUITE";
    BusinessService[BusinessService["SERVICE_ZIM"] = 9] = "SERVICE_ZIM";
    BusinessService[BusinessService["SERVICE_ClOUD_SETTING"] = 10] = "SERVICE_ClOUD_SETTING";
    BusinessService[BusinessService["SERVICE_ZEUSHB"] = 11] = "SERVICE_ZEUSHB";
    BusinessService[BusinessService["SERVICE_USER_LOGIC"] = 12] = "SERVICE_USER_LOGIC";
    BusinessService[BusinessService["SERVICE_UNIFYDISPATCH"] = 13] = "SERVICE_UNIFYDISPATCH";
    BusinessService[BusinessService["SERVICE_QUALITY"] = 14] = "SERVICE_QUALITY";
    BusinessService[BusinessService["SERVICE_SECURITY"] = 15] = "SERVICE_SECURITY";
    BusinessService[BusinessService["SERVICE_KTVCPR"] = 16] = "SERVICE_KTVCPR";
    BusinessService[BusinessService["SERVICE_SWITCH4LIVEROOM"] = 17] = "SERVICE_SWITCH4LIVEROOM";
    BusinessService[BusinessService["SERVICE_WEBRTC_SIGNAL"] = 18] = "SERVICE_WEBRTC_SIGNAL";
    BusinessService[BusinessService["SERVICE_L3_WEBRTC_SIGNAL"] = 19] = "SERVICE_L3_WEBRTC_SIGNAL";
})(BusinessService = exports.BusinessService || (exports.BusinessService = {}));
var ZegoconnRunEnv;
(function (ZegoconnRunEnv) {
    ZegoconnRunEnv[ZegoconnRunEnv["ZEGOCONN_RUN_ENV_UNSET"] = 0] = "ZEGOCONN_RUN_ENV_UNSET";
    ZegoconnRunEnv[ZegoconnRunEnv["ZEGOCONN_RUN_ENV_BROWSER"] = 1] = "ZEGOCONN_RUN_ENV_BROWSER";
    ZegoconnRunEnv[ZegoconnRunEnv["ZEGOCONN_RUN_ENV_APPLET"] = 2] = "ZEGOCONN_RUN_ENV_APPLET"; // web sdk
})(ZegoconnRunEnv = exports.ZegoconnRunEnv || (exports.ZegoconnRunEnv = {}));
var Mode;
(function (Mode) {
    Mode[Mode["Mode_UNSET"] = 0] = "Mode_UNSET";
    Mode[Mode["MODE_ONLINE"] = 1] = "MODE_ONLINE";
    Mode[Mode["MODE_TEST"] = 2] = "MODE_TEST";
    Mode[Mode["MODE_ALPHA"] = 3] = "MODE_ALPHA";
})(Mode = exports.Mode || (exports.Mode = {}));
var StreamType;
(function (StreamType) {
    StreamType[StreamType["HTTP"] = 0] = "HTTP";
    StreamType[StreamType["PC"] = 1] = "PC";
    StreamType[StreamType["OTHER"] = 2] = "OTHER";
})(StreamType = exports.StreamType || (exports.StreamType = {}));
var PcConnectState;
(function (PcConnectState) {
    PcConnectState[PcConnectState["CONNECTED"] = 0] = "CONNECTED";
    PcConnectState[PcConnectState["DISCONNECT"] = 1] = "DISCONNECT";
})(PcConnectState = exports.PcConnectState || (exports.PcConnectState = {}));
exports.Stick = {
    DISPATCH: 'zego-action-dispatch',
    RETRY: 'zego-action-retry',
    ABORT: 'zego-action-abort',
    NEXT_GROUP: 'zego-action-next-group',
    PUSH_APP_CONFIG: 'push-app-config:',
};
exports.externalErrorList = [
    AccessHub_Error_Code.ACCESSHUB_INVALID_APPID,
    AccessHub_Error_Code.ACCESSHUB_AUTH_FAILED,
];
var NetWorkState;
(function (NetWorkState) {
    NetWorkState[NetWorkState["offline"] = 0] = "offline";
    NetWorkState[NetWorkState["online"] = 1] = "online";
})(NetWorkState = exports.NetWorkState || (exports.NetWorkState = {}));
var ConnectionClosedAction;
(function (ConnectionClosedAction) {
    ConnectionClosedAction[ConnectionClosedAction["ACTION_RESERVED"] = 0] = "ACTION_RESERVED";
    ConnectionClosedAction[ConnectionClosedAction["ACTION_DISPATCH"] = 1] = "ACTION_DISPATCH";
    ConnectionClosedAction[ConnectionClosedAction["ACTION_RETRY"] = 2] = "ACTION_RETRY";
    ConnectionClosedAction[ConnectionClosedAction["ACTION_NEXT_NODE"] = 3] = "ACTION_NEXT_NODE";
    ConnectionClosedAction[ConnectionClosedAction["ACTION_ABORT"] = 4] = "ACTION_ABORT";
    ConnectionClosedAction[ConnectionClosedAction["ACTION_NEXT_GROUP"] = 5] = "ACTION_NEXT_GROUP";
})(ConnectionClosedAction = exports.ConnectionClosedAction || (exports.ConnectionClosedAction = {}));
var Method;
(function (Method) {
    Method[Method["METHOD_UNSET"] = 0] = "METHOD_UNSET";
    Method[Method["METHOD_GET"] = 1] = "METHOD_GET";
    Method[Method["METHOD_POST"] = 2] = "METHOD_POST";
})(Method = exports.Method || (exports.Method = {}));


/***/ }),

/***/ "./sdk/src/modules/net/impl/NetAgentBusinessRequestMgr.ts":
/*!****************************************************************!*\
  !*** ./sdk/src/modules/net/impl/NetAgentBusinessRequestMgr.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_540535__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NetAgentBusinessRequestMgr = void 0;
var AccessHubDefine_1 = __nested_webpack_require_540535__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var net_config_1 = __nested_webpack_require_540535__(/*! ../net.config */ "./sdk/src/modules/net/net.config.ts");
var NetAgentBusinessRequestMgr = /** @class */ (function () {
    function NetAgentBusinessRequestMgr(streamManager, protobuf, logger) {
        this.streamManager = streamManager;
        this.protobuf = protobuf;
        this.logger = logger;
    }
    // 
    NetAgentBusinessRequestMgr.prototype.getConfig = function (suc, err) {
        this.logger.info("zm.nab.gc" /* NETAGENTBUS_GETCONFIG */ + ' call');
        var getConfigStream = this.streamManager.createStream(AccessHubDefine_1.StreamType.OTHER);
        getConfigStream.sendMessage(AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_GET_CONFIG_REQUEST, {
            // TODO access
            zegoconn_version: net_config_1.NET_ACCESS_CONFIG.connectVer,
        }, suc, err);
    };
    // 
    NetAgentBusinessRequestMgr.prototype.dispatchURL = function (success, fail) {
        var _this = this;
        this.logger.info("zm.nab.du" /* NETAGENTBUS_DISPATCHURL */ + ' call');
        var sucCallBack = function (msg) {
            _this.logger.info("zm.nab.du" /* NETAGENTBUS_DISPATCHURL */ + ' suc ');
            success && success(msg);
        };
        // TODO
        var failCallBack = function (err) {
            _this.logger.info("zm.nab.du" /* NETAGENTBUS_DISPATCHURL */ + ' fail');
            fail && fail(err);
        };
        var dispatchStream = this.streamManager.createStream(AccessHubDefine_1.StreamType.OTHER);
        dispatchStream.sendMessage(AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_ACCESSHUB_DISPATCH_REQUEST, {}, sucCallBack, failCallBack);
    };
    // 
    NetAgentBusinessRequestMgr.prototype.getAppConfig = function (userID, token) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.logger.info("zm.nab.gac" /* NETAGENTBUS_GETAPPCONFIG */ + ' call');
            var reqBody = {
                id_name: userID,
                config_key: 'init',
                token: token,
                mode_no: net_config_1.NET_ACCESS_CONFIG.modeNo,
            };
            var appConfigCallback = function (msg) {
                if (msg.code === 0) {
                    _this.logger.info("zm.nab.gac" /* NETAGENTBUS_GETAPPCONFIG */ + ' suc');
                    var initConfigData = _this.decodeConfigMessage(msg.data.data);
                    // this.logger.info(
                    //     ZEGO_ACCESS_ACTION.NETAGENTBUS_GETAPPCONFIG + ' ' + JSON.stringify(initConfig.media_config),
                    // );
                    resolve({ code: 0, data: initConfigData });
                }
                else {
                    _this.logger.error("zm.nab.gac" /* NETAGENTBUS_GETAPPCONFIG */ + ' fail ' + msg.code);
                    // TODO 
                    reject({ code: msg.code });
                }
            };
            var getAppConfigStream = _this.streamManager.createStream(AccessHubDefine_1.StreamType.OTHER);
            getAppConfigStream.sendMessage(AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_GET_APPCONFIG_REQUEST, reqBody, appConfigCallback, appConfigCallback);
        });
    };
    NetAgentBusinessRequestMgr.prototype.decodeConfigMessage = function (data) {
        return this.protobuf.decodeConfigMessage(data);
    };
    return NetAgentBusinessRequestMgr;
}());
exports.NetAgentBusinessRequestMgr = NetAgentBusinessRequestMgr;


/***/ }),

/***/ "./sdk/src/modules/net/impl/NetAgentConnect.ts":
/*!*****************************************************!*\
  !*** ./sdk/src/modules/net/impl/NetAgentConnect.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_544569__) {

"use strict";

var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetAgentConnect = void 0;
var AccessHubDefine_1 = __nested_webpack_require_544569__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var AccessHubProtoBuf_1 = __nested_webpack_require_544569__(/*! ../protocol/AccessHubProtoBuf */ "./sdk/src/modules/net/protocol/AccessHubProtoBuf.ts");
var ZegoWssLink_1 = __nested_webpack_require_544569__(/*! ./ZegoWssLink */ "./sdk/src/modules/net/impl/ZegoWssLink.ts");
var NetAgentBusinessRequestMgr_1 = __nested_webpack_require_544569__(/*! ./NetAgentBusinessRequestMgr */ "./sdk/src/modules/net/impl/NetAgentBusinessRequestMgr.ts");
var NetHeartBeatHandler_1 = __nested_webpack_require_544569__(/*! ./NetHeartBeatHandler */ "./sdk/src/modules/net/impl/NetHeartBeatHandler.ts");
var NetAgentPCRequestMgr_1 = __nested_webpack_require_544569__(/*! ./NetAgentPCRequestMgr */ "./sdk/src/modules/net/impl/NetAgentPCRequestMgr.ts");
var StreamManager_1 = __nested_webpack_require_544569__(/*! ../impl/StreamManager */ "./sdk/src/modules/net/impl/StreamManager.ts");
var net_config_1 = __nested_webpack_require_544569__(/*! ../net.config */ "./sdk/src/modules/net/net.config.ts");
var NetAgentHttpRequestMgr_1 = __nested_webpack_require_544569__(/*! ./NetAgentHttpRequestMgr */ "./sdk/src/modules/net/impl/NetAgentHttpRequestMgr.ts");
var EventManager_1 = __nested_webpack_require_544569__(/*! ../../EventManager */ "./sdk/src/modules/EventManager.ts");
var NetRetryLinkHandler_1 = __nested_webpack_require_544569__(/*! ./NetRetryLinkHandler */ "./sdk/src/modules/net/impl/NetRetryLinkHandler.ts");
var zego_externalError_1 = __nested_webpack_require_544569__(/*! ../../../zego.externalError */ "./sdk/src/zego.externalError.ts");
var client_util_1 = __nested_webpack_require_544569__(/*! ../../../../util/client-util */ "./sdk/util/client-util.ts");
var zego_config_1 = __nested_webpack_require_544569__(/*! ../../../zego.config */ "./sdk/src/zego.config.ts");
var NetAgentConnect = /** @class */ (function () {
    function NetAgentConnect(appID, env, logger, stateCenter) {
        var _this = this;
        this.appID = appID;
        this.env = env;
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.linkCheckTimer = null;
        this.connectServers = [];
        this.onConnectedEvent = function (isReconnect) {
            // 
            _this.getConfig();
            _this.dispatch()
                .then(function (servers) { })
                .catch(function (err) { });
            // this.netAgentPCRequestMgr.updateConnectState(PcConnectState.CONNECTED);
            // this.getAppConfig();
            // this.userManager.onConnected(isReconnect);
            // wss 
            _this.eventManager.emit('connected');
        };
        // isReconnect 
        this.onDisConnectedEvent = function (isReconnect) {
            // this.userManager.onDisConnected(isReconnect);
            // this.onDisConnected(isReconnect);
            // wss broken
            _this.eventManager.emit('broken');
            _this.netAgentPCRequestMgr.updateConnectState(AccessHubDefine_1.PcConnectState.DISCONNECT);
        };
        this.onPushEvent = function (streamID, msgType, msg) {
            switch (msgType) {
                case AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_REDIRECT:
                    // 
                    _this.redirect(msg);
                    break;
                case AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_CLOSE_CONNECTION:
                    // close
                    _this.connectClosed(msg);
                    break;
                // case AccessHubMessageType.MSG_TYPE_PC_DOWNWARD_MESSAGE:
                //     // 
                //     break;
                case AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_BROKEN:
                case AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_ESTABLISHED:
                case AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_DOWNWARD_MESSAGE:
                    _this.streamManager.onPushEvent(streamID, msgType, msg);
                    break;
                case AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PUSH_APPCONFIG:
                    var initConfig = _this.businessRequestMgr.decodeConfigMessage(msg.data);
                    console.warn(initConfig);
                    break;
                default:
                    break;
            }
        };
        this.protobuf = new AccessHubProtoBuf_1.AccessHubProtoBuf();
        this.zegoLink = new ZegoWssLink_1.ZegoWssLink(appID, env, this.protobuf, logger, stateCenter);
        this.checkLinkMsg();
        this.zegoLink.initEvent(this.onConnectedEvent, this.onDisConnectedEvent, this.onPushEvent);
        this.streamManager = new StreamManager_1.StreamManager(this.zegoLink);
        this.businessRequestMgr = new NetAgentBusinessRequestMgr_1.NetAgentBusinessRequestMgr(this.streamManager, this.protobuf, logger);
        this.netHeartBeatHandler = new NetHeartBeatHandler_1.NetHeartBeatHandler(this.streamManager, logger);
        this.netAgentPCRequestMgr = new NetAgentPCRequestMgr_1.NetAgentPCRequestMgr(this.streamManager, logger);
        this.netAgentHttpRequestMgr = new NetAgentHttpRequestMgr_1.NetAgentHttpRequestMgr(this.streamManager, logger);
        this.eventManager = new EventManager_1.EventManager();
        this.init();
    }
    NetAgentConnect.prototype.init = function () {
        var _this = this;
        this.netHeartBeatHandler.netHbLogout = function (err) {
            if (_this.retryLinkHandler) {
                if ([zego_externalError_1.errorCodeList.NET_HB_TIMEOUT.code].includes(err.code)) {
                    _this.retryLinkHandler.startMaxTime();
                    _this.retryLinkHandler.active();
                }
                else {
                    _this.retryLinkHandler.stopMaxTime();
                    _this.retryLinkHandler.invalid();
                    _this.eventManager.emit('disconnected');
                }
            }
        };
    };
    NetAgentConnect.prototype.checkLinkMsg = function () {
        var _this = this;
        var interval = Date.now() - this.zegoLink.updateMsgTime;
        // console.error('interval', interval)
        if (interval > 90 * 1000) {
            this.logger.info("zm.nac.clm" /* NETAGENTCONNECT_CHECKLINKMSG */ + ' interval: ' + interval);
            this.resetNetAgent();
            return;
        }
        this.linkCheckTimer && clearTimeout(this.linkCheckTimer);
        this.linkCheckTimer = setTimeout(function () {
            _this.checkLinkMsg();
        }, 5 * 1000);
    };
    NetAgentConnect.prototype.connect = function (servers) {
        var dispatchServers = this.getDispatchUrl();
        this.connectServers = __spreadArrays(dispatchServers, servers);
        this.zegoLink.createSocket(this.connectServers);
        if (!this.retryLinkHandler) {
            this.retryLinkHandler = new NetRetryLinkHandler_1.NetRetryLinkHandler(this.logger, this.stateCenter);
        }
        this.retryLinkHandler.initLink(this.zegoLink);
        this.retryLinkHandler.active(false, true);
    };
    NetAgentConnect.prototype.connectUa = function () {
        this.logger.info("zm.nac.cua" /* NETAGENTCONNECT_CONNECTUA */ + ' call');
        this.retryLinkHandler && this.retryLinkHandler.active(false, true);
    };
    NetAgentConnect.prototype.isConnect = function () {
        return this.zegoLink.isConnect();
    };
    NetAgentConnect.prototype.getHttpRequest = function (service) {
        // if (this.isConnect()) {
        return this.netAgentHttpRequestMgr.getRequest(service);
        // } else {
        //     this.connect(this.connectServers);
        //     return null;
        // }
    };
    NetAgentConnect.prototype.resetNetAgent = function () {
        this.netHeartBeatHandler.reset();
        this.zegoLink.destroySocket();
    };
    NetAgentConnect.prototype.getPCRequest = function (service, path, query) {
        var _this = this;
        // if (this.isConnect()) {
        var pcRequest = this.netAgentPCRequestMgr.getRequest(service, path, query);
        //  link
        pcRequest.on('disconnected', function () {
            // this.zegoLink.destroySocket();
            // this.zegoLink.connectSocket();
            //  wss broken
            _this.eventManager.emit('broken');
            _this.retryLinkHandler.active();
        });
        return pcRequest;
        // } else {
        //     this.connect(this.connectServers);
        //     return null;
        // }
    };
    // 
    // onDisConnected(isReconnect: boolean): void {}
    // onConnected(): void {}
    // emit(listener: string, ...args: Array<any>): void {
    //     this.eventManager.emit(listener, args);
    // }
    NetAgentConnect.prototype.on = function (event, callBack) {
        return this.eventManager.addEventHandler(event, callBack);
    };
    NetAgentConnect.prototype.off = function (event, callBack) {
        this.eventManager.removeEventHandler(event, callBack);
    };
    NetAgentConnect.prototype.getConfig = function () {
        var _this = this;
        var callBack = function (msg) {
            if (msg.code === 0) {
                _this.logger.info("zm.nac.gc" /* NETAGENTCONNECT_GETCONFIG */ + ' suc ' + JSON.stringify(msg));
                _this.getConfigSuccess(msg);
            }
            else {
                _this.logger.info("zm.nac.gc" /* NETAGENTCONNECT_GETCONFIG */ + ' fail');
            }
        };
        this.businessRequestMgr.getConfig(callBack, callBack);
    };
    NetAgentConnect.prototype.getConfigSuccess = function (msg) {
        this.netHeartBeatHandler.init(msg);
        this.netAgentPCRequestMgr.setEstablishTimeout(msg.data.pc_establish_timeout);
    };
    NetAgentConnect.prototype.dispatch = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.businessRequestMgr.dispatchURL(function (msg) {
                var wss_groups = msg.data.wss_groups;
                // const ws_groups = [{ host: 'ssss' }];
                _this.logger.info("zm.nab.du" /* NETAGENTBUS_DISPATCHURL */ + ' wss_groups: ' + JSON.stringify(wss_groups));
                var connectServers = _this.handleWssGroups(wss_groups);
                resolve(connectServers);
            }, function (err) {
                reject(err);
            });
        });
    };
    NetAgentConnect.prototype.handleWssGroups = function (wss_groups) {
        if (Array.isArray(wss_groups) && wss_groups.length > 0) {
            var dispatchServers = wss_groups.map(function (item) {
                return net_config_1.NET_ACCESS_CONFIG.scheme + '://' + item.host + '/' + net_config_1.NET_ACCESS_CONFIG.location;
            });
            var _serversString = client_util_1.ClientUtil.encryptStores(JSON.stringify(dispatchServers), zego_config_1.STORE_SECRET);
            localStorage.setItem(net_config_1.NET_ACCESS_SERVERS + '_' + this.appID + '_' + net_config_1.NET_ACCESS_CONFIG.modeNo, _serversString);
            return dispatchServers;
        }
        else {
            return [];
        }
    };
    NetAgentConnect.prototype.getAppConfig = function (userID, token) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (typeof userID !== 'string' || typeof token !== 'string') {
                _this.logger.error("zm.nac.gac" /* NETAGENTCONNECT_GETAPPCONFIG */ + ' userID or token must be string');
                return;
            }
            _this.businessRequestMgr
                .getAppConfig(userID, token)
                .then(function (initConfig) {
                resolve(initConfig);
            })
                .catch(function (err) {
                _this.logger.error("zm.nac.gac" /* NETAGENTCONNECT_GETAPPCONFIG */ + ' ' + JSON.stringify(err));
                if (err.code === 20008) {
                    // this.getAppConfig(userID, token)
                    //     .then(res => resolve(res))
                    //     .catch(err => reject(err));
                }
                // 
                if (AccessHubDefine_1.externalErrorList.indexOf(err.code)) {
                    reject(err);
                }
            });
        });
    };
    NetAgentConnect.prototype.getDispatchUrl = function () {
        var serverString = localStorage.getItem(net_config_1.NET_ACCESS_SERVERS + '_' + this.appID + '_' + net_config_1.NET_ACCESS_CONFIG.modeNo);
        if (!serverString) {
            return [];
        }
        var _decryptString = client_util_1.ClientUtil.decryptStores(serverString, zego_config_1.STORE_SECRET);
        if (_decryptString) {
            try {
                var servers = JSON.parse(_decryptString);
                return servers;
            }
            catch (error) {
                return [];
            }
        }
        return [];
    };
    NetAgentConnect.prototype.redirect = function (msg) {
        this.logger.info("zm.nac.rd" /* NETAGENTCONNECT_REDIRECT */ + (" " + JSON.stringify(msg.wss_groups)));
        var servers = this.handleWssGroups(msg.wss_groups);
        //  
        if (servers && Array.isArray(servers) && servers.length > 0) {
            this.zegoLink.destroySocket();
            this.eventManager.emit('broken');
            this.zegoLink.createSocket(servers);
            this.retryLinkHandler.active(false, true);
        }
        else {
            this.logger.warn("zm.nac.rd" /* NETAGENTCONNECT_REDIRECT */ + " wss_groups null");
        }
    };
    NetAgentConnect.prototype.connectClosed = function (msg) {
        var _this = this;
        this.logger.info("zm.nac.cc" /* NETAGENTCONNECT_CONNECTCLOSED */ + (" " + msg.reason + " " + msg.msg + " " + msg.action));
        switch (msg.action) {
            case AccessHubDefine_1.ConnectionClosedAction.ACTION_DISPATCH:
                this.dispatch()
                    .then(function (servers) {
                    if (Array.isArray(servers) && servers.length > 0) {
                        _this.zegoLink.destroySocket();
                        _this.eventManager.emit('broken');
                        _this.zegoLink.createSocket(servers);
                        _this.retryLinkHandler.active(false, true);
                    }
                })
                    .catch(function (err) {
                    _this.logger.info("zm.nac.cc" /* NETAGENTCONNECT_CONNECTCLOSED */ + " dispatch fail");
                });
                break;
            case AccessHubDefine_1.ConnectionClosedAction.ACTION_RETRY:
                // this.zegoLink.destroySocket();
                // this.zegoLink.connectSocket();
                this.eventManager.emit('broken');
                this.retryLinkHandler.active(false);
                break;
            case AccessHubDefine_1.ConnectionClosedAction.ACTION_NEXT_GROUP:
                // this.zegoLink.destroySocket();
                // this.zegoLink.connectSocket(true);
                this.eventManager.emit('broken');
                this.retryLinkHandler.active();
                break;
            case AccessHubDefine_1.ConnectionClosedAction.ACTION_ABORT:
                // TODO 
                break;
            case AccessHubDefine_1.ConnectionClosedAction.ACTION_RESERVED:
                // TODO 
                break;
        }
    };
    NetAgentConnect.prototype.netOnLineHandler = function () {
        if (this.retryLinkHandler && this.zegoLink.isDisConnect()) {
            console.error('isDisconnect');
            this.retryLinkHandler.active();
        }
        else {
            console.error('connect');
            this.retryLinkHandler.stopMaxTime();
            // this.eventManager.emit('connected');
            // this.netAgentPCRequestMgr.updateConnectState(PcConnectState.CONNECTED);
        }
    };
    NetAgentConnect.prototype.netOffLineHandler = function () {
        if (this.retryLinkHandler) {
            console.error('disconnect');
            this.retryLinkHandler.invalid();
            this.retryLinkHandler.onactive = function (succsss, error) { };
            this.retryLinkHandler.startMaxTime();
        }
        // this.eventManager.emit('broken');
        // this.netAgentPCRequestMgr.updateConnectState(PcConnectState.DISCONNECT);
    };
    NetAgentConnect.prototype.testConnect = function () {
        var mixRequest = this.getHttpRequest(AccessHubDefine_1.BusinessService.SERVICE_MIX);
        // TODO ABORT PUSH_APP_CONFIG
        mixRequest === null || mixRequest === void 0 ? void 0 : mixRequest.sendRequest({
            headers: [],
            body: {},
            idName: '333',
            ack: true,
            stick: 'zego-action-dispatch',
            method_no: AccessHubDefine_1.Method.METHOD_POST,
            location: '',
        }, function (res) {
            console.warn('suc', res);
        }, function (e) {
            console.warn('suc', e);
        }, function (res) {
            console.warn('suc', res);
        });
        // const cloudSettingRequest = this.getHttpRequest(BusinessService.SERVICE_ClOUD_SETTING);
        // TODO ABORT PUSH_APP_CONFIG
        // cloudSettingRequest?.sendRequest(
        //     {
        //         // headers: [],
        //         body: {
        //             appid: 3104114736,
        //             biztype: 0,
        //             compress: false,
        //             deviceid: 'd2ffd8e1-a45a-4705-8897-b21bf7ad23cd',
        //             files: ['init'],
        //             id_name: '1640682082911',
        //             mode: 'test',
        //             param: {},
        //             product: 'Web_SDK',
        //             timestamp: 1640682082964,
        //             token:
        //                 'eyJ2ZXIiOjEsImhhc2giOiJmMjY5MTU2NWZiODE0ZGNiYjQxZmNlYjllYzRhNzI4YyIsIm5vbmNlIjoiYWRmOGU1MTYzM2VhMWFjMWVkMTI4YzUwNWJiMjM4ODkiLCJleHBpcmVkIjoxNjQzMjc0MDgyfQ==',
        //         },
        //         idName: '1640682082911',
        //         ack: false,
        //         // stick: Stick.DISPATCH,
        //         method_no: Method.METHOD_POST,
        //         location: '/cloud-setting/get',
        //     },
        //     null,
        //     null,
        //     null,
        // );
    };
    return NetAgentConnect;
}());
exports.NetAgentConnect = NetAgentConnect;


/***/ }),

/***/ "./sdk/src/modules/net/impl/NetAgentHttpRequest.ts":
/*!*********************************************************!*\
  !*** ./sdk/src/modules/net/impl/NetAgentHttpRequest.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_563553__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NetAgentHttpRequest = void 0;
var AccessHubDefine_1 = __nested_webpack_require_563553__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var string_1 = __nested_webpack_require_563553__(/*! ../../../../util/string */ "./sdk/util/string.ts");
var zego_externalError_1 = __nested_webpack_require_563553__(/*! ../../../zego.externalError */ "./sdk/src/zego.externalError.ts");
var NetAgentHttpRequest = /** @class */ (function () {
    function NetAgentHttpRequest(logger, service, streamManager) {
        this.logger = logger;
        this.service = service;
        this.streamManager = streamManager;
        this.netHttpStream = this.streamManager.createStream(AccessHubDefine_1.StreamType.HTTP);
    }
    NetAgentHttpRequest.prototype.sendRequest = function (params, sucFunc, errFunc, ackFunc) {
        var _this = this;
        if (this.netHttpStream.isConnect()) {
            var reqBody = {
                service_no: this.service,
                ack: params.ack,
                headers: params.headers,
                body: string_1.encodeString(JSON.stringify(params.body)),
                id_name: params.idName,
                method_no: params.method_no,
                // TODO test
                stick: params.stick,
                location: params.location,
            };
            var httpSucCallback = function (msg) {
                _this.logger.info("zm.nahr.sr" /* NETAGENTHTTPREQUEST_SENDREQUEST */ + ' suc ' + JSON.stringify(msg));
                if (msg.body) {
                    var decodeBody = string_1.decodeString(msg.body);
                    // console.error('decodeBody', this.service, decodeBody);
                    msg.body = decodeBody;
                }
                sucFunc && sucFunc(msg);
            };
            var httpFailCallback = function (e) {
                _this.logger.error("zm.nahr.sr" /* NETAGENTHTTPREQUEST_SENDREQUEST */ + ' fail');
                errFunc && errFunc(e);
            };
            var httpAckCallback = function (msg) {
                _this.logger.error("zm.nahr.sr" /* NETAGENTHTTPREQUEST_SENDREQUEST */ + ' ack');
                ackFunc && ackFunc(msg);
            };
            this.netHttpStream.sendMessage(AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HTTP_REQUEST, reqBody, httpSucCallback, httpFailCallback, httpAckCallback);
            this.netHttpStream.isFirst = false;
        }
        else {
            errFunc && errFunc(zego_externalError_1.errorCodeList.SOCKET_CLOSE);
        }
    };
    return NetAgentHttpRequest;
}());
exports.NetAgentHttpRequest = NetAgentHttpRequest;


/***/ }),

/***/ "./sdk/src/modules/net/impl/NetAgentHttpRequestMgr.ts":
/*!************************************************************!*\
  !*** ./sdk/src/modules/net/impl/NetAgentHttpRequestMgr.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_566592__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NetAgentHttpRequestMgr = void 0;
var NetAgentHttpRequest_1 = __nested_webpack_require_566592__(/*! ./NetAgentHttpRequest */ "./sdk/src/modules/net/impl/NetAgentHttpRequest.ts");
var NetAgentHttpRequestMgr = /** @class */ (function () {
    function NetAgentHttpRequestMgr(streamManager, logger) {
        this.streamManager = streamManager;
        this.logger = logger;
    }
    NetAgentHttpRequestMgr.prototype.getRequest = function (service) {
        var httpRequest = new NetAgentHttpRequest_1.NetAgentHttpRequest(this.logger, service, this.streamManager);
        // pcRequest.onPcEstablished = (streamID: number): void => {
        //     this.onConnectEvent(streamID);
        // };
        // pcRequest.onPcBroken = (streamID: number): void => {
        //     this.onDisConnectEvent(streamID);
        // };
        // pcRequest.setStream(pcLinkStream);
        // this.pcStreamRequests[pcLinkStream.StreamID] = { stream: pcLinkStream, request: pcRequest };
        return httpRequest;
    };
    return NetAgentHttpRequestMgr;
}());
exports.NetAgentHttpRequestMgr = NetAgentHttpRequestMgr;


/***/ }),

/***/ "./sdk/src/modules/net/impl/NetAgentPCRequest.ts":
/*!*******************************************************!*\
  !*** ./sdk/src/modules/net/impl/NetAgentPCRequest.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_568106__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NetAgentPCRequest = void 0;
var string_1 = __nested_webpack_require_568106__(/*! ../../../../util/string */ "./sdk/util/string.ts");
var zego_externalError_1 = __nested_webpack_require_568106__(/*! ../../../zego.externalError */ "./sdk/src/zego.externalError.ts");
var EventManager_1 = __nested_webpack_require_568106__(/*! ../../EventManager */ "./sdk/src/modules/EventManager.ts");
var AccessHubDefine_1 = __nested_webpack_require_568106__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var net_config_1 = __nested_webpack_require_568106__(/*! ../net.config */ "./sdk/src/modules/net/net.config.ts");
var encodeServiceList = [AccessHubDefine_1.BusinessService.SERVICE_WEBRTC_SIGNAL, AccessHubDefine_1.BusinessService.SERVICE_L3_WEBRTC_SIGNAL];
var NetAgentPCRequest = /** @class */ (function () {
    function NetAgentPCRequest(logger, service, streamManager, pcEstablishTimeout, path, query) {
        this.logger = logger;
        this.service = service;
        this.streamManager = streamManager;
        this.pcEstablishTimeout = pcEstablishTimeout;
        this.path = path;
        this.query = query;
        this.connectState = AccessHubDefine_1.PcConnectState.DISCONNECT;
        this.brokenTimer = null;
        this.listenerList = {
            connected: [],
            broken: [],
        };
        this.netPcStream = this.streamManager.createStream(AccessHubDefine_1.StreamType.PC);
        this.eventManager = new EventManager_1.EventManager();
        this.netPcStream.onPushEvent = this.onPushEvent.bind(this);
    }
    NetAgentPCRequest.prototype.sendRequest = function (body, failFunc, ackFunc) {
        var _this = this;
        if (this.netPcStream.isConnect()) {
            body.ack === undefined && (body.ack = true);
            var _message = body.payload;
            if (encodeServiceList.includes(this.service)) {
                _message = string_1.encodeString(body.payload);
            }
            var reqBody = {
                service_no: this.service,
                ack: body.ack,
                payload: _message,
                wss_message_type: net_config_1.NET_ACCESS_CONFIG.wssMessageType,
                wss_path: this.path,
                wss_raw_query: this.query
            };
            var pcSucCallback = function () {
                _this.logger.info("zm.napr.sr" /* NETAGENTPCREQUEST_SENDREQUEST */ + ' suc');
                ackFunc && ackFunc();
            };
            var pcFailCallback = function (err) {
                _this.logger.error("zm.napr.sr" /* NETAGENTPCREQUEST_SENDREQUEST */ + ' fail');
                failFunc && failFunc(err);
            };
            this.netPcStream.sendMessage(AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_UPWARD_MESSAGE, reqBody, pcSucCallback, pcFailCallback);
            this.netPcStream.isFirst = false;
        }
        else {
            failFunc && failFunc(zego_externalError_1.errorCodeList.SOCKET_CLOSE);
        }
    };
    NetAgentPCRequest.prototype.onPushEvent = function (msgType, msg) {
        this.logger.info("zm.napr.ope" /* NETAGENTPCREQUEST_ONPUSHEVENT */ + (" msgType: " + msgType));
        switch (msgType) {
            case AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_ESTABLISHED:
                this.pcEstablished();
                break;
            case AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_BROKEN:
                this.pcBroken();
                break;
            case AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_DOWNWARD_MESSAGE:
                // this.onDownLoadMessage(msg.payload);
                var rsp = msg.payload;
                if (encodeServiceList.includes(this.service)) {
                    rsp = string_1.decodeString(msg.payload);
                }
                this.eventManager.emit('downLoadMessage', rsp);
                break;
        }
    };
    // 
    // onDownLoadMessage(payload: any): void {
    //     // this.logger.info(ZEGO_ACCESS_ACTION.NETAGENTPCREQUEST_ONDOWNLOADMESSAGE + ' call');
    // }
    // 
    // onConnected(): void {}
    NetAgentPCRequest.prototype.on = function (event, callBack) {
        return this.eventManager.addEventHandler(event, callBack);
    };
    NetAgentPCRequest.prototype.off = function (event, callBack) {
        this.eventManager.removeEventHandler(event, callBack);
    };
    // 
    // onDisConnected(): void {}
    NetAgentPCRequest.prototype.pcEstablished = function () {
        this.logger.info("zm.napr.pe" /* NETAGENTPCREQUEST_PCESTABLISHED */ + ' call');
        this.connectState = AccessHubDefine_1.PcConnectState.CONNECTED;
        // this.onConnected();
        // this.actionListener('connected');
        this.eventManager.emit('connected');
        this.brokenTimer && clearTimeout(this.brokenTimer);
    };
    NetAgentPCRequest.prototype.pcBroken = function () {
        var _this = this;
        this.logger.info("zm.napr.pb" /* NETAGENTPCREQUEST_PCBROKEN */ + ' call');
        this.connectState = AccessHubDefine_1.PcConnectState.DISCONNECT;
        // this.actionListener('broken');
        this.eventManager.emit('broken');
        this.brokenTimer = setTimeout(function () {
            //   // TODO
            // this.actionListener('disconnected');
            _this.eventManager.emit('disconnected');
        }, this.pcEstablishTimeout * 1000);
    };
    NetAgentPCRequest.prototype.closeRequest = function () {
        this.netPcStream.closeStream(0, '');
        var streamID = this.streamManager.getStreamID();
        this.netPcStream.refresh(streamID);
        this.eventManager.emit('disconnected');
    };
    return NetAgentPCRequest;
}());
exports.NetAgentPCRequest = NetAgentPCRequest;


/***/ }),

/***/ "./sdk/src/modules/net/impl/NetAgentPCRequestMgr.ts":
/*!**********************************************************!*\
  !*** ./sdk/src/modules/net/impl/NetAgentPCRequestMgr.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_574226__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NetAgentPCRequestMgr = void 0;
var AccessHubDefine_1 = __nested_webpack_require_574226__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var net_config_1 = __nested_webpack_require_574226__(/*! ../net.config */ "./sdk/src/modules/net/net.config.ts");
var NetAgentPCRequest_1 = __nested_webpack_require_574226__(/*! ./NetAgentPCRequest */ "./sdk/src/modules/net/impl/NetAgentPCRequest.ts");
var NetAgentPCRequestMgr = /** @class */ (function () {
    function NetAgentPCRequestMgr(streamManager, logger) {
        this.streamManager = streamManager;
        this.logger = logger;
        // pcStreamRequests: {
        //     [index: number]: { stream: ZegoLinkStream; request: NetAgentPCRequest; timer?: NodeJS.Timeout };
        // } = {};
        this.pcStreamRequests = [];
        this.pcEstablishTimeout = net_config_1.NET_ACCESS_CONFIG.pcEstablishTimeout;
    }
    NetAgentPCRequestMgr.prototype.getRequest = function (service, path, query) {
        var pcRequest = new NetAgentPCRequest_1.NetAgentPCRequest(this.logger, service, this.streamManager, this.pcEstablishTimeout, path || '', query || '');
        // pcRequest.onPcEstablished = (streamID: number): void => {
        //     this.onConnectEvent(streamID);
        // };
        // pcRequest.onPcBroken = (streamID: number): void => {
        //     this.onDisConnectEvent(streamID);
        // };
        // pcRequest.setStream(pcLinkStream);
        // this.pcStreamRequests[pcLinkStream.StreamID] = { stream: pcLinkStream, request: pcRequest };
        this.pcStreamRequests.push(pcRequest);
        return pcRequest;
    };
    NetAgentPCRequestMgr.prototype.updateConnectState = function (state) {
        this.pcStreamRequests.forEach(function (pcRequest) {
            if (state === AccessHubDefine_1.PcConnectState.DISCONNECT) {
                pcRequest.eventManager.emit('broken');
            }
        });
    };
    // onConnectEvent(streamID: number): void {
    //     const streamRequest = this.pcStreamRequests[streamID];
    //     streamRequest.timer && clearTimeout(streamRequest.timer);
    // }
    // onDisConnectEvent(streamID: number): void {
    //     const streamRequest = this.pcStreamRequests[streamID];
    //     if (streamRequest) {
    //         streamRequest.timer = brokenTimer;
    //     }
    // }
    NetAgentPCRequestMgr.prototype.setEstablishTimeout = function (timeout) {
        this.pcEstablishTimeout = timeout;
    };
    return NetAgentPCRequestMgr;
}());
exports.NetAgentPCRequestMgr = NetAgentPCRequestMgr;


/***/ }),

/***/ "./sdk/src/modules/net/impl/NetHeartBeatHandler.ts":
/*!*********************************************************!*\
  !*** ./sdk/src/modules/net/impl/NetHeartBeatHandler.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_577180__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NetHeartBeatHandler = void 0;
var zego_externalError_1 = __nested_webpack_require_577180__(/*! ../../../zego.externalError */ "./sdk/src/zego.externalError.ts");
var AccessHubDefine_1 = __nested_webpack_require_577180__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var NetHeartBeatHandler = /** @class */ (function () {
    function NetHeartBeatHandler(streamManager, logger) {
        this.streamManager = streamManager;
        this.logger = logger;
        this.hbTimer = null;
        this.hbInterval = 5;
        this.hbTimeout = 10;
        this.hbTimeoutMaxCount = 0;
        this.tryHbCount = 0;
    }
    NetHeartBeatHandler.prototype.init = function (msg) {
        var _this = this;
        this.logger.info("zm.nhb.ii" /* NETHEARTBEAT_INIT */ + ' call');
        if (!this.hbStream) {
            this.hbStream = this.streamManager.createStream(AccessHubDefine_1.StreamType.OTHER);
        }
        this.hbInterval = msg.data.logic_hb_interval;
        this.hbTimeout = msg.data.logic_hb_timeout;
        this.hbTimeoutMaxCount = this.hbTimeout / this.hbInterval;
        this.hbTimer && clearTimeout(this.hbTimer);
        this.hbTimer = setTimeout(function () {
            _this.start();
        }, this.hbInterval * 1000);
    };
    NetHeartBeatHandler.prototype.start = function () {
        var _this = this;
        this.logger.info("zm.nhb.s" /* NETHEARTBEAT_START */ + ' call');
        if (this.tryHbCount++ > this.hbTimeoutMaxCount) {
            this.logger.error("zm.nhb.s" /* NETHEARTBEAT_START */ + ' come to try limit');
            // 
            this.reset();
            //
            this.netHbLogout(zego_externalError_1.errorCodeList.NET_HB_TIMEOUT);
            return;
        }
        // start hb
        var hbCallback = function () {
            _this.logger.info("zm.nhb.s" /* NETHEARTBEAT_START */ + ' hb callback');
            _this.tryHbCount = 0;
        };
        var reqBody = {
            ts: Date.now(),
        };
        this.hbStream.sendMessage(AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HB_REQUEST, reqBody, hbCallback, hbCallback);
        this.hbTimer && clearTimeout(this.hbTimer);
        this.hbTimer = setTimeout(function () {
            _this.start();
        }, this.hbInterval * 1000);
    };
    NetHeartBeatHandler.prototype.netHbLogout = function (err) { };
    NetHeartBeatHandler.prototype.reset = function () {
        if (this.hbTimer) {
            clearTimeout(this.hbTimer);
            this.hbTimer = null;
        }
        this.tryHbCount = 0;
    };
    return NetHeartBeatHandler;
}());
exports.NetHeartBeatHandler = NetHeartBeatHandler;


/***/ }),

/***/ "./sdk/src/modules/net/impl/NetRetryLinkHandler.ts":
/*!*********************************************************!*\
  !*** ./sdk/src/modules/net/impl/NetRetryLinkHandler.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_580257__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetRetryLinkHandler = void 0;
var zego_externalError_1 = __nested_webpack_require_580257__(/*! ../../../zego.externalError */ "./sdk/src/zego.externalError.ts");
var retryHandler_1 = __nested_webpack_require_580257__(/*! ../../retryHandler */ "./sdk/src/modules/retryHandler.ts");
var NetRetryLinkHandler = /** @class */ (function (_super) {
    __extends(NetRetryLinkHandler, _super);
    function NetRetryLinkHandler(logger, stateCenter) {
        var _this = _super.call(this, logger, stateCenter) || this;
        _this.logger = logger;
        _this.stateCenter = stateCenter;
        return _this;
    }
    NetRetryLinkHandler.prototype.initLink = function (link) {
        this.link = link;
    };
    //
    NetRetryLinkHandler.prototype.startMaxTime = function () {
        var _this = this;
        if (this.maxTimer) {
            return;
        }
        this.maxTimer = setTimeout(function () {
            // this.logger.info(ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + ` over max time ${this.RETRY_MAX_TIME}s, stop retry`);
            _this.isOverTime = true;
            //
            // this.roomHandler.resetRoom();
            _this.link.resetConnect();
            _this.stopMaxTime();
            _this.invalid();
            _this.onactive(false, zego_externalError_1.errorCodeList.NET_SOCKET_TIMEOUT);
        }, this.RETRY_MAX_TIME * 1e3);
    };
    //
    NetRetryLinkHandler.prototype.stopMaxTime = function () {
        this.maxTimer && clearTimeout(this.maxTimer);
        this.maxTimer = null;
    };
    NetRetryLinkHandler.prototype.active = function (isNext, isFirst) {
        var _this = this;
        //,
        if (this.retryTimer) {
            this.logger.info("zm.rlh.at" /* RETRYLINKHANDLER */ + ' has actived, ignore');
            return;
        }
        //
        if (this.isOverTime) {
            this.logger.info("zm.rlh.at" /* RETRYLINKHANDLER */ + ' retry over time, stop retry');
            return;
        }
        //
        if (this.retryActiveCount == 1) {
            this.retryActiveInterval = Math.floor(Math.random() * (1 - this.RETRY_START_TIME_INTERVAL) + this.RETRY_START_TIME_INTERVAL);
        }
        else {
            var retryActiveInterval = Math.pow(2, Math.round(this.retryActiveCount / this.RETRY_CONTINUE_COUNT + 1));
            this.retryActiveInterval =
                retryActiveInterval > this.RETRY_MAX_TIME_INTERVAL ? this.RETRY_MAX_TIME_INTERVAL : retryActiveInterval;
        }
        // console.error('retryActiveInterval', this.retryActiveInterval, Date.now());
        this.retryTimer = setTimeout(function () {
            // console.error('connectSocket', Date.now());
            _this.link.destroySocket();
            _this.link.connectSocket(isNext, function () {
                _this.logger.info("zm.rlh.at" /* RETRYLINKHANDLER */ + ' suc');
                _this.stopMaxTime();
                _this.invalid();
                _this.onactive(true);
            }, function () {
                _this.logger.info("zm.rlh.at" /* RETRYLINKHANDLER */ + ' fail');
                !_this.maxTimer && _this.startMaxTime();
                _this.active(true);
            });
            _this.retryTimer && clearTimeout(_this.retryTimer);
            _this.retryTimer = null;
            _this.retryActiveCount++;
        }, isFirst ? 0 : this.retryActiveInterval * 1000);
    };
    NetRetryLinkHandler.prototype.onactive = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
    };
    return NetRetryLinkHandler;
}(retryHandler_1.TryHandler));
exports.NetRetryLinkHandler = NetRetryLinkHandler;


/***/ }),

/***/ "./sdk/src/modules/net/impl/NetSocketService.ts":
/*!******************************************************!*\
  !*** ./sdk/src/modules/net/impl/NetSocketService.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_585012__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NetSocketService = void 0;
var zego_entity_1 = __nested_webpack_require_585012__(/*! ../../../zego.entity */ "./sdk/src/zego.entity.ts");
var NetSocketService = /** @class */ (function () {
    function NetSocketService(ENV) {
        this.socket = null;
        this.ENV = ENV;
    }
    NetSocketService.prototype.createSocket = function (server) {
        this.socket = zego_entity_1.createZegoWebSocket(server, this.ENV % 2);
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    NetSocketService.prototype.openHandler = function (hander) {
        var _this = this;
        if (this.socket)
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.socket.onopen = function (evt) {
                _this.socket.binaryType = 'arraybuffer';
                _this.responseHandler();
                hander(evt);
            };
    };
    /*
     *    "zb.sc.ws.rph: "ZegoExpressEngine.base.SocketCenter.responseHandler"
     */
    NetSocketService.prototype.responseHandler = function () {
        var _this = this;
        if (this.socket)
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.socket.onmessage = function (e) {
                var msg = typeof e.data == 'string'
                    ? JSON.parse(e.data)
                    : //: JSON.parse(String.fromCharCode.apply(null, new Uint8Array(e.data) as any));
                        e.data;
                _this.onMessage(msg);
            };
    };
    //cmd
    NetSocketService.prototype.onMessage = function (msg) { };
    /*
     *    "zb.sc.ch": "ZegoExpressEngine.base.SocketCenter.closeHandler"
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    NetSocketService.prototype.closeHandler = function (handler) {
        if (this.socket)
            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
            this.socket.onclose = function (evt) {
                console.error('onclose', evt);
                handler(evt);
            };
    };
    /*
     *    "zb.sc.ws.oe": "ZegoExpressEngine.base.SocketCenter.errorHandler"
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    NetSocketService.prototype.errorHandler = function (handler) {
        this.socket && (this.socket.onerror = handler);
    };
    NetSocketService.prototype.closeSocket = function () {
        if (this.socket) {
            this.socket.onclose = null;
            this.socket.onerror = null;
            this.socket.close();
            this.socket = null;
        }
    };
    NetSocketService.prototype.isDisConnect = function () {
        return !this.socket || this.socket.readyState !== 1;
    };
    NetSocketService.prototype.sendMessage = function (msg) {
        if (this.isDisConnect())
            return;
        if (!this.socket)
            return;
        if (this.ENV % 2 === 1) {
            // TODO wx
        }
        else {
            this.socket.send(msg);
        }
    };
    return NetSocketService;
}());
exports.NetSocketService = NetSocketService;


/***/ }),

/***/ "./sdk/src/modules/net/impl/StreamManager.ts":
/*!***************************************************!*\
  !*** ./sdk/src/modules/net/impl/StreamManager.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_588527__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamManager = void 0;
var AccessHubDefine_1 = __nested_webpack_require_588527__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var ZegoLinkStream_1 = __nested_webpack_require_588527__(/*! ./ZegoLinkStream */ "./sdk/src/modules/net/impl/ZegoLinkStream.ts");
var StreamManager = /** @class */ (function () {
    function StreamManager(zegoLink) {
        this.zegoLink = zegoLink;
        this.streamID = 0;
        this.httpStreams = [];
        this.pcStreams = [];
    }
    StreamManager.prototype.createStream = function (streamType) {
        if (streamType === AccessHubDefine_1.StreamType.HTTP) {
            return this.getStream(streamType, this.httpStreams);
        }
        else if (streamType === AccessHubDefine_1.StreamType.PC) {
            var linkStream = new ZegoLinkStream_1.ZegoLinkStream(streamType, this.streamID++, this.zegoLink);
            this.pcStreams.push(linkStream);
            return linkStream;
        }
        else {
            var linkStream = new ZegoLinkStream_1.ZegoLinkStream(streamType, this.streamID++, this.zegoLink);
            return linkStream;
        }
    };
    StreamManager.prototype.getStream = function (streamType, streams) {
        var freeStream = streams.find(function (stream) { return stream.isFree === true; });
        if (freeStream) {
            freeStream.isFree = false;
            freeStream.isFirst = false;
            return freeStream;
        }
        else {
            var linkStream = new ZegoLinkStream_1.ZegoLinkStream(streamType, this.streamID++, this.zegoLink);
            return linkStream;
        }
    };
    StreamManager.prototype.onPushEvent = function (streamID, msgType, msg) {
        // console.warn('onPushEvent ', streamID, msgType, JSON.stringify(msg));
        var pcStream = this.pcStreams.find(function (stream) { return stream.StreamID === streamID; });
        pcStream && pcStream.onPushEvent(msgType, msg);
    };
    StreamManager.prototype.getStreamID = function () {
        return this.streamID++;
    };
    return StreamManager;
}());
exports.StreamManager = StreamManager;


/***/ }),

/***/ "./sdk/src/modules/net/impl/ZegoLink.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/net/impl/ZegoLink.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ZegoLink = void 0;
var ZegoLink = /** @class */ (function () {
    function ZegoLink() {
        this.txid = 0;
        this.linkRetryTime = 60;
        this.updateMsgTime = 0;
    }
    ZegoLink.prototype.createSocket = function (servers) { };
    ZegoLink.prototype.initEvent = function (onConnectedEvent, onDisConnectedEvent, onPushEvent) { };
    ZegoLink.prototype.sendMessage = function (type, streamID, body, isFirst, success, error, ackFunc) {
        if (isFirst === void 0) { isFirst = true; }
        if (success === void 0) { success = null; }
        if (error === void 0) { error = null; }
        if (ackFunc === void 0) { ackFunc = null; }
    };
    return ZegoLink;
}());
exports.ZegoLink = ZegoLink;


/***/ }),

/***/ "./sdk/src/modules/net/impl/ZegoLinkStream.ts":
/*!****************************************************!*\
  !*** ./sdk/src/modules/net/impl/ZegoLinkStream.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_592153__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ZegoLinkStream = void 0;
var AccessHubDefine_1 = __nested_webpack_require_592153__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var ZegoLinkStream = /** @class */ (function () {
    function ZegoLinkStream(type, streamID, zegoLink) {
        this.type = type;
        this.streamID = streamID;
        this.zegoLink = zegoLink;
        this.isFree = false;
        this.isFirst = true;
    }
    Object.defineProperty(ZegoLinkStream.prototype, "StreamID", {
        get: function () {
            return this.streamID;
        },
        enumerable: false,
        configurable: true
    });
    ZegoLinkStream.prototype.refresh = function (streamID) {
        this.streamID = streamID;
    };
    ZegoLinkStream.prototype.sendMessage = function (type, body, successFunc, errorFunc, ackFunc) {
        var _this = this;
        if (successFunc === void 0) { successFunc = null; }
        if (errorFunc === void 0) { errorFunc = null; }
        if (ackFunc === void 0) { ackFunc = null; }
        this.zegoLink.sendMessage(type, this.streamID, body, this.isFirst, function (msg) {
            _this.type === AccessHubDefine_1.StreamType.HTTP && (_this.isFree = true);
            successFunc && successFunc(msg);
        }, function (err) {
            _this.type === AccessHubDefine_1.StreamType.HTTP && (_this.isFree = true);
            errorFunc && errorFunc(err);
        }, ackFunc);
    };
    ZegoLinkStream.prototype.onPushEvent = function (msgType, msg) { };
    ZegoLinkStream.prototype.closeStream = function (code, msg) {
        this.zegoLink.sendMessage(AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_STREAM_CLOSED, this.streamID, {
            code: code,
            msg: msg,
        });
    };
    ZegoLinkStream.prototype.isConnect = function () {
        return this.zegoLink.isConnect();
    };
    return ZegoLinkStream;
}());
exports.ZegoLinkStream = ZegoLinkStream;


/***/ }),

/***/ "./sdk/src/modules/net/impl/ZegoWssLink.ts":
/*!*************************************************!*\
  !*** ./sdk/src/modules/net/impl/ZegoWssLink.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_594472__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZegoWssLink = void 0;
var zego_entity_1 = __nested_webpack_require_594472__(/*! ../../../zego.entity */ "./sdk/src/zego.entity.ts");
var AccessHubDefine_1 = __nested_webpack_require_594472__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
var ZegoLink_1 = __nested_webpack_require_594472__(/*! ./ZegoLink */ "./sdk/src/modules/net/impl/ZegoLink.ts");
var NetSocketService_1 = __nested_webpack_require_594472__(/*! ./NetSocketService */ "./sdk/src/modules/net/impl/NetSocketService.ts");
var zego_externalError_1 = __nested_webpack_require_594472__(/*! ../../../zego.externalError */ "./sdk/src/zego.externalError.ts");
var net_config_1 = __nested_webpack_require_594472__(/*! ../net.config */ "./sdk/src/modules/net/net.config.ts");
var ZegoWssLink = /** @class */ (function (_super) {
    __extends(ZegoWssLink, _super);
    // retryLinkHandler: RetryLinkHandler;
    function ZegoWssLink(appID, env, protobuf, logger, stateCenter) {
        var _this = _super.call(this) || this;
        _this.appID = appID;
        _this.env = env;
        _this.protobuf = protobuf;
        _this.logger = logger;
        _this.stateCenter = stateCenter;
        _this.socketService = new NetSocketService_1.NetSocketService(_this.env);
        _this.urlIndex = 0;
        _this.updateMsgTime = 0;
        _this.unUpdateMsgTimeTypes = [AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HB_REQUEST, AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HB_RESPONSE, AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_GET_CONFIG_REQUEST, AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_GET_CONFIG_RESPONSE];
        _this.netLinkState = zego_entity_1.ENUM_CONNECT_STATE.disconnect;
        // , 
        _this.sendCommandList = new zego_entity_1.LinkedList();
        _this.sendCommandMap = {};
        // 
        _this.sendDataCheckOnceCount = 100;
        // ,
        _this.sendDataDropTimeout = 10 * 1000;
        // 
        _this.sendDataCheckInterval = 2000;
        _this.timeout = 5000;
        _this.connectInterval = 10 * 1000;
        _this.connectTimer = null;
        // networkState: NetWorkState = NetWorkState.online;
        _this.connectRsp = {};
        _this.updateMsgTime = Date.now();
        return _this;
        // this.bindWindowHandler();
    }
    ZegoWssLink.prototype.initEvent = function (onConnectedEvent, onDisConnectedEvent, onPushEvent) {
        this.onConnectedEvent = onConnectedEvent;
        this.onDisConnectedEvent = onDisConnectedEvent;
        this.onPushEvent = onPushEvent;
    };
    ZegoWssLink.prototype.createSocket = function (servers) {
        this.servers = servers;
        // this.retryLinkHandler.init(this.linkRetryTime);
        // this.retryLinkHandler.initLink(this.socketService, this.servers);
        this.urlIndex = 0;
        // this.connectSocket();
    };
    ZegoWssLink.prototype.destroySocket = function () {
        this.logger.info("zm.wl.ds.0" /* WSSLINK_DESTROYSOCKET */ + ' call');
        this.socketService.closeSocket();
        this.netLinkState = zego_entity_1.ENUM_CONNECT_STATE.disconnect;
        this.resetConnect();
    };
    ZegoWssLink.prototype.refreshServers = function (servers) {
        this.servers = __spreadArrays(servers, this.servers);
    };
    ZegoWssLink.prototype.connectSocket = function (isNext, success, fail) {
        var _this = this;
        if (isNext === void 0) { isNext = true; }
        this.logger.info("zm.wl.cs.0" /* WSSLINK_CONNECTSOCKET */ + ' call');
        this.connectRsp.suc = success;
        this.connectRsp.fail = fail;
        if (this.stateCenter.networkState !== zego_entity_1.ENUM_NETWORK_STATE.online) {
            // this.urlIndex = (this.urlIndex + 1) % this.servers.length;
            return false;
        }
        if (isNext) {
            this.urlIndex = (this.urlIndex + 1) % this.servers.length;
        }
        // console.error('urlIndex', this.urlIndex);
        var server = this.servers[this.urlIndex];
        // this.retryLinkHandler.active(this.urlIndex);
        this.closeSocket();
        this.netLinkState = zego_entity_1.ENUM_CONNECT_STATE.connecting;
        this.socketService.createSocket(server);
        this.bindSocketEvent();
        this.connectTimer = setTimeout(function () {
            _this.logger.info("zm.wl.cs.0" /* WSSLINK_CONNECTSOCKET */ + ' timeout');
            // this.reconnect();
            _this.connectRsp.fail && _this.connectRsp.fail();
        }, this.connectInterval);
        return true;
    };
    ZegoWssLink.prototype.bindSocketEvent = function () {
        var _this = this;
        this.openHandler(function () {
            _this.logger.info("zm.wl.bse" /* WSSLINK_BINDSOCKETEVENT */ + ' open');
            // this.urlIndex = 0;
            _this.resetConnect();
            // this.retryLinkHandler.stopMaxTime();
            // this.retryLinkHandler.invalid();
            _this.connectRsp.suc && _this.connectRsp.suc();
            _this.onConnectedEvent && _this.onConnectedEvent(true);
            _this.netLinkState = zego_entity_1.ENUM_CONNECT_STATE.connected;
        });
        this.closeHandler(function (err) {
            _this.logger.warn("zm.wl.bse" /* WSSLINK_BINDSOCKETEVENT */ + ' close ' + JSON.stringify(err));
            _this.resetConnect();
            // this.reconnect();
            _this.connectRsp.fail && _this.connectRsp.fail();
            _this.onDisConnectedEvent && _this.onDisConnectedEvent(true);
            _this.netLinkState = zego_entity_1.ENUM_CONNECT_STATE.disconnect;
        });
        this.errorHandler(function (err) {
            _this.logger.warn("zm.wl.bse" /* WSSLINK_BINDSOCKETEVENT */ + ' error ' + JSON.stringify(err));
            _this.resetConnect();
            // this.reconnect();
            _this.connectRsp.fail && _this.connectRsp.fail();
            _this.onDisConnectedEvent && _this.onDisConnectedEvent(true);
            _this.netLinkState = zego_entity_1.ENUM_CONNECT_STATE.disconnect;
        });
        this.onMessage();
    };
    // reconnect(): void {
    //     // TODO 
    //     this.closeSocket();
    //     this.resetConnect();
    //     if (this.networkState === NetWorkState.online) {
    //         // this.urlIndex = (this.urlIndex + 1) % this.servers.length;
    //         this.connectSocket();
    //     }
    // }
    ZegoWssLink.prototype.closeSocket = function () {
        this.logger.info("zm.wl.cs.1" /* WSSLINK_CLOSESOCKET */ + ' call');
        this.socketService.closeSocket();
        this.netLinkState = zego_entity_1.ENUM_CONNECT_STATE.disconnect;
    };
    ZegoWssLink.prototype.resetConnect = function () {
        if (this.connectTimer) {
            clearTimeout(this.connectTimer);
            this.connectTimer = null;
        }
    };
    ZegoWssLink.prototype.isConnect = function () {
        return this.netLinkState === zego_entity_1.ENUM_CONNECT_STATE.connected;
    };
    // websocket state
    ZegoWssLink.prototype.isDisConnect = function () {
        return !this.socketService || this.socketService.isDisConnect();
    };
    ZegoWssLink.prototype.closeHandler = function (handler) {
        this.socketService.closeHandler(handler);
    };
    ZegoWssLink.prototype.openHandler = function (handler) {
        this.socketService.openHandler(handler);
    };
    ZegoWssLink.prototype.errorHandler = function (handler) {
        this.socketService.errorHandler(handler);
    };
    ZegoWssLink.prototype.sendMessage = function (type, streamID, body, isFirst, success, error, ackFunc) {
        if (isFirst === void 0) { isFirst = true; }
        if (success === void 0) { success = null; }
        if (error === void 0) { error = null; }
        if (ackFunc === void 0) { ackFunc = null; }
        this.txid++;
        var commonBody = {
            appid: this.appID,
            biz_type: 0,
            // mode: NET_ACCESS_CONFIG.mode,
            mode_no: net_config_1.NET_ACCESS_CONFIG.modeNo,
            // TODO
            id_name: this.stateCenter.idName,
            sdk_type: net_config_1.NET_ACCESS_CONFIG.sdkType,
            zegoconn_run_env: this.env === 0 ? AccessHubDefine_1.ZegoconnRunEnv.ZEGOCONN_RUN_ENV_BROWSER : AccessHubDefine_1.ZegoconnRunEnv.ZEGOCONN_RUN_ENV_APPLET
        };
        // const common = isFirst ? commonBody : {};
        var reqBody = __assign(__assign({ txid: this.txid }, commonBody), body);
        var requestData = {
            data: reqBody,
            txid: this.txid,
            sendTime: Date.now(),
            timeOut: this.timeout,
            ack: body.ack,
            success: success,
            error: error,
            ackFunc: ackFunc,
        };
        var requestNode = this.sendCommandList.push(requestData);
        this.sendCommandMap[this.txid] = requestNode;
        if (!this.unUpdateMsgTimeTypes.includes(type)) {
            this.updateMsgTime = Date.now();
        }
        this.logger.warn("zm.wl.sm" /* WSSLINK_SENDMESSAGE */ +
            ' type: ' +
            type +
            ' streamID: ' +
            streamID +
            ' txid: ' +
            this.txid);
        // console.error('reqBody', JSON.stringify(reqBody));
        var uint8 = this.protobuf.encodeRequest(type, reqBody, streamID);
        this.socketService.sendMessage(uint8);
    };
    ZegoWssLink.prototype.onMessage = function () {
        var _this = this;
        this.socketService.onMessage = function (msg) {
            var _a, _b, _c;
            var uint8 = new Uint8Array(msg);
            var _d = _this.protobuf.decodeResponse(uint8), streamID = _d[0], msgType = _d[1], body = _d[2];
            if (!_this.unUpdateMsgTimeTypes.includes(msgType)) {
                _this.updateMsgTime = Date.now();
            }
            _this.logger.warn("zm.wl.om" /* WSSLINK_ONMESSAGE */ + (" streamID: " + streamID + ", msgType: " + msgType + "}"));
            if (((body === null || body === void 0 ? void 0 : body.txid) || ((_a = body === null || body === void 0 ? void 0 : body.data) === null || _a === void 0 ? void 0 : _a.txid)) && _this.isRspMsg((body === null || body === void 0 ? void 0 : body.txid) || ((_b = body === null || body === void 0 ? void 0 : body.data) === null || _b === void 0 ? void 0 : _b.txid))) {
                _this.handleSendCommandMsgRsp(streamID, msgType, (body === null || body === void 0 ? void 0 : body.txid) || ((_c = body === null || body === void 0 ? void 0 : body.data) === null || _c === void 0 ? void 0 : _c.txid), body);
            }
            else {
                _this.onPushEvent(streamID, msgType, body);
            }
        };
    };
    ZegoWssLink.prototype.isRspMsg = function (txid) {
        return this.sendCommandMap[txid] !== undefined;
    };
    // ,
    ZegoWssLink.prototype.startCheck = function () {
        var _this = this;
        this.checkMessageListTimeout(this.sendCommandList, this.sendCommandMap);
        this.sendDataCheckTimer = setTimeout(function () {
            _this.startCheck();
        }, this.sendDataCheckInterval);
    };
    // 
    ZegoWssLink.prototype.stopCheck = function () {
        this.checkSendMessageList(this.sendCommandList);
        clearTimeout(this.sendDataCheckTimer);
    };
    // ,
    ZegoWssLink.prototype.checkMessageListTimeout = function (messageList, messageMap) {
        var head = messageList.getFirst();
        var timestamp = Date.now();
        var checkCount = 0;
        var timeoutMsgCount = 0;
        var dropMsgCount = 0;
        while (head != null) {
            //  
            if (head._data && head._data.sendTime + head._data.timeOut > timestamp) {
                break;
            }
            //  ,
            head._data && delete messageMap[head._data.data.txid];
            messageList.remove(head);
            ++timeoutMsgCount;
            //  ,
            if ((head._data && head._data.error == null) ||
                (head._data && head._data.sendTime + this.sendDataDropTimeout < timestamp)) {
                ++dropMsgCount;
            }
            else {
                setTimeout(function () {
                    head &&
                        head._data &&
                        head._data.error &&
                        // TODO
                        head._data.error({}, head._data.data.txid, zego_externalError_1.errorCodeList.TIMEOUT);
                }, 0);
            }
            ++checkCount;
            if (checkCount >= this.sendDataCheckOnceCount) {
                break;
            }
            head = messageList.getFirst();
        }
        // if (timeoutMsgCount != 0 || dropMsgCount != 0) {
        //     console.error('zb.hb.cmt call success, stat: timeout=', timeoutMsgCount + '', 'drop=', dropMsgCount + '');
        // }
    };
    // 
    ZegoWssLink.prototype.checkSendMessageList = function (messageList) {
        var head = messageList.getFirst();
        while (head != null) {
            messageList.remove(head);
            if (head._data && head._data.error) {
                setTimeout(function () {
                    head &&
                        head._data &&
                        head._data.error &&
                        head._data.error({}, head._data.data.txid, zego_externalError_1.errorCodeList.TIMEOUT);
                }, 0);
            }
            head = messageList.getFirst();
        }
    };
    ZegoWssLink.prototype.handleSendCommandMsgRsp = function (streamID, msgType, txid, body) {
        var sendDataNode = this.sendCommandMap[txid];
        if (sendDataNode != null) {
            var sendData = sendDataNode._data;
            if (!(sendData === null || sendData === void 0 ? void 0 : sendData.ack)) {
                delete this.sendCommandMap[txid];
                this.sendCommandList.remove(sendDataNode);
            }
            // TODO 
            if (body.code && body.code !== 0) {
                sendData && sendData.error != null && sendData.error(body, txid);
            }
            else {
                if (msgType === AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HTTP_REQUEST_ACK) {
                    sendData && sendData.ackFunc != null && sendData.ackFunc(body, txid);
                }
                else {
                    sendData && sendData.success != null && sendData.success(body, txid);
                }
            }
        }
    };
    return ZegoWssLink;
}(ZegoLink_1.ZegoLink));
exports.ZegoWssLink = ZegoWssLink;


/***/ }),

/***/ "./sdk/src/modules/net/index.ts":
/*!**************************************!*\
  !*** ./sdk/src/modules/net/index.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_610633__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NET_ACCESS_CONFIG = exports.BusinessService = exports.NetAgentHttpRequest = exports.NetAgentPCRequest = exports.NetAgentConnect = void 0;
var AccessHubDefine_1 = __nested_webpack_require_610633__(/*! ./entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
Object.defineProperty(exports, "BusinessService", { enumerable: true, get: function () { return AccessHubDefine_1.BusinessService; } });
var NetAgentConnect_1 = __nested_webpack_require_610633__(/*! ./impl/NetAgentConnect */ "./sdk/src/modules/net/impl/NetAgentConnect.ts");
Object.defineProperty(exports, "NetAgentConnect", { enumerable: true, get: function () { return NetAgentConnect_1.NetAgentConnect; } });
var NetAgentHttpRequest_1 = __nested_webpack_require_610633__(/*! ./impl/NetAgentHttpRequest */ "./sdk/src/modules/net/impl/NetAgentHttpRequest.ts");
Object.defineProperty(exports, "NetAgentHttpRequest", { enumerable: true, get: function () { return NetAgentHttpRequest_1.NetAgentHttpRequest; } });
var NetAgentPCRequest_1 = __nested_webpack_require_610633__(/*! ./impl/NetAgentPCRequest */ "./sdk/src/modules/net/impl/NetAgentPCRequest.ts");
Object.defineProperty(exports, "NetAgentPCRequest", { enumerable: true, get: function () { return NetAgentPCRequest_1.NetAgentPCRequest; } });
var net_config_1 = __nested_webpack_require_610633__(/*! ./net.config */ "./sdk/src/modules/net/net.config.ts");
Object.defineProperty(exports, "NET_ACCESS_CONFIG", { enumerable: true, get: function () { return net_config_1.NET_ACCESS_CONFIG; } });


/***/ }),

/***/ "./sdk/src/modules/net/net.config.ts":
/*!*******************************************!*\
  !*** ./sdk/src/modules/net/net.config.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_612468__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.APP_CONFIG_KEY = exports.NET_ACCESS_SERVERS = exports.NET_ACCESS_CONFIG = void 0;
var AccessHubDefine_1 = __nested_webpack_require_612468__(/*! ./entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
exports.NET_ACCESS_CONFIG = {
    // serverUrls: ['wss://access-wss-alpha.zego.im/accesshub'],
    domains: ['access-wss-alpha.zego.im'],
    mode: 'online',
    modeNo: AccessHubDefine_1.Mode.MODE_ONLINE,
    sdkType: 3,
    connectVer: 1,
    pcEstablishTimeout: 15,
    scheme: 'wss',
    location: 'accesshub',
    wssMessageType: 1,
};
exports.NET_ACCESS_SERVERS = 'z_net_access_servers';
exports.APP_CONFIG_KEY = 'z_appconfig';


/***/ }),

/***/ "./sdk/src/modules/net/protocol/AccessHubProtoBuf.ts":
/*!***********************************************************!*\
  !*** ./sdk/src/modules/net/protocol/AccessHubProtoBuf.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_613554__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccessHubProtoBuf = void 0;
var long_1 = __importDefault(__nested_webpack_require_613554__(/*! long */ "./node_modules/long/src/long.js"));
var $protobuf = __importStar(__nested_webpack_require_613554__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js"));
var AccessHubDefine_1 = __nested_webpack_require_613554__(/*! ../entity/AccessHubDefine */ "./sdk/src/modules/net/entity/AccessHubDefine.ts");
// @ts-ignore
var protocol_js_1 = __importDefault(__nested_webpack_require_613554__(/*! ./protocol.js */ "./sdk/src/modules/net/protocol/protocol.js"));
$protobuf.util.Long = long_1.default;
$protobuf.configure();
var AccessHubProtoBuf = /** @class */ (function () {
    function AccessHubProtoBuf() {
        var _a;
        this.protoInstance = protocol_js_1.default;
        this.protoMap = (_a = {},
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_STREAM_CLOSED] = ['proto_accesshub', 'ConnectionClosed'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_CLOSE_CONNECTION] = ['proto_accesshub', 'CloseConnection'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HTTP_REQUEST] = ['proto_accesshub', 'HTTPRequest'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HTTP_RESPONSE] = ['proto_accesshub', 'HTTPResponse'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HB_REQUEST] = ['proto_accesshub', 'HBRequest'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HB_RESPONSE] = ['proto_accesshub', 'HBResponse'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_GET_CONFIG_REQUEST] = ['proto_accesshub', 'GetConfigRequest'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_GET_CONFIG_RESPONSE] = ['proto_accesshub', 'GetConfigResponse'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_HTTP_REQUEST_ACK] = ['proto_accesshub', 'HBResponse'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_UPWARD_MESSAGE] = ['proto_accesshub', 'PCUpwardMessage'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_UPWARD_MESSAGE_ACK] = ['proto_accesshub', 'PCUpwardMessageAck'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_ESTABLISHED] = ['proto_accesshub', 'PCEstablished'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_BROKEN] = ['proto_accesshub', 'PCBroken'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PC_DOWNWARD_MESSAGE] = ['proto_accesshub', 'PCDownwardMessage'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_REDIRECT] = ['proto_accesshub', 'Redirect'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_GET_APPCONFIG_REQUEST] = ['proto_accesshub', 'GetAppConfigRequest'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_GET_APPCONFIG_RESPONSE] = ['proto_accesshub', 'GetAppConfigResponse'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_PUSH_APPCONFIG] = ['proto_accesshub', 'PushAppConfig'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_ACCESSHUB_DISPATCH_REQUEST] = ['proto_accesshub', 'AccesshubDispatchRequest'],
            _a[AccessHubDefine_1.AccessHubMessageType.MSG_TYPE_ACCESSHUB_DISPATCH_RESPONSE] = ['proto_accesshub', 'AccesshubDispatchResponse'],
            _a);
    }
    AccessHubProtoBuf.prototype.encodeRequest = function (msgType, body, streamID) {
        var _a = this.protoMap[msgType], nameSpace = _a[0], bean = _a[1];
        var uint8_body = this.encode(this.protoInstance[nameSpace][bean], body);
        var len_body = uint8_body.length;
        // 0xAF(1)+ ver(1)+type(2)+bodyLen(4)+streamID(4)+flags(1)+body
        var uint8 = new Uint8Array(1 + 1 + 2 + 4 + 4 + 1 + len_body);
        uint8[0] = 0xaf;
        uint8[1] = 0;
        uint8[2] = msgType >> 8;
        uint8[3] = msgType - (uint8[2] << 8);
        uint8.set(new Uint8Array(Int32Array.from([len_body]).buffer).reverse(), 4); // bodyLen
        uint8.set(new Uint8Array(Int32Array.from([streamID]).buffer).reverse(), 8); // streamID
        uint8[12] = 0;
        uint8.set(uint8_body, 13);
        return uint8;
    };
    AccessHubProtoBuf.prototype.decodeResponse = function (uint8) {
        var msgType = (uint8[2] << 8) + uint8[3];
        var dataView = new DataView(uint8.buffer);
        // const len_body = dataView.getUint32(4);
        var streamID = dataView.getUint32(8);
        var uint8_body = uint8.slice(13);
        try {
            var _a = this.protoMap[msgType], namespace = _a[0], bean = _a[1];
            var body = this.decode(this.protoInstance[namespace][bean], uint8_body);
            return [streamID, msgType, body];
        }
        catch (error) {
            // TODO
            return [streamID, msgType, { code: 1 }];
        }
    };
    AccessHubProtoBuf.prototype.decodeConfigMessage = function (buffer) {
        var config = this.decode(this.protoInstance.proto_initconfig.InitConfig, buffer);
        return config;
    };
    AccessHubProtoBuf.prototype.encode = function (instance, payload) {
        return instance.encode(new instance(payload)).finish();
    };
    AccessHubProtoBuf.prototype.decode = function (instance, buffer) {
        return __assign({}, instance.decode(buffer));
    };
    return AccessHubProtoBuf;
}());
exports.AccessHubProtoBuf = AccessHubProtoBuf;


/***/ }),

/***/ "./sdk/src/modules/net/protocol/protocol.js":
/*!**************************************************!*\
  !*** ./sdk/src/modules/net/protocol/protocol.js ***!
  \**************************************************/
/*! exports provided: proto_accesshub, proto_initconfig, default */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_620691__) {

"use strict";
__nested_webpack_require_620691__.r(__webpack_exports__);
/* harmony export (binding) */ __nested_webpack_require_620691__.d(__webpack_exports__, "proto_accesshub", function() { return proto_accesshub; });
/* harmony export (binding) */ __nested_webpack_require_620691__.d(__webpack_exports__, "proto_initconfig", function() { return proto_initconfig; });
/* harmony export (binding) */ __nested_webpack_require_620691__.d(__webpack_exports__, "default", function() { return $root; });
/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_620691__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");
/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_620691__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/


const $Reader = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__["Reader"], $Writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__["Writer"], $util = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__["util"];

const $root = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__["roots"]["default"] || (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__["roots"]["default"] = {});

const proto_accesshub = $root.proto_accesshub = (() => {

    const proto_accesshub = {};

    proto_accesshub.MessageType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MSG_TYPE_EMPTY"] = 0;
        values[valuesById[1] = "MSG_TYPE_CONNECTION_CLOSED"] = 1;
        values[valuesById[2] = "MSG_TYPE_STREAM_CLOSED"] = 2;
        values[valuesById[3] = "MSG_TYPE_CLOSE_CONNECTION"] = 3;
        values[valuesById[4] = "MSG_TYPE_HTTP_REQUEST"] = 4;
        values[valuesById[5] = "MSG_TYPE_HTTP_RESPONSE"] = 5;
        values[valuesById[6] = "MSG_TYPE_HTTP_REQUEST_DROPED"] = 6;
        values[valuesById[7] = "MSG_TYPE_PROXY_CONNECT"] = 7;
        values[valuesById[8] = "MSG_TYPE_PROXY_CONNECTED"] = 8;
        values[valuesById[9] = "MSG_TYPE_PROXY_CONNECTION_CLOSED"] = 9;
        values[valuesById[10] = "MSG_TYPE_PROXY_SEND_DATA"] = 10;
        values[valuesById[11] = "MSG_TYPE_PROXY_RECV_DATA"] = 11;
        values[valuesById[12] = "MSG_TYPE_HB_REQUEST"] = 12;
        values[valuesById[13] = "MSG_TYPE_HB_RESPONSE"] = 13;
        values[valuesById[14] = "MSG_TYPE_GET_CONFIG_REQUEST"] = 14;
        values[valuesById[15] = "MSG_TYPE_GET_CONFIG_RESPONSE"] = 15;
        values[valuesById[16] = "MSG_TYPE_HTTP_REQUEST_ACK"] = 16;
        values[valuesById[17] = "MSG_TYPE_PC_UPWARD_MESSAGE"] = 17;
        values[valuesById[18] = "MSG_TYPE_PC_UPWARD_MESSAGE_ACK"] = 18;
        values[valuesById[19] = "MSG_TYPE_PC_ESTABLISHED"] = 19;
        values[valuesById[20] = "MSG_TYPE_PC_BROKEN"] = 20;
        values[valuesById[21] = "MSG_TYPE_PC_DOWNWARD_MESSAGE"] = 21;
        values[valuesById[22] = "MSG_TYPE_REDIRECT"] = 22;
        values[valuesById[23] = "MSG_TYPE_GET_APPCONFIG_REQUEST"] = 23;
        values[valuesById[24] = "MSG_TYPE_GET_APPCONFIG_RESPONSE"] = 24;
        values[valuesById[25] = "MSG_TYPE_PUSH_APPCONFIG"] = 25;
        values[valuesById[26] = "MSG_TYPE_ACCESSHUB_DISPATCH_REQUEST"] = 26;
        values[valuesById[27] = "MSG_TYPE_ACCESSHUB_DISPATCH_RESPONSE"] = 27;
        values[valuesById[28] = "MSG_TYPE_GET_IM_CONFIG_REQUEST"] = 28;
        values[valuesById[29] = "MSG_TYPE_GET_IM_CONFIG_RESPONSE"] = 29;
        values[valuesById[50] = "MSG_TYPE_UA_DISPATCH_REQUEST"] = 50;
        values[valuesById[51] = "MSG_TYPE_UA_DISPATCH_RESPONSE"] = 51;
        values[valuesById[52] = "MSG_TYPE_UA_ECHO_REQUEST"] = 52;
        values[valuesById[53] = "MSG_TYPE_UA_ECHO_RESPONSE"] = 53;
        values[valuesById[100] = "MSG_TYPE_NODE_REGISTER_REQUEST"] = 100;
        values[valuesById[101] = "MSG_TYPE_NODE_REGISTER_RESPONSE"] = 101;
        values[valuesById[102] = "MSG_TYPE_NODE_HB_REQUEST"] = 102;
        values[valuesById[103] = "MSG_TYPE_NODE_HB_RESPONSE"] = 103;
        return values;
    })();

    proto_accesshub.ErrorCode = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OK"] = 0;
        values[valuesById[10000] = "DISPATCH_NO_AVAILABLE_NODE"] = 10000;
        values[valuesById[10001] = "DISPATCH_INTERNAL_ERROR"] = 10001;
        values[valuesById[10002] = "DISPATCH_INVALID_FRAME"] = 10002;
        values[valuesById[10003] = "DISPATCH_UNMARSHAL"] = 10003;
        values[valuesById[10004] = "DISPATCH_MSGTYPE"] = 10004;
        values[valuesById[10005] = "DISPATCH_MARSHAL"] = 10005;
        values[valuesById[10006] = "DISPATCH_TOO_FREQUENTLY"] = 10006;
        values[valuesById[20000] = "ACCESSHUB_INVALID_FRAME"] = 20000;
        values[valuesById[20001] = "ACCESSHUB_NEED_ENCRYPT"] = 20001;
        values[valuesById[20002] = "ACCESSHUB_DECRYPT"] = 20002;
        values[valuesById[20003] = "ACCESSHUB_MSGTYPE"] = 20003;
        values[valuesById[20004] = "ACCESSHUB_UNMARSHAL"] = 20004;
        values[valuesById[20005] = "ACCESSHUB_TIMEOUT"] = 20005;
        values[valuesById[20006] = "ACCESSHUB_CONNECT"] = 20006;
        values[valuesById[20007] = "ACCESSHUB_BROKEN"] = 20007;
        values[valuesById[20008] = "ACCESSHUB_INTERNAL_ERROR"] = 20008;
        values[valuesById[20009] = "ACCESSHUB_MARSHAL"] = 20009;
        values[valuesById[20010] = "ACCESSHUB_UNSUPPORTED_SERVICE"] = 20010;
        values[valuesById[20011] = "ACCESSHUB_TOO_FREQUENTLY"] = 20011;
        values[valuesById[20012] = "ACCESSHUB_INVALID_APPID"] = 20012;
        values[valuesById[20013] = "ACCESSHUB_HB_TIMEOUT"] = 20013;
        values[valuesById[20014] = "ACCESSHUB_INVALID_SIGNATURE"] = 20014;
        values[valuesById[20015] = "ACCESSHUB_AUTH_FAILED"] = 20015;
        values[valuesById[30000] = "ACCESSHUB_GET_STREAM_FAILED"] = 30000;
        values[valuesById[30001] = "ACCESSHUB_GET_CONN_FAILED"] = 30001;
        values[valuesById[30002] = "ACCESSHUB_DO_HTTP_REQUEST_FAILED"] = 30002;
        values[valuesById[30003] = "ACCESSHUB_UNMARSHAL_HB_FAILED"] = 30003;
        values[valuesById[30004] = "ACCESSHUB_DO_BACKEND_DISPATCH_FAILED"] = 30004;
        return values;
    })();

    proto_accesshub.Mode = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Mode_UNSET"] = 0;
        values[valuesById[1] = "MODE_ONLINE"] = 1;
        values[valuesById[2] = "MODE_TEST"] = 2;
        values[valuesById[3] = "MODE_ALPHA"] = 3;
        return values;
    })();

    proto_accesshub.Service = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SERVICE_UNSET"] = 0;
        values[valuesById[1] = "SERVICE_MEDIAGW"] = 1;
        values[valuesById[2] = "SERVICE_LIVEROOM"] = 2;
        values[valuesById[3] = "SERVICE_MIX"] = 3;
        values[valuesById[4] = "SERVICE_ZEUS"] = 4;
        values[valuesById[5] = "SERVICE_ZPUSH"] = 5;
        values[valuesById[6] = "SERVICE_L3"] = 6;
        values[valuesById[7] = "SERVICE_TALKLINE"] = 7;
        values[valuesById[8] = "SERVICE_EDUSUITE"] = 8;
        values[valuesById[9] = "SERVICE_ZIM"] = 9;
        values[valuesById[10] = "SERVICE_ClOUD_SETTING"] = 10;
        values[valuesById[11] = "SERVICE_ZEUSHB"] = 11;
        values[valuesById[12] = "SERVICE_USER_LOGIC"] = 12;
        values[valuesById[13] = "SERVICE_UNIFYDISPATCH"] = 13;
        values[valuesById[14] = "SERVICE_QUALITY"] = 14;
        values[valuesById[15] = "SERVICE_SECURITY"] = 15;
        values[valuesById[16] = "SERVICE_KTVCPR"] = 16;
        values[valuesById[17] = "SERVICE_SWITCH4LIVEROOM"] = 17;
        values[valuesById[18] = "SERVICE_WEBRTC_SIGNAL"] = 18;
        values[valuesById[19] = "SERVICE_L3_WEBRTC_SIGNAL"] = 19;
        return values;
    })();

    proto_accesshub.Method = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "METHOD_UNSET"] = 0;
        values[valuesById[1] = "METHOD_GET"] = 1;
        values[valuesById[2] = "METHOD_POST"] = 2;
        return values;
    })();

    proto_accesshub.SdkType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SDK_TYPE_UNSET"] = 0;
        values[valuesById[1] = "SDK_TYPE_QUIC_MTCP_NATIVE"] = 1;
        values[valuesById[2] = "SDK_TYPE_WSS_NATIVE"] = 2;
        values[valuesById[3] = "SDK_TYPE_WSS_WEB"] = 3;
        return values;
    })();

    proto_accesshub.ZegoconnRunEnv = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ZEGOCONN_RUN_ENV_UNSET"] = 0;
        values[valuesById[1] = "ZEGOCONN_RUN_ENV_BROWSER"] = 1;
        values[valuesById[2] = "ZEGOCONN_RUN_ENV_APPLET"] = 2;
        return values;
    })();

    proto_accesshub.ConnectionClosed = (function() {

        function ConnectionClosed(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        ConnectionClosed.prototype.code = 0;
        ConnectionClosed.prototype.msg = "";

        ConnectionClosed.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(8).int32(message.code);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(18).string(message.msg);
            return writer;
        };

        ConnectionClosed.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.ConnectionClosed();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.int32();
                    break;
                case 2:
                    message.msg = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ConnectionClosed;
    })();

    proto_accesshub.StreamClosed = (function() {

        function StreamClosed(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        StreamClosed.prototype.code = 0;
        StreamClosed.prototype.msg = "";

        StreamClosed.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(8).int32(message.code);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(18).string(message.msg);
            return writer;
        };

        StreamClosed.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.StreamClosed();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.int32();
                    break;
                case 2:
                    message.msg = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StreamClosed;
    })();

    proto_accesshub.CloseConnection = (function() {

        function CloseConnection(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        CloseConnection.prototype.reason = 0;
        CloseConnection.prototype.msg = "";
        CloseConnection.prototype.action = 0;

        CloseConnection.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(8).int32(message.reason);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(18).string(message.msg);
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(24).int32(message.action);
            return writer;
        };

        CloseConnection.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.CloseConnection();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reason = reader.int32();
                    break;
                case 2:
                    message.msg = reader.string();
                    break;
                case 3:
                    message.action = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        CloseConnection.Action = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ACTION_RESERVED"] = 0;
            values[valuesById[1] = "ACTION_DISPATCH"] = 1;
            values[valuesById[2] = "ACTION_RETRY"] = 2;
            values[valuesById[3] = "ACTION_NEXT_NODE"] = 3;
            values[valuesById[4] = "ACTION_ABORT"] = 4;
            values[valuesById[5] = "ACTION_NEXT_GROUP"] = 5;
            return values;
        })();

        return CloseConnection;
    })();

    proto_accesshub.HTTPRequest = (function() {

        function HTTPRequest(properties) {
            this.headers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        HTTPRequest.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        HTTPRequest.prototype.appid = 0;
        HTTPRequest.prototype.biz_type = 0;
        HTTPRequest.prototype.mode = "";
        HTTPRequest.prototype.id_name = "";
        HTTPRequest.prototype.reqid = "";
        HTTPRequest.prototype.stick = "";
        HTTPRequest.prototype.service = "";
        HTTPRequest.prototype.location = "";
        HTTPRequest.prototype.method = "";
        HTTPRequest.prototype.headers = $util.emptyArray;
        HTTPRequest.prototype.body = $util.newBuffer([]);
        HTTPRequest.prototype.ack = false;
        HTTPRequest.prototype.mode_no = 0;
        HTTPRequest.prototype.service_no = 0;
        HTTPRequest.prototype.method_no = 0;
        HTTPRequest.prototype.sdk_type = 0;
        HTTPRequest.prototype.zegoconn_run_env = 0;

        HTTPRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.appid != null && Object.hasOwnProperty.call(message, "appid"))
                writer.uint32(16).uint32(message.appid);
            if (message.biz_type != null && Object.hasOwnProperty.call(message, "biz_type"))
                writer.uint32(24).uint32(message.biz_type);
            if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                writer.uint32(34).string(message.mode);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(42).string(message.id_name);
            if (message.reqid != null && Object.hasOwnProperty.call(message, "reqid"))
                writer.uint32(50).string(message.reqid);
            if (message.stick != null && Object.hasOwnProperty.call(message, "stick"))
                writer.uint32(58).string(message.stick);
            if (message.service != null && Object.hasOwnProperty.call(message, "service"))
                writer.uint32(66).string(message.service);
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                writer.uint32(74).string(message.location);
            if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                writer.uint32(82).string(message.method);
            if (message.headers != null && message.headers.length)
                for (let i = 0; i < message.headers.length; ++i)
                    $root.proto_accesshub.HTTPRequest.HTTPHeader.encode(message.headers[i], writer.uint32(90).fork()).ldelim();
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(98).bytes(message.body);
            if (message.ack != null && Object.hasOwnProperty.call(message, "ack"))
                writer.uint32(104).bool(message.ack);
            if (message.mode_no != null && Object.hasOwnProperty.call(message, "mode_no"))
                writer.uint32(112).int32(message.mode_no);
            if (message.service_no != null && Object.hasOwnProperty.call(message, "service_no"))
                writer.uint32(120).int32(message.service_no);
            if (message.method_no != null && Object.hasOwnProperty.call(message, "method_no"))
                writer.uint32(128).int32(message.method_no);
            if (message.sdk_type != null && Object.hasOwnProperty.call(message, "sdk_type"))
                writer.uint32(136).int32(message.sdk_type);
            if (message.zegoconn_run_env != null && Object.hasOwnProperty.call(message, "zegoconn_run_env"))
                writer.uint32(144).int32(message.zegoconn_run_env);
            return writer;
        };

        HTTPRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.HTTPRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.appid = reader.uint32();
                    break;
                case 3:
                    message.biz_type = reader.uint32();
                    break;
                case 4:
                    message.mode = reader.string();
                    break;
                case 5:
                    message.id_name = reader.string();
                    break;
                case 6:
                    message.reqid = reader.string();
                    break;
                case 7:
                    message.stick = reader.string();
                    break;
                case 8:
                    message.service = reader.string();
                    break;
                case 9:
                    message.location = reader.string();
                    break;
                case 10:
                    message.method = reader.string();
                    break;
                case 11:
                    if (!(message.headers && message.headers.length))
                        message.headers = [];
                    message.headers.push($root.proto_accesshub.HTTPRequest.HTTPHeader.decode(reader, reader.uint32()));
                    break;
                case 12:
                    message.body = reader.bytes();
                    break;
                case 13:
                    message.ack = reader.bool();
                    break;
                case 14:
                    message.mode_no = reader.int32();
                    break;
                case 15:
                    message.service_no = reader.int32();
                    break;
                case 16:
                    message.method_no = reader.int32();
                    break;
                case 17:
                    message.sdk_type = reader.int32();
                    break;
                case 18:
                    message.zegoconn_run_env = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        HTTPRequest.HTTPHeader = (function() {

            function HTTPHeader(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            HTTPHeader.prototype.name = "";
            HTTPHeader.prototype.val = "";

            HTTPHeader.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(10).string(message.name);
                if (message.val != null && Object.hasOwnProperty.call(message, "val"))
                    writer.uint32(18).string(message.val);
                return writer;
            };

            HTTPHeader.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.HTTPRequest.HTTPHeader();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.val = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            return HTTPHeader;
        })();

        return HTTPRequest;
    })();

    proto_accesshub.HTTPResponse = (function() {

        function HTTPResponse(properties) {
            this.headers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        HTTPResponse.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        HTTPResponse.prototype.headers = $util.emptyArray;
        HTTPResponse.prototype.status_code = 0;
        HTTPResponse.prototype.body = $util.newBuffer([]);

        HTTPResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.headers != null && message.headers.length)
                for (let i = 0; i < message.headers.length; ++i)
                    $root.proto_accesshub.HTTPRequest.HTTPHeader.encode(message.headers[i], writer.uint32(18).fork()).ldelim();
            if (message.status_code != null && Object.hasOwnProperty.call(message, "status_code"))
                writer.uint32(24).int32(message.status_code);
            if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                writer.uint32(34).bytes(message.body);
            return writer;
        };

        HTTPResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.HTTPResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    if (!(message.headers && message.headers.length))
                        message.headers = [];
                    message.headers.push($root.proto_accesshub.HTTPRequest.HTTPHeader.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.status_code = reader.int32();
                    break;
                case 4:
                    message.body = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return HTTPResponse;
    })();

    proto_accesshub.HTTPRequestAck = (function() {

        function HTTPRequestAck(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        HTTPRequestAck.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        HTTPRequestAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            return writer;
        };

        HTTPRequestAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.HTTPRequestAck();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return HTTPRequestAck;
    })();

    proto_accesshub.HTTPRequestDroped = (function() {

        function HTTPRequestDroped(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        HTTPRequestDroped.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        HTTPRequestDroped.prototype.reason = 0;
        HTTPRequestDroped.prototype.msg = "";

        HTTPRequestDroped.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(16).int32(message.reason);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(26).string(message.msg);
            return writer;
        };

        HTTPRequestDroped.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.HTTPRequestDroped();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                case 3:
                    message.msg = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return HTTPRequestDroped;
    })();

    proto_accesshub.ProxyConnect = (function() {

        function ProxyConnect(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        ProxyConnect.prototype.appid = 0;
        ProxyConnect.prototype.biz_type = 0;
        ProxyConnect.prototype.mode = "";
        ProxyConnect.prototype.id_name = "";
        ProxyConnect.prototype.reqid = "";
        ProxyConnect.prototype.stick = "";
        ProxyConnect.prototype.service = "";
        ProxyConnect.prototype.dest = "";

        ProxyConnect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.appid != null && Object.hasOwnProperty.call(message, "appid"))
                writer.uint32(8).uint32(message.appid);
            if (message.biz_type != null && Object.hasOwnProperty.call(message, "biz_type"))
                writer.uint32(16).uint32(message.biz_type);
            if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                writer.uint32(26).string(message.mode);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(34).string(message.id_name);
            if (message.reqid != null && Object.hasOwnProperty.call(message, "reqid"))
                writer.uint32(42).string(message.reqid);
            if (message.stick != null && Object.hasOwnProperty.call(message, "stick"))
                writer.uint32(50).string(message.stick);
            if (message.service != null && Object.hasOwnProperty.call(message, "service"))
                writer.uint32(58).string(message.service);
            if (message.dest != null && Object.hasOwnProperty.call(message, "dest"))
                writer.uint32(66).string(message.dest);
            return writer;
        };

        ProxyConnect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.ProxyConnect();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.appid = reader.uint32();
                    break;
                case 2:
                    message.biz_type = reader.uint32();
                    break;
                case 3:
                    message.mode = reader.string();
                    break;
                case 4:
                    message.id_name = reader.string();
                    break;
                case 5:
                    message.reqid = reader.string();
                    break;
                case 6:
                    message.stick = reader.string();
                    break;
                case 7:
                    message.service = reader.string();
                    break;
                case 8:
                    message.dest = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ProxyConnect;
    })();

    proto_accesshub.ProxyConnected = (function() {

        function ProxyConnected(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        ProxyConnected.prototype.trycount = 0;
        ProxyConnected.prototype.elapse = 0;

        ProxyConnected.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trycount != null && Object.hasOwnProperty.call(message, "trycount"))
                writer.uint32(8).uint32(message.trycount);
            if (message.elapse != null && Object.hasOwnProperty.call(message, "elapse"))
                writer.uint32(16).uint32(message.elapse);
            return writer;
        };

        ProxyConnected.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.ProxyConnected();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trycount = reader.uint32();
                    break;
                case 2:
                    message.elapse = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ProxyConnected;
    })();

    proto_accesshub.ProxyConnectionClosed = (function() {

        function ProxyConnectionClosed(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        ProxyConnectionClosed.prototype.code = 0;
        ProxyConnectionClosed.prototype.msg = "";
        ProxyConnectionClosed.prototype.connected = 0;

        ProxyConnectionClosed.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(8).int32(message.code);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(18).string(message.msg);
            if (message.connected != null && Object.hasOwnProperty.call(message, "connected"))
                writer.uint32(24).int32(message.connected);
            return writer;
        };

        ProxyConnectionClosed.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.ProxyConnectionClosed();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.int32();
                    break;
                case 2:
                    message.msg = reader.string();
                    break;
                case 3:
                    message.connected = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ProxyConnectionClosed;
    })();

    proto_accesshub.ProxySendData = (function() {

        function ProxySendData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        ProxySendData.prototype.data = $util.newBuffer([]);

        ProxySendData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(10).bytes(message.data);
            return writer;
        };

        ProxySendData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.ProxySendData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ProxySendData;
    })();

    proto_accesshub.ProxyRecvData = (function() {

        function ProxyRecvData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        ProxyRecvData.prototype.data = $util.newBuffer([]);

        ProxyRecvData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(10).bytes(message.data);
            return writer;
        };

        ProxyRecvData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.ProxyRecvData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ProxyRecvData;
    })();

    proto_accesshub.HBRequest = (function() {

        function HBRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        HBRequest.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        HBRequest.prototype.ts = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        HBRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.ts != null && Object.hasOwnProperty.call(message, "ts"))
                writer.uint32(16).int64(message.ts);
            return writer;
        };

        HBRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.HBRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.ts = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return HBRequest;
    })();

    proto_accesshub.HBResponse = (function() {

        function HBResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        HBResponse.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        HBResponse.prototype.ts = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        HBResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.ts != null && Object.hasOwnProperty.call(message, "ts"))
                writer.uint32(16).int64(message.ts);
            return writer;
        };

        HBResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.HBResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.ts = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return HBResponse;
    })();

    proto_accesshub.GetConfigRequest = (function() {

        function GetConfigRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        GetConfigRequest.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        GetConfigRequest.prototype.appid = 0;
        GetConfigRequest.prototype.biz_type = 0;
        GetConfigRequest.prototype.mode = "";
        GetConfigRequest.prototype.id_name = "";
        GetConfigRequest.prototype.reqid = "";
        GetConfigRequest.prototype.zegoconn_version = 0;
        GetConfigRequest.prototype.sdk_type = 0;
        GetConfigRequest.prototype.zegoconn_run_env = 0;

        GetConfigRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.appid != null && Object.hasOwnProperty.call(message, "appid"))
                writer.uint32(16).uint32(message.appid);
            if (message.biz_type != null && Object.hasOwnProperty.call(message, "biz_type"))
                writer.uint32(24).uint32(message.biz_type);
            if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                writer.uint32(34).string(message.mode);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(42).string(message.id_name);
            if (message.reqid != null && Object.hasOwnProperty.call(message, "reqid"))
                writer.uint32(50).string(message.reqid);
            if (message.zegoconn_version != null && Object.hasOwnProperty.call(message, "zegoconn_version"))
                writer.uint32(56).uint32(message.zegoconn_version);
            if (message.sdk_type != null && Object.hasOwnProperty.call(message, "sdk_type"))
                writer.uint32(64).int32(message.sdk_type);
            if (message.zegoconn_run_env != null && Object.hasOwnProperty.call(message, "zegoconn_run_env"))
                writer.uint32(72).int32(message.zegoconn_run_env);
            return writer;
        };

        GetConfigRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.GetConfigRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.appid = reader.uint32();
                    break;
                case 3:
                    message.biz_type = reader.uint32();
                    break;
                case 4:
                    message.mode = reader.string();
                    break;
                case 5:
                    message.id_name = reader.string();
                    break;
                case 6:
                    message.reqid = reader.string();
                    break;
                case 7:
                    message.zegoconn_version = reader.uint32();
                    break;
                case 8:
                    message.sdk_type = reader.int32();
                    break;
                case 9:
                    message.zegoconn_run_env = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return GetConfigRequest;
    })();

    proto_accesshub.GetConfigResponseData = (function() {

        function GetConfigResponseData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        GetConfigResponseData.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        GetConfigResponseData.prototype.quic_hb_interval = 0;
        GetConfigResponseData.prototype.quic_hb_timeout = 0;
        GetConfigResponseData.prototype.logic_hb_interval = 0;
        GetConfigResponseData.prototype.logic_hb_timeout = 0;
        GetConfigResponseData.prototype.pc_establish_timeout = 0;
        GetConfigResponseData.prototype.sdk_link_detect_interval = 0;
        GetConfigResponseData.prototype.sdk_link_detect_duration = 0;

        GetConfigResponseData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.quic_hb_interval != null && Object.hasOwnProperty.call(message, "quic_hb_interval"))
                writer.uint32(16).uint32(message.quic_hb_interval);
            if (message.quic_hb_timeout != null && Object.hasOwnProperty.call(message, "quic_hb_timeout"))
                writer.uint32(24).uint32(message.quic_hb_timeout);
            if (message.logic_hb_interval != null && Object.hasOwnProperty.call(message, "logic_hb_interval"))
                writer.uint32(32).uint32(message.logic_hb_interval);
            if (message.logic_hb_timeout != null && Object.hasOwnProperty.call(message, "logic_hb_timeout"))
                writer.uint32(40).uint32(message.logic_hb_timeout);
            if (message.pc_establish_timeout != null && Object.hasOwnProperty.call(message, "pc_establish_timeout"))
                writer.uint32(48).uint32(message.pc_establish_timeout);
            if (message.sdk_link_detect_interval != null && Object.hasOwnProperty.call(message, "sdk_link_detect_interval"))
                writer.uint32(56).uint32(message.sdk_link_detect_interval);
            if (message.sdk_link_detect_duration != null && Object.hasOwnProperty.call(message, "sdk_link_detect_duration"))
                writer.uint32(64).uint32(message.sdk_link_detect_duration);
            return writer;
        };

        GetConfigResponseData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.GetConfigResponseData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.quic_hb_interval = reader.uint32();
                    break;
                case 3:
                    message.quic_hb_timeout = reader.uint32();
                    break;
                case 4:
                    message.logic_hb_interval = reader.uint32();
                    break;
                case 5:
                    message.logic_hb_timeout = reader.uint32();
                    break;
                case 6:
                    message.pc_establish_timeout = reader.uint32();
                    break;
                case 7:
                    message.sdk_link_detect_interval = reader.uint32();
                    break;
                case 8:
                    message.sdk_link_detect_duration = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return GetConfigResponseData;
    })();

    proto_accesshub.GetConfigResponse = (function() {

        function GetConfigResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        GetConfigResponse.prototype.code = 0;
        GetConfigResponse.prototype.message = "";
        GetConfigResponse.prototype.data = null;

        GetConfigResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(8).int32(message.code);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(18).string(message.message);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                $root.proto_accesshub.GetConfigResponseData.encode(message.data, writer.uint32(26).fork()).ldelim();
            return writer;
        };

        GetConfigResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.GetConfigResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.int32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.data = $root.proto_accesshub.GetConfigResponseData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return GetConfigResponse;
    })();

    proto_accesshub.PCUpwardMessage = (function() {

        function PCUpwardMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        PCUpwardMessage.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        PCUpwardMessage.prototype.appid = 0;
        PCUpwardMessage.prototype.biz_type = 0;
        PCUpwardMessage.prototype.mode_no = 0;
        PCUpwardMessage.prototype.id_name = "";
        PCUpwardMessage.prototype.service_no = 0;
        PCUpwardMessage.prototype.ack = false;
        PCUpwardMessage.prototype.payload = $util.newBuffer([]);
        PCUpwardMessage.prototype.sdk_type = 0;
        PCUpwardMessage.prototype.wss_message_type = 0;
        PCUpwardMessage.prototype.wss_path = "";
        PCUpwardMessage.prototype.wss_raw_query = "";
        PCUpwardMessage.prototype.zegoconn_version = 0;
        PCUpwardMessage.prototype.zegoconn_run_env = 0;

        PCUpwardMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.appid != null && Object.hasOwnProperty.call(message, "appid"))
                writer.uint32(16).uint32(message.appid);
            if (message.biz_type != null && Object.hasOwnProperty.call(message, "biz_type"))
                writer.uint32(24).uint32(message.biz_type);
            if (message.mode_no != null && Object.hasOwnProperty.call(message, "mode_no"))
                writer.uint32(32).int32(message.mode_no);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(42).string(message.id_name);
            if (message.service_no != null && Object.hasOwnProperty.call(message, "service_no"))
                writer.uint32(48).int32(message.service_no);
            if (message.ack != null && Object.hasOwnProperty.call(message, "ack"))
                writer.uint32(56).bool(message.ack);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(66).bytes(message.payload);
            if (message.sdk_type != null && Object.hasOwnProperty.call(message, "sdk_type"))
                writer.uint32(72).int32(message.sdk_type);
            if (message.wss_message_type != null && Object.hasOwnProperty.call(message, "wss_message_type"))
                writer.uint32(80).uint32(message.wss_message_type);
            if (message.wss_path != null && Object.hasOwnProperty.call(message, "wss_path"))
                writer.uint32(90).string(message.wss_path);
            if (message.wss_raw_query != null && Object.hasOwnProperty.call(message, "wss_raw_query"))
                writer.uint32(98).string(message.wss_raw_query);
            if (message.zegoconn_version != null && Object.hasOwnProperty.call(message, "zegoconn_version"))
                writer.uint32(104).uint32(message.zegoconn_version);
            if (message.zegoconn_run_env != null && Object.hasOwnProperty.call(message, "zegoconn_run_env"))
                writer.uint32(112).int32(message.zegoconn_run_env);
            return writer;
        };

        PCUpwardMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.PCUpwardMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.appid = reader.uint32();
                    break;
                case 3:
                    message.biz_type = reader.uint32();
                    break;
                case 4:
                    message.mode_no = reader.int32();
                    break;
                case 5:
                    message.id_name = reader.string();
                    break;
                case 6:
                    message.service_no = reader.int32();
                    break;
                case 7:
                    message.ack = reader.bool();
                    break;
                case 8:
                    message.payload = reader.bytes();
                    break;
                case 9:
                    message.sdk_type = reader.int32();
                    break;
                case 10:
                    message.wss_message_type = reader.uint32();
                    break;
                case 11:
                    message.wss_path = reader.string();
                    break;
                case 12:
                    message.wss_raw_query = reader.string();
                    break;
                case 13:
                    message.zegoconn_version = reader.uint32();
                    break;
                case 14:
                    message.zegoconn_run_env = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PCUpwardMessage;
    })();

    proto_accesshub.PCUpwardMessageAck = (function() {

        function PCUpwardMessageAck(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        PCUpwardMessageAck.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        PCUpwardMessageAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            return writer;
        };

        PCUpwardMessageAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.PCUpwardMessageAck();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PCUpwardMessageAck;
    })();

    proto_accesshub.PCEstablished = (function() {

        function PCEstablished(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        PCEstablished.prototype.elapse = 0;
        PCEstablished.prototype.from = 0;

        PCEstablished.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.elapse != null && Object.hasOwnProperty.call(message, "elapse"))
                writer.uint32(8).uint32(message.elapse);
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                writer.uint32(16).uint32(message.from);
            return writer;
        };

        PCEstablished.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.PCEstablished();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.elapse = reader.uint32();
                    break;
                case 2:
                    message.from = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PCEstablished;
    })();

    proto_accesshub.PCBroken = (function() {

        function PCBroken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        PCBroken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        PCBroken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.PCBroken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PCBroken;
    })();

    proto_accesshub.PCDownwardMessage = (function() {

        function PCDownwardMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        PCDownwardMessage.prototype.payload = $util.newBuffer([]);
        PCDownwardMessage.prototype.wss_message_type = 0;

        PCDownwardMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(10).bytes(message.payload);
            if (message.wss_message_type != null && Object.hasOwnProperty.call(message, "wss_message_type"))
                writer.uint32(16).uint32(message.wss_message_type);
            return writer;
        };

        PCDownwardMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.PCDownwardMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.payload = reader.bytes();
                    break;
                case 2:
                    message.wss_message_type = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PCDownwardMessage;
    })();

    proto_accesshub.Redirect = (function() {

        function Redirect(properties) {
            this.groups = [];
            this.opt_ports = [];
            this.wss_groups = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        Redirect.prototype.rand = "";
        Redirect.prototype.secret = "";
        Redirect.prototype.groups = $util.emptyArray;
        Redirect.prototype.opt_ports = $util.emptyArray;
        Redirect.prototype.wss_groups = $util.emptyArray;

        Redirect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rand != null && Object.hasOwnProperty.call(message, "rand"))
                writer.uint32(10).string(message.rand);
            if (message.secret != null && Object.hasOwnProperty.call(message, "secret"))
                writer.uint32(18).string(message.secret);
            if (message.groups != null && message.groups.length)
                for (let i = 0; i < message.groups.length; ++i)
                    $root.proto_accesshub.AccesshubDispatchGroup.encode(message.groups[i], writer.uint32(26).fork()).ldelim();
            if (message.opt_ports != null && message.opt_ports.length)
                for (let i = 0; i < message.opt_ports.length; ++i)
                    writer.uint32(32).uint32(message.opt_ports[i]);
            if (message.wss_groups != null && message.wss_groups.length)
                for (let i = 0; i < message.wss_groups.length; ++i)
                    $root.proto_accesshub.WssAccesshubDispatchGroup.encode(message.wss_groups[i], writer.uint32(42).fork()).ldelim();
            return writer;
        };

        Redirect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.Redirect();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rand = reader.string();
                    break;
                case 2:
                    message.secret = reader.string();
                    break;
                case 3:
                    if (!(message.groups && message.groups.length))
                        message.groups = [];
                    message.groups.push($root.proto_accesshub.AccesshubDispatchGroup.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.opt_ports && message.opt_ports.length))
                        message.opt_ports = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.opt_ports.push(reader.uint32());
                    } else
                        message.opt_ports.push(reader.uint32());
                    break;
                case 5:
                    if (!(message.wss_groups && message.wss_groups.length))
                        message.wss_groups = [];
                    message.wss_groups.push($root.proto_accesshub.WssAccesshubDispatchGroup.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Redirect;
    })();

    proto_accesshub.GetAppConfigRequest = (function() {

        function GetAppConfigRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        GetAppConfigRequest.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        GetAppConfigRequest.prototype.appid = 0;
        GetAppConfigRequest.prototype.biz_type = 0;
        GetAppConfigRequest.prototype.mode_no = 0;
        GetAppConfigRequest.prototype.id_name = "";
        GetAppConfigRequest.prototype.config_key = "";
        GetAppConfigRequest.prototype.ts = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        GetAppConfigRequest.prototype.signature = $util.newBuffer([]);
        GetAppConfigRequest.prototype.lite_sign = "";
        GetAppConfigRequest.prototype.token = "";
        GetAppConfigRequest.prototype.sdk_type = 0;
        GetAppConfigRequest.prototype.zegoconn_version = 0;
        GetAppConfigRequest.prototype.zegoconn_run_env = 0;

        GetAppConfigRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.appid != null && Object.hasOwnProperty.call(message, "appid"))
                writer.uint32(16).uint32(message.appid);
            if (message.biz_type != null && Object.hasOwnProperty.call(message, "biz_type"))
                writer.uint32(24).uint32(message.biz_type);
            if (message.mode_no != null && Object.hasOwnProperty.call(message, "mode_no"))
                writer.uint32(32).int32(message.mode_no);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(42).string(message.id_name);
            if (message.config_key != null && Object.hasOwnProperty.call(message, "config_key"))
                writer.uint32(50).string(message.config_key);
            if (message.ts != null && Object.hasOwnProperty.call(message, "ts"))
                writer.uint32(56).uint64(message.ts);
            if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                writer.uint32(66).bytes(message.signature);
            if (message.lite_sign != null && Object.hasOwnProperty.call(message, "lite_sign"))
                writer.uint32(74).string(message.lite_sign);
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(82).string(message.token);
            if (message.sdk_type != null && Object.hasOwnProperty.call(message, "sdk_type"))
                writer.uint32(88).int32(message.sdk_type);
            if (message.zegoconn_version != null && Object.hasOwnProperty.call(message, "zegoconn_version"))
                writer.uint32(96).uint32(message.zegoconn_version);
            if (message.zegoconn_run_env != null && Object.hasOwnProperty.call(message, "zegoconn_run_env"))
                writer.uint32(104).int32(message.zegoconn_run_env);
            return writer;
        };

        GetAppConfigRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.GetAppConfigRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.appid = reader.uint32();
                    break;
                case 3:
                    message.biz_type = reader.uint32();
                    break;
                case 4:
                    message.mode_no = reader.int32();
                    break;
                case 5:
                    message.id_name = reader.string();
                    break;
                case 6:
                    message.config_key = reader.string();
                    break;
                case 7:
                    message.ts = reader.uint64();
                    break;
                case 8:
                    message.signature = reader.bytes();
                    break;
                case 9:
                    message.lite_sign = reader.string();
                    break;
                case 10:
                    message.token = reader.string();
                    break;
                case 11:
                    message.sdk_type = reader.int32();
                    break;
                case 12:
                    message.zegoconn_version = reader.uint32();
                    break;
                case 13:
                    message.zegoconn_run_env = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return GetAppConfigRequest;
    })();

    proto_accesshub.GetAppConfigResponseData = (function() {

        function GetAppConfigResponseData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        GetAppConfigResponseData.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        GetAppConfigResponseData.prototype.data = $util.newBuffer([]);
        GetAppConfigResponseData.prototype.ts = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        GetAppConfigResponseData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(18).bytes(message.data);
            if (message.ts != null && Object.hasOwnProperty.call(message, "ts"))
                writer.uint32(24).uint64(message.ts);
            return writer;
        };

        GetAppConfigResponseData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.GetAppConfigResponseData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                case 3:
                    message.ts = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return GetAppConfigResponseData;
    })();

    proto_accesshub.GetAppConfigResponse = (function() {

        function GetAppConfigResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        GetAppConfigResponse.prototype.code = 0;
        GetAppConfigResponse.prototype.message = "";
        GetAppConfigResponse.prototype.data = null;

        GetAppConfigResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(8).int32(message.code);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(18).string(message.message);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                $root.proto_accesshub.GetAppConfigResponseData.encode(message.data, writer.uint32(26).fork()).ldelim();
            return writer;
        };

        GetAppConfigResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.GetAppConfigResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.int32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.data = $root.proto_accesshub.GetAppConfigResponseData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return GetAppConfigResponse;
    })();

    proto_accesshub.PushAppConfig = (function() {

        function PushAppConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        PushAppConfig.prototype.config_key = "";
        PushAppConfig.prototype.data = $util.newBuffer([]);

        PushAppConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.config_key != null && Object.hasOwnProperty.call(message, "config_key"))
                writer.uint32(10).string(message.config_key);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(18).bytes(message.data);
            return writer;
        };

        PushAppConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.PushAppConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.config_key = reader.string();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushAppConfig;
    })();

    proto_accesshub.AccesshubDispatchRequest = (function() {

        function AccesshubDispatchRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        AccesshubDispatchRequest.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        AccesshubDispatchRequest.prototype.appid = 0;
        AccesshubDispatchRequest.prototype.biz_type = 0;
        AccesshubDispatchRequest.prototype.mode_no = 0;
        AccesshubDispatchRequest.prototype.id_name = "";
        AccesshubDispatchRequest.prototype.sdk_type = 0;
        AccesshubDispatchRequest.prototype.zegoconn_version = 0;
        AccesshubDispatchRequest.prototype.zegoconn_run_env = 0;

        AccesshubDispatchRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.appid != null && Object.hasOwnProperty.call(message, "appid"))
                writer.uint32(16).uint32(message.appid);
            if (message.biz_type != null && Object.hasOwnProperty.call(message, "biz_type"))
                writer.uint32(24).uint32(message.biz_type);
            if (message.mode_no != null && Object.hasOwnProperty.call(message, "mode_no"))
                writer.uint32(32).int32(message.mode_no);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(42).string(message.id_name);
            if (message.sdk_type != null && Object.hasOwnProperty.call(message, "sdk_type"))
                writer.uint32(48).int32(message.sdk_type);
            if (message.zegoconn_version != null && Object.hasOwnProperty.call(message, "zegoconn_version"))
                writer.uint32(56).uint32(message.zegoconn_version);
            if (message.zegoconn_run_env != null && Object.hasOwnProperty.call(message, "zegoconn_run_env"))
                writer.uint32(64).int32(message.zegoconn_run_env);
            return writer;
        };

        AccesshubDispatchRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.AccesshubDispatchRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.appid = reader.uint32();
                    break;
                case 3:
                    message.biz_type = reader.uint32();
                    break;
                case 4:
                    message.mode_no = reader.int32();
                    break;
                case 5:
                    message.id_name = reader.string();
                    break;
                case 6:
                    message.sdk_type = reader.int32();
                    break;
                case 7:
                    message.zegoconn_version = reader.uint32();
                    break;
                case 8:
                    message.zegoconn_run_env = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return AccesshubDispatchRequest;
    })();

    proto_accesshub.AccesshubDispatchGroup = (function() {

        function AccesshubDispatchGroup(properties) {
            this.quic_nodes = [];
            this.mtcp_nodes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        AccesshubDispatchGroup.prototype.group = "";
        AccesshubDispatchGroup.prototype.quic_nodes = $util.emptyArray;
        AccesshubDispatchGroup.prototype.mtcp_nodes = $util.emptyArray;

        AccesshubDispatchGroup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.group != null && Object.hasOwnProperty.call(message, "group"))
                writer.uint32(10).string(message.group);
            if (message.quic_nodes != null && message.quic_nodes.length)
                for (let i = 0; i < message.quic_nodes.length; ++i)
                    writer.uint32(18).string(message.quic_nodes[i]);
            if (message.mtcp_nodes != null && message.mtcp_nodes.length)
                for (let i = 0; i < message.mtcp_nodes.length; ++i)
                    writer.uint32(26).string(message.mtcp_nodes[i]);
            return writer;
        };

        AccesshubDispatchGroup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.AccesshubDispatchGroup();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.group = reader.string();
                    break;
                case 2:
                    if (!(message.quic_nodes && message.quic_nodes.length))
                        message.quic_nodes = [];
                    message.quic_nodes.push(reader.string());
                    break;
                case 3:
                    if (!(message.mtcp_nodes && message.mtcp_nodes.length))
                        message.mtcp_nodes = [];
                    message.mtcp_nodes.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return AccesshubDispatchGroup;
    })();

    proto_accesshub.WssAccesshubDispatchGroup = (function() {

        function WssAccesshubDispatchGroup(properties) {
            this.nodes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        WssAccesshubDispatchGroup.prototype.group = "";
        WssAccesshubDispatchGroup.prototype.host = "";
        WssAccesshubDispatchGroup.prototype.nodes = $util.emptyArray;

        WssAccesshubDispatchGroup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.group != null && Object.hasOwnProperty.call(message, "group"))
                writer.uint32(10).string(message.group);
            if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                writer.uint32(18).string(message.host);
            if (message.nodes != null && message.nodes.length)
                for (let i = 0; i < message.nodes.length; ++i)
                    writer.uint32(26).string(message.nodes[i]);
            return writer;
        };

        WssAccesshubDispatchGroup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.WssAccesshubDispatchGroup();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.group = reader.string();
                    break;
                case 2:
                    message.host = reader.string();
                    break;
                case 3:
                    if (!(message.nodes && message.nodes.length))
                        message.nodes = [];
                    message.nodes.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return WssAccesshubDispatchGroup;
    })();

    proto_accesshub.AccesshubDispatchResponseData = (function() {

        function AccesshubDispatchResponseData(properties) {
            this.groups = [];
            this.opt_ports = [];
            this.wss_groups = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        AccesshubDispatchResponseData.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        AccesshubDispatchResponseData.prototype.rand = "";
        AccesshubDispatchResponseData.prototype.secret = "";
        AccesshubDispatchResponseData.prototype.groups = $util.emptyArray;
        AccesshubDispatchResponseData.prototype.opt_ports = $util.emptyArray;
        AccesshubDispatchResponseData.prototype.wss_groups = $util.emptyArray;

        AccesshubDispatchResponseData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.rand != null && Object.hasOwnProperty.call(message, "rand"))
                writer.uint32(18).string(message.rand);
            if (message.secret != null && Object.hasOwnProperty.call(message, "secret"))
                writer.uint32(26).string(message.secret);
            if (message.groups != null && message.groups.length)
                for (let i = 0; i < message.groups.length; ++i)
                    $root.proto_accesshub.AccesshubDispatchGroup.encode(message.groups[i], writer.uint32(34).fork()).ldelim();
            if (message.opt_ports != null && message.opt_ports.length)
                for (let i = 0; i < message.opt_ports.length; ++i)
                    writer.uint32(40).uint32(message.opt_ports[i]);
            if (message.wss_groups != null && message.wss_groups.length)
                for (let i = 0; i < message.wss_groups.length; ++i)
                    $root.proto_accesshub.WssAccesshubDispatchGroup.encode(message.wss_groups[i], writer.uint32(50).fork()).ldelim();
            return writer;
        };

        AccesshubDispatchResponseData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.AccesshubDispatchResponseData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.rand = reader.string();
                    break;
                case 3:
                    message.secret = reader.string();
                    break;
                case 4:
                    if (!(message.groups && message.groups.length))
                        message.groups = [];
                    message.groups.push($root.proto_accesshub.AccesshubDispatchGroup.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.opt_ports && message.opt_ports.length))
                        message.opt_ports = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.opt_ports.push(reader.uint32());
                    } else
                        message.opt_ports.push(reader.uint32());
                    break;
                case 6:
                    if (!(message.wss_groups && message.wss_groups.length))
                        message.wss_groups = [];
                    message.wss_groups.push($root.proto_accesshub.WssAccesshubDispatchGroup.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return AccesshubDispatchResponseData;
    })();

    proto_accesshub.AccesshubDispatchResponse = (function() {

        function AccesshubDispatchResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        AccesshubDispatchResponse.prototype.code = 0;
        AccesshubDispatchResponse.prototype.message = "";
        AccesshubDispatchResponse.prototype.data = null;

        AccesshubDispatchResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(8).int32(message.code);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(18).string(message.message);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                $root.proto_accesshub.AccesshubDispatchResponseData.encode(message.data, writer.uint32(26).fork()).ldelim();
            return writer;
        };

        AccesshubDispatchResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.AccesshubDispatchResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.int32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.data = $root.proto_accesshub.AccesshubDispatchResponseData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return AccesshubDispatchResponse;
    })();

    proto_accesshub.GetIMConfigRequest = (function() {

        function GetIMConfigRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        GetIMConfigRequest.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        GetIMConfigRequest.prototype.appid = 0;
        GetIMConfigRequest.prototype.mode_no = 0;
        GetIMConfigRequest.prototype.user_id = "";
        GetIMConfigRequest.prototype.config_key = "";
        GetIMConfigRequest.prototype.token = "";
        GetIMConfigRequest.prototype.lite_sign = "";
        GetIMConfigRequest.prototype.sdk_type = 0;
        GetIMConfigRequest.prototype.zegoconn_version = 0;
        GetIMConfigRequest.prototype.zegoconn_run_env = 0;

        GetIMConfigRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.appid != null && Object.hasOwnProperty.call(message, "appid"))
                writer.uint32(16).uint32(message.appid);
            if (message.mode_no != null && Object.hasOwnProperty.call(message, "mode_no"))
                writer.uint32(24).int32(message.mode_no);
            if (message.user_id != null && Object.hasOwnProperty.call(message, "user_id"))
                writer.uint32(34).string(message.user_id);
            if (message.config_key != null && Object.hasOwnProperty.call(message, "config_key"))
                writer.uint32(42).string(message.config_key);
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(50).string(message.token);
            if (message.lite_sign != null && Object.hasOwnProperty.call(message, "lite_sign"))
                writer.uint32(58).string(message.lite_sign);
            if (message.sdk_type != null && Object.hasOwnProperty.call(message, "sdk_type"))
                writer.uint32(64).int32(message.sdk_type);
            if (message.zegoconn_version != null && Object.hasOwnProperty.call(message, "zegoconn_version"))
                writer.uint32(72).uint32(message.zegoconn_version);
            if (message.zegoconn_run_env != null && Object.hasOwnProperty.call(message, "zegoconn_run_env"))
                writer.uint32(80).int32(message.zegoconn_run_env);
            return writer;
        };

        GetIMConfigRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.GetIMConfigRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.appid = reader.uint32();
                    break;
                case 3:
                    message.mode_no = reader.int32();
                    break;
                case 4:
                    message.user_id = reader.string();
                    break;
                case 5:
                    message.config_key = reader.string();
                    break;
                case 6:
                    message.token = reader.string();
                    break;
                case 7:
                    message.lite_sign = reader.string();
                    break;
                case 8:
                    message.sdk_type = reader.int32();
                    break;
                case 9:
                    message.zegoconn_version = reader.uint32();
                    break;
                case 10:
                    message.zegoconn_run_env = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return GetIMConfigRequest;
    })();

    proto_accesshub.GetIMConfigResponseData = (function() {

        function GetIMConfigResponseData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        GetIMConfigResponseData.prototype.txid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
        GetIMConfigResponseData.prototype.data = $util.newBuffer([]);

        GetIMConfigResponseData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(8).uint64(message.txid);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(18).bytes(message.data);
            return writer;
        };

        GetIMConfigResponseData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.GetIMConfigResponseData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.uint64();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return GetIMConfigResponseData;
    })();

    proto_accesshub.GetIMConfigResponse = (function() {

        function GetIMConfigResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        GetIMConfigResponse.prototype.code = 0;
        GetIMConfigResponse.prototype.message = "";
        GetIMConfigResponse.prototype.data = null;

        GetIMConfigResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(8).int32(message.code);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(18).string(message.message);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                $root.proto_accesshub.GetIMConfigResponseData.encode(message.data, writer.uint32(26).fork()).ldelim();
            return writer;
        };

        GetIMConfigResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_accesshub.GetIMConfigResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.int32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.data = $root.proto_accesshub.GetIMConfigResponseData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return GetIMConfigResponse;
    })();

    return proto_accesshub;
})();

const proto_initconfig = $root.proto_initconfig = (() => {

    const proto_initconfig = {};

    proto_initconfig.ProtoVersion = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RPOTO_V000000"] = 0;
        values[valuesById[65536] = "RPOTO_V010000"] = 65536;
        return values;
    })();

    proto_initconfig.ResourceType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CDN"] = 0;
        values[valuesById[1] = "RTC"] = 1;
        values[valuesById[2] = "L3"] = 2;
        return values;
    })();

    proto_initconfig.ProtocolType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UDP"] = 0;
        values[valuesById[1] = "RTMP"] = 1;
        values[valuesById[2] = "FLV"] = 2;
        values[valuesById[3] = "HLS"] = 3;
        values[valuesById[4] = "WEBRTC"] = 4;
        return values;
    })();

    proto_initconfig.ResolveType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "LOCAL_DNS"] = 0;
        values[valuesById[1] = "DISPATCH"] = 1;
        return values;
    })();

    proto_initconfig.AppConfig = (function() {

        function AppConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        AppConfig.prototype.test_id = null;
        AppConfig.prototype.domain = null;
        AppConfig.prototype.flexible_domain = null;
        AppConfig.prototype.replace_flexible_domain = null;

        let $oneOfFields;

        Object.defineProperty(AppConfig.prototype, "_test_id", {
            get: $util.oneOfGetter($oneOfFields = ["test_id"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(AppConfig.prototype, "_domain", {
            get: $util.oneOfGetter($oneOfFields = ["domain"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(AppConfig.prototype, "_flexible_domain", {
            get: $util.oneOfGetter($oneOfFields = ["flexible_domain"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(AppConfig.prototype, "_replace_flexible_domain", {
            get: $util.oneOfGetter($oneOfFields = ["replace_flexible_domain"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        AppConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.test_id != null && Object.hasOwnProperty.call(message, "test_id"))
                writer.uint32(8).int32(message.test_id);
            if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
                writer.uint32(18).string(message.domain);
            if (message.flexible_domain != null && Object.hasOwnProperty.call(message, "flexible_domain"))
                writer.uint32(26).string(message.flexible_domain);
            if (message.replace_flexible_domain != null && Object.hasOwnProperty.call(message, "replace_flexible_domain"))
                writer.uint32(34).string(message.replace_flexible_domain);
            return writer;
        };

        AppConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.AppConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.test_id = reader.int32();
                    break;
                case 2:
                    message.domain = reader.string();
                    break;
                case 3:
                    message.flexible_domain = reader.string();
                    break;
                case 4:
                    message.replace_flexible_domain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return AppConfig;
    })();

    proto_initconfig.RoomConfig = (function() {

        function RoomConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        RoomConfig.prototype.license_url = null;

        let $oneOfFields;

        Object.defineProperty(RoomConfig.prototype, "_license_url", {
            get: $util.oneOfGetter($oneOfFields = ["license_url"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        RoomConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.license_url != null && Object.hasOwnProperty.call(message, "license_url"))
                writer.uint32(10).string(message.license_url);
            return writer;
        };

        RoomConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.RoomConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.license_url = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RoomConfig;
    })();

    proto_initconfig.VEConfig = (function() {

        function VEConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        VEConfig.prototype.audio_session_protect = null;

        let $oneOfFields;

        Object.defineProperty(VEConfig.prototype, "_audio_session_protect", {
            get: $util.oneOfGetter($oneOfFields = ["audio_session_protect"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        VEConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audio_session_protect != null && Object.hasOwnProperty.call(message, "audio_session_protect"))
                writer.uint32(8).int32(message.audio_session_protect);
            return writer;
        };

        VEConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.VEConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.audio_session_protect = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return VEConfig;
    })();

    proto_initconfig.SpeedlogConfig = (function() {

        function SpeedlogConfig(properties) {
            this.disable_report_pull = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        SpeedlogConfig.prototype.report_count = null;
        SpeedlogConfig.prototype.report_retry_interval = null;
        SpeedlogConfig.prototype.push_quality_sample_count = null;
        SpeedlogConfig.prototype.pull_quality_sample_count = null;
        SpeedlogConfig.prototype.hardware_report_cycle = null;
        SpeedlogConfig.prototype.room_user_max_count = null;
        SpeedlogConfig.prototype.room_stream_max_count = null;
        SpeedlogConfig.prototype.charge_info_report_cycle = null;
        SpeedlogConfig.prototype.charge_info_report_mode = null;
        SpeedlogConfig.prototype.disable_report_pull = $util.emptyArray;
        SpeedlogConfig.prototype.report_max_bytes = null;

        let $oneOfFields;

        Object.defineProperty(SpeedlogConfig.prototype, "_report_count", {
            get: $util.oneOfGetter($oneOfFields = ["report_count"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SpeedlogConfig.prototype, "_report_retry_interval", {
            get: $util.oneOfGetter($oneOfFields = ["report_retry_interval"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SpeedlogConfig.prototype, "_push_quality_sample_count", {
            get: $util.oneOfGetter($oneOfFields = ["push_quality_sample_count"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SpeedlogConfig.prototype, "_pull_quality_sample_count", {
            get: $util.oneOfGetter($oneOfFields = ["pull_quality_sample_count"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SpeedlogConfig.prototype, "_hardware_report_cycle", {
            get: $util.oneOfGetter($oneOfFields = ["hardware_report_cycle"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SpeedlogConfig.prototype, "_room_user_max_count", {
            get: $util.oneOfGetter($oneOfFields = ["room_user_max_count"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SpeedlogConfig.prototype, "_room_stream_max_count", {
            get: $util.oneOfGetter($oneOfFields = ["room_stream_max_count"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SpeedlogConfig.prototype, "_charge_info_report_cycle", {
            get: $util.oneOfGetter($oneOfFields = ["charge_info_report_cycle"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SpeedlogConfig.prototype, "_charge_info_report_mode", {
            get: $util.oneOfGetter($oneOfFields = ["charge_info_report_mode"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SpeedlogConfig.prototype, "_report_max_bytes", {
            get: $util.oneOfGetter($oneOfFields = ["report_max_bytes"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        SpeedlogConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.report_count != null && Object.hasOwnProperty.call(message, "report_count"))
                writer.uint32(8).int32(message.report_count);
            if (message.report_retry_interval != null && Object.hasOwnProperty.call(message, "report_retry_interval"))
                writer.uint32(16).int32(message.report_retry_interval);
            if (message.push_quality_sample_count != null && Object.hasOwnProperty.call(message, "push_quality_sample_count"))
                writer.uint32(24).int32(message.push_quality_sample_count);
            if (message.pull_quality_sample_count != null && Object.hasOwnProperty.call(message, "pull_quality_sample_count"))
                writer.uint32(32).int32(message.pull_quality_sample_count);
            if (message.hardware_report_cycle != null && Object.hasOwnProperty.call(message, "hardware_report_cycle"))
                writer.uint32(40).int32(message.hardware_report_cycle);
            if (message.room_user_max_count != null && Object.hasOwnProperty.call(message, "room_user_max_count"))
                writer.uint32(48).int32(message.room_user_max_count);
            if (message.room_stream_max_count != null && Object.hasOwnProperty.call(message, "room_stream_max_count"))
                writer.uint32(56).int32(message.room_stream_max_count);
            if (message.charge_info_report_cycle != null && Object.hasOwnProperty.call(message, "charge_info_report_cycle"))
                writer.uint32(64).int32(message.charge_info_report_cycle);
            if (message.charge_info_report_mode != null && Object.hasOwnProperty.call(message, "charge_info_report_mode"))
                writer.uint32(72).int32(message.charge_info_report_mode);
            if (message.disable_report_pull != null && message.disable_report_pull.length) {
                writer.uint32(82).fork();
                for (let i = 0; i < message.disable_report_pull.length; ++i)
                    writer.int32(message.disable_report_pull[i]);
                writer.ldelim();
            }
            if (message.report_max_bytes != null && Object.hasOwnProperty.call(message, "report_max_bytes"))
                writer.uint32(88).int32(message.report_max_bytes);
            return writer;
        };

        SpeedlogConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.SpeedlogConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.report_count = reader.int32();
                    break;
                case 2:
                    message.report_retry_interval = reader.int32();
                    break;
                case 3:
                    message.push_quality_sample_count = reader.int32();
                    break;
                case 4:
                    message.pull_quality_sample_count = reader.int32();
                    break;
                case 5:
                    message.hardware_report_cycle = reader.int32();
                    break;
                case 6:
                    message.room_user_max_count = reader.int32();
                    break;
                case 7:
                    message.room_stream_max_count = reader.int32();
                    break;
                case 8:
                    message.charge_info_report_cycle = reader.int32();
                    break;
                case 9:
                    message.charge_info_report_mode = reader.int32();
                    break;
                case 10:
                    if (!(message.disable_report_pull && message.disable_report_pull.length))
                        message.disable_report_pull = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.disable_report_pull.push(reader.int32());
                    } else
                        message.disable_report_pull.push(reader.int32());
                    break;
                case 11:
                    message.report_max_bytes = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SpeedlogConfig;
    })();

    proto_initconfig.MediaServiceProtocolInfo = (function() {

        function MediaServiceProtocolInfo(properties) {
            this.cdn_quic_version = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        MediaServiceProtocolInfo.prototype.config_id = null;
        MediaServiceProtocolInfo.prototype.protocol = null;
        MediaServiceProtocolInfo.prototype.url_template = null;
        MediaServiceProtocolInfo.prototype.resolve_type = null;
        MediaServiceProtocolInfo.prototype.push_cdn_authentication = null;
        MediaServiceProtocolInfo.prototype.cdn_quic_version = $util.emptyArray;

        let $oneOfFields;

        Object.defineProperty(MediaServiceProtocolInfo.prototype, "_config_id", {
            get: $util.oneOfGetter($oneOfFields = ["config_id"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaServiceProtocolInfo.prototype, "_protocol", {
            get: $util.oneOfGetter($oneOfFields = ["protocol"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaServiceProtocolInfo.prototype, "_url_template", {
            get: $util.oneOfGetter($oneOfFields = ["url_template"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaServiceProtocolInfo.prototype, "_resolve_type", {
            get: $util.oneOfGetter($oneOfFields = ["resolve_type"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaServiceProtocolInfo.prototype, "_push_cdn_authentication", {
            get: $util.oneOfGetter($oneOfFields = ["push_cdn_authentication"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        MediaServiceProtocolInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.config_id != null && Object.hasOwnProperty.call(message, "config_id"))
                writer.uint32(10).string(message.config_id);
            if (message.protocol != null && Object.hasOwnProperty.call(message, "protocol"))
                writer.uint32(16).int32(message.protocol);
            if (message.url_template != null && Object.hasOwnProperty.call(message, "url_template"))
                writer.uint32(26).string(message.url_template);
            if (message.resolve_type != null && Object.hasOwnProperty.call(message, "resolve_type"))
                writer.uint32(32).int32(message.resolve_type);
            if (message.push_cdn_authentication != null && Object.hasOwnProperty.call(message, "push_cdn_authentication"))
                writer.uint32(40).int32(message.push_cdn_authentication);
            if (message.cdn_quic_version != null && message.cdn_quic_version.length) {
                writer.uint32(50).fork();
                for (let i = 0; i < message.cdn_quic_version.length; ++i)
                    writer.int32(message.cdn_quic_version[i]);
                writer.ldelim();
            }
            return writer;
        };

        MediaServiceProtocolInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.MediaServiceProtocolInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.config_id = reader.string();
                    break;
                case 2:
                    message.protocol = reader.int32();
                    break;
                case 3:
                    message.url_template = reader.string();
                    break;
                case 4:
                    message.resolve_type = reader.int32();
                    break;
                case 5:
                    message.push_cdn_authentication = reader.int32();
                    break;
                case 6:
                    if (!(message.cdn_quic_version && message.cdn_quic_version.length))
                        message.cdn_quic_version = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.cdn_quic_version.push(reader.int32());
                    } else
                        message.cdn_quic_version.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MediaServiceProtocolInfo;
    })();

    proto_initconfig.MediaResourceInfo = (function() {

        function MediaResourceInfo(properties) {
            this.service_info = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        MediaResourceInfo.prototype.resource_type = null;
        MediaResourceInfo.prototype.service_info = $util.emptyArray;

        let $oneOfFields;

        Object.defineProperty(MediaResourceInfo.prototype, "_resource_type", {
            get: $util.oneOfGetter($oneOfFields = ["resource_type"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        MediaResourceInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resource_type != null && Object.hasOwnProperty.call(message, "resource_type"))
                writer.uint32(8).int32(message.resource_type);
            if (message.service_info != null && message.service_info.length)
                for (let i = 0; i < message.service_info.length; ++i)
                    $root.proto_initconfig.MediaServiceProtocolInfo.encode(message.service_info[i], writer.uint32(18).fork()).ldelim();
            return writer;
        };

        MediaResourceInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.MediaResourceInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resource_type = reader.int32();
                    break;
                case 2:
                    if (!(message.service_info && message.service_info.length))
                        message.service_info = [];
                    message.service_info.push($root.proto_initconfig.MediaServiceProtocolInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MediaResourceInfo;
    })();

    proto_initconfig.TrafficControl = (function() {

        function TrafficControl(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        TrafficControl.prototype.enable_traffic_control = null;
        TrafficControl.prototype.traffic_properties = null;

        let $oneOfFields;

        Object.defineProperty(TrafficControl.prototype, "_enable_traffic_control", {
            get: $util.oneOfGetter($oneOfFields = ["enable_traffic_control"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(TrafficControl.prototype, "_traffic_properties", {
            get: $util.oneOfGetter($oneOfFields = ["traffic_properties"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        TrafficControl.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enable_traffic_control != null && Object.hasOwnProperty.call(message, "enable_traffic_control"))
                writer.uint32(8).int32(message.enable_traffic_control);
            if (message.traffic_properties != null && Object.hasOwnProperty.call(message, "traffic_properties"))
                writer.uint32(16).int32(message.traffic_properties);
            return writer;
        };

        TrafficControl.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.TrafficControl();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enable_traffic_control = reader.int32();
                    break;
                case 2:
                    message.traffic_properties = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return TrafficControl;
    })();

    proto_initconfig.SupplementFrameControl = (function() {

        function SupplementFrameControl(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        SupplementFrameControl.prototype.enable = null;
        SupplementFrameControl.prototype.threshold = null;
        SupplementFrameControl.prototype.probability = null;

        let $oneOfFields;

        Object.defineProperty(SupplementFrameControl.prototype, "_enable", {
            get: $util.oneOfGetter($oneOfFields = ["enable"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SupplementFrameControl.prototype, "_threshold", {
            get: $util.oneOfGetter($oneOfFields = ["threshold"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(SupplementFrameControl.prototype, "_probability", {
            get: $util.oneOfGetter($oneOfFields = ["probability"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        SupplementFrameControl.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enable != null && Object.hasOwnProperty.call(message, "enable"))
                writer.uint32(8).int32(message.enable);
            if (message.threshold != null && Object.hasOwnProperty.call(message, "threshold"))
                writer.uint32(16).int32(message.threshold);
            if (message.probability != null && Object.hasOwnProperty.call(message, "probability"))
                writer.uint32(24).int32(message.probability);
            return writer;
        };

        SupplementFrameControl.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.SupplementFrameControl();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enable = reader.int32();
                    break;
                case 2:
                    message.threshold = reader.int32();
                    break;
                case 3:
                    message.probability = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SupplementFrameControl;
    })();

    proto_initconfig.VideoParam = (function() {

        function VideoParam(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        VideoParam.prototype.video_width = null;
        VideoParam.prototype.video_height = null;
        VideoParam.prototype.video_codec_id = null;
        VideoParam.prototype.video_bitrate = null;

        let $oneOfFields;

        Object.defineProperty(VideoParam.prototype, "_video_width", {
            get: $util.oneOfGetter($oneOfFields = ["video_width"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(VideoParam.prototype, "_video_height", {
            get: $util.oneOfGetter($oneOfFields = ["video_height"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(VideoParam.prototype, "_video_codec_id", {
            get: $util.oneOfGetter($oneOfFields = ["video_codec_id"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(VideoParam.prototype, "_video_bitrate", {
            get: $util.oneOfGetter($oneOfFields = ["video_bitrate"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        VideoParam.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.video_width != null && Object.hasOwnProperty.call(message, "video_width"))
                writer.uint32(8).int32(message.video_width);
            if (message.video_height != null && Object.hasOwnProperty.call(message, "video_height"))
                writer.uint32(16).int32(message.video_height);
            if (message.video_codec_id != null && Object.hasOwnProperty.call(message, "video_codec_id"))
                writer.uint32(24).int32(message.video_codec_id);
            if (message.video_bitrate != null && Object.hasOwnProperty.call(message, "video_bitrate"))
                writer.uint32(32).int32(message.video_bitrate);
            return writer;
        };

        VideoParam.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.VideoParam();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.video_width = reader.int32();
                    break;
                case 2:
                    message.video_height = reader.int32();
                    break;
                case 3:
                    message.video_codec_id = reader.int32();
                    break;
                case 4:
                    message.video_bitrate = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return VideoParam;
    })();

    proto_initconfig.PushConfig = (function() {

        function PushConfig(properties) {
            this.video_param = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        PushConfig.prototype.channel_idx = null;
        PushConfig.prototype.mode = null;
        PushConfig.prototype.traffic_control = null;
        PushConfig.prototype.resolution_rate = null;
        PushConfig.prototype.video_param = $util.emptyArray;

        let $oneOfFields;

        Object.defineProperty(PushConfig.prototype, "_channel_idx", {
            get: $util.oneOfGetter($oneOfFields = ["channel_idx"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(PushConfig.prototype, "_mode", {
            get: $util.oneOfGetter($oneOfFields = ["mode"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(PushConfig.prototype, "_traffic_control", {
            get: $util.oneOfGetter($oneOfFields = ["traffic_control"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(PushConfig.prototype, "_resolution_rate", {
            get: $util.oneOfGetter($oneOfFields = ["resolution_rate"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        PushConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channel_idx != null && Object.hasOwnProperty.call(message, "channel_idx"))
                writer.uint32(8).int32(message.channel_idx);
            if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                writer.uint32(16).int32(message.mode);
            if (message.traffic_control != null && Object.hasOwnProperty.call(message, "traffic_control"))
                $root.proto_initconfig.TrafficControl.encode(message.traffic_control, writer.uint32(42).fork()).ldelim();
            if (message.resolution_rate != null && Object.hasOwnProperty.call(message, "resolution_rate"))
                writer.uint32(48).int32(message.resolution_rate);
            if (message.video_param != null && message.video_param.length)
                for (let i = 0; i < message.video_param.length; ++i)
                    $root.proto_initconfig.VideoParam.encode(message.video_param[i], writer.uint32(58).fork()).ldelim();
            return writer;
        };

        PushConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.PushConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channel_idx = reader.int32();
                    break;
                case 2:
                    message.mode = reader.int32();
                    break;
                case 5:
                    message.traffic_control = $root.proto_initconfig.TrafficControl.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.resolution_rate = reader.int32();
                    break;
                case 7:
                    if (!(message.video_param && message.video_param.length))
                        message.video_param = [];
                    message.video_param.push($root.proto_initconfig.VideoParam.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushConfig;
    })();

    proto_initconfig.MediaPublishConfig = (function() {

        function MediaPublishConfig(properties) {
            this.resource_info = [];
            this.push_config = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        MediaPublishConfig.prototype.push_type = null;
        MediaPublishConfig.prototype.resource_info = $util.emptyArray;
        MediaPublishConfig.prototype.push_config = $util.emptyArray;

        let $oneOfFields;

        Object.defineProperty(MediaPublishConfig.prototype, "_push_type", {
            get: $util.oneOfGetter($oneOfFields = ["push_type"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        MediaPublishConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.push_type != null && Object.hasOwnProperty.call(message, "push_type"))
                writer.uint32(8).int32(message.push_type);
            if (message.resource_info != null && message.resource_info.length)
                for (let i = 0; i < message.resource_info.length; ++i)
                    $root.proto_initconfig.MediaResourceInfo.encode(message.resource_info[i], writer.uint32(18).fork()).ldelim();
            if (message.push_config != null && message.push_config.length)
                for (let i = 0; i < message.push_config.length; ++i)
                    $root.proto_initconfig.PushConfig.encode(message.push_config[i], writer.uint32(26).fork()).ldelim();
            return writer;
        };

        MediaPublishConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.MediaPublishConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.push_type = reader.int32();
                    break;
                case 2:
                    if (!(message.resource_info && message.resource_info.length))
                        message.resource_info = [];
                    message.resource_info.push($root.proto_initconfig.MediaResourceInfo.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.push_config && message.push_config.length))
                        message.push_config = [];
                    message.push_config.push($root.proto_initconfig.PushConfig.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MediaPublishConfig;
    })();

    proto_initconfig.TranscodingConfig = (function() {

        function TranscodingConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        TranscodingConfig.prototype.video_codec_h264 = null;

        let $oneOfFields;

        Object.defineProperty(TranscodingConfig.prototype, "_video_codec_h264", {
            get: $util.oneOfGetter($oneOfFields = ["video_codec_h264"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        TranscodingConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.video_codec_h264 != null && Object.hasOwnProperty.call(message, "video_codec_h264"))
                writer.uint32(10).string(message.video_codec_h264);
            return writer;
        };

        TranscodingConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.TranscodingConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.video_codec_h264 = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return TranscodingConfig;
    })();

    proto_initconfig.MediaPlayConfig = (function() {

        function MediaPlayConfig(properties) {
            this.resource_order = [];
            this.resource_info = [];
            this.play_order_protocol_type = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        MediaPlayConfig.prototype.pull_type = null;
        MediaPlayConfig.prototype.l3_play_buffer_ms = null;
        MediaPlayConfig.prototype.allow_playing_specific_url = null;
        MediaPlayConfig.prototype.resource_order = $util.emptyArray;
        MediaPlayConfig.prototype.resource_info = $util.emptyArray;
        MediaPlayConfig.prototype.play_order_protocol_type = $util.emptyArray;
        MediaPlayConfig.prototype.jitter_buffer_flag = null;
        MediaPlayConfig.prototype.min_jitter_buffer = null;
        MediaPlayConfig.prototype.max_jitter_buffer = null;
        MediaPlayConfig.prototype.supplement_frame_control = null;
        MediaPlayConfig.prototype.open_l3_play_resource_prefer = null;
        MediaPlayConfig.prototype.switch_to_l3_after_online = null;
        MediaPlayConfig.prototype.transcoding = null;

        let $oneOfFields;

        Object.defineProperty(MediaPlayConfig.prototype, "_pull_type", {
            get: $util.oneOfGetter($oneOfFields = ["pull_type"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaPlayConfig.prototype, "_l3_play_buffer_ms", {
            get: $util.oneOfGetter($oneOfFields = ["l3_play_buffer_ms"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaPlayConfig.prototype, "_allow_playing_specific_url", {
            get: $util.oneOfGetter($oneOfFields = ["allow_playing_specific_url"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaPlayConfig.prototype, "_jitter_buffer_flag", {
            get: $util.oneOfGetter($oneOfFields = ["jitter_buffer_flag"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaPlayConfig.prototype, "_min_jitter_buffer", {
            get: $util.oneOfGetter($oneOfFields = ["min_jitter_buffer"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaPlayConfig.prototype, "_max_jitter_buffer", {
            get: $util.oneOfGetter($oneOfFields = ["max_jitter_buffer"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaPlayConfig.prototype, "_supplement_frame_control", {
            get: $util.oneOfGetter($oneOfFields = ["supplement_frame_control"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaPlayConfig.prototype, "_open_l3_play_resource_prefer", {
            get: $util.oneOfGetter($oneOfFields = ["open_l3_play_resource_prefer"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaPlayConfig.prototype, "_switch_to_l3_after_online", {
            get: $util.oneOfGetter($oneOfFields = ["switch_to_l3_after_online"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaPlayConfig.prototype, "_transcoding", {
            get: $util.oneOfGetter($oneOfFields = ["transcoding"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        MediaPlayConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pull_type != null && Object.hasOwnProperty.call(message, "pull_type"))
                writer.uint32(8).int32(message.pull_type);
            if (message.l3_play_buffer_ms != null && Object.hasOwnProperty.call(message, "l3_play_buffer_ms"))
                writer.uint32(16).int32(message.l3_play_buffer_ms);
            if (message.allow_playing_specific_url != null && Object.hasOwnProperty.call(message, "allow_playing_specific_url"))
                writer.uint32(24).int32(message.allow_playing_specific_url);
            if (message.resource_order != null && message.resource_order.length) {
                writer.uint32(34).fork();
                for (let i = 0; i < message.resource_order.length; ++i)
                    writer.int32(message.resource_order[i]);
                writer.ldelim();
            }
            if (message.resource_info != null && message.resource_info.length)
                for (let i = 0; i < message.resource_info.length; ++i)
                    $root.proto_initconfig.MediaResourceInfo.encode(message.resource_info[i], writer.uint32(42).fork()).ldelim();
            if (message.play_order_protocol_type != null && message.play_order_protocol_type.length) {
                writer.uint32(50).fork();
                for (let i = 0; i < message.play_order_protocol_type.length; ++i)
                    writer.int32(message.play_order_protocol_type[i]);
                writer.ldelim();
            }
            if (message.jitter_buffer_flag != null && Object.hasOwnProperty.call(message, "jitter_buffer_flag"))
                writer.uint32(80).int32(message.jitter_buffer_flag);
            if (message.min_jitter_buffer != null && Object.hasOwnProperty.call(message, "min_jitter_buffer"))
                writer.uint32(88).int32(message.min_jitter_buffer);
            if (message.max_jitter_buffer != null && Object.hasOwnProperty.call(message, "max_jitter_buffer"))
                writer.uint32(96).int32(message.max_jitter_buffer);
            if (message.supplement_frame_control != null && Object.hasOwnProperty.call(message, "supplement_frame_control"))
                $root.proto_initconfig.SupplementFrameControl.encode(message.supplement_frame_control, writer.uint32(106).fork()).ldelim();
            if (message.open_l3_play_resource_prefer != null && Object.hasOwnProperty.call(message, "open_l3_play_resource_prefer"))
                writer.uint32(112).int32(message.open_l3_play_resource_prefer);
            if (message.switch_to_l3_after_online != null && Object.hasOwnProperty.call(message, "switch_to_l3_after_online"))
                writer.uint32(120).int32(message.switch_to_l3_after_online);
            if (message.transcoding != null && Object.hasOwnProperty.call(message, "transcoding"))
                $root.proto_initconfig.TranscodingConfig.encode(message.transcoding, writer.uint32(130).fork()).ldelim();
            return writer;
        };

        MediaPlayConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.MediaPlayConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pull_type = reader.int32();
                    break;
                case 2:
                    message.l3_play_buffer_ms = reader.int32();
                    break;
                case 3:
                    message.allow_playing_specific_url = reader.int32();
                    break;
                case 4:
                    if (!(message.resource_order && message.resource_order.length))
                        message.resource_order = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.resource_order.push(reader.int32());
                    } else
                        message.resource_order.push(reader.int32());
                    break;
                case 5:
                    if (!(message.resource_info && message.resource_info.length))
                        message.resource_info = [];
                    message.resource_info.push($root.proto_initconfig.MediaResourceInfo.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.play_order_protocol_type && message.play_order_protocol_type.length))
                        message.play_order_protocol_type = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.play_order_protocol_type.push(reader.int32());
                    } else
                        message.play_order_protocol_type.push(reader.int32());
                    break;
                case 10:
                    message.jitter_buffer_flag = reader.int32();
                    break;
                case 11:
                    message.min_jitter_buffer = reader.int32();
                    break;
                case 12:
                    message.max_jitter_buffer = reader.int32();
                    break;
                case 13:
                    message.supplement_frame_control = $root.proto_initconfig.SupplementFrameControl.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.open_l3_play_resource_prefer = reader.int32();
                    break;
                case 15:
                    message.switch_to_l3_after_online = reader.int32();
                    break;
                case 16:
                    message.transcoding = $root.proto_initconfig.TranscodingConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MediaPlayConfig;
    })();

    proto_initconfig.MediaDispatchProtocolInfo = (function() {

        function MediaDispatchProtocolInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        MediaDispatchProtocolInfo.prototype.protocol = null;
        MediaDispatchProtocolInfo.prototype.url_template = null;
        MediaDispatchProtocolInfo.prototype.reusable = null;

        let $oneOfFields;

        Object.defineProperty(MediaDispatchProtocolInfo.prototype, "_protocol", {
            get: $util.oneOfGetter($oneOfFields = ["protocol"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaDispatchProtocolInfo.prototype, "_url_template", {
            get: $util.oneOfGetter($oneOfFields = ["url_template"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaDispatchProtocolInfo.prototype, "_reusable", {
            get: $util.oneOfGetter($oneOfFields = ["reusable"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        MediaDispatchProtocolInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.protocol != null && Object.hasOwnProperty.call(message, "protocol"))
                writer.uint32(8).int32(message.protocol);
            if (message.url_template != null && Object.hasOwnProperty.call(message, "url_template"))
                writer.uint32(18).string(message.url_template);
            if (message.reusable != null && Object.hasOwnProperty.call(message, "reusable"))
                writer.uint32(24).int32(message.reusable);
            return writer;
        };

        MediaDispatchProtocolInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.MediaDispatchProtocolInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.protocol = reader.int32();
                    break;
                case 2:
                    message.url_template = reader.string();
                    break;
                case 3:
                    message.reusable = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MediaDispatchProtocolInfo;
    })();

    proto_initconfig.MediaDispatchResourceInfo = (function() {

        function MediaDispatchResourceInfo(properties) {
            this.dispatch_protocol_info = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        MediaDispatchResourceInfo.prototype.resource_type = null;
        MediaDispatchResourceInfo.prototype.dispatch_protocol_info = $util.emptyArray;

        let $oneOfFields;

        Object.defineProperty(MediaDispatchResourceInfo.prototype, "_resource_type", {
            get: $util.oneOfGetter($oneOfFields = ["resource_type"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        MediaDispatchResourceInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resource_type != null && Object.hasOwnProperty.call(message, "resource_type"))
                writer.uint32(8).int32(message.resource_type);
            if (message.dispatch_protocol_info != null && message.dispatch_protocol_info.length)
                for (let i = 0; i < message.dispatch_protocol_info.length; ++i)
                    $root.proto_initconfig.MediaDispatchProtocolInfo.encode(message.dispatch_protocol_info[i], writer.uint32(18).fork()).ldelim();
            return writer;
        };

        MediaDispatchResourceInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.MediaDispatchResourceInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resource_type = reader.int32();
                    break;
                case 2:
                    if (!(message.dispatch_protocol_info && message.dispatch_protocol_info.length))
                        message.dispatch_protocol_info = [];
                    message.dispatch_protocol_info.push($root.proto_initconfig.MediaDispatchProtocolInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MediaDispatchResourceInfo;
    })();

    proto_initconfig.MediaDispatchConfig = (function() {

        function MediaDispatchConfig(properties) {
            this.dispatch_resource_info = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        MediaDispatchConfig.prototype.dispatch_resource_info = $util.emptyArray;

        MediaDispatchConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dispatch_resource_info != null && message.dispatch_resource_info.length)
                for (let i = 0; i < message.dispatch_resource_info.length; ++i)
                    $root.proto_initconfig.MediaDispatchResourceInfo.encode(message.dispatch_resource_info[i], writer.uint32(10).fork()).ldelim();
            return writer;
        };

        MediaDispatchConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.MediaDispatchConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.dispatch_resource_info && message.dispatch_resource_info.length))
                        message.dispatch_resource_info = [];
                    message.dispatch_resource_info.push($root.proto_initconfig.MediaDispatchResourceInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MediaDispatchConfig;
    })();

    proto_initconfig.MediaServiceUrlList = (function() {

        function MediaServiceUrlList(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        MediaServiceUrlList.prototype.base_url = null;
        MediaServiceUrlList.prototype.push_status_url = null;

        let $oneOfFields;

        Object.defineProperty(MediaServiceUrlList.prototype, "_base_url", {
            get: $util.oneOfGetter($oneOfFields = ["base_url"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaServiceUrlList.prototype, "_push_status_url", {
            get: $util.oneOfGetter($oneOfFields = ["push_status_url"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        MediaServiceUrlList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.base_url != null && Object.hasOwnProperty.call(message, "base_url"))
                writer.uint32(10).string(message.base_url);
            if (message.push_status_url != null && Object.hasOwnProperty.call(message, "push_status_url"))
                writer.uint32(18).string(message.push_status_url);
            return writer;
        };

        MediaServiceUrlList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.MediaServiceUrlList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.base_url = reader.string();
                    break;
                case 2:
                    message.push_status_url = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MediaServiceUrlList;
    })();

    proto_initconfig.ZeusMediaConfig = (function() {

        function ZeusMediaConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        ZeusMediaConfig.prototype.push_dispatch_type = null;
        ZeusMediaConfig.prototype.pull_dispatch_type = null;
        ZeusMediaConfig.prototype.open_auth = null;
        ZeusMediaConfig.prototype.send_anchor_login_after_push_cdn = null;

        let $oneOfFields;

        Object.defineProperty(ZeusMediaConfig.prototype, "_push_dispatch_type", {
            get: $util.oneOfGetter($oneOfFields = ["push_dispatch_type"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(ZeusMediaConfig.prototype, "_pull_dispatch_type", {
            get: $util.oneOfGetter($oneOfFields = ["pull_dispatch_type"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(ZeusMediaConfig.prototype, "_open_auth", {
            get: $util.oneOfGetter($oneOfFields = ["open_auth"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(ZeusMediaConfig.prototype, "_send_anchor_login_after_push_cdn", {
            get: $util.oneOfGetter($oneOfFields = ["send_anchor_login_after_push_cdn"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        ZeusMediaConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.push_dispatch_type != null && Object.hasOwnProperty.call(message, "push_dispatch_type"))
                writer.uint32(8).int32(message.push_dispatch_type);
            if (message.pull_dispatch_type != null && Object.hasOwnProperty.call(message, "pull_dispatch_type"))
                writer.uint32(16).int32(message.pull_dispatch_type);
            if (message.open_auth != null && Object.hasOwnProperty.call(message, "open_auth"))
                writer.uint32(24).int32(message.open_auth);
            if (message.send_anchor_login_after_push_cdn != null && Object.hasOwnProperty.call(message, "send_anchor_login_after_push_cdn"))
                writer.uint32(32).int32(message.send_anchor_login_after_push_cdn);
            return writer;
        };

        ZeusMediaConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.ZeusMediaConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.push_dispatch_type = reader.int32();
                    break;
                case 2:
                    message.pull_dispatch_type = reader.int32();
                    break;
                case 3:
                    message.open_auth = reader.int32();
                    break;
                case 4:
                    message.send_anchor_login_after_push_cdn = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ZeusMediaConfig;
    })();

    proto_initconfig.MediaConfig = (function() {

        function MediaConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        MediaConfig.prototype.play_config = null;
        MediaConfig.prototype.publish_config = null;
        MediaConfig.prototype.dispatch_config = null;
        MediaConfig.prototype.service_url_list = null;
        MediaConfig.prototype.zeus_config = null;

        let $oneOfFields;

        Object.defineProperty(MediaConfig.prototype, "_play_config", {
            get: $util.oneOfGetter($oneOfFields = ["play_config"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaConfig.prototype, "_publish_config", {
            get: $util.oneOfGetter($oneOfFields = ["publish_config"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaConfig.prototype, "_dispatch_config", {
            get: $util.oneOfGetter($oneOfFields = ["dispatch_config"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaConfig.prototype, "_service_url_list", {
            get: $util.oneOfGetter($oneOfFields = ["service_url_list"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(MediaConfig.prototype, "_zeus_config", {
            get: $util.oneOfGetter($oneOfFields = ["zeus_config"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        MediaConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.play_config != null && Object.hasOwnProperty.call(message, "play_config"))
                $root.proto_initconfig.MediaPlayConfig.encode(message.play_config, writer.uint32(10).fork()).ldelim();
            if (message.publish_config != null && Object.hasOwnProperty.call(message, "publish_config"))
                $root.proto_initconfig.MediaPublishConfig.encode(message.publish_config, writer.uint32(18).fork()).ldelim();
            if (message.dispatch_config != null && Object.hasOwnProperty.call(message, "dispatch_config"))
                $root.proto_initconfig.MediaDispatchConfig.encode(message.dispatch_config, writer.uint32(26).fork()).ldelim();
            if (message.service_url_list != null && Object.hasOwnProperty.call(message, "service_url_list"))
                $root.proto_initconfig.MediaServiceUrlList.encode(message.service_url_list, writer.uint32(34).fork()).ldelim();
            if (message.zeus_config != null && Object.hasOwnProperty.call(message, "zeus_config"))
                $root.proto_initconfig.ZeusMediaConfig.encode(message.zeus_config, writer.uint32(42).fork()).ldelim();
            return writer;
        };

        MediaConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.MediaConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.play_config = $root.proto_initconfig.MediaPlayConfig.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.publish_config = $root.proto_initconfig.MediaPublishConfig.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.dispatch_config = $root.proto_initconfig.MediaDispatchConfig.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.service_url_list = $root.proto_initconfig.MediaServiceUrlList.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.zeus_config = $root.proto_initconfig.ZeusMediaConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MediaConfig;
    })();

    proto_initconfig.InitConfig = (function() {

        function InitConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        InitConfig.prototype.app_config = null;
        InitConfig.prototype.room_config = null;
        InitConfig.prototype.ve_config = null;
        InitConfig.prototype.speedlog_config = null;
        InitConfig.prototype.media_config = null;
        InitConfig.prototype.proto_version = null;

        let $oneOfFields;

        Object.defineProperty(InitConfig.prototype, "_app_config", {
            get: $util.oneOfGetter($oneOfFields = ["app_config"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(InitConfig.prototype, "_room_config", {
            get: $util.oneOfGetter($oneOfFields = ["room_config"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(InitConfig.prototype, "_ve_config", {
            get: $util.oneOfGetter($oneOfFields = ["ve_config"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(InitConfig.prototype, "_speedlog_config", {
            get: $util.oneOfGetter($oneOfFields = ["speedlog_config"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(InitConfig.prototype, "_media_config", {
            get: $util.oneOfGetter($oneOfFields = ["media_config"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        Object.defineProperty(InitConfig.prototype, "_proto_version", {
            get: $util.oneOfGetter($oneOfFields = ["proto_version"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        InitConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.app_config != null && Object.hasOwnProperty.call(message, "app_config"))
                $root.proto_initconfig.AppConfig.encode(message.app_config, writer.uint32(10).fork()).ldelim();
            if (message.room_config != null && Object.hasOwnProperty.call(message, "room_config"))
                $root.proto_initconfig.RoomConfig.encode(message.room_config, writer.uint32(18).fork()).ldelim();
            if (message.ve_config != null && Object.hasOwnProperty.call(message, "ve_config"))
                $root.proto_initconfig.VEConfig.encode(message.ve_config, writer.uint32(26).fork()).ldelim();
            if (message.speedlog_config != null && Object.hasOwnProperty.call(message, "speedlog_config"))
                $root.proto_initconfig.SpeedlogConfig.encode(message.speedlog_config, writer.uint32(34).fork()).ldelim();
            if (message.media_config != null && Object.hasOwnProperty.call(message, "media_config"))
                $root.proto_initconfig.MediaConfig.encode(message.media_config, writer.uint32(42).fork()).ldelim();
            if (message.proto_version != null && Object.hasOwnProperty.call(message, "proto_version"))
                writer.uint32(48).int32(message.proto_version);
            return writer;
        };

        InitConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_initconfig.InitConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.app_config = $root.proto_initconfig.AppConfig.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.room_config = $root.proto_initconfig.RoomConfig.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.ve_config = $root.proto_initconfig.VEConfig.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.speedlog_config = $root.proto_initconfig.SpeedlogConfig.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.media_config = $root.proto_initconfig.MediaConfig.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.proto_version = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return InitConfig;
    })();

    return proto_initconfig;
})();




/***/ }),

/***/ "./sdk/src/modules/proto/liveroom.js":
/*!*******************************************!*\
  !*** ./sdk/src/modules/proto/liveroom.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_798406__) {

"use strict";
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/


var $protobuf = __nested_webpack_require_798406__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.proto_switch = (function() {

    /**
     * Namespace proto_switch.
     * @exports proto_switch
     * @namespace
     */
    var proto_switch = {};

    proto_switch.CommonRsp = (function() {

        /**
         * Properties of a CommonRsp.
         * @memberof proto_switch
         * @interface ICommonRsp
         * @property {proto_switch.IRspHead|null} [rsp_head] CommonRsp rsp_head
         */

        /**
         * Constructs a new CommonRsp.
         * @memberof proto_switch
         * @classdesc Represents a CommonRsp.
         * @implements ICommonRsp
         * @constructor
         * @param {proto_switch.ICommonRsp=} [properties] Properties to set
         */
        function CommonRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommonRsp rsp_head.
         * @member {proto_switch.IRspHead|null|undefined} rsp_head
         * @memberof proto_switch.CommonRsp
         * @instance
         */
        CommonRsp.prototype.rsp_head = null;

        /**
         * Creates a new CommonRsp instance using the specified properties.
         * @function create
         * @memberof proto_switch.CommonRsp
         * @static
         * @param {proto_switch.ICommonRsp=} [properties] Properties to set
         * @returns {proto_switch.CommonRsp} CommonRsp instance
         */
        CommonRsp.create = function create(properties) {
            return new CommonRsp(properties);
        };

        /**
         * Encodes the specified CommonRsp message. Does not implicitly {@link proto_switch.CommonRsp.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.CommonRsp
         * @static
         * @param {proto_switch.ICommonRsp} message CommonRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.proto_switch.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a CommonRsp message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.CommonRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.CommonRsp} CommonRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.CommonRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.proto_switch.RspHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return CommonRsp;
    })();

    proto_switch.RspHead = (function() {

        /**
         * Properties of a RspHead.
         * @memberof proto_switch
         * @interface IRspHead
         * @property {number|null} [code] RspHead code
         * @property {string|null} [message] RspHead message
         */

        /**
         * Constructs a new RspHead.
         * @memberof proto_switch
         * @classdesc -title:
         * liveroom
         * @implements IRspHead
         * @constructor
         * @param {proto_switch.IRspHead=} [properties] Properties to set
         */
        function RspHead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RspHead code.
         * @member {number} code
         * @memberof proto_switch.RspHead
         * @instance
         */
        RspHead.prototype.code = 0;

        /**
         * RspHead message.
         * @member {string} message
         * @memberof proto_switch.RspHead
         * @instance
         */
        RspHead.prototype.message = "";

        /**
         * Creates a new RspHead instance using the specified properties.
         * @function create
         * @memberof proto_switch.RspHead
         * @static
         * @param {proto_switch.IRspHead=} [properties] Properties to set
         * @returns {proto_switch.RspHead} RspHead instance
         */
        RspHead.create = function create(properties) {
            return new RspHead(properties);
        };

        /**
         * Encodes the specified RspHead message. Does not implicitly {@link proto_switch.RspHead.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.RspHead
         * @static
         * @param {proto_switch.IRspHead} message RspHead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RspHead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.code);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            return writer;
        };

        /**
         * Decodes a RspHead message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.RspHead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.RspHead} RspHead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RspHead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.RspHead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.uint32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RspHead;
    })();

    proto_switch.LoginRoomReq = (function() {

        /**
         * Properties of a LoginRoomReq.
         * @memberof proto_switch
         * @interface ILoginRoomReq
         * @property {number|null} [app_id] LoginRoomReq app_id
         * @property {Uint8Array|null} [id_name] LoginRoomReq id_name
         * @property {string|null} [device_id] LoginRoomReq device_id
         * @property {proto_switch.TermType|null} [term_type] LoginRoomReq term_type
         * @property {proto_switch.NetType|null} [net_type] LoginRoomReq net_type
         * @property {number|null} [sdk_ver] LoginRoomReq sdk_ver
         * @property {proto_switch.LiveroomProtoVersion|null} [proto_ver] LoginRoomReq proto_ver
         * @property {Uint8Array|null} [nick_name] LoginRoomReq nick_name
         * @property {Uint8Array|null} [client_stamp] LoginRoomReq client_stamp
         * @property {number|null} [crypt_version] LoginRoomReq crypt_version
         * @property {Uint8Array|null} [k1_sign] LoginRoomReq k1_sign
         * @property {Uint8Array|null} [login_token] LoginRoomReq login_token
         * @property {Uint8Array|null} [relogin_token] LoginRoomReq relogin_token
         * @property {number|null} [role] LoginRoomReq role
         * @property {number|Long|null} [liveroom_session_id] LoginRoomReq liveroom_session_id
         * @property {Uint8Array|null} [room_id] LoginRoomReq room_id
         * @property {Uint8Array|null} [room_name] LoginRoomReq room_name
         * @property {number|null} [biz_type] LoginRoomReq biz_type
         * @property {number|null} [room_create_flag] LoginRoomReq room_create_flag
         * @property {number|null} [user_state_flag] LoginRoomReq user_state_flag
         * @property {string|null} [lv_key] LoginRoomReq lv_key
         * @property {Uint8Array|null} [third_token] LoginRoomReq third_token
         * @property {number|null} [cluster_req] LoginRoomReq cluster_req
         * @property {number|null} [user_count_limit] LoginRoomReq user_count_limit
         * @property {string|null} [relate_service] LoginRoomReq relate_service
         * @property {string|null} [biz_version] LoginRoomReq biz_version
         * @property {number|null} [login_logic] LoginRoomReq login_logic
         * @property {proto_switch.SdkConnType|null} [sdk_conn_type] sdk, native sdkweb sdk; 01: native sdk; 2: web sdk
         */

        /**
         * Constructs a new LoginRoomReq.
         * @memberof proto_switch
         * @classdesc Represents a LoginRoomReq.
         * @implements ILoginRoomReq
         * @constructor
         * @param {proto_switch.ILoginRoomReq=} [properties] Properties to set
         */
        function LoginRoomReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginRoomReq app_id.
         * @member {number} app_id
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.app_id = 0;

        /**
         * LoginRoomReq id_name.
         * @member {Uint8Array} id_name
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.id_name = $util.newBuffer([]);

        /**
         * LoginRoomReq device_id.
         * @member {string} device_id
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.device_id = "";

        /**
         * LoginRoomReq term_type.
         * @member {proto_switch.TermType} term_type
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.term_type = 0;

        /**
         * LoginRoomReq net_type.
         * @member {proto_switch.NetType} net_type
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.net_type = 0;

        /**
         * LoginRoomReq sdk_ver.
         * @member {number} sdk_ver
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.sdk_ver = 0;

        /**
         * LoginRoomReq proto_ver.
         * @member {proto_switch.LiveroomProtoVersion} proto_ver
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.proto_ver = 0;

        /**
         * LoginRoomReq nick_name.
         * @member {Uint8Array} nick_name
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.nick_name = $util.newBuffer([]);

        /**
         * LoginRoomReq client_stamp.
         * @member {Uint8Array} client_stamp
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.client_stamp = $util.newBuffer([]);

        /**
         * LoginRoomReq crypt_version.
         * @member {number} crypt_version
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.crypt_version = 0;

        /**
         * LoginRoomReq k1_sign.
         * @member {Uint8Array} k1_sign
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.k1_sign = $util.newBuffer([]);

        /**
         * LoginRoomReq login_token.
         * @member {Uint8Array} login_token
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.login_token = $util.newBuffer([]);

        /**
         * LoginRoomReq relogin_token.
         * @member {Uint8Array} relogin_token
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.relogin_token = $util.newBuffer([]);

        /**
         * LoginRoomReq role.
         * @member {number} role
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.role = 0;

        /**
         * LoginRoomReq liveroom_session_id.
         * @member {number|Long} liveroom_session_id
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.liveroom_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * LoginRoomReq room_id.
         * @member {Uint8Array} room_id
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.room_id = $util.newBuffer([]);

        /**
         * LoginRoomReq room_name.
         * @member {Uint8Array} room_name
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.room_name = $util.newBuffer([]);

        /**
         * LoginRoomReq biz_type.
         * @member {number} biz_type
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.biz_type = 0;

        /**
         * LoginRoomReq room_create_flag.
         * @member {number} room_create_flag
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.room_create_flag = 0;

        /**
         * LoginRoomReq user_state_flag.
         * @member {number} user_state_flag
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.user_state_flag = 0;

        /**
         * LoginRoomReq lv_key.
         * @member {string} lv_key
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.lv_key = "";

        /**
         * LoginRoomReq third_token.
         * @member {Uint8Array} third_token
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.third_token = $util.newBuffer([]);

        /**
         * LoginRoomReq cluster_req.
         * @member {number} cluster_req
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.cluster_req = 0;

        /**
         * LoginRoomReq user_count_limit.
         * @member {number} user_count_limit
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.user_count_limit = 0;

        /**
         * LoginRoomReq relate_service.
         * @member {string} relate_service
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.relate_service = "";

        /**
         * LoginRoomReq biz_version.
         * @member {string} biz_version
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.biz_version = "";

        /**
         * LoginRoomReq login_logic.
         * @member {number} login_logic
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.login_logic = 0;

        /**
         * sdk, native sdkweb sdk; 01: native sdk; 2: web sdk
         * @member {proto_switch.SdkConnType} sdk_conn_type
         * @memberof proto_switch.LoginRoomReq
         * @instance
         */
        LoginRoomReq.prototype.sdk_conn_type = 0;

        /**
         * Creates a new LoginRoomReq instance using the specified properties.
         * @function create
         * @memberof proto_switch.LoginRoomReq
         * @static
         * @param {proto_switch.ILoginRoomReq=} [properties] Properties to set
         * @returns {proto_switch.LoginRoomReq} LoginRoomReq instance
         */
        LoginRoomReq.create = function create(properties) {
            return new LoginRoomReq(properties);
        };

        /**
         * Encodes the specified LoginRoomReq message. Does not implicitly {@link proto_switch.LoginRoomReq.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.LoginRoomReq
         * @static
         * @param {proto_switch.ILoginRoomReq} message LoginRoomReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginRoomReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.app_id != null && Object.hasOwnProperty.call(message, "app_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.app_id);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.id_name);
            if (message.device_id != null && Object.hasOwnProperty.call(message, "device_id"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.device_id);
            if (message.term_type != null && Object.hasOwnProperty.call(message, "term_type"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.term_type);
            if (message.net_type != null && Object.hasOwnProperty.call(message, "net_type"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.net_type);
            if (message.sdk_ver != null && Object.hasOwnProperty.call(message, "sdk_ver"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.sdk_ver);
            if (message.proto_ver != null && Object.hasOwnProperty.call(message, "proto_ver"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.proto_ver);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.nick_name);
            if (message.client_stamp != null && Object.hasOwnProperty.call(message, "client_stamp"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.client_stamp);
            if (message.crypt_version != null && Object.hasOwnProperty.call(message, "crypt_version"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.crypt_version);
            if (message.k1_sign != null && Object.hasOwnProperty.call(message, "k1_sign"))
                writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.k1_sign);
            if (message.login_token != null && Object.hasOwnProperty.call(message, "login_token"))
                writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.login_token);
            if (message.relogin_token != null && Object.hasOwnProperty.call(message, "relogin_token"))
                writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.relogin_token);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.role);
            if (message.liveroom_session_id != null && Object.hasOwnProperty.call(message, "liveroom_session_id"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint64(message.liveroom_session_id);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.room_id);
            if (message.room_name != null && Object.hasOwnProperty.call(message, "room_name"))
                writer.uint32(/* id 17, wireType 2 =*/138).bytes(message.room_name);
            if (message.biz_type != null && Object.hasOwnProperty.call(message, "biz_type"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.biz_type);
            if (message.room_create_flag != null && Object.hasOwnProperty.call(message, "room_create_flag"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.room_create_flag);
            if (message.user_state_flag != null && Object.hasOwnProperty.call(message, "user_state_flag"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.user_state_flag);
            if (message.lv_key != null && Object.hasOwnProperty.call(message, "lv_key"))
                writer.uint32(/* id 21, wireType 2 =*/170).string(message.lv_key);
            if (message.third_token != null && Object.hasOwnProperty.call(message, "third_token"))
                writer.uint32(/* id 22, wireType 2 =*/178).bytes(message.third_token);
            if (message.cluster_req != null && Object.hasOwnProperty.call(message, "cluster_req"))
                writer.uint32(/* id 23, wireType 0 =*/184).uint32(message.cluster_req);
            if (message.user_count_limit != null && Object.hasOwnProperty.call(message, "user_count_limit"))
                writer.uint32(/* id 24, wireType 0 =*/192).uint32(message.user_count_limit);
            if (message.relate_service != null && Object.hasOwnProperty.call(message, "relate_service"))
                writer.uint32(/* id 25, wireType 2 =*/202).string(message.relate_service);
            if (message.biz_version != null && Object.hasOwnProperty.call(message, "biz_version"))
                writer.uint32(/* id 26, wireType 2 =*/210).string(message.biz_version);
            if (message.login_logic != null && Object.hasOwnProperty.call(message, "login_logic"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint32(message.login_logic);
            if (message.sdk_conn_type != null && Object.hasOwnProperty.call(message, "sdk_conn_type"))
                writer.uint32(/* id 28, wireType 0 =*/224).int32(message.sdk_conn_type);
            return writer;
        };

        /**
         * Decodes a LoginRoomReq message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.LoginRoomReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.LoginRoomReq} LoginRoomReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginRoomReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.LoginRoomReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.app_id = reader.uint32();
                    break;
                case 2:
                    message.id_name = reader.bytes();
                    break;
                case 3:
                    message.device_id = reader.string();
                    break;
                case 4:
                    message.term_type = reader.int32();
                    break;
                case 5:
                    message.net_type = reader.int32();
                    break;
                case 6:
                    message.sdk_ver = reader.uint32();
                    break;
                case 7:
                    message.proto_ver = reader.int32();
                    break;
                case 8:
                    message.nick_name = reader.bytes();
                    break;
                case 9:
                    message.client_stamp = reader.bytes();
                    break;
                case 10:
                    message.crypt_version = reader.uint32();
                    break;
                case 11:
                    message.k1_sign = reader.bytes();
                    break;
                case 12:
                    message.login_token = reader.bytes();
                    break;
                case 13:
                    message.relogin_token = reader.bytes();
                    break;
                case 14:
                    message.role = reader.uint32();
                    break;
                case 15:
                    message.liveroom_session_id = reader.uint64();
                    break;
                case 16:
                    message.room_id = reader.bytes();
                    break;
                case 17:
                    message.room_name = reader.bytes();
                    break;
                case 18:
                    message.biz_type = reader.uint32();
                    break;
                case 19:
                    message.room_create_flag = reader.uint32();
                    break;
                case 20:
                    message.user_state_flag = reader.uint32();
                    break;
                case 21:
                    message.lv_key = reader.string();
                    break;
                case 22:
                    message.third_token = reader.bytes();
                    break;
                case 23:
                    message.cluster_req = reader.uint32();
                    break;
                case 24:
                    message.user_count_limit = reader.uint32();
                    break;
                case 25:
                    message.relate_service = reader.string();
                    break;
                case 26:
                    message.biz_version = reader.string();
                    break;
                case 27:
                    message.login_logic = reader.uint32();
                    break;
                case 28:
                    message.sdk_conn_type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return LoginRoomReq;
    })();

    proto_switch.LoginRoomRsp = (function() {

        /**
         * Properties of a LoginRoomRsp.
         * @memberof proto_switch
         * @interface ILoginRoomRsp
         * @property {proto_switch.IRspHead|null} [rsp_head] LoginRoomRsp rsp_head
         * @property {Uint8Array|null} [room_id] LoginRoomRsp room_id
         * @property {number|null} [heartbeat_interval] LoginRoomRsp heartbeat_interval
         * @property {number|null} [heartbeat_timeout] LoginRoomRsp heartbeat_timeout
         * @property {number|Long|null} [ret_timestamp] LoginRoomRsp ret_timestamp
         * @property {number|null} [crypt_option] LoginRoomRsp crypt_option
         * @property {Uint8Array|null} [k2_sign] LoginRoomRsp k2_sign
         * @property {number|Long|null} [liveroom_session_id] LoginRoomRsp liveroom_session_id
         * @property {number|null} [liveroom_hb_interval] LoginRoomRsp liveroom_hb_interval
         * @property {number|null} [liveroom_hb_timeout] LoginRoomRsp liveroom_hb_timeout
         * @property {proto_switch.IStAnchorInfo|null} [anchor_info] LoginRoomRsp anchor_info
         * @property {number|null} [stream_seq] LoginRoomRsp stream_seq
         * @property {Array.<proto_switch.IStStreamInfo>|null} [stream_info] LoginRoomRsp stream_info
         * @property {number|null} [stream_fetch_flag] LoginRoomRsp stream_fetch_flag
         * @property {string|null} [lv_key] LoginRoomRsp lv_key
         * @property {string|null} [zp_key] LoginRoomRsp zp_key
         * @property {number|null} [online_count] LoginRoomRsp online_count
         * @property {number|null} [bigim_time_window] LoginRoomRsp bigim_time_window
         * @property {number|null} [dati_time_window] LoginRoomRsp dati_time_window
         * @property {string|null} [cluster_name] LoginRoomRsp cluster_name
         * @property {Uint8Array|null} [relogin_token] LoginRoomRsp relogin_token
         * @property {Array.<proto_switch.IStStreamInfo>|null} [stream_mix_info] LoginRoomRsp stream_mix_info
         * @property {number|null} [userlist_merge_timeout] LoginRoomRsp userlist_merge_timeout
         * @property {number|null} [userlist_interval] LoginRoomRsp userlist_interval
         * @property {number|Long|null} [room_session_id] LoginRoomRsp room_session_id
         * @property {Array.<proto_switch.IStTransInfo>|null} [trans_seqs] LoginRoomRsp trans_seqs
         * @property {number|null} [stream_list_push_merge_timeout] LoginRoomRsp stream_list_push_merge_timeout
         * @property {number|null} [stream_list_hb_wait_merge_time] LoginRoomRsp stream_list_hb_wait_merge_time
         * @property {number|null} [trans_list_seq] LoginRoomRsp trans_list_seq
         * @property {number|null} [token_remain_time] LoginRoomRsp token_remain_time
         */

        /**
         * Constructs a new LoginRoomRsp.
         * @memberof proto_switch
         * @classdesc Represents a LoginRoomRsp.
         * @implements ILoginRoomRsp
         * @constructor
         * @param {proto_switch.ILoginRoomRsp=} [properties] Properties to set
         */
        function LoginRoomRsp(properties) {
            this.stream_info = [];
            this.stream_mix_info = [];
            this.trans_seqs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginRoomRsp rsp_head.
         * @member {proto_switch.IRspHead|null|undefined} rsp_head
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.rsp_head = null;

        /**
         * LoginRoomRsp room_id.
         * @member {Uint8Array} room_id
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.room_id = $util.newBuffer([]);

        /**
         * LoginRoomRsp heartbeat_interval.
         * @member {number} heartbeat_interval
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.heartbeat_interval = 0;

        /**
         * LoginRoomRsp heartbeat_timeout.
         * @member {number} heartbeat_timeout
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.heartbeat_timeout = 0;

        /**
         * LoginRoomRsp ret_timestamp.
         * @member {number|Long} ret_timestamp
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.ret_timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LoginRoomRsp crypt_option.
         * @member {number} crypt_option
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.crypt_option = 0;

        /**
         * LoginRoomRsp k2_sign.
         * @member {Uint8Array} k2_sign
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.k2_sign = $util.newBuffer([]);

        /**
         * LoginRoomRsp liveroom_session_id.
         * @member {number|Long} liveroom_session_id
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.liveroom_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * LoginRoomRsp liveroom_hb_interval.
         * @member {number} liveroom_hb_interval
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.liveroom_hb_interval = 0;

        /**
         * LoginRoomRsp liveroom_hb_timeout.
         * @member {number} liveroom_hb_timeout
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.liveroom_hb_timeout = 0;

        /**
         * LoginRoomRsp anchor_info.
         * @member {proto_switch.IStAnchorInfo|null|undefined} anchor_info
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.anchor_info = null;

        /**
         * LoginRoomRsp stream_seq.
         * @member {number} stream_seq
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.stream_seq = 0;

        /**
         * LoginRoomRsp stream_info.
         * @member {Array.<proto_switch.IStStreamInfo>} stream_info
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.stream_info = $util.emptyArray;

        /**
         * LoginRoomRsp stream_fetch_flag.
         * @member {number} stream_fetch_flag
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.stream_fetch_flag = 0;

        /**
         * LoginRoomRsp lv_key.
         * @member {string} lv_key
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.lv_key = "";

        /**
         * LoginRoomRsp zp_key.
         * @member {string} zp_key
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.zp_key = "";

        /**
         * LoginRoomRsp online_count.
         * @member {number} online_count
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.online_count = 0;

        /**
         * LoginRoomRsp bigim_time_window.
         * @member {number} bigim_time_window
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.bigim_time_window = 0;

        /**
         * LoginRoomRsp dati_time_window.
         * @member {number} dati_time_window
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.dati_time_window = 0;

        /**
         * LoginRoomRsp cluster_name.
         * @member {string} cluster_name
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.cluster_name = "";

        /**
         * LoginRoomRsp relogin_token.
         * @member {Uint8Array} relogin_token
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.relogin_token = $util.newBuffer([]);

        /**
         * LoginRoomRsp stream_mix_info.
         * @member {Array.<proto_switch.IStStreamInfo>} stream_mix_info
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.stream_mix_info = $util.emptyArray;

        /**
         * LoginRoomRsp userlist_merge_timeout.
         * @member {number} userlist_merge_timeout
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.userlist_merge_timeout = 0;

        /**
         * LoginRoomRsp userlist_interval.
         * @member {number} userlist_interval
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.userlist_interval = 0;

        /**
         * LoginRoomRsp room_session_id.
         * @member {number|Long} room_session_id
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.room_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * LoginRoomRsp trans_seqs.
         * @member {Array.<proto_switch.IStTransInfo>} trans_seqs
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.trans_seqs = $util.emptyArray;

        /**
         * LoginRoomRsp stream_list_push_merge_timeout.
         * @member {number} stream_list_push_merge_timeout
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.stream_list_push_merge_timeout = 0;

        /**
         * LoginRoomRsp stream_list_hb_wait_merge_time.
         * @member {number} stream_list_hb_wait_merge_time
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.stream_list_hb_wait_merge_time = 0;

        /**
         * LoginRoomRsp trans_list_seq.
         * @member {number} trans_list_seq
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.trans_list_seq = 0;

        /**
         * LoginRoomRsp token_remain_time.
         * @member {number} token_remain_time
         * @memberof proto_switch.LoginRoomRsp
         * @instance
         */
        LoginRoomRsp.prototype.token_remain_time = 0;

        /**
         * Creates a new LoginRoomRsp instance using the specified properties.
         * @function create
         * @memberof proto_switch.LoginRoomRsp
         * @static
         * @param {proto_switch.ILoginRoomRsp=} [properties] Properties to set
         * @returns {proto_switch.LoginRoomRsp} LoginRoomRsp instance
         */
        LoginRoomRsp.create = function create(properties) {
            return new LoginRoomRsp(properties);
        };

        /**
         * Encodes the specified LoginRoomRsp message. Does not implicitly {@link proto_switch.LoginRoomRsp.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.LoginRoomRsp
         * @static
         * @param {proto_switch.ILoginRoomRsp} message LoginRoomRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginRoomRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.proto_switch.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.room_id);
            if (message.heartbeat_interval != null && Object.hasOwnProperty.call(message, "heartbeat_interval"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.heartbeat_interval);
            if (message.heartbeat_timeout != null && Object.hasOwnProperty.call(message, "heartbeat_timeout"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.heartbeat_timeout);
            if (message.ret_timestamp != null && Object.hasOwnProperty.call(message, "ret_timestamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.ret_timestamp);
            if (message.crypt_option != null && Object.hasOwnProperty.call(message, "crypt_option"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.crypt_option);
            if (message.k2_sign != null && Object.hasOwnProperty.call(message, "k2_sign"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.k2_sign);
            if (message.liveroom_session_id != null && Object.hasOwnProperty.call(message, "liveroom_session_id"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.liveroom_session_id);
            if (message.liveroom_hb_interval != null && Object.hasOwnProperty.call(message, "liveroom_hb_interval"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.liveroom_hb_interval);
            if (message.liveroom_hb_timeout != null && Object.hasOwnProperty.call(message, "liveroom_hb_timeout"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.liveroom_hb_timeout);
            if (message.anchor_info != null && Object.hasOwnProperty.call(message, "anchor_info"))
                $root.proto_switch.StAnchorInfo.encode(message.anchor_info, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.stream_seq != null && Object.hasOwnProperty.call(message, "stream_seq"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.stream_seq);
            if (message.stream_info != null && message.stream_info.length)
                for (var i = 0; i < message.stream_info.length; ++i)
                    $root.proto_switch.StStreamInfo.encode(message.stream_info[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.stream_fetch_flag != null && Object.hasOwnProperty.call(message, "stream_fetch_flag"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.stream_fetch_flag);
            if (message.lv_key != null && Object.hasOwnProperty.call(message, "lv_key"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.lv_key);
            if (message.zp_key != null && Object.hasOwnProperty.call(message, "zp_key"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.zp_key);
            if (message.online_count != null && Object.hasOwnProperty.call(message, "online_count"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint32(message.online_count);
            if (message.bigim_time_window != null && Object.hasOwnProperty.call(message, "bigim_time_window"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.bigim_time_window);
            if (message.dati_time_window != null && Object.hasOwnProperty.call(message, "dati_time_window"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.dati_time_window);
            if (message.cluster_name != null && Object.hasOwnProperty.call(message, "cluster_name"))
                writer.uint32(/* id 20, wireType 2 =*/162).string(message.cluster_name);
            if (message.relogin_token != null && Object.hasOwnProperty.call(message, "relogin_token"))
                writer.uint32(/* id 21, wireType 2 =*/170).bytes(message.relogin_token);
            if (message.stream_mix_info != null && message.stream_mix_info.length)
                for (var i = 0; i < message.stream_mix_info.length; ++i)
                    $root.proto_switch.StStreamInfo.encode(message.stream_mix_info[i], writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.userlist_merge_timeout != null && Object.hasOwnProperty.call(message, "userlist_merge_timeout"))
                writer.uint32(/* id 23, wireType 0 =*/184).uint32(message.userlist_merge_timeout);
            if (message.userlist_interval != null && Object.hasOwnProperty.call(message, "userlist_interval"))
                writer.uint32(/* id 24, wireType 0 =*/192).uint32(message.userlist_interval);
            if (message.room_session_id != null && Object.hasOwnProperty.call(message, "room_session_id"))
                writer.uint32(/* id 25, wireType 0 =*/200).uint64(message.room_session_id);
            if (message.trans_seqs != null && message.trans_seqs.length)
                for (var i = 0; i < message.trans_seqs.length; ++i)
                    $root.proto_switch.StTransInfo.encode(message.trans_seqs[i], writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
            if (message.stream_list_push_merge_timeout != null && Object.hasOwnProperty.call(message, "stream_list_push_merge_timeout"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint32(message.stream_list_push_merge_timeout);
            if (message.stream_list_hb_wait_merge_time != null && Object.hasOwnProperty.call(message, "stream_list_hb_wait_merge_time"))
                writer.uint32(/* id 28, wireType 0 =*/224).uint32(message.stream_list_hb_wait_merge_time);
            if (message.trans_list_seq != null && Object.hasOwnProperty.call(message, "trans_list_seq"))
                writer.uint32(/* id 29, wireType 0 =*/232).uint32(message.trans_list_seq);
            if (message.token_remain_time != null && Object.hasOwnProperty.call(message, "token_remain_time"))
                writer.uint32(/* id 30, wireType 0 =*/240).uint32(message.token_remain_time);
            return writer;
        };

        /**
         * Decodes a LoginRoomRsp message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.LoginRoomRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.LoginRoomRsp} LoginRoomRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginRoomRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.LoginRoomRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.proto_switch.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.room_id = reader.bytes();
                    break;
                case 3:
                    message.heartbeat_interval = reader.uint32();
                    break;
                case 4:
                    message.heartbeat_timeout = reader.uint32();
                    break;
                case 5:
                    message.ret_timestamp = reader.int64();
                    break;
                case 6:
                    message.crypt_option = reader.uint32();
                    break;
                case 7:
                    message.k2_sign = reader.bytes();
                    break;
                case 8:
                    message.liveroom_session_id = reader.uint64();
                    break;
                case 9:
                    message.liveroom_hb_interval = reader.uint32();
                    break;
                case 10:
                    message.liveroom_hb_timeout = reader.uint32();
                    break;
                case 11:
                    message.anchor_info = $root.proto_switch.StAnchorInfo.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.stream_seq = reader.uint32();
                    break;
                case 13:
                    if (!(message.stream_info && message.stream_info.length))
                        message.stream_info = [];
                    message.stream_info.push($root.proto_switch.StStreamInfo.decode(reader, reader.uint32()));
                    break;
                case 14:
                    message.stream_fetch_flag = reader.uint32();
                    break;
                case 15:
                    message.lv_key = reader.string();
                    break;
                case 16:
                    message.zp_key = reader.string();
                    break;
                case 17:
                    message.online_count = reader.uint32();
                    break;
                case 18:
                    message.bigim_time_window = reader.uint32();
                    break;
                case 19:
                    message.dati_time_window = reader.uint32();
                    break;
                case 20:
                    message.cluster_name = reader.string();
                    break;
                case 21:
                    message.relogin_token = reader.bytes();
                    break;
                case 22:
                    if (!(message.stream_mix_info && message.stream_mix_info.length))
                        message.stream_mix_info = [];
                    message.stream_mix_info.push($root.proto_switch.StStreamInfo.decode(reader, reader.uint32()));
                    break;
                case 23:
                    message.userlist_merge_timeout = reader.uint32();
                    break;
                case 24:
                    message.userlist_interval = reader.uint32();
                    break;
                case 25:
                    message.room_session_id = reader.uint64();
                    break;
                case 26:
                    if (!(message.trans_seqs && message.trans_seqs.length))
                        message.trans_seqs = [];
                    message.trans_seqs.push($root.proto_switch.StTransInfo.decode(reader, reader.uint32()));
                    break;
                case 27:
                    message.stream_list_push_merge_timeout = reader.uint32();
                    break;
                case 28:
                    message.stream_list_hb_wait_merge_time = reader.uint32();
                    break;
                case 29:
                    message.trans_list_seq = reader.uint32();
                    break;
                case 30:
                    message.token_remain_time = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return LoginRoomRsp;
    })();

    proto_switch.StAnchorInfo = (function() {

        /**
         * Properties of a StAnchorInfo.
         * @memberof proto_switch
         * @interface IStAnchorInfo
         * @property {Uint8Array|null} [anchor_id_name] StAnchorInfo anchor_id_name
         * @property {number|Long|null} [anchor_id] StAnchorInfo anchor_id
         * @property {Uint8Array|null} [anchor_nick_name] StAnchorInfo anchor_nick_name
         */

        /**
         * Constructs a new StAnchorInfo.
         * @memberof proto_switch
         * @classdesc Represents a StAnchorInfo.
         * @implements IStAnchorInfo
         * @constructor
         * @param {proto_switch.IStAnchorInfo=} [properties] Properties to set
         */
        function StAnchorInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StAnchorInfo anchor_id_name.
         * @member {Uint8Array} anchor_id_name
         * @memberof proto_switch.StAnchorInfo
         * @instance
         */
        StAnchorInfo.prototype.anchor_id_name = $util.newBuffer([]);

        /**
         * StAnchorInfo anchor_id.
         * @member {number|Long} anchor_id
         * @memberof proto_switch.StAnchorInfo
         * @instance
         */
        StAnchorInfo.prototype.anchor_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StAnchorInfo anchor_nick_name.
         * @member {Uint8Array} anchor_nick_name
         * @memberof proto_switch.StAnchorInfo
         * @instance
         */
        StAnchorInfo.prototype.anchor_nick_name = $util.newBuffer([]);

        /**
         * Creates a new StAnchorInfo instance using the specified properties.
         * @function create
         * @memberof proto_switch.StAnchorInfo
         * @static
         * @param {proto_switch.IStAnchorInfo=} [properties] Properties to set
         * @returns {proto_switch.StAnchorInfo} StAnchorInfo instance
         */
        StAnchorInfo.create = function create(properties) {
            return new StAnchorInfo(properties);
        };

        /**
         * Encodes the specified StAnchorInfo message. Does not implicitly {@link proto_switch.StAnchorInfo.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.StAnchorInfo
         * @static
         * @param {proto_switch.IStAnchorInfo} message StAnchorInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StAnchorInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.anchor_id_name != null && Object.hasOwnProperty.call(message, "anchor_id_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.anchor_id_name);
            if (message.anchor_id != null && Object.hasOwnProperty.call(message, "anchor_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.anchor_id);
            if (message.anchor_nick_name != null && Object.hasOwnProperty.call(message, "anchor_nick_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.anchor_nick_name);
            return writer;
        };

        /**
         * Decodes a StAnchorInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.StAnchorInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.StAnchorInfo} StAnchorInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StAnchorInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.StAnchorInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.anchor_id_name = reader.bytes();
                    break;
                case 2:
                    message.anchor_id = reader.uint64();
                    break;
                case 3:
                    message.anchor_nick_name = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StAnchorInfo;
    })();

    proto_switch.StStreamInfo = (function() {

        /**
         * Properties of a StStreamInfo.
         * @memberof proto_switch
         * @interface IStStreamInfo
         * @property {Uint8Array|null} [stream_id] StStreamInfo stream_id
         * @property {string|null} [stream_sid] StStreamInfo stream_sid
         * @property {Uint8Array|null} [id_name] StStreamInfo id_name
         * @property {Uint8Array|null} [nick_name] StStreamInfo nick_name
         * @property {number|Long|null} [create_time] StStreamInfo create_time
         * @property {Uint8Array|null} [extra_info] StStreamInfo extra_info
         * @property {Uint8Array|null} [title] StStreamInfo title
         * @property {number|null} [stream_ver] StStreamInfo stream_ver
         * @property {Uint8Array|null} [stream_attr] StStreamInfo stream_attr
         * @property {number|null} [stream_src] StStreamInfo stream_src
         * @property {number|null} [stream_state] StStreamInfo stream_state
         * @property {number|null} [stream_type] StStreamInfo stream_type
         * @property {number|null} [stream_nid] StStreamInfo stream_nid
         */

        /**
         * Constructs a new StStreamInfo.
         * @memberof proto_switch
         * @classdesc Represents a StStreamInfo.
         * @implements IStStreamInfo
         * @constructor
         * @param {proto_switch.IStStreamInfo=} [properties] Properties to set
         */
        function StStreamInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StStreamInfo stream_id.
         * @member {Uint8Array} stream_id
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_id = $util.newBuffer([]);

        /**
         * StStreamInfo stream_sid.
         * @member {string} stream_sid
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_sid = "";

        /**
         * StStreamInfo id_name.
         * @member {Uint8Array} id_name
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.id_name = $util.newBuffer([]);

        /**
         * StStreamInfo nick_name.
         * @member {Uint8Array} nick_name
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.nick_name = $util.newBuffer([]);

        /**
         * StStreamInfo create_time.
         * @member {number|Long} create_time
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.create_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StStreamInfo extra_info.
         * @member {Uint8Array} extra_info
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.extra_info = $util.newBuffer([]);

        /**
         * StStreamInfo title.
         * @member {Uint8Array} title
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.title = $util.newBuffer([]);

        /**
         * StStreamInfo stream_ver.
         * @member {number} stream_ver
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_ver = 0;

        /**
         * StStreamInfo stream_attr.
         * @member {Uint8Array} stream_attr
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_attr = $util.newBuffer([]);

        /**
         * StStreamInfo stream_src.
         * @member {number} stream_src
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_src = 0;

        /**
         * StStreamInfo stream_state.
         * @member {number} stream_state
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_state = 0;

        /**
         * StStreamInfo stream_type.
         * @member {number} stream_type
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_type = 0;

        /**
         * StStreamInfo stream_nid.
         * @member {number} stream_nid
         * @memberof proto_switch.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_nid = 0;

        /**
         * Creates a new StStreamInfo instance using the specified properties.
         * @function create
         * @memberof proto_switch.StStreamInfo
         * @static
         * @param {proto_switch.IStStreamInfo=} [properties] Properties to set
         * @returns {proto_switch.StStreamInfo} StStreamInfo instance
         */
        StStreamInfo.create = function create(properties) {
            return new StStreamInfo(properties);
        };

        /**
         * Encodes the specified StStreamInfo message. Does not implicitly {@link proto_switch.StStreamInfo.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.StStreamInfo
         * @static
         * @param {proto_switch.IStStreamInfo} message StStreamInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StStreamInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.stream_id);
            if (message.stream_sid != null && Object.hasOwnProperty.call(message, "stream_sid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.stream_sid);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.id_name);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.nick_name);
            if (message.create_time != null && Object.hasOwnProperty.call(message, "create_time"))
                writer.uint32(/* id 5, wireType 1 =*/41).fixed64(message.create_time);
            if (message.extra_info != null && Object.hasOwnProperty.call(message, "extra_info"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.extra_info);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.title);
            if (message.stream_ver != null && Object.hasOwnProperty.call(message, "stream_ver"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.stream_ver);
            if (message.stream_attr != null && Object.hasOwnProperty.call(message, "stream_attr"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.stream_attr);
            if (message.stream_src != null && Object.hasOwnProperty.call(message, "stream_src"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.stream_src);
            if (message.stream_state != null && Object.hasOwnProperty.call(message, "stream_state"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.stream_state);
            if (message.stream_type != null && Object.hasOwnProperty.call(message, "stream_type"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.stream_type);
            if (message.stream_nid != null && Object.hasOwnProperty.call(message, "stream_nid"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.stream_nid);
            return writer;
        };

        /**
         * Decodes a StStreamInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.StStreamInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.StStreamInfo} StStreamInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StStreamInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.StStreamInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stream_id = reader.bytes();
                    break;
                case 2:
                    message.stream_sid = reader.string();
                    break;
                case 3:
                    message.id_name = reader.bytes();
                    break;
                case 4:
                    message.nick_name = reader.bytes();
                    break;
                case 5:
                    message.create_time = reader.fixed64();
                    break;
                case 6:
                    message.extra_info = reader.bytes();
                    break;
                case 7:
                    message.title = reader.bytes();
                    break;
                case 8:
                    message.stream_ver = reader.uint32();
                    break;
                case 9:
                    message.stream_attr = reader.bytes();
                    break;
                case 10:
                    message.stream_src = reader.uint32();
                    break;
                case 11:
                    message.stream_state = reader.uint32();
                    break;
                case 12:
                    message.stream_type = reader.uint32();
                    break;
                case 13:
                    message.stream_nid = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StStreamInfo;
    })();

    proto_switch.StTransSeqInfo = (function() {

        /**
         * Properties of a StTransSeqInfo.
         * @memberof proto_switch
         * @interface IStTransSeqInfo
         * @property {Uint8Array|null} [trans_type] StTransSeqInfo trans_type
         * @property {number|null} [trans_seq] StTransSeqInfo trans_seq
         */

        /**
         * Constructs a new StTransSeqInfo.
         * @memberof proto_switch
         * @classdesc Represents a StTransSeqInfo.
         * @implements IStTransSeqInfo
         * @constructor
         * @param {proto_switch.IStTransSeqInfo=} [properties] Properties to set
         */
        function StTransSeqInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StTransSeqInfo trans_type.
         * @member {Uint8Array} trans_type
         * @memberof proto_switch.StTransSeqInfo
         * @instance
         */
        StTransSeqInfo.prototype.trans_type = $util.newBuffer([]);

        /**
         * StTransSeqInfo trans_seq.
         * @member {number} trans_seq
         * @memberof proto_switch.StTransSeqInfo
         * @instance
         */
        StTransSeqInfo.prototype.trans_seq = 0;

        /**
         * Creates a new StTransSeqInfo instance using the specified properties.
         * @function create
         * @memberof proto_switch.StTransSeqInfo
         * @static
         * @param {proto_switch.IStTransSeqInfo=} [properties] Properties to set
         * @returns {proto_switch.StTransSeqInfo} StTransSeqInfo instance
         */
        StTransSeqInfo.create = function create(properties) {
            return new StTransSeqInfo(properties);
        };

        /**
         * Encodes the specified StTransSeqInfo message. Does not implicitly {@link proto_switch.StTransSeqInfo.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.StTransSeqInfo
         * @static
         * @param {proto_switch.IStTransSeqInfo} message StTransSeqInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StTransSeqInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_type);
            if (message.trans_seq != null && Object.hasOwnProperty.call(message, "trans_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.trans_seq);
            return writer;
        };

        /**
         * Decodes a StTransSeqInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.StTransSeqInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.StTransSeqInfo} StTransSeqInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StTransSeqInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.StTransSeqInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_type = reader.bytes();
                    break;
                case 2:
                    message.trans_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StTransSeqInfo;
    })();

    proto_switch.StTransInfo = (function() {

        /**
         * Properties of a StTransInfo.
         * @memberof proto_switch
         * @interface IStTransInfo
         * @property {Uint8Array|null} [trans_channel] StTransInfo trans_channel
         * @property {Array.<proto_switch.IStTransSeqInfo>|null} [trans_seq_array] StTransInfo trans_seq_array
         */

        /**
         * Constructs a new StTransInfo.
         * @memberof proto_switch
         * @classdesc Represents a StTransInfo.
         * @implements IStTransInfo
         * @constructor
         * @param {proto_switch.IStTransInfo=} [properties] Properties to set
         */
        function StTransInfo(properties) {
            this.trans_seq_array = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StTransInfo trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof proto_switch.StTransInfo
         * @instance
         */
        StTransInfo.prototype.trans_channel = $util.newBuffer([]);

        /**
         * StTransInfo trans_seq_array.
         * @member {Array.<proto_switch.IStTransSeqInfo>} trans_seq_array
         * @memberof proto_switch.StTransInfo
         * @instance
         */
        StTransInfo.prototype.trans_seq_array = $util.emptyArray;

        /**
         * Creates a new StTransInfo instance using the specified properties.
         * @function create
         * @memberof proto_switch.StTransInfo
         * @static
         * @param {proto_switch.IStTransInfo=} [properties] Properties to set
         * @returns {proto_switch.StTransInfo} StTransInfo instance
         */
        StTransInfo.create = function create(properties) {
            return new StTransInfo(properties);
        };

        /**
         * Encodes the specified StTransInfo message. Does not implicitly {@link proto_switch.StTransInfo.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.StTransInfo
         * @static
         * @param {proto_switch.IStTransInfo} message StTransInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StTransInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_channel);
            if (message.trans_seq_array != null && message.trans_seq_array.length)
                for (var i = 0; i < message.trans_seq_array.length; ++i)
                    $root.proto_switch.StTransSeqInfo.encode(message.trans_seq_array[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a StTransInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.StTransInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.StTransInfo} StTransInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StTransInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.StTransInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_channel = reader.bytes();
                    break;
                case 2:
                    if (!(message.trans_seq_array && message.trans_seq_array.length))
                        message.trans_seq_array = [];
                    message.trans_seq_array.push($root.proto_switch.StTransSeqInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StTransInfo;
    })();

    proto_switch.LogoutRoomReq = (function() {

        /**
         * Properties of a LogoutRoomReq.
         * @memberof proto_switch
         * @interface ILogoutRoomReq
         * @property {number|null} [logout_code] LogoutRoomReq logout_code
         * @property {Uint8Array|null} [logout_check] LogoutRoomReq logout_check
         * @property {number|Long|null} [liveroom_session_id] LogoutRoomReq liveroom_session_id
         * @property {Uint8Array|null} [room_id] LogoutRoomReq room_id
         * @property {number|null} [role] LogoutRoomReq role
         * @property {Uint8Array|null} [nickname] LogoutRoomReq nickname
         * @property {number|null} [logout_logic] LogoutRoomReq logout_logic
         */

        /**
         * Constructs a new LogoutRoomReq.
         * @memberof proto_switch
         * @classdesc Represents a LogoutRoomReq.
         * @implements ILogoutRoomReq
         * @constructor
         * @param {proto_switch.ILogoutRoomReq=} [properties] Properties to set
         */
        function LogoutRoomReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LogoutRoomReq logout_code.
         * @member {number} logout_code
         * @memberof proto_switch.LogoutRoomReq
         * @instance
         */
        LogoutRoomReq.prototype.logout_code = 0;

        /**
         * LogoutRoomReq logout_check.
         * @member {Uint8Array} logout_check
         * @memberof proto_switch.LogoutRoomReq
         * @instance
         */
        LogoutRoomReq.prototype.logout_check = $util.newBuffer([]);

        /**
         * LogoutRoomReq liveroom_session_id.
         * @member {number|Long} liveroom_session_id
         * @memberof proto_switch.LogoutRoomReq
         * @instance
         */
        LogoutRoomReq.prototype.liveroom_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * LogoutRoomReq room_id.
         * @member {Uint8Array} room_id
         * @memberof proto_switch.LogoutRoomReq
         * @instance
         */
        LogoutRoomReq.prototype.room_id = $util.newBuffer([]);

        /**
         * LogoutRoomReq role.
         * @member {number} role
         * @memberof proto_switch.LogoutRoomReq
         * @instance
         */
        LogoutRoomReq.prototype.role = 0;

        /**
         * LogoutRoomReq nickname.
         * @member {Uint8Array} nickname
         * @memberof proto_switch.LogoutRoomReq
         * @instance
         */
        LogoutRoomReq.prototype.nickname = $util.newBuffer([]);

        /**
         * LogoutRoomReq logout_logic.
         * @member {number} logout_logic
         * @memberof proto_switch.LogoutRoomReq
         * @instance
         */
        LogoutRoomReq.prototype.logout_logic = 0;

        /**
         * Creates a new LogoutRoomReq instance using the specified properties.
         * @function create
         * @memberof proto_switch.LogoutRoomReq
         * @static
         * @param {proto_switch.ILogoutRoomReq=} [properties] Properties to set
         * @returns {proto_switch.LogoutRoomReq} LogoutRoomReq instance
         */
        LogoutRoomReq.create = function create(properties) {
            return new LogoutRoomReq(properties);
        };

        /**
         * Encodes the specified LogoutRoomReq message. Does not implicitly {@link proto_switch.LogoutRoomReq.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.LogoutRoomReq
         * @static
         * @param {proto_switch.ILogoutRoomReq} message LogoutRoomReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogoutRoomReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.logout_code != null && Object.hasOwnProperty.call(message, "logout_code"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.logout_code);
            if (message.logout_check != null && Object.hasOwnProperty.call(message, "logout_check"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.logout_check);
            if (message.liveroom_session_id != null && Object.hasOwnProperty.call(message, "liveroom_session_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.liveroom_session_id);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.room_id);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.role);
            if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.nickname);
            if (message.logout_logic != null && Object.hasOwnProperty.call(message, "logout_logic"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.logout_logic);
            return writer;
        };

        /**
         * Decodes a LogoutRoomReq message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.LogoutRoomReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.LogoutRoomReq} LogoutRoomReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogoutRoomReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.LogoutRoomReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.logout_code = reader.uint32();
                    break;
                case 2:
                    message.logout_check = reader.bytes();
                    break;
                case 3:
                    message.liveroom_session_id = reader.uint64();
                    break;
                case 4:
                    message.room_id = reader.bytes();
                    break;
                case 5:
                    message.role = reader.uint32();
                    break;
                case 6:
                    message.nickname = reader.bytes();
                    break;
                case 7:
                    message.logout_logic = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return LogoutRoomReq;
    })();

    proto_switch.LogoutRoomRsp = (function() {

        /**
         * Properties of a LogoutRoomRsp.
         * @memberof proto_switch
         * @interface ILogoutRoomRsp
         * @property {proto_switch.IRspHead|null} [rsp_head] LogoutRoomRsp rsp_head
         */

        /**
         * Constructs a new LogoutRoomRsp.
         * @memberof proto_switch
         * @classdesc Represents a LogoutRoomRsp.
         * @implements ILogoutRoomRsp
         * @constructor
         * @param {proto_switch.ILogoutRoomRsp=} [properties] Properties to set
         */
        function LogoutRoomRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LogoutRoomRsp rsp_head.
         * @member {proto_switch.IRspHead|null|undefined} rsp_head
         * @memberof proto_switch.LogoutRoomRsp
         * @instance
         */
        LogoutRoomRsp.prototype.rsp_head = null;

        /**
         * Creates a new LogoutRoomRsp instance using the specified properties.
         * @function create
         * @memberof proto_switch.LogoutRoomRsp
         * @static
         * @param {proto_switch.ILogoutRoomRsp=} [properties] Properties to set
         * @returns {proto_switch.LogoutRoomRsp} LogoutRoomRsp instance
         */
        LogoutRoomRsp.create = function create(properties) {
            return new LogoutRoomRsp(properties);
        };

        /**
         * Encodes the specified LogoutRoomRsp message. Does not implicitly {@link proto_switch.LogoutRoomRsp.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.LogoutRoomRsp
         * @static
         * @param {proto_switch.ILogoutRoomRsp} message LogoutRoomRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogoutRoomRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.proto_switch.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a LogoutRoomRsp message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.LogoutRoomRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.LogoutRoomRsp} LogoutRoomRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogoutRoomRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.LogoutRoomRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.proto_switch.RspHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return LogoutRoomRsp;
    })();

    proto_switch.TcpHbReq = (function() {

        /**
         * Properties of a TcpHbReq.
         * @memberof proto_switch
         * @interface ITcpHbReq
         * @property {Uint8Array|null} [id_name] TcpHbReq id_name
         */

        /**
         * Constructs a new TcpHbReq.
         * @memberof proto_switch
         * @classdesc Represents a TcpHbReq.
         * @implements ITcpHbReq
         * @constructor
         * @param {proto_switch.ITcpHbReq=} [properties] Properties to set
         */
        function TcpHbReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TcpHbReq id_name.
         * @member {Uint8Array} id_name
         * @memberof proto_switch.TcpHbReq
         * @instance
         */
        TcpHbReq.prototype.id_name = $util.newBuffer([]);

        /**
         * Creates a new TcpHbReq instance using the specified properties.
         * @function create
         * @memberof proto_switch.TcpHbReq
         * @static
         * @param {proto_switch.ITcpHbReq=} [properties] Properties to set
         * @returns {proto_switch.TcpHbReq} TcpHbReq instance
         */
        TcpHbReq.create = function create(properties) {
            return new TcpHbReq(properties);
        };

        /**
         * Encodes the specified TcpHbReq message. Does not implicitly {@link proto_switch.TcpHbReq.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.TcpHbReq
         * @static
         * @param {proto_switch.ITcpHbReq} message TcpHbReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TcpHbReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id_name);
            return writer;
        };

        /**
         * Decodes a TcpHbReq message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.TcpHbReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.TcpHbReq} TcpHbReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TcpHbReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.TcpHbReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id_name = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return TcpHbReq;
    })();

    proto_switch.TcpHbRsp = (function() {

        /**
         * Properties of a TcpHbRsp.
         * @memberof proto_switch
         * @interface ITcpHbRsp
         * @property {proto_switch.IRspHead|null} [rsp_head] TcpHbRsp rsp_head
         * @property {number|null} [heartbeat_interval] TcpHbRsp heartbeat_interval
         * @property {number|null} [heartbeat_timeout] TcpHbRsp heartbeat_timeout
         * @property {number|Long|null} [server_timestamp] TcpHbRsp server_timestamp
         */

        /**
         * Constructs a new TcpHbRsp.
         * @memberof proto_switch
         * @classdesc Represents a TcpHbRsp.
         * @implements ITcpHbRsp
         * @constructor
         * @param {proto_switch.ITcpHbRsp=} [properties] Properties to set
         */
        function TcpHbRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TcpHbRsp rsp_head.
         * @member {proto_switch.IRspHead|null|undefined} rsp_head
         * @memberof proto_switch.TcpHbRsp
         * @instance
         */
        TcpHbRsp.prototype.rsp_head = null;

        /**
         * TcpHbRsp heartbeat_interval.
         * @member {number} heartbeat_interval
         * @memberof proto_switch.TcpHbRsp
         * @instance
         */
        TcpHbRsp.prototype.heartbeat_interval = 0;

        /**
         * TcpHbRsp heartbeat_timeout.
         * @member {number} heartbeat_timeout
         * @memberof proto_switch.TcpHbRsp
         * @instance
         */
        TcpHbRsp.prototype.heartbeat_timeout = 0;

        /**
         * TcpHbRsp server_timestamp.
         * @member {number|Long} server_timestamp
         * @memberof proto_switch.TcpHbRsp
         * @instance
         */
        TcpHbRsp.prototype.server_timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TcpHbRsp instance using the specified properties.
         * @function create
         * @memberof proto_switch.TcpHbRsp
         * @static
         * @param {proto_switch.ITcpHbRsp=} [properties] Properties to set
         * @returns {proto_switch.TcpHbRsp} TcpHbRsp instance
         */
        TcpHbRsp.create = function create(properties) {
            return new TcpHbRsp(properties);
        };

        /**
         * Encodes the specified TcpHbRsp message. Does not implicitly {@link proto_switch.TcpHbRsp.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.TcpHbRsp
         * @static
         * @param {proto_switch.ITcpHbRsp} message TcpHbRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TcpHbRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.proto_switch.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.heartbeat_interval != null && Object.hasOwnProperty.call(message, "heartbeat_interval"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.heartbeat_interval);
            if (message.heartbeat_timeout != null && Object.hasOwnProperty.call(message, "heartbeat_timeout"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.heartbeat_timeout);
            if (message.server_timestamp != null && Object.hasOwnProperty.call(message, "server_timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.server_timestamp);
            return writer;
        };

        /**
         * Decodes a TcpHbRsp message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.TcpHbRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.TcpHbRsp} TcpHbRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TcpHbRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.TcpHbRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.proto_switch.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.heartbeat_interval = reader.uint32();
                    break;
                case 3:
                    message.heartbeat_timeout = reader.uint32();
                    break;
                case 4:
                    message.server_timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return TcpHbRsp;
    })();

    /**
     * TermType enum.
     * @name proto_switch.TermType
     * @enum {number}
     * @property {number} TT_NONE=0 TT_NONE value
     * @property {number} TT_PC=1 TT_PC value
     * @property {number} TT_IOS=2 TT_IOS value
     * @property {number} TT_ANDROID=3 TT_ANDROID value
     * @property {number} TT_MAC=4 TT_MAC value
     * @property {number} TT_LINUX=5 TT_LINUX value
     * @property {number} TT_WEB=6 TT_WEB value
     * @property {number} TT_MINIPROGRAM=7 TT_MINIPROGRAM value
     * @property {number} TT_UNKNOWN=32 TT_UNKNOWN value
     */
    proto_switch.TermType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TT_NONE"] = 0;
        values[valuesById[1] = "TT_PC"] = 1;
        values[valuesById[2] = "TT_IOS"] = 2;
        values[valuesById[3] = "TT_ANDROID"] = 3;
        values[valuesById[4] = "TT_MAC"] = 4;
        values[valuesById[5] = "TT_LINUX"] = 5;
        values[valuesById[6] = "TT_WEB"] = 6;
        values[valuesById[7] = "TT_MINIPROGRAM"] = 7;
        values[valuesById[32] = "TT_UNKNOWN"] = 32;
        return values;
    })();

    /**
     * NetType enum.
     * @name proto_switch.NetType
     * @enum {number}
     * @property {number} NT_NONE=0 NT_NONE value
     * @property {number} NT_LINE=1 NT_LINE value
     * @property {number} NT_WIFI=2 NT_WIFI value
     * @property {number} NT_2G=3 NT_2G value
     * @property {number} NT_3G=4 NT_3G value
     * @property {number} NT_4G=5 NT_4G value
     * @property {number} NT_UNKNOWN=32 NT_UNKNOWN value
     */
    proto_switch.NetType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NT_NONE"] = 0;
        values[valuesById[1] = "NT_LINE"] = 1;
        values[valuesById[2] = "NT_WIFI"] = 2;
        values[valuesById[3] = "NT_2G"] = 3;
        values[valuesById[4] = "NT_3G"] = 4;
        values[valuesById[5] = "NT_4G"] = 5;
        values[valuesById[32] = "NT_UNKNOWN"] = 32;
        return values;
    })();

    /**
     * ProductType enum.
     * @name proto_switch.ProductType
     * @enum {number}
     * @property {number} PRODUCT_TYPE_NONE=0 PRODUCT_TYPE_NONE value
     * @property {number} PRODUCT_TYPE_LIVEROOM=1 PRODUCT_TYPE_LIVEROOM value
     * @property {number} PRODUCT_TYPE_IM=2 PRODUCT_TYPE_IM value
     */
    proto_switch.ProductType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PRODUCT_TYPE_NONE"] = 0;
        values[valuesById[1] = "PRODUCT_TYPE_LIVEROOM"] = 1;
        values[valuesById[2] = "PRODUCT_TYPE_IM"] = 2;
        return values;
    })();

    /**
     * LiveroomProtoVersion enum.
     * @name proto_switch.LiveroomProtoVersion
     * @enum {number}
     * @property {number} PROTO_VERSION_NONE=0 PROTO_VERSION_NONE value
     * @property {number} RPOTO_V020000=131072 RPOTO_V020000 value
     */
    proto_switch.LiveroomProtoVersion = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PROTO_VERSION_NONE"] = 0;
        values[valuesById[131072] = "RPOTO_V020000"] = 131072;
        return values;
    })();

    /**
     * SdkConnType enum.
     * @name proto_switch.SdkConnType
     * @enum {number}
     * @property {number} SdkConnType_None=0 SdkConnType_None value
     * @property {number} SdkConnType_Tcp=1 SdkConnType_Tcp value
     * @property {number} SdkConnType_Websocket=2 SdkConnType_Websocket value
     */
    proto_switch.SdkConnType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SdkConnType_None"] = 0;
        values[valuesById[1] = "SdkConnType_Tcp"] = 1;
        values[valuesById[2] = "SdkConnType_Websocket"] = 2;
        return values;
    })();

    proto_switch.Header = (function() {

        /**
         * Properties of a Header.
         * @memberof proto_switch
         * @interface IHeader
         * @property {string|null} [cmd] Header cmd
         * @property {number|null} [seq] Header seq
         * @property {number|Long|null} [timestamp] Header timestamp
         * @property {number|null} [app_id] Header app_id
         * @property {string|null} [user_id] Header user_id
         * @property {number|Long|null} [session_id] Header session_id
         * @property {number|Long|null} [user_nid] Header user_nid
         * @property {Uint8Array|null} [controls] Header controls
         * @property {proto_switch.ProductType|null} [product] Header product
         * @property {Uint8Array|null} [flags] Header flags
         */

        /**
         * Constructs a new Header.
         * @memberof proto_switch
         * @classdesc Represents a Header.
         * @implements IHeader
         * @constructor
         * @param {proto_switch.IHeader=} [properties] Properties to set
         */
        function Header(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Header cmd.
         * @member {string} cmd
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.cmd = "";

        /**
         * Header seq.
         * @member {number} seq
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.seq = 0;

        /**
         * Header timestamp.
         * @member {number|Long} timestamp
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Header app_id.
         * @member {number} app_id
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.app_id = 0;

        /**
         * Header user_id.
         * @member {string} user_id
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.user_id = "";

        /**
         * Header session_id.
         * @member {number|Long} session_id
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.session_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Header user_nid.
         * @member {number|Long} user_nid
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.user_nid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Header controls.
         * @member {Uint8Array} controls
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.controls = $util.newBuffer([]);

        /**
         * Header product.
         * @member {proto_switch.ProductType} product
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.product = 0;

        /**
         * Header flags.
         * @member {Uint8Array} flags
         * @memberof proto_switch.Header
         * @instance
         */
        Header.prototype.flags = $util.newBuffer([]);

        /**
         * Creates a new Header instance using the specified properties.
         * @function create
         * @memberof proto_switch.Header
         * @static
         * @param {proto_switch.IHeader=} [properties] Properties to set
         * @returns {proto_switch.Header} Header instance
         */
        Header.create = function create(properties) {
            return new Header(properties);
        };

        /**
         * Encodes the specified Header message. Does not implicitly {@link proto_switch.Header.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.Header
         * @static
         * @param {proto_switch.IHeader} message Header message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Header.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cmd != null && Object.hasOwnProperty.call(message, "cmd"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cmd);
            if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.seq);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            if (message.app_id != null && Object.hasOwnProperty.call(message, "app_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.app_id);
            if (message.user_id != null && Object.hasOwnProperty.call(message, "user_id"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.user_id);
            if (message.session_id != null && Object.hasOwnProperty.call(message, "session_id"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.session_id);
            if (message.user_nid != null && Object.hasOwnProperty.call(message, "user_nid"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.user_nid);
            if (message.controls != null && Object.hasOwnProperty.call(message, "controls"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.controls);
            if (message.product != null && Object.hasOwnProperty.call(message, "product"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.product);
            if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.flags);
            return writer;
        };

        /**
         * Decodes a Header message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.Header
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.Header} Header
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Header.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.Header();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cmd = reader.string();
                    break;
                case 2:
                    message.seq = reader.uint32();
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                case 4:
                    message.app_id = reader.uint32();
                    break;
                case 5:
                    message.user_id = reader.string();
                    break;
                case 6:
                    message.session_id = reader.int64();
                    break;
                case 7:
                    message.user_nid = reader.int64();
                    break;
                case 8:
                    message.controls = reader.bytes();
                    break;
                case 9:
                    message.product = reader.int32();
                    break;
                case 10:
                    message.flags = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return Header;
    })();

    proto_switch.PushKickout = (function() {

        /**
         * Properties of a PushKickout.
         * @memberof proto_switch
         * @interface IPushKickout
         * @property {number|null} [reason] PushKickout reason
         * @property {string|null} [message] PushKickout message
         * @property {number|null} [need_relogin] PushKickout need_relogin
         */

        /**
         * Constructs a new PushKickout.
         * @memberof proto_switch
         * @classdesc Represents a PushKickout.
         * @implements IPushKickout
         * @constructor
         * @param {proto_switch.IPushKickout=} [properties] Properties to set
         */
        function PushKickout(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushKickout reason.
         * @member {number} reason
         * @memberof proto_switch.PushKickout
         * @instance
         */
        PushKickout.prototype.reason = 0;

        /**
         * PushKickout message.
         * @member {string} message
         * @memberof proto_switch.PushKickout
         * @instance
         */
        PushKickout.prototype.message = "";

        /**
         * PushKickout need_relogin.
         * @member {number} need_relogin
         * @memberof proto_switch.PushKickout
         * @instance
         */
        PushKickout.prototype.need_relogin = 0;

        /**
         * Creates a new PushKickout instance using the specified properties.
         * @function create
         * @memberof proto_switch.PushKickout
         * @static
         * @param {proto_switch.IPushKickout=} [properties] Properties to set
         * @returns {proto_switch.PushKickout} PushKickout instance
         */
        PushKickout.create = function create(properties) {
            return new PushKickout(properties);
        };

        /**
         * Encodes the specified PushKickout message. Does not implicitly {@link proto_switch.PushKickout.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.PushKickout
         * @static
         * @param {proto_switch.IPushKickout} message PushKickout message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushKickout.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.reason);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            if (message.need_relogin != null && Object.hasOwnProperty.call(message, "need_relogin"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.need_relogin);
            return writer;
        };

        /**
         * Decodes a PushKickout message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.PushKickout
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.PushKickout} PushKickout
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushKickout.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.PushKickout();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reason = reader.uint32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.need_relogin = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushKickout;
    })();

    proto_switch.PushRedirect2Sdk = (function() {

        /**
         * Properties of a PushRedirect2Sdk.
         * @memberof proto_switch
         * @interface IPushRedirect2Sdk
         * @property {Array.<string>|null} [redirect_server] PushRedirect2Sdk redirect_server
         */

        /**
         * Constructs a new PushRedirect2Sdk.
         * @memberof proto_switch
         * @classdesc Represents a PushRedirect2Sdk.
         * @implements IPushRedirect2Sdk
         * @constructor
         * @param {proto_switch.IPushRedirect2Sdk=} [properties] Properties to set
         */
        function PushRedirect2Sdk(properties) {
            this.redirect_server = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushRedirect2Sdk redirect_server.
         * @member {Array.<string>} redirect_server
         * @memberof proto_switch.PushRedirect2Sdk
         * @instance
         */
        PushRedirect2Sdk.prototype.redirect_server = $util.emptyArray;

        /**
         * Creates a new PushRedirect2Sdk instance using the specified properties.
         * @function create
         * @memberof proto_switch.PushRedirect2Sdk
         * @static
         * @param {proto_switch.IPushRedirect2Sdk=} [properties] Properties to set
         * @returns {proto_switch.PushRedirect2Sdk} PushRedirect2Sdk instance
         */
        PushRedirect2Sdk.create = function create(properties) {
            return new PushRedirect2Sdk(properties);
        };

        /**
         * Encodes the specified PushRedirect2Sdk message. Does not implicitly {@link proto_switch.PushRedirect2Sdk.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.PushRedirect2Sdk
         * @static
         * @param {proto_switch.IPushRedirect2Sdk} message PushRedirect2Sdk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushRedirect2Sdk.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.redirect_server != null && message.redirect_server.length)
                for (var i = 0; i < message.redirect_server.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.redirect_server[i]);
            return writer;
        };

        /**
         * Decodes a PushRedirect2Sdk message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.PushRedirect2Sdk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.PushRedirect2Sdk} PushRedirect2Sdk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushRedirect2Sdk.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.PushRedirect2Sdk();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.redirect_server && message.redirect_server.length))
                        message.redirect_server = [];
                    message.redirect_server.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushRedirect2Sdk;
    })();

    proto_switch.PushReq = (function() {

        /**
         * Properties of a PushReq.
         * @memberof proto_switch
         * @interface IPushReq
         * @property {proto_switch.IPushReqHead|null} [head] PushReq head
         * @property {Uint8Array|null} [msg_body] PushReq msg_body
         */

        /**
         * Constructs a new PushReq.
         * @memberof proto_switch
         * @classdesc Represents a PushReq.
         * @implements IPushReq
         * @constructor
         * @param {proto_switch.IPushReq=} [properties] Properties to set
         */
        function PushReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushReq head.
         * @member {proto_switch.IPushReqHead|null|undefined} head
         * @memberof proto_switch.PushReq
         * @instance
         */
        PushReq.prototype.head = null;

        /**
         * PushReq msg_body.
         * @member {Uint8Array} msg_body
         * @memberof proto_switch.PushReq
         * @instance
         */
        PushReq.prototype.msg_body = $util.newBuffer([]);

        /**
         * Creates a new PushReq instance using the specified properties.
         * @function create
         * @memberof proto_switch.PushReq
         * @static
         * @param {proto_switch.IPushReq=} [properties] Properties to set
         * @returns {proto_switch.PushReq} PushReq instance
         */
        PushReq.create = function create(properties) {
            return new PushReq(properties);
        };

        /**
         * Encodes the specified PushReq message. Does not implicitly {@link proto_switch.PushReq.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.PushReq
         * @static
         * @param {proto_switch.IPushReq} message PushReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.head != null && Object.hasOwnProperty.call(message, "head"))
                $root.proto_switch.PushReqHead.encode(message.head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.msg_body != null && Object.hasOwnProperty.call(message, "msg_body"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.msg_body);
            return writer;
        };

        /**
         * Decodes a PushReq message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.PushReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.PushReq} PushReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.PushReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.head = $root.proto_switch.PushReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.msg_body = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushReq;
    })();

    proto_switch.PushReqHead = (function() {

        /**
         * Properties of a PushReqHead.
         * @memberof proto_switch
         * @interface IPushReqHead
         * @property {string|null} [sub_cmd] PushReqHead sub_cmd
         * @property {string|null} [sender_user_id] PushReqHead sender_user_id
         * @property {number|null} [qos_flag] PushReqHead qos_flag
         * @property {string|null} [msg_id] PushReqHead msg_id
         * @property {number|Long|null} [send_time] PushReqHead send_time
         * @property {Uint8Array|null} [room_id] PushReqHead room_id
         * @property {number|Long|null} [sender_user_nid] PushReqHead sender_user_nid
         */

        /**
         * Constructs a new PushReqHead.
         * @memberof proto_switch
         * @classdesc Represents a PushReqHead.
         * @implements IPushReqHead
         * @constructor
         * @param {proto_switch.IPushReqHead=} [properties] Properties to set
         */
        function PushReqHead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushReqHead sub_cmd.
         * @member {string} sub_cmd
         * @memberof proto_switch.PushReqHead
         * @instance
         */
        PushReqHead.prototype.sub_cmd = "";

        /**
         * PushReqHead sender_user_id.
         * @member {string} sender_user_id
         * @memberof proto_switch.PushReqHead
         * @instance
         */
        PushReqHead.prototype.sender_user_id = "";

        /**
         * PushReqHead qos_flag.
         * @member {number} qos_flag
         * @memberof proto_switch.PushReqHead
         * @instance
         */
        PushReqHead.prototype.qos_flag = 0;

        /**
         * PushReqHead msg_id.
         * @member {string} msg_id
         * @memberof proto_switch.PushReqHead
         * @instance
         */
        PushReqHead.prototype.msg_id = "";

        /**
         * PushReqHead send_time.
         * @member {number|Long} send_time
         * @memberof proto_switch.PushReqHead
         * @instance
         */
        PushReqHead.prototype.send_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PushReqHead room_id.
         * @member {Uint8Array} room_id
         * @memberof proto_switch.PushReqHead
         * @instance
         */
        PushReqHead.prototype.room_id = $util.newBuffer([]);

        /**
         * PushReqHead sender_user_nid.
         * @member {number|Long} sender_user_nid
         * @memberof proto_switch.PushReqHead
         * @instance
         */
        PushReqHead.prototype.sender_user_nid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new PushReqHead instance using the specified properties.
         * @function create
         * @memberof proto_switch.PushReqHead
         * @static
         * @param {proto_switch.IPushReqHead=} [properties] Properties to set
         * @returns {proto_switch.PushReqHead} PushReqHead instance
         */
        PushReqHead.create = function create(properties) {
            return new PushReqHead(properties);
        };

        /**
         * Encodes the specified PushReqHead message. Does not implicitly {@link proto_switch.PushReqHead.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.PushReqHead
         * @static
         * @param {proto_switch.IPushReqHead} message PushReqHead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushReqHead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sub_cmd != null && Object.hasOwnProperty.call(message, "sub_cmd"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sub_cmd);
            if (message.sender_user_id != null && Object.hasOwnProperty.call(message, "sender_user_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.sender_user_id);
            if (message.qos_flag != null && Object.hasOwnProperty.call(message, "qos_flag"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.qos_flag);
            if (message.msg_id != null && Object.hasOwnProperty.call(message, "msg_id"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.msg_id);
            if (message.send_time != null && Object.hasOwnProperty.call(message, "send_time"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.send_time);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.room_id);
            if (message.sender_user_nid != null && Object.hasOwnProperty.call(message, "sender_user_nid"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.sender_user_nid);
            return writer;
        };

        /**
         * Decodes a PushReqHead message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.PushReqHead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.PushReqHead} PushReqHead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushReqHead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.PushReqHead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sub_cmd = reader.string();
                    break;
                case 2:
                    message.sender_user_id = reader.string();
                    break;
                case 3:
                    message.qos_flag = reader.uint32();
                    break;
                case 4:
                    message.msg_id = reader.string();
                    break;
                case 5:
                    message.send_time = reader.int64();
                    break;
                case 6:
                    message.room_id = reader.bytes();
                    break;
                case 7:
                    message.sender_user_nid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushReqHead;
    })();

    proto_switch.PushRsp = (function() {

        /**
         * Properties of a PushRsp.
         * @memberof proto_switch
         * @interface IPushRsp
         * @property {number|null} [code] PushRsp code
         * @property {string|null} [message] PushRsp message
         * @property {string|null} [sub_cmd] PushRsp sub_cmd
         * @property {string|null} [msg_id] PushRsp msg_id
         * @property {number|Long|null} [server_send_time] PushRsp server_send_time
         */

        /**
         * Constructs a new PushRsp.
         * @memberof proto_switch
         * @classdesc Represents a PushRsp.
         * @implements IPushRsp
         * @constructor
         * @param {proto_switch.IPushRsp=} [properties] Properties to set
         */
        function PushRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushRsp code.
         * @member {number} code
         * @memberof proto_switch.PushRsp
         * @instance
         */
        PushRsp.prototype.code = 0;

        /**
         * PushRsp message.
         * @member {string} message
         * @memberof proto_switch.PushRsp
         * @instance
         */
        PushRsp.prototype.message = "";

        /**
         * PushRsp sub_cmd.
         * @member {string} sub_cmd
         * @memberof proto_switch.PushRsp
         * @instance
         */
        PushRsp.prototype.sub_cmd = "";

        /**
         * PushRsp msg_id.
         * @member {string} msg_id
         * @memberof proto_switch.PushRsp
         * @instance
         */
        PushRsp.prototype.msg_id = "";

        /**
         * PushRsp server_send_time.
         * @member {number|Long} server_send_time
         * @memberof proto_switch.PushRsp
         * @instance
         */
        PushRsp.prototype.server_send_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PushRsp instance using the specified properties.
         * @function create
         * @memberof proto_switch.PushRsp
         * @static
         * @param {proto_switch.IPushRsp=} [properties] Properties to set
         * @returns {proto_switch.PushRsp} PushRsp instance
         */
        PushRsp.create = function create(properties) {
            return new PushRsp(properties);
        };

        /**
         * Encodes the specified PushRsp message. Does not implicitly {@link proto_switch.PushRsp.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.PushRsp
         * @static
         * @param {proto_switch.IPushRsp} message PushRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.code);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            if (message.sub_cmd != null && Object.hasOwnProperty.call(message, "sub_cmd"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.sub_cmd);
            if (message.msg_id != null && Object.hasOwnProperty.call(message, "msg_id"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.msg_id);
            if (message.server_send_time != null && Object.hasOwnProperty.call(message, "server_send_time"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.server_send_time);
            return writer;
        };

        /**
         * Decodes a PushRsp message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.PushRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.PushRsp} PushRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.PushRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.uint32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.sub_cmd = reader.string();
                    break;
                case 4:
                    message.msg_id = reader.string();
                    break;
                case 5:
                    message.server_send_time = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushRsp;
    })();

    proto_switch.MergePushHead = (function() {

        /**
         * Properties of a MergePushHead.
         * @memberof proto_switch
         * @interface IMergePushHead
         * @property {number|null} [qos_flag] MergePushHead qos_flag
         * @property {number|Long|null} [send_time] MergePushHead send_time
         * @property {Uint8Array|null} [room_id] MergePushHead room_id
         */

        /**
         * Constructs a new MergePushHead.
         * @memberof proto_switch
         * @classdesc Represents a MergePushHead.
         * @implements IMergePushHead
         * @constructor
         * @param {proto_switch.IMergePushHead=} [properties] Properties to set
         */
        function MergePushHead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MergePushHead qos_flag.
         * @member {number} qos_flag
         * @memberof proto_switch.MergePushHead
         * @instance
         */
        MergePushHead.prototype.qos_flag = 0;

        /**
         * MergePushHead send_time.
         * @member {number|Long} send_time
         * @memberof proto_switch.MergePushHead
         * @instance
         */
        MergePushHead.prototype.send_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MergePushHead room_id.
         * @member {Uint8Array} room_id
         * @memberof proto_switch.MergePushHead
         * @instance
         */
        MergePushHead.prototype.room_id = $util.newBuffer([]);

        /**
         * Creates a new MergePushHead instance using the specified properties.
         * @function create
         * @memberof proto_switch.MergePushHead
         * @static
         * @param {proto_switch.IMergePushHead=} [properties] Properties to set
         * @returns {proto_switch.MergePushHead} MergePushHead instance
         */
        MergePushHead.create = function create(properties) {
            return new MergePushHead(properties);
        };

        /**
         * Encodes the specified MergePushHead message. Does not implicitly {@link proto_switch.MergePushHead.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.MergePushHead
         * @static
         * @param {proto_switch.IMergePushHead} message MergePushHead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MergePushHead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.qos_flag != null && Object.hasOwnProperty.call(message, "qos_flag"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.qos_flag);
            if (message.send_time != null && Object.hasOwnProperty.call(message, "send_time"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.send_time);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.room_id);
            return writer;
        };

        /**
         * Decodes a MergePushHead message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.MergePushHead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.MergePushHead} MergePushHead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MergePushHead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.MergePushHead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.qos_flag = reader.uint32();
                    break;
                case 2:
                    message.send_time = reader.int64();
                    break;
                case 3:
                    message.room_id = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MergePushHead;
    })();

    proto_switch.MergePushInfo = (function() {

        /**
         * Properties of a MergePushInfo.
         * @memberof proto_switch
         * @interface IMergePushInfo
         * @property {string|null} [sub_cmd] MergePushInfo sub_cmd
         * @property {number|null} [sub_seq] MergePushInfo sub_seq
         * @property {number|Long|null} [sender_nid] MergePushInfo sender_nid
         * @property {Uint8Array|null} [msg_id] MergePushInfo msg_id
         * @property {Uint8Array|null} [msg_body] MergePushInfo msg_body
         * @property {number|Long|null} [msg_timestamp] MergePushInfo msg_timestamp
         */

        /**
         * Constructs a new MergePushInfo.
         * @memberof proto_switch
         * @classdesc Represents a MergePushInfo.
         * @implements IMergePushInfo
         * @constructor
         * @param {proto_switch.IMergePushInfo=} [properties] Properties to set
         */
        function MergePushInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MergePushInfo sub_cmd.
         * @member {string} sub_cmd
         * @memberof proto_switch.MergePushInfo
         * @instance
         */
        MergePushInfo.prototype.sub_cmd = "";

        /**
         * MergePushInfo sub_seq.
         * @member {number} sub_seq
         * @memberof proto_switch.MergePushInfo
         * @instance
         */
        MergePushInfo.prototype.sub_seq = 0;

        /**
         * MergePushInfo sender_nid.
         * @member {number|Long} sender_nid
         * @memberof proto_switch.MergePushInfo
         * @instance
         */
        MergePushInfo.prototype.sender_nid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * MergePushInfo msg_id.
         * @member {Uint8Array} msg_id
         * @memberof proto_switch.MergePushInfo
         * @instance
         */
        MergePushInfo.prototype.msg_id = $util.newBuffer([]);

        /**
         * MergePushInfo msg_body.
         * @member {Uint8Array} msg_body
         * @memberof proto_switch.MergePushInfo
         * @instance
         */
        MergePushInfo.prototype.msg_body = $util.newBuffer([]);

        /**
         * MergePushInfo msg_timestamp.
         * @member {number|Long} msg_timestamp
         * @memberof proto_switch.MergePushInfo
         * @instance
         */
        MergePushInfo.prototype.msg_timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new MergePushInfo instance using the specified properties.
         * @function create
         * @memberof proto_switch.MergePushInfo
         * @static
         * @param {proto_switch.IMergePushInfo=} [properties] Properties to set
         * @returns {proto_switch.MergePushInfo} MergePushInfo instance
         */
        MergePushInfo.create = function create(properties) {
            return new MergePushInfo(properties);
        };

        /**
         * Encodes the specified MergePushInfo message. Does not implicitly {@link proto_switch.MergePushInfo.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.MergePushInfo
         * @static
         * @param {proto_switch.IMergePushInfo} message MergePushInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MergePushInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sub_cmd != null && Object.hasOwnProperty.call(message, "sub_cmd"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sub_cmd);
            if (message.sub_seq != null && Object.hasOwnProperty.call(message, "sub_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sub_seq);
            if (message.sender_nid != null && Object.hasOwnProperty.call(message, "sender_nid"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.sender_nid);
            if (message.msg_id != null && Object.hasOwnProperty.call(message, "msg_id"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.msg_id);
            if (message.msg_body != null && Object.hasOwnProperty.call(message, "msg_body"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.msg_body);
            if (message.msg_timestamp != null && Object.hasOwnProperty.call(message, "msg_timestamp"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.msg_timestamp);
            return writer;
        };

        /**
         * Decodes a MergePushInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.MergePushInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.MergePushInfo} MergePushInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MergePushInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.MergePushInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sub_cmd = reader.string();
                    break;
                case 2:
                    message.sub_seq = reader.uint32();
                    break;
                case 3:
                    message.sender_nid = reader.uint64();
                    break;
                case 4:
                    message.msg_id = reader.bytes();
                    break;
                case 5:
                    message.msg_body = reader.bytes();
                    break;
                case 6:
                    message.msg_timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return MergePushInfo;
    })();

    proto_switch.CmdMergePushReq = (function() {

        /**
         * Properties of a CmdMergePushReq.
         * @memberof proto_switch
         * @interface ICmdMergePushReq
         * @property {proto_switch.IMergePushHead|null} [head] CmdMergePushReq head
         * @property {Array.<proto_switch.IMergePushInfo>|null} [messages] CmdMergePushReq messages
         */

        /**
         * Constructs a new CmdMergePushReq.
         * @memberof proto_switch
         * @classdesc Represents a CmdMergePushReq.
         * @implements ICmdMergePushReq
         * @constructor
         * @param {proto_switch.ICmdMergePushReq=} [properties] Properties to set
         */
        function CmdMergePushReq(properties) {
            this.messages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CmdMergePushReq head.
         * @member {proto_switch.IMergePushHead|null|undefined} head
         * @memberof proto_switch.CmdMergePushReq
         * @instance
         */
        CmdMergePushReq.prototype.head = null;

        /**
         * CmdMergePushReq messages.
         * @member {Array.<proto_switch.IMergePushInfo>} messages
         * @memberof proto_switch.CmdMergePushReq
         * @instance
         */
        CmdMergePushReq.prototype.messages = $util.emptyArray;

        /**
         * Creates a new CmdMergePushReq instance using the specified properties.
         * @function create
         * @memberof proto_switch.CmdMergePushReq
         * @static
         * @param {proto_switch.ICmdMergePushReq=} [properties] Properties to set
         * @returns {proto_switch.CmdMergePushReq} CmdMergePushReq instance
         */
        CmdMergePushReq.create = function create(properties) {
            return new CmdMergePushReq(properties);
        };

        /**
         * Encodes the specified CmdMergePushReq message. Does not implicitly {@link proto_switch.CmdMergePushReq.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.CmdMergePushReq
         * @static
         * @param {proto_switch.ICmdMergePushReq} message CmdMergePushReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CmdMergePushReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.head != null && Object.hasOwnProperty.call(message, "head"))
                $root.proto_switch.MergePushHead.encode(message.head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.proto_switch.MergePushInfo.encode(message.messages[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a CmdMergePushReq message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.CmdMergePushReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.CmdMergePushReq} CmdMergePushReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CmdMergePushReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.CmdMergePushReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.head = $root.proto_switch.MergePushHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push($root.proto_switch.MergePushInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return CmdMergePushReq;
    })();

    proto_switch.CmdMergePushRspInfo = (function() {

        /**
         * Properties of a CmdMergePushRspInfo.
         * @memberof proto_switch
         * @interface ICmdMergePushRspInfo
         * @property {string|null} [sub_cmd] CmdMergePushRspInfo sub_cmd
         * @property {number|null} [sub_seq] CmdMergePushRspInfo sub_seq
         * @property {Uint8Array|null} [msg_id] CmdMergePushRspInfo msg_id
         */

        /**
         * Constructs a new CmdMergePushRspInfo.
         * @memberof proto_switch
         * @classdesc Represents a CmdMergePushRspInfo.
         * @implements ICmdMergePushRspInfo
         * @constructor
         * @param {proto_switch.ICmdMergePushRspInfo=} [properties] Properties to set
         */
        function CmdMergePushRspInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CmdMergePushRspInfo sub_cmd.
         * @member {string} sub_cmd
         * @memberof proto_switch.CmdMergePushRspInfo
         * @instance
         */
        CmdMergePushRspInfo.prototype.sub_cmd = "";

        /**
         * CmdMergePushRspInfo sub_seq.
         * @member {number} sub_seq
         * @memberof proto_switch.CmdMergePushRspInfo
         * @instance
         */
        CmdMergePushRspInfo.prototype.sub_seq = 0;

        /**
         * CmdMergePushRspInfo msg_id.
         * @member {Uint8Array} msg_id
         * @memberof proto_switch.CmdMergePushRspInfo
         * @instance
         */
        CmdMergePushRspInfo.prototype.msg_id = $util.newBuffer([]);

        /**
         * Creates a new CmdMergePushRspInfo instance using the specified properties.
         * @function create
         * @memberof proto_switch.CmdMergePushRspInfo
         * @static
         * @param {proto_switch.ICmdMergePushRspInfo=} [properties] Properties to set
         * @returns {proto_switch.CmdMergePushRspInfo} CmdMergePushRspInfo instance
         */
        CmdMergePushRspInfo.create = function create(properties) {
            return new CmdMergePushRspInfo(properties);
        };

        /**
         * Encodes the specified CmdMergePushRspInfo message. Does not implicitly {@link proto_switch.CmdMergePushRspInfo.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.CmdMergePushRspInfo
         * @static
         * @param {proto_switch.ICmdMergePushRspInfo} message CmdMergePushRspInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CmdMergePushRspInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sub_cmd != null && Object.hasOwnProperty.call(message, "sub_cmd"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.sub_cmd);
            if (message.sub_seq != null && Object.hasOwnProperty.call(message, "sub_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sub_seq);
            if (message.msg_id != null && Object.hasOwnProperty.call(message, "msg_id"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.msg_id);
            return writer;
        };

        /**
         * Decodes a CmdMergePushRspInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.CmdMergePushRspInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.CmdMergePushRspInfo} CmdMergePushRspInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CmdMergePushRspInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.CmdMergePushRspInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sub_cmd = reader.string();
                    break;
                case 2:
                    message.sub_seq = reader.uint32();
                    break;
                case 3:
                    message.msg_id = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return CmdMergePushRspInfo;
    })();

    proto_switch.CmdMergePushRsp = (function() {

        /**
         * Properties of a CmdMergePushRsp.
         * @memberof proto_switch
         * @interface ICmdMergePushRsp
         * @property {Array.<proto_switch.ICmdMergePushRspInfo>|null} [messages] CmdMergePushRsp messages
         */

        /**
         * Constructs a new CmdMergePushRsp.
         * @memberof proto_switch
         * @classdesc Represents a CmdMergePushRsp.
         * @implements ICmdMergePushRsp
         * @constructor
         * @param {proto_switch.ICmdMergePushRsp=} [properties] Properties to set
         */
        function CmdMergePushRsp(properties) {
            this.messages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CmdMergePushRsp messages.
         * @member {Array.<proto_switch.ICmdMergePushRspInfo>} messages
         * @memberof proto_switch.CmdMergePushRsp
         * @instance
         */
        CmdMergePushRsp.prototype.messages = $util.emptyArray;

        /**
         * Creates a new CmdMergePushRsp instance using the specified properties.
         * @function create
         * @memberof proto_switch.CmdMergePushRsp
         * @static
         * @param {proto_switch.ICmdMergePushRsp=} [properties] Properties to set
         * @returns {proto_switch.CmdMergePushRsp} CmdMergePushRsp instance
         */
        CmdMergePushRsp.create = function create(properties) {
            return new CmdMergePushRsp(properties);
        };

        /**
         * Encodes the specified CmdMergePushRsp message. Does not implicitly {@link proto_switch.CmdMergePushRsp.verify|verify} messages.
         * @function encode
         * @memberof proto_switch.CmdMergePushRsp
         * @static
         * @param {proto_switch.ICmdMergePushRsp} message CmdMergePushRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CmdMergePushRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.proto_switch.CmdMergePushRspInfo.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a CmdMergePushRsp message from the specified reader or buffer.
         * @function decode
         * @memberof proto_switch.CmdMergePushRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto_switch.CmdMergePushRsp} CmdMergePushRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CmdMergePushRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto_switch.CmdMergePushRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push($root.proto_switch.CmdMergePushRspInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return CmdMergePushRsp;
    })();

    return proto_switch;
})();

$root.liveroom_cs = (function() {

    /**
     * Namespace liveroom_cs.
     * @exports liveroom_cs
     * @namespace
     */
    var liveroom_cs = {};

    liveroom_cs.ReqHead = (function() {

        /**
         * Properties of a ReqHead.
         * @memberof liveroom_cs
         * @interface IReqHead
         * @property {string|null} [room_id] ReqHead room_id
         * @property {number|Long|null} [user_session_id] ReqHead user_session_id
         * @property {number|Long|null} [room_session_id] ReqHead room_session_id
         */

        /**
         * Constructs a new ReqHead.
         * @memberof liveroom_cs
         * @classdesc -title:liveroom_pb
         * @implements IReqHead
         * @constructor
         * @param {liveroom_cs.IReqHead=} [properties] Properties to set
         */
        function ReqHead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReqHead room_id.
         * @member {string} room_id
         * @memberof liveroom_cs.ReqHead
         * @instance
         */
        ReqHead.prototype.room_id = "";

        /**
         * ReqHead user_session_id.
         * @member {number|Long} user_session_id
         * @memberof liveroom_cs.ReqHead
         * @instance
         */
        ReqHead.prototype.user_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ReqHead room_session_id.
         * @member {number|Long} room_session_id
         * @memberof liveroom_cs.ReqHead
         * @instance
         */
        ReqHead.prototype.room_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ReqHead instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.ReqHead
         * @static
         * @param {liveroom_cs.IReqHead=} [properties] Properties to set
         * @returns {liveroom_cs.ReqHead} ReqHead instance
         */
        ReqHead.create = function create(properties) {
            return new ReqHead(properties);
        };

        /**
         * Encodes the specified ReqHead message. Does not implicitly {@link liveroom_cs.ReqHead.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.ReqHead
         * @static
         * @param {liveroom_cs.IReqHead} message ReqHead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReqHead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.room_id);
            if (message.user_session_id != null && Object.hasOwnProperty.call(message, "user_session_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.user_session_id);
            if (message.room_session_id != null && Object.hasOwnProperty.call(message, "room_session_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.room_session_id);
            return writer;
        };

        /**
         * Decodes a ReqHead message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.ReqHead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.ReqHead} ReqHead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReqHead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.ReqHead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.room_id = reader.string();
                    break;
                case 2:
                    message.user_session_id = reader.uint64();
                    break;
                case 3:
                    message.room_session_id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ReqHead;
    })();

    liveroom_cs.RspHead = (function() {

        /**
         * Properties of a RspHead.
         * @memberof liveroom_cs
         * @interface IRspHead
         * @property {number|null} [code] RspHead code
         * @property {string|null} [message] RspHead message
         */

        /**
         * Constructs a new RspHead.
         * @memberof liveroom_cs
         * @classdesc -title:liveroom_pb
         * @implements IRspHead
         * @constructor
         * @param {liveroom_cs.IRspHead=} [properties] Properties to set
         */
        function RspHead(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RspHead code.
         * @member {number} code
         * @memberof liveroom_cs.RspHead
         * @instance
         */
        RspHead.prototype.code = 0;

        /**
         * RspHead message.
         * @member {string} message
         * @memberof liveroom_cs.RspHead
         * @instance
         */
        RspHead.prototype.message = "";

        /**
         * Creates a new RspHead instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.RspHead
         * @static
         * @param {liveroom_cs.IRspHead=} [properties] Properties to set
         * @returns {liveroom_cs.RspHead} RspHead instance
         */
        RspHead.create = function create(properties) {
            return new RspHead(properties);
        };

        /**
         * Encodes the specified RspHead message. Does not implicitly {@link liveroom_cs.RspHead.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.RspHead
         * @static
         * @param {liveroom_cs.IRspHead} message RspHead message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RspHead.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.code);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            return writer;
        };

        /**
         * Decodes a RspHead message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.RspHead
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.RspHead} RspHead
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RspHead.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.RspHead();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.uint32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RspHead;
    })();

    liveroom_cs.CommonRsp = (function() {

        /**
         * Properties of a CommonRsp.
         * @memberof liveroom_cs
         * @interface ICommonRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] CommonRsp rsp_head
         */

        /**
         * Constructs a new CommonRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a CommonRsp.
         * @implements ICommonRsp
         * @constructor
         * @param {liveroom_cs.ICommonRsp=} [properties] Properties to set
         */
        function CommonRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommonRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.CommonRsp
         * @instance
         */
        CommonRsp.prototype.rsp_head = null;

        /**
         * Creates a new CommonRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.CommonRsp
         * @static
         * @param {liveroom_cs.ICommonRsp=} [properties] Properties to set
         * @returns {liveroom_cs.CommonRsp} CommonRsp instance
         */
        CommonRsp.create = function create(properties) {
            return new CommonRsp(properties);
        };

        /**
         * Encodes the specified CommonRsp message. Does not implicitly {@link liveroom_cs.CommonRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.CommonRsp
         * @static
         * @param {liveroom_cs.ICommonRsp} message CommonRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommonRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a CommonRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.CommonRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.CommonRsp} CommonRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommonRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.CommonRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return CommonRsp;
    })();

    liveroom_cs.HbReq = (function() {

        /**
         * Properties of a HbReq.
         * @memberof liveroom_cs
         * @interface IHbReq
         * @property {liveroom_cs.IReqHead|null} [req_head] HbReq req_head
         * @property {number|null} [role] HbReq role
         * @property {string|null} [lv_key] HbReq lv_key
         */

        /**
         * Constructs a new HbReq.
         * @memberof liveroom_cs
         * @classdesc -title:liveroom (/liveroompb/hb)
         * cmd: /lr/room/hb
         * @implements IHbReq
         * @constructor
         * @param {liveroom_cs.IHbReq=} [properties] Properties to set
         */
        function HbReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HbReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.HbReq
         * @instance
         */
        HbReq.prototype.req_head = null;

        /**
         * HbReq role.
         * @member {number} role
         * @memberof liveroom_cs.HbReq
         * @instance
         */
        HbReq.prototype.role = 0;

        /**
         * HbReq lv_key.
         * @member {string} lv_key
         * @memberof liveroom_cs.HbReq
         * @instance
         */
        HbReq.prototype.lv_key = "";

        /**
         * Creates a new HbReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.HbReq
         * @static
         * @param {liveroom_cs.IHbReq=} [properties] Properties to set
         * @returns {liveroom_cs.HbReq} HbReq instance
         */
        HbReq.create = function create(properties) {
            return new HbReq(properties);
        };

        /**
         * Encodes the specified HbReq message. Does not implicitly {@link liveroom_cs.HbReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.HbReq
         * @static
         * @param {liveroom_cs.IHbReq} message HbReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HbReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.role);
            if (message.lv_key != null && Object.hasOwnProperty.call(message, "lv_key"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.lv_key);
            return writer;
        };

        /**
         * Decodes a HbReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.HbReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.HbReq} HbReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HbReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.HbReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.role = reader.uint32();
                    break;
                case 3:
                    message.lv_key = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return HbReq;
    })();

    liveroom_cs.HbRsp = (function() {

        /**
         * Properties of a HbRsp.
         * @memberof liveroom_cs
         * @interface IHbRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] HbRsp rsp_head
         * @property {number|Long|null} [ret_timestamp] HbRsp ret_timestamp
         * @property {number|null} [hb_interval] HbRsp hb_interval
         * @property {number|null} [hb_timeout] HbRsp hb_timeout
         * @property {number|null} [stream_seq] HbRsp stream_seq
         * @property {number|Long|null} [user_seq] HbRsp user_seq
         * @property {number|null} [online_count] HbRsp online_count
         * @property {number|null} [bigim_time_window] HbRsp bigim_time_window
         * @property {number|Long|null} [dati_time_window] HbRsp dati_time_window
         * @property {Array.<liveroom_cs.IStTransChannelSeq>|null} [trans_seqs] HbRsp trans_seqs
         * @property {Array.<liveroom_cs.IStTransChannelSeq>|null} [user_trans_seqs] HbRsp user_trans_seqs
         * @property {number|null} [StreamRefresh] HbRsp StreamRefresh
         * @property {number|null} [trans_list_seq] HbRsp trans_list_seq
         */

        /**
         * Constructs a new HbRsp.
         * @memberof liveroom_cs
         * @classdesc -title:liveroom 
         * cmd: /lr/room/hb_rsp
         * @implements IHbRsp
         * @constructor
         * @param {liveroom_cs.IHbRsp=} [properties] Properties to set
         */
        function HbRsp(properties) {
            this.trans_seqs = [];
            this.user_trans_seqs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HbRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.rsp_head = null;

        /**
         * HbRsp ret_timestamp.
         * @member {number|Long} ret_timestamp
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.ret_timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * HbRsp hb_interval.
         * @member {number} hb_interval
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.hb_interval = 0;

        /**
         * HbRsp hb_timeout.
         * @member {number} hb_timeout
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.hb_timeout = 0;

        /**
         * HbRsp stream_seq.
         * @member {number} stream_seq
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.stream_seq = 0;

        /**
         * HbRsp user_seq.
         * @member {number|Long} user_seq
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.user_seq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * HbRsp online_count.
         * @member {number} online_count
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.online_count = 0;

        /**
         * HbRsp bigim_time_window.
         * @member {number} bigim_time_window
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.bigim_time_window = 0;

        /**
         * HbRsp dati_time_window.
         * @member {number|Long} dati_time_window
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.dati_time_window = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * HbRsp trans_seqs.
         * @member {Array.<liveroom_cs.IStTransChannelSeq>} trans_seqs
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.trans_seqs = $util.emptyArray;

        /**
         * HbRsp user_trans_seqs.
         * @member {Array.<liveroom_cs.IStTransChannelSeq>} user_trans_seqs
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.user_trans_seqs = $util.emptyArray;

        /**
         * HbRsp StreamRefresh.
         * @member {number} StreamRefresh
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.StreamRefresh = 0;

        /**
         * HbRsp trans_list_seq.
         * @member {number} trans_list_seq
         * @memberof liveroom_cs.HbRsp
         * @instance
         */
        HbRsp.prototype.trans_list_seq = 0;

        /**
         * Creates a new HbRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.HbRsp
         * @static
         * @param {liveroom_cs.IHbRsp=} [properties] Properties to set
         * @returns {liveroom_cs.HbRsp} HbRsp instance
         */
        HbRsp.create = function create(properties) {
            return new HbRsp(properties);
        };

        /**
         * Encodes the specified HbRsp message. Does not implicitly {@link liveroom_cs.HbRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.HbRsp
         * @static
         * @param {liveroom_cs.IHbRsp} message HbRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HbRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.ret_timestamp != null && Object.hasOwnProperty.call(message, "ret_timestamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.ret_timestamp);
            if (message.hb_interval != null && Object.hasOwnProperty.call(message, "hb_interval"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.hb_interval);
            if (message.hb_timeout != null && Object.hasOwnProperty.call(message, "hb_timeout"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.hb_timeout);
            if (message.stream_seq != null && Object.hasOwnProperty.call(message, "stream_seq"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.stream_seq);
            if (message.user_seq != null && Object.hasOwnProperty.call(message, "user_seq"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.user_seq);
            if (message.online_count != null && Object.hasOwnProperty.call(message, "online_count"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.online_count);
            if (message.bigim_time_window != null && Object.hasOwnProperty.call(message, "bigim_time_window"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.bigim_time_window);
            if (message.dati_time_window != null && Object.hasOwnProperty.call(message, "dati_time_window"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.dati_time_window);
            if (message.trans_seqs != null && message.trans_seqs.length)
                for (var i = 0; i < message.trans_seqs.length; ++i)
                    $root.liveroom_cs.StTransChannelSeq.encode(message.trans_seqs[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.user_trans_seqs != null && message.user_trans_seqs.length)
                for (var i = 0; i < message.user_trans_seqs.length; ++i)
                    $root.liveroom_cs.StTransChannelSeq.encode(message.user_trans_seqs[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.StreamRefresh != null && Object.hasOwnProperty.call(message, "StreamRefresh"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.StreamRefresh);
            if (message.trans_list_seq != null && Object.hasOwnProperty.call(message, "trans_list_seq"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.trans_list_seq);
            return writer;
        };

        /**
         * Decodes a HbRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.HbRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.HbRsp} HbRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HbRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.HbRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.ret_timestamp = reader.int64();
                    break;
                case 3:
                    message.hb_interval = reader.uint32();
                    break;
                case 4:
                    message.hb_timeout = reader.uint32();
                    break;
                case 5:
                    message.stream_seq = reader.uint32();
                    break;
                case 6:
                    message.user_seq = reader.int64();
                    break;
                case 7:
                    message.online_count = reader.uint32();
                    break;
                case 8:
                    message.bigim_time_window = reader.uint32();
                    break;
                case 9:
                    message.dati_time_window = reader.int64();
                    break;
                case 10:
                    if (!(message.trans_seqs && message.trans_seqs.length))
                        message.trans_seqs = [];
                    message.trans_seqs.push($root.liveroom_cs.StTransChannelSeq.decode(reader, reader.uint32()));
                    break;
                case 11:
                    if (!(message.user_trans_seqs && message.user_trans_seqs.length))
                        message.user_trans_seqs = [];
                    message.user_trans_seqs.push($root.liveroom_cs.StTransChannelSeq.decode(reader, reader.uint32()));
                    break;
                case 12:
                    message.StreamRefresh = reader.uint32();
                    break;
                case 13:
                    message.trans_list_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return HbRsp;
    })();

    liveroom_cs.StTransSeq = (function() {

        /**
         * Properties of a StTransSeq.
         * @memberof liveroom_cs
         * @interface IStTransSeq
         * @property {Uint8Array|null} [trans_type] StTransSeq trans_type
         * @property {number|null} [trans_seq] StTransSeq trans_seq
         */

        /**
         * Constructs a new StTransSeq.
         * @memberof liveroom_cs
         * @classdesc Represents a StTransSeq.
         * @implements IStTransSeq
         * @constructor
         * @param {liveroom_cs.IStTransSeq=} [properties] Properties to set
         */
        function StTransSeq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StTransSeq trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.StTransSeq
         * @instance
         */
        StTransSeq.prototype.trans_type = $util.newBuffer([]);

        /**
         * StTransSeq trans_seq.
         * @member {number} trans_seq
         * @memberof liveroom_cs.StTransSeq
         * @instance
         */
        StTransSeq.prototype.trans_seq = 0;

        /**
         * Creates a new StTransSeq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StTransSeq
         * @static
         * @param {liveroom_cs.IStTransSeq=} [properties] Properties to set
         * @returns {liveroom_cs.StTransSeq} StTransSeq instance
         */
        StTransSeq.create = function create(properties) {
            return new StTransSeq(properties);
        };

        /**
         * Encodes the specified StTransSeq message. Does not implicitly {@link liveroom_cs.StTransSeq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StTransSeq
         * @static
         * @param {liveroom_cs.IStTransSeq} message StTransSeq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StTransSeq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_type);
            if (message.trans_seq != null && Object.hasOwnProperty.call(message, "trans_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.trans_seq);
            return writer;
        };

        /**
         * Decodes a StTransSeq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StTransSeq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StTransSeq} StTransSeq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StTransSeq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StTransSeq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_type = reader.bytes();
                    break;
                case 2:
                    message.trans_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StTransSeq;
    })();

    liveroom_cs.StTransChannelSeq = (function() {

        /**
         * Properties of a StTransChannelSeq.
         * @memberof liveroom_cs
         * @interface IStTransChannelSeq
         * @property {Uint8Array|null} [trans_channel] StTransChannelSeq trans_channel
         * @property {Array.<liveroom_cs.IStTransSeq>|null} [trans_seq_array] StTransChannelSeq trans_seq_array
         */

        /**
         * Constructs a new StTransChannelSeq.
         * @memberof liveroom_cs
         * @classdesc Represents a StTransChannelSeq.
         * @implements IStTransChannelSeq
         * @constructor
         * @param {liveroom_cs.IStTransChannelSeq=} [properties] Properties to set
         */
        function StTransChannelSeq(properties) {
            this.trans_seq_array = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StTransChannelSeq trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.StTransChannelSeq
         * @instance
         */
        StTransChannelSeq.prototype.trans_channel = $util.newBuffer([]);

        /**
         * StTransChannelSeq trans_seq_array.
         * @member {Array.<liveroom_cs.IStTransSeq>} trans_seq_array
         * @memberof liveroom_cs.StTransChannelSeq
         * @instance
         */
        StTransChannelSeq.prototype.trans_seq_array = $util.emptyArray;

        /**
         * Creates a new StTransChannelSeq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StTransChannelSeq
         * @static
         * @param {liveroom_cs.IStTransChannelSeq=} [properties] Properties to set
         * @returns {liveroom_cs.StTransChannelSeq} StTransChannelSeq instance
         */
        StTransChannelSeq.create = function create(properties) {
            return new StTransChannelSeq(properties);
        };

        /**
         * Encodes the specified StTransChannelSeq message. Does not implicitly {@link liveroom_cs.StTransChannelSeq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StTransChannelSeq
         * @static
         * @param {liveroom_cs.IStTransChannelSeq} message StTransChannelSeq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StTransChannelSeq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_channel);
            if (message.trans_seq_array != null && message.trans_seq_array.length)
                for (var i = 0; i < message.trans_seq_array.length; ++i)
                    $root.liveroom_cs.StTransSeq.encode(message.trans_seq_array[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a StTransChannelSeq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StTransChannelSeq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StTransChannelSeq} StTransChannelSeq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StTransChannelSeq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StTransChannelSeq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_channel = reader.bytes();
                    break;
                case 2:
                    if (!(message.trans_seq_array && message.trans_seq_array.length))
                        message.trans_seq_array = [];
                    message.trans_seq_array.push($root.liveroom_cs.StTransSeq.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StTransChannelSeq;
    })();

    liveroom_cs.UserlistReq = (function() {

        /**
         * Properties of a UserlistReq.
         * @memberof liveroom_cs
         * @interface IUserlistReq
         * @property {liveroom_cs.IReqHead|null} [req_head] UserlistReq req_head
         * @property {number|null} [sort_type] UserlistReq sort_type
         * @property {number|null} [user_index] UserlistReq user_index
         */

        /**
         * Constructs a new UserlistReq.
         * @memberof liveroom_cs
         * @classdesc Represents a UserlistReq.
         * @implements IUserlistReq
         * @constructor
         * @param {liveroom_cs.IUserlistReq=} [properties] Properties to set
         */
        function UserlistReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserlistReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.UserlistReq
         * @instance
         */
        UserlistReq.prototype.req_head = null;

        /**
         * UserlistReq sort_type.
         * @member {number} sort_type
         * @memberof liveroom_cs.UserlistReq
         * @instance
         */
        UserlistReq.prototype.sort_type = 0;

        /**
         * UserlistReq user_index.
         * @member {number} user_index
         * @memberof liveroom_cs.UserlistReq
         * @instance
         */
        UserlistReq.prototype.user_index = 0;

        /**
         * Creates a new UserlistReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.UserlistReq
         * @static
         * @param {liveroom_cs.IUserlistReq=} [properties] Properties to set
         * @returns {liveroom_cs.UserlistReq} UserlistReq instance
         */
        UserlistReq.create = function create(properties) {
            return new UserlistReq(properties);
        };

        /**
         * Encodes the specified UserlistReq message. Does not implicitly {@link liveroom_cs.UserlistReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.UserlistReq
         * @static
         * @param {liveroom_cs.IUserlistReq} message UserlistReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserlistReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sort_type != null && Object.hasOwnProperty.call(message, "sort_type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sort_type);
            if (message.user_index != null && Object.hasOwnProperty.call(message, "user_index"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.user_index);
            return writer;
        };

        /**
         * Decodes a UserlistReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.UserlistReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.UserlistReq} UserlistReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserlistReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.UserlistReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.sort_type = reader.uint32();
                    break;
                case 3:
                    message.user_index = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return UserlistReq;
    })();

    liveroom_cs.UserlistRsp = (function() {

        /**
         * Properties of a UserlistRsp.
         * @memberof liveroom_cs
         * @interface IUserlistRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] UserlistRsp rsp_head
         * @property {number|Long|null} [server_user_seq] UserlistRsp server_user_seq
         * @property {number|Long|null} [server_user_index] UserlistRsp server_user_index
         * @property {number|Long|null} [ret_user_index] UserlistRsp ret_user_index
         * @property {Array.<liveroom_cs.IStUserBasicDef>|null} [user_basic_list] UserlistRsp user_basic_list
         */

        /**
         * Constructs a new UserlistRsp.
         * @memberof liveroom_cs
         * @classdesc -title:liveroom userlist
         * cmd: /lr/userlist/userlist_rsp
         * @implements IUserlistRsp
         * @constructor
         * @param {liveroom_cs.IUserlistRsp=} [properties] Properties to set
         */
        function UserlistRsp(properties) {
            this.user_basic_list = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserlistRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.UserlistRsp
         * @instance
         */
        UserlistRsp.prototype.rsp_head = null;

        /**
         * UserlistRsp server_user_seq.
         * @member {number|Long} server_user_seq
         * @memberof liveroom_cs.UserlistRsp
         * @instance
         */
        UserlistRsp.prototype.server_user_seq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * UserlistRsp server_user_index.
         * @member {number|Long} server_user_index
         * @memberof liveroom_cs.UserlistRsp
         * @instance
         */
        UserlistRsp.prototype.server_user_index = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UserlistRsp ret_user_index.
         * @member {number|Long} ret_user_index
         * @memberof liveroom_cs.UserlistRsp
         * @instance
         */
        UserlistRsp.prototype.ret_user_index = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UserlistRsp user_basic_list.
         * @member {Array.<liveroom_cs.IStUserBasicDef>} user_basic_list
         * @memberof liveroom_cs.UserlistRsp
         * @instance
         */
        UserlistRsp.prototype.user_basic_list = $util.emptyArray;

        /**
         * Creates a new UserlistRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.UserlistRsp
         * @static
         * @param {liveroom_cs.IUserlistRsp=} [properties] Properties to set
         * @returns {liveroom_cs.UserlistRsp} UserlistRsp instance
         */
        UserlistRsp.create = function create(properties) {
            return new UserlistRsp(properties);
        };

        /**
         * Encodes the specified UserlistRsp message. Does not implicitly {@link liveroom_cs.UserlistRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.UserlistRsp
         * @static
         * @param {liveroom_cs.IUserlistRsp} message UserlistRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserlistRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.server_user_seq != null && Object.hasOwnProperty.call(message, "server_user_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.server_user_seq);
            if (message.server_user_index != null && Object.hasOwnProperty.call(message, "server_user_index"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.server_user_index);
            if (message.ret_user_index != null && Object.hasOwnProperty.call(message, "ret_user_index"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.ret_user_index);
            if (message.user_basic_list != null && message.user_basic_list.length)
                for (var i = 0; i < message.user_basic_list.length; ++i)
                    $root.liveroom_cs.StUserBasicDef.encode(message.user_basic_list[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a UserlistRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.UserlistRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.UserlistRsp} UserlistRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserlistRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.UserlistRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.server_user_seq = reader.uint64();
                    break;
                case 3:
                    message.server_user_index = reader.int64();
                    break;
                case 4:
                    message.ret_user_index = reader.int64();
                    break;
                case 5:
                    if (!(message.user_basic_list && message.user_basic_list.length))
                        message.user_basic_list = [];
                    message.user_basic_list.push($root.liveroom_cs.StUserBasicDef.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return UserlistRsp;
    })();

    liveroom_cs.StUserBasicDef = (function() {

        /**
         * Properties of a StUserBasicDef.
         * @memberof liveroom_cs
         * @interface IStUserBasicDef
         * @property {Uint8Array|null} [id_name] StUserBasicDef id_name
         * @property {Uint8Array|null} [nick_name] StUserBasicDef nick_name
         * @property {number|null} [role] StUserBasicDef role
         */

        /**
         * Constructs a new StUserBasicDef.
         * @memberof liveroom_cs
         * @classdesc Represents a StUserBasicDef.
         * @implements IStUserBasicDef
         * @constructor
         * @param {liveroom_cs.IStUserBasicDef=} [properties] Properties to set
         */
        function StUserBasicDef(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StUserBasicDef id_name.
         * @member {Uint8Array} id_name
         * @memberof liveroom_cs.StUserBasicDef
         * @instance
         */
        StUserBasicDef.prototype.id_name = $util.newBuffer([]);

        /**
         * StUserBasicDef nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.StUserBasicDef
         * @instance
         */
        StUserBasicDef.prototype.nick_name = $util.newBuffer([]);

        /**
         * StUserBasicDef role.
         * @member {number} role
         * @memberof liveroom_cs.StUserBasicDef
         * @instance
         */
        StUserBasicDef.prototype.role = 0;

        /**
         * Creates a new StUserBasicDef instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StUserBasicDef
         * @static
         * @param {liveroom_cs.IStUserBasicDef=} [properties] Properties to set
         * @returns {liveroom_cs.StUserBasicDef} StUserBasicDef instance
         */
        StUserBasicDef.create = function create(properties) {
            return new StUserBasicDef(properties);
        };

        /**
         * Encodes the specified StUserBasicDef message. Does not implicitly {@link liveroom_cs.StUserBasicDef.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StUserBasicDef
         * @static
         * @param {liveroom_cs.IStUserBasicDef} message StUserBasicDef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StUserBasicDef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id_name);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.role);
            return writer;
        };

        /**
         * Decodes a StUserBasicDef message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StUserBasicDef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StUserBasicDef} StUserBasicDef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StUserBasicDef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StUserBasicDef();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id_name = reader.bytes();
                    break;
                case 2:
                    message.nick_name = reader.bytes();
                    break;
                case 3:
                    message.role = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StUserBasicDef;
    })();

    liveroom_cs.StreamAddReq = (function() {

        /**
         * Properties of a StreamAddReq.
         * @memberof liveroom_cs
         * @interface IStreamAddReq
         * @property {liveroom_cs.IReqHead|null} [req_head] StreamAddReq req_head
         * @property {Uint8Array|null} [stream_id] StreamAddReq stream_id
         * @property {Uint8Array|null} [title] StreamAddReq title
         * @property {Uint8Array|null} [stream_attr] StreamAddReq stream_attr
         * @property {Uint8Array|null} [extra_info] StreamAddReq extra_info
         * @property {number|null} [client_req_seq] StreamAddReq client_req_seq
         * @property {Uint8Array|null} [nickname] StreamAddReq nickname
         * @property {number|null} [login_mode] StreamAddReq login_mode
         * @property {number|null} [stream_type] StreamAddReq stream_type
         * @property {Uint8Array|null} [third_token] StreamAddReq third_token
         */

        /**
         * Constructs a new StreamAddReq.
         * @memberof liveroom_cs
         * @classdesc Represents a StreamAddReq.
         * @implements IStreamAddReq
         * @constructor
         * @param {liveroom_cs.IStreamAddReq=} [properties] Properties to set
         */
        function StreamAddReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamAddReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.req_head = null;

        /**
         * StreamAddReq stream_id.
         * @member {Uint8Array} stream_id
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.stream_id = $util.newBuffer([]);

        /**
         * StreamAddReq title.
         * @member {Uint8Array} title
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.title = $util.newBuffer([]);

        /**
         * StreamAddReq stream_attr.
         * @member {Uint8Array} stream_attr
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.stream_attr = $util.newBuffer([]);

        /**
         * StreamAddReq extra_info.
         * @member {Uint8Array} extra_info
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.extra_info = $util.newBuffer([]);

        /**
         * StreamAddReq client_req_seq.
         * @member {number} client_req_seq
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.client_req_seq = 0;

        /**
         * StreamAddReq nickname.
         * @member {Uint8Array} nickname
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.nickname = $util.newBuffer([]);

        /**
         * StreamAddReq login_mode.
         * @member {number} login_mode
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.login_mode = 0;

        /**
         * StreamAddReq stream_type.
         * @member {number} stream_type
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.stream_type = 0;

        /**
         * StreamAddReq third_token.
         * @member {Uint8Array} third_token
         * @memberof liveroom_cs.StreamAddReq
         * @instance
         */
        StreamAddReq.prototype.third_token = $util.newBuffer([]);

        /**
         * Creates a new StreamAddReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StreamAddReq
         * @static
         * @param {liveroom_cs.IStreamAddReq=} [properties] Properties to set
         * @returns {liveroom_cs.StreamAddReq} StreamAddReq instance
         */
        StreamAddReq.create = function create(properties) {
            return new StreamAddReq(properties);
        };

        /**
         * Encodes the specified StreamAddReq message. Does not implicitly {@link liveroom_cs.StreamAddReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StreamAddReq
         * @static
         * @param {liveroom_cs.IStreamAddReq} message StreamAddReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamAddReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.stream_id);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.title);
            if (message.stream_attr != null && Object.hasOwnProperty.call(message, "stream_attr"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.stream_attr);
            if (message.extra_info != null && Object.hasOwnProperty.call(message, "extra_info"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.extra_info);
            if (message.client_req_seq != null && Object.hasOwnProperty.call(message, "client_req_seq"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.client_req_seq);
            if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.nickname);
            if (message.login_mode != null && Object.hasOwnProperty.call(message, "login_mode"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.login_mode);
            if (message.stream_type != null && Object.hasOwnProperty.call(message, "stream_type"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.stream_type);
            if (message.third_token != null && Object.hasOwnProperty.call(message, "third_token"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.third_token);
            return writer;
        };

        /**
         * Decodes a StreamAddReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StreamAddReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StreamAddReq} StreamAddReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamAddReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StreamAddReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.stream_id = reader.bytes();
                    break;
                case 3:
                    message.title = reader.bytes();
                    break;
                case 4:
                    message.stream_attr = reader.bytes();
                    break;
                case 5:
                    message.extra_info = reader.bytes();
                    break;
                case 6:
                    message.client_req_seq = reader.uint32();
                    break;
                case 7:
                    message.nickname = reader.bytes();
                    break;
                case 8:
                    message.login_mode = reader.uint32();
                    break;
                case 9:
                    message.stream_type = reader.uint32();
                    break;
                case 10:
                    message.third_token = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StreamAddReq;
    })();

    liveroom_cs.StreamAddRsp = (function() {

        /**
         * Properties of a StreamAddRsp.
         * @memberof liveroom_cs
         * @interface IStreamAddRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] StreamAddRsp rsp_head
         * @property {number|null} [stream_seq] StreamAddRsp stream_seq
         * @property {string|null} [stream_sid] StreamAddRsp stream_sid
         * @property {number|null} [stream_ver] StreamAddRsp stream_ver
         * @property {number|null} [stream_nid] StreamAddRsp stream_nid
         * @property {number|null} [token_remain_time] StreamAddRsp token_remain_time
         */

        /**
         * Constructs a new StreamAddRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a StreamAddRsp.
         * @implements IStreamAddRsp
         * @constructor
         * @param {liveroom_cs.IStreamAddRsp=} [properties] Properties to set
         */
        function StreamAddRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamAddRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.StreamAddRsp
         * @instance
         */
        StreamAddRsp.prototype.rsp_head = null;

        /**
         * StreamAddRsp stream_seq.
         * @member {number} stream_seq
         * @memberof liveroom_cs.StreamAddRsp
         * @instance
         */
        StreamAddRsp.prototype.stream_seq = 0;

        /**
         * StreamAddRsp stream_sid.
         * @member {string} stream_sid
         * @memberof liveroom_cs.StreamAddRsp
         * @instance
         */
        StreamAddRsp.prototype.stream_sid = "";

        /**
         * StreamAddRsp stream_ver.
         * @member {number} stream_ver
         * @memberof liveroom_cs.StreamAddRsp
         * @instance
         */
        StreamAddRsp.prototype.stream_ver = 0;

        /**
         * StreamAddRsp stream_nid.
         * @member {number} stream_nid
         * @memberof liveroom_cs.StreamAddRsp
         * @instance
         */
        StreamAddRsp.prototype.stream_nid = 0;

        /**
         * StreamAddRsp token_remain_time.
         * @member {number} token_remain_time
         * @memberof liveroom_cs.StreamAddRsp
         * @instance
         */
        StreamAddRsp.prototype.token_remain_time = 0;

        /**
         * Creates a new StreamAddRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StreamAddRsp
         * @static
         * @param {liveroom_cs.IStreamAddRsp=} [properties] Properties to set
         * @returns {liveroom_cs.StreamAddRsp} StreamAddRsp instance
         */
        StreamAddRsp.create = function create(properties) {
            return new StreamAddRsp(properties);
        };

        /**
         * Encodes the specified StreamAddRsp message. Does not implicitly {@link liveroom_cs.StreamAddRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StreamAddRsp
         * @static
         * @param {liveroom_cs.IStreamAddRsp} message StreamAddRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamAddRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.stream_seq != null && Object.hasOwnProperty.call(message, "stream_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stream_seq);
            if (message.stream_sid != null && Object.hasOwnProperty.call(message, "stream_sid"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.stream_sid);
            if (message.stream_ver != null && Object.hasOwnProperty.call(message, "stream_ver"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.stream_ver);
            if (message.stream_nid != null && Object.hasOwnProperty.call(message, "stream_nid"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.stream_nid);
            if (message.token_remain_time != null && Object.hasOwnProperty.call(message, "token_remain_time"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.token_remain_time);
            return writer;
        };

        /**
         * Decodes a StreamAddRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StreamAddRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StreamAddRsp} StreamAddRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamAddRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StreamAddRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.stream_seq = reader.uint32();
                    break;
                case 3:
                    message.stream_sid = reader.string();
                    break;
                case 4:
                    message.stream_ver = reader.uint32();
                    break;
                case 5:
                    message.stream_nid = reader.uint32();
                    break;
                case 6:
                    message.token_remain_time = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StreamAddRsp;
    })();

    liveroom_cs.StreamDeleteReq = (function() {

        /**
         * Properties of a StreamDeleteReq.
         * @memberof liveroom_cs
         * @interface IStreamDeleteReq
         * @property {liveroom_cs.IReqHead|null} [req_head] StreamDeleteReq req_head
         * @property {string|null} [stream_sid] StreamDeleteReq stream_sid
         * @property {Uint8Array|null} [stream_id] StreamDeleteReq stream_id
         * @property {number|null} [client_req_seq] StreamDeleteReq client_req_seq
         */

        /**
         * Constructs a new StreamDeleteReq.
         * @memberof liveroom_cs
         * @classdesc Represents a StreamDeleteReq.
         * @implements IStreamDeleteReq
         * @constructor
         * @param {liveroom_cs.IStreamDeleteReq=} [properties] Properties to set
         */
        function StreamDeleteReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamDeleteReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.StreamDeleteReq
         * @instance
         */
        StreamDeleteReq.prototype.req_head = null;

        /**
         * StreamDeleteReq stream_sid.
         * @member {string} stream_sid
         * @memberof liveroom_cs.StreamDeleteReq
         * @instance
         */
        StreamDeleteReq.prototype.stream_sid = "";

        /**
         * StreamDeleteReq stream_id.
         * @member {Uint8Array} stream_id
         * @memberof liveroom_cs.StreamDeleteReq
         * @instance
         */
        StreamDeleteReq.prototype.stream_id = $util.newBuffer([]);

        /**
         * StreamDeleteReq client_req_seq.
         * @member {number} client_req_seq
         * @memberof liveroom_cs.StreamDeleteReq
         * @instance
         */
        StreamDeleteReq.prototype.client_req_seq = 0;

        /**
         * Creates a new StreamDeleteReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StreamDeleteReq
         * @static
         * @param {liveroom_cs.IStreamDeleteReq=} [properties] Properties to set
         * @returns {liveroom_cs.StreamDeleteReq} StreamDeleteReq instance
         */
        StreamDeleteReq.create = function create(properties) {
            return new StreamDeleteReq(properties);
        };

        /**
         * Encodes the specified StreamDeleteReq message. Does not implicitly {@link liveroom_cs.StreamDeleteReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StreamDeleteReq
         * @static
         * @param {liveroom_cs.IStreamDeleteReq} message StreamDeleteReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamDeleteReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.stream_sid != null && Object.hasOwnProperty.call(message, "stream_sid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.stream_sid);
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.stream_id);
            if (message.client_req_seq != null && Object.hasOwnProperty.call(message, "client_req_seq"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.client_req_seq);
            return writer;
        };

        /**
         * Decodes a StreamDeleteReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StreamDeleteReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StreamDeleteReq} StreamDeleteReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamDeleteReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StreamDeleteReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.stream_sid = reader.string();
                    break;
                case 3:
                    message.stream_id = reader.bytes();
                    break;
                case 4:
                    message.client_req_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StreamDeleteReq;
    })();

    liveroom_cs.StreamDeleteRsp = (function() {

        /**
         * Properties of a StreamDeleteRsp.
         * @memberof liveroom_cs
         * @interface IStreamDeleteRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] StreamDeleteRsp rsp_head
         * @property {number|null} [stream_seq] StreamDeleteRsp stream_seq
         * @property {number|null} [stream_ver] StreamDeleteRsp stream_ver
         */

        /**
         * Constructs a new StreamDeleteRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a StreamDeleteRsp.
         * @implements IStreamDeleteRsp
         * @constructor
         * @param {liveroom_cs.IStreamDeleteRsp=} [properties] Properties to set
         */
        function StreamDeleteRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamDeleteRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.StreamDeleteRsp
         * @instance
         */
        StreamDeleteRsp.prototype.rsp_head = null;

        /**
         * StreamDeleteRsp stream_seq.
         * @member {number} stream_seq
         * @memberof liveroom_cs.StreamDeleteRsp
         * @instance
         */
        StreamDeleteRsp.prototype.stream_seq = 0;

        /**
         * StreamDeleteRsp stream_ver.
         * @member {number} stream_ver
         * @memberof liveroom_cs.StreamDeleteRsp
         * @instance
         */
        StreamDeleteRsp.prototype.stream_ver = 0;

        /**
         * Creates a new StreamDeleteRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StreamDeleteRsp
         * @static
         * @param {liveroom_cs.IStreamDeleteRsp=} [properties] Properties to set
         * @returns {liveroom_cs.StreamDeleteRsp} StreamDeleteRsp instance
         */
        StreamDeleteRsp.create = function create(properties) {
            return new StreamDeleteRsp(properties);
        };

        /**
         * Encodes the specified StreamDeleteRsp message. Does not implicitly {@link liveroom_cs.StreamDeleteRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StreamDeleteRsp
         * @static
         * @param {liveroom_cs.IStreamDeleteRsp} message StreamDeleteRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamDeleteRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.stream_seq != null && Object.hasOwnProperty.call(message, "stream_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stream_seq);
            if (message.stream_ver != null && Object.hasOwnProperty.call(message, "stream_ver"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.stream_ver);
            return writer;
        };

        /**
         * Decodes a StreamDeleteRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StreamDeleteRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StreamDeleteRsp} StreamDeleteRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamDeleteRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StreamDeleteRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.stream_seq = reader.uint32();
                    break;
                case 3:
                    message.stream_ver = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StreamDeleteRsp;
    })();

    liveroom_cs.StreamUpdateReq = (function() {

        /**
         * Properties of a StreamUpdateReq.
         * @memberof liveroom_cs
         * @interface IStreamUpdateReq
         * @property {liveroom_cs.IReqHead|null} [req_head] StreamUpdateReq req_head
         * @property {string|null} [stream_sid] StreamUpdateReq stream_sid
         * @property {Uint8Array|null} [stream_id] StreamUpdateReq stream_id
         * @property {Uint8Array|null} [title] StreamUpdateReq title
         * @property {Uint8Array|null} [stream_attr] StreamUpdateReq stream_attr
         * @property {Uint8Array|null} [extra_info] StreamUpdateReq extra_info
         * @property {number|null} [client_req_seq] StreamUpdateReq client_req_seq
         * @property {Uint8Array|null} [nickname] StreamUpdateReq nickname
         */

        /**
         * Constructs a new StreamUpdateReq.
         * @memberof liveroom_cs
         * @classdesc Represents a StreamUpdateReq.
         * @implements IStreamUpdateReq
         * @constructor
         * @param {liveroom_cs.IStreamUpdateReq=} [properties] Properties to set
         */
        function StreamUpdateReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamUpdateReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.StreamUpdateReq
         * @instance
         */
        StreamUpdateReq.prototype.req_head = null;

        /**
         * StreamUpdateReq stream_sid.
         * @member {string} stream_sid
         * @memberof liveroom_cs.StreamUpdateReq
         * @instance
         */
        StreamUpdateReq.prototype.stream_sid = "";

        /**
         * StreamUpdateReq stream_id.
         * @member {Uint8Array} stream_id
         * @memberof liveroom_cs.StreamUpdateReq
         * @instance
         */
        StreamUpdateReq.prototype.stream_id = $util.newBuffer([]);

        /**
         * StreamUpdateReq title.
         * @member {Uint8Array} title
         * @memberof liveroom_cs.StreamUpdateReq
         * @instance
         */
        StreamUpdateReq.prototype.title = $util.newBuffer([]);

        /**
         * StreamUpdateReq stream_attr.
         * @member {Uint8Array} stream_attr
         * @memberof liveroom_cs.StreamUpdateReq
         * @instance
         */
        StreamUpdateReq.prototype.stream_attr = $util.newBuffer([]);

        /**
         * StreamUpdateReq extra_info.
         * @member {Uint8Array} extra_info
         * @memberof liveroom_cs.StreamUpdateReq
         * @instance
         */
        StreamUpdateReq.prototype.extra_info = $util.newBuffer([]);

        /**
         * StreamUpdateReq client_req_seq.
         * @member {number} client_req_seq
         * @memberof liveroom_cs.StreamUpdateReq
         * @instance
         */
        StreamUpdateReq.prototype.client_req_seq = 0;

        /**
         * StreamUpdateReq nickname.
         * @member {Uint8Array} nickname
         * @memberof liveroom_cs.StreamUpdateReq
         * @instance
         */
        StreamUpdateReq.prototype.nickname = $util.newBuffer([]);

        /**
         * Creates a new StreamUpdateReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StreamUpdateReq
         * @static
         * @param {liveroom_cs.IStreamUpdateReq=} [properties] Properties to set
         * @returns {liveroom_cs.StreamUpdateReq} StreamUpdateReq instance
         */
        StreamUpdateReq.create = function create(properties) {
            return new StreamUpdateReq(properties);
        };

        /**
         * Encodes the specified StreamUpdateReq message. Does not implicitly {@link liveroom_cs.StreamUpdateReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StreamUpdateReq
         * @static
         * @param {liveroom_cs.IStreamUpdateReq} message StreamUpdateReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamUpdateReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.stream_sid != null && Object.hasOwnProperty.call(message, "stream_sid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.stream_sid);
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.stream_id);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.title);
            if (message.stream_attr != null && Object.hasOwnProperty.call(message, "stream_attr"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.stream_attr);
            if (message.extra_info != null && Object.hasOwnProperty.call(message, "extra_info"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.extra_info);
            if (message.client_req_seq != null && Object.hasOwnProperty.call(message, "client_req_seq"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.client_req_seq);
            if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.nickname);
            return writer;
        };

        /**
         * Decodes a StreamUpdateReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StreamUpdateReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StreamUpdateReq} StreamUpdateReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamUpdateReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StreamUpdateReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.stream_sid = reader.string();
                    break;
                case 3:
                    message.stream_id = reader.bytes();
                    break;
                case 4:
                    message.title = reader.bytes();
                    break;
                case 5:
                    message.stream_attr = reader.bytes();
                    break;
                case 6:
                    message.extra_info = reader.bytes();
                    break;
                case 7:
                    message.client_req_seq = reader.uint32();
                    break;
                case 8:
                    message.nickname = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StreamUpdateReq;
    })();

    liveroom_cs.StreamUpdateRsp = (function() {

        /**
         * Properties of a StreamUpdateRsp.
         * @memberof liveroom_cs
         * @interface IStreamUpdateRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] StreamUpdateRsp rsp_head
         * @property {number|null} [stream_seq] StreamUpdateRsp stream_seq
         * @property {number|null} [stream_ver] StreamUpdateRsp stream_ver
         */

        /**
         * Constructs a new StreamUpdateRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a StreamUpdateRsp.
         * @implements IStreamUpdateRsp
         * @constructor
         * @param {liveroom_cs.IStreamUpdateRsp=} [properties] Properties to set
         */
        function StreamUpdateRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamUpdateRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.StreamUpdateRsp
         * @instance
         */
        StreamUpdateRsp.prototype.rsp_head = null;

        /**
         * StreamUpdateRsp stream_seq.
         * @member {number} stream_seq
         * @memberof liveroom_cs.StreamUpdateRsp
         * @instance
         */
        StreamUpdateRsp.prototype.stream_seq = 0;

        /**
         * StreamUpdateRsp stream_ver.
         * @member {number} stream_ver
         * @memberof liveroom_cs.StreamUpdateRsp
         * @instance
         */
        StreamUpdateRsp.prototype.stream_ver = 0;

        /**
         * Creates a new StreamUpdateRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StreamUpdateRsp
         * @static
         * @param {liveroom_cs.IStreamUpdateRsp=} [properties] Properties to set
         * @returns {liveroom_cs.StreamUpdateRsp} StreamUpdateRsp instance
         */
        StreamUpdateRsp.create = function create(properties) {
            return new StreamUpdateRsp(properties);
        };

        /**
         * Encodes the specified StreamUpdateRsp message. Does not implicitly {@link liveroom_cs.StreamUpdateRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StreamUpdateRsp
         * @static
         * @param {liveroom_cs.IStreamUpdateRsp} message StreamUpdateRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamUpdateRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.stream_seq != null && Object.hasOwnProperty.call(message, "stream_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stream_seq);
            if (message.stream_ver != null && Object.hasOwnProperty.call(message, "stream_ver"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.stream_ver);
            return writer;
        };

        /**
         * Decodes a StreamUpdateRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StreamUpdateRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StreamUpdateRsp} StreamUpdateRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamUpdateRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StreamUpdateRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.stream_seq = reader.uint32();
                    break;
                case 3:
                    message.stream_ver = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StreamUpdateRsp;
    })();

    liveroom_cs.StreamListReq = (function() {

        /**
         * Properties of a StreamListReq.
         * @memberof liveroom_cs
         * @interface IStreamListReq
         * @property {liveroom_cs.IReqHead|null} [req_head] StreamListReq req_head
         */

        /**
         * Constructs a new StreamListReq.
         * @memberof liveroom_cs
         * @classdesc Represents a StreamListReq.
         * @implements IStreamListReq
         * @constructor
         * @param {liveroom_cs.IStreamListReq=} [properties] Properties to set
         */
        function StreamListReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamListReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.StreamListReq
         * @instance
         */
        StreamListReq.prototype.req_head = null;

        /**
         * Creates a new StreamListReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StreamListReq
         * @static
         * @param {liveroom_cs.IStreamListReq=} [properties] Properties to set
         * @returns {liveroom_cs.StreamListReq} StreamListReq instance
         */
        StreamListReq.create = function create(properties) {
            return new StreamListReq(properties);
        };

        /**
         * Encodes the specified StreamListReq message. Does not implicitly {@link liveroom_cs.StreamListReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StreamListReq
         * @static
         * @param {liveroom_cs.IStreamListReq} message StreamListReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamListReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a StreamListReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StreamListReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StreamListReq} StreamListReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamListReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StreamListReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StreamListReq;
    })();

    liveroom_cs.StreamListRsp = (function() {

        /**
         * Properties of a StreamListRsp.
         * @memberof liveroom_cs
         * @interface IStreamListRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] StreamListRsp rsp_head
         * @property {number|null} [stream_seq] StreamListRsp stream_seq
         * @property {Array.<liveroom_cs.IStStreamInfo>|null} [stream_info] StreamListRsp stream_info
         * @property {number|null} [stream_refresh] StreamListRsp stream_refresh
         * @property {Array.<liveroom_cs.IStStreamInfo>|null} [stream_mix_info] StreamListRsp stream_mix_info
         */

        /**
         * Constructs a new StreamListRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a StreamListRsp.
         * @implements IStreamListRsp
         * @constructor
         * @param {liveroom_cs.IStreamListRsp=} [properties] Properties to set
         */
        function StreamListRsp(properties) {
            this.stream_info = [];
            this.stream_mix_info = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StreamListRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.StreamListRsp
         * @instance
         */
        StreamListRsp.prototype.rsp_head = null;

        /**
         * StreamListRsp stream_seq.
         * @member {number} stream_seq
         * @memberof liveroom_cs.StreamListRsp
         * @instance
         */
        StreamListRsp.prototype.stream_seq = 0;

        /**
         * StreamListRsp stream_info.
         * @member {Array.<liveroom_cs.IStStreamInfo>} stream_info
         * @memberof liveroom_cs.StreamListRsp
         * @instance
         */
        StreamListRsp.prototype.stream_info = $util.emptyArray;

        /**
         * StreamListRsp stream_refresh.
         * @member {number} stream_refresh
         * @memberof liveroom_cs.StreamListRsp
         * @instance
         */
        StreamListRsp.prototype.stream_refresh = 0;

        /**
         * StreamListRsp stream_mix_info.
         * @member {Array.<liveroom_cs.IStStreamInfo>} stream_mix_info
         * @memberof liveroom_cs.StreamListRsp
         * @instance
         */
        StreamListRsp.prototype.stream_mix_info = $util.emptyArray;

        /**
         * Creates a new StreamListRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StreamListRsp
         * @static
         * @param {liveroom_cs.IStreamListRsp=} [properties] Properties to set
         * @returns {liveroom_cs.StreamListRsp} StreamListRsp instance
         */
        StreamListRsp.create = function create(properties) {
            return new StreamListRsp(properties);
        };

        /**
         * Encodes the specified StreamListRsp message. Does not implicitly {@link liveroom_cs.StreamListRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StreamListRsp
         * @static
         * @param {liveroom_cs.IStreamListRsp} message StreamListRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StreamListRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.stream_seq != null && Object.hasOwnProperty.call(message, "stream_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stream_seq);
            if (message.stream_info != null && message.stream_info.length)
                for (var i = 0; i < message.stream_info.length; ++i)
                    $root.liveroom_cs.StStreamInfo.encode(message.stream_info[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.stream_refresh != null && Object.hasOwnProperty.call(message, "stream_refresh"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.stream_refresh);
            if (message.stream_mix_info != null && message.stream_mix_info.length)
                for (var i = 0; i < message.stream_mix_info.length; ++i)
                    $root.liveroom_cs.StStreamInfo.encode(message.stream_mix_info[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a StreamListRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StreamListRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StreamListRsp} StreamListRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StreamListRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StreamListRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.stream_seq = reader.uint32();
                    break;
                case 3:
                    if (!(message.stream_info && message.stream_info.length))
                        message.stream_info = [];
                    message.stream_info.push($root.liveroom_cs.StStreamInfo.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.stream_refresh = reader.uint32();
                    break;
                case 5:
                    if (!(message.stream_mix_info && message.stream_mix_info.length))
                        message.stream_mix_info = [];
                    message.stream_mix_info.push($root.liveroom_cs.StStreamInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StreamListRsp;
    })();

    liveroom_cs.StStreamInfo = (function() {

        /**
         * Properties of a StStreamInfo.
         * @memberof liveroom_cs
         * @interface IStStreamInfo
         * @property {string|null} [stream_sid] StStreamInfo stream_sid
         * @property {Uint8Array|null} [stream_id] StStreamInfo stream_id
         * @property {Uint8Array|null} [id_name] StStreamInfo id_name
         * @property {Uint8Array|null} [nick_name] StStreamInfo nick_name
         * @property {Uint8Array|null} [extra_info] StStreamInfo extra_info
         * @property {Uint8Array|null} [title] StStreamInfo title
         * @property {number|null} [stream_ver] StStreamInfo stream_ver
         * @property {Uint8Array|null} [stream_attr] StStreamInfo stream_attr
         * @property {number|Long|null} [create_time] StStreamInfo create_time
         * @property {number|null} [stream_src] StStreamInfo stream_src
         * @property {number|null} [state] StStreamInfo state
         * @property {number|null} [stream_type] StStreamInfo stream_type
         * @property {number|null} [stream_nid] StStreamInfo stream_nid
         */

        /**
         * Constructs a new StStreamInfo.
         * @memberof liveroom_cs
         * @classdesc Represents a StStreamInfo.
         * @implements IStStreamInfo
         * @constructor
         * @param {liveroom_cs.IStStreamInfo=} [properties] Properties to set
         */
        function StStreamInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StStreamInfo stream_sid.
         * @member {string} stream_sid
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_sid = "";

        /**
         * StStreamInfo stream_id.
         * @member {Uint8Array} stream_id
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_id = $util.newBuffer([]);

        /**
         * StStreamInfo id_name.
         * @member {Uint8Array} id_name
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.id_name = $util.newBuffer([]);

        /**
         * StStreamInfo nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.nick_name = $util.newBuffer([]);

        /**
         * StStreamInfo extra_info.
         * @member {Uint8Array} extra_info
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.extra_info = $util.newBuffer([]);

        /**
         * StStreamInfo title.
         * @member {Uint8Array} title
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.title = $util.newBuffer([]);

        /**
         * StStreamInfo stream_ver.
         * @member {number} stream_ver
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_ver = 0;

        /**
         * StStreamInfo stream_attr.
         * @member {Uint8Array} stream_attr
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_attr = $util.newBuffer([]);

        /**
         * StStreamInfo create_time.
         * @member {number|Long} create_time
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.create_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StStreamInfo stream_src.
         * @member {number} stream_src
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_src = 0;

        /**
         * StStreamInfo state.
         * @member {number} state
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.state = 0;

        /**
         * StStreamInfo stream_type.
         * @member {number} stream_type
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_type = 0;

        /**
         * StStreamInfo stream_nid.
         * @member {number} stream_nid
         * @memberof liveroom_cs.StStreamInfo
         * @instance
         */
        StStreamInfo.prototype.stream_nid = 0;

        /**
         * Creates a new StStreamInfo instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StStreamInfo
         * @static
         * @param {liveroom_cs.IStStreamInfo=} [properties] Properties to set
         * @returns {liveroom_cs.StStreamInfo} StStreamInfo instance
         */
        StStreamInfo.create = function create(properties) {
            return new StStreamInfo(properties);
        };

        /**
         * Encodes the specified StStreamInfo message. Does not implicitly {@link liveroom_cs.StStreamInfo.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StStreamInfo
         * @static
         * @param {liveroom_cs.IStStreamInfo} message StStreamInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StStreamInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stream_sid != null && Object.hasOwnProperty.call(message, "stream_sid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.stream_sid);
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.stream_id);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.id_name);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.nick_name);
            if (message.extra_info != null && Object.hasOwnProperty.call(message, "extra_info"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.extra_info);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.title);
            if (message.stream_ver != null && Object.hasOwnProperty.call(message, "stream_ver"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.stream_ver);
            if (message.stream_attr != null && Object.hasOwnProperty.call(message, "stream_attr"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.stream_attr);
            if (message.create_time != null && Object.hasOwnProperty.call(message, "create_time"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.create_time);
            if (message.stream_src != null && Object.hasOwnProperty.call(message, "stream_src"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.stream_src);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.state);
            if (message.stream_type != null && Object.hasOwnProperty.call(message, "stream_type"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.stream_type);
            if (message.stream_nid != null && Object.hasOwnProperty.call(message, "stream_nid"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.stream_nid);
            return writer;
        };

        /**
         * Decodes a StStreamInfo message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StStreamInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StStreamInfo} StStreamInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StStreamInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StStreamInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stream_sid = reader.string();
                    break;
                case 2:
                    message.stream_id = reader.bytes();
                    break;
                case 3:
                    message.id_name = reader.bytes();
                    break;
                case 4:
                    message.nick_name = reader.bytes();
                    break;
                case 5:
                    message.extra_info = reader.bytes();
                    break;
                case 6:
                    message.title = reader.bytes();
                    break;
                case 7:
                    message.stream_ver = reader.uint32();
                    break;
                case 8:
                    message.stream_attr = reader.bytes();
                    break;
                case 9:
                    message.create_time = reader.int64();
                    break;
                case 10:
                    message.stream_src = reader.uint32();
                    break;
                case 11:
                    message.state = reader.uint32();
                    break;
                case 12:
                    message.stream_type = reader.uint32();
                    break;
                case 13:
                    message.stream_nid = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StStreamInfo;
    })();

    liveroom_cs.StDstUser = (function() {

        /**
         * Properties of a StDstUser.
         * @memberof liveroom_cs
         * @interface IStDstUser
         * @property {Uint8Array|null} [id_name] StDstUser id_name
         * @property {number|Long|null} [id] StDstUser id
         */

        /**
         * Constructs a new StDstUser.
         * @memberof liveroom_cs
         * @classdesc Represents a StDstUser.
         * @implements IStDstUser
         * @constructor
         * @param {liveroom_cs.IStDstUser=} [properties] Properties to set
         */
        function StDstUser(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StDstUser id_name.
         * @member {Uint8Array} id_name
         * @memberof liveroom_cs.StDstUser
         * @instance
         */
        StDstUser.prototype.id_name = $util.newBuffer([]);

        /**
         * StDstUser id.
         * @member {number|Long} id
         * @memberof liveroom_cs.StDstUser
         * @instance
         */
        StDstUser.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new StDstUser instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StDstUser
         * @static
         * @param {liveroom_cs.IStDstUser=} [properties] Properties to set
         * @returns {liveroom_cs.StDstUser} StDstUser instance
         */
        StDstUser.create = function create(properties) {
            return new StDstUser(properties);
        };

        /**
         * Encodes the specified StDstUser message. Does not implicitly {@link liveroom_cs.StDstUser.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StDstUser
         * @static
         * @param {liveroom_cs.IStDstUser} message StDstUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StDstUser.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id_name);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.id);
            return writer;
        };

        /**
         * Decodes a StDstUser message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StDstUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StDstUser} StDstUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StDstUser.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StDstUser();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id_name = reader.bytes();
                    break;
                case 2:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StDstUser;
    })();

    liveroom_cs.SignalLiveReq = (function() {

        /**
         * Properties of a SignalLiveReq.
         * @memberof liveroom_cs
         * @interface ISignalLiveReq
         * @property {liveroom_cs.IReqHead|null} [req_head] SignalLiveReq req_head
         * @property {Uint8Array|null} [push_message] SignalLiveReq push_message
         * @property {Array.<liveroom_cs.IStDstUser>|null} [dst_userlist] SignalLiveReq dst_userlist
         */

        /**
         * Constructs a new SignalLiveReq.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveReq.
         * @implements ISignalLiveReq
         * @constructor
         * @param {liveroom_cs.ISignalLiveReq=} [properties] Properties to set
         */
        function SignalLiveReq(properties) {
            this.dst_userlist = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.SignalLiveReq
         * @instance
         */
        SignalLiveReq.prototype.req_head = null;

        /**
         * SignalLiveReq push_message.
         * @member {Uint8Array} push_message
         * @memberof liveroom_cs.SignalLiveReq
         * @instance
         */
        SignalLiveReq.prototype.push_message = $util.newBuffer([]);

        /**
         * SignalLiveReq dst_userlist.
         * @member {Array.<liveroom_cs.IStDstUser>} dst_userlist
         * @memberof liveroom_cs.SignalLiveReq
         * @instance
         */
        SignalLiveReq.prototype.dst_userlist = $util.emptyArray;

        /**
         * Creates a new SignalLiveReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveReq
         * @static
         * @param {liveroom_cs.ISignalLiveReq=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveReq} SignalLiveReq instance
         */
        SignalLiveReq.create = function create(properties) {
            return new SignalLiveReq(properties);
        };

        /**
         * Encodes the specified SignalLiveReq message. Does not implicitly {@link liveroom_cs.SignalLiveReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveReq
         * @static
         * @param {liveroom_cs.ISignalLiveReq} message SignalLiveReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.push_message != null && Object.hasOwnProperty.call(message, "push_message"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.push_message);
            if (message.dst_userlist != null && message.dst_userlist.length)
                for (var i = 0; i < message.dst_userlist.length; ++i)
                    $root.liveroom_cs.StDstUser.encode(message.dst_userlist[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveReq} SignalLiveReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.push_message = reader.bytes();
                    break;
                case 3:
                    if (!(message.dst_userlist && message.dst_userlist.length))
                        message.dst_userlist = [];
                    message.dst_userlist.push($root.liveroom_cs.StDstUser.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveReq;
    })();

    liveroom_cs.SignalLiveRsp = (function() {

        /**
         * Properties of a SignalLiveRsp.
         * @memberof liveroom_cs
         * @interface ISignalLiveRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] SignalLiveRsp rsp_head
         */

        /**
         * Constructs a new SignalLiveRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveRsp.
         * @implements ISignalLiveRsp
         * @constructor
         * @param {liveroom_cs.ISignalLiveRsp=} [properties] Properties to set
         */
        function SignalLiveRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.SignalLiveRsp
         * @instance
         */
        SignalLiveRsp.prototype.rsp_head = null;

        /**
         * Creates a new SignalLiveRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveRsp
         * @static
         * @param {liveroom_cs.ISignalLiveRsp=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveRsp} SignalLiveRsp instance
         */
        SignalLiveRsp.create = function create(properties) {
            return new SignalLiveRsp(properties);
        };

        /**
         * Encodes the specified SignalLiveRsp message. Does not implicitly {@link liveroom_cs.SignalLiveRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveRsp
         * @static
         * @param {liveroom_cs.ISignalLiveRsp} message SignalLiveRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveRsp} SignalLiveRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveRsp;
    })();

    liveroom_cs.SignalLiveResultReq = (function() {

        /**
         * Properties of a SignalLiveResultReq.
         * @memberof liveroom_cs
         * @interface ISignalLiveResultReq
         * @property {liveroom_cs.IReqHead|null} [req_head] SignalLiveResultReq req_head
         * @property {Uint8Array|null} [push_message] SignalLiveResultReq push_message
         * @property {Array.<liveroom_cs.IStDstUser>|null} [dst_userlist] SignalLiveResultReq dst_userlist
         */

        /**
         * Constructs a new SignalLiveResultReq.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveResultReq.
         * @implements ISignalLiveResultReq
         * @constructor
         * @param {liveroom_cs.ISignalLiveResultReq=} [properties] Properties to set
         */
        function SignalLiveResultReq(properties) {
            this.dst_userlist = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveResultReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.SignalLiveResultReq
         * @instance
         */
        SignalLiveResultReq.prototype.req_head = null;

        /**
         * SignalLiveResultReq push_message.
         * @member {Uint8Array} push_message
         * @memberof liveroom_cs.SignalLiveResultReq
         * @instance
         */
        SignalLiveResultReq.prototype.push_message = $util.newBuffer([]);

        /**
         * SignalLiveResultReq dst_userlist.
         * @member {Array.<liveroom_cs.IStDstUser>} dst_userlist
         * @memberof liveroom_cs.SignalLiveResultReq
         * @instance
         */
        SignalLiveResultReq.prototype.dst_userlist = $util.emptyArray;

        /**
         * Creates a new SignalLiveResultReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveResultReq
         * @static
         * @param {liveroom_cs.ISignalLiveResultReq=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveResultReq} SignalLiveResultReq instance
         */
        SignalLiveResultReq.create = function create(properties) {
            return new SignalLiveResultReq(properties);
        };

        /**
         * Encodes the specified SignalLiveResultReq message. Does not implicitly {@link liveroom_cs.SignalLiveResultReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveResultReq
         * @static
         * @param {liveroom_cs.ISignalLiveResultReq} message SignalLiveResultReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveResultReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.push_message != null && Object.hasOwnProperty.call(message, "push_message"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.push_message);
            if (message.dst_userlist != null && message.dst_userlist.length)
                for (var i = 0; i < message.dst_userlist.length; ++i)
                    $root.liveroom_cs.StDstUser.encode(message.dst_userlist[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveResultReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveResultReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveResultReq} SignalLiveResultReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveResultReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveResultReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.push_message = reader.bytes();
                    break;
                case 3:
                    if (!(message.dst_userlist && message.dst_userlist.length))
                        message.dst_userlist = [];
                    message.dst_userlist.push($root.liveroom_cs.StDstUser.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveResultReq;
    })();

    liveroom_cs.SignalLiveResulRsp = (function() {

        /**
         * Properties of a SignalLiveResulRsp.
         * @memberof liveroom_cs
         * @interface ISignalLiveResulRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] SignalLiveResulRsp rsp_head
         */

        /**
         * Constructs a new SignalLiveResulRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveResulRsp.
         * @implements ISignalLiveResulRsp
         * @constructor
         * @param {liveroom_cs.ISignalLiveResulRsp=} [properties] Properties to set
         */
        function SignalLiveResulRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveResulRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.SignalLiveResulRsp
         * @instance
         */
        SignalLiveResulRsp.prototype.rsp_head = null;

        /**
         * Creates a new SignalLiveResulRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveResulRsp
         * @static
         * @param {liveroom_cs.ISignalLiveResulRsp=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveResulRsp} SignalLiveResulRsp instance
         */
        SignalLiveResulRsp.create = function create(properties) {
            return new SignalLiveResulRsp(properties);
        };

        /**
         * Encodes the specified SignalLiveResulRsp message. Does not implicitly {@link liveroom_cs.SignalLiveResulRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveResulRsp
         * @static
         * @param {liveroom_cs.ISignalLiveResulRsp} message SignalLiveResulRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveResulRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveResulRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveResulRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveResulRsp} SignalLiveResulRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveResulRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveResulRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveResulRsp;
    })();

    liveroom_cs.SignalLiveInviteReq = (function() {

        /**
         * Properties of a SignalLiveInviteReq.
         * @memberof liveroom_cs
         * @interface ISignalLiveInviteReq
         * @property {liveroom_cs.IReqHead|null} [req_head] SignalLiveInviteReq req_head
         * @property {Uint8Array|null} [push_message] SignalLiveInviteReq push_message
         * @property {Array.<liveroom_cs.IStDstUser>|null} [dst_userlist] SignalLiveInviteReq dst_userlist
         */

        /**
         * Constructs a new SignalLiveInviteReq.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveInviteReq.
         * @implements ISignalLiveInviteReq
         * @constructor
         * @param {liveroom_cs.ISignalLiveInviteReq=} [properties] Properties to set
         */
        function SignalLiveInviteReq(properties) {
            this.dst_userlist = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveInviteReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.SignalLiveInviteReq
         * @instance
         */
        SignalLiveInviteReq.prototype.req_head = null;

        /**
         * SignalLiveInviteReq push_message.
         * @member {Uint8Array} push_message
         * @memberof liveroom_cs.SignalLiveInviteReq
         * @instance
         */
        SignalLiveInviteReq.prototype.push_message = $util.newBuffer([]);

        /**
         * SignalLiveInviteReq dst_userlist.
         * @member {Array.<liveroom_cs.IStDstUser>} dst_userlist
         * @memberof liveroom_cs.SignalLiveInviteReq
         * @instance
         */
        SignalLiveInviteReq.prototype.dst_userlist = $util.emptyArray;

        /**
         * Creates a new SignalLiveInviteReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveInviteReq
         * @static
         * @param {liveroom_cs.ISignalLiveInviteReq=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveInviteReq} SignalLiveInviteReq instance
         */
        SignalLiveInviteReq.create = function create(properties) {
            return new SignalLiveInviteReq(properties);
        };

        /**
         * Encodes the specified SignalLiveInviteReq message. Does not implicitly {@link liveroom_cs.SignalLiveInviteReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveInviteReq
         * @static
         * @param {liveroom_cs.ISignalLiveInviteReq} message SignalLiveInviteReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveInviteReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.push_message != null && Object.hasOwnProperty.call(message, "push_message"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.push_message);
            if (message.dst_userlist != null && message.dst_userlist.length)
                for (var i = 0; i < message.dst_userlist.length; ++i)
                    $root.liveroom_cs.StDstUser.encode(message.dst_userlist[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveInviteReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveInviteReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveInviteReq} SignalLiveInviteReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveInviteReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveInviteReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.push_message = reader.bytes();
                    break;
                case 3:
                    if (!(message.dst_userlist && message.dst_userlist.length))
                        message.dst_userlist = [];
                    message.dst_userlist.push($root.liveroom_cs.StDstUser.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveInviteReq;
    })();

    liveroom_cs.SignalLiveInviteRsp = (function() {

        /**
         * Properties of a SignalLiveInviteRsp.
         * @memberof liveroom_cs
         * @interface ISignalLiveInviteRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] SignalLiveInviteRsp rsp_head
         */

        /**
         * Constructs a new SignalLiveInviteRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveInviteRsp.
         * @implements ISignalLiveInviteRsp
         * @constructor
         * @param {liveroom_cs.ISignalLiveInviteRsp=} [properties] Properties to set
         */
        function SignalLiveInviteRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveInviteRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.SignalLiveInviteRsp
         * @instance
         */
        SignalLiveInviteRsp.prototype.rsp_head = null;

        /**
         * Creates a new SignalLiveInviteRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveInviteRsp
         * @static
         * @param {liveroom_cs.ISignalLiveInviteRsp=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveInviteRsp} SignalLiveInviteRsp instance
         */
        SignalLiveInviteRsp.create = function create(properties) {
            return new SignalLiveInviteRsp(properties);
        };

        /**
         * Encodes the specified SignalLiveInviteRsp message. Does not implicitly {@link liveroom_cs.SignalLiveInviteRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveInviteRsp
         * @static
         * @param {liveroom_cs.ISignalLiveInviteRsp} message SignalLiveInviteRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveInviteRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveInviteRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveInviteRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveInviteRsp} SignalLiveInviteRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveInviteRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveInviteRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveInviteRsp;
    })();

    liveroom_cs.SignalLiveStopReq = (function() {

        /**
         * Properties of a SignalLiveStopReq.
         * @memberof liveroom_cs
         * @interface ISignalLiveStopReq
         * @property {liveroom_cs.IReqHead|null} [req_head] SignalLiveStopReq req_head
         * @property {Uint8Array|null} [push_message] SignalLiveStopReq push_message
         * @property {Array.<liveroom_cs.IStDstUser>|null} [dst_userlist] SignalLiveStopReq dst_userlist
         */

        /**
         * Constructs a new SignalLiveStopReq.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveStopReq.
         * @implements ISignalLiveStopReq
         * @constructor
         * @param {liveroom_cs.ISignalLiveStopReq=} [properties] Properties to set
         */
        function SignalLiveStopReq(properties) {
            this.dst_userlist = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveStopReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.SignalLiveStopReq
         * @instance
         */
        SignalLiveStopReq.prototype.req_head = null;

        /**
         * SignalLiveStopReq push_message.
         * @member {Uint8Array} push_message
         * @memberof liveroom_cs.SignalLiveStopReq
         * @instance
         */
        SignalLiveStopReq.prototype.push_message = $util.newBuffer([]);

        /**
         * SignalLiveStopReq dst_userlist.
         * @member {Array.<liveroom_cs.IStDstUser>} dst_userlist
         * @memberof liveroom_cs.SignalLiveStopReq
         * @instance
         */
        SignalLiveStopReq.prototype.dst_userlist = $util.emptyArray;

        /**
         * Creates a new SignalLiveStopReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveStopReq
         * @static
         * @param {liveroom_cs.ISignalLiveStopReq=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveStopReq} SignalLiveStopReq instance
         */
        SignalLiveStopReq.create = function create(properties) {
            return new SignalLiveStopReq(properties);
        };

        /**
         * Encodes the specified SignalLiveStopReq message. Does not implicitly {@link liveroom_cs.SignalLiveStopReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveStopReq
         * @static
         * @param {liveroom_cs.ISignalLiveStopReq} message SignalLiveStopReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveStopReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.push_message != null && Object.hasOwnProperty.call(message, "push_message"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.push_message);
            if (message.dst_userlist != null && message.dst_userlist.length)
                for (var i = 0; i < message.dst_userlist.length; ++i)
                    $root.liveroom_cs.StDstUser.encode(message.dst_userlist[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveStopReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveStopReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveStopReq} SignalLiveStopReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveStopReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveStopReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.push_message = reader.bytes();
                    break;
                case 3:
                    if (!(message.dst_userlist && message.dst_userlist.length))
                        message.dst_userlist = [];
                    message.dst_userlist.push($root.liveroom_cs.StDstUser.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveStopReq;
    })();

    liveroom_cs.SignalLiveStopRsp = (function() {

        /**
         * Properties of a SignalLiveStopRsp.
         * @memberof liveroom_cs
         * @interface ISignalLiveStopRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] SignalLiveStopRsp rsp_head
         */

        /**
         * Constructs a new SignalLiveStopRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveStopRsp.
         * @implements ISignalLiveStopRsp
         * @constructor
         * @param {liveroom_cs.ISignalLiveStopRsp=} [properties] Properties to set
         */
        function SignalLiveStopRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveStopRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.SignalLiveStopRsp
         * @instance
         */
        SignalLiveStopRsp.prototype.rsp_head = null;

        /**
         * Creates a new SignalLiveStopRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveStopRsp
         * @static
         * @param {liveroom_cs.ISignalLiveStopRsp=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveStopRsp} SignalLiveStopRsp instance
         */
        SignalLiveStopRsp.create = function create(properties) {
            return new SignalLiveStopRsp(properties);
        };

        /**
         * Encodes the specified SignalLiveStopRsp message. Does not implicitly {@link liveroom_cs.SignalLiveStopRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveStopRsp
         * @static
         * @param {liveroom_cs.ISignalLiveStopRsp} message SignalLiveStopRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveStopRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveStopRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveStopRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveStopRsp} SignalLiveStopRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveStopRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveStopRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveStopRsp;
    })();

    liveroom_cs.SignalLiveCustomReq = (function() {

        /**
         * Properties of a SignalLiveCustomReq.
         * @memberof liveroom_cs
         * @interface ISignalLiveCustomReq
         * @property {liveroom_cs.IReqHead|null} [req_head] SignalLiveCustomReq req_head
         * @property {Uint8Array|null} [push_message] SignalLiveCustomReq push_message
         * @property {Array.<liveroom_cs.IStDstUser>|null} [dst_userlist] SignalLiveCustomReq dst_userlist
         */

        /**
         * Constructs a new SignalLiveCustomReq.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveCustomReq.
         * @implements ISignalLiveCustomReq
         * @constructor
         * @param {liveroom_cs.ISignalLiveCustomReq=} [properties] Properties to set
         */
        function SignalLiveCustomReq(properties) {
            this.dst_userlist = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveCustomReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.SignalLiveCustomReq
         * @instance
         */
        SignalLiveCustomReq.prototype.req_head = null;

        /**
         * SignalLiveCustomReq push_message.
         * @member {Uint8Array} push_message
         * @memberof liveroom_cs.SignalLiveCustomReq
         * @instance
         */
        SignalLiveCustomReq.prototype.push_message = $util.newBuffer([]);

        /**
         * SignalLiveCustomReq dst_userlist.
         * @member {Array.<liveroom_cs.IStDstUser>} dst_userlist
         * @memberof liveroom_cs.SignalLiveCustomReq
         * @instance
         */
        SignalLiveCustomReq.prototype.dst_userlist = $util.emptyArray;

        /**
         * Creates a new SignalLiveCustomReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveCustomReq
         * @static
         * @param {liveroom_cs.ISignalLiveCustomReq=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveCustomReq} SignalLiveCustomReq instance
         */
        SignalLiveCustomReq.create = function create(properties) {
            return new SignalLiveCustomReq(properties);
        };

        /**
         * Encodes the specified SignalLiveCustomReq message. Does not implicitly {@link liveroom_cs.SignalLiveCustomReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveCustomReq
         * @static
         * @param {liveroom_cs.ISignalLiveCustomReq} message SignalLiveCustomReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveCustomReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.push_message != null && Object.hasOwnProperty.call(message, "push_message"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.push_message);
            if (message.dst_userlist != null && message.dst_userlist.length)
                for (var i = 0; i < message.dst_userlist.length; ++i)
                    $root.liveroom_cs.StDstUser.encode(message.dst_userlist[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveCustomReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveCustomReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveCustomReq} SignalLiveCustomReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveCustomReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveCustomReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.push_message = reader.bytes();
                    break;
                case 3:
                    if (!(message.dst_userlist && message.dst_userlist.length))
                        message.dst_userlist = [];
                    message.dst_userlist.push($root.liveroom_cs.StDstUser.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveCustomReq;
    })();

    liveroom_cs.SignalLiveCustomRsp = (function() {

        /**
         * Properties of a SignalLiveCustomRsp.
         * @memberof liveroom_cs
         * @interface ISignalLiveCustomRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] SignalLiveCustomRsp rsp_head
         */

        /**
         * Constructs a new SignalLiveCustomRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a SignalLiveCustomRsp.
         * @implements ISignalLiveCustomRsp
         * @constructor
         * @param {liveroom_cs.ISignalLiveCustomRsp=} [properties] Properties to set
         */
        function SignalLiveCustomRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SignalLiveCustomRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.SignalLiveCustomRsp
         * @instance
         */
        SignalLiveCustomRsp.prototype.rsp_head = null;

        /**
         * Creates a new SignalLiveCustomRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.SignalLiveCustomRsp
         * @static
         * @param {liveroom_cs.ISignalLiveCustomRsp=} [properties] Properties to set
         * @returns {liveroom_cs.SignalLiveCustomRsp} SignalLiveCustomRsp instance
         */
        SignalLiveCustomRsp.create = function create(properties) {
            return new SignalLiveCustomRsp(properties);
        };

        /**
         * Encodes the specified SignalLiveCustomRsp message. Does not implicitly {@link liveroom_cs.SignalLiveCustomRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.SignalLiveCustomRsp
         * @static
         * @param {liveroom_cs.ISignalLiveCustomRsp} message SignalLiveCustomRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignalLiveCustomRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a SignalLiveCustomRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.SignalLiveCustomRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.SignalLiveCustomRsp} SignalLiveCustomRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignalLiveCustomRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.SignalLiveCustomRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return SignalLiveCustomRsp;
    })();

    liveroom_cs.ImChatReq = (function() {

        /**
         * Properties of an ImChatReq.
         * @memberof liveroom_cs
         * @interface IImChatReq
         * @property {liveroom_cs.IReqHead|null} [req_head] ImChatReq req_head
         * @property {number|null} [msg_category] ImChatReq msg_category
         * @property {number|null} [msg_type] ImChatReq msg_type
         * @property {number|null} [msg_priority] ImChatReq msg_priority
         * @property {Uint8Array|null} [msg_content] ImChatReq msg_content
         * @property {Array.<liveroom_cs.IStDstUser>|null} [dst_userlist] ImChatReq dst_userlist
         */

        /**
         * Constructs a new ImChatReq.
         * @memberof liveroom_cs
         * @classdesc Represents an ImChatReq.
         * @implements IImChatReq
         * @constructor
         * @param {liveroom_cs.IImChatReq=} [properties] Properties to set
         */
        function ImChatReq(properties) {
            this.dst_userlist = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImChatReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.ImChatReq
         * @instance
         */
        ImChatReq.prototype.req_head = null;

        /**
         * ImChatReq msg_category.
         * @member {number} msg_category
         * @memberof liveroom_cs.ImChatReq
         * @instance
         */
        ImChatReq.prototype.msg_category = 0;

        /**
         * ImChatReq msg_type.
         * @member {number} msg_type
         * @memberof liveroom_cs.ImChatReq
         * @instance
         */
        ImChatReq.prototype.msg_type = 0;

        /**
         * ImChatReq msg_priority.
         * @member {number} msg_priority
         * @memberof liveroom_cs.ImChatReq
         * @instance
         */
        ImChatReq.prototype.msg_priority = 0;

        /**
         * ImChatReq msg_content.
         * @member {Uint8Array} msg_content
         * @memberof liveroom_cs.ImChatReq
         * @instance
         */
        ImChatReq.prototype.msg_content = $util.newBuffer([]);

        /**
         * ImChatReq dst_userlist.
         * @member {Array.<liveroom_cs.IStDstUser>} dst_userlist
         * @memberof liveroom_cs.ImChatReq
         * @instance
         */
        ImChatReq.prototype.dst_userlist = $util.emptyArray;

        /**
         * Creates a new ImChatReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.ImChatReq
         * @static
         * @param {liveroom_cs.IImChatReq=} [properties] Properties to set
         * @returns {liveroom_cs.ImChatReq} ImChatReq instance
         */
        ImChatReq.create = function create(properties) {
            return new ImChatReq(properties);
        };

        /**
         * Encodes the specified ImChatReq message. Does not implicitly {@link liveroom_cs.ImChatReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.ImChatReq
         * @static
         * @param {liveroom_cs.IImChatReq} message ImChatReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImChatReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.msg_category != null && Object.hasOwnProperty.call(message, "msg_category"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.msg_category);
            if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.msg_type);
            if (message.msg_priority != null && Object.hasOwnProperty.call(message, "msg_priority"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.msg_priority);
            if (message.msg_content != null && Object.hasOwnProperty.call(message, "msg_content"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.msg_content);
            if (message.dst_userlist != null && message.dst_userlist.length)
                for (var i = 0; i < message.dst_userlist.length; ++i)
                    $root.liveroom_cs.StDstUser.encode(message.dst_userlist[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes an ImChatReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.ImChatReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.ImChatReq} ImChatReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImChatReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.ImChatReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.msg_category = reader.uint32();
                    break;
                case 3:
                    message.msg_type = reader.uint32();
                    break;
                case 4:
                    message.msg_priority = reader.uint32();
                    break;
                case 5:
                    message.msg_content = reader.bytes();
                    break;
                case 6:
                    if (!(message.dst_userlist && message.dst_userlist.length))
                        message.dst_userlist = [];
                    message.dst_userlist.push($root.liveroom_cs.StDstUser.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ImChatReq;
    })();

    liveroom_cs.ImChatRsp = (function() {

        /**
         * Properties of an ImChatRsp.
         * @memberof liveroom_cs
         * @interface IImChatRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] ImChatRsp rsp_head
         * @property {number|Long|null} [msg_id] ImChatRsp msg_id
         */

        /**
         * Constructs a new ImChatRsp.
         * @memberof liveroom_cs
         * @classdesc Represents an ImChatRsp.
         * @implements IImChatRsp
         * @constructor
         * @param {liveroom_cs.IImChatRsp=} [properties] Properties to set
         */
        function ImChatRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImChatRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.ImChatRsp
         * @instance
         */
        ImChatRsp.prototype.rsp_head = null;

        /**
         * ImChatRsp msg_id.
         * @member {number|Long} msg_id
         * @memberof liveroom_cs.ImChatRsp
         * @instance
         */
        ImChatRsp.prototype.msg_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ImChatRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.ImChatRsp
         * @static
         * @param {liveroom_cs.IImChatRsp=} [properties] Properties to set
         * @returns {liveroom_cs.ImChatRsp} ImChatRsp instance
         */
        ImChatRsp.create = function create(properties) {
            return new ImChatRsp(properties);
        };

        /**
         * Encodes the specified ImChatRsp message. Does not implicitly {@link liveroom_cs.ImChatRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.ImChatRsp
         * @static
         * @param {liveroom_cs.IImChatRsp} message ImChatRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImChatRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.msg_id != null && Object.hasOwnProperty.call(message, "msg_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.msg_id);
            return writer;
        };

        /**
         * Decodes an ImChatRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.ImChatRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.ImChatRsp} ImChatRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImChatRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.ImChatRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.msg_id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ImChatRsp;
    })();

    liveroom_cs.ImGethatReq = (function() {

        /**
         * Properties of an ImGethatReq.
         * @memberof liveroom_cs
         * @interface IImGethatReq
         * @property {liveroom_cs.IReqHead|null} [req_head] ImGethatReq req_head
         * @property {number|null} [msg_priority] ImGethatReq msg_priority
         * @property {number|Long|null} [msg_id] ImGethatReq msg_id
         * @property {number|null} [sort_type] ImGethatReq sort_type
         * @property {number|null} [msg_count] ImGethatReq msg_count
         */

        /**
         * Constructs a new ImGethatReq.
         * @memberof liveroom_cs
         * @classdesc Represents an ImGethatReq.
         * @implements IImGethatReq
         * @constructor
         * @param {liveroom_cs.IImGethatReq=} [properties] Properties to set
         */
        function ImGethatReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImGethatReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.ImGethatReq
         * @instance
         */
        ImGethatReq.prototype.req_head = null;

        /**
         * ImGethatReq msg_priority.
         * @member {number} msg_priority
         * @memberof liveroom_cs.ImGethatReq
         * @instance
         */
        ImGethatReq.prototype.msg_priority = 0;

        /**
         * ImGethatReq msg_id.
         * @member {number|Long} msg_id
         * @memberof liveroom_cs.ImGethatReq
         * @instance
         */
        ImGethatReq.prototype.msg_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ImGethatReq sort_type.
         * @member {number} sort_type
         * @memberof liveroom_cs.ImGethatReq
         * @instance
         */
        ImGethatReq.prototype.sort_type = 0;

        /**
         * ImGethatReq msg_count.
         * @member {number} msg_count
         * @memberof liveroom_cs.ImGethatReq
         * @instance
         */
        ImGethatReq.prototype.msg_count = 0;

        /**
         * Creates a new ImGethatReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.ImGethatReq
         * @static
         * @param {liveroom_cs.IImGethatReq=} [properties] Properties to set
         * @returns {liveroom_cs.ImGethatReq} ImGethatReq instance
         */
        ImGethatReq.create = function create(properties) {
            return new ImGethatReq(properties);
        };

        /**
         * Encodes the specified ImGethatReq message. Does not implicitly {@link liveroom_cs.ImGethatReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.ImGethatReq
         * @static
         * @param {liveroom_cs.IImGethatReq} message ImGethatReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImGethatReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.msg_priority != null && Object.hasOwnProperty.call(message, "msg_priority"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.msg_priority);
            if (message.msg_id != null && Object.hasOwnProperty.call(message, "msg_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.msg_id);
            if (message.sort_type != null && Object.hasOwnProperty.call(message, "sort_type"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.sort_type);
            if (message.msg_count != null && Object.hasOwnProperty.call(message, "msg_count"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.msg_count);
            return writer;
        };

        /**
         * Decodes an ImGethatReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.ImGethatReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.ImGethatReq} ImGethatReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImGethatReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.ImGethatReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.msg_priority = reader.uint32();
                    break;
                case 3:
                    message.msg_id = reader.uint64();
                    break;
                case 4:
                    message.sort_type = reader.uint32();
                    break;
                case 5:
                    message.msg_count = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ImGethatReq;
    })();

    liveroom_cs.ImGetChatRsp = (function() {

        /**
         * Properties of an ImGetChatRsp.
         * @memberof liveroom_cs
         * @interface IImGetChatRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] ImGetChatRsp rsp_head
         * @property {number|Long|null} [server_msg_id] ImGetChatRsp server_msg_id
         * @property {number|Long|null} [ret_msg_id] ImGetChatRsp ret_msg_id
         * @property {Array.<liveroom_cs.IStMsgData>|null} [msg_data] ImGetChatRsp msg_data
         */

        /**
         * Constructs a new ImGetChatRsp.
         * @memberof liveroom_cs
         * @classdesc Represents an ImGetChatRsp.
         * @implements IImGetChatRsp
         * @constructor
         * @param {liveroom_cs.IImGetChatRsp=} [properties] Properties to set
         */
        function ImGetChatRsp(properties) {
            this.msg_data = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImGetChatRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.ImGetChatRsp
         * @instance
         */
        ImGetChatRsp.prototype.rsp_head = null;

        /**
         * ImGetChatRsp server_msg_id.
         * @member {number|Long} server_msg_id
         * @memberof liveroom_cs.ImGetChatRsp
         * @instance
         */
        ImGetChatRsp.prototype.server_msg_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ImGetChatRsp ret_msg_id.
         * @member {number|Long} ret_msg_id
         * @memberof liveroom_cs.ImGetChatRsp
         * @instance
         */
        ImGetChatRsp.prototype.ret_msg_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ImGetChatRsp msg_data.
         * @member {Array.<liveroom_cs.IStMsgData>} msg_data
         * @memberof liveroom_cs.ImGetChatRsp
         * @instance
         */
        ImGetChatRsp.prototype.msg_data = $util.emptyArray;

        /**
         * Creates a new ImGetChatRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.ImGetChatRsp
         * @static
         * @param {liveroom_cs.IImGetChatRsp=} [properties] Properties to set
         * @returns {liveroom_cs.ImGetChatRsp} ImGetChatRsp instance
         */
        ImGetChatRsp.create = function create(properties) {
            return new ImGetChatRsp(properties);
        };

        /**
         * Encodes the specified ImGetChatRsp message. Does not implicitly {@link liveroom_cs.ImGetChatRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.ImGetChatRsp
         * @static
         * @param {liveroom_cs.IImGetChatRsp} message ImGetChatRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImGetChatRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.server_msg_id != null && Object.hasOwnProperty.call(message, "server_msg_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.server_msg_id);
            if (message.ret_msg_id != null && Object.hasOwnProperty.call(message, "ret_msg_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.ret_msg_id);
            if (message.msg_data != null && message.msg_data.length)
                for (var i = 0; i < message.msg_data.length; ++i)
                    $root.liveroom_cs.StMsgData.encode(message.msg_data[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes an ImGetChatRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.ImGetChatRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.ImGetChatRsp} ImGetChatRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImGetChatRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.ImGetChatRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.server_msg_id = reader.uint64();
                    break;
                case 3:
                    message.ret_msg_id = reader.uint64();
                    break;
                case 4:
                    if (!(message.msg_data && message.msg_data.length))
                        message.msg_data = [];
                    message.msg_data.push($root.liveroom_cs.StMsgData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return ImGetChatRsp;
    })();

    liveroom_cs.StMsgData = (function() {

        /**
         * Properties of a StMsgData.
         * @memberof liveroom_cs
         * @interface IStMsgData
         * @property {Uint8Array|null} [id_name] StMsgData id_name
         * @property {Uint8Array|null} [nick_name] StMsgData nick_name
         * @property {number|null} [role] StMsgData role
         * @property {number|Long|null} [msg_id] StMsgData msg_id
         * @property {number|null} [msg_category] StMsgData msg_category
         * @property {number|null} [msg_type] StMsgData msg_type
         * @property {number|null} [msg_priority] StMsgData msg_priority
         * @property {Uint8Array|null} [msg_content] StMsgData msg_content
         * @property {number|Long|null} [send_time] StMsgData send_time
         */

        /**
         * Constructs a new StMsgData.
         * @memberof liveroom_cs
         * @classdesc Represents a StMsgData.
         * @implements IStMsgData
         * @constructor
         * @param {liveroom_cs.IStMsgData=} [properties] Properties to set
         */
        function StMsgData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StMsgData id_name.
         * @member {Uint8Array} id_name
         * @memberof liveroom_cs.StMsgData
         * @instance
         */
        StMsgData.prototype.id_name = $util.newBuffer([]);

        /**
         * StMsgData nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.StMsgData
         * @instance
         */
        StMsgData.prototype.nick_name = $util.newBuffer([]);

        /**
         * StMsgData role.
         * @member {number} role
         * @memberof liveroom_cs.StMsgData
         * @instance
         */
        StMsgData.prototype.role = 0;

        /**
         * StMsgData msg_id.
         * @member {number|Long} msg_id
         * @memberof liveroom_cs.StMsgData
         * @instance
         */
        StMsgData.prototype.msg_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StMsgData msg_category.
         * @member {number} msg_category
         * @memberof liveroom_cs.StMsgData
         * @instance
         */
        StMsgData.prototype.msg_category = 0;

        /**
         * StMsgData msg_type.
         * @member {number} msg_type
         * @memberof liveroom_cs.StMsgData
         * @instance
         */
        StMsgData.prototype.msg_type = 0;

        /**
         * StMsgData msg_priority.
         * @member {number} msg_priority
         * @memberof liveroom_cs.StMsgData
         * @instance
         */
        StMsgData.prototype.msg_priority = 0;

        /**
         * StMsgData msg_content.
         * @member {Uint8Array} msg_content
         * @memberof liveroom_cs.StMsgData
         * @instance
         */
        StMsgData.prototype.msg_content = $util.newBuffer([]);

        /**
         * StMsgData send_time.
         * @member {number|Long} send_time
         * @memberof liveroom_cs.StMsgData
         * @instance
         */
        StMsgData.prototype.send_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new StMsgData instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StMsgData
         * @static
         * @param {liveroom_cs.IStMsgData=} [properties] Properties to set
         * @returns {liveroom_cs.StMsgData} StMsgData instance
         */
        StMsgData.create = function create(properties) {
            return new StMsgData(properties);
        };

        /**
         * Encodes the specified StMsgData message. Does not implicitly {@link liveroom_cs.StMsgData.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StMsgData
         * @static
         * @param {liveroom_cs.IStMsgData} message StMsgData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StMsgData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id_name);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.role);
            if (message.msg_id != null && Object.hasOwnProperty.call(message, "msg_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.msg_id);
            if (message.msg_category != null && Object.hasOwnProperty.call(message, "msg_category"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.msg_category);
            if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.msg_type);
            if (message.msg_priority != null && Object.hasOwnProperty.call(message, "msg_priority"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.msg_priority);
            if (message.msg_content != null && Object.hasOwnProperty.call(message, "msg_content"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.msg_content);
            if (message.send_time != null && Object.hasOwnProperty.call(message, "send_time"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.send_time);
            return writer;
        };

        /**
         * Decodes a StMsgData message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StMsgData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StMsgData} StMsgData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StMsgData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StMsgData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id_name = reader.bytes();
                    break;
                case 2:
                    message.nick_name = reader.bytes();
                    break;
                case 3:
                    message.role = reader.uint32();
                    break;
                case 4:
                    message.msg_id = reader.uint64();
                    break;
                case 5:
                    message.msg_category = reader.uint32();
                    break;
                case 6:
                    message.msg_type = reader.uint32();
                    break;
                case 7:
                    message.msg_priority = reader.uint32();
                    break;
                case 8:
                    message.msg_content = reader.bytes();
                    break;
                case 9:
                    message.send_time = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StMsgData;
    })();

    liveroom_cs.EnterReq = (function() {

        /**
         * Properties of an EnterReq.
         * @memberof liveroom_cs
         * @interface IEnterReq
         * @property {liveroom_cs.IReqHead|null} [req_head] EnterReq req_head
         * @property {number|Long|null} [switch_session_id] EnterReq switch_session_id
         * @property {Uint8Array|null} [nick_name] EnterReq nick_name
         * @property {number|null} [role] EnterReq role
         * @property {number|null} [net_type] EnterReq net_type
         * @property {liveroom_cs.IStConfigList|null} [config] EnterReq config
         * @property {string|null} [lv_key] EnterReq lv_key
         * @property {Uint8Array|null} [third_token] EnterReq third_token
         * @property {number|Long|null} [cluster_req] EnterReq cluster_req
         * @property {number|null} [user_count_limit] EnterReq user_count_limit
         * @property {string|null} [relate_service] EnterReq relate_service
         * @property {number|null} [conn_type] EnterReq conn_type
         * @property {Uint8Array|null} [room_name] EnterReq room_name
         */

        /**
         * Constructs a new EnterReq.
         * @memberof liveroom_cs
         * @classdesc Represents an EnterReq.
         * @implements IEnterReq
         * @constructor
         * @param {liveroom_cs.IEnterReq=} [properties] Properties to set
         */
        function EnterReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.req_head = null;

        /**
         * EnterReq switch_session_id.
         * @member {number|Long} switch_session_id
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.switch_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EnterReq nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.nick_name = $util.newBuffer([]);

        /**
         * EnterReq role.
         * @member {number} role
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.role = 0;

        /**
         * EnterReq net_type.
         * @member {number} net_type
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.net_type = 0;

        /**
         * EnterReq config.
         * @member {liveroom_cs.IStConfigList|null|undefined} config
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.config = null;

        /**
         * EnterReq lv_key.
         * @member {string} lv_key
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.lv_key = "";

        /**
         * EnterReq third_token.
         * @member {Uint8Array} third_token
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.third_token = $util.newBuffer([]);

        /**
         * EnterReq cluster_req.
         * @member {number|Long} cluster_req
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.cluster_req = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EnterReq user_count_limit.
         * @member {number} user_count_limit
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.user_count_limit = 0;

        /**
         * EnterReq relate_service.
         * @member {string} relate_service
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.relate_service = "";

        /**
         * EnterReq conn_type.
         * @member {number} conn_type
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.conn_type = 0;

        /**
         * EnterReq room_name.
         * @member {Uint8Array} room_name
         * @memberof liveroom_cs.EnterReq
         * @instance
         */
        EnterReq.prototype.room_name = $util.newBuffer([]);

        /**
         * Creates a new EnterReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.EnterReq
         * @static
         * @param {liveroom_cs.IEnterReq=} [properties] Properties to set
         * @returns {liveroom_cs.EnterReq} EnterReq instance
         */
        EnterReq.create = function create(properties) {
            return new EnterReq(properties);
        };

        /**
         * Encodes the specified EnterReq message. Does not implicitly {@link liveroom_cs.EnterReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.EnterReq
         * @static
         * @param {liveroom_cs.IEnterReq} message EnterReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.switch_session_id != null && Object.hasOwnProperty.call(message, "switch_session_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.switch_session_id);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.role);
            if (message.net_type != null && Object.hasOwnProperty.call(message, "net_type"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.net_type);
            if (message.config != null && Object.hasOwnProperty.call(message, "config"))
                $root.liveroom_cs.StConfigList.encode(message.config, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.lv_key != null && Object.hasOwnProperty.call(message, "lv_key"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.lv_key);
            if (message.third_token != null && Object.hasOwnProperty.call(message, "third_token"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.third_token);
            if (message.cluster_req != null && Object.hasOwnProperty.call(message, "cluster_req"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.cluster_req);
            if (message.user_count_limit != null && Object.hasOwnProperty.call(message, "user_count_limit"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.user_count_limit);
            if (message.relate_service != null && Object.hasOwnProperty.call(message, "relate_service"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.relate_service);
            if (message.conn_type != null && Object.hasOwnProperty.call(message, "conn_type"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.conn_type);
            if (message.room_name != null && Object.hasOwnProperty.call(message, "room_name"))
                writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.room_name);
            return writer;
        };

        /**
         * Decodes an EnterReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.EnterReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.EnterReq} EnterReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.EnterReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.switch_session_id = reader.uint64();
                    break;
                case 3:
                    message.nick_name = reader.bytes();
                    break;
                case 4:
                    message.role = reader.uint32();
                    break;
                case 5:
                    message.net_type = reader.uint32();
                    break;
                case 6:
                    message.config = $root.liveroom_cs.StConfigList.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.lv_key = reader.string();
                    break;
                case 8:
                    message.third_token = reader.bytes();
                    break;
                case 9:
                    message.cluster_req = reader.uint64();
                    break;
                case 10:
                    message.user_count_limit = reader.uint32();
                    break;
                case 11:
                    message.relate_service = reader.string();
                    break;
                case 12:
                    message.conn_type = reader.uint32();
                    break;
                case 13:
                    message.room_name = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return EnterReq;
    })();

    liveroom_cs.EnterRsp = (function() {

        /**
         * Properties of an EnterRsp.
         * @memberof liveroom_cs
         * @interface IEnterRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] EnterRsp rsp_head
         * @property {Uint8Array|null} [room_id] EnterRsp room_id
         * @property {number|Long|null} [user_session_id] EnterRsp user_session_id
         * @property {number|Long|null} [room_session_id] EnterRsp room_session_id
         * @property {number|Long|null} [user_id] EnterRsp user_id
         * @property {number|Long|null} [ret_timestamp] EnterRsp ret_timestamp
         * @property {number|null} [bigim_time_window] EnterRsp bigim_time_window
         * @property {number|Long|null} [dati_time_window] EnterRsp dati_time_window
         * @property {number|null} [room_id32] EnterRsp room_id32
         * @property {number|null} [hb_interval] EnterRsp hb_interval
         * @property {number|null} [hb_timeout] EnterRsp hb_timeout
         * @property {string|null} [lv_key] EnterRsp lv_key
         * @property {string|null} [zp_key] EnterRsp zp_key
         * @property {number|null} [online_count] EnterRsp online_count
         * @property {liveroom_cs.IStAnchorInfo|null} [anchor_info] EnterRsp anchor_info
         * @property {number|null} [stream_seq] EnterRsp stream_seq
         * @property {Array.<liveroom_cs.IStStreamInfo>|null} [stream_info] EnterRsp stream_info
         * @property {Array.<liveroom_cs.IStStreamInfo>|null} [stream_mix_info] EnterRsp stream_mix_info
         * @property {number|null} [userlist_merge_timeout] EnterRsp userlist_merge_timeout
         * @property {number|null} [userlist_interval] EnterRsp userlist_interval
         * @property {number|null} [stream_list_push_merge_timeout] EnterRsp stream_list_push_merge_timeout
         * @property {number|null} [stream_list_hb_wait_merge_time] EnterRsp stream_list_hb_wait_merge_time
         * @property {number|null} [trans_list_seq] EnterRsp trans_list_seq
         * @property {Array.<liveroom_cs.IStTransInfo>|null} [trans_seqs] EnterRsp trans_seqs
         * @property {string|null} [cluster_name] EnterRsp cluster_name
         * @property {number|null} [token_remain_time] EnterRsp token_remain_time
         * @property {number|null} [stream_fetch_flag] EnterRsp stream_fetch_flag
         */

        /**
         * Constructs a new EnterRsp.
         * @memberof liveroom_cs
         * @classdesc Represents an EnterRsp.
         * @implements IEnterRsp
         * @constructor
         * @param {liveroom_cs.IEnterRsp=} [properties] Properties to set
         */
        function EnterRsp(properties) {
            this.stream_info = [];
            this.stream_mix_info = [];
            this.trans_seqs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.rsp_head = null;

        /**
         * EnterRsp room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.room_id = $util.newBuffer([]);

        /**
         * EnterRsp user_session_id.
         * @member {number|Long} user_session_id
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.user_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EnterRsp room_session_id.
         * @member {number|Long} room_session_id
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.room_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EnterRsp user_id.
         * @member {number|Long} user_id
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.user_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EnterRsp ret_timestamp.
         * @member {number|Long} ret_timestamp
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.ret_timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EnterRsp bigim_time_window.
         * @member {number} bigim_time_window
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.bigim_time_window = 0;

        /**
         * EnterRsp dati_time_window.
         * @member {number|Long} dati_time_window
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.dati_time_window = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EnterRsp room_id32.
         * @member {number} room_id32
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.room_id32 = 0;

        /**
         * EnterRsp hb_interval.
         * @member {number} hb_interval
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.hb_interval = 0;

        /**
         * EnterRsp hb_timeout.
         * @member {number} hb_timeout
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.hb_timeout = 0;

        /**
         * EnterRsp lv_key.
         * @member {string} lv_key
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.lv_key = "";

        /**
         * EnterRsp zp_key.
         * @member {string} zp_key
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.zp_key = "";

        /**
         * EnterRsp online_count.
         * @member {number} online_count
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.online_count = 0;

        /**
         * EnterRsp anchor_info.
         * @member {liveroom_cs.IStAnchorInfo|null|undefined} anchor_info
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.anchor_info = null;

        /**
         * EnterRsp stream_seq.
         * @member {number} stream_seq
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.stream_seq = 0;

        /**
         * EnterRsp stream_info.
         * @member {Array.<liveroom_cs.IStStreamInfo>} stream_info
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.stream_info = $util.emptyArray;

        /**
         * EnterRsp stream_mix_info.
         * @member {Array.<liveroom_cs.IStStreamInfo>} stream_mix_info
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.stream_mix_info = $util.emptyArray;

        /**
         * EnterRsp userlist_merge_timeout.
         * @member {number} userlist_merge_timeout
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.userlist_merge_timeout = 0;

        /**
         * EnterRsp userlist_interval.
         * @member {number} userlist_interval
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.userlist_interval = 0;

        /**
         * EnterRsp stream_list_push_merge_timeout.
         * @member {number} stream_list_push_merge_timeout
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.stream_list_push_merge_timeout = 0;

        /**
         * EnterRsp stream_list_hb_wait_merge_time.
         * @member {number} stream_list_hb_wait_merge_time
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.stream_list_hb_wait_merge_time = 0;

        /**
         * EnterRsp trans_list_seq.
         * @member {number} trans_list_seq
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.trans_list_seq = 0;

        /**
         * EnterRsp trans_seqs.
         * @member {Array.<liveroom_cs.IStTransInfo>} trans_seqs
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.trans_seqs = $util.emptyArray;

        /**
         * EnterRsp cluster_name.
         * @member {string} cluster_name
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.cluster_name = "";

        /**
         * EnterRsp token_remain_time.
         * @member {number} token_remain_time
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.token_remain_time = 0;

        /**
         * EnterRsp stream_fetch_flag.
         * @member {number} stream_fetch_flag
         * @memberof liveroom_cs.EnterRsp
         * @instance
         */
        EnterRsp.prototype.stream_fetch_flag = 0;

        /**
         * Creates a new EnterRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.EnterRsp
         * @static
         * @param {liveroom_cs.IEnterRsp=} [properties] Properties to set
         * @returns {liveroom_cs.EnterRsp} EnterRsp instance
         */
        EnterRsp.create = function create(properties) {
            return new EnterRsp(properties);
        };

        /**
         * Encodes the specified EnterRsp message. Does not implicitly {@link liveroom_cs.EnterRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.EnterRsp
         * @static
         * @param {liveroom_cs.IEnterRsp} message EnterRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.room_id);
            if (message.user_session_id != null && Object.hasOwnProperty.call(message, "user_session_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.user_session_id);
            if (message.room_session_id != null && Object.hasOwnProperty.call(message, "room_session_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.room_session_id);
            if (message.user_id != null && Object.hasOwnProperty.call(message, "user_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.user_id);
            if (message.ret_timestamp != null && Object.hasOwnProperty.call(message, "ret_timestamp"))
                writer.uint32(/* id 6, wireType 1 =*/49).fixed64(message.ret_timestamp);
            if (message.bigim_time_window != null && Object.hasOwnProperty.call(message, "bigim_time_window"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.bigim_time_window);
            if (message.dati_time_window != null && Object.hasOwnProperty.call(message, "dati_time_window"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.dati_time_window);
            if (message.room_id32 != null && Object.hasOwnProperty.call(message, "room_id32"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.room_id32);
            if (message.hb_interval != null && Object.hasOwnProperty.call(message, "hb_interval"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.hb_interval);
            if (message.hb_timeout != null && Object.hasOwnProperty.call(message, "hb_timeout"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.hb_timeout);
            if (message.lv_key != null && Object.hasOwnProperty.call(message, "lv_key"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.lv_key);
            if (message.zp_key != null && Object.hasOwnProperty.call(message, "zp_key"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.zp_key);
            if (message.online_count != null && Object.hasOwnProperty.call(message, "online_count"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.online_count);
            if (message.anchor_info != null && Object.hasOwnProperty.call(message, "anchor_info"))
                $root.liveroom_cs.StAnchorInfo.encode(message.anchor_info, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.stream_seq != null && Object.hasOwnProperty.call(message, "stream_seq"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.stream_seq);
            if (message.stream_info != null && message.stream_info.length)
                for (var i = 0; i < message.stream_info.length; ++i)
                    $root.liveroom_cs.StStreamInfo.encode(message.stream_info[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.stream_mix_info != null && message.stream_mix_info.length)
                for (var i = 0; i < message.stream_mix_info.length; ++i)
                    $root.liveroom_cs.StStreamInfo.encode(message.stream_mix_info[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.userlist_merge_timeout != null && Object.hasOwnProperty.call(message, "userlist_merge_timeout"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.userlist_merge_timeout);
            if (message.userlist_interval != null && Object.hasOwnProperty.call(message, "userlist_interval"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.userlist_interval);
            if (message.stream_list_push_merge_timeout != null && Object.hasOwnProperty.call(message, "stream_list_push_merge_timeout"))
                writer.uint32(/* id 21, wireType 0 =*/168).uint32(message.stream_list_push_merge_timeout);
            if (message.stream_list_hb_wait_merge_time != null && Object.hasOwnProperty.call(message, "stream_list_hb_wait_merge_time"))
                writer.uint32(/* id 22, wireType 0 =*/176).uint32(message.stream_list_hb_wait_merge_time);
            if (message.trans_list_seq != null && Object.hasOwnProperty.call(message, "trans_list_seq"))
                writer.uint32(/* id 23, wireType 0 =*/184).uint32(message.trans_list_seq);
            if (message.trans_seqs != null && message.trans_seqs.length)
                for (var i = 0; i < message.trans_seqs.length; ++i)
                    $root.liveroom_cs.StTransInfo.encode(message.trans_seqs[i], writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.cluster_name != null && Object.hasOwnProperty.call(message, "cluster_name"))
                writer.uint32(/* id 25, wireType 2 =*/202).string(message.cluster_name);
            if (message.token_remain_time != null && Object.hasOwnProperty.call(message, "token_remain_time"))
                writer.uint32(/* id 26, wireType 0 =*/208).uint32(message.token_remain_time);
            if (message.stream_fetch_flag != null && Object.hasOwnProperty.call(message, "stream_fetch_flag"))
                writer.uint32(/* id 27, wireType 0 =*/216).uint32(message.stream_fetch_flag);
            return writer;
        };

        /**
         * Decodes an EnterRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.EnterRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.EnterRsp} EnterRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.EnterRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.room_id = reader.bytes();
                    break;
                case 3:
                    message.user_session_id = reader.uint64();
                    break;
                case 4:
                    message.room_session_id = reader.uint64();
                    break;
                case 5:
                    message.user_id = reader.uint64();
                    break;
                case 6:
                    message.ret_timestamp = reader.fixed64();
                    break;
                case 7:
                    message.bigim_time_window = reader.uint32();
                    break;
                case 8:
                    message.dati_time_window = reader.int64();
                    break;
                case 9:
                    message.room_id32 = reader.uint32();
                    break;
                case 10:
                    message.hb_interval = reader.uint32();
                    break;
                case 11:
                    message.hb_timeout = reader.uint32();
                    break;
                case 12:
                    message.lv_key = reader.string();
                    break;
                case 13:
                    message.zp_key = reader.string();
                    break;
                case 14:
                    message.online_count = reader.uint32();
                    break;
                case 15:
                    message.anchor_info = $root.liveroom_cs.StAnchorInfo.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.stream_seq = reader.uint32();
                    break;
                case 17:
                    if (!(message.stream_info && message.stream_info.length))
                        message.stream_info = [];
                    message.stream_info.push($root.liveroom_cs.StStreamInfo.decode(reader, reader.uint32()));
                    break;
                case 18:
                    if (!(message.stream_mix_info && message.stream_mix_info.length))
                        message.stream_mix_info = [];
                    message.stream_mix_info.push($root.liveroom_cs.StStreamInfo.decode(reader, reader.uint32()));
                    break;
                case 19:
                    message.userlist_merge_timeout = reader.uint32();
                    break;
                case 20:
                    message.userlist_interval = reader.uint32();
                    break;
                case 21:
                    message.stream_list_push_merge_timeout = reader.uint32();
                    break;
                case 22:
                    message.stream_list_hb_wait_merge_time = reader.uint32();
                    break;
                case 23:
                    message.trans_list_seq = reader.uint32();
                    break;
                case 24:
                    if (!(message.trans_seqs && message.trans_seqs.length))
                        message.trans_seqs = [];
                    message.trans_seqs.push($root.liveroom_cs.StTransInfo.decode(reader, reader.uint32()));
                    break;
                case 25:
                    message.cluster_name = reader.string();
                    break;
                case 26:
                    message.token_remain_time = reader.uint32();
                    break;
                case 27:
                    message.stream_fetch_flag = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return EnterRsp;
    })();

    liveroom_cs.StAnchorInfo = (function() {

        /**
         * Properties of a StAnchorInfo.
         * @memberof liveroom_cs
         * @interface IStAnchorInfo
         * @property {Uint8Array|null} [anchor_id_name] StAnchorInfo anchor_id_name
         * @property {number|Long|null} [anchor_id] StAnchorInfo anchor_id
         * @property {Uint8Array|null} [anchor_nick_name] StAnchorInfo anchor_nick_name
         */

        /**
         * Constructs a new StAnchorInfo.
         * @memberof liveroom_cs
         * @classdesc Represents a StAnchorInfo.
         * @implements IStAnchorInfo
         * @constructor
         * @param {liveroom_cs.IStAnchorInfo=} [properties] Properties to set
         */
        function StAnchorInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StAnchorInfo anchor_id_name.
         * @member {Uint8Array} anchor_id_name
         * @memberof liveroom_cs.StAnchorInfo
         * @instance
         */
        StAnchorInfo.prototype.anchor_id_name = $util.newBuffer([]);

        /**
         * StAnchorInfo anchor_id.
         * @member {number|Long} anchor_id
         * @memberof liveroom_cs.StAnchorInfo
         * @instance
         */
        StAnchorInfo.prototype.anchor_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StAnchorInfo anchor_nick_name.
         * @member {Uint8Array} anchor_nick_name
         * @memberof liveroom_cs.StAnchorInfo
         * @instance
         */
        StAnchorInfo.prototype.anchor_nick_name = $util.newBuffer([]);

        /**
         * Creates a new StAnchorInfo instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StAnchorInfo
         * @static
         * @param {liveroom_cs.IStAnchorInfo=} [properties] Properties to set
         * @returns {liveroom_cs.StAnchorInfo} StAnchorInfo instance
         */
        StAnchorInfo.create = function create(properties) {
            return new StAnchorInfo(properties);
        };

        /**
         * Encodes the specified StAnchorInfo message. Does not implicitly {@link liveroom_cs.StAnchorInfo.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StAnchorInfo
         * @static
         * @param {liveroom_cs.IStAnchorInfo} message StAnchorInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StAnchorInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.anchor_id_name != null && Object.hasOwnProperty.call(message, "anchor_id_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.anchor_id_name);
            if (message.anchor_id != null && Object.hasOwnProperty.call(message, "anchor_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.anchor_id);
            if (message.anchor_nick_name != null && Object.hasOwnProperty.call(message, "anchor_nick_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.anchor_nick_name);
            return writer;
        };

        /**
         * Decodes a StAnchorInfo message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StAnchorInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StAnchorInfo} StAnchorInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StAnchorInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StAnchorInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.anchor_id_name = reader.bytes();
                    break;
                case 2:
                    message.anchor_id = reader.uint64();
                    break;
                case 3:
                    message.anchor_nick_name = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StAnchorInfo;
    })();

    liveroom_cs.QuitReq = (function() {

        /**
         * Properties of a QuitReq.
         * @memberof liveroom_cs
         * @interface IQuitReq
         * @property {liveroom_cs.IReqHead|null} [req_head] QuitReq req_head
         * @property {number|Long|null} [switch_session_id] QuitReq switch_session_id
         * @property {number|null} [room_id32] QuitReq room_id32
         * @property {Uint8Array|null} [nick_name] QuitReq nick_name
         * @property {number|null} [role] QuitReq role
         * @property {number|null} [net_type] QuitReq net_type
         * @property {liveroom_cs.IStConfigList|null} [config_list] QuitReq config_list
         */

        /**
         * Constructs a new QuitReq.
         * @memberof liveroom_cs
         * @classdesc Represents a QuitReq.
         * @implements IQuitReq
         * @constructor
         * @param {liveroom_cs.IQuitReq=} [properties] Properties to set
         */
        function QuitReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QuitReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.QuitReq
         * @instance
         */
        QuitReq.prototype.req_head = null;

        /**
         * QuitReq switch_session_id.
         * @member {number|Long} switch_session_id
         * @memberof liveroom_cs.QuitReq
         * @instance
         */
        QuitReq.prototype.switch_session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * QuitReq room_id32.
         * @member {number} room_id32
         * @memberof liveroom_cs.QuitReq
         * @instance
         */
        QuitReq.prototype.room_id32 = 0;

        /**
         * QuitReq nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.QuitReq
         * @instance
         */
        QuitReq.prototype.nick_name = $util.newBuffer([]);

        /**
         * QuitReq role.
         * @member {number} role
         * @memberof liveroom_cs.QuitReq
         * @instance
         */
        QuitReq.prototype.role = 0;

        /**
         * QuitReq net_type.
         * @member {number} net_type
         * @memberof liveroom_cs.QuitReq
         * @instance
         */
        QuitReq.prototype.net_type = 0;

        /**
         * QuitReq config_list.
         * @member {liveroom_cs.IStConfigList|null|undefined} config_list
         * @memberof liveroom_cs.QuitReq
         * @instance
         */
        QuitReq.prototype.config_list = null;

        /**
         * Creates a new QuitReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.QuitReq
         * @static
         * @param {liveroom_cs.IQuitReq=} [properties] Properties to set
         * @returns {liveroom_cs.QuitReq} QuitReq instance
         */
        QuitReq.create = function create(properties) {
            return new QuitReq(properties);
        };

        /**
         * Encodes the specified QuitReq message. Does not implicitly {@link liveroom_cs.QuitReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.QuitReq
         * @static
         * @param {liveroom_cs.IQuitReq} message QuitReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QuitReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.switch_session_id != null && Object.hasOwnProperty.call(message, "switch_session_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.switch_session_id);
            if (message.room_id32 != null && Object.hasOwnProperty.call(message, "room_id32"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.room_id32);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.role);
            if (message.net_type != null && Object.hasOwnProperty.call(message, "net_type"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.net_type);
            if (message.config_list != null && Object.hasOwnProperty.call(message, "config_list"))
                $root.liveroom_cs.StConfigList.encode(message.config_list, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a QuitReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.QuitReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.QuitReq} QuitReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QuitReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.QuitReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.switch_session_id = reader.uint64();
                    break;
                case 3:
                    message.room_id32 = reader.uint32();
                    break;
                case 4:
                    message.nick_name = reader.bytes();
                    break;
                case 5:
                    message.role = reader.uint32();
                    break;
                case 6:
                    message.net_type = reader.uint32();
                    break;
                case 7:
                    message.config_list = $root.liveroom_cs.StConfigList.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return QuitReq;
    })();

    liveroom_cs.StConfigList = (function() {

        /**
         * Properties of a StConfigList.
         * @memberof liveroom_cs
         * @interface IStConfigList
         * @property {number|null} [room_create_flag] StConfigList room_create_flag
         * @property {number|null} [user_state_flag] StConfigList user_state_flag
         */

        /**
         * Constructs a new StConfigList.
         * @memberof liveroom_cs
         * @classdesc Represents a StConfigList.
         * @implements IStConfigList
         * @constructor
         * @param {liveroom_cs.IStConfigList=} [properties] Properties to set
         */
        function StConfigList(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StConfigList room_create_flag.
         * @member {number} room_create_flag
         * @memberof liveroom_cs.StConfigList
         * @instance
         */
        StConfigList.prototype.room_create_flag = 0;

        /**
         * StConfigList user_state_flag.
         * @member {number} user_state_flag
         * @memberof liveroom_cs.StConfigList
         * @instance
         */
        StConfigList.prototype.user_state_flag = 0;

        /**
         * Creates a new StConfigList instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StConfigList
         * @static
         * @param {liveroom_cs.IStConfigList=} [properties] Properties to set
         * @returns {liveroom_cs.StConfigList} StConfigList instance
         */
        StConfigList.create = function create(properties) {
            return new StConfigList(properties);
        };

        /**
         * Encodes the specified StConfigList message. Does not implicitly {@link liveroom_cs.StConfigList.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StConfigList
         * @static
         * @param {liveroom_cs.IStConfigList} message StConfigList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StConfigList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.room_create_flag != null && Object.hasOwnProperty.call(message, "room_create_flag"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.room_create_flag);
            if (message.user_state_flag != null && Object.hasOwnProperty.call(message, "user_state_flag"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.user_state_flag);
            return writer;
        };

        /**
         * Decodes a StConfigList message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StConfigList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StConfigList} StConfigList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StConfigList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StConfigList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.room_create_flag = reader.uint32();
                    break;
                case 2:
                    message.user_state_flag = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StConfigList;
    })();

    liveroom_cs.QuitRsp = (function() {

        /**
         * Properties of a QuitRsp.
         * @memberof liveroom_cs
         * @interface IQuitRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] QuitRsp rsp_head
         * @property {Uint8Array|null} [room_id] QuitRsp room_id
         * @property {number|null} [room_id32] QuitRsp room_id32
         */

        /**
         * Constructs a new QuitRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a QuitRsp.
         * @implements IQuitRsp
         * @constructor
         * @param {liveroom_cs.IQuitRsp=} [properties] Properties to set
         */
        function QuitRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QuitRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.QuitRsp
         * @instance
         */
        QuitRsp.prototype.rsp_head = null;

        /**
         * QuitRsp room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.QuitRsp
         * @instance
         */
        QuitRsp.prototype.room_id = $util.newBuffer([]);

        /**
         * QuitRsp room_id32.
         * @member {number} room_id32
         * @memberof liveroom_cs.QuitRsp
         * @instance
         */
        QuitRsp.prototype.room_id32 = 0;

        /**
         * Creates a new QuitRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.QuitRsp
         * @static
         * @param {liveroom_cs.IQuitRsp=} [properties] Properties to set
         * @returns {liveroom_cs.QuitRsp} QuitRsp instance
         */
        QuitRsp.create = function create(properties) {
            return new QuitRsp(properties);
        };

        /**
         * Encodes the specified QuitRsp message. Does not implicitly {@link liveroom_cs.QuitRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.QuitRsp
         * @static
         * @param {liveroom_cs.IQuitRsp} message QuitRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QuitRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.room_id);
            if (message.room_id32 != null && Object.hasOwnProperty.call(message, "room_id32"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.room_id32);
            return writer;
        };

        /**
         * Decodes a QuitRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.QuitRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.QuitRsp} QuitRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QuitRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.QuitRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.room_id = reader.bytes();
                    break;
                case 3:
                    message.room_id32 = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return QuitRsp;
    })();

    liveroom_cs.RoomListReq = (function() {

        /**
         * Properties of a RoomListReq.
         * @memberof liveroom_cs
         * @interface IRoomListReq
         * @property {liveroom_cs.IReqHead|null} [req_head] RoomListReq req_head
         */

        /**
         * Constructs a new RoomListReq.
         * @memberof liveroom_cs
         * @classdesc Represents a RoomListReq.
         * @implements IRoomListReq
         * @constructor
         * @param {liveroom_cs.IRoomListReq=} [properties] Properties to set
         */
        function RoomListReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomListReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.RoomListReq
         * @instance
         */
        RoomListReq.prototype.req_head = null;

        /**
         * Creates a new RoomListReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.RoomListReq
         * @static
         * @param {liveroom_cs.IRoomListReq=} [properties] Properties to set
         * @returns {liveroom_cs.RoomListReq} RoomListReq instance
         */
        RoomListReq.create = function create(properties) {
            return new RoomListReq(properties);
        };

        /**
         * Encodes the specified RoomListReq message. Does not implicitly {@link liveroom_cs.RoomListReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.RoomListReq
         * @static
         * @param {liveroom_cs.IRoomListReq} message RoomListReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoomListReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a RoomListReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.RoomListReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.RoomListReq} RoomListReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomListReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.RoomListReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RoomListReq;
    })();

    liveroom_cs.RoomListRsp = (function() {

        /**
         * Properties of a RoomListRsp.
         * @memberof liveroom_cs
         * @interface IRoomListRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] RoomListRsp rsp_head
         * @property {Array.<liveroom_cs.IStRoomListRoom>|null} [room_list] RoomListRsp room_list
         */

        /**
         * Constructs a new RoomListRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a RoomListRsp.
         * @implements IRoomListRsp
         * @constructor
         * @param {liveroom_cs.IRoomListRsp=} [properties] Properties to set
         */
        function RoomListRsp(properties) {
            this.room_list = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoomListRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.RoomListRsp
         * @instance
         */
        RoomListRsp.prototype.rsp_head = null;

        /**
         * RoomListRsp room_list.
         * @member {Array.<liveroom_cs.IStRoomListRoom>} room_list
         * @memberof liveroom_cs.RoomListRsp
         * @instance
         */
        RoomListRsp.prototype.room_list = $util.emptyArray;

        /**
         * Creates a new RoomListRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.RoomListRsp
         * @static
         * @param {liveroom_cs.IRoomListRsp=} [properties] Properties to set
         * @returns {liveroom_cs.RoomListRsp} RoomListRsp instance
         */
        RoomListRsp.create = function create(properties) {
            return new RoomListRsp(properties);
        };

        /**
         * Encodes the specified RoomListRsp message. Does not implicitly {@link liveroom_cs.RoomListRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.RoomListRsp
         * @static
         * @param {liveroom_cs.IRoomListRsp} message RoomListRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoomListRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.room_list != null && message.room_list.length)
                for (var i = 0; i < message.room_list.length; ++i)
                    $root.liveroom_cs.StRoomListRoom.encode(message.room_list[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a RoomListRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.RoomListRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.RoomListRsp} RoomListRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoomListRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.RoomListRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.room_list && message.room_list.length))
                        message.room_list = [];
                    message.room_list.push($root.liveroom_cs.StRoomListRoom.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RoomListRsp;
    })();

    liveroom_cs.StRoomListStream = (function() {

        /**
         * Properties of a StRoomListStream.
         * @memberof liveroom_cs
         * @interface IStRoomListStream
         * @property {Uint8Array|null} [stream_id] StRoomListStream stream_id
         */

        /**
         * Constructs a new StRoomListStream.
         * @memberof liveroom_cs
         * @classdesc Represents a StRoomListStream.
         * @implements IStRoomListStream
         * @constructor
         * @param {liveroom_cs.IStRoomListStream=} [properties] Properties to set
         */
        function StRoomListStream(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StRoomListStream stream_id.
         * @member {Uint8Array} stream_id
         * @memberof liveroom_cs.StRoomListStream
         * @instance
         */
        StRoomListStream.prototype.stream_id = $util.newBuffer([]);

        /**
         * Creates a new StRoomListStream instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StRoomListStream
         * @static
         * @param {liveroom_cs.IStRoomListStream=} [properties] Properties to set
         * @returns {liveroom_cs.StRoomListStream} StRoomListStream instance
         */
        StRoomListStream.create = function create(properties) {
            return new StRoomListStream(properties);
        };

        /**
         * Encodes the specified StRoomListStream message. Does not implicitly {@link liveroom_cs.StRoomListStream.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StRoomListStream
         * @static
         * @param {liveroom_cs.IStRoomListStream} message StRoomListStream message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StRoomListStream.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.stream_id);
            return writer;
        };

        /**
         * Decodes a StRoomListStream message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StRoomListStream
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StRoomListStream} StRoomListStream
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StRoomListStream.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StRoomListStream();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stream_id = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StRoomListStream;
    })();

    liveroom_cs.StRoomListRoom = (function() {

        /**
         * Properties of a StRoomListRoom.
         * @memberof liveroom_cs
         * @interface IStRoomListRoom
         * @property {Uint8Array|null} [room_id] StRoomListRoom room_id
         * @property {Uint8Array|null} [room_name] StRoomListRoom room_name
         * @property {Uint8Array|null} [anchor_id_name] StRoomListRoom anchor_id_name
         * @property {Uint8Array|null} [anchor_nick_name] StRoomListRoom anchor_nick_name
         * @property {Array.<liveroom_cs.IStRoomListStream>|null} [stream_list] StRoomListRoom stream_list
         */

        /**
         * Constructs a new StRoomListRoom.
         * @memberof liveroom_cs
         * @classdesc Represents a StRoomListRoom.
         * @implements IStRoomListRoom
         * @constructor
         * @param {liveroom_cs.IStRoomListRoom=} [properties] Properties to set
         */
        function StRoomListRoom(properties) {
            this.stream_list = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StRoomListRoom room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.StRoomListRoom
         * @instance
         */
        StRoomListRoom.prototype.room_id = $util.newBuffer([]);

        /**
         * StRoomListRoom room_name.
         * @member {Uint8Array} room_name
         * @memberof liveroom_cs.StRoomListRoom
         * @instance
         */
        StRoomListRoom.prototype.room_name = $util.newBuffer([]);

        /**
         * StRoomListRoom anchor_id_name.
         * @member {Uint8Array} anchor_id_name
         * @memberof liveroom_cs.StRoomListRoom
         * @instance
         */
        StRoomListRoom.prototype.anchor_id_name = $util.newBuffer([]);

        /**
         * StRoomListRoom anchor_nick_name.
         * @member {Uint8Array} anchor_nick_name
         * @memberof liveroom_cs.StRoomListRoom
         * @instance
         */
        StRoomListRoom.prototype.anchor_nick_name = $util.newBuffer([]);

        /**
         * StRoomListRoom stream_list.
         * @member {Array.<liveroom_cs.IStRoomListStream>} stream_list
         * @memberof liveroom_cs.StRoomListRoom
         * @instance
         */
        StRoomListRoom.prototype.stream_list = $util.emptyArray;

        /**
         * Creates a new StRoomListRoom instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StRoomListRoom
         * @static
         * @param {liveroom_cs.IStRoomListRoom=} [properties] Properties to set
         * @returns {liveroom_cs.StRoomListRoom} StRoomListRoom instance
         */
        StRoomListRoom.create = function create(properties) {
            return new StRoomListRoom(properties);
        };

        /**
         * Encodes the specified StRoomListRoom message. Does not implicitly {@link liveroom_cs.StRoomListRoom.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StRoomListRoom
         * @static
         * @param {liveroom_cs.IStRoomListRoom} message StRoomListRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StRoomListRoom.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.room_id);
            if (message.room_name != null && Object.hasOwnProperty.call(message, "room_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.room_name);
            if (message.anchor_id_name != null && Object.hasOwnProperty.call(message, "anchor_id_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.anchor_id_name);
            if (message.anchor_nick_name != null && Object.hasOwnProperty.call(message, "anchor_nick_name"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.anchor_nick_name);
            if (message.stream_list != null && message.stream_list.length)
                for (var i = 0; i < message.stream_list.length; ++i)
                    $root.liveroom_cs.StRoomListStream.encode(message.stream_list[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a StRoomListRoom message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StRoomListRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StRoomListRoom} StRoomListRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StRoomListRoom.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StRoomListRoom();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.room_id = reader.bytes();
                    break;
                case 2:
                    message.room_name = reader.bytes();
                    break;
                case 3:
                    message.anchor_id_name = reader.bytes();
                    break;
                case 4:
                    message.anchor_nick_name = reader.bytes();
                    break;
                case 5:
                    if (!(message.stream_list && message.stream_list.length))
                        message.stream_list = [];
                    message.stream_list.push($root.liveroom_cs.StRoomListStream.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StRoomListRoom;
    })();

    liveroom_cs.StTransSeqInfo = (function() {

        /**
         * Properties of a StTransSeqInfo.
         * @memberof liveroom_cs
         * @interface IStTransSeqInfo
         * @property {Uint8Array|null} [trans_type] StTransSeqInfo trans_type
         * @property {number|null} [trans_seq] StTransSeqInfo trans_seq
         */

        /**
         * Constructs a new StTransSeqInfo.
         * @memberof liveroom_cs
         * @classdesc Represents a StTransSeqInfo.
         * @implements IStTransSeqInfo
         * @constructor
         * @param {liveroom_cs.IStTransSeqInfo=} [properties] Properties to set
         */
        function StTransSeqInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StTransSeqInfo trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.StTransSeqInfo
         * @instance
         */
        StTransSeqInfo.prototype.trans_type = $util.newBuffer([]);

        /**
         * StTransSeqInfo trans_seq.
         * @member {number} trans_seq
         * @memberof liveroom_cs.StTransSeqInfo
         * @instance
         */
        StTransSeqInfo.prototype.trans_seq = 0;

        /**
         * Creates a new StTransSeqInfo instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StTransSeqInfo
         * @static
         * @param {liveroom_cs.IStTransSeqInfo=} [properties] Properties to set
         * @returns {liveroom_cs.StTransSeqInfo} StTransSeqInfo instance
         */
        StTransSeqInfo.create = function create(properties) {
            return new StTransSeqInfo(properties);
        };

        /**
         * Encodes the specified StTransSeqInfo message. Does not implicitly {@link liveroom_cs.StTransSeqInfo.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StTransSeqInfo
         * @static
         * @param {liveroom_cs.IStTransSeqInfo} message StTransSeqInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StTransSeqInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_type);
            if (message.trans_seq != null && Object.hasOwnProperty.call(message, "trans_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.trans_seq);
            return writer;
        };

        /**
         * Decodes a StTransSeqInfo message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StTransSeqInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StTransSeqInfo} StTransSeqInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StTransSeqInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StTransSeqInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_type = reader.bytes();
                    break;
                case 2:
                    message.trans_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StTransSeqInfo;
    })();

    liveroom_cs.StTransInfo = (function() {

        /**
         * Properties of a StTransInfo.
         * @memberof liveroom_cs
         * @interface IStTransInfo
         * @property {Uint8Array|null} [trans_channel] StTransInfo trans_channel
         * @property {Array.<liveroom_cs.IStTransSeqInfo>|null} [trans_seq_array] StTransInfo trans_seq_array
         */

        /**
         * Constructs a new StTransInfo.
         * @memberof liveroom_cs
         * @classdesc Represents a StTransInfo.
         * @implements IStTransInfo
         * @constructor
         * @param {liveroom_cs.IStTransInfo=} [properties] Properties to set
         */
        function StTransInfo(properties) {
            this.trans_seq_array = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StTransInfo trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.StTransInfo
         * @instance
         */
        StTransInfo.prototype.trans_channel = $util.newBuffer([]);

        /**
         * StTransInfo trans_seq_array.
         * @member {Array.<liveroom_cs.IStTransSeqInfo>} trans_seq_array
         * @memberof liveroom_cs.StTransInfo
         * @instance
         */
        StTransInfo.prototype.trans_seq_array = $util.emptyArray;

        /**
         * Creates a new StTransInfo instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StTransInfo
         * @static
         * @param {liveroom_cs.IStTransInfo=} [properties] Properties to set
         * @returns {liveroom_cs.StTransInfo} StTransInfo instance
         */
        StTransInfo.create = function create(properties) {
            return new StTransInfo(properties);
        };

        /**
         * Encodes the specified StTransInfo message. Does not implicitly {@link liveroom_cs.StTransInfo.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StTransInfo
         * @static
         * @param {liveroom_cs.IStTransInfo} message StTransInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StTransInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_channel);
            if (message.trans_seq_array != null && message.trans_seq_array.length)
                for (var i = 0; i < message.trans_seq_array.length; ++i)
                    $root.liveroom_cs.StTransSeqInfo.encode(message.trans_seq_array[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a StTransInfo message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StTransInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StTransInfo} StTransInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StTransInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StTransInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_channel = reader.bytes();
                    break;
                case 2:
                    if (!(message.trans_seq_array && message.trans_seq_array.length))
                        message.trans_seq_array = [];
                    message.trans_seq_array.push($root.liveroom_cs.StTransSeqInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StTransInfo;
    })();

    liveroom_cs.TransReq = (function() {

        /**
         * Properties of a TransReq.
         * @memberof liveroom_cs
         * @interface ITransReq
         * @property {liveroom_cs.IReqHead|null} [req_head] TransReq req_head
         * @property {Uint8Array|null} [nick_name] TransReq nick_name
         * @property {number|null} [role] TransReq role
         * @property {Uint8Array|null} [trans_type] TransReq trans_type
         * @property {Uint8Array|null} [trans_data] TransReq trans_data
         * @property {number|null} [trans_local_seq] TransReq trans_local_seq
         * @property {Uint8Array|null} [trans_channel] TransReq trans_channel
         */

        /**
         * Constructs a new TransReq.
         * @memberof liveroom_cs
         * @classdesc Represents a TransReq.
         * @implements ITransReq
         * @constructor
         * @param {liveroom_cs.ITransReq=} [properties] Properties to set
         */
        function TransReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.TransReq
         * @instance
         */
        TransReq.prototype.req_head = null;

        /**
         * TransReq nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.TransReq
         * @instance
         */
        TransReq.prototype.nick_name = $util.newBuffer([]);

        /**
         * TransReq role.
         * @member {number} role
         * @memberof liveroom_cs.TransReq
         * @instance
         */
        TransReq.prototype.role = 0;

        /**
         * TransReq trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.TransReq
         * @instance
         */
        TransReq.prototype.trans_type = $util.newBuffer([]);

        /**
         * TransReq trans_data.
         * @member {Uint8Array} trans_data
         * @memberof liveroom_cs.TransReq
         * @instance
         */
        TransReq.prototype.trans_data = $util.newBuffer([]);

        /**
         * TransReq trans_local_seq.
         * @member {number} trans_local_seq
         * @memberof liveroom_cs.TransReq
         * @instance
         */
        TransReq.prototype.trans_local_seq = 0;

        /**
         * TransReq trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.TransReq
         * @instance
         */
        TransReq.prototype.trans_channel = $util.newBuffer([]);

        /**
         * Creates a new TransReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.TransReq
         * @static
         * @param {liveroom_cs.ITransReq=} [properties] Properties to set
         * @returns {liveroom_cs.TransReq} TransReq instance
         */
        TransReq.create = function create(properties) {
            return new TransReq(properties);
        };

        /**
         * Encodes the specified TransReq message. Does not implicitly {@link liveroom_cs.TransReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.TransReq
         * @static
         * @param {liveroom_cs.ITransReq} message TransReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.role);
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.trans_type);
            if (message.trans_data != null && Object.hasOwnProperty.call(message, "trans_data"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.trans_data);
            if (message.trans_local_seq != null && Object.hasOwnProperty.call(message, "trans_local_seq"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.trans_local_seq);
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.trans_channel);
            return writer;
        };

        /**
         * Decodes a TransReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.TransReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.TransReq} TransReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.TransReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.nick_name = reader.bytes();
                    break;
                case 3:
                    message.role = reader.uint32();
                    break;
                case 4:
                    message.trans_type = reader.bytes();
                    break;
                case 5:
                    message.trans_data = reader.bytes();
                    break;
                case 6:
                    message.trans_local_seq = reader.uint32();
                    break;
                case 7:
                    message.trans_channel = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return TransReq;
    })();

    liveroom_cs.TransRsp = (function() {

        /**
         * Properties of a TransRsp.
         * @memberof liveroom_cs
         * @interface ITransRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] TransRsp rsp_head
         * @property {Uint8Array|null} [trans_type] TransRsp trans_type
         * @property {number|null} [trans_seq] TransRsp trans_seq
         * @property {number|null} [trans_list_seq] TransRsp trans_list_seq
         * @property {Uint8Array|null} [trans_channel] TransRsp trans_channel
         */

        /**
         * Constructs a new TransRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a TransRsp.
         * @implements ITransRsp
         * @constructor
         * @param {liveroom_cs.ITransRsp=} [properties] Properties to set
         */
        function TransRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.TransRsp
         * @instance
         */
        TransRsp.prototype.rsp_head = null;

        /**
         * TransRsp trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.TransRsp
         * @instance
         */
        TransRsp.prototype.trans_type = $util.newBuffer([]);

        /**
         * TransRsp trans_seq.
         * @member {number} trans_seq
         * @memberof liveroom_cs.TransRsp
         * @instance
         */
        TransRsp.prototype.trans_seq = 0;

        /**
         * TransRsp trans_list_seq.
         * @member {number} trans_list_seq
         * @memberof liveroom_cs.TransRsp
         * @instance
         */
        TransRsp.prototype.trans_list_seq = 0;

        /**
         * TransRsp trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.TransRsp
         * @instance
         */
        TransRsp.prototype.trans_channel = $util.newBuffer([]);

        /**
         * Creates a new TransRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.TransRsp
         * @static
         * @param {liveroom_cs.ITransRsp=} [properties] Properties to set
         * @returns {liveroom_cs.TransRsp} TransRsp instance
         */
        TransRsp.create = function create(properties) {
            return new TransRsp(properties);
        };

        /**
         * Encodes the specified TransRsp message. Does not implicitly {@link liveroom_cs.TransRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.TransRsp
         * @static
         * @param {liveroom_cs.ITransRsp} message TransRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.trans_type);
            if (message.trans_seq != null && Object.hasOwnProperty.call(message, "trans_seq"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.trans_seq);
            if (message.trans_list_seq != null && Object.hasOwnProperty.call(message, "trans_list_seq"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.trans_list_seq);
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.trans_channel);
            return writer;
        };

        /**
         * Decodes a TransRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.TransRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.TransRsp} TransRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.TransRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.trans_type = reader.bytes();
                    break;
                case 3:
                    message.trans_seq = reader.uint32();
                    break;
                case 4:
                    message.trans_list_seq = reader.uint32();
                    break;
                case 5:
                    message.trans_channel = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return TransRsp;
    })();

    liveroom_cs.TransFetchReq = (function() {

        /**
         * Properties of a TransFetchReq.
         * @memberof liveroom_cs
         * @interface ITransFetchReq
         * @property {liveroom_cs.IReqHead|null} [req_head] TransFetchReq req_head
         * @property {Uint8Array|null} [trans_channel] TransFetchReq trans_channel
         * @property {Array.<liveroom_cs.IStTransFetch>|null} [fetch_array] TransFetchReq fetch_array
         */

        /**
         * Constructs a new TransFetchReq.
         * @memberof liveroom_cs
         * @classdesc Represents a TransFetchReq.
         * @implements ITransFetchReq
         * @constructor
         * @param {liveroom_cs.ITransFetchReq=} [properties] Properties to set
         */
        function TransFetchReq(properties) {
            this.fetch_array = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransFetchReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.TransFetchReq
         * @instance
         */
        TransFetchReq.prototype.req_head = null;

        /**
         * TransFetchReq trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.TransFetchReq
         * @instance
         */
        TransFetchReq.prototype.trans_channel = $util.newBuffer([]);

        /**
         * TransFetchReq fetch_array.
         * @member {Array.<liveroom_cs.IStTransFetch>} fetch_array
         * @memberof liveroom_cs.TransFetchReq
         * @instance
         */
        TransFetchReq.prototype.fetch_array = $util.emptyArray;

        /**
         * Creates a new TransFetchReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.TransFetchReq
         * @static
         * @param {liveroom_cs.ITransFetchReq=} [properties] Properties to set
         * @returns {liveroom_cs.TransFetchReq} TransFetchReq instance
         */
        TransFetchReq.create = function create(properties) {
            return new TransFetchReq(properties);
        };

        /**
         * Encodes the specified TransFetchReq message. Does not implicitly {@link liveroom_cs.TransFetchReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.TransFetchReq
         * @static
         * @param {liveroom_cs.ITransFetchReq} message TransFetchReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransFetchReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.trans_channel);
            if (message.fetch_array != null && message.fetch_array.length)
                for (var i = 0; i < message.fetch_array.length; ++i)
                    $root.liveroom_cs.StTransFetch.encode(message.fetch_array[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a TransFetchReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.TransFetchReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.TransFetchReq} TransFetchReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransFetchReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.TransFetchReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.trans_channel = reader.bytes();
                    break;
                case 3:
                    if (!(message.fetch_array && message.fetch_array.length))
                        message.fetch_array = [];
                    message.fetch_array.push($root.liveroom_cs.StTransFetch.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return TransFetchReq;
    })();

    liveroom_cs.StTransFetch = (function() {

        /**
         * Properties of a StTransFetch.
         * @memberof liveroom_cs
         * @interface IStTransFetch
         * @property {Uint8Array|null} [trans_type] StTransFetch trans_type
         * @property {number|null} [trans_local_seq] StTransFetch trans_local_seq
         */

        /**
         * Constructs a new StTransFetch.
         * @memberof liveroom_cs
         * @classdesc Represents a StTransFetch.
         * @implements IStTransFetch
         * @constructor
         * @param {liveroom_cs.IStTransFetch=} [properties] Properties to set
         */
        function StTransFetch(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StTransFetch trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.StTransFetch
         * @instance
         */
        StTransFetch.prototype.trans_type = $util.newBuffer([]);

        /**
         * StTransFetch trans_local_seq.
         * @member {number} trans_local_seq
         * @memberof liveroom_cs.StTransFetch
         * @instance
         */
        StTransFetch.prototype.trans_local_seq = 0;

        /**
         * Creates a new StTransFetch instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StTransFetch
         * @static
         * @param {liveroom_cs.IStTransFetch=} [properties] Properties to set
         * @returns {liveroom_cs.StTransFetch} StTransFetch instance
         */
        StTransFetch.create = function create(properties) {
            return new StTransFetch(properties);
        };

        /**
         * Encodes the specified StTransFetch message. Does not implicitly {@link liveroom_cs.StTransFetch.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StTransFetch
         * @static
         * @param {liveroom_cs.IStTransFetch} message StTransFetch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StTransFetch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_type);
            if (message.trans_local_seq != null && Object.hasOwnProperty.call(message, "trans_local_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.trans_local_seq);
            return writer;
        };

        /**
         * Decodes a StTransFetch message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StTransFetch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StTransFetch} StTransFetch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StTransFetch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StTransFetch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_type = reader.bytes();
                    break;
                case 2:
                    message.trans_local_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StTransFetch;
    })();

    liveroom_cs.TransFetchRsp = (function() {

        /**
         * Properties of a TransFetchRsp.
         * @memberof liveroom_cs
         * @interface ITransFetchRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] TransFetchRsp rsp_head
         * @property {Uint8Array|null} [trans_channel] TransFetchRsp trans_channel
         * @property {Array.<liveroom_cs.ITransFetchResult>|null} [trans_fetch_results] TransFetchRsp trans_fetch_results
         * @property {number|null} [trans_list_seq] TransFetchRsp trans_list_seq
         */

        /**
         * Constructs a new TransFetchRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a TransFetchRsp.
         * @implements ITransFetchRsp
         * @constructor
         * @param {liveroom_cs.ITransFetchRsp=} [properties] Properties to set
         */
        function TransFetchRsp(properties) {
            this.trans_fetch_results = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransFetchRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.TransFetchRsp
         * @instance
         */
        TransFetchRsp.prototype.rsp_head = null;

        /**
         * TransFetchRsp trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.TransFetchRsp
         * @instance
         */
        TransFetchRsp.prototype.trans_channel = $util.newBuffer([]);

        /**
         * TransFetchRsp trans_fetch_results.
         * @member {Array.<liveroom_cs.ITransFetchResult>} trans_fetch_results
         * @memberof liveroom_cs.TransFetchRsp
         * @instance
         */
        TransFetchRsp.prototype.trans_fetch_results = $util.emptyArray;

        /**
         * TransFetchRsp trans_list_seq.
         * @member {number} trans_list_seq
         * @memberof liveroom_cs.TransFetchRsp
         * @instance
         */
        TransFetchRsp.prototype.trans_list_seq = 0;

        /**
         * Creates a new TransFetchRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.TransFetchRsp
         * @static
         * @param {liveroom_cs.ITransFetchRsp=} [properties] Properties to set
         * @returns {liveroom_cs.TransFetchRsp} TransFetchRsp instance
         */
        TransFetchRsp.create = function create(properties) {
            return new TransFetchRsp(properties);
        };

        /**
         * Encodes the specified TransFetchRsp message. Does not implicitly {@link liveroom_cs.TransFetchRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.TransFetchRsp
         * @static
         * @param {liveroom_cs.ITransFetchRsp} message TransFetchRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransFetchRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.trans_channel);
            if (message.trans_fetch_results != null && message.trans_fetch_results.length)
                for (var i = 0; i < message.trans_fetch_results.length; ++i)
                    $root.liveroom_cs.TransFetchResult.encode(message.trans_fetch_results[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.trans_list_seq != null && Object.hasOwnProperty.call(message, "trans_list_seq"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.trans_list_seq);
            return writer;
        };

        /**
         * Decodes a TransFetchRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.TransFetchRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.TransFetchRsp} TransFetchRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransFetchRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.TransFetchRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.trans_channel = reader.bytes();
                    break;
                case 3:
                    if (!(message.trans_fetch_results && message.trans_fetch_results.length))
                        message.trans_fetch_results = [];
                    message.trans_fetch_results.push($root.liveroom_cs.TransFetchResult.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.trans_list_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return TransFetchRsp;
    })();

    liveroom_cs.TransFetchResult = (function() {

        /**
         * Properties of a TransFetchResult.
         * @memberof liveroom_cs
         * @interface ITransFetchResult
         * @property {Uint8Array|null} [trans_type] TransFetchResult trans_type
         * @property {Uint8Array|null} [trans_data] TransFetchResult trans_data
         * @property {Uint8Array|null} [trans_idname] TransFetchResult trans_idname
         * @property {Uint8Array|null} [trans_nickname] TransFetchResult trans_nickname
         * @property {number|null} [trans_role] TransFetchResult trans_role
         * @property {number|Long|null} [trans_send_time] TransFetchResult trans_send_time
         * @property {number|null} [trans_seq] TransFetchResult trans_seq
         * @property {number|null} [err_code] TransFetchResult err_code
         */

        /**
         * Constructs a new TransFetchResult.
         * @memberof liveroom_cs
         * @classdesc Represents a TransFetchResult.
         * @implements ITransFetchResult
         * @constructor
         * @param {liveroom_cs.ITransFetchResult=} [properties] Properties to set
         */
        function TransFetchResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransFetchResult trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.TransFetchResult
         * @instance
         */
        TransFetchResult.prototype.trans_type = $util.newBuffer([]);

        /**
         * TransFetchResult trans_data.
         * @member {Uint8Array} trans_data
         * @memberof liveroom_cs.TransFetchResult
         * @instance
         */
        TransFetchResult.prototype.trans_data = $util.newBuffer([]);

        /**
         * TransFetchResult trans_idname.
         * @member {Uint8Array} trans_idname
         * @memberof liveroom_cs.TransFetchResult
         * @instance
         */
        TransFetchResult.prototype.trans_idname = $util.newBuffer([]);

        /**
         * TransFetchResult trans_nickname.
         * @member {Uint8Array} trans_nickname
         * @memberof liveroom_cs.TransFetchResult
         * @instance
         */
        TransFetchResult.prototype.trans_nickname = $util.newBuffer([]);

        /**
         * TransFetchResult trans_role.
         * @member {number} trans_role
         * @memberof liveroom_cs.TransFetchResult
         * @instance
         */
        TransFetchResult.prototype.trans_role = 0;

        /**
         * TransFetchResult trans_send_time.
         * @member {number|Long} trans_send_time
         * @memberof liveroom_cs.TransFetchResult
         * @instance
         */
        TransFetchResult.prototype.trans_send_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransFetchResult trans_seq.
         * @member {number} trans_seq
         * @memberof liveroom_cs.TransFetchResult
         * @instance
         */
        TransFetchResult.prototype.trans_seq = 0;

        /**
         * TransFetchResult err_code.
         * @member {number} err_code
         * @memberof liveroom_cs.TransFetchResult
         * @instance
         */
        TransFetchResult.prototype.err_code = 0;

        /**
         * Creates a new TransFetchResult instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.TransFetchResult
         * @static
         * @param {liveroom_cs.ITransFetchResult=} [properties] Properties to set
         * @returns {liveroom_cs.TransFetchResult} TransFetchResult instance
         */
        TransFetchResult.create = function create(properties) {
            return new TransFetchResult(properties);
        };

        /**
         * Encodes the specified TransFetchResult message. Does not implicitly {@link liveroom_cs.TransFetchResult.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.TransFetchResult
         * @static
         * @param {liveroom_cs.ITransFetchResult} message TransFetchResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransFetchResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_type);
            if (message.trans_data != null && Object.hasOwnProperty.call(message, "trans_data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.trans_data);
            if (message.trans_idname != null && Object.hasOwnProperty.call(message, "trans_idname"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.trans_idname);
            if (message.trans_nickname != null && Object.hasOwnProperty.call(message, "trans_nickname"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.trans_nickname);
            if (message.trans_role != null && Object.hasOwnProperty.call(message, "trans_role"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.trans_role);
            if (message.trans_send_time != null && Object.hasOwnProperty.call(message, "trans_send_time"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.trans_send_time);
            if (message.trans_seq != null && Object.hasOwnProperty.call(message, "trans_seq"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.trans_seq);
            if (message.err_code != null && Object.hasOwnProperty.call(message, "err_code"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.err_code);
            return writer;
        };

        /**
         * Decodes a TransFetchResult message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.TransFetchResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.TransFetchResult} TransFetchResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransFetchResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.TransFetchResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_type = reader.bytes();
                    break;
                case 2:
                    message.trans_data = reader.bytes();
                    break;
                case 3:
                    message.trans_idname = reader.bytes();
                    break;
                case 4:
                    message.trans_nickname = reader.bytes();
                    break;
                case 5:
                    message.trans_role = reader.uint32();
                    break;
                case 6:
                    message.trans_send_time = reader.int64();
                    break;
                case 7:
                    message.trans_seq = reader.uint32();
                    break;
                case 8:
                    message.err_code = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return TransFetchResult;
    })();

    liveroom_cs.UserTransFetchReq = (function() {

        /**
         * Properties of a UserTransFetchReq.
         * @memberof liveroom_cs
         * @interface IUserTransFetchReq
         * @property {liveroom_cs.IReqHead|null} [req_head] UserTransFetchReq req_head
         * @property {Uint8Array|null} [nick_name] UserTransFetchReq nick_name
         * @property {number|null} [role] UserTransFetchReq role
         * @property {Uint8Array|null} [trans_channel] UserTransFetchReq trans_channel
         * @property {Array.<liveroom_cs.IStUserTransFetch>|null} [fetch_array] UserTransFetchReq fetch_array
         */

        /**
         * Constructs a new UserTransFetchReq.
         * @memberof liveroom_cs
         * @classdesc Represents a UserTransFetchReq.
         * @implements IUserTransFetchReq
         * @constructor
         * @param {liveroom_cs.IUserTransFetchReq=} [properties] Properties to set
         */
        function UserTransFetchReq(properties) {
            this.fetch_array = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserTransFetchReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.UserTransFetchReq
         * @instance
         */
        UserTransFetchReq.prototype.req_head = null;

        /**
         * UserTransFetchReq nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.UserTransFetchReq
         * @instance
         */
        UserTransFetchReq.prototype.nick_name = $util.newBuffer([]);

        /**
         * UserTransFetchReq role.
         * @member {number} role
         * @memberof liveroom_cs.UserTransFetchReq
         * @instance
         */
        UserTransFetchReq.prototype.role = 0;

        /**
         * UserTransFetchReq trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.UserTransFetchReq
         * @instance
         */
        UserTransFetchReq.prototype.trans_channel = $util.newBuffer([]);

        /**
         * UserTransFetchReq fetch_array.
         * @member {Array.<liveroom_cs.IStUserTransFetch>} fetch_array
         * @memberof liveroom_cs.UserTransFetchReq
         * @instance
         */
        UserTransFetchReq.prototype.fetch_array = $util.emptyArray;

        /**
         * Creates a new UserTransFetchReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.UserTransFetchReq
         * @static
         * @param {liveroom_cs.IUserTransFetchReq=} [properties] Properties to set
         * @returns {liveroom_cs.UserTransFetchReq} UserTransFetchReq instance
         */
        UserTransFetchReq.create = function create(properties) {
            return new UserTransFetchReq(properties);
        };

        /**
         * Encodes the specified UserTransFetchReq message. Does not implicitly {@link liveroom_cs.UserTransFetchReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.UserTransFetchReq
         * @static
         * @param {liveroom_cs.IUserTransFetchReq} message UserTransFetchReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserTransFetchReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.role);
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.trans_channel);
            if (message.fetch_array != null && message.fetch_array.length)
                for (var i = 0; i < message.fetch_array.length; ++i)
                    $root.liveroom_cs.StUserTransFetch.encode(message.fetch_array[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a UserTransFetchReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.UserTransFetchReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.UserTransFetchReq} UserTransFetchReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserTransFetchReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.UserTransFetchReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.nick_name = reader.bytes();
                    break;
                case 3:
                    message.role = reader.uint32();
                    break;
                case 4:
                    message.trans_channel = reader.bytes();
                    break;
                case 5:
                    if (!(message.fetch_array && message.fetch_array.length))
                        message.fetch_array = [];
                    message.fetch_array.push($root.liveroom_cs.StUserTransFetch.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return UserTransFetchReq;
    })();

    liveroom_cs.StUserTransFetch = (function() {

        /**
         * Properties of a StUserTransFetch.
         * @memberof liveroom_cs
         * @interface IStUserTransFetch
         * @property {Uint8Array|null} [trans_type] StUserTransFetch trans_type
         * @property {number|null} [trans_local_seq] StUserTransFetch trans_local_seq
         */

        /**
         * Constructs a new StUserTransFetch.
         * @memberof liveroom_cs
         * @classdesc Represents a StUserTransFetch.
         * @implements IStUserTransFetch
         * @constructor
         * @param {liveroom_cs.IStUserTransFetch=} [properties] Properties to set
         */
        function StUserTransFetch(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StUserTransFetch trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.StUserTransFetch
         * @instance
         */
        StUserTransFetch.prototype.trans_type = $util.newBuffer([]);

        /**
         * StUserTransFetch trans_local_seq.
         * @member {number} trans_local_seq
         * @memberof liveroom_cs.StUserTransFetch
         * @instance
         */
        StUserTransFetch.prototype.trans_local_seq = 0;

        /**
         * Creates a new StUserTransFetch instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StUserTransFetch
         * @static
         * @param {liveroom_cs.IStUserTransFetch=} [properties] Properties to set
         * @returns {liveroom_cs.StUserTransFetch} StUserTransFetch instance
         */
        StUserTransFetch.create = function create(properties) {
            return new StUserTransFetch(properties);
        };

        /**
         * Encodes the specified StUserTransFetch message. Does not implicitly {@link liveroom_cs.StUserTransFetch.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StUserTransFetch
         * @static
         * @param {liveroom_cs.IStUserTransFetch} message StUserTransFetch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StUserTransFetch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_type);
            if (message.trans_local_seq != null && Object.hasOwnProperty.call(message, "trans_local_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.trans_local_seq);
            return writer;
        };

        /**
         * Decodes a StUserTransFetch message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StUserTransFetch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StUserTransFetch} StUserTransFetch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StUserTransFetch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StUserTransFetch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_type = reader.bytes();
                    break;
                case 2:
                    message.trans_local_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StUserTransFetch;
    })();

    liveroom_cs.UserTransFetchRsp = (function() {

        /**
         * Properties of a UserTransFetchRsp.
         * @memberof liveroom_cs
         * @interface IUserTransFetchRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] UserTransFetchRsp rsp_head
         * @property {Uint8Array|null} [trans_channel] UserTransFetchRsp trans_channel
         * @property {Array.<liveroom_cs.IStUserTransFetchResult>|null} [trans_fetch_results] UserTransFetchRsp trans_fetch_results
         */

        /**
         * Constructs a new UserTransFetchRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a UserTransFetchRsp.
         * @implements IUserTransFetchRsp
         * @constructor
         * @param {liveroom_cs.IUserTransFetchRsp=} [properties] Properties to set
         */
        function UserTransFetchRsp(properties) {
            this.trans_fetch_results = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserTransFetchRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.UserTransFetchRsp
         * @instance
         */
        UserTransFetchRsp.prototype.rsp_head = null;

        /**
         * UserTransFetchRsp trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.UserTransFetchRsp
         * @instance
         */
        UserTransFetchRsp.prototype.trans_channel = $util.newBuffer([]);

        /**
         * UserTransFetchRsp trans_fetch_results.
         * @member {Array.<liveroom_cs.IStUserTransFetchResult>} trans_fetch_results
         * @memberof liveroom_cs.UserTransFetchRsp
         * @instance
         */
        UserTransFetchRsp.prototype.trans_fetch_results = $util.emptyArray;

        /**
         * Creates a new UserTransFetchRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.UserTransFetchRsp
         * @static
         * @param {liveroom_cs.IUserTransFetchRsp=} [properties] Properties to set
         * @returns {liveroom_cs.UserTransFetchRsp} UserTransFetchRsp instance
         */
        UserTransFetchRsp.create = function create(properties) {
            return new UserTransFetchRsp(properties);
        };

        /**
         * Encodes the specified UserTransFetchRsp message. Does not implicitly {@link liveroom_cs.UserTransFetchRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.UserTransFetchRsp
         * @static
         * @param {liveroom_cs.IUserTransFetchRsp} message UserTransFetchRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserTransFetchRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.trans_channel);
            if (message.trans_fetch_results != null && message.trans_fetch_results.length)
                for (var i = 0; i < message.trans_fetch_results.length; ++i)
                    $root.liveroom_cs.StUserTransFetchResult.encode(message.trans_fetch_results[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a UserTransFetchRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.UserTransFetchRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.UserTransFetchRsp} UserTransFetchRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserTransFetchRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.UserTransFetchRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.trans_channel = reader.bytes();
                    break;
                case 3:
                    if (!(message.trans_fetch_results && message.trans_fetch_results.length))
                        message.trans_fetch_results = [];
                    message.trans_fetch_results.push($root.liveroom_cs.StUserTransFetchResult.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return UserTransFetchRsp;
    })();

    liveroom_cs.StUserTransFetchResult = (function() {

        /**
         * Properties of a StUserTransFetchResult.
         * @memberof liveroom_cs
         * @interface IStUserTransFetchResult
         * @property {Uint8Array|null} [trans_type] StUserTransFetchResult trans_type
         * @property {Uint8Array|null} [trans_data] StUserTransFetchResult trans_data
         * @property {Uint8Array|null} [trans_idname] StUserTransFetchResult trans_idname
         * @property {Uint8Array|null} [trans_nickname] StUserTransFetchResult trans_nickname
         * @property {number|null} [trans_role] StUserTransFetchResult trans_role
         * @property {number|Long|null} [trans_send_time] StUserTransFetchResult trans_send_time
         * @property {number|null} [trans_seq] StUserTransFetchResult trans_seq
         * @property {number|null} [err_code] StUserTransFetchResult err_code
         */

        /**
         * Constructs a new StUserTransFetchResult.
         * @memberof liveroom_cs
         * @classdesc Represents a StUserTransFetchResult.
         * @implements IStUserTransFetchResult
         * @constructor
         * @param {liveroom_cs.IStUserTransFetchResult=} [properties] Properties to set
         */
        function StUserTransFetchResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StUserTransFetchResult trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.StUserTransFetchResult
         * @instance
         */
        StUserTransFetchResult.prototype.trans_type = $util.newBuffer([]);

        /**
         * StUserTransFetchResult trans_data.
         * @member {Uint8Array} trans_data
         * @memberof liveroom_cs.StUserTransFetchResult
         * @instance
         */
        StUserTransFetchResult.prototype.trans_data = $util.newBuffer([]);

        /**
         * StUserTransFetchResult trans_idname.
         * @member {Uint8Array} trans_idname
         * @memberof liveroom_cs.StUserTransFetchResult
         * @instance
         */
        StUserTransFetchResult.prototype.trans_idname = $util.newBuffer([]);

        /**
         * StUserTransFetchResult trans_nickname.
         * @member {Uint8Array} trans_nickname
         * @memberof liveroom_cs.StUserTransFetchResult
         * @instance
         */
        StUserTransFetchResult.prototype.trans_nickname = $util.newBuffer([]);

        /**
         * StUserTransFetchResult trans_role.
         * @member {number} trans_role
         * @memberof liveroom_cs.StUserTransFetchResult
         * @instance
         */
        StUserTransFetchResult.prototype.trans_role = 0;

        /**
         * StUserTransFetchResult trans_send_time.
         * @member {number|Long} trans_send_time
         * @memberof liveroom_cs.StUserTransFetchResult
         * @instance
         */
        StUserTransFetchResult.prototype.trans_send_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StUserTransFetchResult trans_seq.
         * @member {number} trans_seq
         * @memberof liveroom_cs.StUserTransFetchResult
         * @instance
         */
        StUserTransFetchResult.prototype.trans_seq = 0;

        /**
         * StUserTransFetchResult err_code.
         * @member {number} err_code
         * @memberof liveroom_cs.StUserTransFetchResult
         * @instance
         */
        StUserTransFetchResult.prototype.err_code = 0;

        /**
         * Creates a new StUserTransFetchResult instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StUserTransFetchResult
         * @static
         * @param {liveroom_cs.IStUserTransFetchResult=} [properties] Properties to set
         * @returns {liveroom_cs.StUserTransFetchResult} StUserTransFetchResult instance
         */
        StUserTransFetchResult.create = function create(properties) {
            return new StUserTransFetchResult(properties);
        };

        /**
         * Encodes the specified StUserTransFetchResult message. Does not implicitly {@link liveroom_cs.StUserTransFetchResult.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StUserTransFetchResult
         * @static
         * @param {liveroom_cs.IStUserTransFetchResult} message StUserTransFetchResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StUserTransFetchResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_type);
            if (message.trans_data != null && Object.hasOwnProperty.call(message, "trans_data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.trans_data);
            if (message.trans_idname != null && Object.hasOwnProperty.call(message, "trans_idname"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.trans_idname);
            if (message.trans_nickname != null && Object.hasOwnProperty.call(message, "trans_nickname"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.trans_nickname);
            if (message.trans_role != null && Object.hasOwnProperty.call(message, "trans_role"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.trans_role);
            if (message.trans_send_time != null && Object.hasOwnProperty.call(message, "trans_send_time"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.trans_send_time);
            if (message.trans_seq != null && Object.hasOwnProperty.call(message, "trans_seq"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.trans_seq);
            if (message.err_code != null && Object.hasOwnProperty.call(message, "err_code"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.err_code);
            return writer;
        };

        /**
         * Decodes a StUserTransFetchResult message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StUserTransFetchResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StUserTransFetchResult} StUserTransFetchResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StUserTransFetchResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StUserTransFetchResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_type = reader.bytes();
                    break;
                case 2:
                    message.trans_data = reader.bytes();
                    break;
                case 3:
                    message.trans_idname = reader.bytes();
                    break;
                case 4:
                    message.trans_nickname = reader.bytes();
                    break;
                case 5:
                    message.trans_role = reader.uint32();
                    break;
                case 6:
                    message.trans_send_time = reader.int64();
                    break;
                case 7:
                    message.trans_seq = reader.uint32();
                    break;
                case 8:
                    message.err_code = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StUserTransFetchResult;
    })();

    liveroom_cs.BigimChatReq = (function() {

        /**
         * Properties of a BigimChatReq.
         * @memberof liveroom_cs
         * @interface IBigimChatReq
         * @property {liveroom_cs.IReqHead|null} [req_head] BigimChatReq req_head
         * @property {Uint8Array|null} [nick_name] BigimChatReq nick_name
         * @property {number|null} [role] BigimChatReq role
         * @property {Array.<liveroom_cs.IStBigimChatData>|null} [msgs] BigimChatReq msgs
         */

        /**
         * Constructs a new BigimChatReq.
         * @memberof liveroom_cs
         * @classdesc Represents a BigimChatReq.
         * @implements IBigimChatReq
         * @constructor
         * @param {liveroom_cs.IBigimChatReq=} [properties] Properties to set
         */
        function BigimChatReq(properties) {
            this.msgs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BigimChatReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.BigimChatReq
         * @instance
         */
        BigimChatReq.prototype.req_head = null;

        /**
         * BigimChatReq nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.BigimChatReq
         * @instance
         */
        BigimChatReq.prototype.nick_name = $util.newBuffer([]);

        /**
         * BigimChatReq role.
         * @member {number} role
         * @memberof liveroom_cs.BigimChatReq
         * @instance
         */
        BigimChatReq.prototype.role = 0;

        /**
         * BigimChatReq msgs.
         * @member {Array.<liveroom_cs.IStBigimChatData>} msgs
         * @memberof liveroom_cs.BigimChatReq
         * @instance
         */
        BigimChatReq.prototype.msgs = $util.emptyArray;

        /**
         * Creates a new BigimChatReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.BigimChatReq
         * @static
         * @param {liveroom_cs.IBigimChatReq=} [properties] Properties to set
         * @returns {liveroom_cs.BigimChatReq} BigimChatReq instance
         */
        BigimChatReq.create = function create(properties) {
            return new BigimChatReq(properties);
        };

        /**
         * Encodes the specified BigimChatReq message. Does not implicitly {@link liveroom_cs.BigimChatReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.BigimChatReq
         * @static
         * @param {liveroom_cs.IBigimChatReq} message BigimChatReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigimChatReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.role);
            if (message.msgs != null && message.msgs.length)
                for (var i = 0; i < message.msgs.length; ++i)
                    $root.liveroom_cs.StBigimChatData.encode(message.msgs[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a BigimChatReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.BigimChatReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.BigimChatReq} BigimChatReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigimChatReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.BigimChatReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.nick_name = reader.bytes();
                    break;
                case 3:
                    message.role = reader.uint32();
                    break;
                case 4:
                    if (!(message.msgs && message.msgs.length))
                        message.msgs = [];
                    message.msgs.push($root.liveroom_cs.StBigimChatData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return BigimChatReq;
    })();

    liveroom_cs.StBigimChatData = (function() {

        /**
         * Properties of a StBigimChatData.
         * @memberof liveroom_cs
         * @interface IStBigimChatData
         * @property {number|null} [msg_category] StBigimChatData msg_category
         * @property {number|null} [msg_type] StBigimChatData msg_type
         * @property {Uint8Array|null} [msg_content] StBigimChatData msg_content
         * @property {number|Long|null} [msg_timestamp] StBigimChatData msg_timestamp
         * @property {Uint8Array|null} [bigmsg_client_id] StBigimChatData bigmsg_client_id
         */

        /**
         * Constructs a new StBigimChatData.
         * @memberof liveroom_cs
         * @classdesc Represents a StBigimChatData.
         * @implements IStBigimChatData
         * @constructor
         * @param {liveroom_cs.IStBigimChatData=} [properties] Properties to set
         */
        function StBigimChatData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StBigimChatData msg_category.
         * @member {number} msg_category
         * @memberof liveroom_cs.StBigimChatData
         * @instance
         */
        StBigimChatData.prototype.msg_category = 0;

        /**
         * StBigimChatData msg_type.
         * @member {number} msg_type
         * @memberof liveroom_cs.StBigimChatData
         * @instance
         */
        StBigimChatData.prototype.msg_type = 0;

        /**
         * StBigimChatData msg_content.
         * @member {Uint8Array} msg_content
         * @memberof liveroom_cs.StBigimChatData
         * @instance
         */
        StBigimChatData.prototype.msg_content = $util.newBuffer([]);

        /**
         * StBigimChatData msg_timestamp.
         * @member {number|Long} msg_timestamp
         * @memberof liveroom_cs.StBigimChatData
         * @instance
         */
        StBigimChatData.prototype.msg_timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StBigimChatData bigmsg_client_id.
         * @member {Uint8Array} bigmsg_client_id
         * @memberof liveroom_cs.StBigimChatData
         * @instance
         */
        StBigimChatData.prototype.bigmsg_client_id = $util.newBuffer([]);

        /**
         * Creates a new StBigimChatData instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StBigimChatData
         * @static
         * @param {liveroom_cs.IStBigimChatData=} [properties] Properties to set
         * @returns {liveroom_cs.StBigimChatData} StBigimChatData instance
         */
        StBigimChatData.create = function create(properties) {
            return new StBigimChatData(properties);
        };

        /**
         * Encodes the specified StBigimChatData message. Does not implicitly {@link liveroom_cs.StBigimChatData.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StBigimChatData
         * @static
         * @param {liveroom_cs.IStBigimChatData} message StBigimChatData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StBigimChatData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg_category != null && Object.hasOwnProperty.call(message, "msg_category"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.msg_category);
            if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.msg_type);
            if (message.msg_content != null && Object.hasOwnProperty.call(message, "msg_content"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.msg_content);
            if (message.msg_timestamp != null && Object.hasOwnProperty.call(message, "msg_timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.msg_timestamp);
            if (message.bigmsg_client_id != null && Object.hasOwnProperty.call(message, "bigmsg_client_id"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.bigmsg_client_id);
            return writer;
        };

        /**
         * Decodes a StBigimChatData message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StBigimChatData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StBigimChatData} StBigimChatData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StBigimChatData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StBigimChatData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg_category = reader.uint32();
                    break;
                case 2:
                    message.msg_type = reader.uint32();
                    break;
                case 3:
                    message.msg_content = reader.bytes();
                    break;
                case 4:
                    message.msg_timestamp = reader.int64();
                    break;
                case 5:
                    message.bigmsg_client_id = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StBigimChatData;
    })();

    liveroom_cs.BigimChatRsp = (function() {

        /**
         * Properties of a BigimChatRsp.
         * @memberof liveroom_cs
         * @interface IBigimChatRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] BigimChatRsp rsp_head
         * @property {number|null} [bigim_time_window] BigimChatRsp bigim_time_window
         * @property {Array.<liveroom_cs.IStBigimChatRspData>|null} [msgs] BigimChatRsp msgs
         */

        /**
         * Constructs a new BigimChatRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a BigimChatRsp.
         * @implements IBigimChatRsp
         * @constructor
         * @param {liveroom_cs.IBigimChatRsp=} [properties] Properties to set
         */
        function BigimChatRsp(properties) {
            this.msgs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BigimChatRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.BigimChatRsp
         * @instance
         */
        BigimChatRsp.prototype.rsp_head = null;

        /**
         * BigimChatRsp bigim_time_window.
         * @member {number} bigim_time_window
         * @memberof liveroom_cs.BigimChatRsp
         * @instance
         */
        BigimChatRsp.prototype.bigim_time_window = 0;

        /**
         * BigimChatRsp msgs.
         * @member {Array.<liveroom_cs.IStBigimChatRspData>} msgs
         * @memberof liveroom_cs.BigimChatRsp
         * @instance
         */
        BigimChatRsp.prototype.msgs = $util.emptyArray;

        /**
         * Creates a new BigimChatRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.BigimChatRsp
         * @static
         * @param {liveroom_cs.IBigimChatRsp=} [properties] Properties to set
         * @returns {liveroom_cs.BigimChatRsp} BigimChatRsp instance
         */
        BigimChatRsp.create = function create(properties) {
            return new BigimChatRsp(properties);
        };

        /**
         * Encodes the specified BigimChatRsp message. Does not implicitly {@link liveroom_cs.BigimChatRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.BigimChatRsp
         * @static
         * @param {liveroom_cs.IBigimChatRsp} message BigimChatRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigimChatRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.bigim_time_window != null && Object.hasOwnProperty.call(message, "bigim_time_window"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.bigim_time_window);
            if (message.msgs != null && message.msgs.length)
                for (var i = 0; i < message.msgs.length; ++i)
                    $root.liveroom_cs.StBigimChatRspData.encode(message.msgs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a BigimChatRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.BigimChatRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.BigimChatRsp} BigimChatRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigimChatRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.BigimChatRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.bigim_time_window = reader.uint32();
                    break;
                case 3:
                    if (!(message.msgs && message.msgs.length))
                        message.msgs = [];
                    message.msgs.push($root.liveroom_cs.StBigimChatRspData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return BigimChatRsp;
    })();

    liveroom_cs.StBigimChatRspData = (function() {

        /**
         * Properties of a StBigimChatRspData.
         * @memberof liveroom_cs
         * @interface IStBigimChatRspData
         * @property {Uint8Array|null} [bigmsg_id] StBigimChatRspData bigmsg_id
         * @property {Uint8Array|null} [bigmsg_client_id] StBigimChatRspData bigmsg_client_id
         */

        /**
         * Constructs a new StBigimChatRspData.
         * @memberof liveroom_cs
         * @classdesc Represents a StBigimChatRspData.
         * @implements IStBigimChatRspData
         * @constructor
         * @param {liveroom_cs.IStBigimChatRspData=} [properties] Properties to set
         */
        function StBigimChatRspData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StBigimChatRspData bigmsg_id.
         * @member {Uint8Array} bigmsg_id
         * @memberof liveroom_cs.StBigimChatRspData
         * @instance
         */
        StBigimChatRspData.prototype.bigmsg_id = $util.newBuffer([]);

        /**
         * StBigimChatRspData bigmsg_client_id.
         * @member {Uint8Array} bigmsg_client_id
         * @memberof liveroom_cs.StBigimChatRspData
         * @instance
         */
        StBigimChatRspData.prototype.bigmsg_client_id = $util.newBuffer([]);

        /**
         * Creates a new StBigimChatRspData instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StBigimChatRspData
         * @static
         * @param {liveroom_cs.IStBigimChatRspData=} [properties] Properties to set
         * @returns {liveroom_cs.StBigimChatRspData} StBigimChatRspData instance
         */
        StBigimChatRspData.create = function create(properties) {
            return new StBigimChatRspData(properties);
        };

        /**
         * Encodes the specified StBigimChatRspData message. Does not implicitly {@link liveroom_cs.StBigimChatRspData.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StBigimChatRspData
         * @static
         * @param {liveroom_cs.IStBigimChatRspData} message StBigimChatRspData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StBigimChatRspData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bigmsg_id != null && Object.hasOwnProperty.call(message, "bigmsg_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.bigmsg_id);
            if (message.bigmsg_client_id != null && Object.hasOwnProperty.call(message, "bigmsg_client_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bigmsg_client_id);
            return writer;
        };

        /**
         * Decodes a StBigimChatRspData message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StBigimChatRspData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StBigimChatRspData} StBigimChatRspData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StBigimChatRspData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StBigimChatRspData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bigmsg_id = reader.bytes();
                    break;
                case 2:
                    message.bigmsg_client_id = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StBigimChatRspData;
    })();

    liveroom_cs.RelayReq = (function() {

        /**
         * Properties of a RelayReq.
         * @memberof liveroom_cs
         * @interface IRelayReq
         * @property {liveroom_cs.IReqHead|null} [req_head] RelayReq req_head
         * @property {Uint8Array|null} [nick_name] RelayReq nick_name
         * @property {number|null} [role] RelayReq role
         * @property {Uint8Array|null} [relay_type] RelayReq relay_type
         * @property {Uint8Array|null} [relay_data] RelayReq relay_data
         */

        /**
         * Constructs a new RelayReq.
         * @memberof liveroom_cs
         * @classdesc Represents a RelayReq.
         * @implements IRelayReq
         * @constructor
         * @param {liveroom_cs.IRelayReq=} [properties] Properties to set
         */
        function RelayReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RelayReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.RelayReq
         * @instance
         */
        RelayReq.prototype.req_head = null;

        /**
         * RelayReq nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.RelayReq
         * @instance
         */
        RelayReq.prototype.nick_name = $util.newBuffer([]);

        /**
         * RelayReq role.
         * @member {number} role
         * @memberof liveroom_cs.RelayReq
         * @instance
         */
        RelayReq.prototype.role = 0;

        /**
         * RelayReq relay_type.
         * @member {Uint8Array} relay_type
         * @memberof liveroom_cs.RelayReq
         * @instance
         */
        RelayReq.prototype.relay_type = $util.newBuffer([]);

        /**
         * RelayReq relay_data.
         * @member {Uint8Array} relay_data
         * @memberof liveroom_cs.RelayReq
         * @instance
         */
        RelayReq.prototype.relay_data = $util.newBuffer([]);

        /**
         * Creates a new RelayReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.RelayReq
         * @static
         * @param {liveroom_cs.IRelayReq=} [properties] Properties to set
         * @returns {liveroom_cs.RelayReq} RelayReq instance
         */
        RelayReq.create = function create(properties) {
            return new RelayReq(properties);
        };

        /**
         * Encodes the specified RelayReq message. Does not implicitly {@link liveroom_cs.RelayReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.RelayReq
         * @static
         * @param {liveroom_cs.IRelayReq} message RelayReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RelayReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.role);
            if (message.relay_type != null && Object.hasOwnProperty.call(message, "relay_type"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.relay_type);
            if (message.relay_data != null && Object.hasOwnProperty.call(message, "relay_data"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.relay_data);
            return writer;
        };

        /**
         * Decodes a RelayReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.RelayReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.RelayReq} RelayReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RelayReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.RelayReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.nick_name = reader.bytes();
                    break;
                case 3:
                    message.role = reader.uint32();
                    break;
                case 4:
                    message.relay_type = reader.bytes();
                    break;
                case 5:
                    message.relay_data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RelayReq;
    })();

    liveroom_cs.RelayRsp = (function() {

        /**
         * Properties of a RelayRsp.
         * @memberof liveroom_cs
         * @interface IRelayRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] RelayRsp rsp_head
         * @property {Uint8Array|null} [reley_type] RelayRsp reley_type
         * @property {Uint8Array|null} [relay_result] RelayRsp relay_result
         */

        /**
         * Constructs a new RelayRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a RelayRsp.
         * @implements IRelayRsp
         * @constructor
         * @param {liveroom_cs.IRelayRsp=} [properties] Properties to set
         */
        function RelayRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RelayRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.RelayRsp
         * @instance
         */
        RelayRsp.prototype.rsp_head = null;

        /**
         * RelayRsp reley_type.
         * @member {Uint8Array} reley_type
         * @memberof liveroom_cs.RelayRsp
         * @instance
         */
        RelayRsp.prototype.reley_type = $util.newBuffer([]);

        /**
         * RelayRsp relay_result.
         * @member {Uint8Array} relay_result
         * @memberof liveroom_cs.RelayRsp
         * @instance
         */
        RelayRsp.prototype.relay_result = $util.newBuffer([]);

        /**
         * Creates a new RelayRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.RelayRsp
         * @static
         * @param {liveroom_cs.IRelayRsp=} [properties] Properties to set
         * @returns {liveroom_cs.RelayRsp} RelayRsp instance
         */
        RelayRsp.create = function create(properties) {
            return new RelayRsp(properties);
        };

        /**
         * Encodes the specified RelayRsp message. Does not implicitly {@link liveroom_cs.RelayRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.RelayRsp
         * @static
         * @param {liveroom_cs.IRelayRsp} message RelayRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RelayRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.reley_type != null && Object.hasOwnProperty.call(message, "reley_type"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.reley_type);
            if (message.relay_result != null && Object.hasOwnProperty.call(message, "relay_result"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.relay_result);
            return writer;
        };

        /**
         * Decodes a RelayRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.RelayRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.RelayRsp} RelayRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RelayRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.RelayRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.reley_type = reader.bytes();
                    break;
                case 3:
                    message.relay_result = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RelayRsp;
    })();

    liveroom_cs.RenewTokenReq = (function() {

        /**
         * Properties of a RenewTokenReq.
         * @memberof liveroom_cs
         * @interface IRenewTokenReq
         * @property {liveroom_cs.IReqHead|null} [req_head] RenewTokenReq req_head
         * @property {string|null} [token] RenewTokenReq token
         */

        /**
         * Constructs a new RenewTokenReq.
         * @memberof liveroom_cs
         * @classdesc Represents a RenewTokenReq.
         * @implements IRenewTokenReq
         * @constructor
         * @param {liveroom_cs.IRenewTokenReq=} [properties] Properties to set
         */
        function RenewTokenReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RenewTokenReq req_head.
         * @member {liveroom_cs.IReqHead|null|undefined} req_head
         * @memberof liveroom_cs.RenewTokenReq
         * @instance
         */
        RenewTokenReq.prototype.req_head = null;

        /**
         * RenewTokenReq token.
         * @member {string} token
         * @memberof liveroom_cs.RenewTokenReq
         * @instance
         */
        RenewTokenReq.prototype.token = "";

        /**
         * Creates a new RenewTokenReq instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.RenewTokenReq
         * @static
         * @param {liveroom_cs.IRenewTokenReq=} [properties] Properties to set
         * @returns {liveroom_cs.RenewTokenReq} RenewTokenReq instance
         */
        RenewTokenReq.create = function create(properties) {
            return new RenewTokenReq(properties);
        };

        /**
         * Encodes the specified RenewTokenReq message. Does not implicitly {@link liveroom_cs.RenewTokenReq.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.RenewTokenReq
         * @static
         * @param {liveroom_cs.IRenewTokenReq} message RenewTokenReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenewTokenReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.req_head != null && Object.hasOwnProperty.call(message, "req_head"))
                $root.liveroom_cs.ReqHead.encode(message.req_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
            return writer;
        };

        /**
         * Decodes a RenewTokenReq message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.RenewTokenReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.RenewTokenReq} RenewTokenReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenewTokenReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.RenewTokenReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.req_head = $root.liveroom_cs.ReqHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.token = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RenewTokenReq;
    })();

    liveroom_cs.RenewTokenRsp = (function() {

        /**
         * Properties of a RenewTokenRsp.
         * @memberof liveroom_cs
         * @interface IRenewTokenRsp
         * @property {liveroom_cs.IRspHead|null} [rsp_head] RenewTokenRsp rsp_head
         * @property {number|null} [token_remain_time] RenewTokenRsp token_remain_time
         */

        /**
         * Constructs a new RenewTokenRsp.
         * @memberof liveroom_cs
         * @classdesc Represents a RenewTokenRsp.
         * @implements IRenewTokenRsp
         * @constructor
         * @param {liveroom_cs.IRenewTokenRsp=} [properties] Properties to set
         */
        function RenewTokenRsp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RenewTokenRsp rsp_head.
         * @member {liveroom_cs.IRspHead|null|undefined} rsp_head
         * @memberof liveroom_cs.RenewTokenRsp
         * @instance
         */
        RenewTokenRsp.prototype.rsp_head = null;

        /**
         * RenewTokenRsp token_remain_time.
         * @member {number} token_remain_time
         * @memberof liveroom_cs.RenewTokenRsp
         * @instance
         */
        RenewTokenRsp.prototype.token_remain_time = 0;

        /**
         * Creates a new RenewTokenRsp instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.RenewTokenRsp
         * @static
         * @param {liveroom_cs.IRenewTokenRsp=} [properties] Properties to set
         * @returns {liveroom_cs.RenewTokenRsp} RenewTokenRsp instance
         */
        RenewTokenRsp.create = function create(properties) {
            return new RenewTokenRsp(properties);
        };

        /**
         * Encodes the specified RenewTokenRsp message. Does not implicitly {@link liveroom_cs.RenewTokenRsp.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.RenewTokenRsp
         * @static
         * @param {liveroom_cs.IRenewTokenRsp} message RenewTokenRsp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenewTokenRsp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rsp_head != null && Object.hasOwnProperty.call(message, "rsp_head"))
                $root.liveroom_cs.RspHead.encode(message.rsp_head, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.token_remain_time != null && Object.hasOwnProperty.call(message, "token_remain_time"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.token_remain_time);
            return writer;
        };

        /**
         * Decodes a RenewTokenRsp message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.RenewTokenRsp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.RenewTokenRsp} RenewTokenRsp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenewTokenRsp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.RenewTokenRsp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rsp_head = $root.liveroom_cs.RspHead.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.token_remain_time = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return RenewTokenRsp;
    })();

    liveroom_cs.UserAction = (function() {

        /**
         * Properties of a UserAction.
         * @memberof liveroom_cs
         * @interface IUserAction
         * @property {number|null} [action] UserAction action
         * @property {Uint8Array|null} [id_name] UserAction id_name
         * @property {Uint8Array|null} [nick_name] UserAction nick_name
         * @property {number|null} [role] UserAction role
         * @property {number|Long|null} [login_time] UserAction login_time
         */

        /**
         * Constructs a new UserAction.
         * @memberof liveroom_cs
         * @classdesc Represents a UserAction.
         * @implements IUserAction
         * @constructor
         * @param {liveroom_cs.IUserAction=} [properties] Properties to set
         */
        function UserAction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserAction action.
         * @member {number} action
         * @memberof liveroom_cs.UserAction
         * @instance
         */
        UserAction.prototype.action = 0;

        /**
         * UserAction id_name.
         * @member {Uint8Array} id_name
         * @memberof liveroom_cs.UserAction
         * @instance
         */
        UserAction.prototype.id_name = $util.newBuffer([]);

        /**
         * UserAction nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.UserAction
         * @instance
         */
        UserAction.prototype.nick_name = $util.newBuffer([]);

        /**
         * UserAction role.
         * @member {number} role
         * @memberof liveroom_cs.UserAction
         * @instance
         */
        UserAction.prototype.role = 0;

        /**
         * UserAction login_time.
         * @member {number|Long} login_time
         * @memberof liveroom_cs.UserAction
         * @instance
         */
        UserAction.prototype.login_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UserAction instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.UserAction
         * @static
         * @param {liveroom_cs.IUserAction=} [properties] Properties to set
         * @returns {liveroom_cs.UserAction} UserAction instance
         */
        UserAction.create = function create(properties) {
            return new UserAction(properties);
        };

        /**
         * Encodes the specified UserAction message. Does not implicitly {@link liveroom_cs.UserAction.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.UserAction
         * @static
         * @param {liveroom_cs.IUserAction} message UserAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.action);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.id_name);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.role);
            if (message.login_time != null && Object.hasOwnProperty.call(message, "login_time"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.login_time);
            return writer;
        };

        /**
         * Decodes a UserAction message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.UserAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.UserAction} UserAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.UserAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.uint32();
                    break;
                case 2:
                    message.id_name = reader.bytes();
                    break;
                case 3:
                    message.nick_name = reader.bytes();
                    break;
                case 4:
                    message.role = reader.uint32();
                    break;
                case 5:
                    message.login_time = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return UserAction;
    })();

    liveroom_cs.PushUserInfoUpdated = (function() {

        /**
         * Properties of a PushUserInfoUpdated.
         * @memberof liveroom_cs
         * @interface IPushUserInfoUpdated
         * @property {Uint8Array|null} [room_id] PushUserInfoUpdated room_id
         * @property {number|Long|null} [server_user_seq] PushUserInfoUpdated server_user_seq
         * @property {Array.<liveroom_cs.IUserAction>|null} [user_list] PushUserInfoUpdated user_list
         */

        /**
         * Constructs a new PushUserInfoUpdated.
         * @memberof liveroom_cs
         * @classdesc Represents a PushUserInfoUpdated.
         * @implements IPushUserInfoUpdated
         * @constructor
         * @param {liveroom_cs.IPushUserInfoUpdated=} [properties] Properties to set
         */
        function PushUserInfoUpdated(properties) {
            this.user_list = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushUserInfoUpdated room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.PushUserInfoUpdated
         * @instance
         */
        PushUserInfoUpdated.prototype.room_id = $util.newBuffer([]);

        /**
         * PushUserInfoUpdated server_user_seq.
         * @member {number|Long} server_user_seq
         * @memberof liveroom_cs.PushUserInfoUpdated
         * @instance
         */
        PushUserInfoUpdated.prototype.server_user_seq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PushUserInfoUpdated user_list.
         * @member {Array.<liveroom_cs.IUserAction>} user_list
         * @memberof liveroom_cs.PushUserInfoUpdated
         * @instance
         */
        PushUserInfoUpdated.prototype.user_list = $util.emptyArray;

        /**
         * Creates a new PushUserInfoUpdated instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.PushUserInfoUpdated
         * @static
         * @param {liveroom_cs.IPushUserInfoUpdated=} [properties] Properties to set
         * @returns {liveroom_cs.PushUserInfoUpdated} PushUserInfoUpdated instance
         */
        PushUserInfoUpdated.create = function create(properties) {
            return new PushUserInfoUpdated(properties);
        };

        /**
         * Encodes the specified PushUserInfoUpdated message. Does not implicitly {@link liveroom_cs.PushUserInfoUpdated.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.PushUserInfoUpdated
         * @static
         * @param {liveroom_cs.IPushUserInfoUpdated} message PushUserInfoUpdated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushUserInfoUpdated.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.room_id);
            if (message.server_user_seq != null && Object.hasOwnProperty.call(message, "server_user_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.server_user_seq);
            if (message.user_list != null && message.user_list.length)
                for (var i = 0; i < message.user_list.length; ++i)
                    $root.liveroom_cs.UserAction.encode(message.user_list[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a PushUserInfoUpdated message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.PushUserInfoUpdated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.PushUserInfoUpdated} PushUserInfoUpdated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushUserInfoUpdated.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.PushUserInfoUpdated();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.room_id = reader.bytes();
                    break;
                case 2:
                    message.server_user_seq = reader.int64();
                    break;
                case 3:
                    if (!(message.user_list && message.user_list.length))
                        message.user_list = [];
                    message.user_list.push($root.liveroom_cs.UserAction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushUserInfoUpdated;
    })();

    liveroom_cs.PushUserKickout = (function() {

        /**
         * Properties of a PushUserKickout.
         * @memberof liveroom_cs
         * @interface IPushUserKickout
         * @property {Uint8Array|null} [id_name] PushUserKickout id_name
         * @property {Uint8Array|null} [room_id] PushUserKickout room_id
         * @property {number|Long|null} [session_id] PushUserKickout session_id
         * @property {number|null} [kickout_reason] PushUserKickout kickout_reason
         * @property {Uint8Array|null} [custom_reason] PushUserKickout custom_reason
         */

        /**
         * Constructs a new PushUserKickout.
         * @memberof liveroom_cs
         * @classdesc lr/push/user_kickout
         * @implements IPushUserKickout
         * @constructor
         * @param {liveroom_cs.IPushUserKickout=} [properties] Properties to set
         */
        function PushUserKickout(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushUserKickout id_name.
         * @member {Uint8Array} id_name
         * @memberof liveroom_cs.PushUserKickout
         * @instance
         */
        PushUserKickout.prototype.id_name = $util.newBuffer([]);

        /**
         * PushUserKickout room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.PushUserKickout
         * @instance
         */
        PushUserKickout.prototype.room_id = $util.newBuffer([]);

        /**
         * PushUserKickout session_id.
         * @member {number|Long} session_id
         * @memberof liveroom_cs.PushUserKickout
         * @instance
         */
        PushUserKickout.prototype.session_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PushUserKickout kickout_reason.
         * @member {number} kickout_reason
         * @memberof liveroom_cs.PushUserKickout
         * @instance
         */
        PushUserKickout.prototype.kickout_reason = 0;

        /**
         * PushUserKickout custom_reason.
         * @member {Uint8Array} custom_reason
         * @memberof liveroom_cs.PushUserKickout
         * @instance
         */
        PushUserKickout.prototype.custom_reason = $util.newBuffer([]);

        /**
         * Creates a new PushUserKickout instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.PushUserKickout
         * @static
         * @param {liveroom_cs.IPushUserKickout=} [properties] Properties to set
         * @returns {liveroom_cs.PushUserKickout} PushUserKickout instance
         */
        PushUserKickout.create = function create(properties) {
            return new PushUserKickout(properties);
        };

        /**
         * Encodes the specified PushUserKickout message. Does not implicitly {@link liveroom_cs.PushUserKickout.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.PushUserKickout
         * @static
         * @param {liveroom_cs.IPushUserKickout} message PushUserKickout message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushUserKickout.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id_name);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.room_id);
            if (message.session_id != null && Object.hasOwnProperty.call(message, "session_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.session_id);
            if (message.kickout_reason != null && Object.hasOwnProperty.call(message, "kickout_reason"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.kickout_reason);
            if (message.custom_reason != null && Object.hasOwnProperty.call(message, "custom_reason"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.custom_reason);
            return writer;
        };

        /**
         * Decodes a PushUserKickout message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.PushUserKickout
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.PushUserKickout} PushUserKickout
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushUserKickout.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.PushUserKickout();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id_name = reader.bytes();
                    break;
                case 2:
                    message.room_id = reader.bytes();
                    break;
                case 3:
                    message.session_id = reader.uint64();
                    break;
                case 4:
                    message.kickout_reason = reader.int32();
                    break;
                case 5:
                    message.custom_reason = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushUserKickout;
    })();

    liveroom_cs.PushUserLogReport = (function() {

        /**
         * Properties of a PushUserLogReport.
         * @memberof liveroom_cs
         * @interface IPushUserLogReport
         */

        /**
         * Constructs a new PushUserLogReport.
         * @memberof liveroom_cs
         * @classdesc Represents a PushUserLogReport.
         * @implements IPushUserLogReport
         * @constructor
         * @param {liveroom_cs.IPushUserLogReport=} [properties] Properties to set
         */
        function PushUserLogReport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PushUserLogReport instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.PushUserLogReport
         * @static
         * @param {liveroom_cs.IPushUserLogReport=} [properties] Properties to set
         * @returns {liveroom_cs.PushUserLogReport} PushUserLogReport instance
         */
        PushUserLogReport.create = function create(properties) {
            return new PushUserLogReport(properties);
        };

        /**
         * Encodes the specified PushUserLogReport message. Does not implicitly {@link liveroom_cs.PushUserLogReport.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.PushUserLogReport
         * @static
         * @param {liveroom_cs.IPushUserLogReport} message PushUserLogReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushUserLogReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Decodes a PushUserLogReport message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.PushUserLogReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.PushUserLogReport} PushUserLogReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushUserLogReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.PushUserLogReport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushUserLogReport;
    })();

    liveroom_cs.PushUserTokenExpire = (function() {

        /**
         * Properties of a PushUserTokenExpire.
         * @memberof liveroom_cs
         * @interface IPushUserTokenExpire
         * @property {Uint8Array|null} [room_id] PushUserTokenExpire room_id
         * @property {string|null} [token] PushUserTokenExpire token
         * @property {liveroom_cs.IStopStream|null} [stop_stream] PushUserTokenExpire stop_stream
         */

        /**
         * Constructs a new PushUserTokenExpire.
         * @memberof liveroom_cs
         * @classdesc Represents a PushUserTokenExpire.
         * @implements IPushUserTokenExpire
         * @constructor
         * @param {liveroom_cs.IPushUserTokenExpire=} [properties] Properties to set
         */
        function PushUserTokenExpire(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushUserTokenExpire room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.PushUserTokenExpire
         * @instance
         */
        PushUserTokenExpire.prototype.room_id = $util.newBuffer([]);

        /**
         * PushUserTokenExpire token.
         * @member {string} token
         * @memberof liveroom_cs.PushUserTokenExpire
         * @instance
         */
        PushUserTokenExpire.prototype.token = "";

        /**
         * PushUserTokenExpire stop_stream.
         * @member {liveroom_cs.IStopStream|null|undefined} stop_stream
         * @memberof liveroom_cs.PushUserTokenExpire
         * @instance
         */
        PushUserTokenExpire.prototype.stop_stream = null;

        /**
         * Creates a new PushUserTokenExpire instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.PushUserTokenExpire
         * @static
         * @param {liveroom_cs.IPushUserTokenExpire=} [properties] Properties to set
         * @returns {liveroom_cs.PushUserTokenExpire} PushUserTokenExpire instance
         */
        PushUserTokenExpire.create = function create(properties) {
            return new PushUserTokenExpire(properties);
        };

        /**
         * Encodes the specified PushUserTokenExpire message. Does not implicitly {@link liveroom_cs.PushUserTokenExpire.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.PushUserTokenExpire
         * @static
         * @param {liveroom_cs.IPushUserTokenExpire} message PushUserTokenExpire message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushUserTokenExpire.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.room_id);
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);
            if (message.stop_stream != null && Object.hasOwnProperty.call(message, "stop_stream"))
                $root.liveroom_cs.StopStream.encode(message.stop_stream, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a PushUserTokenExpire message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.PushUserTokenExpire
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.PushUserTokenExpire} PushUserTokenExpire
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushUserTokenExpire.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.PushUserTokenExpire();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.room_id = reader.bytes();
                    break;
                case 2:
                    message.token = reader.string();
                    break;
                case 3:
                    message.stop_stream = $root.liveroom_cs.StopStream.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushUserTokenExpire;
    })();

    liveroom_cs.StopStream = (function() {

        /**
         * Properties of a StopStream.
         * @memberof liveroom_cs
         * @interface IStopStream
         * @property {Array.<Uint8Array>|null} [stream_id_list] StopStream stream_id_list
         */

        /**
         * Constructs a new StopStream.
         * @memberof liveroom_cs
         * @classdesc Represents a StopStream.
         * @implements IStopStream
         * @constructor
         * @param {liveroom_cs.IStopStream=} [properties] Properties to set
         */
        function StopStream(properties) {
            this.stream_id_list = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StopStream stream_id_list.
         * @member {Array.<Uint8Array>} stream_id_list
         * @memberof liveroom_cs.StopStream
         * @instance
         */
        StopStream.prototype.stream_id_list = $util.emptyArray;

        /**
         * Creates a new StopStream instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StopStream
         * @static
         * @param {liveroom_cs.IStopStream=} [properties] Properties to set
         * @returns {liveroom_cs.StopStream} StopStream instance
         */
        StopStream.create = function create(properties) {
            return new StopStream(properties);
        };

        /**
         * Encodes the specified StopStream message. Does not implicitly {@link liveroom_cs.StopStream.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StopStream
         * @static
         * @param {liveroom_cs.IStopStream} message StopStream message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopStream.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stream_id_list != null && message.stream_id_list.length)
                for (var i = 0; i < message.stream_id_list.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.stream_id_list[i]);
            return writer;
        };

        /**
         * Decodes a StopStream message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StopStream
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StopStream} StopStream
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopStream.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StopStream();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.stream_id_list && message.stream_id_list.length))
                        message.stream_id_list = [];
                    message.stream_id_list.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StopStream;
    })();

    liveroom_cs.PushStream = (function() {

        /**
         * Properties of a PushStream.
         * @memberof liveroom_cs
         * @interface IPushStream
         * @property {Uint8Array|null} [room_id] PushStream room_id
         * @property {number|null} [stream_seq] PushStream stream_seq
         * @property {Array.<liveroom_cs.IStPushStreamInfo>|null} [stream_info] PushStream stream_info
         */

        /**
         * Constructs a new PushStream.
         * @memberof liveroom_cs
         * @classdesc Represents a PushStream.
         * @implements IPushStream
         * @constructor
         * @param {liveroom_cs.IPushStream=} [properties] Properties to set
         */
        function PushStream(properties) {
            this.stream_info = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushStream room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.PushStream
         * @instance
         */
        PushStream.prototype.room_id = $util.newBuffer([]);

        /**
         * PushStream stream_seq.
         * @member {number} stream_seq
         * @memberof liveroom_cs.PushStream
         * @instance
         */
        PushStream.prototype.stream_seq = 0;

        /**
         * PushStream stream_info.
         * @member {Array.<liveroom_cs.IStPushStreamInfo>} stream_info
         * @memberof liveroom_cs.PushStream
         * @instance
         */
        PushStream.prototype.stream_info = $util.emptyArray;

        /**
         * Creates a new PushStream instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.PushStream
         * @static
         * @param {liveroom_cs.IPushStream=} [properties] Properties to set
         * @returns {liveroom_cs.PushStream} PushStream instance
         */
        PushStream.create = function create(properties) {
            return new PushStream(properties);
        };

        /**
         * Encodes the specified PushStream message. Does not implicitly {@link liveroom_cs.PushStream.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.PushStream
         * @static
         * @param {liveroom_cs.IPushStream} message PushStream message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushStream.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.room_id);
            if (message.stream_seq != null && Object.hasOwnProperty.call(message, "stream_seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.stream_seq);
            if (message.stream_info != null && message.stream_info.length)
                for (var i = 0; i < message.stream_info.length; ++i)
                    $root.liveroom_cs.StPushStreamInfo.encode(message.stream_info[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a PushStream message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.PushStream
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.PushStream} PushStream
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushStream.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.PushStream();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.room_id = reader.bytes();
                    break;
                case 2:
                    message.stream_seq = reader.uint32();
                    break;
                case 3:
                    if (!(message.stream_info && message.stream_info.length))
                        message.stream_info = [];
                    message.stream_info.push($root.liveroom_cs.StPushStreamInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushStream;
    })();

    liveroom_cs.StPushStreamInfo = (function() {

        /**
         * Properties of a StPushStreamInfo.
         * @memberof liveroom_cs
         * @interface IStPushStreamInfo
         * @property {Uint8Array|null} [stream_id] StPushStreamInfo stream_id
         * @property {string|null} [stream_sid] StPushStreamInfo stream_sid
         * @property {Uint8Array|null} [id_name] StPushStreamInfo id_name
         * @property {Uint8Array|null} [nick_name] StPushStreamInfo nick_name
         * @property {Uint8Array|null} [extra_info] StPushStreamInfo extra_info
         * @property {Uint8Array|null} [title] StPushStreamInfo title
         * @property {Uint8Array|null} [third_define_data] StPushStreamInfo third_define_data
         * @property {number|Long|null} [create_time] StPushStreamInfo create_time
         * @property {number|null} [req_seq] StPushStreamInfo req_seq
         * @property {number|null} [stream_ver] StPushStreamInfo stream_ver
         * @property {Uint8Array|null} [stream_attr] StPushStreamInfo stream_attr
         * @property {number|null} [stream_src] StPushStreamInfo stream_src
         * @property {number|null} [stream_state] StPushStreamInfo stream_state
         * @property {number|null} [stream_type] StPushStreamInfo stream_type
         * @property {number|null} [stream_nid] StPushStreamInfo stream_nid
         * @property {number|null} [close_type] StPushStreamInfo close_type
         */

        /**
         * Constructs a new StPushStreamInfo.
         * @memberof liveroom_cs
         * @classdesc Represents a StPushStreamInfo.
         * @implements IStPushStreamInfo
         * @constructor
         * @param {liveroom_cs.IStPushStreamInfo=} [properties] Properties to set
         */
        function StPushStreamInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StPushStreamInfo stream_id.
         * @member {Uint8Array} stream_id
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.stream_id = $util.newBuffer([]);

        /**
         * StPushStreamInfo stream_sid.
         * @member {string} stream_sid
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.stream_sid = "";

        /**
         * StPushStreamInfo id_name.
         * @member {Uint8Array} id_name
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.id_name = $util.newBuffer([]);

        /**
         * StPushStreamInfo nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.nick_name = $util.newBuffer([]);

        /**
         * StPushStreamInfo extra_info.
         * @member {Uint8Array} extra_info
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.extra_info = $util.newBuffer([]);

        /**
         * StPushStreamInfo title.
         * @member {Uint8Array} title
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.title = $util.newBuffer([]);

        /**
         * StPushStreamInfo third_define_data.
         * @member {Uint8Array} third_define_data
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.third_define_data = $util.newBuffer([]);

        /**
         * StPushStreamInfo create_time.
         * @member {number|Long} create_time
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.create_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StPushStreamInfo req_seq.
         * @member {number} req_seq
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.req_seq = 0;

        /**
         * StPushStreamInfo stream_ver.
         * @member {number} stream_ver
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.stream_ver = 0;

        /**
         * StPushStreamInfo stream_attr.
         * @member {Uint8Array} stream_attr
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.stream_attr = $util.newBuffer([]);

        /**
         * StPushStreamInfo stream_src.
         * @member {number} stream_src
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.stream_src = 0;

        /**
         * StPushStreamInfo stream_state.
         * @member {number} stream_state
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.stream_state = 0;

        /**
         * StPushStreamInfo stream_type.
         * @member {number} stream_type
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.stream_type = 0;

        /**
         * StPushStreamInfo stream_nid.
         * @member {number} stream_nid
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.stream_nid = 0;

        /**
         * StPushStreamInfo close_type.
         * @member {number} close_type
         * @memberof liveroom_cs.StPushStreamInfo
         * @instance
         */
        StPushStreamInfo.prototype.close_type = 0;

        /**
         * Creates a new StPushStreamInfo instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StPushStreamInfo
         * @static
         * @param {liveroom_cs.IStPushStreamInfo=} [properties] Properties to set
         * @returns {liveroom_cs.StPushStreamInfo} StPushStreamInfo instance
         */
        StPushStreamInfo.create = function create(properties) {
            return new StPushStreamInfo(properties);
        };

        /**
         * Encodes the specified StPushStreamInfo message. Does not implicitly {@link liveroom_cs.StPushStreamInfo.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StPushStreamInfo
         * @static
         * @param {liveroom_cs.IStPushStreamInfo} message StPushStreamInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StPushStreamInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stream_id != null && Object.hasOwnProperty.call(message, "stream_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.stream_id);
            if (message.stream_sid != null && Object.hasOwnProperty.call(message, "stream_sid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.stream_sid);
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.id_name);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.nick_name);
            if (message.extra_info != null && Object.hasOwnProperty.call(message, "extra_info"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.extra_info);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.title);
            if (message.third_define_data != null && Object.hasOwnProperty.call(message, "third_define_data"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.third_define_data);
            if (message.create_time != null && Object.hasOwnProperty.call(message, "create_time"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.create_time);
            if (message.req_seq != null && Object.hasOwnProperty.call(message, "req_seq"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.req_seq);
            if (message.stream_ver != null && Object.hasOwnProperty.call(message, "stream_ver"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.stream_ver);
            if (message.stream_attr != null && Object.hasOwnProperty.call(message, "stream_attr"))
                writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.stream_attr);
            if (message.stream_src != null && Object.hasOwnProperty.call(message, "stream_src"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.stream_src);
            if (message.stream_state != null && Object.hasOwnProperty.call(message, "stream_state"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.stream_state);
            if (message.stream_type != null && Object.hasOwnProperty.call(message, "stream_type"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.stream_type);
            if (message.stream_nid != null && Object.hasOwnProperty.call(message, "stream_nid"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.stream_nid);
            if (message.close_type != null && Object.hasOwnProperty.call(message, "close_type"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.close_type);
            return writer;
        };

        /**
         * Decodes a StPushStreamInfo message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StPushStreamInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StPushStreamInfo} StPushStreamInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StPushStreamInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StPushStreamInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stream_id = reader.bytes();
                    break;
                case 2:
                    message.stream_sid = reader.string();
                    break;
                case 3:
                    message.id_name = reader.bytes();
                    break;
                case 4:
                    message.nick_name = reader.bytes();
                    break;
                case 5:
                    message.extra_info = reader.bytes();
                    break;
                case 6:
                    message.title = reader.bytes();
                    break;
                case 7:
                    message.third_define_data = reader.bytes();
                    break;
                case 8:
                    message.create_time = reader.int64();
                    break;
                case 9:
                    message.req_seq = reader.uint32();
                    break;
                case 10:
                    message.stream_ver = reader.uint32();
                    break;
                case 11:
                    message.stream_attr = reader.bytes();
                    break;
                case 12:
                    message.stream_src = reader.uint32();
                    break;
                case 13:
                    message.stream_state = reader.uint32();
                    break;
                case 14:
                    message.stream_type = reader.uint32();
                    break;
                case 15:
                    message.stream_nid = reader.uint32();
                    break;
                case 16:
                    message.close_type = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StPushStreamInfo;
    })();

    liveroom_cs.PushImChat = (function() {

        /**
         * Properties of a PushImChat.
         * @memberof liveroom_cs
         * @interface IPushImChat
         * @property {Uint8Array|null} [room_id] PushImChat room_id
         * @property {number|Long|null} [server_msg_id] PushImChat server_msg_id
         * @property {number|Long|null} [ret_msg_id] PushImChat ret_msg_id
         * @property {Array.<liveroom_cs.IStImChatData>|null} [msg_data] PushImChat msg_data
         */

        /**
         * Constructs a new PushImChat.
         * @memberof liveroom_cs
         * @classdesc Represents a PushImChat.
         * @implements IPushImChat
         * @constructor
         * @param {liveroom_cs.IPushImChat=} [properties] Properties to set
         */
        function PushImChat(properties) {
            this.msg_data = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushImChat room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.PushImChat
         * @instance
         */
        PushImChat.prototype.room_id = $util.newBuffer([]);

        /**
         * PushImChat server_msg_id.
         * @member {number|Long} server_msg_id
         * @memberof liveroom_cs.PushImChat
         * @instance
         */
        PushImChat.prototype.server_msg_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PushImChat ret_msg_id.
         * @member {number|Long} ret_msg_id
         * @memberof liveroom_cs.PushImChat
         * @instance
         */
        PushImChat.prototype.ret_msg_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PushImChat msg_data.
         * @member {Array.<liveroom_cs.IStImChatData>} msg_data
         * @memberof liveroom_cs.PushImChat
         * @instance
         */
        PushImChat.prototype.msg_data = $util.emptyArray;

        /**
         * Creates a new PushImChat instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.PushImChat
         * @static
         * @param {liveroom_cs.IPushImChat=} [properties] Properties to set
         * @returns {liveroom_cs.PushImChat} PushImChat instance
         */
        PushImChat.create = function create(properties) {
            return new PushImChat(properties);
        };

        /**
         * Encodes the specified PushImChat message. Does not implicitly {@link liveroom_cs.PushImChat.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.PushImChat
         * @static
         * @param {liveroom_cs.IPushImChat} message PushImChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushImChat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.room_id);
            if (message.server_msg_id != null && Object.hasOwnProperty.call(message, "server_msg_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.server_msg_id);
            if (message.ret_msg_id != null && Object.hasOwnProperty.call(message, "ret_msg_id"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.ret_msg_id);
            if (message.msg_data != null && message.msg_data.length)
                for (var i = 0; i < message.msg_data.length; ++i)
                    $root.liveroom_cs.StImChatData.encode(message.msg_data[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a PushImChat message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.PushImChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.PushImChat} PushImChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushImChat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.PushImChat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.room_id = reader.bytes();
                    break;
                case 2:
                    message.server_msg_id = reader.uint64();
                    break;
                case 3:
                    message.ret_msg_id = reader.uint64();
                    break;
                case 4:
                    if (!(message.msg_data && message.msg_data.length))
                        message.msg_data = [];
                    message.msg_data.push($root.liveroom_cs.StImChatData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushImChat;
    })();

    liveroom_cs.StImChatData = (function() {

        /**
         * Properties of a StImChatData.
         * @memberof liveroom_cs
         * @interface IStImChatData
         * @property {Uint8Array|null} [id_name] StImChatData id_name
         * @property {Uint8Array|null} [nick_name] StImChatData nick_name
         * @property {number|null} [role] StImChatData role
         * @property {number|Long|null} [msg_id] StImChatData msg_id
         * @property {number|null} [msg_category] StImChatData msg_category
         * @property {number|null} [msg_type] StImChatData msg_type
         * @property {number|null} [msg_priority] StImChatData msg_priority
         * @property {Uint8Array|null} [msg_content] StImChatData msg_content
         * @property {number|Long|null} [send_time] StImChatData send_time
         */

        /**
         * Constructs a new StImChatData.
         * @memberof liveroom_cs
         * @classdesc Represents a StImChatData.
         * @implements IStImChatData
         * @constructor
         * @param {liveroom_cs.IStImChatData=} [properties] Properties to set
         */
        function StImChatData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StImChatData id_name.
         * @member {Uint8Array} id_name
         * @memberof liveroom_cs.StImChatData
         * @instance
         */
        StImChatData.prototype.id_name = $util.newBuffer([]);

        /**
         * StImChatData nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.StImChatData
         * @instance
         */
        StImChatData.prototype.nick_name = $util.newBuffer([]);

        /**
         * StImChatData role.
         * @member {number} role
         * @memberof liveroom_cs.StImChatData
         * @instance
         */
        StImChatData.prototype.role = 0;

        /**
         * StImChatData msg_id.
         * @member {number|Long} msg_id
         * @memberof liveroom_cs.StImChatData
         * @instance
         */
        StImChatData.prototype.msg_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StImChatData msg_category.
         * @member {number} msg_category
         * @memberof liveroom_cs.StImChatData
         * @instance
         */
        StImChatData.prototype.msg_category = 0;

        /**
         * StImChatData msg_type.
         * @member {number} msg_type
         * @memberof liveroom_cs.StImChatData
         * @instance
         */
        StImChatData.prototype.msg_type = 0;

        /**
         * StImChatData msg_priority.
         * @member {number} msg_priority
         * @memberof liveroom_cs.StImChatData
         * @instance
         */
        StImChatData.prototype.msg_priority = 0;

        /**
         * StImChatData msg_content.
         * @member {Uint8Array} msg_content
         * @memberof liveroom_cs.StImChatData
         * @instance
         */
        StImChatData.prototype.msg_content = $util.newBuffer([]);

        /**
         * StImChatData send_time.
         * @member {number|Long} send_time
         * @memberof liveroom_cs.StImChatData
         * @instance
         */
        StImChatData.prototype.send_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new StImChatData instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StImChatData
         * @static
         * @param {liveroom_cs.IStImChatData=} [properties] Properties to set
         * @returns {liveroom_cs.StImChatData} StImChatData instance
         */
        StImChatData.create = function create(properties) {
            return new StImChatData(properties);
        };

        /**
         * Encodes the specified StImChatData message. Does not implicitly {@link liveroom_cs.StImChatData.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StImChatData
         * @static
         * @param {liveroom_cs.IStImChatData} message StImChatData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StImChatData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id_name);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.role);
            if (message.msg_id != null && Object.hasOwnProperty.call(message, "msg_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.msg_id);
            if (message.msg_category != null && Object.hasOwnProperty.call(message, "msg_category"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.msg_category);
            if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.msg_type);
            if (message.msg_priority != null && Object.hasOwnProperty.call(message, "msg_priority"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.msg_priority);
            if (message.msg_content != null && Object.hasOwnProperty.call(message, "msg_content"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.msg_content);
            if (message.send_time != null && Object.hasOwnProperty.call(message, "send_time"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.send_time);
            return writer;
        };

        /**
         * Decodes a StImChatData message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StImChatData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StImChatData} StImChatData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StImChatData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StImChatData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id_name = reader.bytes();
                    break;
                case 2:
                    message.nick_name = reader.bytes();
                    break;
                case 3:
                    message.role = reader.uint32();
                    break;
                case 4:
                    message.msg_id = reader.uint64();
                    break;
                case 5:
                    message.msg_category = reader.uint32();
                    break;
                case 6:
                    message.msg_type = reader.uint32();
                    break;
                case 7:
                    message.msg_priority = reader.uint32();
                    break;
                case 8:
                    message.msg_content = reader.bytes();
                    break;
                case 9:
                    message.send_time = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StImChatData;
    })();

    liveroom_cs.PushBigImChat = (function() {

        /**
         * Properties of a PushBigImChat.
         * @memberof liveroom_cs
         * @interface IPushBigImChat
         * @property {number|null} [app_id] PushBigImChat app_id
         * @property {Uint8Array|null} [room_id] PushBigImChat room_id
         * @property {number|Long|null} [timestamp] PushBigImChat timestamp
         * @property {Array.<liveroom_cs.IStBigImChatData>|null} [msg_data] PushBigImChat msg_data
         */

        /**
         * Constructs a new PushBigImChat.
         * @memberof liveroom_cs
         * @classdesc Represents a PushBigImChat.
         * @implements IPushBigImChat
         * @constructor
         * @param {liveroom_cs.IPushBigImChat=} [properties] Properties to set
         */
        function PushBigImChat(properties) {
            this.msg_data = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushBigImChat app_id.
         * @member {number} app_id
         * @memberof liveroom_cs.PushBigImChat
         * @instance
         */
        PushBigImChat.prototype.app_id = 0;

        /**
         * PushBigImChat room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.PushBigImChat
         * @instance
         */
        PushBigImChat.prototype.room_id = $util.newBuffer([]);

        /**
         * PushBigImChat timestamp.
         * @member {number|Long} timestamp
         * @memberof liveroom_cs.PushBigImChat
         * @instance
         */
        PushBigImChat.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PushBigImChat msg_data.
         * @member {Array.<liveroom_cs.IStBigImChatData>} msg_data
         * @memberof liveroom_cs.PushBigImChat
         * @instance
         */
        PushBigImChat.prototype.msg_data = $util.emptyArray;

        /**
         * Creates a new PushBigImChat instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.PushBigImChat
         * @static
         * @param {liveroom_cs.IPushBigImChat=} [properties] Properties to set
         * @returns {liveroom_cs.PushBigImChat} PushBigImChat instance
         */
        PushBigImChat.create = function create(properties) {
            return new PushBigImChat(properties);
        };

        /**
         * Encodes the specified PushBigImChat message. Does not implicitly {@link liveroom_cs.PushBigImChat.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.PushBigImChat
         * @static
         * @param {liveroom_cs.IPushBigImChat} message PushBigImChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushBigImChat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.app_id != null && Object.hasOwnProperty.call(message, "app_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.app_id);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.room_id);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            if (message.msg_data != null && message.msg_data.length)
                for (var i = 0; i < message.msg_data.length; ++i)
                    $root.liveroom_cs.StBigImChatData.encode(message.msg_data[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a PushBigImChat message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.PushBigImChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.PushBigImChat} PushBigImChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushBigImChat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.PushBigImChat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.app_id = reader.uint32();
                    break;
                case 2:
                    message.room_id = reader.bytes();
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                case 4:
                    if (!(message.msg_data && message.msg_data.length))
                        message.msg_data = [];
                    message.msg_data.push($root.liveroom_cs.StBigImChatData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushBigImChat;
    })();

    liveroom_cs.StBigImChatData = (function() {

        /**
         * Properties of a StBigImChatData.
         * @memberof liveroom_cs
         * @interface IStBigImChatData
         * @property {Uint8Array|null} [id_name] StBigImChatData id_name
         * @property {Uint8Array|null} [nick_name] StBigImChatData nick_name
         * @property {number|null} [role] StBigImChatData role
         * @property {Uint8Array|null} [bigmsg_id] StBigImChatData bigmsg_id
         * @property {number|null} [msg_category] StBigImChatData msg_category
         * @property {number|null} [msg_type] StBigImChatData msg_type
         * @property {Uint8Array|null} [msg_content] StBigImChatData msg_content
         * @property {number|Long|null} [msg_timestamp] StBigImChatData msg_timestamp
         */

        /**
         * Constructs a new StBigImChatData.
         * @memberof liveroom_cs
         * @classdesc Represents a StBigImChatData.
         * @implements IStBigImChatData
         * @constructor
         * @param {liveroom_cs.IStBigImChatData=} [properties] Properties to set
         */
        function StBigImChatData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StBigImChatData id_name.
         * @member {Uint8Array} id_name
         * @memberof liveroom_cs.StBigImChatData
         * @instance
         */
        StBigImChatData.prototype.id_name = $util.newBuffer([]);

        /**
         * StBigImChatData nick_name.
         * @member {Uint8Array} nick_name
         * @memberof liveroom_cs.StBigImChatData
         * @instance
         */
        StBigImChatData.prototype.nick_name = $util.newBuffer([]);

        /**
         * StBigImChatData role.
         * @member {number} role
         * @memberof liveroom_cs.StBigImChatData
         * @instance
         */
        StBigImChatData.prototype.role = 0;

        /**
         * StBigImChatData bigmsg_id.
         * @member {Uint8Array} bigmsg_id
         * @memberof liveroom_cs.StBigImChatData
         * @instance
         */
        StBigImChatData.prototype.bigmsg_id = $util.newBuffer([]);

        /**
         * StBigImChatData msg_category.
         * @member {number} msg_category
         * @memberof liveroom_cs.StBigImChatData
         * @instance
         */
        StBigImChatData.prototype.msg_category = 0;

        /**
         * StBigImChatData msg_type.
         * @member {number} msg_type
         * @memberof liveroom_cs.StBigImChatData
         * @instance
         */
        StBigImChatData.prototype.msg_type = 0;

        /**
         * StBigImChatData msg_content.
         * @member {Uint8Array} msg_content
         * @memberof liveroom_cs.StBigImChatData
         * @instance
         */
        StBigImChatData.prototype.msg_content = $util.newBuffer([]);

        /**
         * StBigImChatData msg_timestamp.
         * @member {number|Long} msg_timestamp
         * @memberof liveroom_cs.StBigImChatData
         * @instance
         */
        StBigImChatData.prototype.msg_timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new StBigImChatData instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StBigImChatData
         * @static
         * @param {liveroom_cs.IStBigImChatData=} [properties] Properties to set
         * @returns {liveroom_cs.StBigImChatData} StBigImChatData instance
         */
        StBigImChatData.create = function create(properties) {
            return new StBigImChatData(properties);
        };

        /**
         * Encodes the specified StBigImChatData message. Does not implicitly {@link liveroom_cs.StBigImChatData.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StBigImChatData
         * @static
         * @param {liveroom_cs.IStBigImChatData} message StBigImChatData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StBigImChatData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id_name != null && Object.hasOwnProperty.call(message, "id_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id_name);
            if (message.nick_name != null && Object.hasOwnProperty.call(message, "nick_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nick_name);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.role);
            if (message.bigmsg_id != null && Object.hasOwnProperty.call(message, "bigmsg_id"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.bigmsg_id);
            if (message.msg_category != null && Object.hasOwnProperty.call(message, "msg_category"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.msg_category);
            if (message.msg_type != null && Object.hasOwnProperty.call(message, "msg_type"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.msg_type);
            if (message.msg_content != null && Object.hasOwnProperty.call(message, "msg_content"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.msg_content);
            if (message.msg_timestamp != null && Object.hasOwnProperty.call(message, "msg_timestamp"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.msg_timestamp);
            return writer;
        };

        /**
         * Decodes a StBigImChatData message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StBigImChatData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StBigImChatData} StBigImChatData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StBigImChatData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StBigImChatData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id_name = reader.bytes();
                    break;
                case 2:
                    message.nick_name = reader.bytes();
                    break;
                case 3:
                    message.role = reader.uint32();
                    break;
                case 4:
                    message.bigmsg_id = reader.bytes();
                    break;
                case 5:
                    message.msg_category = reader.uint32();
                    break;
                case 6:
                    message.msg_type = reader.uint32();
                    break;
                case 7:
                    message.msg_content = reader.bytes();
                    break;
                case 8:
                    message.msg_timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StBigImChatData;
    })();

    liveroom_cs.PushTrans = (function() {

        /**
         * Properties of a PushTrans.
         * @memberof liveroom_cs
         * @interface IPushTrans
         * @property {number|null} [app_id] PushTrans app_id
         * @property {Uint8Array|null} [room_id] PushTrans room_id
         * @property {Uint8Array|null} [trans_idname] PushTrans trans_idname
         * @property {Uint8Array|null} [trans_nickname] PushTrans trans_nickname
         * @property {number|null} [trans_role] PushTrans trans_role
         * @property {Uint8Array|null} [trans_type] PushTrans trans_type
         * @property {Uint8Array|null} [trans_data] PushTrans trans_data
         * @property {number|null} [trans_seq] PushTrans trans_seq
         * @property {number|Long|null} [trans_send_time] PushTrans trans_send_time
         * @property {Uint8Array|null} [trans_channel] PushTrans trans_channel
         * @property {number|null} [trans_list_seq] PushTrans trans_list_seq
         */

        /**
         * Constructs a new PushTrans.
         * @memberof liveroom_cs
         * @classdesc Represents a PushTrans.
         * @implements IPushTrans
         * @constructor
         * @param {liveroom_cs.IPushTrans=} [properties] Properties to set
         */
        function PushTrans(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushTrans app_id.
         * @member {number} app_id
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.app_id = 0;

        /**
         * PushTrans room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.room_id = $util.newBuffer([]);

        /**
         * PushTrans trans_idname.
         * @member {Uint8Array} trans_idname
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.trans_idname = $util.newBuffer([]);

        /**
         * PushTrans trans_nickname.
         * @member {Uint8Array} trans_nickname
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.trans_nickname = $util.newBuffer([]);

        /**
         * PushTrans trans_role.
         * @member {number} trans_role
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.trans_role = 0;

        /**
         * PushTrans trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.trans_type = $util.newBuffer([]);

        /**
         * PushTrans trans_data.
         * @member {Uint8Array} trans_data
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.trans_data = $util.newBuffer([]);

        /**
         * PushTrans trans_seq.
         * @member {number} trans_seq
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.trans_seq = 0;

        /**
         * PushTrans trans_send_time.
         * @member {number|Long} trans_send_time
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.trans_send_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PushTrans trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.trans_channel = $util.newBuffer([]);

        /**
         * PushTrans trans_list_seq.
         * @member {number} trans_list_seq
         * @memberof liveroom_cs.PushTrans
         * @instance
         */
        PushTrans.prototype.trans_list_seq = 0;

        /**
         * Creates a new PushTrans instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.PushTrans
         * @static
         * @param {liveroom_cs.IPushTrans=} [properties] Properties to set
         * @returns {liveroom_cs.PushTrans} PushTrans instance
         */
        PushTrans.create = function create(properties) {
            return new PushTrans(properties);
        };

        /**
         * Encodes the specified PushTrans message. Does not implicitly {@link liveroom_cs.PushTrans.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.PushTrans
         * @static
         * @param {liveroom_cs.IPushTrans} message PushTrans message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushTrans.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.app_id != null && Object.hasOwnProperty.call(message, "app_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.app_id);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.room_id);
            if (message.trans_idname != null && Object.hasOwnProperty.call(message, "trans_idname"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.trans_idname);
            if (message.trans_nickname != null && Object.hasOwnProperty.call(message, "trans_nickname"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.trans_nickname);
            if (message.trans_role != null && Object.hasOwnProperty.call(message, "trans_role"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.trans_role);
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.trans_type);
            if (message.trans_data != null && Object.hasOwnProperty.call(message, "trans_data"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.trans_data);
            if (message.trans_seq != null && Object.hasOwnProperty.call(message, "trans_seq"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.trans_seq);
            if (message.trans_send_time != null && Object.hasOwnProperty.call(message, "trans_send_time"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.trans_send_time);
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.trans_channel);
            if (message.trans_list_seq != null && Object.hasOwnProperty.call(message, "trans_list_seq"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.trans_list_seq);
            return writer;
        };

        /**
         * Decodes a PushTrans message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.PushTrans
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.PushTrans} PushTrans
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushTrans.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.PushTrans();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.app_id = reader.uint32();
                    break;
                case 2:
                    message.room_id = reader.bytes();
                    break;
                case 3:
                    message.trans_idname = reader.bytes();
                    break;
                case 4:
                    message.trans_nickname = reader.bytes();
                    break;
                case 5:
                    message.trans_role = reader.uint32();
                    break;
                case 6:
                    message.trans_type = reader.bytes();
                    break;
                case 7:
                    message.trans_data = reader.bytes();
                    break;
                case 8:
                    message.trans_seq = reader.uint32();
                    break;
                case 9:
                    message.trans_send_time = reader.int64();
                    break;
                case 10:
                    message.trans_channel = reader.bytes();
                    break;
                case 11:
                    message.trans_list_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushTrans;
    })();

    liveroom_cs.PushUserTrans = (function() {

        /**
         * Properties of a PushUserTrans.
         * @memberof liveroom_cs
         * @interface IPushUserTrans
         * @property {number|null} [app_id] PushUserTrans app_id
         * @property {Uint8Array|null} [room_id] PushUserTrans room_id
         * @property {Uint8Array|null} [trans_idname] PushUserTrans trans_idname
         * @property {Uint8Array|null} [trans_nickname] PushUserTrans trans_nickname
         * @property {number|null} [trans_role] PushUserTrans trans_role
         * @property {number|Long|null} [trans_send_time] PushUserTrans trans_send_time
         * @property {Uint8Array|null} [trans_channel] PushUserTrans trans_channel
         * @property {Array.<liveroom_cs.IStTransSimple>|null} [trans_array] PushUserTrans trans_array
         */

        /**
         * Constructs a new PushUserTrans.
         * @memberof liveroom_cs
         * @classdesc Represents a PushUserTrans.
         * @implements IPushUserTrans
         * @constructor
         * @param {liveroom_cs.IPushUserTrans=} [properties] Properties to set
         */
        function PushUserTrans(properties) {
            this.trans_array = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushUserTrans app_id.
         * @member {number} app_id
         * @memberof liveroom_cs.PushUserTrans
         * @instance
         */
        PushUserTrans.prototype.app_id = 0;

        /**
         * PushUserTrans room_id.
         * @member {Uint8Array} room_id
         * @memberof liveroom_cs.PushUserTrans
         * @instance
         */
        PushUserTrans.prototype.room_id = $util.newBuffer([]);

        /**
         * PushUserTrans trans_idname.
         * @member {Uint8Array} trans_idname
         * @memberof liveroom_cs.PushUserTrans
         * @instance
         */
        PushUserTrans.prototype.trans_idname = $util.newBuffer([]);

        /**
         * PushUserTrans trans_nickname.
         * @member {Uint8Array} trans_nickname
         * @memberof liveroom_cs.PushUserTrans
         * @instance
         */
        PushUserTrans.prototype.trans_nickname = $util.newBuffer([]);

        /**
         * PushUserTrans trans_role.
         * @member {number} trans_role
         * @memberof liveroom_cs.PushUserTrans
         * @instance
         */
        PushUserTrans.prototype.trans_role = 0;

        /**
         * PushUserTrans trans_send_time.
         * @member {number|Long} trans_send_time
         * @memberof liveroom_cs.PushUserTrans
         * @instance
         */
        PushUserTrans.prototype.trans_send_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PushUserTrans trans_channel.
         * @member {Uint8Array} trans_channel
         * @memberof liveroom_cs.PushUserTrans
         * @instance
         */
        PushUserTrans.prototype.trans_channel = $util.newBuffer([]);

        /**
         * PushUserTrans trans_array.
         * @member {Array.<liveroom_cs.IStTransSimple>} trans_array
         * @memberof liveroom_cs.PushUserTrans
         * @instance
         */
        PushUserTrans.prototype.trans_array = $util.emptyArray;

        /**
         * Creates a new PushUserTrans instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.PushUserTrans
         * @static
         * @param {liveroom_cs.IPushUserTrans=} [properties] Properties to set
         * @returns {liveroom_cs.PushUserTrans} PushUserTrans instance
         */
        PushUserTrans.create = function create(properties) {
            return new PushUserTrans(properties);
        };

        /**
         * Encodes the specified PushUserTrans message. Does not implicitly {@link liveroom_cs.PushUserTrans.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.PushUserTrans
         * @static
         * @param {liveroom_cs.IPushUserTrans} message PushUserTrans message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushUserTrans.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.app_id != null && Object.hasOwnProperty.call(message, "app_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.app_id);
            if (message.room_id != null && Object.hasOwnProperty.call(message, "room_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.room_id);
            if (message.trans_idname != null && Object.hasOwnProperty.call(message, "trans_idname"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.trans_idname);
            if (message.trans_nickname != null && Object.hasOwnProperty.call(message, "trans_nickname"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.trans_nickname);
            if (message.trans_role != null && Object.hasOwnProperty.call(message, "trans_role"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.trans_role);
            if (message.trans_send_time != null && Object.hasOwnProperty.call(message, "trans_send_time"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.trans_send_time);
            if (message.trans_channel != null && Object.hasOwnProperty.call(message, "trans_channel"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.trans_channel);
            if (message.trans_array != null && message.trans_array.length)
                for (var i = 0; i < message.trans_array.length; ++i)
                    $root.liveroom_cs.StTransSimple.encode(message.trans_array[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Decodes a PushUserTrans message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.PushUserTrans
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.PushUserTrans} PushUserTrans
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushUserTrans.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.PushUserTrans();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.app_id = reader.uint32();
                    break;
                case 2:
                    message.room_id = reader.bytes();
                    break;
                case 3:
                    message.trans_idname = reader.bytes();
                    break;
                case 4:
                    message.trans_nickname = reader.bytes();
                    break;
                case 5:
                    message.trans_role = reader.uint32();
                    break;
                case 9:
                    message.trans_send_time = reader.int64();
                    break;
                case 10:
                    message.trans_channel = reader.bytes();
                    break;
                case 11:
                    if (!(message.trans_array && message.trans_array.length))
                        message.trans_array = [];
                    message.trans_array.push($root.liveroom_cs.StTransSimple.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return PushUserTrans;
    })();

    liveroom_cs.StTransSimple = (function() {

        /**
         * Properties of a StTransSimple.
         * @memberof liveroom_cs
         * @interface IStTransSimple
         * @property {Uint8Array|null} [trans_type] StTransSimple trans_type
         * @property {Uint8Array|null} [trans_data] StTransSimple trans_data
         * @property {number|null} [trans_seq] StTransSimple trans_seq
         */

        /**
         * Constructs a new StTransSimple.
         * @memberof liveroom_cs
         * @classdesc Represents a StTransSimple.
         * @implements IStTransSimple
         * @constructor
         * @param {liveroom_cs.IStTransSimple=} [properties] Properties to set
         */
        function StTransSimple(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StTransSimple trans_type.
         * @member {Uint8Array} trans_type
         * @memberof liveroom_cs.StTransSimple
         * @instance
         */
        StTransSimple.prototype.trans_type = $util.newBuffer([]);

        /**
         * StTransSimple trans_data.
         * @member {Uint8Array} trans_data
         * @memberof liveroom_cs.StTransSimple
         * @instance
         */
        StTransSimple.prototype.trans_data = $util.newBuffer([]);

        /**
         * StTransSimple trans_seq.
         * @member {number} trans_seq
         * @memberof liveroom_cs.StTransSimple
         * @instance
         */
        StTransSimple.prototype.trans_seq = 0;

        /**
         * Creates a new StTransSimple instance using the specified properties.
         * @function create
         * @memberof liveroom_cs.StTransSimple
         * @static
         * @param {liveroom_cs.IStTransSimple=} [properties] Properties to set
         * @returns {liveroom_cs.StTransSimple} StTransSimple instance
         */
        StTransSimple.create = function create(properties) {
            return new StTransSimple(properties);
        };

        /**
         * Encodes the specified StTransSimple message. Does not implicitly {@link liveroom_cs.StTransSimple.verify|verify} messages.
         * @function encode
         * @memberof liveroom_cs.StTransSimple
         * @static
         * @param {liveroom_cs.IStTransSimple} message StTransSimple message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StTransSimple.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.trans_type != null && Object.hasOwnProperty.call(message, "trans_type"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.trans_type);
            if (message.trans_data != null && Object.hasOwnProperty.call(message, "trans_data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.trans_data);
            if (message.trans_seq != null && Object.hasOwnProperty.call(message, "trans_seq"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.trans_seq);
            return writer;
        };

        /**
         * Decodes a StTransSimple message from the specified reader or buffer.
         * @function decode
         * @memberof liveroom_cs.StTransSimple
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {liveroom_cs.StTransSimple} StTransSimple
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StTransSimple.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.liveroom_cs.StTransSimple();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.trans_type = reader.bytes();
                    break;
                case 2:
                    message.trans_data = reader.bytes();
                    break;
                case 3:
                    message.trans_seq = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        return StTransSimple;
    })();

    return liveroom_cs;
})();

module.exports = $root;


/***/ }),

/***/ "./sdk/src/modules/retryHandler.ts":
/*!*****************************************!*\
  !*** ./sdk/src/modules/retryHandler.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TryHandler = void 0;
var TryHandler = /** @class */ (function () {
    function TryHandler(logger, stateCenter) {
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.RETRY_MAX_TIME = 300;
        this.RETRY_START_TIME_INTERVAL = 4;
        this.RETRY_CONTINUE_COUNT = 2;
        this.RETRY_MAX_TIME_INTERVAL = 32;
        this.retryTimer = null;
        this.maxTimer = null;
        this.retryStartTime = 0;
        this.retryActiveCount = 1;
        this.isOverTime = false;
    }
    //
    TryHandler.prototype.init = function (retryMaxTime, startTimeInterval, retryContinuteCount, maxTimeInterval) {
        this.invalid();
        this.stopMaxTime();
        this.isOverTime = false;
        if (typeof retryMaxTime == 'number' && retryMaxTime < 3600) {
            this.RETRY_MAX_TIME = retryMaxTime;
        }
        if (typeof startTimeInterval == 'number') {
            this.RETRY_START_TIME_INTERVAL = startTimeInterval;
        }
        if (typeof retryContinuteCount == 'number') {
            this.RETRY_CONTINUE_COUNT = retryContinuteCount;
        }
        if (typeof maxTimeInterval == 'number') {
            this.RETRY_MAX_TIME_INTERVAL = maxTimeInterval;
        }
    };
    //
    TryHandler.prototype.invalid = function () {
        this.retryTimer && clearTimeout(this.retryTimer);
        this.retryTimer = null;
        this.retryStartTime = 0;
        this.retryActiveCount = 1;
    };
    return TryHandler;
}());
exports.TryHandler = TryHandler;


/***/ }),

/***/ "./sdk/src/modules/retryRoomHandler.ts":
/*!*********************************************!*\
  !*** ./sdk/src/modules/retryRoomHandler.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1438104__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.RetryRoomHandler = void 0;
var retryHandler_1 = __nested_webpack_require_1438104__(/*! ./retryHandler */ "./sdk/src/modules/retryHandler.ts");
var zego_entity_1 = __nested_webpack_require_1438104__(/*! ../zego.entity */ "./sdk/src/zego.entity.ts");
var zego_action_1 = __nested_webpack_require_1438104__(/*! ../zego.action */ "./sdk/src/zego.action.ts");
var zego_externalError_1 = __nested_webpack_require_1438104__(/*! ../zego.externalError */ "./sdk/src/zego.externalError.ts");
var client_util_1 = __nested_webpack_require_1438104__(/*! ../../util/client-util */ "./sdk/util/client-util.ts");
var RetryRoomHandler = /** @class */ (function (_super) {
    __extends(RetryRoomHandler, _super);
    function RetryRoomHandler(logger, stateCenter, room) {
        var _this = _super.call(this, logger, stateCenter) || this;
        _this.logger = logger;
        _this.stateCenter = stateCenter;
        _this.room = room;
        // loginRoom 
        _this.loginRoomCallback = {};
        return _this;
    }
    RetryRoomHandler.prototype.renewLocalToken = function (token, remainTime) {
        this.token = token;
        this.room.token = this.token;
        var currentTime = new Date().getTime();
        var remainTimeResult = undefined;
        if (remainTime && typeof remainTime === 'number') {
            remainTimeResult = remainTime * 1000;
        }
        else if (token.substr(0, 2) === '03') {
            remainTimeResult = client_util_1.ClientUtil.decodeTokenExpire(token.substr(2)) * 1000 - currentTime;
        }
        remainTimeResult && this.roomHandler.resetTokenTimer(remainTimeResult - this.stateCenter.local_time_deviation);
        this.stateCenter.actionListener('_tokenRenewed', token, this.room.roomID);
    };
    //
    RetryRoomHandler.prototype.initRoom = function (roomHandler, roomID, token, user, server, serverBak, config) {
        this.roomHandler = roomHandler;
        this.roomID = roomID;
        this.renewLocalToken(token);
        this.user = user;
        this.server = server;
        this.serverBak = serverBak ? serverBak : server;
        this.config = config;
    };
    //
    RetryRoomHandler.prototype.active = function (isFirst) {
        var _this = this;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + ' retry call');
        this.roomHandler.setRunState(zego_entity_1.ENUM_RUN_STATE.trylogin);
        //service 
        if (this.room.isMulti && this.room.isDisConnect()) {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + ' service is disconnected, multi room stop retry');
            return;
        }
        //
        if (this.stateCenter.networkState == zego_entity_1.ENUM_NETWORK_STATE.offline) {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + ' network is broken, stop retry');
            return;
        }
        //,
        if (this.retryTimer) {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + ' has actived, ignore');
            return;
        }
        //
        if (this.isOverTime) {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + ' retry over time, stop retry');
            return;
        }
        //
        if (this.retryActiveCount == 1) {
            this.retryActiveInterval = Math.floor(Math.random() * (1 - this.RETRY_START_TIME_INTERVAL) + this.RETRY_START_TIME_INTERVAL);
        }
        else {
            var retryActiveInterval = Math.pow(2, Math.round(this.retryActiveCount / this.RETRY_CONTINUE_COUNT + 1));
            this.retryActiveInterval =
                retryActiveInterval > this.RETRY_MAX_TIME_INTERVAL ? this.RETRY_MAX_TIME_INTERVAL : retryActiveInterval;
        }
        this.retryTimer = setTimeout(function () {
            _this.roomHandler.login(_this.retryActiveCount % 2 == 1 ? _this.server : _this.serverBak, _this.roomID, _this.token, _this.user, _this.config, function (success) {
                _this.handleLoginFinish(success);
            }, function (err, isServerError) {
                _this.handleLoginFinish(false, err, isServerError);
            });
            _this.retryTimer && clearTimeout(_this.retryTimer);
            _this.retryTimer = null;
            _this.retryActiveCount++;
        }, isFirst ? 0 : this.retryActiveInterval * 1000);
    };
    //
    RetryRoomHandler.prototype.startMaxTime = function () {
        var _this = this;
        if (this.maxTimer) {
            return;
        }
        this.maxTimer = setTimeout(function () {
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + (" over max time " + _this.RETRY_MAX_TIME + "s, stop retry"));
            _this.isOverTime = true;
            //
            _this.roomHandler.resetRoom();
            _this.stopMaxTime();
            _this.invalid();
            _this.onactive(false, zego_externalError_1.errorCodeList.LOGIN_TIMEOUT);
            if (_this.loginRoomCallback.fail) {
                _this.loginRoomCallback.fail(zego_externalError_1.errorCodeList.LOGIN_TIMEOUT);
                _this.roomHandler.disconnectedHandle(zego_externalError_1.errorCodeList.LOGIN_TIMEOUT);
                _this.loginRoomCallback.fail = undefined;
            }
        }, this.RETRY_MAX_TIME * 1e3);
    };
    //
    RetryRoomHandler.prototype.stopMaxTime = function () {
        this.maxTimer && clearTimeout(this.maxTimer);
        this.maxTimer = null;
    };
    //
    RetryRoomHandler.prototype.onactive = function (success, error) { };
    //
    RetryRoomHandler.prototype.handleError = function (error, isServerError) {
        //3s
        if (this.RETRY_MAX_TIME < 3) {
            return false;
        }
        if (isServerError) {
            var stopErrorList = void 0, retryErrorList = void 0, resetErrorList = void 0;
            if (this.stateCenter.useNetAgent) {
                stopErrorList = ['202002', '205030', '205035', '50116', '50117', '50118'];
                retryErrorList = ['40001', '40100'];
                resetErrorList = ['201002', '30019'];
            }
            else {
                /*
                  sdk
                  const unsigned int kLiveRoomThirdTokenAuthError = 1000002002; //third token auth error
                  const unsigned int kLiveRoomBlackListErrcode = 1000005030; // 
                  const unsigned int kLiveRoomTokenBlackListErrcode = 1000005035; //token
                  */
                stopErrorList = [
                    '1000002002',
                    '1000005030',
                    '1000005035',
                    '1010',
                    '1011',
                    '1013',
                    '1014',
                    '1015',
                    '1016',
                    '1017',
                    '1018',
                    '1019',
                    '1020',
                    '1021',
                    '1023',
                ];
                retryErrorList = ['1100040001', '1100040100'];
            }
            var code = error.code + '';
            console.error('code ', code);
            if (this.stateCenter.useNetAgent) {
                if ((error.code >= 40001 && error.code <= 40100) || (error.code >= 50200 && error.code <= 50299) || (resetErrorList === null || resetErrorList === void 0 ? void 0 : resetErrorList.includes(code))) {
                    console.error('');
                    this.room.resetSessionInfo();
                    return true;
                }
            }
            if (stopErrorList.includes(code)) {
                return false;
            }
            else if (retryErrorList.includes(code)) {
                return true;
            }
            else if (this.room.lastRunState == zego_entity_1.ENUM_RUN_STATE.login) {
                //
                this.room.sessionID = '0';
                this.invalid();
                return true;
            }
            else {
                return false;
            }
        }
        else {
            return true;
        }
    };
    RetryRoomHandler.prototype.setLoginRoomCallback = function (success, fail) {
        this.loginRoomCallback.success = success;
        this.loginRoomCallback.fail = fail;
    };
    //
    RetryRoomHandler.prototype.handleLoginFinish = function (success, error, isServerError) {
        if (error) {
            //
            if (this.handleError(error, isServerError)) {
                !this.maxTimer && this.startMaxTime();
                this.active();
            }
            else {
                //
                this.roomHandler.resetRoom();
                this.stopMaxTime();
                this.invalid();
                this.onactive(success, error);
                if (this.loginRoomCallback.fail) {
                    this.loginRoomCallback.fail(error);
                    this.roomHandler.disconnectedHandle(error);
                    this.loginRoomCallback.fail = undefined;
                }
            }
        }
        else {
            //
            this.stopMaxTime();
            this.invalid();
            this.onactive(success, { code: 0, msg: '' });
            if (this.loginRoomCallback.success) {
                this.loginRoomCallback.success(success);
                this.loginRoomCallback.fail = undefined;
            }
        }
    };
    return RetryRoomHandler;
}(retryHandler_1.TryHandler));
exports.RetryRoomHandler = RetryRoomHandler;


/***/ }),

/***/ "./sdk/src/modules/roomHandler.ts":
/*!****************************************!*\
  !*** ./sdk/src/modules/roomHandler.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1448717__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RoomHandler = void 0;
var zego_entity_1 = __nested_webpack_require_1448717__(/*! ../zego.entity */ "./sdk/src/zego.entity.ts");
var client_util_1 = __nested_webpack_require_1448717__(/*! ../../util/client-util */ "./sdk/util/client-util.ts");
var zego_action_1 = __nested_webpack_require_1448717__(/*! ../zego.action */ "./sdk/src/zego.action.ts");
var zego_externalError_1 = __nested_webpack_require_1448717__(/*! ../zego.externalError */ "./sdk/src/zego.externalError.ts");
var zego_log_event_1 = __nested_webpack_require_1448717__(/*! ../zego.log.event */ "./sdk/src/zego.log.event.ts");
var RoomHandler = /** @class */ (function () {
    function RoomHandler(logger, stateCenter, dataReport, service, 
    // TODO: LiveRoomModules
    room, liveRoomHandler) {
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.dataReport = dataReport;
        this.service = service;
        this.room = room;
        this.liveRoomHandler = liveRoomHandler;
        this.tryLoginTimer = null;
        this.tryLoginCount = 0;
        this.tryLoginInterval = 10000;
        this.tokenTimer = null;
        this.beforeExpire = 30; // s
        /*
         *    "zb.rh.hlf": "ZegoClient.base.ROOM.handleLoginFail",
         */
        // 
        this.loginCallback = {};
    }
    RoomHandler.prototype.resetTokenTimer = function (interval) {
        var _this = this;
        interval = interval - 30 * 1000; // 
        interval = interval < 0 ? 0 : interval;
        interval = interval > 2147483648 ? 2147483648 : interval; // 2147483648,
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_RESETTOKEN_TIMER + '  call: ' + interval);
        if (this.tokenTimer) {
            clearTimeout(this.tokenTimer);
        }
        this.tokenTimer = setTimeout(function () {
            _this.stateCenter.actionListener('tokenWillExpire', _this.room.roomID);
            _this.stateCenter.actionListener('roomTokenWillExpire', _this.room.roomID);
        }, interval);
    };
    RoomHandler.prototype.stopTokenTimer = function () {
        this.tokenTimer && clearTimeout(this.tokenTimer);
        this.tokenTimer = null;
    };
    RoomHandler.prototype.setRunState = function (newRunState) {
        if (this.room.runState !== newRunState) {
            this.room.lastRunState = this.room.runState;
            this.room.runState = newRunState;
        }
    };
    RoomHandler.prototype.resetTryLogin = function () {
        this.tryLoginTimer && clearTimeout(this.tryLoginTimer);
        this.tryLoginTimer = null;
    };
    RoomHandler.prototype.resetRoom = function (isAll) {
        var _this = this;
        var _a;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_RESET_ROOM + ' call');
        if (this.stateCenter.roomModulesList.length > 1 && !isAll) {
            this.room.isMulti = true;
        }
        // 
        this.resetTryLogin();
        // 
        if (this.room.sessionID !== '0' &&
            this.room.runState !== zego_entity_1.ENUM_RUN_STATE.logout &&
            !this.room.isDisConnect()) {
            var callBack = function (msg) {
                _this.handleLogoutRsp(msg);
            };
            var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
            serviceHandler.logout(this.room, callBack, callBack);
        }
        // 
        this.setRunState(zego_entity_1.ENUM_RUN_STATE.logout);
        this.room.sessionID = '0';
        this.room.roomSessionID = '0';
        if (!this.room.isMulti) {
            this.stateCenter.userid = '';
            this.logger.setSessionInfo(this.stateCenter.appid, this.room.roomID, this.room.sessionID, this.stateCenter.idName, this.stateCenter.nickName, this.stateCenter.sdKVersion);
            this.stateCenter.useNetAgent ? (_a = this.liveRoomHandler) === null || _a === void 0 ? void 0 : _a.reset() : this.service.closeSocket();
        }
        this.resetRoomCallBack();
        this.stateCenter.roomModulesList = this.stateCenter.roomModulesList.filter(function (_room) { return _room !== _this.room; });
        var _room = this.stateCenter.roomModulesList[0];
        if (_room) {
            _room.isMulti = false;
            if (_room.runState !== zego_entity_1.ENUM_RUN_STATE.login && _room.roomTryHandler) {
                _room.roomTryHandler.startMaxTime();
                _room.roomTryHandler.active();
            }
        }
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_RESET_ROOM + ' call success');
    };
    //; ,,
    RoomHandler.prototype.resetRoomCallBack = function () { };
    //
    RoomHandler.prototype.loginSuccessCallBack = function (lastRunState, msg) { };
    RoomHandler.prototype.handlePushKickout = function (msg, isAll, isSwitch) {
        var _this = this;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_KICK_OUT + '  call ' + JSON.stringify(msg));
        if (!isSwitch && this.room.sessionID !== msg.header.session_id && this.room.sessionID !== msg.body.session_id) {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_KICK_OUT + ' session id wrong, ignore');
            return;
        }
        // logger start
        var reportSeq = zego_entity_1.getReportSeq();
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskKickout.event);
        this.dataReport.addMsgInfo(reportSeq, {
            user_id: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskKickout.user_id(this.stateCenter.idName),
        });
        var _kickoutErr = client_util_1.ClientUtil.getKickoutError(msg.body.reason || msg.body.kickout_reason, this.stateCenter.useNetAgent);
        this.dataReport.addMsgInfo(reportSeq, {
            error: _kickoutErr.code,
            message: _kickoutErr.message,
        });
        this.dataReport.uploadReport(reportSeq);
        // logger end
        var roomTryHandler = this.room.roomTryHandler;
        if (roomTryHandler) {
            roomTryHandler.onactive = function (success, err) {
                _this.disconnectedHandle(err);
                _this.stateCenter.actionListener('_kickout', err);
            };
            if (msg.body.need_relogin && msg.body.need_relogin == 1) {
                //
                this.room.sessionID = '0';
                roomTryHandler.startMaxTime();
                roomTryHandler.active();
            }
            else {
                // kickout
                this.setRunState(zego_entity_1.ENUM_RUN_STATE.logout);
                this.resetRoom(isAll);
                var extendedData = {};
                if (msg && msg.body.custom_reason) {
                    extendedData['custom_kickout_message'] = msg.body.custom_reason;
                    //@ts-ignore
                }
                else if (_kickoutErr.name && zego_externalError_1.errorCodeList[_kickoutErr.name]) {
                    //@ts-ignore
                    extendedData['custom_kickout_message'] =
                        //@ts-ignore
                        zego_externalError_1.errorCodeList[_kickoutErr.name].msg + '; kickout reason: ' + msg.body.reason || msg.body.kickout_reason;
                }
                // @ts-ignore
                if (_kickoutErr.name && zego_externalError_1.errorCodeList[_kickoutErr.name]) {
                    //@ts-ignore
                    this.disconnectedHandle(zego_externalError_1.errorCodeList[_kickoutErr.name], JSON.stringify(extendedData));
                }
                else {
                    this.disconnectedHandle(zego_externalError_1.errorCodeList.ROOM_INNER_ERROR, JSON.stringify(extendedData));
                }
                this.stateCenter.actionListener('_kickout', {
                    code: zego_externalError_1.errorCodeList.MANUAL_KICKOUT.code,
                    msg: zego_externalError_1.errorCodeList.MANUAL_KICKOUT.msg + msg.body.reason || msg.body.kickout_reason,
                });
            }
        }
        else {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_KICK_OUT + ' try handler no found');
        }
    };
    RoomHandler.prototype.handleHbLogout = function (err) {
        var _this = this;
        //
        var roomTryHandler = this.room.roomTryHandler;
        if (roomTryHandler) {
            roomTryHandler.onactive = function (success, error) {
                _this.disconnectedHandle(error);
            };
            //kLiveRoomRequiredReloginError = 1000002001;  kLiveRoomSessionIdError = 1000000152 
            if ([zego_externalError_1.errorCodeList.HEARTBEAT_TIMEOUT, zego_externalError_1.errorCodeList.SOCKET_CLOSE, zego_externalError_1.errorCodeList.TIMEOUT].includes(err) ||
                [105, 152, 2001].includes(err.code) ||
                err.msg.endsWith('1000002001') ||
                err.msg.endsWith('1000000152') ||
                err.msg.endsWith('1000000105')) {
                roomTryHandler.startMaxTime();
                roomTryHandler.active();
            }
            else {
                //
                roomTryHandler.stopMaxTime();
                roomTryHandler.invalid();
                //
                this.resetRoom();
                this.disconnectedHandle(err);
            }
        }
    };
    RoomHandler.prototype.onDisconnect = function (err) {
        var _this = this;
        this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_DISCONNECT + ' ' + err.msg);
        //logger start
        if (typeof err.code == 'string' && err.code === 'Error.Network') {
            this.dataReport.addMsgInfo(this.stateCenter.reportSeqList.relogin, {
                error: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReLoginRoom.error.ROOM_DISCONNECT.code,
                message: zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReLoginRoom.error.ROOM_DISCONNECT.msg,
            });
        }
        else if (typeof err.code == 'number') {
            var serverErr = void 0;
            if ((err.code < 2000000000 && err.code > 1000000000) || err.code < 1000000) {
                serverErr = client_util_1.ClientUtil.decodeServerError(err.code, err.msg);
            }
            else {
                serverErr = { code: err.code, message: err.msg };
            }
            serverErr &&
                this.dataReport.addMsgInfo(this.stateCenter.reportSeqList.relogin, {
                    error: serverErr.code,
                    message: serverErr.message,
                });
        }
        this.dataReport.uploadReport(this.stateCenter.reportSeqList.relogin);
        this.stateCenter.reportSeqList.relogin = 0;
        client_util_1.ClientUtil.unregisterCallback(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReLoginRoom.event, this.stateCenter.reportList);
        //logger end;
        //
        var roomTryHandler = this.room.roomTryHandler;
        if (roomTryHandler) {
            roomTryHandler.onactive = function (success, error) {
                if (error && error.code !== 0) {
                    _this.roomStateHandle('DISCONNECTED', error);
                }
                else {
                    _this.roomStateHandle('CONNECTED', error);
                }
            };
            roomTryHandler.startMaxTime();
            roomTryHandler.active();
        }
        else {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_DISCONNECT + ' try handler no found');
        }
    };
    RoomHandler.prototype.onConnecting = function (err) {
        this.roomStateHandle('CONNECTING', err);
    };
    RoomHandler.prototype.disconnectedHandle = function (error, extendedData) {
        if (error && error.code !== 0) {
            // , token
            this.stopTokenTimer();
            this.roomStateHandle('DISCONNECTED', error, extendedData);
        }
        else {
            this.roomStateHandle('CONNECTED', error, extendedData);
        }
    };
    RoomHandler.prototype.roomStateHandle = function (state, error, extendedData) {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_STATUS_CALLBACK + ' ' + state + ' ' + JSON.stringify(error));
        this.room.lastRoomState = this.room.roomState;
        this.room.roomState = state;
        if (this.room.roomState !== this.room.lastRoomState) {
            this.stateCenter.actionListener('_roomStateUpdate', this.room.roomID, state, error ? error.code : 0, extendedData);
            this.stateCenter.actionListener('roomStateUpdate', this.room.roomID, state, error ? error.code : 0, extendedData);
        }
    };
    //
    RoomHandler.prototype.login = function (server, roomid, token, user, config, success, error) {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + ' call:', roomid, token);
        !this.room.isMulti &&
            this.logger.setSessionInfo(this.stateCenter.appid, roomid, '', user.userID, '', this.stateCenter.sdKVersion);
        if (config) {
            config.userUpdate &&
                typeof config.userUpdate == 'boolean' &&
                (this.stateCenter.userStateUpdate = config.userUpdate);
            config.maxMemberCount &&
                typeof config.maxMemberCount == 'number' &&
                // (this.stateCenter.maxMemberCount = config.maxMemberCount);
                // 
                (this.room.maxMemberCount = config.maxMemberCount);
        }
        if (!this.stateCenter.configOK) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + ' init sdk wrong');
            error(zego_externalError_1.errorCodeList.INIT);
            return;
        }
        this.room.runState !== zego_entity_1.ENUM_RUN_STATE.trylogin && this.setRunState(zego_entity_1.ENUM_RUN_STATE.trylogin);
        this.room.roomID = roomid;
        this.room.token = token;
        this.room.thirdToken = token;
        this.stateCenter.idName = user.userID;
        this.stateCenter.nickName = user.userName || user.userID;
        // 
        this.loginCallback.success = success;
        this.loginCallback.fail = error;
        if (this.stateCenter.reportSeqList.login === 0) {
            var reportSeq = zego_entity_1.getReportSeq();
            this.stateCenter.reportSeqList.relogin = reportSeq;
            this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReLoginRoom.event);
            this.dataReport.addMsgInfo(reportSeq, {
                server: server,
            });
            client_util_1.ClientUtil.logReportCallback(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReLoginRoom.event, this.dataReport, reportSeq, this.stateCenter.reportList);
        }
        this.resetTryLogin();
        this.onConnecting({ code: 0, msg: '' });
        this.tryLogin(server);
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGIN_ROOM + ' call success');
    };
    /*
     *    "zb.rh.tl": "ZegoClient.base.ROOM.tryLogin",
     */
    RoomHandler.prototype.tryLogin = function (server) {
        var _this = this;
        var _a;
        if (this.room.runState !== zego_entity_1.ENUM_RUN_STATE.trylogin) {
            this.logger.error('zb.rh.tl state error');
            return;
        }
        var logAction = this.stateCenter.reportSeqList.login !== 0
            ? zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.event
            : zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReLoginRoom.event;
        //
        if (this.stateCenter.useNetAgent) {
            if (this.room.isMulti && this.room.isDisConnect()) {
                this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + ' liveroom is not connected');
                return;
            }
            var callBack = function (msg, cmdSeq) {
                _this.handleLoginRsp(msg, cmdSeq);
            };
            if ((_a = this.liveRoomHandler) === null || _a === void 0 ? void 0 : _a.isUaConnect()) {
                this.liveRoomHandler.login(this.room, callBack, callBack);
            }
            else {
                // TODO
                this.tryLoginTimer = setTimeout(function () {
                    //no response,login fail
                    _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + ' over time no response, login timeout');
                    _this.loginCallback.fail && _this.loginCallback.fail(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.LOGIN_TIMEOUT);
                }, this.tryLoginInterval);
                this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + ' ua is not connected');
            }
            return;
        }
        // websocket
        if (this.service.isDisConnect()) {
            try {
                // null
                this.service.closeSocket();
                // websocket
                this.logger.debug(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + ' new websocket');
                if (client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)) {
                    this.tryLoginCount > 1 &&
                        client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)(zego_entity_1.REPORT_ACTION.eventEnd, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.create_socket.event);
                    client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)(zego_entity_1.REPORT_ACTION.eventStart, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.create_socket.event);
                    client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)(zego_entity_1.REPORT_ACTION.addEventMsg, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.create_socket.event, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.create_socket.server('server'), server);
                }
                this.service.createSocket(server);
                this.service.openHandler(function () {
                    _this.openHandler();
                });
                this.service.closeHandler(function (err) {
                    _this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + ' close ' + JSON.stringify(err.code ? err.code : err));
                    _this.service.closeSocket();
                    _this.closeHandler(err);
                });
                this.service.errorHandler(function (err) {
                    _this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + ' error ' + JSON.stringify(err.code ? err.code : err));
                    _this.service.closeSocket();
                    _this.closeHandler(err);
                });
            }
            catch (e) {
                this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + '  websocket err:' + JSON.stringify(e));
            }
        }
        else {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + ' use current websocket and sent login');
            client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList) &&
                client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)(zego_entity_1.REPORT_ACTION.eventStart, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.liveroom_login.event);
            var callBack = function (msg, cmdSeq) {
                _this.handleLoginRsp(msg, cmdSeq);
            };
            this.service.login(this.room, callBack, callBack);
        }
        //set timeout
        this.tryLoginTimer = setTimeout(function () {
            //no response,login fail
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + ' over time no response, login timeout');
            _this.loginCallback.fail && _this.loginCallback.fail(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.LOGIN_TIMEOUT);
        }, this.tryLoginInterval);
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_TRY_LOGIN + ' call success');
    };
    /*
     *    "zb.rh.oh": "ZegoClient.base.ROOM.openHandler",
     */
    RoomHandler.prototype.openHandler = function () {
        var _this = this;
        // websocket
        // onmessage
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_OPEN_HANDLER + ' websocket.onpen call');
        var logAction = this.stateCenter.reportSeqList.login !== 0
            ? zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.event
            : zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReLoginRoom.event;
        client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList) &&
            client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)(zego_entity_1.REPORT_ACTION.eventEndWithMsgInfo, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.create_socket.event, { try_cnt: this.tryLoginCount });
        this.service.onPush();
        client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList) &&
            client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)(zego_entity_1.REPORT_ACTION.eventStart, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.liveroom_login.event);
        var callBack = function (msg, cmdSeq) {
            _this.handleLoginRsp(msg, cmdSeq);
        };
        this.service.login(this.room, callBack, callBack);
    };
    /*
     *    "zb.rh.hlr": "ZegoClient.base.ROOM.handleLoginRsp",
     */
    RoomHandler.prototype.handleLoginRsp = function (msg, cmdSeq) {
        var logAction = this.stateCenter.reportSeqList.login !== 0
            ? zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.event
            : zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReLoginRoom.event;
        client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList) &&
            client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)(zego_entity_1.REPORT_ACTION.eventEndWithMsgInfo, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.liveroom_login.event);
        if (this.room.runState !== zego_entity_1.ENUM_RUN_STATE.trylogin) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_HANDLE_LOGINRSP + ' state error');
            return;
        }
        else if (!msg.header || !msg.body) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_HANDLE_LOGINRSP + ' ' + JSON.stringify(msg));
            this.handleLoginFail(msg);
        }
        else if (msg.header.seq !== cmdSeq && this.room.isMulti == false) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_HANDLE_LOGINRSP + ' in wrong seq, local=', cmdSeq + '', ',recv=', msg.header.seq);
            return;
        }
        else if (msg.body.err_code !== 0) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_HANDLE_LOGINRSP + ' server error=', msg.body.err_code);
            this.handleLoginFail(msg);
        }
        else {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_HANDLE_LOGINRSP + ' call success.');
            this.handleLoginSuccess(msg);
        }
    };
    // 
    RoomHandler.prototype.handleLoginFail = function (msg) {
        this.resetTryLogin();
        // const logAction =
        //     this.stateCenter.reportSeqList.login !== 0
        //         ? ZegoRTMLogEvent.kZegoTaskLoginRoom.event
        //         : ZegoRTMLogEvent.kZegoTaskReLoginRoom.event;
        // ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList) &&
        //     ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)(
        //         REPORT_ACTION.addEventMsg,
        //         ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.liveroom_login.event,
        //         ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.liveroom_login.respond_info('respond_info'),
        //         msg,
        //     );
        var err = zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.INNER_ERROR;
        if (!msg.header || !msg.body) {
            msg.code && msg.msg && (err = msg);
        }
        else {
            err = client_util_1.ClientUtil.getServerError(msg.body.err_code);
        }
        this.loginCallback.fail && this.loginCallback.fail(err, true);
    };
    // 
    RoomHandler.prototype.handleLoginSuccess = function (msg) {
        var _a;
        var loginInfo = {};
        //enter login
        var lastRunState = this.room.lastRunState;
        this.setRunState(zego_entity_1.ENUM_RUN_STATE.login);
        this.stateCenter.userid = msg.body.user_id;
        this.room.sessionID = msg.body.session_id;
        this.room.roomSessionID = msg.body.room_session_id;
        this.room.lvKey = msg.body.lv_key;
        if (msg.body.ret_timestamp && this.room.token.substr(0, 2) === '03') {
            var currentTime = new Date().getTime();
            var local_time_deviation = currentTime - msg.body.ret_timestamp;
            this.stateCenter.local_time_deviation = local_time_deviation < 5000 ? 0 : local_time_deviation;
            var remainTime = ((_a = msg === null || msg === void 0 ? void 0 : msg.body) === null || _a === void 0 ? void 0 : _a.token_remain_time) ? msg.body.token_remain_time * 1000
                : client_util_1.ClientUtil.decodeTokenExpire(this.room.token.substr(2)) * 1000 - currentTime;
            this.resetTokenTimer(remainTime - this.stateCenter.local_time_deviation);
        }
        //set log
        !this.room.isMulti &&
            this.logger.setSessionInfo(this.stateCenter.appid, this.room.roomID, this.room.sessionID, this.stateCenter.idName, this.stateCenter.nickName, this.stateCenter.sdKVersion);
        if (!this.stateCenter.useNetAgent) {
            if (msg.body.config_info) {
                var logLevel = this.stateCenter.settingConfig.getSetting('remote_log_level', true) || msg.body.config_info.log_level;
                this.logger.setRemoteLogLevel(logLevel);
                loginInfo['log_level'] = logLevel;
                if (msg.body.config_info.log_url != '' && !this.logger.url) {
                    this.logger.setLogServer(msg.body.config_info.log_url);
                    loginInfo['log_url'] = msg.body.config_info.log_url;
                }
            }
            //get if testEnvironment
            if (msg.body.cluster_env && msg.body.cluster_env === 1) {
                this.stateCenter.testEnvironment = true;
                loginInfo['test_environment'] = 'true';
                !this.stateCenter.debugCustom && (this.stateCenter.debug = true);
            }
        }
        var logAction = this.stateCenter.reportSeqList.login !== 0
            ? zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.event
            : zego_log_event_1.ZegoRTMLogEvent.kZegoTaskReLoginRoom.event;
        client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList) &&
            client_util_1.ClientUtil.actionSuccessCallback(logAction, this.stateCenter.reportList)(zego_entity_1.REPORT_ACTION.addEventMsg, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.liveroom_login.event, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.subEvent.liveroom_login.respond_info('respond_info'), loginInfo);
        //stop trylogin
        this.resetTryLogin();
        this.loginSuccessCallBack(lastRunState, msg);
        this.loginCallback.success && this.loginCallback.success(true);
        this.roomStateHandle('CONNECTED', { code: 0, msg: '' });
    };
    RoomHandler.prototype.closeHandler = function (e) {
        this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ROOM_CLOSEHANDLER + ' room websocket close ' + JSON.stringify(e.code ? e.code : e));
        if (this.room.runState !== zego_entity_1.ENUM_RUN_STATE.logout) {
            if (this.room.runState === zego_entity_1.ENUM_RUN_STATE.trylogin) {
                //trylogin --> trylogin
                this.resetTryLogin();
                this.loginCallback.fail &&
                    this.loginCallback.fail(e.code == 1006 ? zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.LOGIN_TIMEOUT : e);
            }
            else if (this.room.runState === zego_entity_1.ENUM_RUN_STATE.login) {
                //login --> trylogin
                this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_CLOSEHANDLER + ' is called because of network broken');
                //this.setRunState (ENUM_RUN_STATE.trylogin);
                this.resetTryLogin();
                this.onDisconnect(zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLoginRoom.error.NETWORK_BROKEN);
            }
        }
        else {
            //* --> logout
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_CLOSEHANDLER + ' onclose logout flow call websocket.close');
        }
    };
    RoomHandler.prototype.logout = function (isAll) {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGOUT + ' call');
        if (this.room.runState === zego_entity_1.ENUM_RUN_STATE.logout) {
            this.logger.warn('zb.rh.lo at logout');
            return;
        }
        this.resetRoom(isAll);
        this.roomStateHandle('DISCONNECTED', { code: 0, msg: '' });
        // ,token
        this.stopTokenTimer();
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGOUT + ' call success');
    };
    RoomHandler.prototype.handleLogoutRsp = function (msg) {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.ROOM_LOGOUT + ' result=', msg.body && msg.body.err_code ? msg.body.err_code : '-1');
    };
    return RoomHandler;
}());
exports.RoomHandler = RoomHandler;


/***/ }),

/***/ "./sdk/src/modules/switchCmd.ts":
/*!**************************************!*\
  !*** ./sdk/src/modules/switchCmd.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveroomProMap = void 0;
exports.LiveroomProMap = {
    '/lr/login_room_rsp': 'LoginRoomRsp',
    '/lr/logout_room_rsp': 'LogoutRoomRsp',
    '/sw/push_kickout': 'PushKickout',
    '/sw/push': 'PushReq',
    '/sw/merge_push': 'CmdMergePushReq',
    '/lr/room/hb_rsp': 'HbRsp',
    '/lr/userlist/userlist_rsp': 'UserlistRsp',
    '/lr/stream/add_rsp': 'StreamAddRsp',
    '/lr/stream/delete_rsp': 'StreamDeleteRsp',
    '/lr/stream/update_rsp': 'StreamUpdateRsp',
    '/lr/stream/list_rsp': 'StreamListRsp',
    '/lr/push/stream_add': 'PushStream',
    '/lr/push/stream_delete': 'PushStream',
    '/lr/push/stream_update': 'PushStream',
    '/lr/signal/liverequest_rsp': 'SignalLiveRsp',
    '/lr/signal/liverresult_rsp': 'SignalLiveResulRsp',
    '/lr/signal/liveinvite_rsp': 'SignalLiveInviteRsp',
    '/lr/signal/livestop_rsp': 'SignalLiveStopRsp',
    '/lr/signal/livescustom_rsp': 'SignalLiveCustomRsp',
    '/lr/im/chat_rsp': 'ImChatRsp',
    '/lr/room/enter_rsp': 'EnterRsp',
    '/lr/room/quit_rsp': 'QuitRsp',
    '/lr/trans/trans_rsp': 'TransRsp',
    '/lr/trans/transfetch_rsp': 'TransFetchRsp',
    '/lr/bigim/chat_rsp': 'BigimChatRsp',
    '/lr/relay_rsp': 'RelayRsp',
    '/lr/token/renew_token_rsp': 'RenewTokenRsp',
    '/lr/push/user_updated': 'PushUserInfoUpdated',
    '/lr/push/user_token_expire': 'PushUserTokenExpire',
    '/lr/push/im_chat': 'PushImChat',
    '/lr/push/bigim_chat': 'PushBigImChat',
    '/lr/push/trans': 'PushTrans',
    '/lr/push/user_kickout': 'PushUserKickout',
    '/lr/push/user_logreport': 'PushUserLogReport',
    '/lr/push/usertrans': 'PushUserTrans'
};


/***/ }),

/***/ "./sdk/src/modules/userHandler.ts":
/*!****************************************!*\
  !*** ./sdk/src/modules/userHandler.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1480682__) {

"use strict";

var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserHandler = void 0;
var zego_entity_1 = __nested_webpack_require_1480682__(/*! ../zego.entity */ "./sdk/src/zego.entity.ts");
var client_util_1 = __nested_webpack_require_1480682__(/*! ../../util/client-util */ "./sdk/util/client-util.ts");
var zego_action_1 = __nested_webpack_require_1480682__(/*! ../zego.action */ "./sdk/src/zego.action.ts");
var zego_log_event_1 = __nested_webpack_require_1480682__(/*! ../zego.log.event */ "./sdk/src/zego.log.event.ts");
var UserHandler = /** @class */ (function () {
    function UserHandler(logger, stateCenter, dataReport, service, liveRoomHandler, room) {
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.dataReport = dataReport;
        this.service = service;
        this.liveRoomHandler = liveRoomHandler;
        this.room = room;
        this.userQuerying = false;
        this.userTempList = [];
        this.userSeq = 0;
        this.minUserSeq = 0;
        this.userList = [];
        this.userSeqMergeMap = null;
        this.userListInterval = 30000;
        this.userListMergeInterval = 5000;
        this.anchor_info = {
            anchor_id: '',
            anchor_id_name: '',
            anchor_nick_name: '',
        };
    }
    // , 
    UserHandler.prototype.loginRsp = function (msg, lastRunState) {
        this.anchor_info = msg.body.anchor_info || this.anchor_info;
        this.userListInterval = msg.body.userlist_interval || this.userListInterval;
        this.userListMergeInterval = msg.body.userlist_merge_timeout || this.userListMergeInterval;
        //
        //handle anchor info
        if (msg.body.anchor_info) {
            this.stateCenter.actionListener('getAnchorInfo', msg.body.anchor_info.anchor_id_name, msg.body.anchor_info.anchor_nick_name);
            this.stateCenter.actionListener('_getAnchorInfo', msg.body.anchor_info.anchor_id_name, msg.body.anchor_info.anchor_nick_name);
        }
        if (msg.body.online_count) {
            this.stateCenter.actionListener('roomOnlineUserCountUpdate', this.room.roomID, msg.body.online_count);
        }
        //handle userStateUpdate
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_LOGIN_RSP + '  userStateUpdate ' + this.stateCenter.userStateUpdate);
        if (this.stateCenter.userStateUpdate) {
            this.fetchUserList(lastRunState);
        }
    };
    UserHandler.prototype.patchUserList = function (msg) {
        var _this = this;
        if (msg.body.server_user_seq !== this.userSeq && this.stateCenter.userStateUpdate && !this.userSeqMergeMap) {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_HB_PATCH +
                ' call update user ' +
                this.userSeq +
                ' server ' +
                msg.body.server_user_seq);
            // TODO
            if (!this.userSeqMergeMap) {
                this.userSeqMergeMap = {};
            }
            this.userSeqMergeTimer && clearTimeout(this.userSeqMergeTimer);
            this.userSeqMergeTimer = setTimeout(function () {
                _this.handleMergeTimeout();
            }, this.userListMergeInterval);
        }
        this.minUserSeq = msg.body.server_user_seq;
        //get online count
        if (msg.body.online_count != undefined && msg.body.online_count != 0) {
            this.stateCenter.actionListener('roomOnlineUserCountUpdate', this.room.roomID, msg.body.online_count);
        }
    };
    UserHandler.prototype.resetUserHandler = function () {
        this.userQuerying = false;
        this.lastUserQueryTime = 0;
        this.userTempList = [];
        this.userSeq = 0;
        this.minUserSeq = 0;
        this.userList = undefined;
        this.userSeqMergeMap = {};
        this.userSeqMergeTimer = undefined;
        this.userQueryTimer = undefined;
        this.userListInterval = 30000;
        this.userListMergeInterval = 5000;
        this.anchor_info = {
            anchor_id: '',
            anchor_id_name: '',
            anchor_nick_name: '',
        };
    };
    // user
    UserHandler.prototype.fetchUserList = function (lastRunState) {
        if (this.userQuerying) {
            this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.USER_FETCH_USER + ' is already querying');
            return;
        }
        this.userQuerying = true;
        this.userTempList = [];
        this.fetchUserListWithPage(0, lastRunState ? lastRunState : 0);
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_FETCH_USER + ' the first time call');
    };
    //user list
    UserHandler.prototype.fetchUserListWithPage = function (userIndex, lastRunState) {
        var _this = this;
        var callBack = function (msg) {
            _this.handleFetchUserListRsp(msg, lastRunState);
        };
        var body = {
            user_index: userIndex,
            sort_type: 0,
        };
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.fetchUserList(body, callBack, callBack, this.room);
    };
    UserHandler.prototype.handleFetchUserListRsp = function (msg, lastRunState) {
        var _this = this;
        if (msg.body && msg.body.err_code != 0) {
            this.userQuerying = false;
            this.lastUserQueryTime = Date.now() + this.userListInterval;
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_FETCH_USER_RSP + ' fetch error ' + msg.body.err_code);
            return;
        }
        if (!msg.header || !msg.body) {
            this.userQuerying = false;
            this.lastUserQueryTime = Date.now() + this.userListInterval;
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_FETCH_USER_RSP + ' fetch error ' + msg);
            return;
        }
        if (!this.stateCenter.userStateUpdate) {
            return;
        }
        this.userTempList = __spreadArrays(this.userTempList, msg.body.user_baseinfos);
        var currentIndex = msg.body.ret_user_index;
        var serverIndex = msg.body.server_user_index;
        if (currentIndex != serverIndex && currentIndex.ne(serverIndex)) {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_FETCH_USER_RSP + ' fetch another page');
            this.fetchUserListWithPage(currentIndex + 1, lastRunState);
            return;
        }
        this.userSeq = msg.body.server_user_seq;
        var user_list = [];
        var _user_list = [];
        for (var i = 0; i < this.userTempList.length; i++) {
            var user_info = {
                userID: this.userTempList[i].id_name,
                userName: this.userTempList[i].nick_name,
                role: this.userTempList[i].role,
            };
            user_list.push(user_info);
            _user_list.push({
                idName: this.userTempList[i].id_name,
                nickName: this.userTempList[i].nick_name,
                role: this.userTempList[i].role,
            });
        }
        this.stateCenter.actionListener('_getTotalUserList', this.room.roomID, _user_list);
        if (lastRunState == zego_entity_1.ENUM_RUN_STATE.login) {
            this.userList &&
                client_util_1.ClientUtil.mergeUserList(this.logger, this.userList, user_list, function (addUserList, delUserList) {
                    addUserList.length !== 0 && _this.onUserStateUpdate(_this.room.roomID, 'ADD', addUserList);
                    delUserList.length !== 0 && _this.onUserStateUpdate(_this.room.roomID, 'DELETE', delUserList);
                });
            this.userList = user_list;
        }
        else {
            this.userList = user_list;
            user_list.length !== 0 && this.onUserStateUpdate(this.room.roomID, 'ADD', user_list);
        }
        this.userQuerying = false;
        this.lastUserQueryTime = Date.now() + this.userListInterval;
        this.userTempList = [];
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_FETCH_USER_RSP + ' call success user_list ' + user_list + ' count ' + user_list.length);
    };
    UserHandler.prototype.handlePushUserStateUpdateMsg = function (msg) {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_USER_PUSH + ' call');
        if (!this.stateCenter.userStateUpdate) {
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_USER_PUSH + ' userStateUpdate is false');
            return;
        }
        if (this.userSeq === msg.body.user_list_seq) {
            this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.USER_USER_PUSH + ' user_list_seq is the same with local seq');
            return;
        }
        // merge user or fetchUserList
        console.error('handlePushUserStateUpdateMsg', this.userSeq, msg.body.user_actions.length, msg.body.user_list_seq);
        if (this.userSeq + msg.body.user_actions.length !== msg.body.user_list_seq) {
            this.mergeUserByUserSeq(msg.body.user_list_seq, msg.body.user_actions);
            return;
        }
        this.userSeq = msg.body.user_list_seq;
        var user_list = [];
        var addAction, delAction;
        if (this.stateCenter.type == 'PRIVATE') {
            addAction = 0;
            delAction = 1;
            for (var i = 0; i < msg.body.user_actions.length; i++) {
                var user_info = {
                    action: msg.body.user_actions[i].action,
                    idName: msg.body.user_actions[i].user_id,
                    nickName: msg.body.user_actions[i].user_name,
                    role: msg.body.user_actions[i].role,
                    loginTime: msg.body.user_actions[i].login_time,
                };
                user_list.push(user_info);
            }
        }
        else {
            addAction = 1;
            delAction = 2;
            for (var i = 0; i < msg.body.user_actions.length; i++) {
                var user_info = {
                    action: msg.body.user_actions[i].Action,
                    idName: msg.body.user_actions[i].IdName,
                    nickName: msg.body.user_actions[i].NickName,
                    role: msg.body.user_actions[i].Role,
                    loginTime: msg.body.user_actions[i].LoginTime,
                };
                user_list.push(user_info);
            }
            this.stateCenter.actionListener('_userStateUpdate', msg.body.room_id, user_list);
        }
        var addUserList = [];
        var delUserList = [];
        user_list.forEach(function (user) {
            if (user.action == addAction) {
                addUserList.push({ userID: user.idName, userName: user.nickName, role: user.role });
            }
            else if (user.action == delAction) {
                delUserList.push({ userID: user.idName, userName: user.nickName, role: user.role });
            }
        });
        this.userList &&
            (this.userList = this.userList
                .concat(addUserList)
                .filter(function (user) { return !delUserList.some(function (delUser) { return delUser.userID == user.userID; }); }));
        addUserList.length !== 0 &&
            this.onUserStateUpdate(msg.body.room_id || msg.body.room_pushheader.room_id, 'ADD', addUserList);
        delUserList.length !== 0 &&
            this.onUserStateUpdate(msg.body.room_id || msg.body.room_pushheader.room_id, 'DELETE', delUserList);
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_USER_PUSH + ' call success');
    };
    UserHandler.prototype.onUserStateUpdate = function (roomID, updateType, userList) {
        var _this = this;
        var reportSeq = zego_entity_1.getReportSeq();
        this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomGetUserUpdateInfo.event);
        var callUserList = userList.filter(function (val) { return val.userID !== _this.stateCenter.idName; });
        if (callUserList.length == 0)
            return;
        if (this.stateCenter.type !== 'PRIVATE') {
            callUserList = callUserList.map(function (item) { return ({
                userID: item.userID,
                userName: item.userName,
            }); });
        }
        this.stateCenter.actionListener('roomUserUpdate', roomID, updateType, callUserList);
        this.dataReport.addMsgInfo(reportSeq, {
            user_update_type: updateType == 'ADD'
                ? zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomGetUserUpdateInfo.user_update_type('added')
                : zego_log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomGetUserUpdateInfo.user_update_type('deleted'),
        });
        this.dataReport.uploadReport(reportSeq);
    };
    UserHandler.prototype.mergeUserByUserSeq = function (userSeq, userList) {
        var _this = this;
        if (!this.userSeqMergeMap) {
            this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.USER_MERGE_SEQ + ' new merge userlist ' + this.userSeq + ' server ' + userSeq);
            this.userSeqMergeMap = {};
            //  userSeq 
            this.userSeqMergeTimer && clearTimeout(this.userSeqMergeTimer);
            this.userSeqMergeTimer = setTimeout(function () {
                _this.handleMergeTimeout();
            }, this.userListMergeInterval);
        }
        this.userSeqMergeMap[userSeq] = userList;
        this.logger.warn(zego_action_1.ZEGO_RTM_ACTION.USER_MERGE_SEQ +
            '  merge userlist ' +
            this.userSeq +
            ' server ' +
            userSeq +
            ' userlist ' +
            userList.length);
    };
    UserHandler.prototype.mergeUser = function (userSeqList) {
        var _this = this;
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_MERGE + ' merge userlist ' + this.userSeq + ' userSeqList ' + userSeqList.join(','));
        this.userSeq = userSeqList[userSeqList.length - 1];
        this.lastUserQueryTime = Date.now() + this.userListInterval;
        // userSeq
        var userMap = {};
        userSeqList.forEach(function (seq) {
            _this.userSeqMergeMap &&
                _this.userSeqMergeMap[seq].forEach(function (item) {
                    userMap[item.IdName] = item;
                });
        });
        this.userSeqMergeMap = null;
        var userList = Object.values(userMap).map(function (item) {
            var user = {
                action: item.Action,
                idName: item.IdName,
                nickName: item.NickName,
                role: item.Role,
                loginTime: item.LoginTime ? String(item.LoginTime) : '',
            };
            return user;
        });
        // loginTime 
        userList.sort(function (a, b) { return a.loginTime.localeCompare(b.loginTime); });
        var addUserList = [];
        var delUserList = [];
        userList.forEach(function (user) {
            if (user.action == 1) {
                addUserList.push({ userID: user.idName, userName: user.nickName, role: user.role });
            }
            else if (user.action == 2) {
                delUserList.push({ userID: user.idName, userName: user.nickName, role: user.role });
            }
        });
        this.userList =
            this.userList &&
                this.userList
                    .concat(addUserList)
                    .filter(function (user) { return !delUserList.some(function (delUser) { return delUser.userID == user.userID; }); });
        addUserList.length !== 0 && this.onUserStateUpdate(this.room.roomID, 'ADD', addUserList);
        delUserList.length !== 0 && this.onUserStateUpdate(this.room.roomID, 'DELETE', delUserList);
        this.stateCenter.actionListener('_userStateUpdate', this.room.roomID, userList);
    };
    UserHandler.prototype.handleMergeTimeout = function () {
        var _this = this;
        var userSeqList = Object.keys(this.userSeqMergeMap)
            .map(function (key) { return +key; })
            .sort(function (a, b) { return a - b; });
        // userSeq 
        if (userSeqList[userSeqList.length - 1] - userSeqList[0] + 1 === userSeqList.length ||
            userSeqList[userSeqList.length - 1] >= this.minUserSeq) {
            this.mergeUser(userSeqList);
        }
        else {
            this.userSeqMergeMap = null;
            // 
            var wait = this.lastUserQueryTime - Date.now();
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_MERGE_TIMEOUT +
                '  fetch merge userlist ' +
                this.userSeq +
                ' userSeqList ' +
                userSeqList.join(',') +
                ' wait ' +
                wait);
            if (wait > 0) {
                this.userQueryTimer && clearTimeout(this.userQueryTimer);
                this.userQueryTimer = setTimeout(function () {
                    _this.fetchUserList();
                }, wait);
            }
            else {
                this.fetchUserList();
            }
        }
    };
    UserHandler.prototype.loginPrivateRsp = function (msg) {
        this.logger.info(zego_action_1.ZEGO_RTM_ACTION.USER_FETCH_USER, ' userStateUpdate ' + this.stateCenter.userStateUpdate);
        if (this.stateCenter.userStateUpdate) {
            this.fetchUserList();
        }
    };
    return UserHandler;
}());
exports.UserHandler = UserHandler;


/***/ }),

/***/ "./sdk/src/service.private.ts":
/*!************************************!*\
  !*** ./sdk/src/service.private.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1498526__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveRoomPrivateService = void 0;
var socket_util_1 = __nested_webpack_require_1498526__(/*! ../util/socket-util */ "./sdk/util/socket-util.ts");
var zego_entity_1 = __nested_webpack_require_1498526__(/*! ./zego.entity */ "./sdk/src/zego.entity.ts");
var service_1 = __nested_webpack_require_1498526__(/*! ./service */ "./sdk/src/service.ts");
var LiveRoomPrivateService = /** @class */ (function (_super) {
    __extends(LiveRoomPrivateService, _super);
    function LiveRoomPrivateService(stateCenter, logger, rtm) {
        var _this = _super.call(this, stateCenter, logger, rtm) || this;
        _this.stateCenter = stateCenter;
        _this.logger = logger;
        _this.service = new socket_util_1.ZegoSocketService(_this.stateCenter.ENV);
        _this.cmdSeq = 0;
        _this.responseRouters = {};
        return _this;
    }
    LiveRoomPrivateService.prototype.checkResponse = function (msg) {
        if (msg.header.app_id !== this.stateCenter.appid ||
            msg.header.user_uid !== this.stateCenter.userid ||
            this.stateCenter.priModules.hallRunState !== zego_entity_1.ENUM_RUN_STATE.login) {
            return true;
        }
        else {
            return false;
        }
    };
    //  start
    LiveRoomPrivateService.prototype.handleHallKickout = function (msg) { };
    LiveRoomPrivateService.prototype.handlePushKickout = function (msg) { };
    LiveRoomPrivateService.prototype.handlePushCustomMsg = function (msg) { };
    LiveRoomPrivateService.prototype.handlePushRoomMsg = function (msg) { };
    LiveRoomPrivateService.prototype.handlePushUserStateUpdateMsg = function (msg) { };
    LiveRoomPrivateService.prototype.handlePushMergeMsg = function (msg) { };
    LiveRoomPrivateService.prototype.handlePushTransMsg = function (msg) { };
    LiveRoomPrivateService.prototype.handleBigImMsgRsp = function (msg) { };
    LiveRoomPrivateService.prototype.handlePushSignalMsg = function (msg) { };
    //  end
    /*
     *    "zb.sc.htr": "ZegoExpressEngine.base.SocketCenter.handleTransRsp",
     *
     */
    LiveRoomPrivateService.prototype.closeHandler = function (handler) {
        this.service.closeHandler(handler);
    };
    LiveRoomPrivateService.prototype.openHandler = function (handler) {
        this.service.openHandler(handler);
    };
    LiveRoomPrivateService.prototype.errorHandler = function (handler) {
        this.service.errorHandler(handler);
    };
    LiveRoomPrivateService.prototype.getHeader = function (cmd) {
        return {
            cmd: cmd,
            seq: ++this.cmdSeq,
            timestamp: Math.ceil(new Date().getTime() / 1000) + '',
            app_id: this.stateCenter.appid,
            user_uid: this.stateCenter.userid || '0',
            session_id: this.stateCenter.priModules.sessionID || '0',
        };
    };
    LiveRoomPrivateService.prototype.startCheck = function () {
        this.service.startCheck();
    };
    LiveRoomPrivateService.prototype.stopCheck = function () {
        this.service.stopCheck();
    };
    LiveRoomPrivateService.prototype.isDisConnect = function () {
        return !this.service || this.service.isDisConnect();
    };
    LiveRoomPrivateService.prototype.closeSocket = function () {
        this.service.closeSocket();
    };
    LiveRoomPrivateService.prototype.on = function (cmd, callBack) {
        this.responseRouters[cmd] = callBack;
    };
    return LiveRoomPrivateService;
}(service_1.LiveRoomService));
exports.LiveRoomPrivateService = LiveRoomPrivateService;


/***/ }),

/***/ "./sdk/src/service.ts":
/*!****************************!*\
  !*** ./sdk/src/service.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1502939__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveRoomService = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
var zego_entity_1 = __nested_webpack_require_1502939__(/*! ./zego.entity */ "./sdk/src/zego.entity.ts");
var socket_util_1 = __nested_webpack_require_1502939__(/*! ../util/socket-util */ "./sdk/util/socket-util.ts");
var zego_action_1 = __nested_webpack_require_1502939__(/*! ./zego.action */ "./sdk/src/zego.action.ts");
var zego_externalError_1 = __nested_webpack_require_1502939__(/*! ./zego.externalError */ "./sdk/src/zego.externalError.ts");
var LiveRoomService = /** @class */ (function () {
    function LiveRoomService(stateCenter, logger, rtm) {
        this.stateCenter = stateCenter;
        this.logger = logger;
        this.rtm = rtm;
        this.service = new socket_util_1.ZegoSocketService(this.stateCenter.ENV);
        this.cmdSeq = 0;
        this.responseRouters = {};
    }
    LiveRoomService.prototype.checkResponse = function (msg) {
        if (msg.header.appid !== this.stateCenter.appid || msg.header.user_id !== this.stateCenter.userid) {
            return true;
        }
        else {
            return false;
        }
    };
    /*
     *    "zb.sc.hscmr: "ZegoExpressEngine.base.SocketCenter.handleSendCommandMsgRsp"
     */
    LiveRoomService.prototype.handleSendCommandMsgRsp = function (msg) {
        var _this = this;
        var sendDataNode = this.service.sendCommandMap[msg.header.seq];
        if (sendDataNode != null) {
            var sendData_1 = sendDataNode._data;
            delete this.service.sendCommandMap[msg.header.seq];
            this.service.sendCommandList.remove(sendDataNode);
            if (msg.body.err_code === 0) {
                setTimeout(function () {
                    sendData_1 && sendData_1.success != null && sendData_1.success(msg, _this.cmdSeq);
                }, 0);
            }
            else {
                setTimeout(function () {
                    sendData_1 && sendData_1.error != null && sendData_1.error(msg, _this.cmdSeq);
                }, 0);
            }
        }
    };
    // server push
    LiveRoomService.prototype.onPush = function () {
        var _this = this;
        this.service.onMessage = function (msg) {
            if (msg instanceof ArrayBuffer) {
                _this.stateCenter.actionListener('_protobufResponse', msg);
                return;
            }
            if (!msg.header) {
                _this.logger.error(zego_action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + " msg type error ");
                return;
            }
            if (msg.body.err_code !== 0) {
                msg.body.err_message &&
                    _this.logger.error(zego_action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + " cmd=" + msg.header.cmd + ", err_code=" + msg.body.err_code + ", err_message=" + msg.body.err_message + " ");
            }
            else {
                _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + " cmd=" + msg.header.cmd + ", msg=" + JSON.stringify(msg) + " ");
            }
            if (['login', 'logout'].indexOf(msg.header.cmd) > -1) {
                // 
                _this.handleSendCommandMsgRsp(msg);
                return;
            }
            if (_this.checkResponse(msg)) {
                _this.logger.error(zego_action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + '  check session fail.');
                return;
            }
            _this.logger.info(zego_action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + " cmd=" + msg.header.cmd + ",function=" + !!_this.responseRouters[msg.header.cmd]);
            // 
            _this.handleSendCommandMsgRsp(msg);
            // push
            if (_this.responseRouters[msg.header.cmd]) {
                _this.responseRouters[msg.header.cmd](msg, _this.cmdSeq);
            }
        };
    };
    //  start
    LiveRoomService.prototype.handlePushKickout = function (msg) {
        var _a, _b, _c, _d;
        if (((_a = msg === null || msg === void 0 ? void 0 : msg.body) === null || _a === void 0 ? void 0 : _a.protocol) === undefined || ((_b = msg === null || msg === void 0 ? void 0 : msg.body) === null || _b === void 0 ? void 0 : _b.protocol) === 1) {
            __spreadArrays(this.stateCenter.roomModulesList).forEach(function (room) { return room.roomHandler.handlePushKickout(msg, true); });
        }
        else {
            var roomID_1 = (_c = msg === null || msg === void 0 ? void 0 : msg.header) === null || _c === void 0 ? void 0 : _c.room_id;
            var room = this.stateCenter.roomModulesList.find(function (roomModules) { return roomModules.roomID == roomID_1; });
            if (!room) {
                this.logger.error(zego_action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + ' room no found ignore ' + JSON.stringify((_d = msg.header) === null || _d === void 0 ? void 0 : _d.room_id));
                return;
            }
            room.roomHandler.handlePushKickout(msg);
        }
    };
    LiveRoomService.prototype.handlePushCustomMsg = function (msg) { };
    LiveRoomService.prototype.handlePushRoomMsg = function (msg) { };
    LiveRoomService.prototype.handlePushUserStateUpdateMsg = function (msg) {
        var _a;
        var roomID = (_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id;
        var room = this.stateCenter.roomModulesList.find(function (roomModules) { return roomModules.roomID == roomID; });
        if (!room) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + ' room no found ignore ' + JSON.stringify(msg));
            return;
        }
        room.userHandler.handlePushUserStateUpdateMsg(msg);
    };
    LiveRoomService.prototype.handlePushMergeMsg = function (msg) { };
    LiveRoomService.prototype.handlePushTransMsg = function (msg) { };
    LiveRoomService.prototype.handleBigImMsgRsp = function (msg) { };
    LiveRoomService.prototype.handlePushSignalMsg = function (msg) { };
    LiveRoomService.prototype.handlePushTokenExpire = function (msg) {
        // TODO: 
        this.stateCenter.actionListener('_tokenExpired', msg);
    };
    //  end
    /*
     *    "zb.sc.htr": "ZegoExpressEngine.base.SocketCenter.handleTransRsp",
     *
     */
    LiveRoomService.prototype.closeHandler = function (handler) {
        this.service.closeHandler(handler);
    };
    LiveRoomService.prototype.openHandler = function (handler) {
        this.service.openHandler(handler);
    };
    LiveRoomService.prototype.errorHandler = function (handler) {
        this.service.errorHandler(handler);
    };
    LiveRoomService.prototype.getHeader = function (cmd, sessionID, roomID, roomSessionID) {
        return {
            Protocol: zego_entity_1.ROOMVERSION === 'V1' ? 'req' : 'req_v2',
            cmd: cmd,
            appid: this.stateCenter.appid,
            seq: ++this.cmdSeq,
            user_id: this.stateCenter.userid,
            session_id: sessionID || '',
            room_id: roomID || '',
            room_session_id: roomSessionID || '',
            biz_version: this.stateCenter.bizVersion || '',
        };
    };
    LiveRoomService.prototype.startCheck = function () {
        this.service.startCheck();
    };
    LiveRoomService.prototype.stopCheck = function () {
        this.service.stopCheck();
    };
    LiveRoomService.prototype.isDisConnect = function () {
        return !this.service || this.service.isDisConnect();
    };
    LiveRoomService.prototype.createSocket = function (server) {
        var _this = this;
        this.service.createSocket(server);
        this.responseRouters = __assign(__assign({}, this.responseRouters), { push_kickout: function (msg) {
                _this.handlePushKickout(msg);
            }, push_custommsg: function (msg) {
                _this.handlePushCustomMsg(msg);
            }, push_im_chat: function (msg) {
                _this.handlePushRoomMsg(msg);
            }, push_userlist_update: function (msg) {
                _this.handlePushUserStateUpdateMsg(msg);
            }, push_merge_message: function (msg) {
                _this.handlePushMergeMsg(msg);
            }, push_trans: function (msg) {
                _this.handlePushTransMsg(msg);
            }, push_signal: function (msg) {
                _this.handlePushSignalMsg(msg);
            }, push_token_expire: function (msg) {
                _this.handlePushTokenExpire(msg);
            } });
    };
    LiveRoomService.prototype.closeSocket = function () {
        this.service.closeSocket();
    };
    LiveRoomService.prototype.sendMessage = function (cmd, body, suc, err, theHeader, customRoom) {
        var _a, _b, _c;
        if (!this.service.isDisConnect()) {
            var roomID = (customRoom === null || customRoom === void 0 ? void 0 : customRoom.roomID) ? customRoom.roomID : (_a = this.stateCenter.roomModulesList[0]) === null || _a === void 0 ? void 0 : _a.roomID;
            var roomSessionID = (customRoom === null || customRoom === void 0 ? void 0 : customRoom.roomSessionID) ? customRoom.roomSessionID
                : (_b = this.stateCenter.roomModulesList[0]) === null || _b === void 0 ? void 0 : _b.roomSessionID;
            var sessionID = (customRoom === null || customRoom === void 0 ? void 0 : customRoom.sessionID) ? customRoom.sessionID
                : (_c = this.stateCenter.roomModulesList[0]) === null || _c === void 0 ? void 0 : _c.sessionID;
            var header = theHeader || this.getHeader(cmd, sessionID, roomID, roomSessionID);
            this.logger.info(zego_action_1.ZEGO_RTM_ACTION.SERVICE_SEND +
                ' sendMsg:' +
                JSON.stringify({
                    header: header,
                    body: body,
                }));
            return this.service.sendMessage(header, body, suc, err);
        }
        else {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.SERVICE_SEND + ' socket is disconnect');
            err(zego_externalError_1.errorCodeList.SOCKET_CLOSE);
            return 0;
        }
    };
    LiveRoomService.prototype.on = function (cmd, callBack) {
        this.responseRouters[cmd] = callBack;
    };
    LiveRoomService.prototype.login = function (room, suc, err) {
        var header = this.getHeader(room.isMulti ? 'enter' : 'login', room.sessionID, room.roomID, room.roomSessionID);
        var body = {
            id_name: this.stateCenter.idName,
            nick_name: this.stateCenter.nickName,
            role: this.stateCenter.role,
            token: room.token,
            version: this.stateCenter.sdKVersion,
            room_name: room.roomID,
            user_state_flag: this.stateCenter.userStateUpdate ? 1 : 0,
            room_create_flag: this.stateCenter.roomCreateFlag,
            client_type: this.stateCenter.ENV === 0 ? zego_entity_1.E_CLIENT_TYPE.ClientType_Webrtc : zego_entity_1.E_CLIENT_TYPE.ClientType_SmallProgram,
            third_token: room.thirdToken,
            user_count_limit: room.maxMemberCount,
            relate_service: this.stateCenter.relateService.join() || '',
            login_logic: this.stateCenter.isMultiRoom ? 3 : 1,
            proto_format: this.stateCenter.protoFormat,
        };
        return this.sendMessage('', body, suc, err, header);
    };
    LiveRoomService.prototype.logout = function (room, suc, err) {
        var cmd = room.isMulti ? 'quit' : 'logout';
        var body = {
            reserve: 0,
        };
        if (cmd == 'logout') {
            body.login_logic = this.stateCenter.isMultiRoom ? 3 : 1;
        }
        return this.sendMessage(cmd, body, suc, err, undefined, {
            sessionID: room.sessionID,
            roomID: room.roomID,
            roomSessionID: room.roomSessionID,
        });
    };
    LiveRoomService.prototype.heartBeat = function (suc, err, room) {
        var body = {
            reserve: 0,
        };
        return this.sendMessage('hb', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.fetchUserList = function (body, suc, err, room) {
        return this.sendMessage('user_list', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.fetchUserListV2 = function (body, suc, err, room) {
        return this.sendMessage('user_list_v2', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.fetchReliableMessage = function (body, suc, err, room) {
        return this.sendMessage('trans_fetch', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.sendReliableMessage = function (body, suc, err, room) {
        return this.sendMessage('trans', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.sendRoomMsg = function (body, suc, err, room) {
        return this.sendMessage('im_chat', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.sendCustomCommand = function (body, suc, err, room) {
        return this.sendMessage('custommsg', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.sendBigRoomMessage = function (body, suc, err, room) {
        return this.sendMessage('bigim_chat', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.sendRelayMessage = function (body, suc, err, room) {
        return this.sendMessage('relay', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.sendSignalCmd = function (body, suc, err, room) {
        return this.sendMessage('signal', body, suc, err, undefined, room);
    };
    LiveRoomService.prototype.sendPB = function (msg) {
        if (this.service.isDisConnect() || this.stateCenter.networkState == zego_entity_1.ENUM_NETWORK_STATE.offline) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_PB + ' socket is disconnected');
            return false;
        }
        return this.service.sendPB(msg);
    };
    return LiveRoomService;
}());
exports.LiveRoomService = LiveRoomService;


/***/ }),

/***/ "./sdk/src/setting.config.ts":
/*!***********************************!*\
  !*** ./sdk/src/setting.config.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ZegoSettingConfig = void 0;
var ZegoSettingConfig = /** @class */ (function () {
    function ZegoSettingConfig() {
        this.defaultSetting = {
            remote_log_level: 'info',
        };
        this.requestList = {};
        this.setting = JSON.parse(JSON.stringify(this.defaultSetting));
    }
    ZegoSettingConfig.getInstance = function () {
        if (!ZegoSettingConfig.instance) {
            ZegoSettingConfig.instance = new ZegoSettingConfig();
        }
        return ZegoSettingConfig.instance;
    };
    ZegoSettingConfig.prototype.setSetting = function (settingFile, changeItems) {
        var isDynamic = Array.isArray(changeItems) && changeItems.length > 0;
        for (var settingGroup in settingFile) {
            if (typeof settingFile[settingGroup]['ctrlmode'] === 'number' && [1, 2].includes(settingFile[settingGroup]['ctrlmode'])) {
                this.setting[settingGroup] = settingFile[settingGroup];
                this.setting[settingGroup + '_ctrlmode'] = settingFile[settingGroup]['ctrlmode'];
            }
            else {
                for (var settingItem in settingFile[settingGroup]) {
                    //  _ctrlmode  _ctrlmode 0 1 2 
                    if (!settingItem.endsWith('_ctrlmode')) {
                        if (isDynamic && changeItems.indexOf(settingItem) == -1) {
                            continue;
                        }
                        var _mode = settingFile[settingGroup][settingItem + '_ctrlmode'];
                        if (_mode === 1 || _mode === 2) {
                            this.setting[settingItem] = settingFile[settingGroup][settingItem];
                        }
                        else {
                            this.defaultSetting[settingItem] &&
                                (this.setting[settingItem] = this.defaultSetting[settingItem]);
                        }
                        typeof _mode === 'number' &&
                            (this.setting[settingItem + '_ctrlmode'] =
                                settingFile[settingGroup][settingItem + '_ctrlmode']);
                    }
                }
            }
        }
    };
    ZegoSettingConfig.prototype.getSetting = function (key, force) {
        if (force === void 0) { force = false; }
        if (force) {
            if (this.setting[key + '_ctrlmode'] == 2) {
                return this.setting[key];
            }
            else {
                return undefined;
            }
        }
        return this.setting[key];
    };
    return ZegoSettingConfig;
}());
exports.ZegoSettingConfig = ZegoSettingConfig;


/***/ }),

/***/ "./sdk/src/stateCenter.ts":
/*!********************************!*\
  !*** ./sdk/src/stateCenter.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1520876__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StateCenter = void 0;
var zego_entity_1 = __nested_webpack_require_1520876__(/*! ./zego.entity */ "./sdk/src/zego.entity.ts");
var zego_action_1 = __nested_webpack_require_1520876__(/*! ./zego.action */ "./sdk/src/zego.action.ts");
var zego_log_event_1 = __nested_webpack_require_1520876__(/*! ./zego.log.event */ "./sdk/src/zego.log.event.ts");
var StateCenter = /** @class */ (function () {
    function StateCenter(logger, dataReport) {
        this.logger = logger;
        this.dataReport = dataReport;
        this._debug = false;
        this.appConfigFetched = false;
        this._testEnvironment = false;
        this._env = 0;
        //
        this.type = 'PUBLIC';
        this.debugCustom = false;
        this.configOK = false;
        this.role = 2;
        this.relateService = [];
        this.maxMemberCount = 0;
        this.roomCreateFlag = 1;
        this.local_time_deviation = 0;
        this.callbackList = {};
        //
        this.listenerList = {
            roomUserUpdate: [],
            roomOnlineUserCountUpdate: [],
            getAnchorInfo: [],
            _getAnchorInfo: [],
            IMRecvCustomCommand: [],
            IMRecvBroadcastMessage: [],
            recvReliableMessage: [],
            roomExtraInfoUpdate: [],
            IMRecvBarrageMessage: [],
            recvJoinLiveRequest: [],
            recvInviteJoinLiveRequest: [],
            recvEndJoinLiveCommand: [],
            roomLoginResponse: [],
            _roomLogin: [],
            _appConfigRsp: [],
            HBResponse: [],
            roomStateUpdate: [],
            _roomStateUpdate: [],
            _getTotalUserList: [],
            _userStateUpdate: [],
            _recvBigRoomMessage: [],
            _recvRoomMsg: [],
            _kickout: [],
            tokenWillExpire: [],
            _tokenExpired: [],
            // private
            hallStateUpdate: [],
            _hallStateUpdate: [],
            roomTokenWillExpire: [],
            _tokenRenewed: [],
            _protobufResponse: [],
            _cloudSettingNotify: [],
            _settingCanFetch: [],
        };
        // log event
        this.reportList = {};
        this.reportSeqList = {
            login: 0,
            relogin: 0,
        };
        //
        this.networkState = zego_entity_1.ENUM_NETWORK_STATE.offline;
        this.roomRetryTime = 300;
        this.roomModulesList = [];
        this.isMultiRoom = false;
        this.setMultiRoom = false;
        // 
        this.protoFormat = 'json';
        this.settingFetched = false;
        this.useNetAgent = true;
        this._sdkVersion = 'unknown';
    }
    Object.defineProperty(StateCenter.prototype, "debug", {
        get: function () {
            return this._debug;
        },
        set: function (enable) {
            this._debug = enable;
            zego_entity_1.LoggerStateCenter.getInstance().debug = enable;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StateCenter.prototype, "testEnvironment", {
        get: function () {
            return this._testEnvironment;
        },
        set: function (env) {
            this._testEnvironment = env;
            zego_entity_1.LoggerStateCenter.getInstance().testEnvironment = env;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StateCenter.prototype, "ENV", {
        get: function () {
            return this._env;
        },
        set: function (env) {
            this._env = env;
            zego_entity_1.LoggerStateCenter.getInstance().ENV = env;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StateCenter.prototype, "roomid", {
        // idNameroomid  serverTimeOffset SDK
        get: function () {
            if (this.roomModulesList[0]) {
                return this.roomModulesList[0].roomID;
            }
            return '';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StateCenter.prototype, "serverTimeOffset", {
        get: function () {
            if (this.roomModulesList[0]) {
                return this.roomModulesList[0].messageHandler.serverTimeOffset;
            }
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    //requestId
    StateCenter.prototype.getRequestId = function () {
        return this.idName + '-' + zego_entity_1.getSeq();
    };
    StateCenter.prototype.actionListener = function (listener) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.listenerList[listener]) {
            var reportSeq = zego_entity_1.getReportSeq();
            this.dataReport.newReport(reportSeq, zego_log_event_1.ZegoRTMLogEvent.kZegoListener.event);
            this.dataReport.addMsgInfo(reportSeq, {
                listener: listener,
                params: args,
            });
            this.dataReport.uploadReport(reportSeq);
        }
        this.listenerList[listener] &&
            this.listenerList[listener].forEach(function (func) {
                try {
                    // setTimeout(() => {
                    func.apply(void 0, args);
                    // }, 0);
                }
                catch (error) {
                    _this.logger.error(zego_action_1.ZEGO_RTM_ACTION.STATE_ACTION + ' ', listener, ' ', JSON.stringify(error));
                }
            });
    };
    StateCenter.prototype.onListener = function (event, callBack) {
        if (!this.listenerList[event]) {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ON_LISTENER + ' event ' + event + ' no found');
            return false;
        }
        if (typeof callBack !== 'function') {
            this.logger.error(zego_action_1.ZEGO_RTM_ACTION.ON_LISTENER + ' listener callBack must be funciton');
            return false;
        }
        this.listenerList[event].indexOf(callBack) == -1 && this.listenerList[event].push(callBack);
        return true;
    };
    Object.defineProperty(StateCenter.prototype, "sdKVersion", {
        get: function () {
            return this._sdkVersion;
        },
        set: function (version) {
            this._sdkVersion = version;
        },
        enumerable: false,
        configurable: true
    });
    return StateCenter;
}());
exports.StateCenter = StateCenter;


/***/ }),

/***/ "./sdk/src/zego.action.ts":
/*!********************************!*\
  !*** ./sdk/src/zego.action.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ZEGO_RTM_ACTION = void 0;
// import * as fs from 'fs';
// import * as path from 'path';
//****** sdk************//
var ZEGO_RTM_ACTION;
(function (ZEGO_RTM_ACTION) {
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_CONSTRUCTOR"] = "zm.0";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_BIND_WINDOW_LISTENER"] = "zm.wl";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_SET_LOG_CONFIG"] = "zm.slf";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_SET_DEBUG_VERBOSE"] = "zm.sdv";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_LOGIN_ROOM"] = "zm.lg";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_LOGOUT_ROOM"] = "zm.lo";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_FETCH_APP_CONFIG"] = "zm.fac";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_CREATENETAGENT"] = "zm.cna";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_GETSTOREAPPCONFIG"] = "zm.gsac";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_SET_CLOUD_SETTING_URLS"] = "zm.scsu";
    // ZEGOEXPRESSWEBRTM_SEND_CUSTOM = 'zm.scc', // 
    // ZEGOEXPRESSWEBRTM_SEND_BCM = 'zm.sbcm', // 
    // ZEGOEXPRESSWEBRTM_SEND_RLM = 'zm.srlm', // 
    // ZEGOEXPRESSWEBRTM_SEND_BRM = 'zm.sbrm', // 
    // ZEGOEXPRESSWEBRTM_SEND_RAM = 'zm.sram', // relay
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_ON"] = "zm.on";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_OFF"] = "zm.off";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_RENEWTOKEN"] = "zm.rntk";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_RESETTOKENTIMER"] = "zm.rstt";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_ENABLE_MULTI_ROOM"] = "zm.emr";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_SEND_PB"] = "zm.spb";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_GET_HEADER"] = "zm.gh";
    ZEGO_RTM_ACTION["ROOM_LOGIN_ROOM"] = "zm.rm.lg";
    ZEGO_RTM_ACTION["ROOM_TRY_LOGIN"] = "zm.rm.tl";
    ZEGO_RTM_ACTION["ROOM_OPEN_HANDLER"] = "zm.rm.op";
    ZEGO_RTM_ACTION["ROOM_HANDLE_LOGINRSP"] = "zm.rm.lgr";
    ZEGO_RTM_ACTION["ROOM_CLOSEHANDLER"] = "zm.rm.clh";
    ZEGO_RTM_ACTION["ROOM_LOGOUT"] = "zm.rm.lo";
    ZEGO_RTM_ACTION["ROOM_RESET_ROOM"] = "zm.rm.rr";
    ZEGO_RTM_ACTION["ROOM_DISCONNECT"] = "zm.rm.dcn";
    ZEGO_RTM_ACTION["ROOM_KICK_OUT"] = "zm.rm.kco";
    ZEGO_RTM_ACTION["ROOM_STATUS_CALLBACK"] = "zm.rm.scb";
    ZEGO_RTM_ACTION["ROOM_RESETTOKEN_TIMER"] = "zm.rm.rst";
    ZEGO_RTM_ACTION["HEARTBEAT_START"] = "zm.hb.st";
    ZEGO_RTM_ACTION["HEARTBEAT_HEARTBEAT_RSP"] = "zm.hb.rsp";
    ZEGO_RTM_ACTION["HEARTBEAT_RESET"] = "zm.hb.rst";
    ZEGO_RTM_ACTION["SERVICE_PUSH"] = "zm.sv.ps";
    ZEGO_RTM_ACTION["SERVICE_SEND"] = "zm.sv.sd";
    ZEGO_RTM_ACTION["USER_LOGIN_RSP"] = "zm.us.lgr";
    ZEGO_RTM_ACTION["USER_FETCH_USER"] = "zm.us.ftu";
    ZEGO_RTM_ACTION["USER_FETCH_USER_RSP"] = "zm.us.urp";
    ZEGO_RTM_ACTION["USER_USER_PUSH"] = "zm.us.uph";
    ZEGO_RTM_ACTION["USER_MERGE_SEQ"] = "zm.us.mg";
    ZEGO_RTM_ACTION["USER_MERGE_TIMEOUT"] = "zm.us.mto";
    ZEGO_RTM_ACTION["USER_MERGE"] = "zm.us.mg";
    ZEGO_RTM_ACTION["USER_HB_PATCH"] = "zm.us.pt";
    // MESSAGE_SEND_RELIABLE = 'zm.msg.sdr', // 
    // MESSAGE_FETCH_RELIABLE = 'zm.msg.frm', // 
    // MESSAGE_RELIABLE_RSP = 'zm.msg.rlr', // 
    // MESSAGE_RELIABLE_PUSH = 'zm.msg.rps', // push
    // MESSAGE_SEND_ROOM_MSG = 'zm.msg.srm', // 
    // MESSAGE_SEND_CUSTOM_MSG = 'zm.msg.scm', // 
    // MESSAGE_SEND_BIG_MSG = 'zm.msg.sbm', // 
    // MESSAGE_BIG_MSG_PUSH = 'zm.msg.bps', // 
    // MESSAGE_SEND_RELAY_MSG = 'zm.msg.slm', // relay
    // LIVE_SEND_SIGNAL = 'zm.lv.ssg', // signal
    // LIVE_RESPOND_JOIN_LIVE = 'zm.lv.rjl', // 
    // LIVE_PUSH_SIGNAL = 'zm.lv.pss', // push
    ZEGO_RTM_ACTION["STATE_ACTION"] = "zm.st.at";
    ZEGO_RTM_ACTION["ON_LISTENER"] = "ON_LISTENER";
    ZEGO_RTM_ACTION["LIVEROOMHANDLER_SENDMESSAGE"] = "zm.lrh.sm";
    ZEGO_RTM_ACTION["LIVEROOMHANDLER_PUSHUSERUPDATE"] = "zm.lrh.puu";
    ZEGO_RTM_ACTION["LIVEROOMHANDLER_PUSHKICKOUT"] = "zm.lrh.pk";
    ZEGO_RTM_ACTION["LIVEROOMHANDLER_GETSTREAMLIST"] = "zm.lrh.gs";
    ZEGO_RTM_ACTION["LIVEROOMHANDLER_HANDLEDISCONNECTED"] = "zm.lrh.hd";
    ZEGO_RTM_ACTION["LIVEROOMHANDLER_HANDLEBROKEN"] = "zm.lrh.hb";
    ZEGO_RTM_ACTION["LIVEROOMHANDLER_HANDLECONNECTED"] = "zm.lrh.hc";
})(ZEGO_RTM_ACTION = exports.ZEGO_RTM_ACTION || (exports.ZEGO_RTM_ACTION = {}));
// const _path = path.resolve(__dirname, 'zego.action.ts');
// fs.readFile(_path, 'utf8', (err, data) => {
//     if (err) {
//         console.error(err);
//     } else {
//         const actionArr: Array<string> = [];
//         const reg = /([A-Z])\w+ = '(.*)'.*\/\/([\u4e00-\u9fa5_a-zA-Z0-9]+)/g;
//         data.replace(reg, (target, p, key, value, _content): any => {
//             console;
//             actionArr.push(`${key} : ${value}`);
//         });
//         fs.writeFile(path.resolve(__dirname, '../../doc/action.log'), actionArr.join('\r'), 'utf8', err => {
//             console.log(err);
//         });
//     }
// });


/***/ }),

/***/ "./sdk/src/zego.config.ts":
/*!********************************!*\
  !*** ./sdk/src/zego.config.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.STORE_SECRET = exports.BIZ_TYPE = exports.PROTO_VER = exports.CRYPT_VERSION = exports.SDK_CONN_TYPE = exports.ROOM_BASIC = exports.INIT = exports.CLOUD_SETTING = void 0;
exports.CLOUD_SETTING = {
    product: 'Web_SDK',
    URL: [
        'https://cloud-setting-api.zego.im/cloud-setting/get',
        'https://cloud-setting-api.zegocloud.com/cloud-setting/get',
    ],
    POLLING_FREQ: 60 * 5,
    ONLINE: false,
};
exports.INIT = 'init';
exports.ROOM_BASIC = 'room';
var SDK_CONN_TYPE = 2;
exports.SDK_CONN_TYPE = SDK_CONN_TYPE;
var CRYPT_VERSION = 1;
exports.CRYPT_VERSION = CRYPT_VERSION;
var PROTO_VER = 0x00020000;
exports.PROTO_VER = PROTO_VER;
var BIZ_TYPE = 0;
exports.BIZ_TYPE = BIZ_TYPE;
var STORE_SECRET = '0c9e6e0f8c0a8f4e';
exports.STORE_SECRET = STORE_SECRET;


/***/ }),

/***/ "./sdk/src/zego.entity.ts":
/*!********************************!*\
  !*** ./sdk/src/zego.entity.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1534003__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.createZegoWebSocket = exports.LoggerStateCenter = exports.ZegoDataReport = exports.ZegoLogger = exports.MODULE_TIPS = exports.LinkedList = exports.ListNode = exports.getReportSeq = exports.getSeq = exports.REPORT_ACTION = exports.E_CLIENT_TYPE = exports.SERVER_ERROR_CODE = exports.ENUM_STREAM_UPDATE_CMD = exports.MINIUM_HEARTBEAT_INTERVAL = exports.NetType = exports.ENUM_NETWORK_STATE = exports.ENUM_RUN_STATE = exports.MAX_MIX_TASK_ID_LENGTH = exports.MAX_ROOM_ID_LENGTH = exports.MAX_USER_NAME_LENGTH = exports.MAX_USER_ID_LENGTH = exports.MAX_STREAM_ID_LENGTH = exports.MAX_TRY_HEARTBEAT_COUNT = exports.SEND_MSG_TIMEOUT = exports.SEND_MSG_RESET = exports.MAX_TRY_CONNECT_COUNT = exports.ENUM_CONNECT_STATE = exports.ENUM_SCREEM_RESOLUTION_TYPE = exports.ENUM_RESOLUTION_TYPE = exports.ENUM_SIGNAL_STATE = exports.TermType = exports.ERROR_CODES = exports.ENUM_REMOTE_TYPE = exports.LOG_LEVEL = exports.ENUM_LOG_LEVEL = exports.ROOMVERSION = exports.PROTO_VERSION = void 0;
exports.PROTO_VERSION = "1.12.0";
exports.ROOMVERSION = "V1";
var ENUM_LOG_LEVEL;
(function (ENUM_LOG_LEVEL) {
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["debug"] = 0] = "debug";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["info"] = 1] = "info";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["warn"] = 2] = "warn";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["error"] = 3] = "error";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["report"] = 99] = "report";
    ENUM_LOG_LEVEL[ENUM_LOG_LEVEL["disable"] = 100] = "disable";
})(ENUM_LOG_LEVEL = exports.ENUM_LOG_LEVEL || (exports.ENUM_LOG_LEVEL = {}));
exports.LOG_LEVEL = {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3,
    report: 99,
    disable: 100,
};
var ENUM_REMOTE_TYPE;
(function (ENUM_REMOTE_TYPE) {
    ENUM_REMOTE_TYPE[ENUM_REMOTE_TYPE["disable"] = 0] = "disable";
    ENUM_REMOTE_TYPE[ENUM_REMOTE_TYPE["websocket"] = 1] = "websocket";
    ENUM_REMOTE_TYPE[ENUM_REMOTE_TYPE["https"] = 2] = "https";
})(ENUM_REMOTE_TYPE = exports.ENUM_REMOTE_TYPE || (exports.ENUM_REMOTE_TYPE = {}));
exports.ERROR_CODES = {
    ROOM_SESSION_ID_ERR: 1000000152,
};
var TermType;
(function (TermType) {
    TermType[TermType["TT_NONE"] = 0] = "TT_NONE";
    TermType[TermType["TT_PC"] = 1] = "TT_PC";
    TermType[TermType["TT_IOS"] = 2] = "TT_IOS";
    TermType[TermType["TT_ANDROID"] = 3] = "TT_ANDROID";
    TermType[TermType["TT_MAC"] = 4] = "TT_MAC";
    TermType[TermType["TT_LINUX"] = 5] = "TT_LINUX";
    TermType[TermType["TT_WEB"] = 6] = "TT_WEB";
    TermType[TermType["TT_MINIPROGRAM"] = 7] = "TT_MINIPROGRAM";
    TermType[TermType["TT_UNKNOWN"] = 32] = "TT_UNKNOWN";
})(TermType = exports.TermType || (exports.TermType = {}));
var ENUM_SIGNAL_STATE;
(function (ENUM_SIGNAL_STATE) {
    ENUM_SIGNAL_STATE[ENUM_SIGNAL_STATE["disconnected"] = 0] = "disconnected";
    ENUM_SIGNAL_STATE[ENUM_SIGNAL_STATE["connecting"] = 1] = "connecting";
    ENUM_SIGNAL_STATE[ENUM_SIGNAL_STATE["connected"] = 2] = "connected";
})(ENUM_SIGNAL_STATE = exports.ENUM_SIGNAL_STATE || (exports.ENUM_SIGNAL_STATE = {}));
exports.ENUM_RESOLUTION_TYPE = {
    LOW: {
        width: 320,
        height: 240,
        frameRate: 15,
        bitRate: 300,
    },
    MEDIUM: {
        width: 640,
        height: 480,
        frameRate: 15,
        bitRate: 800,
    },
    HIGH: {
        width: 1280,
        height: 720,
        frameRate: 20,
        bitRate: 1500,
    },
};
exports.ENUM_SCREEM_RESOLUTION_TYPE = {
    LOW: {
        frameRate: 20,
        bitRate: 800,
    },
    MEDIUM: {
        frameRate: 15,
        bitRate: 1200,
    },
    HIGH: {
        frameRate: 5,
        bitRate: 2000,
    },
};
exports.ENUM_CONNECT_STATE = { disconnect: 0, connecting: 1, connected: 2 };
exports.MAX_TRY_CONNECT_COUNT = 1;
exports.SEND_MSG_RESET = 2;
exports.SEND_MSG_TIMEOUT = 1;
exports.MAX_TRY_HEARTBEAT_COUNT = 5;
exports.MAX_STREAM_ID_LENGTH = 256;
exports.MAX_USER_ID_LENGTH = 64;
exports.MAX_USER_NAME_LENGTH = 256;
exports.MAX_ROOM_ID_LENGTH = 128;
exports.MAX_MIX_TASK_ID_LENGTH = 256;
//
var ENUM_RUN_STATE;
(function (ENUM_RUN_STATE) {
    ENUM_RUN_STATE[ENUM_RUN_STATE["logout"] = 0] = "logout";
    ENUM_RUN_STATE[ENUM_RUN_STATE["trylogin"] = 1] = "trylogin";
    ENUM_RUN_STATE[ENUM_RUN_STATE["login"] = 2] = "login";
})(ENUM_RUN_STATE = exports.ENUM_RUN_STATE || (exports.ENUM_RUN_STATE = {}));
var ENUM_NETWORK_STATE;
(function (ENUM_NETWORK_STATE) {
    ENUM_NETWORK_STATE[ENUM_NETWORK_STATE["offline"] = 0] = "offline";
    ENUM_NETWORK_STATE[ENUM_NETWORK_STATE["online"] = 1] = "online";
})(ENUM_NETWORK_STATE = exports.ENUM_NETWORK_STATE || (exports.ENUM_NETWORK_STATE = {}));
var NetType;
(function (NetType) {
    NetType[NetType["NT_NONE"] = 0] = "NT_NONE";
    NetType[NetType["NT_LINE"] = 1] = "NT_LINE";
    NetType[NetType["NT_WIFI"] = 2] = "NT_WIFI";
    NetType[NetType["NT_2G"] = 3] = "NT_2G";
    NetType[NetType["NT_3G"] = 4] = "NT_3G";
    NetType[NetType["NT_4G"] = 5] = "NT_4G";
    NetType[NetType["NT_UNKNOWN"] = 32] = "NT_UNKNOWN";
})(NetType = exports.NetType || (exports.NetType = {}));
exports.MINIUM_HEARTBEAT_INTERVAL = 3000; //
exports.ENUM_STREAM_UPDATE_CMD = {
    added: 12001,
    deleted: 12002,
    updated: 12003,
};
exports.SERVER_ERROR_CODE = 10000;
// export interface MessageInfo {
//     idName: string; //	ID	
//     nickName: string; //		
//     messageId: string; //	ID	
//     category: number; //		
//     type: number; //		
//     content: string; //		
//     time: number; //		
// }
var E_CLIENT_TYPE;
(function (E_CLIENT_TYPE) {
    E_CLIENT_TYPE[E_CLIENT_TYPE["ClientType_None"] = 0] = "ClientType_None";
    E_CLIENT_TYPE[E_CLIENT_TYPE["ClientType_H5"] = 1] = "ClientType_H5";
    E_CLIENT_TYPE[E_CLIENT_TYPE["ClientType_SmallProgram"] = 2] = "ClientType_SmallProgram";
    E_CLIENT_TYPE[E_CLIENT_TYPE["ClientType_Webrtc"] = 3] = "ClientType_Webrtc";
})(E_CLIENT_TYPE = exports.E_CLIENT_TYPE || (exports.E_CLIENT_TYPE = {}));
exports.REPORT_ACTION = {
    eventStart: 'eventStart',
    eventEndWithMsgInfo: 'eventEndWithMsgInfo',
    addEventMsg: 'addEventMsg',
    addEvent: 'addEvent',
    eventEnd: 'eventEnd',
    addMsgInfo: 'addMsgInfo',
};
exports.getSeq = (function () {
    var seq = 1;
    return function () {
        return seq++;
    };
})();
exports.getReportSeq = (function () {
    var seq = 1;
    return function () {
        return seq++;
    };
})();
var ListNode = /** @class */ (function () {
    function ListNode(id, data) {
        if (id === void 0) { id = null; }
        if (data === void 0) { data = null; }
        this.next = null;
        this.prev = null;
        this._id = id;
        this._data = data;
    }
    Object.defineProperty(ListNode.prototype, "id", {
        get: function () {
            if (this._id) {
                return this._id;
            }
            else {
                return null;
            }
        },
        set: function (id) {
            this._id = id;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ListNode.prototype, "data", {
        get: function () {
            return this._data;
        },
        set: function (data) {
            this._data = data;
        },
        enumerable: false,
        configurable: true
    });
    ListNode.prototype.hasNext = function () {
        return this.next && this.next.id;
    };
    ListNode.prototype.hasPrev = function () {
        return this.prev && this.prev.id;
    };
    return ListNode;
}());
exports.ListNode = ListNode;
var LinkedList = /** @class */ (function () {
    function LinkedList() {
        //initialize end buffer nodes
        this.start = new ListNode();
        this.end = new ListNode();
        //initialize counters
        this._idCounter = 0;
        this._numNodes = 0;
        //initialize node pointers
        this.start.next = this.end;
        this.start.prev = null;
        this.end.prev = this.start;
        this.end.next = null;
    }
    /**
     *   Inserts a node before another node in the linked list
     *   @param {Node} toInsertBefore
     *   @param {Node} node
     */
    LinkedList.prototype.insertBefore = function (toInsertBefore, data) {
        var newNode = new ListNode(this._idCounter, data);
        newNode.next = toInsertBefore;
        newNode.prev = toInsertBefore.prev;
        if (toInsertBefore.prev)
            toInsertBefore.prev.next = newNode;
        toInsertBefore.prev = newNode;
        ++this._idCounter;
        ++this._numNodes;
        return newNode;
    };
    /**
     *   Adds data wrapped in a Node object to the end of the linked list
     *   @param {object} data
     */
    LinkedList.prototype.addLast = function (data) {
        return this.insertBefore(this.end, data);
    };
    /**
     *   Alias for addLast
     *   @param {object} data
     */
    LinkedList.prototype.add = function (data) {
        return this.addLast(data);
    };
    /**
     *   Gets and returns the first node in the linked list or null
     *   @return {Node/null}
     */
    LinkedList.prototype.getFirst = function () {
        if (this._numNodes === 0) {
            return null;
        }
        else {
            return this.start.next;
        }
    };
    /**
     *   Gets and returns the last node in the linked list or null
     *   @return {Node/null}
     */
    LinkedList.prototype.getLast = function () {
        if (this._numNodes === 0) {
            return null;
        }
        else {
            return this.end.prev;
        }
    };
    /**
     *   Gets and returns the size of the linked list
     *   @return {number}
     */
    LinkedList.prototype.size = function () {
        return this._numNodes;
    };
    /**
     *   (Internal) Gets and returns the node at the specified index starting from the first in the linked list
     *   Use getAt instead of this function
     *   @param {number} index
     */
    LinkedList.prototype.getFromFirst = function (index) {
        var count = 0, temp = this.start.next;
        if (index >= 0) {
            while (count < index && temp !== null) {
                temp = temp.next;
                ++count;
            }
        }
        else {
            temp = null;
        }
        if (temp === null) {
            throw 'Index out of bounds.';
        }
        return temp;
    };
    /**
     *   Gets and returns the Node at the specified index in the linked list
     *   @param {number} index
     */
    LinkedList.prototype.get = function (index) {
        var temp = null;
        if (index === 0) {
            temp = this.getFirst();
        }
        else if (index === this._numNodes - 1) {
            temp = this.getLast();
        }
        else {
            temp = this.getFromFirst(index);
        }
        return temp;
    };
    /**
     *   Removes and returns node from the linked list by rearranging pointers
     *   @param {Node} node
     *   @return {Node}
     */
    LinkedList.prototype.remove = function (node) {
        if (node.prev)
            node.prev.next = node.next;
        if (node.next)
            node.next.prev = node.prev;
        --this._numNodes;
        return node;
    };
    /**
     *   Removes and returns the first node in the linked list if it exists, otherwise returns null
     *   @return {Node/null}
     */
    LinkedList.prototype.removeFirst = function () {
        var temp = null;
        if (this._numNodes > 0 && this.start.next) {
            temp = this.remove(this.start.next);
        }
        return temp;
    };
    /**
     *   Removes and returns the last node in the linked list if it exists, otherwise returns null
     *   @return {Node/null}
     */
    LinkedList.prototype.removeLast = function () {
        var temp = null;
        if (this._numNodes > 0 && this.end.prev) {
            temp = this.remove(this.end.prev);
        }
        return temp;
    };
    /**
     *   Removes all nodes from the list
     */
    LinkedList.prototype.removeAll = function () {
        this.start.next = this.end;
        this.end.prev = this.start;
        this._numNodes = 0;
        this._idCounter = 0;
    };
    /**
     *    Iterates the list calling the given fn for each node
     *    @param {function} fn
     */
    LinkedList.prototype.each = function (iterator) {
        var temp = this.start;
        while (temp.hasNext()) {
            temp = temp.next;
            iterator(temp);
        }
    };
    LinkedList.prototype.find = function (iterator) {
        var temp = this.start, found = false, result = null;
        while (temp.hasNext() && !found) {
            temp = temp.next;
            if (iterator(temp)) {
                result = temp;
                found = true;
            }
        }
        return result;
    };
    LinkedList.prototype.map = function (iterator) {
        var temp = this.start;
        var results = [];
        while (temp.hasNext()) {
            temp = temp.next;
            if (iterator(temp)) {
                results.push(temp);
            }
        }
        return results;
    };
    /**
     *    Alias for addLast
     *    @param {object} data
     */
    LinkedList.prototype.push = function (data) {
        return this.addLast(data);
    };
    /**
     *    Performs insertBefore on the first node
     *    @param {object} data
     */
    LinkedList.prototype.unshift = function (data) {
        if (this._numNodes > 0) {
            this.insertBefore(this.start.next, data);
        }
        else {
            this.insertBefore(this.end, data);
        }
    };
    /**
     *    Alias for removeLast
     */
    LinkedList.prototype.pop = function () {
        return this.removeLast();
    };
    /**
     *    Alias for removeFirst()
     */
    LinkedList.prototype.shift = function () {
        return this.removeFirst();
    };
    return LinkedList;
}());
exports.LinkedList = LinkedList;
exports.MODULE_TIPS = {
    MESSAGE: '',
};
var zego_express_logger_1 = __nested_webpack_require_1534003__(/*! zego-express-logger */ "../node_modules/zego-express-logger/ZegoExpressLogger.js");
Object.defineProperty(exports, "ZegoLogger", { enumerable: true, get: function () { return zego_express_logger_1.ZegoLogger; } });
Object.defineProperty(exports, "ZegoDataReport", { enumerable: true, get: function () { return zego_express_logger_1.ZegoDataReport; } });
Object.defineProperty(exports, "LoggerStateCenter", { enumerable: true, get: function () { return zego_express_logger_1.LoggerStateCenter; } });
Object.defineProperty(exports, "createZegoWebSocket", { enumerable: true, get: function () { return zego_express_logger_1.createZegoWebSocket; } });


/***/ }),

/***/ "./sdk/src/zego.externalError.ts":
/*!***************************************!*\
  !*** ./sdk/src/zego.externalError.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.errorCodeList = void 0;
exports.errorCodeList = {
    SERVER: {
        code: 0,
        msg: 'liverooom cmd error',
    },
    SUCCESS: {
        code: 0,
        msg: 'success.',
    },
    INIT: {
        code: 2000000001,
        msg: 'init sdk wrong',
    },
    // commonErr
    NOT_LOGIN: {
        code: 1000002,
        msg: 'not login',
    },
    NETWORK_BROKEN: {
        code: 1000017,
        msg: 'network is broken',
    },
    // 
    INPUT_PARAM: {
        code: 1100001,
        msg: 'input parm error.',
    },
    TIMEOUT: {
        code: 1100002,
        msg: 'network timeout.',
    },
    SOCKET_CLOSE: {
        code: 1100003,
        msg: 'socket close',
    },
    NET_SOCKET_TIMEOUT: {
        code: 1100004,
        msg: 'net agent timeout',
    },
    NET_HB_TIMEOUT: {
        code: 1100005,
        msg: 'net hb timeout',
    },
    // rtc 
    INIT_SDK_WRONG: {
        code: 1101000,
        msg: 'init sdk wrong',
    },
    // roomErr
    // NONE_APP_ID: {
    //     code: 1001000,
    //     msg: 'app id can not be 0',
    // },
    // ROOM_COUNT_EXCEED: {
    //     code: 1002001,
    //     msg: 'login rooms exceeds the upper limit',
    // },
    USER_ID_NULL: {
        code: 1002005,
        msg: 'user ID is empty',
    },
    USER_ID_INVALID_CHARACTER: {
        code: 1002006,
        msg: 'user ID contains illegal characters',
    },
    USER_ID_TOO_LONG: {
        code: 1002007,
        msg: 'user ID is too long',
    },
    USER_NAME_NULL: {
        code: 1002008,
        msg: 'username is empty',
    },
    // USER_NAME_INVALID_CHARACTER: {
    //     code: 1002009,
    //     msg: 'username contains illegal characters',
    // },
    USER_NAME_TOO_LONG: {
        code: 1002010,
        msg: 'username is too long',
    },
    ROOM_ID_NULL: {
        code: 1002011,
        msg: 'room ID is empty',
    },
    ROOM_ID_INVALID_CHARACTER: {
        code: 1002012,
        msg: 'room ID contains illegal characters',
    },
    ROOM_ID_TOO_LONG: {
        code: 1002013,
        msg: 'room ID is too long',
    },
    ROOM_NOT_EXIST: {
        code: 1002014,
        msg: 'room not exist',
    },
    LOGIN_TIMEOUT: {
        code: 1002031,
        msg: 'login timeout',
    },
    ROOM_MAX_USER_COUNT: {
        code: 1002034,
        msg: 'users logging into the room exceeds the maximum number',
    },
    MULTI_ROOM_UNABLE: {
        code: 1002036,
        msg: 'multi room unable',
    },
    MULTIPLE_LOGIN_KICKOUT: {
        code: 1002050,
        msg: 'kickout may be the same user ID login other',
    },
    NETWORK_RECOVERY: {
        code: 1002051,
        msg: 'network recovery',
    },
    ROOM_RETRY_TIMEOUT: {
        code: 1002053,
        msg: 'network is broken and login fail.',
    },
    MANUAL_KICKOUT: {
        code: 1002055,
        msg: 'server has sent a signal to kick out',
    },
    REPEATEDLY_LOGIN: {
        code: 1002056,
        msg: 'user repeatedly login',
    },
    REPEATEDLY_ENTER_ROOM: {
        code: 1002057,
        msg: 'user repeatedly enter room',
    },
    ALREADY_LOGIN: {
        code: 1002058,
        msg: 'user already logged in',
    },
    ROOM_INNER_ERROR: {
        code: 1002099,
        msg: 'room inner error',
    },
    // web
    HEARTBEAT_TIMEOUT: {
        code: 1102001,
        msg: 'heartbeat timeout.',
    },
    // access_svr
    PARSE_JSON_ERROR: {
        code: 1102011,
        msg: 'parse json error.',
    },
    LOGIN_PROCESSING: {
        code: 1102012,
        msg: 'login is processing.',
    },
    LIVEROMM_REQUEST_ERROR: {
        code: 1102013,
        msg: 'liveroom request error.',
    },
    ZPUSH_REQUEST_FAIL: {
        code: 1102014,
        msg: 'zpush request fail.',
    },
    LOGIN_STATE_WRONG: {
        code: 1102015,
        msg: 'user login state is wrong.',
    },
    TOKEN_ERROR: {
        code: 1102016,
        msg: 'token error',
    },
    DIAPATCH_ERROR: {
        code: 1102017,
        msg: 'dispatch error',
    },
    TOKEN_EXPIRED: {
        code: 1102018,
        msg: 'token expired',
    },
    SUBCMD_ERROR: {
        code: 1102019,
        msg: 'subcmd error.',
    },
    ZEGO_AUTH_ERROR: {
        code: 1102020,
        msg: 'zego auth error.',
    },
    BIZ_CHANNEL_ERROR: {
        code: 1102021,
        msg: 'biz channel error.',
    },
};


/***/ }),

/***/ "./sdk/src/zego.log.event.ts":
/*!***********************************!*\
  !*** ./sdk/src/zego.log.event.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1553685__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ZegoRTMLogEvent = void 0;
var zego_externalError_1 = __nested_webpack_require_1553685__(/*! ./zego.externalError */ "./sdk/src/zego.externalError.ts");
var getItem = function (item) { return item; };
// 
exports.ZegoRTMLogEvent = {
    kZegoTaskInitSetting: {
        ///< 
        event: '/sdk/init',
        error: {
            kInvalidParamError: zego_externalError_1.errorCodeList.INPUT_PARAM,
        },
        system_info: navigator ? navigator.appVersion : '',
    },
    kZegoTaskSetDebug: {
        event: '/sdk/set_debug',
        debug: getItem,
    },
    kZegoTaskSetLog: {
        event: '/sdk/set_log_config',
        error: {
            kInvalidParamError: zego_externalError_1.errorCodeList.INPUT_PARAM,
        },
        log_level: function (level) { return level; },
        remote_log_level: getItem,
        log_url: getItem,
    },
    kZegoTaskLoginRoom: {
        ///< sdk/login login--onlogin 
        event: '/sdk/login',
        user_update: getItem,
        max_member_count: getItem,
        message: getItem,
        token: getItem,
        error: {
            ROOM_ID_NULL: zego_externalError_1.errorCodeList.ROOM_ID_NULL,
            INPUT_PARAM: zego_externalError_1.errorCodeList.INPUT_PARAM,
            ROOM_ID_TOO_LONG: zego_externalError_1.errorCodeList.ROOM_ID_TOO_LONG,
            ROOM_ID_INVALID_CHARACTER: zego_externalError_1.errorCodeList.ROOM_ID_INVALID_CHARACTER,
            USER_ID_NULL: zego_externalError_1.errorCodeList.USER_ID_NULL,
            USER_ID_TOO_LONG: zego_externalError_1.errorCodeList.USER_ID_TOO_LONG,
            USER_ID_INVALID_CHARACTER: zego_externalError_1.errorCodeList.USER_ID_INVALID_CHARACTER,
            USER_NAME_NULL: zego_externalError_1.errorCodeList.USER_NAME_NULL,
            USER_NAME_TOO_LONG: zego_externalError_1.errorCodeList.USER_NAME_TOO_LONG,
            REPEATEDLY_LOGIN: zego_externalError_1.errorCodeList.REPEATEDLY_LOGIN,
            LOGIN_TIMEOUT: zego_externalError_1.errorCodeList.LOGIN_TIMEOUT,
            INNER_ERROR: zego_externalError_1.errorCodeList.ROOM_INNER_ERROR,
            NETWORK_BROKEN: zego_externalError_1.errorCodeList.NETWORK_BROKEN,
        },
        subEvent: {
            create_socket: {
                event: 'create_socket',
                server: getItem,
                try_cnt: getItem,
            },
            liveroom_login: {
                event: 'liveroom_login',
                server: getItem,
                respond_info: getItem,
            },
        },
    },
    kZegoTaskReNewToken: {
        event: '/sdk/reNewToken',
        error: {
            INPUT_PARAM: zego_externalError_1.errorCodeList.INPUT_PARAM,
            NOT_LOGIN: zego_externalError_1.errorCodeList.NOT_LOGIN,
        },
    },
    kZegoTaskLogoutRoom: {
        event: '/sdk/logout',
        error: {
            INPUT_PARAM: zego_externalError_1.errorCodeList.INPUT_PARAM,
            ROOM_NOT_EXIST: zego_externalError_1.errorCodeList.ROOM_NOT_EXIST,
        },
    },
    kZegoTaskReLoginRoom: {
        //sessionid  
        event: '/sdk/relogin',
        error: {
            ROOM_ID_NULL: zego_externalError_1.errorCodeList.ROOM_ID_NULL,
            ROOM_DISCONNECT: zego_externalError_1.errorCodeList.NETWORK_BROKEN,
        },
        subEvent: {
            create_socket: {
                event: 'create_socket',
                server: getItem,
                try_cnt: getItem,
            },
            liveroom_login: {
                event: 'liveroom_login',
                server: getItem,
                respond_info: getItem,
            },
        },
    },
    // kZegoTaskSdkDisconnect: {
    //     ///< Zpush
    //     event: '/sdk/disconnect',
    // },
    kZegoTaskKickout: {
        ///< Kickout Room
        event: '/sdk/kickout',
        user_id: getItem,
        error: {},
    },
    kZegoTaskRoomKickout: {
        event: '/sdk/room_kickout',
        user_id: getItem,
        room_id: getItem,
        message: getItem,
    },
    kZegoTaskLiveRoomHB: {
        ///< liveroom
        event: '/liveroom/hb',
        room_sid: getItem,
        error: {
            NOT_LOGIN: zego_externalError_1.errorCodeList.NOT_LOGIN,
            HB_TIMEOUT: zego_externalError_1.errorCodeList.TIMEOUT,
        },
    },
    // kZegoTaskLiveSendRoomBigIM: {
    //     event: '/liveroom/send_big_room_message',
    //     room_sid: getItem,
    //     error: {
    //         INPUT_PARAM: errorCodeList.INPUT_PARAM,
    //         IM_CONTENT_NULL: errorCodeList.IM_CONTENT_NULL,
    //         IM_CONTENT_TOO_LONG: errorCodeList.IM_CONTENT_TOO_LONG,
    //         ROOM_NOT_EXIST: errorCodeList.ROOM_NOT_EXIST,
    //     },
    // },
    // kZegoTaskLiveRoomSendCustomCommand: {
    //     event: '/liveroom/send_custom_command',
    //     room_sid: getItem,
    //     error: {
    //         INPUT_PARAM: errorCodeList.INPUT_PARAM,
    //         IM_CONTENT_NULL: errorCodeList.IM_CONTENT_NULL,
    //         IM_CONTENT_TOO_LONG: errorCodeList.IM_CONTENT_TOO_LONG,
    //         ROOM_NOT_EXIST: errorCodeList.ROOM_NOT_EXIST,
    //     },
    // },
    // kZegoTaskLiveRoomSendRoomMessage: {
    //     event: '/liveroom/send_room_message',
    //     room_sid: getItem,
    //     error: {
    //         INPUT_PARAM: errorCodeList.INPUT_PARAM,
    //         IM_CONTENT_NULL: errorCodeList.IM_CONTENT_NULL,
    //         IM_CONTENT_TOO_LONG: errorCodeList.IM_CONTENT_TOO_LONG,
    //         ROOM_NOT_EXIST: errorCodeList.ROOM_NOT_EXIST,
    //     },
    // },
    // kZegoTaskLiveRoomSendReliableMessage: {
    //     event: '/liveroom/send_reliable_message',
    //     room_sid: getItem,
    //     error: {
    //         INPUT_PARAM: errorCodeList.INPUT_PARAM,
    //         TRANS_FREQUENTLY: errorCodeList.TRANS_FREQUENTLY,
    //         ROOM_NOT_EXIST: errorCodeList.ROOM_NOT_EXIST,
    //     },
    // },
    // kZegoTaskLiveGetRoomBigIM: {
    //     event: '/liveroom/get_big_room_message',
    // },
    // kZegoTaskLiveRoomGetRoomMessage: {
    //     event: '/liveroom/get_room_message',
    //     room_sid: getItem,
    // },
    // kZegoTaskLiveRoomGetCustomCommand: {
    //     event: '/liveroom/get_custom_command',
    // },
    kZegoTaskLiveRoomGetUserUpdateInfo: {
        event: '/liveroom/get_user_update_info',
        user_update_type: getItem,
    },
    kZegoListener: {
        event: '/sdk/listener',
    },
    kZegoEnableMultiRoom: {
        event: 'sdk/enable_multi_room',
        error: {
            kInvalidParamError: zego_externalError_1.errorCodeList.INPUT_PARAM,
            kAlreadyLoginError: zego_externalError_1.errorCodeList.ALREADY_LOGIN,
        },
    },
    // kZegoTaskLiveRoomGetCurrentUserList: {
    //     event: '/liveroom/get_current_user_list',
    // },
    // kZegoTaskLiveRoomSendEndJoinLive: {
    //     event: '/liveroom/send_end_join_live',
    // },
    // kZegoTaskLiveRoomSendInviteJoinLive: {
    //     event: '/liveroom/send_invite_join_live',
    // },
    // kZegoTaskLiveRoomSendJoinLiveResult: {
    //     event: '/liveroom/send_join_live_result',
    // },
    // kZegoTaskLiveRoomSendRequestJoinLive: {
    //     event: '/liveroom/send_request_join_live',
    // },
    kZegoTaskCloudSettingCache: {
        event: '/cloud_setting/cache',
    },
    kZegoTaskCloudSettingRefresh: {
        event: '/cloud_setting/refresh',
    },
    kZegoTaskCloudSettingRequest: {
        event: '/cloud_setting/request',
    },
};


/***/ }),

/***/ "./sdk/util/base64.ts":
/*!****************************!*\
  !*** ./sdk/util/base64.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Base64 = void 0;
/* eslint-disable prefer-const */
var Base64 = /** @class */ (function () {
    function Base64() {
    }
    Base64.base64encode = function (str) {
        var out, i, len;
        var c1, c2, c3;
        len = str.length;
        i = 0;
        out = '';
        while (i < len) {
            c1 = str.charCodeAt(i++) & 0xff;
            if (i == len) {
                out += Base64.base64EncodeChars.charAt(c1 >> 2);
                out += Base64.base64EncodeChars.charAt((c1 & 0x3) << 4);
                out += '==';
                break;
            }
            c2 = str.charCodeAt(i++);
            if (i == len) {
                out += Base64.base64EncodeChars.charAt(c1 >> 2);
                out += Base64.base64EncodeChars.charAt(((c1 & 0x3) << 4) | ((c2 & 0xf0) >> 4));
                out += Base64.base64EncodeChars.charAt((c2 & 0xf) << 2);
                out += '=';
                break;
            }
            c3 = str.charCodeAt(i++);
            out += Base64.base64EncodeChars.charAt(c1 >> 2);
            out += Base64.base64EncodeChars.charAt(((c1 & 0x3) << 4) | ((c2 & 0xf0) >> 4));
            out += Base64.base64EncodeChars.charAt(((c2 & 0xf) << 2) | ((c3 & 0xc0) >> 6));
            out += Base64.base64EncodeChars.charAt(c3 & 0x3f);
        }
        return out;
    };
    Base64.base64decode = function (str) {
        var c1, c2, c3, c4;
        var i, len, out;
        len = str.length;
        i = 0;
        out = '';
        while (i < len) {
            /* c1 */
            do {
                c1 = Base64.base64DecodeChars[str.charCodeAt(i++) & 0xff];
            } while (i < len && c1 == -1);
            if (c1 == -1)
                break;
            /* c2 */
            do {
                c2 = Base64.base64DecodeChars[str.charCodeAt(i++) & 0xff];
            } while (i < len && c2 == -1);
            if (c2 == -1)
                break;
            out += String.fromCharCode((c1 << 2) | ((c2 & 0x30) >> 4));
            /* c3 */
            do {
                c3 = str.charCodeAt(i++) & 0xff;
                if (c3 == 61)
                    return out;
                c3 = Base64.base64DecodeChars[c3];
            } while (i < len && c3 == -1);
            if (c3 == -1)
                break;
            out += String.fromCharCode(((c2 & 0xf) << 4) | ((c3 & 0x3c) >> 2));
            /* c4 */
            do {
                c4 = str.charCodeAt(i++) & 0xff;
                if (c4 == 61)
                    return out;
                c4 = Base64.base64DecodeChars[c4];
            } while (i < len && c4 == -1);
            if (c4 == -1)
                break;
            out += String.fromCharCode(((c3 & 0x03) << 6) | c4);
        }
        return out;
    };
    Base64.utf16to8 = function (str) {
        var out, i, len, c;
        out = '';
        len = str.length;
        for (i = 0; i < len; i++) {
            c = str.charCodeAt(i);
            if (c >= 0x0001 && c <= 0x007f) {
                out += str.charAt(i);
            }
            else if (c > 0x07ff) {
                out += String.fromCharCode(0xe0 | ((c >> 12) & 0x0f));
                out += String.fromCharCode(0x80 | ((c >> 6) & 0x3f));
                out += String.fromCharCode(0x80 | ((c >> 0) & 0x3f));
            }
            else {
                out += String.fromCharCode(0xc0 | ((c >> 6) & 0x1f));
                out += String.fromCharCode(0x80 | ((c >> 0) & 0x3f));
            }
        }
        return out;
    };
    Base64.utf8to16 = function (str) {
        var out, i, len, c;
        var char2, char3;
        out = '';
        len = str.length;
        i = 0;
        while (i < len) {
            c = str.charCodeAt(i++);
            switch (c >> 4) {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    // 0xxxxxxx
                    out += str.charAt(i - 1);
                    break;
                case 12:
                case 13:
                    // 110x xxxx 10xx xxxx
                    char2 = str.charCodeAt(i++);
                    out += String.fromCharCode(((c & 0x1f) << 6) | (char2 & 0x3f));
                    break;
                case 14:
                    // 1110 xxxx10xx xxxx10xx xxxx
                    char2 = str.charCodeAt(i++);
                    char3 = str.charCodeAt(i++);
                    out += String.fromCharCode(((c & 0x0f) << 12) | ((char2 & 0x3f) << 6) | ((char3 & 0x3f) << 0));
                    break;
            }
        }
        return out;
    };
    Base64.base64EncodeChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    Base64.base64DecodeChars = [
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        62,
        -1,
        -1,
        -1,
        63,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        -1,
        -1,
        -1,
        -1,
        -1,
    ];
    return Base64;
}());
exports.Base64 = Base64;


/***/ }),

/***/ "./sdk/util/client-util.ts":
/*!*********************************!*\
  !*** ./sdk/util/client-util.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1568214__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientUtil = void 0;
var base64_1 = __nested_webpack_require_1568214__(/*! ./base64 */ "./sdk/util/base64.ts");
var zego_entity_1 = __nested_webpack_require_1568214__(/*! ../src/zego.entity */ "./sdk/src/zego.entity.ts");
var aes_1 = __importDefault(__nested_webpack_require_1568214__(/*! crypto-js/aes */ "./node_modules/crypto-js/aes.js"));
var enc_utf8_1 = __importDefault(__nested_webpack_require_1568214__(/*! crypto-js/enc-utf8 */ "./node_modules/crypto-js/enc-utf8.js"));
var zego_externalError_1 = __nested_webpack_require_1568214__(/*! ../src/zego.externalError */ "./sdk/src/zego.externalError.ts");
var ClientUtil = /** @class */ (function () {
    function ClientUtil() {
    }
    ClientUtil.checkConfigParam = function (appid, server, logger) {
        if (!appid || typeof appid !== 'number' || !this.checkInteger(appid)) {
            logger.error('ccp.0 appid must be positive integer number and not empty');
            return false;
        }
        if (!server || (typeof server !== 'string' && !Array.isArray(server)) || server == '') {
            logger.error('ccp.0 server must be string or string array and not empty');
            return false;
        }
        return true;
    };
    ClientUtil.checkPriConfigParam = function (appid, dispatchServer, deviceInfo, anType, logger) {
        if (!appid || typeof appid !== 'number' || !this.checkInteger(appid)) {
            logger.error('ccp.0 appid must be positive integer number and not empty');
            return false;
        }
        if (!dispatchServer || typeof dispatchServer !== 'string') {
            logger.error('ccp.0 dispatchServer must be string and not empty');
            return false;
        }
        if (typeof deviceInfo !== 'object' || typeof deviceInfo.deviceID !== 'string') {
            logger.error('ccp.0 deviceID must be string and not empty');
            return false;
        }
        if (anType !== 1 && anType !== 0) {
            logger.error('ccp.0 anType must be 0 or 1');
            return false;
        }
        return true;
    };
    ClientUtil.checkIllegalCharacters = function (str) {
        // const reg = /^(?=.*[a-zA-Z\d~!@#$%^&amp;*()_+`\-={}:";'&lt;&gt;?,.\/]).{1,256}$/;
        var reg = /^([0-9a-zA-Z#!$%&()`'+-;<=.>@^_~,\\*])+$/;
        var reg2 = /^[^:/]*$/g;
        return reg.test(str) && reg2.test(str);
    };
    ClientUtil.isUrl = function (str) {
        if (str.startsWith('rtmp://') ||
            (str.startsWith('https://') && str.endsWith('.flv')) ||
            (str.startsWith('https://') && str.endsWith('.m3u8'))) {
            return true;
        }
        return false;
    };
    ClientUtil.registerCallback = function (fName, option, callbackList) {
        var sf, ef;
        if (option.success) {
            sf = option.success;
            callbackList[fName + 'SuccessCallback'] = sf;
        }
        if (option.error) {
            ef = option.error;
            callbackList[fName + 'ErrorCallback'] = ef;
        }
    };
    ClientUtil.actionErrorCallback = function (fName, callbackList) {
        return callbackList[fName + 'ErrorCallback'];
    };
    // 
    ClientUtil.actionSuccessCallback = function (fName, callbackList) {
        return callbackList[fName + 'SuccessCallback'];
    };
    ClientUtil.logReportCallback = function (logEvent, dataReport, reportSeq, callbackList) {
        ClientUtil.registerCallback(logEvent, {
            success: function (reportName, eventName) {
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    args[_i - 2] = arguments[_i];
                }
                ClientUtil.dataReportEvent(dataReport, reportSeq, reportName, eventName, args);
            },
        }, callbackList);
    };
    ClientUtil.proxyRes = function (dataReport, reportSeq, resolve, reject) {
        var interResolve = function (res) {
            dataReport.uploadReport(reportSeq);
            resolve(res);
        };
        var interReject = function (err, externMsg) {
            if (externMsg === void 0) { externMsg = ''; }
            var reportErr;
            if (err.code < 2000000000 && err.code > 1000000000) {
                reportErr = ClientUtil.decodeServerError(err.code, err.msg);
            }
            else {
                reportErr = {
                    code: err.code,
                    message: err.msg,
                };
            }
            reportErr &&
                dataReport.addMsgInfo(reportSeq, {
                    error: reportErr.code,
                    message: reportErr.message + externMsg,
                });
            dataReport.uploadReport(reportSeq);
            reject({ errorCode: err.code });
        };
        return { interResolve: interResolve, interReject: interReject };
    };
    /**
         
         */
    ClientUtil.getServerError = function (code) {
        var serverErrorList = {
            1: 'parse json error.',
            1001: 'login is processing.',
            1002: 'liveroom request error.',
            1003: 'zpush connect fail.',
            1004: 'zpush handshake fail.',
            1005: 'zpush login fail.',
            1006: 'user login state is wrong.',
            1007: 'got no zpush addr',
            1008: 'token error',
            1009: 'dispatch error',
            1010: 'token expired',
            1011: 'token format error',
            2002: 'biz channel error',
            1000000000: 'liveroom cmd error, code:',
            1000002001: 'need relogin',
            1000002002: 'third token auth error',
            1000002003: 'token nonce type should be int64',
            1000002004: 'token appid type  should be uint32',
            1000002005: 'token timeout type should be int64',
            1000002006: 'token user_id type should be string',
            1000002007: 'token room_id type should be string',
            1000002008: 'token format error',
            1000002009: 'token privilege type should be map',
            1000002010: 'token expire_time type should be int64',
            1000002011: 'token user_id type should be string',
            1000002012: 'token not exist',
            1000002013: 'token update error',
            1000002014: 'token not need to check',
        };
        if (code === 0) {
            return zego_externalError_1.errorCodeList.SUCCESS;
        }
        var err = __assign({}, zego_externalError_1.errorCodeList.ROOM_INNER_ERROR);
        err.code = code;
        if (code > 1000000000) {
            var errMsg = serverErrorList[code];
            if (errMsg) {
                err.msg = 'liveroom cmd error, code: ' + code + ', message: ' + errMsg;
            }
            else {
                err.msg = serverErrorList[1000000000] + code;
            }
        }
        else if (serverErrorList[code]) {
            err.msg = serverErrorList[code] + ' code:' + code;
        }
        else {
            err.msg = 'unknown error code:' + code;
        }
        return err;
    };
    ClientUtil.unregisterCallback = function (fName, callbackList) {
        delete callbackList[fName + 'SuccessCallback'];
        delete callbackList[fName + 'ErrorCallback'];
    };
    ClientUtil.decodeServerError = function (code, msg) {
        var err = { code: -1, message: 'server error' };
        if (code > 1000000000) {
            err.code = code - 1000000000 + 52000000;
        }
        else {
            err.code = code + 2002000000;
        }
        msg && (err.message = msg);
        return err;
    };
    ClientUtil.getLiveRoomError = function (code, useNetAgent) {
        var liveRoomErrMap = {
            1016: 'MULTI_ROOM_UNABLE',
            1105: 'ROOM_MAX_USER_COUNT',
            1012: 'PUBLISHER_ERROR_REPETITIVE_PUBLISH_STREAM',
            // 2002: 'ROOM_ERROR_AUTHENTICATION_FAILED',
            2002: 'TOKEN_ERROR',
            2003: 'ROOM_ERROR_LOGIN_TIMEOUT',
            2010: 'TOKEN_ERROR',
        };
        var switchErrMap = {
            50116: "TOKEN_ERROR",
            50117: "TOKEN_EXPIRED",
            50118: 'TOKEN_ERROR'
        };
        if (useNetAgent) {
            if (code > 200000 && code < 300000) {
                return liveRoomErrMap[code - 200000];
            }
            else if (code < 200000) {
                return switchErrMap[code] || 'ROOM_INNER_ERROR';
            }
            return liveRoomErrMap[code] || 'ROOM_INNER_ERROR';
        }
        else {
            var prefix = 1000000000;
            var accessSvrErrMap = {
                1: 'PARSE_JSON_ERROR',
                1001: 'LOGIN_PROCESSING',
                1002: 'LIVEROMM_REQUEST_ERROR',
                1003: 'ZPUSH_REQUEST_FAIL',
                1004: 'ZPUSH_REQUEST_FAIL',
                1005: 'ZPUSH_REQUEST_FAIL',
                1006: 'LOGIN_STATE_WRONG',
                1007: 'ZPUSH_REQUEST_FAIL',
                1008: 'TOKEN_ERROR',
                1009: 'DIAPATCH_ERROR',
                1010: 'TOKEN_EXPIRED',
                1011: 'TOKEN_ERROR',
                1012: 'SUBCMD_ERROR',
                1101: 'ZEGO_AUTH_ERROR',
                2001: 'BIZ_CHANNEL_ERROR',
                2002: 'BIZ_CHANNEL_ERROR',
            };
            if (code > 1000000000) {
                return liveRoomErrMap[code - prefix] || '';
            }
            else {
                return accessSvrErrMap[code] || 'ROOM_INNER_ERROR';
            }
        }
    };
    ClientUtil.getKickoutError = function (code, useNetAgent) {
        var err = { code: code, message: 'kickout reason = ' + code };
        if (useNetAgent) {
            switch (code) {
                case 1:
                    err.code = 63000001;
                    err.message = 'zpush multiple login kickout';
                    err.name = 'MULTIPLE_LOGIN_KICKOUT';
                    break;
                case 2:
                    err.code = 63000002;
                    err.message = 'zpush manual kickout';
                    err.name = 'MANUAL_KICKOUT';
                    break;
                case 4:
                    err.code = 63000005;
                    err.message = 'zpush token expired';
                    err.name = 'TOKEN_EXPIRED';
                    break;
                default:
                    err.code = code;
                    err.message = 'kickout reason = ' + code;
                    break;
            }
        }
        else {
            switch (code) {
                case 1:
                    err.code = 63000001;
                    err.message = 'zpush multiple login kickout';
                    err.name = 'MULTIPLE_LOGIN_KICKOUT';
                    break;
                case 2:
                    err.code = 63000002;
                    err.message = 'zpush manual kickout';
                    err.name = 'MANUAL_KICKOUT';
                    break;
                case 3:
                    err.code = 63000003;
                    err.message = 'kickout reason = ' + code;
                    break;
                case 4:
                    err.code = 63000004;
                    err.message = 'zpush multiple login kickout';
                    err.name = 'MULTIPLE_LOGIN_KICKOUT';
                    break;
                case 5:
                    err.code = 63000005;
                    err.message = 'zpush token expired';
                    err.name = 'TOKEN_EXPIRED';
                    break;
                default:
                    err.code = code;
                    err.message = 'kickout reason = ' + code;
                    break;
            }
        }
        return err;
    };
    ClientUtil.dataReportEvent = function (dataReport, reportSeq, reportName, eventName, args) {
        switch (reportName) {
            case 'eventStart':
                dataReport.eventStart(reportSeq, eventName);
                break;
            case 'eventEndWithMsgInfo':
                dataReport.eventEndWithMsgInfo(reportSeq, eventName, args[0]);
                break;
            case 'addEventMsg':
                dataReport.addEventMsg(reportSeq, eventName, args[0], args[1]);
                break;
            case 'addEvent':
                dataReport.addEvent(reportSeq, eventName);
                break;
            case 'eventEnd':
                dataReport.eventEnd(reportSeq, eventName);
                break;
            case 'addMsgInfo':
                dataReport.addMsgInfo(reportSeq, args[0]);
                break;
            default:
                break;
        }
    };
    ClientUtil.isKeepTryLogin = function (code) {
        switch (code) {
            case 1002: //liveroom connect error
            case 1003: //zpush connect error
                return true;
            default:
                return false;
        }
    };
    ClientUtil.mergeUserList = function (logger, oldUserList, newUserList, callbackResult) {
        logger.debug('msl.0 call');
        var addUserList = [];
        var delUserList = [];
        var flag;
        if (!newUserList) {
            newUserList = [];
        }
        for (var i = 0; i < newUserList.length; i++) {
            flag = false;
            for (var j = 0; j < oldUserList.length; j++) {
                if (newUserList[i].userID === oldUserList[j].userID) {
                    flag = true;
                    break;
                }
            }
            if (!flag) {
                addUserList.push(newUserList[i]);
            }
        }
        for (var k = 0; k < oldUserList.length; k++) {
            flag = false;
            for (var n = 0; n < newUserList.length; n++) {
                if (oldUserList[k].userID === newUserList[n].userID) {
                    flag = true;
                    break;
                }
            }
            if (!flag) {
                delUserList.push(oldUserList[k]);
            }
        }
        oldUserList.splice(0);
        for (var i = 0; i < newUserList.length; i++) {
            oldUserList.push(oldUserList[i]);
        }
        callbackResult(addUserList, delUserList);
        logger.debug('msl.0 call success');
    };
    ClientUtil.checkInteger = function (num, positive) {
        if (positive == false)
            return typeof num === 'number' && num % 1 === 0 && num >= 0;
        return typeof num === 'number' && num % 1 === 0 && num > 0;
    };
    ClientUtil.checkValidNumber = function (param, min, max) {
        min = min || 1;
        max = max || 1 * 1e4;
        return typeof param === 'number' && param % 1 == 0 && param >= min && param <= max;
    };
    //
    ClientUtil.generateRandumNumber = function (maxNum) {
        return parseInt(Math.random() * (maxNum + 1) + '', 10);
    };
    //
    ClientUtil.uuid = function (len, radix) {
        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
        var uuid = [];
        var i;
        radix = radix || chars.length;
        if (len) {
            // Compact form
            for (i = 0; i < len; i++)
                uuid[i] = chars[0 | (Math.random() * radix)];
        }
        else {
            // rfc4122, version 4 form
            var r = void 0;
            // rfc4122 requires these characters
            uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
            uuid[14] = '4';
            // Fill in random data. At i==19 set the high bits of clock sequence as
            // per rfc4122, sec. 4.1.5
            for (i = 0; i < 36; i++) {
                if (!uuid[i]) {
                    r = 0 | (Math.random() * 16);
                    uuid[i] = chars[i == 19 ? (r & 0x3) | 0x8 : r];
                }
            }
        }
        return uuid.join('');
    };
    ClientUtil.compareVersion = function (v1, v2) {
        v1 = v1.split('.');
        v2 = v2.split('.');
        var len = Math.max(v1.length, v2.length);
        while (v1.length < len) {
            v1.push('0');
        }
        while (v2.length < len) {
            v2.push('0');
        }
        for (var i = 0; i < len; i++) {
            var num1 = parseInt(v1[i]);
            var num2 = parseInt(v2[i]);
            if (num1 > num2) {
                return 1;
            }
            else if (num1 < num2) {
                return -1;
            }
        }
        return 0;
    };
    ClientUtil.getBrowser = function () {
        var ua = window.navigator.userAgent;
        var isIE = window.ActiveXObject != undefined && ua.indexOf('MSIE') != -1;
        var isFirefox = ua.indexOf('Firefox') != -1;
        var isOpera = window.opr != undefined;
        var isChrome = ua.indexOf('Chrome') && window.chrome;
        var isSafari = ua.indexOf('Safari') != -1 && ua.indexOf('Version') != -1;
        if (isIE) {
            return 'IE';
        }
        else if (isFirefox) {
            return 'Firefox';
        }
        else if (isOpera) {
            return 'Opera';
        }
        else if (isChrome) {
            return 'Chrome';
        }
        else if (isSafari) {
            return 'Safari';
        }
        else {
            return 'Unkown';
        }
    };
    ClientUtil.isTestEnv = function (server) {
        if (server.indexOf('wss://wssliveroom-test.zego.im/ws') != -1 ||
            server.indexOf('wss://test2-wsliveroom-api.zego.im/ws') != -1 ||
            server.indexOf('wss://wsliveroom-test.zegocloud.com/ws') != -1 ||
            server.indexOf('wss://wsliveroom-test.zego.im/ws') != -1 ||
            server.indexOf('wss://webliveroom-test.zego.im/ws') != -1 ||
            server.indexOf('wss://webliveroom-test-bak.zego.im/ws') != -1 ||
            server.indexOf('wss://webliveroom-hk-test.zegocloud.com/ws') != -1 ||
            server.indexOf('wss://webliveroom-hk-test-bak.zegocloud.com/ws') != -1) {
            return true;
        }
        return false;
    };
    ClientUtil.getLogLevel = function (level) {
        return zego_entity_1.LOG_LEVEL[level];
    };
    ClientUtil.getUint64 = function (byteOffset, littleEndian, dv) {
        // split 64-bit number into two 32-bit parts
        var left = dv.getUint32(byteOffset, littleEndian);
        var right = dv.getUint32(byteOffset + 4, littleEndian);
        // combine the two 32-bit values
        var combined = littleEndian ? left + Math.pow(2, 32) * right : Math.pow(2, 32) * left + right;
        if (!Number.isSafeInteger(combined))
            console.warn(combined, 'exceeds MAX_SAFE_INTEGER. Precision may be lost');
        return combined;
    };
    /**
     *   token  s
     */
    ClientUtil.decodeTokenExpire = function (token) {
        try {
            var u8 = Uint8Array.from(base64_1.Base64.base64decode(token), function (c) { return c.charCodeAt(0); });
            var dv = new DataView(u8.buffer);
            var expire = void 0;
            if (typeof dv.getBigInt64 === 'function') {
                expire = dv.getBigUint64(0);
            }
            else {
                expire = ClientUtil.getUint64(0, false, dv);
            }
            if (expire > 0) {
                return Number(expire);
            }
            else {
                return Number(dv.getBigUint64(0, true));
            }
        }
        catch (err) {
            console.error('token error');
        }
        return -1;
    };
    ClientUtil.bin2hex = function (s) {
        var i, l, o = '', n;
        s += '';
        for (i = 0, l = s.length; i < l; i++) {
            n = s.charCodeAt(i).toString(16);
            o += n.length < 2 ? '0' + n : n;
        }
        return o;
    };
    ClientUtil.getCanvasFingerprint = function (domain) {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        var txt = domain;
        ctx.textBaseline = 'top';
        ctx.font = "14px 'Arial'";
        ctx.fillStyle = '#f60';
        ctx.fillRect(125, 1, 62, 20);
        ctx.fillStyle = '#069';
        ctx.fillText(txt, 2, 15);
        ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
        ctx.fillText(txt, 4, 17);
        var b64 = canvas.toDataURL().replace('data:image/png;base64,', '');
        var bin = atob(b64);
        var crc = this.bin2hex(bin.slice(-16, -12));
        return crc;
    };
    ClientUtil.generateUUID = function (env) {
        if (env === void 0) { env = 0; }
        var deviceID;
        if (env === 0) {
            deviceID = localStorage.getItem('z_deviceID');
        }
        else {
            wx.getStorageSync('z_deviceID');
        }
        if (deviceID) {
            return deviceID;
        }
        else {
            var d_1 = new Date().getTime();
            var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = (d_1 + Math.random() * 16) % 16 | 0;
                d_1 = Math.floor(d_1 / 16);
                return (c == 'x' ? r : (r & 0x3) | 0x8).toString(36);
            });
            if (env === 0) {
                var canvas = this.getCanvasFingerprint('hello, zego');
                var _uuid = canvas + uuid.slice(8);
                localStorage.setItem('z_deviceID', _uuid);
            }
            else {
                wx.setStorageSync('z_deviceID', uuid);
            }
            return uuid;
        }
    };
    ClientUtil.getNetType = function () {
        // @ts-ignore
        var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        // @ts-ignore
        return ((connection === null || connection === void 0 ? void 0 : connection.effectiveType) || (connection === null || connection === void 0 ? void 0 : connection.type) || 'unknwon').toUpperCase();
    };
    ClientUtil.getNetTypeNum = function () {
        // @ts-ignore
        var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        // @ts-ignore
        var type = ((connection === null || connection === void 0 ? void 0 : connection.effectiveType) || (connection === null || connection === void 0 ? void 0 : connection.type) || 'unknwon').toUpperCase();
        var netType;
        if (type.indexOf('4G') > -1) {
            netType = zego_entity_1.NetType.NT_4G;
        }
        else if (type.indexOf('2G') > -1) {
            netType = zego_entity_1.NetType.NT_2G;
        }
        else if (type.indexOf('3G') > -1) {
            netType = zego_entity_1.NetType.NT_3G;
        }
        else if (type.indexOf('WIFI') > -1) {
            netType = zego_entity_1.NetType.NT_WIFI;
        }
        else if (type.indexOf('LINE') > -1) {
            netType = zego_entity_1.NetType.NT_LINE;
        }
        else if (type.indexOf('NONE') > -1) {
            netType = zego_entity_1.NetType.NT_NONE;
        }
        else {
            netType = zego_entity_1.NetType.NT_UNKNOWN;
        }
        return netType;
    };
    ClientUtil.encryptStores = function (originString, secret) {
        var ciphertext = aes_1.default.encrypt(originString, secret).toString();
        return ciphertext;
    };
    ClientUtil.decryptStores = function (ciphertext, secret) {
        try {
            var bytes = aes_1.default.decrypt(ciphertext, secret);
            var originalText = bytes.toString(enc_utf8_1.default);
            return originalText;
        }
        catch (error) {
            return '';
        }
    };
    return ClientUtil;
}());
exports.ClientUtil = ClientUtil;


/***/ }),

/***/ "./sdk/util/crypto.ts":
/*!****************************!*\
  !*** ./sdk/util/crypto.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1592409__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Crypto = void 0;
var js_base64_1 = __nested_webpack_require_1592409__(/*! js-base64 */ "./node_modules/js-base64/base64.mjs");
var aes_1 = __importDefault(__nested_webpack_require_1592409__(/*! crypto-js/aes */ "./node_modules/crypto-js/aes.js"));
var enc_hex_1 = __importDefault(__nested_webpack_require_1592409__(/*! crypto-js/enc-hex */ "./node_modules/crypto-js/enc-hex.js"));
var enc_utf8_1 = __importDefault(__nested_webpack_require_1592409__(/*! crypto-js/enc-utf8 */ "./node_modules/crypto-js/enc-utf8.js"));
var lib_typedarrays_1 = __importDefault(__nested_webpack_require_1592409__(/*! crypto-js/lib-typedarrays */ "./node_modules/crypto-js/lib-typedarrays.js"));
var md5_1 = __importDefault(__nested_webpack_require_1592409__(/*! crypto-js/md5 */ "./node_modules/crypto-js/md5.js"));
// @ts-ignore
var jsencrypt_js_1 = __importDefault(__nested_webpack_require_1592409__(/*! ./jsencrypt.js */ "./sdk/util/jsencrypt.js"));
var Crypto = /** @class */ (function () {
    function Crypto() {
    }
    Object.defineProperty(Crypto.prototype, "publicKey", {
        get: function () {
            return "-----BEGIN PUBLIC KEY-----\n        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxtEM51skf+Bg29Mdb+WN\n        IkgbGDZ/wOP4MTntlut65WpPpXOkg2m9EKscmzfE6kUNLYnYV77fZGFSjr+Wkmoz\n        VK1lJ3seswBNyP6X5LUszkf1WoeEyBbfegTf3XkHEeWJ5BlD9syurlA2Fh+cTaNO\n        RNlAGBZO7SdgTHPYAcHu0fAnJZwCZ9+ZZkVnjyTBqQckovMttKqvtoUKcp7NgGve\n        w0OJxFKwIITu1keGdZ+yN9wBul4qJfTy8otOcwGL4bnoABMhCNvJc3xA70BuaaF0\n        fvhxA8diV/2W+qg+LAzdqajLaNciuDHIY5Y+z5kZI1eBa3J3aqUASse4YzzTYv48\n        7wIDAQAB\n        -----END PUBLIC KEY-----";
        },
        enumerable: false,
        configurable: true
    });
    /**
     *  ArrayBuffer
     *
     * @param body  ArrayBuffer
     */
    Crypto.prototype.encrypt = function (body) {
        var base64 = aes_1.default.encrypt(this.uint8Array2WordArray(body), this.key2, { iv: this.iv2 }).toString();
        return js_base64_1.Base64.toUint8Array(base64);
    };
    /**
     *  ArrayBuffer
     *
     * @param body  ArrayBuffer
     */
    Crypto.prototype.decrypt = function (body) {
        return this.wordArray2Uint8Array(aes_1.default.decrypt(js_base64_1.Base64.fromUint8Array(body), this.key2, { iv: this.iv2 }));
    };
    /**
     *  K1  RSA 
     *
     * 
     */
    Crypto.prototype.generateK1Sign = function () {
        var k1 = this.generateNonce();
        this.key1 = enc_utf8_1.default.parse(k1);
        this.iv1 = enc_hex_1.default.parse(md5_1.default(k1)
            .toString()
            .toLowerCase());
        var encrypt = new jsencrypt_js_1.default();
        encrypt.setPublicKey(this.publicKey);
        var hex = encrypt.getKey().encrypt(k1);
        var bytes = this.wordArray2Uint8Array(enc_hex_1.default.parse(hex));
        return bytes;
    };
    /**
     * AES  k1  k2Sign
     *
     *  body k2 
     */
    Crypto.prototype.decryptK2Sign = function (k2Sign) {
        try {
            this.key2 = aes_1.default.decrypt(js_base64_1.Base64.fromUint8Array(k2Sign), this.key1, { iv: this.iv1 });
            this.iv2 = md5_1.default(this.key2);
        }
        catch (error) { }
    };
    /**
     *  16 
     */
    Crypto.prototype.generateNonce = function () {
        var str = Math.random()
            .toString()
            .substr(2, 16);
        if (str.length < 16)
            str += str.substr(0, 16 - str.length);
        return str;
    };
    Crypto.prototype.md5 = function (str) {
        return md5_1.default(str).toString();
    };
    Crypto.prototype.md5Bytes = function (bytes) {
        return this.wordArray2Uint8Array(md5_1.default(this.uint8Array2WordArray(bytes)));
    };
    Crypto.prototype.wordArray2Uint8Array = function (wordArray) {
        var words = wordArray.words;
        var sigBytes = wordArray.sigBytes;
        var u8arr = new Uint8Array(sigBytes);
        for (var i = 0; i < sigBytes; i++) {
            var byte = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
            u8arr[i] = byte;
        }
        return u8arr;
    };
    Crypto.prototype.uint8Array2WordArray = function (u8arr) {
        var sigBytes = u8arr.length;
        var words = [];
        for (var i = 0; i < sigBytes; i++) {
            words[i >>> 2] |= (u8arr[i] & 0xff) << (24 - (i % 4) * 8);
        }
        return lib_typedarrays_1.default.create(words, sigBytes);
    };
    return Crypto;
}());
exports.Crypto = Crypto;


/***/ }),

/***/ "./sdk/util/jsencrypt.js":
/*!*******************************!*\
  !*** ./sdk/util/jsencrypt.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_1597297__) {

"use strict";
__nested_webpack_require_1597297__.r(__webpack_exports__);
var t = [
        ,
        (t, e, i) => {
            function r(t) {
                return '0123456789abcdefghijklmnopqrstuvwxyz'.charAt(t);
            }
            function n(t, e) {
                return t & e;
            }
            function s(t, e) {
                return t | e;
            }
            function o(t, e) {
                return t ^ e;
            }
            function h(t, e) {
                return t & ~e;
            }
            function a(t) {
                if (0 == t) return -1;
                var e = 0;
                return (
                    0 == (65535 & t) && ((t >>= 16), (e += 16)),
                    0 == (255 & t) && ((t >>= 8), (e += 8)),
                    0 == (15 & t) && ((t >>= 4), (e += 4)),
                    0 == (3 & t) && ((t >>= 2), (e += 2)),
                    0 == (1 & t) && ++e,
                    e
                );
            }
            function u(t) {
                for (var e = 0; 0 != t; ) (t &= t - 1), ++e;
                return e;
            }
            i.d(e, { default: () => nt });
            var c,
                f = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
            function l(t) {
                var e,
                    i,
                    r = '';
                for (e = 0; e + 3 <= t.length; e += 3)
                    (i = parseInt(t.substring(e, e + 3), 16)), (r += f.charAt(i >> 6) + f.charAt(63 & i));
                for (
                    e + 1 == t.length
                        ? ((i = parseInt(t.substring(e, e + 1), 16)), (r += f.charAt(i << 2)))
                        : e + 2 == t.length &&
                          ((i = parseInt(t.substring(e, e + 2), 16)), (r += f.charAt(i >> 2) + f.charAt((3 & i) << 4)));
                    (3 & r.length) > 0;

                )
                    r += '=';
                return r;
            }
            function p(t) {
                var e,
                    i = '',
                    n = 0,
                    s = 0;
                for (e = 0; e < t.length && '=' != t.charAt(e); ++e) {
                    var o = f.indexOf(t.charAt(e));
                    o < 0 ||
                        (0 == n
                            ? ((i += r(o >> 2)), (s = 3 & o), (n = 1))
                            : 1 == n
                            ? ((i += r((s << 2) | (o >> 4))), (s = 15 & o), (n = 2))
                            : 2 == n
                            ? ((i += r(s)), (i += r(o >> 2)), (s = 3 & o), (n = 3))
                            : ((i += r((s << 2) | (o >> 4))), (i += r(15 & o)), (n = 0)));
                }
                return 1 == n && (i += r(s << 2)), i;
            }
            var g,
                d = {
                    decode: function (t) {
                        var e;
                        if (void 0 === g) {
                            var i = '= \f\n\r\t\u2028\u2029';
                            for (g = Object.create(null), e = 0; e < 64; ++e)
                                g['ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.charAt(e)] = e;
                            for (g['-'] = 62, g._ = 63, e = 0; e < i.length; ++e) g[i.charAt(e)] = -1;
                        }
                        var r = [],
                            n = 0,
                            s = 0;
                        for (e = 0; e < t.length; ++e) {
                            var o = t.charAt(e);
                            if ('=' == o) break;
                            if (-1 != (o = g[o])) {
                                if (void 0 === o) throw new Error('Illegal character at offset ' + e);
                                (n |= o),
                                    ++s >= 4
                                        ? ((r[r.length] = n >> 16),
                                          (r[r.length] = (n >> 8) & 255),
                                          (r[r.length] = 255 & n),
                                          (n = 0),
                                          (s = 0))
                                        : (n <<= 6);
                            }
                        }
                        switch (s) {
                            case 1:
                                throw new Error('Base64 encoding incomplete: at least 2 bits missing');
                            case 2:
                                r[r.length] = n >> 10;
                                break;
                            case 3:
                                (r[r.length] = n >> 16), (r[r.length] = (n >> 8) & 255);
                        }
                        return r;
                    },
                    re: /-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/,
                    unarmor: function (t) {
                        var e = d.re.exec(t);
                        if (e)
                            if (e[1]) t = e[1];
                            else {
                                if (!e[2]) throw new Error('RegExp out of sync');
                                t = e[2];
                            }
                        return d.decode(t);
                    },
                },
                v = 1e13,
                m = (function () {
                    function t(t) {
                        this.buf = [+t || 0];
                    }
                    return (
                        (t.prototype.mulAdd = function (t, e) {
                            var i,
                                r,
                                n = this.buf,
                                s = n.length;
                            for (i = 0; i < s; ++i)
                                (r = n[i] * t + e) < v ? (e = 0) : (r -= (e = 0 | (r / v)) * v), (n[i] = r);
                            e > 0 && (n[i] = e);
                        }),
                        (t.prototype.sub = function (t) {
                            var e,
                                i,
                                r = this.buf,
                                n = r.length;
                            for (e = 0; e < n; ++e) (i = r[e] - t) < 0 ? ((i += v), (t = 1)) : (t = 0), (r[e] = i);
                            for (; 0 === r[r.length - 1]; ) r.pop();
                        }),
                        (t.prototype.toString = function (t) {
                            if (10 != (t || 10)) throw new Error('only base 10 is supported');
                            for (var e = this.buf, i = e[e.length - 1].toString(), r = e.length - 2; r >= 0; --r)
                                i += (v + e[r]).toString().substring(1);
                            return i;
                        }),
                        (t.prototype.valueOf = function () {
                            for (var t = this.buf, e = 0, i = t.length - 1; i >= 0; --i) e = e * v + t[i];
                            return e;
                        }),
                        (t.prototype.simplify = function () {
                            var t = this.buf;
                            return 1 == t.length ? t[0] : this;
                        }),
                        t
                    );
                })(),
                y = /^(\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/,
                b = /^(\d\d\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
            function T(t, e) {
                return t.length > e && (t = t.substring(0, e) + ''), t;
            }
            var S,
                E = (function () {
                    function t(e, i) {
                        (this.hexDigits = '0123456789ABCDEF'),
                            e instanceof t
                                ? ((this.enc = e.enc), (this.pos = e.pos))
                                : ((this.enc = e), (this.pos = i));
                    }
                    return (
                        (t.prototype.get = function (t) {
                            if ((void 0 === t && (t = this.pos++), t >= this.enc.length))
                                throw new Error(
                                    'Requesting byte offset ' + t + ' on a stream of length ' + this.enc.length,
                                );
                            return 'string' == typeof this.enc ? this.enc.charCodeAt(t) : this.enc[t];
                        }),
                        (t.prototype.hexByte = function (t) {
                            return this.hexDigits.charAt((t >> 4) & 15) + this.hexDigits.charAt(15 & t);
                        }),
                        (t.prototype.hexDump = function (t, e, i) {
                            for (var r = '', n = t; n < e; ++n)
                                if (((r += this.hexByte(this.get(n))), !0 !== i))
                                    switch (15 & n) {
                                        case 7:
                                            r += '  ';
                                            break;
                                        case 15:
                                            r += '\n';
                                            break;
                                        default:
                                            r += ' ';
                                    }
                            return r;
                        }),
                        (t.prototype.isASCII = function (t, e) {
                            for (var i = t; i < e; ++i) {
                                var r = this.get(i);
                                if (r < 32 || r > 176) return !1;
                            }
                            return !0;
                        }),
                        (t.prototype.parseStringISO = function (t, e) {
                            for (var i = '', r = t; r < e; ++r) i += String.fromCharCode(this.get(r));
                            return i;
                        }),
                        (t.prototype.parseStringUTF = function (t, e) {
                            for (var i = '', r = t; r < e; ) {
                                var n = this.get(r++);
                                i +=
                                    n < 128
                                        ? String.fromCharCode(n)
                                        : n > 191 && n < 224
                                        ? String.fromCharCode(((31 & n) << 6) | (63 & this.get(r++)))
                                        : String.fromCharCode(
                                              ((15 & n) << 12) | ((63 & this.get(r++)) << 6) | (63 & this.get(r++)),
                                          );
                            }
                            return i;
                        }),
                        (t.prototype.parseStringBMP = function (t, e) {
                            for (var i, r, n = '', s = t; s < e; )
                                (i = this.get(s++)), (r = this.get(s++)), (n += String.fromCharCode((i << 8) | r));
                            return n;
                        }),
                        (t.prototype.parseTime = function (t, e, i) {
                            var r = this.parseStringISO(t, e),
                                n = (i ? y : b).exec(r);
                            return n
                                ? (i && ((n[1] = +n[1]), (n[1] += +n[1] < 70 ? 2e3 : 1900)),
                                  (r = n[1] + '-' + n[2] + '-' + n[3] + ' ' + n[4]),
                                  n[5] && ((r += ':' + n[5]), n[6] && ((r += ':' + n[6]), n[7] && (r += '.' + n[7]))),
                                  n[8] && ((r += ' UTC'), 'Z' != n[8] && ((r += n[8]), n[9] && (r += ':' + n[9]))),
                                  r)
                                : 'Unrecognized time: ' + r;
                        }),
                        (t.prototype.parseInteger = function (t, e) {
                            for (var i, r = this.get(t), n = r > 127, s = n ? 255 : 0, o = ''; r == s && ++t < e; )
                                r = this.get(t);
                            if (0 == (i = e - t)) return n ? -1 : 0;
                            if (i > 4) {
                                for (o = r, i <<= 3; 0 == (128 & (+o ^ s)); ) (o = +o << 1), --i;
                                o = '(' + i + ' bit)\n';
                            }
                            n && (r -= 256);
                            for (var h = new m(r), a = t + 1; a < e; ++a) h.mulAdd(256, this.get(a));
                            return o + h.toString();
                        }),
                        (t.prototype.parseBitString = function (t, e, i) {
                            for (
                                var r = this.get(t), n = '(' + (((e - t - 1) << 3) - r) + ' bit)\n', s = '', o = t + 1;
                                o < e;
                                ++o
                            ) {
                                for (var h = this.get(o), a = o == e - 1 ? r : 0, u = 7; u >= a; --u)
                                    s += (h >> u) & 1 ? '1' : '0';
                                if (s.length > i) return n + T(s, i);
                            }
                            return n + s;
                        }),
                        (t.prototype.parseOctetString = function (t, e, i) {
                            if (this.isASCII(t, e)) return T(this.parseStringISO(t, e), i);
                            var r = e - t,
                                n = '(' + r + ' byte)\n';
                            r > (i /= 2) && (e = t + i);
                            for (var s = t; s < e; ++s) n += this.hexByte(this.get(s));
                            return r > i && (n += ''), n;
                        }),
                        (t.prototype.parseOID = function (t, e, i) {
                            for (var r = '', n = new m(), s = 0, o = t; o < e; ++o) {
                                var h = this.get(o);
                                if ((n.mulAdd(128, 127 & h), (s += 7), !(128 & h))) {
                                    if ('' === r)
                                        if ((n = n.simplify()) instanceof m) n.sub(80), (r = '2.' + n.toString());
                                        else {
                                            var a = n < 80 ? (n < 40 ? 0 : 1) : 2;
                                            r = a + '.' + (n - 40 * a);
                                        }
                                    else r += '.' + n.toString();
                                    if (r.length > i) return T(r, i);
                                    (n = new m()), (s = 0);
                                }
                            }
                            return s > 0 && (r += '.incomplete'), r;
                        }),
                        t
                    );
                })(),
                w = (function () {
                    function t(t, e, i, r, n) {
                        if (!(r instanceof D)) throw new Error('Invalid tag value.');
                        (this.stream = t), (this.header = e), (this.length = i), (this.tag = r), (this.sub = n);
                    }
                    return (
                        (t.prototype.typeName = function () {
                            switch (this.tag.tagClass) {
                                case 0:
                                    switch (this.tag.tagNumber) {
                                        case 0:
                                            return 'EOC';
                                        case 1:
                                            return 'BOOLEAN';
                                        case 2:
                                            return 'INTEGER';
                                        case 3:
                                            return 'BIT_STRING';
                                        case 4:
                                            return 'OCTET_STRING';
                                        case 5:
                                            return 'NULL';
                                        case 6:
                                            return 'OBJECT_IDENTIFIER';
                                        case 7:
                                            return 'ObjectDescriptor';
                                        case 8:
                                            return 'EXTERNAL';
                                        case 9:
                                            return 'REAL';
                                        case 10:
                                            return 'ENUMERATED';
                                        case 11:
                                            return 'EMBEDDED_PDV';
                                        case 12:
                                            return 'UTF8String';
                                        case 16:
                                            return 'SEQUENCE';
                                        case 17:
                                            return 'SET';
                                        case 18:
                                            return 'NumericString';
                                        case 19:
                                            return 'PrintableString';
                                        case 20:
                                            return 'TeletexString';
                                        case 21:
                                            return 'VideotexString';
                                        case 22:
                                            return 'IA5String';
                                        case 23:
                                            return 'UTCTime';
                                        case 24:
                                            return 'GeneralizedTime';
                                        case 25:
                                            return 'GraphicString';
                                        case 26:
                                            return 'VisibleString';
                                        case 27:
                                            return 'GeneralString';
                                        case 28:
                                            return 'UniversalString';
                                        case 30:
                                            return 'BMPString';
                                    }
                                    return 'Universal_' + this.tag.tagNumber.toString();
                                case 1:
                                    return 'Application_' + this.tag.tagNumber.toString();
                                case 2:
                                    return '[' + this.tag.tagNumber.toString() + ']';
                                case 3:
                                    return 'Private_' + this.tag.tagNumber.toString();
                            }
                        }),
                        (t.prototype.content = function (t) {
                            if (void 0 === this.tag) return null;
                            void 0 === t && (t = 1 / 0);
                            var e = this.posContent(),
                                i = Math.abs(this.length);
                            if (!this.tag.isUniversal())
                                return null !== this.sub
                                    ? '(' + this.sub.length + ' elem)'
                                    : this.stream.parseOctetString(e, e + i, t);
                            switch (this.tag.tagNumber) {
                                case 1:
                                    return 0 === this.stream.get(e) ? 'false' : 'true';
                                case 2:
                                    return this.stream.parseInteger(e, e + i);
                                case 3:
                                    return this.sub
                                        ? '(' + this.sub.length + ' elem)'
                                        : this.stream.parseBitString(e, e + i, t);
                                case 4:
                                    return this.sub
                                        ? '(' + this.sub.length + ' elem)'
                                        : this.stream.parseOctetString(e, e + i, t);
                                case 6:
                                    return this.stream.parseOID(e, e + i, t);
                                case 16:
                                case 17:
                                    return null !== this.sub ? '(' + this.sub.length + ' elem)' : '(no elem)';
                                case 12:
                                    return T(this.stream.parseStringUTF(e, e + i), t);
                                case 18:
                                case 19:
                                case 20:
                                case 21:
                                case 22:
                                case 26:
                                    return T(this.stream.parseStringISO(e, e + i), t);
                                case 30:
                                    return T(this.stream.parseStringBMP(e, e + i), t);
                                case 23:
                                case 24:
                                    return this.stream.parseTime(e, e + i, 23 == this.tag.tagNumber);
                            }
                            return null;
                        }),
                        (t.prototype.toString = function () {
                            return (
                                this.typeName() +
                                '@' +
                                this.stream.pos +
                                '[header:' +
                                this.header +
                                ',length:' +
                                this.length +
                                ',sub:' +
                                (null === this.sub ? 'null' : this.sub.length) +
                                ']'
                            );
                        }),
                        (t.prototype.toPrettyString = function (t) {
                            void 0 === t && (t = '');
                            var e = t + this.typeName() + ' @' + this.stream.pos;
                            if (
                                (this.length >= 0 && (e += '+'),
                                (e += this.length),
                                this.tag.tagConstructed
                                    ? (e += ' (constructed)')
                                    : !this.tag.isUniversal() ||
                                      (3 != this.tag.tagNumber && 4 != this.tag.tagNumber) ||
                                      null === this.sub ||
                                      (e += ' (encapsulates)'),
                                (e += '\n'),
                                null !== this.sub)
                            ) {
                                t += '  ';
                                for (var i = 0, r = this.sub.length; i < r; ++i) e += this.sub[i].toPrettyString(t);
                            }
                            return e;
                        }),
                        (t.prototype.posStart = function () {
                            return this.stream.pos;
                        }),
                        (t.prototype.posContent = function () {
                            return this.stream.pos + this.header;
                        }),
                        (t.prototype.posEnd = function () {
                            return this.stream.pos + this.header + Math.abs(this.length);
                        }),
                        (t.prototype.toHexString = function () {
                            return this.stream.hexDump(this.posStart(), this.posEnd(), !0);
                        }),
                        (t.decodeLength = function (t) {
                            var e = t.get(),
                                i = 127 & e;
                            if (i == e) return i;
                            if (i > 6) throw new Error('Length over 48 bits not supported at position ' + (t.pos - 1));
                            if (0 === i) return null;
                            e = 0;
                            for (var r = 0; r < i; ++r) e = 256 * e + t.get();
                            return e;
                        }),
                        (t.prototype.getHexStringValue = function () {
                            var t = this.toHexString(),
                                e = 2 * this.header,
                                i = 2 * this.length;
                            return t.substr(e, i);
                        }),
                        (t.decode = function (e) {
                            var i;
                            i = e instanceof E ? e : new E(e, 0);
                            var r = new E(i),
                                n = new D(i),
                                s = t.decodeLength(i),
                                o = i.pos,
                                h = o - r.pos,
                                a = null,
                                u = function () {
                                    var e = [];
                                    if (null !== s) {
                                        for (var r = o + s; i.pos < r; ) e[e.length] = t.decode(i);
                                        if (i.pos != r)
                                            throw new Error(
                                                'Content size is not correct for container starting at offset ' + o,
                                            );
                                    } else
                                        try {
                                            for (;;) {
                                                var n = t.decode(i);
                                                if (n.tag.isEOC()) break;
                                                e[e.length] = n;
                                            }
                                            s = o - i.pos;
                                        } catch (t) {
                                            throw new Error('Exception while decoding undefined length content: ' + t);
                                        }
                                    return e;
                                };
                            if (n.tagConstructed) a = u();
                            else if (n.isUniversal() && (3 == n.tagNumber || 4 == n.tagNumber))
                                try {
                                    if (3 == n.tagNumber && 0 != i.get())
                                        throw new Error('BIT STRINGs with unused bits cannot encapsulate.');
                                    a = u();
                                    for (var c = 0; c < a.length; ++c)
                                        if (a[c].tag.isEOC())
                                            throw new Error('EOC is not supposed to be actual content.');
                                } catch (t) {
                                    a = null;
                                }
                            if (null === a) {
                                if (null === s)
                                    throw new Error(
                                        "We can't skip over an invalid tag with undefined length at offset " + o,
                                    );
                                i.pos = o + Math.abs(s);
                            }
                            return new t(r, h, s, n, a);
                        }),
                        t
                    );
                })(),
                D = (function () {
                    function t(t) {
                        var e = t.get();
                        if (
                            ((this.tagClass = e >> 6),
                            (this.tagConstructed = 0 != (32 & e)),
                            (this.tagNumber = 31 & e),
                            31 == this.tagNumber)
                        ) {
                            var i = new m();
                            do {
                                (e = t.get()), i.mulAdd(128, 127 & e);
                            } while (128 & e);
                            this.tagNumber = i.simplify();
                        }
                    }
                    return (
                        (t.prototype.isUniversal = function () {
                            return 0 === this.tagClass;
                        }),
                        (t.prototype.isEOC = function () {
                            return 0 === this.tagClass && 0 === this.tagNumber;
                        }),
                        t
                    );
                })(),
                x = [
                    2,
                    3,
                    5,
                    7,
                    11,
                    13,
                    17,
                    19,
                    23,
                    29,
                    31,
                    37,
                    41,
                    43,
                    47,
                    53,
                    59,
                    61,
                    67,
                    71,
                    73,
                    79,
                    83,
                    89,
                    97,
                    101,
                    103,
                    107,
                    109,
                    113,
                    127,
                    131,
                    137,
                    139,
                    149,
                    151,
                    157,
                    163,
                    167,
                    173,
                    179,
                    181,
                    191,
                    193,
                    197,
                    199,
                    211,
                    223,
                    227,
                    229,
                    233,
                    239,
                    241,
                    251,
                    257,
                    263,
                    269,
                    271,
                    277,
                    281,
                    283,
                    293,
                    307,
                    311,
                    313,
                    317,
                    331,
                    337,
                    347,
                    349,
                    353,
                    359,
                    367,
                    373,
                    379,
                    383,
                    389,
                    397,
                    401,
                    409,
                    419,
                    421,
                    431,
                    433,
                    439,
                    443,
                    449,
                    457,
                    461,
                    463,
                    467,
                    479,
                    487,
                    491,
                    499,
                    503,
                    509,
                    521,
                    523,
                    541,
                    547,
                    557,
                    563,
                    569,
                    571,
                    577,
                    587,
                    593,
                    599,
                    601,
                    607,
                    613,
                    617,
                    619,
                    631,
                    641,
                    643,
                    647,
                    653,
                    659,
                    661,
                    673,
                    677,
                    683,
                    691,
                    701,
                    709,
                    719,
                    727,
                    733,
                    739,
                    743,
                    751,
                    757,
                    761,
                    769,
                    773,
                    787,
                    797,
                    809,
                    811,
                    821,
                    823,
                    827,
                    829,
                    839,
                    853,
                    857,
                    859,
                    863,
                    877,
                    881,
                    883,
                    887,
                    907,
                    911,
                    919,
                    929,
                    937,
                    941,
                    947,
                    953,
                    967,
                    971,
                    977,
                    983,
                    991,
                    997,
                ],
                R = (1 << 26) / x[x.length - 1],
                B = (function () {
                    function t(t, e, i) {
                        null != t &&
                            ('number' == typeof t
                                ? this.fromNumber(t, e, i)
                                : null == e && 'string' != typeof t
                                ? this.fromString(t, 256)
                                : this.fromString(t, e));
                    }
                    return (
                        (t.prototype.toString = function (t) {
                            if (this.s < 0) return '-' + this.negate().toString(t);
                            var e;
                            if (16 == t) e = 4;
                            else if (8 == t) e = 3;
                            else if (2 == t) e = 1;
                            else if (32 == t) e = 5;
                            else {
                                if (4 != t) return this.toRadix(t);
                                e = 2;
                            }
                            var i,
                                n = (1 << e) - 1,
                                s = !1,
                                o = '',
                                h = this.t,
                                a = this.DB - ((h * this.DB) % e);
                            if (h-- > 0)
                                for (a < this.DB && (i = this[h] >> a) > 0 && ((s = !0), (o = r(i))); h >= 0; )
                                    a < e
                                        ? ((i = (this[h] & ((1 << a) - 1)) << (e - a)),
                                          (i |= this[--h] >> (a += this.DB - e)))
                                        : ((i = (this[h] >> (a -= e)) & n), a <= 0 && ((a += this.DB), --h)),
                                        i > 0 && (s = !0),
                                        s && (o += r(i));
                            return s ? o : '0';
                        }),
                        (t.prototype.negate = function () {
                            var e = N();
                            return t.ZERO.subTo(this, e), e;
                        }),
                        (t.prototype.abs = function () {
                            return this.s < 0 ? this.negate() : this;
                        }),
                        (t.prototype.compareTo = function (t) {
                            var e = this.s - t.s;
                            if (0 != e) return e;
                            var i = this.t;
                            if (0 != (e = i - t.t)) return this.s < 0 ? -e : e;
                            for (; --i >= 0; ) if (0 != (e = this[i] - t[i])) return e;
                            return 0;
                        }),
                        (t.prototype.bitLength = function () {
                            return this.t <= 0 ? 0 : this.DB * (this.t - 1) + F(this[this.t - 1] ^ (this.s & this.DM));
                        }),
                        (t.prototype.mod = function (e) {
                            var i = N();
                            return (
                                this.abs().divRemTo(e, null, i),
                                this.s < 0 && i.compareTo(t.ZERO) > 0 && e.subTo(i, i),
                                i
                            );
                        }),
                        (t.prototype.modPowInt = function (t, e) {
                            var i;
                            return (i = t < 256 || e.isEven() ? new A(e) : new V(e)), this.exp(t, i);
                        }),
                        (t.prototype.clone = function () {
                            var t = N();
                            return this.copyTo(t), t;
                        }),
                        (t.prototype.intValue = function () {
                            if (this.s < 0) {
                                if (1 == this.t) return this[0] - this.DV;
                                if (0 == this.t) return -1;
                            } else {
                                if (1 == this.t) return this[0];
                                if (0 == this.t) return 0;
                            }
                            return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
                        }),
                        (t.prototype.byteValue = function () {
                            return 0 == this.t ? this.s : (this[0] << 24) >> 24;
                        }),
                        (t.prototype.shortValue = function () {
                            return 0 == this.t ? this.s : (this[0] << 16) >> 16;
                        }),
                        (t.prototype.signum = function () {
                            return this.s < 0 ? -1 : this.t <= 0 || (1 == this.t && this[0] <= 0) ? 0 : 1;
                        }),
                        (t.prototype.toByteArray = function () {
                            var t = this.t,
                                e = [];
                            e[0] = this.s;
                            var i,
                                r = this.DB - ((t * this.DB) % 8),
                                n = 0;
                            if (t-- > 0)
                                for (
                                    r < this.DB &&
                                    (i = this[t] >> r) != (this.s & this.DM) >> r &&
                                    (e[n++] = i | (this.s << (this.DB - r)));
                                    t >= 0;

                                )
                                    r < 8
                                        ? ((i = (this[t] & ((1 << r) - 1)) << (8 - r)),
                                          (i |= this[--t] >> (r += this.DB - 8)))
                                        : ((i = (this[t] >> (r -= 8)) & 255), r <= 0 && ((r += this.DB), --t)),
                                        0 != (128 & i) && (i |= -256),
                                        0 == n && (128 & this.s) != (128 & i) && ++n,
                                        (n > 0 || i != this.s) && (e[n++] = i);
                            return e;
                        }),
                        (t.prototype.equals = function (t) {
                            return 0 == this.compareTo(t);
                        }),
                        (t.prototype.min = function (t) {
                            return this.compareTo(t) < 0 ? this : t;
                        }),
                        (t.prototype.max = function (t) {
                            return this.compareTo(t) > 0 ? this : t;
                        }),
                        (t.prototype.and = function (t) {
                            var e = N();
                            return this.bitwiseTo(t, n, e), e;
                        }),
                        (t.prototype.or = function (t) {
                            var e = N();
                            return this.bitwiseTo(t, s, e), e;
                        }),
                        (t.prototype.xor = function (t) {
                            var e = N();
                            return this.bitwiseTo(t, o, e), e;
                        }),
                        (t.prototype.andNot = function (t) {
                            var e = N();
                            return this.bitwiseTo(t, h, e), e;
                        }),
                        (t.prototype.not = function () {
                            for (var t = N(), e = 0; e < this.t; ++e) t[e] = this.DM & ~this[e];
                            return (t.t = this.t), (t.s = ~this.s), t;
                        }),
                        (t.prototype.shiftLeft = function (t) {
                            var e = N();
                            return t < 0 ? this.rShiftTo(-t, e) : this.lShiftTo(t, e), e;
                        }),
                        (t.prototype.shiftRight = function (t) {
                            var e = N();
                            return t < 0 ? this.lShiftTo(-t, e) : this.rShiftTo(t, e), e;
                        }),
                        (t.prototype.getLowestSetBit = function () {
                            for (var t = 0; t < this.t; ++t) if (0 != this[t]) return t * this.DB + a(this[t]);
                            return this.s < 0 ? this.t * this.DB : -1;
                        }),
                        (t.prototype.bitCount = function () {
                            for (var t = 0, e = this.s & this.DM, i = 0; i < this.t; ++i) t += u(this[i] ^ e);
                            return t;
                        }),
                        (t.prototype.testBit = function (t) {
                            var e = Math.floor(t / this.DB);
                            return e >= this.t ? 0 != this.s : 0 != (this[e] & (1 << t % this.DB));
                        }),
                        (t.prototype.setBit = function (t) {
                            return this.changeBit(t, s);
                        }),
                        (t.prototype.clearBit = function (t) {
                            return this.changeBit(t, h);
                        }),
                        (t.prototype.flipBit = function (t) {
                            return this.changeBit(t, o);
                        }),
                        (t.prototype.add = function (t) {
                            var e = N();
                            return this.addTo(t, e), e;
                        }),
                        (t.prototype.subtract = function (t) {
                            var e = N();
                            return this.subTo(t, e), e;
                        }),
                        (t.prototype.multiply = function (t) {
                            var e = N();
                            return this.multiplyTo(t, e), e;
                        }),
                        (t.prototype.divide = function (t) {
                            var e = N();
                            return this.divRemTo(t, e, null), e;
                        }),
                        (t.prototype.remainder = function (t) {
                            var e = N();
                            return this.divRemTo(t, null, e), e;
                        }),
                        (t.prototype.divideAndRemainder = function (t) {
                            var e = N(),
                                i = N();
                            return this.divRemTo(t, e, i), [e, i];
                        }),
                        (t.prototype.modPow = function (t, e) {
                            var i,
                                r,
                                n = t.bitLength(),
                                s = C(1);
                            if (n <= 0) return s;
                            (i = n < 18 ? 1 : n < 48 ? 3 : n < 144 ? 4 : n < 768 ? 5 : 6),
                                (r = n < 8 ? new A(e) : e.isEven() ? new I(e) : new V(e));
                            var o = [],
                                h = 3,
                                a = i - 1,
                                u = (1 << i) - 1;
                            if (((o[1] = r.convert(this)), i > 1)) {
                                var c = N();
                                for (r.sqrTo(o[1], c); h <= u; ) (o[h] = N()), r.mulTo(c, o[h - 2], o[h]), (h += 2);
                            }
                            var f,
                                l,
                                p = t.t - 1,
                                g = !0,
                                d = N();
                            for (n = F(t[p]) - 1; p >= 0; ) {
                                for (
                                    n >= a
                                        ? (f = (t[p] >> (n - a)) & u)
                                        : ((f = (t[p] & ((1 << (n + 1)) - 1)) << (a - n)),
                                          p > 0 && (f |= t[p - 1] >> (this.DB + n - a))),
                                        h = i;
                                    0 == (1 & f);

                                )
                                    (f >>= 1), --h;
                                if (((n -= h) < 0 && ((n += this.DB), --p), g)) o[f].copyTo(s), (g = !1);
                                else {
                                    for (; h > 1; ) r.sqrTo(s, d), r.sqrTo(d, s), (h -= 2);
                                    h > 0 ? r.sqrTo(s, d) : ((l = s), (s = d), (d = l)), r.mulTo(d, o[f], s);
                                }
                                for (; p >= 0 && 0 == (t[p] & (1 << n)); )
                                    r.sqrTo(s, d), (l = s), (s = d), (d = l), --n < 0 && ((n = this.DB - 1), --p);
                            }
                            return r.revert(s);
                        }),
                        (t.prototype.modInverse = function (e) {
                            var i = e.isEven();
                            if ((this.isEven() && i) || 0 == e.signum()) return t.ZERO;
                            for (
                                var r = e.clone(), n = this.clone(), s = C(1), o = C(0), h = C(0), a = C(1);
                                0 != r.signum();

                            ) {
                                for (; r.isEven(); )
                                    r.rShiftTo(1, r),
                                        i
                                            ? ((s.isEven() && o.isEven()) || (s.addTo(this, s), o.subTo(e, o)),
                                              s.rShiftTo(1, s))
                                            : o.isEven() || o.subTo(e, o),
                                        o.rShiftTo(1, o);
                                for (; n.isEven(); )
                                    n.rShiftTo(1, n),
                                        i
                                            ? ((h.isEven() && a.isEven()) || (h.addTo(this, h), a.subTo(e, a)),
                                              h.rShiftTo(1, h))
                                            : a.isEven() || a.subTo(e, a),
                                        a.rShiftTo(1, a);
                                r.compareTo(n) >= 0
                                    ? (r.subTo(n, r), i && s.subTo(h, s), o.subTo(a, o))
                                    : (n.subTo(r, n), i && h.subTo(s, h), a.subTo(o, a));
                            }
                            return 0 != n.compareTo(t.ONE)
                                ? t.ZERO
                                : a.compareTo(e) >= 0
                                ? a.subtract(e)
                                : a.signum() < 0
                                ? (a.addTo(e, a), a.signum() < 0 ? a.add(e) : a)
                                : a;
                        }),
                        (t.prototype.pow = function (t) {
                            return this.exp(t, new O());
                        }),
                        (t.prototype.gcd = function (t) {
                            var e = this.s < 0 ? this.negate() : this.clone(),
                                i = t.s < 0 ? t.negate() : t.clone();
                            if (e.compareTo(i) < 0) {
                                var r = e;
                                (e = i), (i = r);
                            }
                            var n = e.getLowestSetBit(),
                                s = i.getLowestSetBit();
                            if (s < 0) return e;
                            for (n < s && (s = n), s > 0 && (e.rShiftTo(s, e), i.rShiftTo(s, i)); e.signum() > 0; )
                                (n = e.getLowestSetBit()) > 0 && e.rShiftTo(n, e),
                                    (n = i.getLowestSetBit()) > 0 && i.rShiftTo(n, i),
                                    e.compareTo(i) >= 0
                                        ? (e.subTo(i, e), e.rShiftTo(1, e))
                                        : (i.subTo(e, i), i.rShiftTo(1, i));
                            return s > 0 && i.lShiftTo(s, i), i;
                        }),
                        (t.prototype.isProbablePrime = function (t) {
                            var e,
                                i = this.abs();
                            if (1 == i.t && i[0] <= x[x.length - 1]) {
                                for (e = 0; e < x.length; ++e) if (i[0] == x[e]) return !0;
                                return !1;
                            }
                            if (i.isEven()) return !1;
                            for (e = 1; e < x.length; ) {
                                for (var r = x[e], n = e + 1; n < x.length && r < R; ) r *= x[n++];
                                for (r = i.modInt(r); e < n; ) if (r % x[e++] == 0) return !1;
                            }
                            return i.millerRabin(t);
                        }),
                        (t.prototype.copyTo = function (t) {
                            for (var e = this.t - 1; e >= 0; --e) t[e] = this[e];
                            (t.t = this.t), (t.s = this.s);
                        }),
                        (t.prototype.fromInt = function (t) {
                            (this.t = 1),
                                (this.s = t < 0 ? -1 : 0),
                                t > 0 ? (this[0] = t) : t < -1 ? (this[0] = t + this.DV) : (this.t = 0);
                        }),
                        (t.prototype.fromString = function (e, i) {
                            var r;
                            if (16 == i) r = 4;
                            else if (8 == i) r = 3;
                            else if (256 == i) r = 8;
                            else if (2 == i) r = 1;
                            else if (32 == i) r = 5;
                            else {
                                if (4 != i) return void this.fromRadix(e, i);
                                r = 2;
                            }
                            (this.t = 0), (this.s = 0);
                            for (var n = e.length, s = !1, o = 0; --n >= 0; ) {
                                var h = 8 == r ? 255 & +e[n] : H(e, n);
                                h < 0
                                    ? '-' == e.charAt(n) && (s = !0)
                                    : ((s = !1),
                                      0 == o
                                          ? (this[this.t++] = h)
                                          : o + r > this.DB
                                          ? ((this[this.t - 1] |= (h & ((1 << (this.DB - o)) - 1)) << o),
                                            (this[this.t++] = h >> (this.DB - o)))
                                          : (this[this.t - 1] |= h << o),
                                      (o += r) >= this.DB && (o -= this.DB));
                            }
                            8 == r &&
                                0 != (128 & +e[0]) &&
                                ((this.s = -1), o > 0 && (this[this.t - 1] |= ((1 << (this.DB - o)) - 1) << o)),
                                this.clamp(),
                                s && t.ZERO.subTo(this, this);
                        }),
                        (t.prototype.clamp = function () {
                            for (var t = this.s & this.DM; this.t > 0 && this[this.t - 1] == t; ) --this.t;
                        }),
                        (t.prototype.dlShiftTo = function (t, e) {
                            var i;
                            for (i = this.t - 1; i >= 0; --i) e[i + t] = this[i];
                            for (i = t - 1; i >= 0; --i) e[i] = 0;
                            (e.t = this.t + t), (e.s = this.s);
                        }),
                        (t.prototype.drShiftTo = function (t, e) {
                            for (var i = t; i < this.t; ++i) e[i - t] = this[i];
                            (e.t = Math.max(this.t - t, 0)), (e.s = this.s);
                        }),
                        (t.prototype.lShiftTo = function (t, e) {
                            for (
                                var i = t % this.DB,
                                    r = this.DB - i,
                                    n = (1 << r) - 1,
                                    s = Math.floor(t / this.DB),
                                    o = (this.s << i) & this.DM,
                                    h = this.t - 1;
                                h >= 0;
                                --h
                            )
                                (e[h + s + 1] = (this[h] >> r) | o), (o = (this[h] & n) << i);
                            for (h = s - 1; h >= 0; --h) e[h] = 0;
                            (e[s] = o), (e.t = this.t + s + 1), (e.s = this.s), e.clamp();
                        }),
                        (t.prototype.rShiftTo = function (t, e) {
                            e.s = this.s;
                            var i = Math.floor(t / this.DB);
                            if (i >= this.t) e.t = 0;
                            else {
                                var r = t % this.DB,
                                    n = this.DB - r,
                                    s = (1 << r) - 1;
                                e[0] = this[i] >> r;
                                for (var o = i + 1; o < this.t; ++o)
                                    (e[o - i - 1] |= (this[o] & s) << n), (e[o - i] = this[o] >> r);
                                r > 0 && (e[this.t - i - 1] |= (this.s & s) << n), (e.t = this.t - i), e.clamp();
                            }
                        }),
                        (t.prototype.subTo = function (t, e) {
                            for (var i = 0, r = 0, n = Math.min(t.t, this.t); i < n; )
                                (r += this[i] - t[i]), (e[i++] = r & this.DM), (r >>= this.DB);
                            if (t.t < this.t) {
                                for (r -= t.s; i < this.t; ) (r += this[i]), (e[i++] = r & this.DM), (r >>= this.DB);
                                r += this.s;
                            } else {
                                for (r += this.s; i < t.t; ) (r -= t[i]), (e[i++] = r & this.DM), (r >>= this.DB);
                                r -= t.s;
                            }
                            (e.s = r < 0 ? -1 : 0),
                                r < -1 ? (e[i++] = this.DV + r) : r > 0 && (e[i++] = r),
                                (e.t = i),
                                e.clamp();
                        }),
                        (t.prototype.multiplyTo = function (e, i) {
                            var r = this.abs(),
                                n = e.abs(),
                                s = r.t;
                            for (i.t = s + n.t; --s >= 0; ) i[s] = 0;
                            for (s = 0; s < n.t; ++s) i[s + r.t] = r.am(0, n[s], i, s, 0, r.t);
                            (i.s = 0), i.clamp(), this.s != e.s && t.ZERO.subTo(i, i);
                        }),
                        (t.prototype.squareTo = function (t) {
                            for (var e = this.abs(), i = (t.t = 2 * e.t); --i >= 0; ) t[i] = 0;
                            for (i = 0; i < e.t - 1; ++i) {
                                var r = e.am(i, e[i], t, 2 * i, 0, 1);
                                (t[i + e.t] += e.am(i + 1, 2 * e[i], t, 2 * i + 1, r, e.t - i - 1)) >= e.DV &&
                                    ((t[i + e.t] -= e.DV), (t[i + e.t + 1] = 1));
                            }
                            t.t > 0 && (t[t.t - 1] += e.am(i, e[i], t, 2 * i, 0, 1)), (t.s = 0), t.clamp();
                        }),
                        (t.prototype.divRemTo = function (e, i, r) {
                            var n = e.abs();
                            if (!(n.t <= 0)) {
                                var s = this.abs();
                                if (s.t < n.t) return null != i && i.fromInt(0), void (null != r && this.copyTo(r));
                                null == r && (r = N());
                                var o = N(),
                                    h = this.s,
                                    a = e.s,
                                    u = this.DB - F(n[n.t - 1]);
                                u > 0 ? (n.lShiftTo(u, o), s.lShiftTo(u, r)) : (n.copyTo(o), s.copyTo(r));
                                var c = o.t,
                                    f = o[c - 1];
                                if (0 != f) {
                                    var l = f * (1 << this.F1) + (c > 1 ? o[c - 2] >> this.F2 : 0),
                                        p = this.FV / l,
                                        g = (1 << this.F1) / l,
                                        d = 1 << this.F2,
                                        v = r.t,
                                        m = v - c,
                                        y = null == i ? N() : i;
                                    for (
                                        o.dlShiftTo(m, y),
                                            r.compareTo(y) >= 0 && ((r[r.t++] = 1), r.subTo(y, r)),
                                            t.ONE.dlShiftTo(c, y),
                                            y.subTo(o, o);
                                        o.t < c;

                                    )
                                        o[o.t++] = 0;
                                    for (; --m >= 0; ) {
                                        var b = r[--v] == f ? this.DM : Math.floor(r[v] * p + (r[v - 1] + d) * g);
                                        if ((r[v] += o.am(0, b, r, m, 0, c)) < b)
                                            for (o.dlShiftTo(m, y), r.subTo(y, r); r[v] < --b; ) r.subTo(y, r);
                                    }
                                    null != i && (r.drShiftTo(c, i), h != a && t.ZERO.subTo(i, i)),
                                        (r.t = c),
                                        r.clamp(),
                                        u > 0 && r.rShiftTo(u, r),
                                        h < 0 && t.ZERO.subTo(r, r);
                                }
                            }
                        }),
                        (t.prototype.invDigit = function () {
                            if (this.t < 1) return 0;
                            var t = this[0];
                            if (0 == (1 & t)) return 0;
                            var e = 3 & t;
                            return (e =
                                ((e =
                                    ((e = ((e = (e * (2 - (15 & t) * e)) & 15) * (2 - (255 & t) * e)) & 255) *
                                        (2 - (((65535 & t) * e) & 65535))) &
                                    65535) *
                                    (2 - ((t * e) % this.DV))) %
                                this.DV) > 0
                                ? this.DV - e
                                : -e;
                        }),
                        (t.prototype.isEven = function () {
                            return 0 == (this.t > 0 ? 1 & this[0] : this.s);
                        }),
                        (t.prototype.exp = function (e, i) {
                            if (e > 4294967295 || e < 1) return t.ONE;
                            var r = N(),
                                n = N(),
                                s = i.convert(this),
                                o = F(e) - 1;
                            for (s.copyTo(r); --o >= 0; )
                                if ((i.sqrTo(r, n), (e & (1 << o)) > 0)) i.mulTo(n, s, r);
                                else {
                                    var h = r;
                                    (r = n), (n = h);
                                }
                            return i.revert(r);
                        }),
                        (t.prototype.chunkSize = function (t) {
                            return Math.floor((Math.LN2 * this.DB) / Math.log(t));
                        }),
                        (t.prototype.toRadix = function (t) {
                            if ((null == t && (t = 10), 0 == this.signum() || t < 2 || t > 36)) return '0';
                            var e = this.chunkSize(t),
                                i = Math.pow(t, e),
                                r = C(i),
                                n = N(),
                                s = N(),
                                o = '';
                            for (this.divRemTo(r, n, s); n.signum() > 0; )
                                (o = (i + s.intValue()).toString(t).substr(1) + o), n.divRemTo(r, n, s);
                            return s.intValue().toString(t) + o;
                        }),
                        (t.prototype.fromRadix = function (e, i) {
                            this.fromInt(0), null == i && (i = 10);
                            for (
                                var r = this.chunkSize(i), n = Math.pow(i, r), s = !1, o = 0, h = 0, a = 0;
                                a < e.length;
                                ++a
                            ) {
                                var u = H(e, a);
                                u < 0
                                    ? '-' == e.charAt(a) && 0 == this.signum() && (s = !0)
                                    : ((h = i * h + u),
                                      ++o >= r && (this.dMultiply(n), this.dAddOffset(h, 0), (o = 0), (h = 0)));
                            }
                            o > 0 && (this.dMultiply(Math.pow(i, o)), this.dAddOffset(h, 0)),
                                s && t.ZERO.subTo(this, this);
                        }),
                        (t.prototype.fromNumber = function (e, i, r) {
                            if ('number' == typeof i)
                                if (e < 2) this.fromInt(1);
                                else
                                    for (
                                        this.fromNumber(e, r),
                                            this.testBit(e - 1) || this.bitwiseTo(t.ONE.shiftLeft(e - 1), s, this),
                                            this.isEven() && this.dAddOffset(1, 0);
                                        !this.isProbablePrime(i);

                                    )
                                        this.dAddOffset(2, 0),
                                            this.bitLength() > e && this.subTo(t.ONE.shiftLeft(e - 1), this);
                            else {
                                var n = [],
                                    o = 7 & e;
                                (n.length = 1 + (e >> 3)),
                                    i.nextBytes(n),
                                    o > 0 ? (n[0] &= (1 << o) - 1) : (n[0] = 0),
                                    this.fromString(n, 256);
                            }
                        }),
                        (t.prototype.bitwiseTo = function (t, e, i) {
                            var r,
                                n,
                                s = Math.min(t.t, this.t);
                            for (r = 0; r < s; ++r) i[r] = e(this[r], t[r]);
                            if (t.t < this.t) {
                                for (n = t.s & this.DM, r = s; r < this.t; ++r) i[r] = e(this[r], n);
                                i.t = this.t;
                            } else {
                                for (n = this.s & this.DM, r = s; r < t.t; ++r) i[r] = e(n, t[r]);
                                i.t = t.t;
                            }
                            (i.s = e(this.s, t.s)), i.clamp();
                        }),
                        (t.prototype.changeBit = function (e, i) {
                            var r = t.ONE.shiftLeft(e);
                            return this.bitwiseTo(r, i, r), r;
                        }),
                        (t.prototype.addTo = function (t, e) {
                            for (var i = 0, r = 0, n = Math.min(t.t, this.t); i < n; )
                                (r += this[i] + t[i]), (e[i++] = r & this.DM), (r >>= this.DB);
                            if (t.t < this.t) {
                                for (r += t.s; i < this.t; ) (r += this[i]), (e[i++] = r & this.DM), (r >>= this.DB);
                                r += this.s;
                            } else {
                                for (r += this.s; i < t.t; ) (r += t[i]), (e[i++] = r & this.DM), (r >>= this.DB);
                                r += t.s;
                            }
                            (e.s = r < 0 ? -1 : 0),
                                r > 0 ? (e[i++] = r) : r < -1 && (e[i++] = this.DV + r),
                                (e.t = i),
                                e.clamp();
                        }),
                        (t.prototype.dMultiply = function (t) {
                            (this[this.t] = this.am(0, t - 1, this, 0, 0, this.t)), ++this.t, this.clamp();
                        }),
                        (t.prototype.dAddOffset = function (t, e) {
                            if (0 != t) {
                                for (; this.t <= e; ) this[this.t++] = 0;
                                for (this[e] += t; this[e] >= this.DV; )
                                    (this[e] -= this.DV), ++e >= this.t && (this[this.t++] = 0), ++this[e];
                            }
                        }),
                        (t.prototype.multiplyLowerTo = function (t, e, i) {
                            var r = Math.min(this.t + t.t, e);
                            for (i.s = 0, i.t = r; r > 0; ) i[--r] = 0;
                            for (var n = i.t - this.t; r < n; ++r) i[r + this.t] = this.am(0, t[r], i, r, 0, this.t);
                            for (n = Math.min(t.t, e); r < n; ++r) this.am(0, t[r], i, r, 0, e - r);
                            i.clamp();
                        }),
                        (t.prototype.multiplyUpperTo = function (t, e, i) {
                            --e;
                            var r = (i.t = this.t + t.t - e);
                            for (i.s = 0; --r >= 0; ) i[r] = 0;
                            for (r = Math.max(e - this.t, 0); r < t.t; ++r)
                                i[this.t + r - e] = this.am(e - r, t[r], i, 0, 0, this.t + r - e);
                            i.clamp(), i.drShiftTo(1, i);
                        }),
                        (t.prototype.modInt = function (t) {
                            if (t <= 0) return 0;
                            var e = this.DV % t,
                                i = this.s < 0 ? t - 1 : 0;
                            if (this.t > 0)
                                if (0 == e) i = this[0] % t;
                                else for (var r = this.t - 1; r >= 0; --r) i = (e * i + this[r]) % t;
                            return i;
                        }),
                        (t.prototype.millerRabin = function (e) {
                            var i = this.subtract(t.ONE),
                                r = i.getLowestSetBit();
                            if (r <= 0) return !1;
                            var n = i.shiftRight(r);
                            (e = (e + 1) >> 1) > x.length && (e = x.length);
                            for (var s = N(), o = 0; o < e; ++o) {
                                s.fromInt(x[Math.floor(Math.random() * x.length)]);
                                var h = s.modPow(n, this);
                                if (0 != h.compareTo(t.ONE) && 0 != h.compareTo(i)) {
                                    for (var a = 1; a++ < r && 0 != h.compareTo(i); )
                                        if (0 == (h = h.modPowInt(2, this)).compareTo(t.ONE)) return !1;
                                    if (0 != h.compareTo(i)) return !1;
                                }
                            }
                            return !0;
                        }),
                        (t.prototype.square = function () {
                            var t = N();
                            return this.squareTo(t), t;
                        }),
                        (t.prototype.gcda = function (t, e) {
                            var i = this.s < 0 ? this.negate() : this.clone(),
                                r = t.s < 0 ? t.negate() : t.clone();
                            if (i.compareTo(r) < 0) {
                                var n = i;
                                (i = r), (r = n);
                            }
                            var s = i.getLowestSetBit(),
                                o = r.getLowestSetBit();
                            if (o < 0) e(i);
                            else {
                                s < o && (o = s), o > 0 && (i.rShiftTo(o, i), r.rShiftTo(o, r));
                                var h = function () {
                                    (s = i.getLowestSetBit()) > 0 && i.rShiftTo(s, i),
                                        (s = r.getLowestSetBit()) > 0 && r.rShiftTo(s, r),
                                        i.compareTo(r) >= 0
                                            ? (i.subTo(r, i), i.rShiftTo(1, i))
                                            : (r.subTo(i, r), r.rShiftTo(1, r)),
                                        i.signum() > 0
                                            ? setTimeout(h, 0)
                                            : (o > 0 && r.lShiftTo(o, r),
                                              setTimeout(function () {
                                                  e(r);
                                              }, 0));
                                };
                                setTimeout(h, 10);
                            }
                        }),
                        (t.prototype.fromNumberAsync = function (e, i, r, n) {
                            if ('number' == typeof i)
                                if (e < 2) this.fromInt(1);
                                else {
                                    this.fromNumber(e, r),
                                        this.testBit(e - 1) || this.bitwiseTo(t.ONE.shiftLeft(e - 1), s, this),
                                        this.isEven() && this.dAddOffset(1, 0);
                                    var o = this,
                                        h = function () {
                                            o.dAddOffset(2, 0),
                                                o.bitLength() > e && o.subTo(t.ONE.shiftLeft(e - 1), o),
                                                o.isProbablePrime(i)
                                                    ? setTimeout(function () {
                                                          n();
                                                      }, 0)
                                                    : setTimeout(h, 0);
                                        };
                                    setTimeout(h, 0);
                                }
                            else {
                                var a = [],
                                    u = 7 & e;
                                (a.length = 1 + (e >> 3)),
                                    i.nextBytes(a),
                                    u > 0 ? (a[0] &= (1 << u) - 1) : (a[0] = 0),
                                    this.fromString(a, 256);
                            }
                        }),
                        t
                    );
                })(),
                O = (function () {
                    function t() {}
                    return (
                        (t.prototype.convert = function (t) {
                            return t;
                        }),
                        (t.prototype.revert = function (t) {
                            return t;
                        }),
                        (t.prototype.mulTo = function (t, e, i) {
                            t.multiplyTo(e, i);
                        }),
                        (t.prototype.sqrTo = function (t, e) {
                            t.squareTo(e);
                        }),
                        t
                    );
                })(),
                A = (function () {
                    function t(t) {
                        this.m = t;
                    }
                    return (
                        (t.prototype.convert = function (t) {
                            return t.s < 0 || t.compareTo(this.m) >= 0 ? t.mod(this.m) : t;
                        }),
                        (t.prototype.revert = function (t) {
                            return t;
                        }),
                        (t.prototype.reduce = function (t) {
                            t.divRemTo(this.m, null, t);
                        }),
                        (t.prototype.mulTo = function (t, e, i) {
                            t.multiplyTo(e, i), this.reduce(i);
                        }),
                        (t.prototype.sqrTo = function (t, e) {
                            t.squareTo(e), this.reduce(e);
                        }),
                        t
                    );
                })(),
                V = (function () {
                    function t(t) {
                        (this.m = t),
                            (this.mp = t.invDigit()),
                            (this.mpl = 32767 & this.mp),
                            (this.mph = this.mp >> 15),
                            (this.um = (1 << (t.DB - 15)) - 1),
                            (this.mt2 = 2 * t.t);
                    }
                    return (
                        (t.prototype.convert = function (t) {
                            var e = N();
                            return (
                                t.abs().dlShiftTo(this.m.t, e),
                                e.divRemTo(this.m, null, e),
                                t.s < 0 && e.compareTo(B.ZERO) > 0 && this.m.subTo(e, e),
                                e
                            );
                        }),
                        (t.prototype.revert = function (t) {
                            var e = N();
                            return t.copyTo(e), this.reduce(e), e;
                        }),
                        (t.prototype.reduce = function (t) {
                            for (; t.t <= this.mt2; ) t[t.t++] = 0;
                            for (var e = 0; e < this.m.t; ++e) {
                                var i = 32767 & t[e],
                                    r =
                                        (i * this.mpl + (((i * this.mph + (t[e] >> 15) * this.mpl) & this.um) << 15)) &
                                        t.DM;
                                for (t[(i = e + this.m.t)] += this.m.am(0, r, t, e, 0, this.m.t); t[i] >= t.DV; )
                                    (t[i] -= t.DV), t[++i]++;
                            }
                            t.clamp(), t.drShiftTo(this.m.t, t), t.compareTo(this.m) >= 0 && t.subTo(this.m, t);
                        }),
                        (t.prototype.mulTo = function (t, e, i) {
                            t.multiplyTo(e, i), this.reduce(i);
                        }),
                        (t.prototype.sqrTo = function (t, e) {
                            t.squareTo(e), this.reduce(e);
                        }),
                        t
                    );
                })(),
                I = (function () {
                    function t(t) {
                        (this.m = t),
                            (this.r2 = N()),
                            (this.q3 = N()),
                            B.ONE.dlShiftTo(2 * t.t, this.r2),
                            (this.mu = this.r2.divide(t));
                    }
                    return (
                        (t.prototype.convert = function (t) {
                            if (t.s < 0 || t.t > 2 * this.m.t) return t.mod(this.m);
                            if (t.compareTo(this.m) < 0) return t;
                            var e = N();
                            return t.copyTo(e), this.reduce(e), e;
                        }),
                        (t.prototype.revert = function (t) {
                            return t;
                        }),
                        (t.prototype.reduce = function (t) {
                            for (
                                t.drShiftTo(this.m.t - 1, this.r2),
                                    t.t > this.m.t + 1 && ((t.t = this.m.t + 1), t.clamp()),
                                    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3),
                                    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
                                t.compareTo(this.r2) < 0;

                            )
                                t.dAddOffset(1, this.m.t + 1);
                            for (t.subTo(this.r2, t); t.compareTo(this.m) >= 0; ) t.subTo(this.m, t);
                        }),
                        (t.prototype.mulTo = function (t, e, i) {
                            t.multiplyTo(e, i), this.reduce(i);
                        }),
                        (t.prototype.sqrTo = function (t, e) {
                            t.squareTo(e), this.reduce(e);
                        }),
                        t
                    );
                })();
            function N() {
                return new B(null);
            }
            function P(t, e) {
                return new B(t, e);
            }
            var M = 'undefined' != typeof navigator;
            M && 'Microsoft Internet Explorer' == navigator.appName
                ? ((B.prototype.am = function (t, e, i, r, n, s) {
                      for (var o = 32767 & e, h = e >> 15; --s >= 0; ) {
                          var a = 32767 & this[t],
                              u = this[t++] >> 15,
                              c = h * a + u * o;
                          (n =
                              ((a = o * a + ((32767 & c) << 15) + i[r] + (1073741823 & n)) >>> 30) +
                              (c >>> 15) +
                              h * u +
                              (n >>> 30)),
                              (i[r++] = 1073741823 & a);
                      }
                      return n;
                  }),
                  (S = 30))
                : M && 'Netscape' != navigator.appName
                ? ((B.prototype.am = function (t, e, i, r, n, s) {
                      for (; --s >= 0; ) {
                          var o = e * this[t++] + i[r] + n;
                          (n = Math.floor(o / 67108864)), (i[r++] = 67108863 & o);
                      }
                      return n;
                  }),
                  (S = 26))
                : ((B.prototype.am = function (t, e, i, r, n, s) {
                      for (var o = 16383 & e, h = e >> 14; --s >= 0; ) {
                          var a = 16383 & this[t],
                              u = this[t++] >> 14,
                              c = h * a + u * o;
                          (n = ((a = o * a + ((16383 & c) << 14) + i[r] + n) >> 28) + (c >> 14) + h * u),
                              (i[r++] = 268435455 & a);
                      }
                      return n;
                  }),
                  (S = 28)),
                (B.prototype.DB = S),
                (B.prototype.DM = (1 << S) - 1),
                (B.prototype.DV = 1 << S),
                (B.prototype.FV = Math.pow(2, 52)),
                (B.prototype.F1 = 52 - S),
                (B.prototype.F2 = 2 * S - 52);
            var j,
                q,
                L = [];
            for (j = '0'.charCodeAt(0), q = 0; q <= 9; ++q) L[j++] = q;
            for (j = 'a'.charCodeAt(0), q = 10; q < 36; ++q) L[j++] = q;
            for (j = 'A'.charCodeAt(0), q = 10; q < 36; ++q) L[j++] = q;
            function H(t, e) {
                var i = L[t.charCodeAt(e)];
                return null == i ? -1 : i;
            }
            function C(t) {
                var e = N();
                return e.fromInt(t), e;
            }
            function F(t) {
                var e,
                    i = 1;
                return (
                    0 != (e = t >>> 16) && ((t = e), (i += 16)),
                    0 != (e = t >> 8) && ((t = e), (i += 8)),
                    0 != (e = t >> 4) && ((t = e), (i += 4)),
                    0 != (e = t >> 2) && ((t = e), (i += 2)),
                    0 != (e = t >> 1) && ((t = e), (i += 1)),
                    i
                );
            }
            (B.ZERO = C(0)), (B.ONE = C(1));
            var U,
                K,
                k = (function () {
                    function t() {
                        (this.i = 0), (this.j = 0), (this.S = []);
                    }
                    return (
                        (t.prototype.init = function (t) {
                            var e, i, r;
                            for (e = 0; e < 256; ++e) this.S[e] = e;
                            for (i = 0, e = 0; e < 256; ++e)
                                (i = (i + this.S[e] + t[e % t.length]) & 255),
                                    (r = this.S[e]),
                                    (this.S[e] = this.S[i]),
                                    (this.S[i] = r);
                            (this.i = 0), (this.j = 0);
                        }),
                        (t.prototype.next = function () {
                            var t;
                            return (
                                (this.i = (this.i + 1) & 255),
                                (this.j = (this.j + this.S[this.i]) & 255),
                                (t = this.S[this.i]),
                                (this.S[this.i] = this.S[this.j]),
                                (this.S[this.j] = t),
                                this.S[(t + this.S[this.i]) & 255]
                            );
                        }),
                        t
                    );
                })(),
                _ = null;
            if (null == _) {
                (_ = []), (K = 0);
                var z = void 0;
                if ('undefined' != typeof window && window.crypto && window.crypto.getRandomValues) {
                    var Z = new Uint32Array(256);
                    for (window.crypto.getRandomValues(Z), z = 0; z < Z.length; ++z) _[K++] = 255 & Z[z];
                }
            }
            function Y() {
                if (null == U) {
                    for (U = new k(); K < 256; ) {
                        var t = Math.floor(65536 * Math.random());
                        _[K++] = 255 & t;
                    }
                    for (U.init(_), K = 0; K < _.length; ++K) _[K] = 0;
                    K = 0;
                }
                return U.next();
            }
            var J = (function () {
                    function t() {}
                    return (
                        (t.prototype.nextBytes = function (t) {
                            for (var e = 0; e < t.length; ++e) t[e] = Y();
                        }),
                        t
                    );
                })(),
                X = (function () {
                    function t() {
                        (this.n = null),
                            (this.e = 0),
                            (this.d = null),
                            (this.p = null),
                            (this.q = null),
                            (this.dmp1 = null),
                            (this.dmq1 = null),
                            (this.coeff = null);
                    }
                    return (
                        (t.prototype.doPublic = function (t) {
                            return t.modPowInt(this.e, this.n);
                        }),
                        (t.prototype.doPrivate = function (t) {
                            if (null == this.p || null == this.q) return t.modPow(this.d, this.n);
                            for (
                                var e = t.mod(this.p).modPow(this.dmp1, this.p),
                                    i = t.mod(this.q).modPow(this.dmq1, this.q);
                                e.compareTo(i) < 0;

                            )
                                e = e.add(this.p);
                            return e.subtract(i).multiply(this.coeff).mod(this.p).multiply(this.q).add(i);
                        }),
                        (t.prototype.setPublic = function (t, e) {
                            null != t && null != e && t.length > 0 && e.length > 0
                                ? ((this.n = P(t, 16)), (this.e = parseInt(e, 16)))
                                : console.error('Invalid RSA public key');
                        }),
                        (t.prototype.encrypt = function (t) {
                            var e = (this.n.bitLength() + 7) >> 3,
                                i = (function (t, e) {
                                    if (e < t.length + 11) return console.error('Message too long for RSA'), null;
                                    for (var i = [], r = t.length - 1; r >= 0 && e > 0; ) {
                                        var n = t.charCodeAt(r--);
                                        n < 128
                                            ? (i[--e] = n)
                                            : n > 127 && n < 2048
                                            ? ((i[--e] = (63 & n) | 128), (i[--e] = (n >> 6) | 192))
                                            : ((i[--e] = (63 & n) | 128),
                                              (i[--e] = ((n >> 6) & 63) | 128),
                                              (i[--e] = (n >> 12) | 224));
                                    }
                                    i[--e] = 0;
                                    for (var s = new J(), o = []; e > 2; ) {
                                        for (o[0] = 0; 0 == o[0]; ) s.nextBytes(o);
                                        i[--e] = o[0];
                                    }
                                    return (i[--e] = 2), (i[--e] = 0), new B(i);
                                })(t, e);
                            if (null == i) return null;
                            var r = this.doPublic(i);
                            if (null == r) return null;
                            for (var n = r.toString(16), s = n.length, o = 0; o < 2 * e - s; o++) n = '0' + n;
                            return n;
                        }),
                        (t.prototype.setPrivate = function (t, e, i) {
                            null != t && null != e && t.length > 0 && e.length > 0
                                ? ((this.n = P(t, 16)), (this.e = parseInt(e, 16)), (this.d = P(i, 16)))
                                : console.error('Invalid RSA private key');
                        }),
                        (t.prototype.setPrivateEx = function (t, e, i, r, n, s, o, h) {
                            null != t && null != e && t.length > 0 && e.length > 0
                                ? ((this.n = P(t, 16)),
                                  (this.e = parseInt(e, 16)),
                                  (this.d = P(i, 16)),
                                  (this.p = P(r, 16)),
                                  (this.q = P(n, 16)),
                                  (this.dmp1 = P(s, 16)),
                                  (this.dmq1 = P(o, 16)),
                                  (this.coeff = P(h, 16)))
                                : console.error('Invalid RSA private key');
                        }),
                        (t.prototype.generate = function (t, e) {
                            var i = new J(),
                                r = t >> 1;
                            this.e = parseInt(e, 16);
                            for (var n = new B(e, 16); ; ) {
                                for (
                                    ;
                                    (this.p = new B(t - r, 1, i)),
                                        0 != this.p.subtract(B.ONE).gcd(n).compareTo(B.ONE) ||
                                            !this.p.isProbablePrime(10);

                                );
                                for (
                                    ;
                                    (this.q = new B(r, 1, i)),
                                        0 != this.q.subtract(B.ONE).gcd(n).compareTo(B.ONE) ||
                                            !this.q.isProbablePrime(10);

                                );
                                if (this.p.compareTo(this.q) <= 0) {
                                    var s = this.p;
                                    (this.p = this.q), (this.q = s);
                                }
                                var o = this.p.subtract(B.ONE),
                                    h = this.q.subtract(B.ONE),
                                    a = o.multiply(h);
                                if (0 == a.gcd(n).compareTo(B.ONE)) {
                                    (this.n = this.p.multiply(this.q)),
                                        (this.d = n.modInverse(a)),
                                        (this.dmp1 = this.d.mod(o)),
                                        (this.dmq1 = this.d.mod(h)),
                                        (this.coeff = this.q.modInverse(this.p));
                                    break;
                                }
                            }
                        }),
                        (t.prototype.decrypt = function (t) {
                            var e = P(t, 16),
                                i = this.doPrivate(e);
                            return null == i
                                ? null
                                : (function (t, e) {
                                      for (var i = t.toByteArray(), r = 0; r < i.length && 0 == i[r]; ) ++r;
                                      if (i.length - r != e - 1 || 2 != i[r]) return null;
                                      for (++r; 0 != i[r]; ) if (++r >= i.length) return null;
                                      for (var n = ''; ++r < i.length; ) {
                                          var s = 255 & i[r];
                                          s < 128
                                              ? (n += String.fromCharCode(s))
                                              : s > 191 && s < 224
                                              ? ((n += String.fromCharCode(((31 & s) << 6) | (63 & i[r + 1]))), ++r)
                                              : ((n += String.fromCharCode(
                                                    ((15 & s) << 12) | ((63 & i[r + 1]) << 6) | (63 & i[r + 2]),
                                                )),
                                                (r += 2));
                                      }
                                      return n;
                                  })(i, (this.n.bitLength() + 7) >> 3);
                        }),
                        (t.prototype.generateAsync = function (t, e, i) {
                            var r = new J(),
                                n = t >> 1;
                            this.e = parseInt(e, 16);
                            var s = new B(e, 16),
                                o = this,
                                h = function () {
                                    var e = function () {
                                            if (o.p.compareTo(o.q) <= 0) {
                                                var t = o.p;
                                                (o.p = o.q), (o.q = t);
                                            }
                                            var e = o.p.subtract(B.ONE),
                                                r = o.q.subtract(B.ONE),
                                                n = e.multiply(r);
                                            0 == n.gcd(s).compareTo(B.ONE)
                                                ? ((o.n = o.p.multiply(o.q)),
                                                  (o.d = s.modInverse(n)),
                                                  (o.dmp1 = o.d.mod(e)),
                                                  (o.dmq1 = o.d.mod(r)),
                                                  (o.coeff = o.q.modInverse(o.p)),
                                                  setTimeout(function () {
                                                      i();
                                                  }, 0))
                                                : setTimeout(h, 0);
                                        },
                                        a = function () {
                                            (o.q = N()),
                                                o.q.fromNumberAsync(n, 1, r, function () {
                                                    o.q.subtract(B.ONE).gcda(s, function (t) {
                                                        0 == t.compareTo(B.ONE) && o.q.isProbablePrime(10)
                                                            ? setTimeout(e, 0)
                                                            : setTimeout(a, 0);
                                                    });
                                                });
                                        },
                                        u = function () {
                                            (o.p = N()),
                                                o.p.fromNumberAsync(t - n, 1, r, function () {
                                                    o.p.subtract(B.ONE).gcda(s, function (t) {
                                                        0 == t.compareTo(B.ONE) && o.p.isProbablePrime(10)
                                                            ? setTimeout(a, 0)
                                                            : setTimeout(u, 0);
                                                    });
                                                });
                                        };
                                    setTimeout(u, 0);
                                };
                            setTimeout(h, 0);
                        }),
                        (t.prototype.sign = function (t, e, i) {
                            var r = (function (t, e) {
                                if (e < t.length + 22) return console.error('Message too long for RSA'), null;
                                for (var i = e - t.length - 6, r = '', n = 0; n < i; n += 2) r += 'ff';
                                return P('0001' + r + '00' + t, 16);
                            })((Q[i] || '') + e(t).toString(), this.n.bitLength() / 4);
                            if (null == r) return null;
                            var n = this.doPrivate(r);
                            if (null == n) return null;
                            var s = n.toString(16);
                            return 0 == (1 & s.length) ? s : '0' + s;
                        }),
                        (t.prototype.verify = function (t, e, i) {
                            var r = P(e, 16),
                                n = this.doPublic(r);
                            return null == n
                                ? null
                                : (function (t) {
                                      for (var e in Q)
                                          if (Q.hasOwnProperty(e)) {
                                              var i = Q[e],
                                                  r = i.length;
                                              if (t.substr(0, r) == i) return t.substr(r);
                                          }
                                      return t;
                                  })(n.toString(16).replace(/^1f+00/, '')) == i(t).toString();
                        }),
                        t
                    );
                })(),
                Q = {
                    md2: '3020300c06082a864886f70d020205000410',
                    md5: '3020300c06082a864886f70d020505000410',
                    sha1: '3021300906052b0e03021a05000414',
                    sha224: '302d300d06096086480165030402040500041c',
                    sha256: '3031300d060960864801650304020105000420',
                    sha384: '3041300d060960864801650304020205000430',
                    sha512: '3051300d060960864801650304020305000440',
                    ripemd160: '3021300906052b2403020105000414',
                },
                W = {};
            W.lang = {
                extend: function (t, e, i) {
                    if (!e || !t)
                        throw new Error('YAHOO.lang.extend failed, please check that all dependencies are included.');
                    var r = function () {};
                    if (
                        ((r.prototype = e.prototype),
                        (t.prototype = new r()),
                        (t.prototype.constructor = t),
                        (t.superclass = e.prototype),
                        e.prototype.constructor == Object.prototype.constructor && (e.prototype.constructor = e),
                        i)
                    ) {
                        var n;
                        for (n in i) t.prototype[n] = i[n];
                        var s = function () {},
                            o = ['toString', 'valueOf'];
                        try {
                            'undefined' != typeof navigator &&
                                /MSIE/.test(navigator.userAgent) &&
                                (s = function (t, e) {
                                    for (n = 0; n < o.length; n += 1) {
                                        var i = o[n],
                                            r = e[i];
                                        'function' == typeof r && r != Object.prototype[i] && (t[i] = r);
                                    }
                                });
                        } catch (t) {}
                        s(t.prototype, i);
                    }
                },
            };
            var tt = {};
            (void 0 !== tt.asn1 && tt.asn1) || (tt.asn1 = {}),
                (tt.asn1.ASN1Util = new (function () {
                    (this.integerToByteHex = function (t) {
                        var e = t.toString(16);
                        return e.length % 2 == 1 && (e = '0' + e), e;
                    }),
                        (this.bigIntToMinTwosComplementsHex = function (t) {
                            var e = t.toString(16);
                            if ('-' != e.substr(0, 1))
                                e.length % 2 == 1 ? (e = '0' + e) : e.match(/^[0-7]/) || (e = '00' + e);
                            else {
                                var i = e.substr(1).length;
                                i % 2 == 1 ? (i += 1) : e.match(/^[0-7]/) || (i += 2);
                                for (var r = '', n = 0; n < i; n++) r += 'f';
                                e = new B(r, 16).xor(t).add(B.ONE).toString(16).replace(/^-/, '');
                            }
                            return e;
                        }),
                        (this.getPEMStringFromHex = function (t, e) {
                            return hextopem(t, e);
                        }),
                        (this.newObject = function (t) {
                            var e = tt.asn1,
                                i = e.DERBoolean,
                                r = e.DERInteger,
                                n = e.DERBitString,
                                s = e.DEROctetString,
                                o = e.DERNull,
                                h = e.DERObjectIdentifier,
                                a = e.DEREnumerated,
                                u = e.DERUTF8String,
                                c = e.DERNumericString,
                                f = e.DERPrintableString,
                                l = e.DERTeletexString,
                                p = e.DERIA5String,
                                g = e.DERUTCTime,
                                d = e.DERGeneralizedTime,
                                v = e.DERSequence,
                                m = e.DERSet,
                                y = e.DERTaggedObject,
                                b = e.ASN1Util.newObject,
                                T = Object.keys(t);
                            if (1 != T.length) throw 'key of param shall be only one.';
                            var S = T[0];
                            if (
                                -1 ==
                                ':bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:'.indexOf(
                                    ':' + S + ':',
                                )
                            )
                                throw 'undefined key: ' + S;
                            if ('bool' == S) return new i(t[S]);
                            if ('int' == S) return new r(t[S]);
                            if ('bitstr' == S) return new n(t[S]);
                            if ('octstr' == S) return new s(t[S]);
                            if ('null' == S) return new o(t[S]);
                            if ('oid' == S) return new h(t[S]);
                            if ('enum' == S) return new a(t[S]);
                            if ('utf8str' == S) return new u(t[S]);
                            if ('numstr' == S) return new c(t[S]);
                            if ('prnstr' == S) return new f(t[S]);
                            if ('telstr' == S) return new l(t[S]);
                            if ('ia5str' == S) return new p(t[S]);
                            if ('utctime' == S) return new g(t[S]);
                            if ('gentime' == S) return new d(t[S]);
                            if ('seq' == S) {
                                for (var E = t[S], w = [], D = 0; D < E.length; D++) {
                                    var x = b(E[D]);
                                    w.push(x);
                                }
                                return new v({ array: w });
                            }
                            if ('set' == S) {
                                for (E = t[S], w = [], D = 0; D < E.length; D++) (x = b(E[D])), w.push(x);
                                return new m({ array: w });
                            }
                            if ('tag' == S) {
                                var R = t[S];
                                if ('[object Array]' === Object.prototype.toString.call(R) && 3 == R.length) {
                                    var B = b(R[2]);
                                    return new y({ tag: R[0], explicit: R[1], obj: B });
                                }
                                var O = {};
                                if (
                                    (void 0 !== R.explicit && (O.explicit = R.explicit),
                                    void 0 !== R.tag && (O.tag = R.tag),
                                    void 0 === R.obj)
                                )
                                    throw "obj shall be specified for 'tag'.";
                                return (O.obj = b(R.obj)), new y(O);
                            }
                        }),
                        (this.jsonToASN1HEX = function (t) {
                            return this.newObject(t).getEncodedHex();
                        });
                })()),
                (tt.asn1.ASN1Util.oidHexToInt = function (t) {
                    for (
                        var e = '',
                            i = parseInt(t.substr(0, 2), 16),
                            r = ((e = Math.floor(i / 40) + '.' + (i % 40)), ''),
                            n = 2;
                        n < t.length;
                        n += 2
                    ) {
                        var s = ('00000000' + parseInt(t.substr(n, 2), 16).toString(2)).slice(-8);
                        (r += s.substr(1, 7)),
                            '0' == s.substr(0, 1) && ((e = e + '.' + new B(r, 2).toString(10)), (r = ''));
                    }
                    return e;
                }),
                (tt.asn1.ASN1Util.oidIntToHex = function (t) {
                    var e = function (t) {
                            var e = t.toString(16);
                            return 1 == e.length && (e = '0' + e), e;
                        },
                        i = function (t) {
                            var i = '',
                                r = new B(t, 10).toString(2),
                                n = 7 - (r.length % 7);
                            7 == n && (n = 0);
                            for (var s = '', o = 0; o < n; o++) s += '0';
                            for (r = s + r, o = 0; o < r.length - 1; o += 7) {
                                var h = r.substr(o, 7);
                                o != r.length - 7 && (h = '1' + h), (i += e(parseInt(h, 2)));
                            }
                            return i;
                        };
                    if (!t.match(/^[0-9.]+$/)) throw 'malformed oid string: ' + t;
                    var r = '',
                        n = t.split('.'),
                        s = 40 * parseInt(n[0]) + parseInt(n[1]);
                    (r += e(s)), n.splice(0, 2);
                    for (var o = 0; o < n.length; o++) r += i(n[o]);
                    return r;
                }),
                (tt.asn1.ASN1Object = function () {
                    (this.getLengthHexFromValue = function () {
                        if (void 0 === this.hV || null == this.hV) throw 'this.hV is null or undefined.';
                        if (this.hV.length % 2 == 1)
                            throw 'value hex must be even length: n=' + ''.length + ',v=' + this.hV;
                        var t = this.hV.length / 2,
                            e = t.toString(16);
                        if ((e.length % 2 == 1 && (e = '0' + e), t < 128)) return e;
                        var i = e.length / 2;
                        if (i > 15) throw 'ASN.1 length too long to represent by 8x: n = ' + t.toString(16);
                        return (128 + i).toString(16) + e;
                    }),
                        (this.getEncodedHex = function () {
                            return (
                                (null == this.hTLV || this.isModified) &&
                                    ((this.hV = this.getFreshValueHex()),
                                    (this.hL = this.getLengthHexFromValue()),
                                    (this.hTLV = this.hT + this.hL + this.hV),
                                    (this.isModified = !1)),
                                this.hTLV
                            );
                        }),
                        (this.getValueHex = function () {
                            return this.getEncodedHex(), this.hV;
                        }),
                        (this.getFreshValueHex = function () {
                            return '';
                        });
                }),
                (tt.asn1.DERAbstractString = function (t) {
                    tt.asn1.DERAbstractString.superclass.constructor.call(this),
                        (this.getString = function () {
                            return this.s;
                        }),
                        (this.setString = function (t) {
                            (this.hTLV = null), (this.isModified = !0), (this.s = t), (this.hV = stohex(this.s));
                        }),
                        (this.setStringHex = function (t) {
                            (this.hTLV = null), (this.isModified = !0), (this.s = null), (this.hV = t);
                        }),
                        (this.getFreshValueHex = function () {
                            return this.hV;
                        }),
                        void 0 !== t &&
                            ('string' == typeof t
                                ? this.setString(t)
                                : void 0 !== t.str
                                ? this.setString(t.str)
                                : void 0 !== t.hex && this.setStringHex(t.hex));
                }),
                W.lang.extend(tt.asn1.DERAbstractString, tt.asn1.ASN1Object),
                (tt.asn1.DERAbstractTime = function (t) {
                    tt.asn1.DERAbstractTime.superclass.constructor.call(this),
                        (this.localDateToUTC = function (t) {
                            return (utc = t.getTime() + 6e4 * t.getTimezoneOffset()), new Date(utc);
                        }),
                        (this.formatDate = function (t, e, i) {
                            var r = this.zeroPadding,
                                n = this.localDateToUTC(t),
                                s = String(n.getFullYear());
                            'utc' == e && (s = s.substr(2, 2));
                            var o =
                                s +
                                r(String(n.getMonth() + 1), 2) +
                                r(String(n.getDate()), 2) +
                                r(String(n.getHours()), 2) +
                                r(String(n.getMinutes()), 2) +
                                r(String(n.getSeconds()), 2);
                            if (!0 === i) {
                                var h = n.getMilliseconds();
                                if (0 != h) {
                                    var a = r(String(h), 3);
                                    o = o + '.' + (a = a.replace(/[0]+$/, ''));
                                }
                            }
                            return o + 'Z';
                        }),
                        (this.zeroPadding = function (t, e) {
                            return t.length >= e ? t : new Array(e - t.length + 1).join('0') + t;
                        }),
                        (this.getString = function () {
                            return this.s;
                        }),
                        (this.setString = function (t) {
                            (this.hTLV = null), (this.isModified = !0), (this.s = t), (this.hV = stohex(t));
                        }),
                        (this.setByDateValue = function (t, e, i, r, n, s) {
                            var o = new Date(Date.UTC(t, e - 1, i, r, n, s, 0));
                            this.setByDate(o);
                        }),
                        (this.getFreshValueHex = function () {
                            return this.hV;
                        });
                }),
                W.lang.extend(tt.asn1.DERAbstractTime, tt.asn1.ASN1Object),
                (tt.asn1.DERAbstractStructured = function (t) {
                    tt.asn1.DERAbstractString.superclass.constructor.call(this),
                        (this.setByASN1ObjectArray = function (t) {
                            (this.hTLV = null), (this.isModified = !0), (this.asn1Array = t);
                        }),
                        (this.appendASN1Object = function (t) {
                            (this.hTLV = null), (this.isModified = !0), this.asn1Array.push(t);
                        }),
                        (this.asn1Array = new Array()),
                        void 0 !== t && void 0 !== t.array && (this.asn1Array = t.array);
                }),
                W.lang.extend(tt.asn1.DERAbstractStructured, tt.asn1.ASN1Object),
                (tt.asn1.DERBoolean = function () {
                    tt.asn1.DERBoolean.superclass.constructor.call(this), (this.hT = '01'), (this.hTLV = '0101ff');
                }),
                W.lang.extend(tt.asn1.DERBoolean, tt.asn1.ASN1Object),
                (tt.asn1.DERInteger = function (t) {
                    tt.asn1.DERInteger.superclass.constructor.call(this),
                        (this.hT = '02'),
                        (this.setByBigInteger = function (t) {
                            (this.hTLV = null),
                                (this.isModified = !0),
                                (this.hV = tt.asn1.ASN1Util.bigIntToMinTwosComplementsHex(t));
                        }),
                        (this.setByInteger = function (t) {
                            var e = new B(String(t), 10);
                            this.setByBigInteger(e);
                        }),
                        (this.setValueHex = function (t) {
                            this.hV = t;
                        }),
                        (this.getFreshValueHex = function () {
                            return this.hV;
                        }),
                        void 0 !== t &&
                            (void 0 !== t.bigint
                                ? this.setByBigInteger(t.bigint)
                                : void 0 !== t.int
                                ? this.setByInteger(t.int)
                                : 'number' == typeof t
                                ? this.setByInteger(t)
                                : void 0 !== t.hex && this.setValueHex(t.hex));
                }),
                W.lang.extend(tt.asn1.DERInteger, tt.asn1.ASN1Object),
                (tt.asn1.DERBitString = function (t) {
                    if (void 0 !== t && void 0 !== t.obj) {
                        var e = tt.asn1.ASN1Util.newObject(t.obj);
                        t.hex = '00' + e.getEncodedHex();
                    }
                    tt.asn1.DERBitString.superclass.constructor.call(this),
                        (this.hT = '03'),
                        (this.setHexValueIncludingUnusedBits = function (t) {
                            (this.hTLV = null), (this.isModified = !0), (this.hV = t);
                        }),
                        (this.setUnusedBitsAndHexValue = function (t, e) {
                            if (t < 0 || 7 < t) throw 'unused bits shall be from 0 to 7: u = ' + t;
                            var i = '0' + t;
                            (this.hTLV = null), (this.isModified = !0), (this.hV = i + e);
                        }),
                        (this.setByBinaryString = function (t) {
                            var e = 8 - ((t = t.replace(/0+$/, '')).length % 8);
                            8 == e && (e = 0);
                            for (var i = 0; i <= e; i++) t += '0';
                            var r = '';
                            for (i = 0; i < t.length - 1; i += 8) {
                                var n = t.substr(i, 8),
                                    s = parseInt(n, 2).toString(16);
                                1 == s.length && (s = '0' + s), (r += s);
                            }
                            (this.hTLV = null), (this.isModified = !0), (this.hV = '0' + e + r);
                        }),
                        (this.setByBooleanArray = function (t) {
                            for (var e = '', i = 0; i < t.length; i++) 1 == t[i] ? (e += '1') : (e += '0');
                            this.setByBinaryString(e);
                        }),
                        (this.newFalseArray = function (t) {
                            for (var e = new Array(t), i = 0; i < t; i++) e[i] = !1;
                            return e;
                        }),
                        (this.getFreshValueHex = function () {
                            return this.hV;
                        }),
                        void 0 !== t &&
                            ('string' == typeof t && t.toLowerCase().match(/^[0-9a-f]+$/)
                                ? this.setHexValueIncludingUnusedBits(t)
                                : void 0 !== t.hex
                                ? this.setHexValueIncludingUnusedBits(t.hex)
                                : void 0 !== t.bin
                                ? this.setByBinaryString(t.bin)
                                : void 0 !== t.array && this.setByBooleanArray(t.array));
                }),
                W.lang.extend(tt.asn1.DERBitString, tt.asn1.ASN1Object),
                (tt.asn1.DEROctetString = function (t) {
                    if (void 0 !== t && void 0 !== t.obj) {
                        var e = tt.asn1.ASN1Util.newObject(t.obj);
                        t.hex = e.getEncodedHex();
                    }
                    tt.asn1.DEROctetString.superclass.constructor.call(this, t), (this.hT = '04');
                }),
                W.lang.extend(tt.asn1.DEROctetString, tt.asn1.DERAbstractString),
                (tt.asn1.DERNull = function () {
                    tt.asn1.DERNull.superclass.constructor.call(this), (this.hT = '05'), (this.hTLV = '0500');
                }),
                W.lang.extend(tt.asn1.DERNull, tt.asn1.ASN1Object),
                (tt.asn1.DERObjectIdentifier = function (t) {
                    var e = function (t) {
                            var e = t.toString(16);
                            return 1 == e.length && (e = '0' + e), e;
                        },
                        i = function (t) {
                            var i = '',
                                r = new B(t, 10).toString(2),
                                n = 7 - (r.length % 7);
                            7 == n && (n = 0);
                            for (var s = '', o = 0; o < n; o++) s += '0';
                            for (r = s + r, o = 0; o < r.length - 1; o += 7) {
                                var h = r.substr(o, 7);
                                o != r.length - 7 && (h = '1' + h), (i += e(parseInt(h, 2)));
                            }
                            return i;
                        };
                    tt.asn1.DERObjectIdentifier.superclass.constructor.call(this),
                        (this.hT = '06'),
                        (this.setValueHex = function (t) {
                            (this.hTLV = null), (this.isModified = !0), (this.s = null), (this.hV = t);
                        }),
                        (this.setValueOidString = function (t) {
                            if (!t.match(/^[0-9.]+$/)) throw 'malformed oid string: ' + t;
                            var r = '',
                                n = t.split('.'),
                                s = 40 * parseInt(n[0]) + parseInt(n[1]);
                            (r += e(s)), n.splice(0, 2);
                            for (var o = 0; o < n.length; o++) r += i(n[o]);
                            (this.hTLV = null), (this.isModified = !0), (this.s = null), (this.hV = r);
                        }),
                        (this.setValueName = function (t) {
                            var e = tt.asn1.x509.OID.name2oid(t);
                            if ('' === e) throw 'DERObjectIdentifier oidName undefined: ' + t;
                            this.setValueOidString(e);
                        }),
                        (this.getFreshValueHex = function () {
                            return this.hV;
                        }),
                        void 0 !== t &&
                            ('string' == typeof t
                                ? t.match(/^[0-2].[0-9.]+$/)
                                    ? this.setValueOidString(t)
                                    : this.setValueName(t)
                                : void 0 !== t.oid
                                ? this.setValueOidString(t.oid)
                                : void 0 !== t.hex
                                ? this.setValueHex(t.hex)
                                : void 0 !== t.name && this.setValueName(t.name));
                }),
                W.lang.extend(tt.asn1.DERObjectIdentifier, tt.asn1.ASN1Object),
                (tt.asn1.DEREnumerated = function (t) {
                    tt.asn1.DEREnumerated.superclass.constructor.call(this),
                        (this.hT = '0a'),
                        (this.setByBigInteger = function (t) {
                            (this.hTLV = null),
                                (this.isModified = !0),
                                (this.hV = tt.asn1.ASN1Util.bigIntToMinTwosComplementsHex(t));
                        }),
                        (this.setByInteger = function (t) {
                            var e = new B(String(t), 10);
                            this.setByBigInteger(e);
                        }),
                        (this.setValueHex = function (t) {
                            this.hV = t;
                        }),
                        (this.getFreshValueHex = function () {
                            return this.hV;
                        }),
                        void 0 !== t &&
                            (void 0 !== t.int
                                ? this.setByInteger(t.int)
                                : 'number' == typeof t
                                ? this.setByInteger(t)
                                : void 0 !== t.hex && this.setValueHex(t.hex));
                }),
                W.lang.extend(tt.asn1.DEREnumerated, tt.asn1.ASN1Object),
                (tt.asn1.DERUTF8String = function (t) {
                    tt.asn1.DERUTF8String.superclass.constructor.call(this, t), (this.hT = '0c');
                }),
                W.lang.extend(tt.asn1.DERUTF8String, tt.asn1.DERAbstractString),
                (tt.asn1.DERNumericString = function (t) {
                    tt.asn1.DERNumericString.superclass.constructor.call(this, t), (this.hT = '12');
                }),
                W.lang.extend(tt.asn1.DERNumericString, tt.asn1.DERAbstractString),
                (tt.asn1.DERPrintableString = function (t) {
                    tt.asn1.DERPrintableString.superclass.constructor.call(this, t), (this.hT = '13');
                }),
                W.lang.extend(tt.asn1.DERPrintableString, tt.asn1.DERAbstractString),
                (tt.asn1.DERTeletexString = function (t) {
                    tt.asn1.DERTeletexString.superclass.constructor.call(this, t), (this.hT = '14');
                }),
                W.lang.extend(tt.asn1.DERTeletexString, tt.asn1.DERAbstractString),
                (tt.asn1.DERIA5String = function (t) {
                    tt.asn1.DERIA5String.superclass.constructor.call(this, t), (this.hT = '16');
                }),
                W.lang.extend(tt.asn1.DERIA5String, tt.asn1.DERAbstractString),
                (tt.asn1.DERUTCTime = function (t) {
                    tt.asn1.DERUTCTime.superclass.constructor.call(this, t),
                        (this.hT = '17'),
                        (this.setByDate = function (t) {
                            (this.hTLV = null),
                                (this.isModified = !0),
                                (this.date = t),
                                (this.s = this.formatDate(this.date, 'utc')),
                                (this.hV = stohex(this.s));
                        }),
                        (this.getFreshValueHex = function () {
                            return (
                                void 0 === this.date &&
                                    void 0 === this.s &&
                                    ((this.date = new Date()),
                                    (this.s = this.formatDate(this.date, 'utc')),
                                    (this.hV = stohex(this.s))),
                                this.hV
                            );
                        }),
                        void 0 !== t &&
                            (void 0 !== t.str
                                ? this.setString(t.str)
                                : 'string' == typeof t && t.match(/^[0-9]{12}Z$/)
                                ? this.setString(t)
                                : void 0 !== t.hex
                                ? this.setStringHex(t.hex)
                                : void 0 !== t.date && this.setByDate(t.date));
                }),
                W.lang.extend(tt.asn1.DERUTCTime, tt.asn1.DERAbstractTime),
                (tt.asn1.DERGeneralizedTime = function (t) {
                    tt.asn1.DERGeneralizedTime.superclass.constructor.call(this, t),
                        (this.hT = '18'),
                        (this.withMillis = !1),
                        (this.setByDate = function (t) {
                            (this.hTLV = null),
                                (this.isModified = !0),
                                (this.date = t),
                                (this.s = this.formatDate(this.date, 'gen', this.withMillis)),
                                (this.hV = stohex(this.s));
                        }),
                        (this.getFreshValueHex = function () {
                            return (
                                void 0 === this.date &&
                                    void 0 === this.s &&
                                    ((this.date = new Date()),
                                    (this.s = this.formatDate(this.date, 'gen', this.withMillis)),
                                    (this.hV = stohex(this.s))),
                                this.hV
                            );
                        }),
                        void 0 !== t &&
                            (void 0 !== t.str
                                ? this.setString(t.str)
                                : 'string' == typeof t && t.match(/^[0-9]{14}Z$/)
                                ? this.setString(t)
                                : void 0 !== t.hex
                                ? this.setStringHex(t.hex)
                                : void 0 !== t.date && this.setByDate(t.date),
                            !0 === t.millis && (this.withMillis = !0));
                }),
                W.lang.extend(tt.asn1.DERGeneralizedTime, tt.asn1.DERAbstractTime),
                (tt.asn1.DERSequence = function (t) {
                    tt.asn1.DERSequence.superclass.constructor.call(this, t),
                        (this.hT = '30'),
                        (this.getFreshValueHex = function () {
                            for (var t = '', e = 0; e < this.asn1Array.length; e++)
                                t += this.asn1Array[e].getEncodedHex();
                            return (this.hV = t), this.hV;
                        });
                }),
                W.lang.extend(tt.asn1.DERSequence, tt.asn1.DERAbstractStructured),
                (tt.asn1.DERSet = function (t) {
                    tt.asn1.DERSet.superclass.constructor.call(this, t),
                        (this.hT = '31'),
                        (this.sortFlag = !0),
                        (this.getFreshValueHex = function () {
                            for (var t = new Array(), e = 0; e < this.asn1Array.length; e++) {
                                var i = this.asn1Array[e];
                                t.push(i.getEncodedHex());
                            }
                            return 1 == this.sortFlag && t.sort(), (this.hV = t.join('')), this.hV;
                        }),
                        void 0 !== t && void 0 !== t.sortflag && 0 == t.sortflag && (this.sortFlag = !1);
                }),
                W.lang.extend(tt.asn1.DERSet, tt.asn1.DERAbstractStructured),
                (tt.asn1.DERTaggedObject = function (t) {
                    tt.asn1.DERTaggedObject.superclass.constructor.call(this),
                        (this.hT = 'a0'),
                        (this.hV = ''),
                        (this.isExplicit = !0),
                        (this.asn1Object = null),
                        (this.setASN1Object = function (t, e, i) {
                            (this.hT = e),
                                (this.isExplicit = t),
                                (this.asn1Object = i),
                                this.isExplicit
                                    ? ((this.hV = this.asn1Object.getEncodedHex()),
                                      (this.hTLV = null),
                                      (this.isModified = !0))
                                    : ((this.hV = null),
                                      (this.hTLV = i.getEncodedHex()),
                                      (this.hTLV = this.hTLV.replace(/^../, e)),
                                      (this.isModified = !1));
                        }),
                        (this.getFreshValueHex = function () {
                            return this.hV;
                        }),
                        void 0 !== t &&
                            (void 0 !== t.tag && (this.hT = t.tag),
                            void 0 !== t.explicit && (this.isExplicit = t.explicit),
                            void 0 !== t.obj &&
                                ((this.asn1Object = t.obj),
                                this.setASN1Object(this.isExplicit, this.hT, this.asn1Object)));
                }),
                W.lang.extend(tt.asn1.DERTaggedObject, tt.asn1.ASN1Object);
            var et,
                it =
                    ((et = function (t, e) {
                        return (et =
                            Object.setPrototypeOf ||
                            ({ __proto__: [] } instanceof Array &&
                                function (t, e) {
                                    t.__proto__ = e;
                                }) ||
                            function (t, e) {
                                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
                            })(t, e);
                    }),
                    function (t, e) {
                        if ('function' != typeof e && null !== e)
                            throw new TypeError('Class extends value ' + String(e) + ' is not a constructor or null');
                        function i() {
                            this.constructor = t;
                        }
                        et(t, e),
                            (t.prototype = null === e ? Object.create(e) : ((i.prototype = e.prototype), new i()));
                    }),
                rt = (function (t) {
                    function e(i) {
                        var r = t.call(this) || this;
                        return (
                            i &&
                                ('string' == typeof i
                                    ? r.parseKey(i)
                                    : (e.hasPrivateKeyProperty(i) || e.hasPublicKeyProperty(i)) &&
                                      r.parsePropertiesFrom(i)),
                            r
                        );
                    }
                    return (
                        it(e, t),
                        (e.prototype.parseKey = function (t) {
                            try {
                                var e = 0,
                                    i = 0,
                                    r = /^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/.test(t)
                                        ? (function (t) {
                                              var e;
                                              if (void 0 === c) {
                                                  var i = '0123456789ABCDEF',
                                                      r = ' \f\n\r\t\u2028\u2029';
                                                  for (c = {}, e = 0; e < 16; ++e) c[i.charAt(e)] = e;
                                                  for (i = i.toLowerCase(), e = 10; e < 16; ++e) c[i.charAt(e)] = e;
                                                  for (e = 0; e < r.length; ++e) c[r.charAt(e)] = -1;
                                              }
                                              var n = [],
                                                  s = 0,
                                                  o = 0;
                                              for (e = 0; e < t.length; ++e) {
                                                  var h = t.charAt(e);
                                                  if ('=' == h) break;
                                                  if (-1 != (h = c[h])) {
                                                      if (void 0 === h)
                                                          throw new Error('Illegal character at offset ' + e);
                                                      (s |= h),
                                                          ++o >= 2 ? ((n[n.length] = s), (s = 0), (o = 0)) : (s <<= 4);
                                                  }
                                              }
                                              if (o) throw new Error('Hex encoding incomplete: 4 bits missing');
                                              return n;
                                          })(t)
                                        : d.unarmor(t),
                                    n = w.decode(r);
                                if ((3 === n.sub.length && (n = n.sub[2].sub[0]), 9 === n.sub.length)) {
                                    (e = n.sub[1].getHexStringValue()),
                                        (this.n = P(e, 16)),
                                        (i = n.sub[2].getHexStringValue()),
                                        (this.e = parseInt(i, 16));
                                    var s = n.sub[3].getHexStringValue();
                                    this.d = P(s, 16);
                                    var o = n.sub[4].getHexStringValue();
                                    this.p = P(o, 16);
                                    var h = n.sub[5].getHexStringValue();
                                    this.q = P(h, 16);
                                    var a = n.sub[6].getHexStringValue();
                                    this.dmp1 = P(a, 16);
                                    var u = n.sub[7].getHexStringValue();
                                    this.dmq1 = P(u, 16);
                                    var f = n.sub[8].getHexStringValue();
                                    this.coeff = P(f, 16);
                                } else {
                                    if (2 !== n.sub.length) return !1;
                                    var l = n.sub[1].sub[0];
                                    (e = l.sub[0].getHexStringValue()),
                                        (this.n = P(e, 16)),
                                        (i = l.sub[1].getHexStringValue()),
                                        (this.e = parseInt(i, 16));
                                }
                                return !0;
                            } catch (t) {
                                return !1;
                            }
                        }),
                        (e.prototype.getPrivateBaseKey = function () {
                            var t = {
                                array: [
                                    new tt.asn1.DERInteger({ int: 0 }),
                                    new tt.asn1.DERInteger({ bigint: this.n }),
                                    new tt.asn1.DERInteger({ int: this.e }),
                                    new tt.asn1.DERInteger({ bigint: this.d }),
                                    new tt.asn1.DERInteger({ bigint: this.p }),
                                    new tt.asn1.DERInteger({ bigint: this.q }),
                                    new tt.asn1.DERInteger({ bigint: this.dmp1 }),
                                    new tt.asn1.DERInteger({ bigint: this.dmq1 }),
                                    new tt.asn1.DERInteger({ bigint: this.coeff }),
                                ],
                            };
                            return new tt.asn1.DERSequence(t).getEncodedHex();
                        }),
                        (e.prototype.getPrivateBaseKeyB64 = function () {
                            return l(this.getPrivateBaseKey());
                        }),
                        (e.prototype.getPublicBaseKey = function () {
                            var t = new tt.asn1.DERSequence({
                                    array: [
                                        new tt.asn1.DERObjectIdentifier({ oid: '1.2.840.113549.1.1.1' }),
                                        new tt.asn1.DERNull(),
                                    ],
                                }),
                                e = new tt.asn1.DERSequence({
                                    array: [
                                        new tt.asn1.DERInteger({ bigint: this.n }),
                                        new tt.asn1.DERInteger({ int: this.e }),
                                    ],
                                }),
                                i = new tt.asn1.DERBitString({ hex: '00' + e.getEncodedHex() });
                            return new tt.asn1.DERSequence({ array: [t, i] }).getEncodedHex();
                        }),
                        (e.prototype.getPublicBaseKeyB64 = function () {
                            return l(this.getPublicBaseKey());
                        }),
                        (e.wordwrap = function (t, e) {
                            if (!t) return t;
                            var i = '(.{1,' + (e = e || 64) + '})( +|$\n?)|(.{1,' + e + '})';
                            return t.match(RegExp(i, 'g')).join('\n');
                        }),
                        (e.prototype.getPrivateKey = function () {
                            var t = '-----BEGIN RSA PRIVATE KEY-----\n';
                            return (
                                (t += e.wordwrap(this.getPrivateBaseKeyB64()) + '\n') + '-----END RSA PRIVATE KEY-----'
                            );
                        }),
                        (e.prototype.getPublicKey = function () {
                            var t = '-----BEGIN PUBLIC KEY-----\n';
                            return (t += e.wordwrap(this.getPublicBaseKeyB64()) + '\n') + '-----END PUBLIC KEY-----';
                        }),
                        (e.hasPublicKeyProperty = function (t) {
                            return (t = t || {}).hasOwnProperty('n') && t.hasOwnProperty('e');
                        }),
                        (e.hasPrivateKeyProperty = function (t) {
                            return (
                                (t = t || {}).hasOwnProperty('n') &&
                                t.hasOwnProperty('e') &&
                                t.hasOwnProperty('d') &&
                                t.hasOwnProperty('p') &&
                                t.hasOwnProperty('q') &&
                                t.hasOwnProperty('dmp1') &&
                                t.hasOwnProperty('dmq1') &&
                                t.hasOwnProperty('coeff')
                            );
                        }),
                        (e.prototype.parsePropertiesFrom = function (t) {
                            (this.n = t.n),
                                (this.e = t.e),
                                t.hasOwnProperty('d') &&
                                    ((this.d = t.d),
                                    (this.p = t.p),
                                    (this.q = t.q),
                                    (this.dmp1 = t.dmp1),
                                    (this.dmq1 = t.dmq1),
                                    (this.coeff = t.coeff));
                        }),
                        e
                    );
                })(X);
            const nt = (function () {
                function t(t) {
                    void 0 === t && (t = {}),
                        (t = t || {}),
                        (this.default_key_size = t.default_key_size ? parseInt(t.default_key_size, 10) : 1024),
                        (this.default_public_exponent = t.default_public_exponent || '010001'),
                        (this.log = t.log || !1),
                        (this.key = null);
                }
                return (
                    (t.prototype.setKey = function (t) {
                        this.log && this.key && console.warn('A key was already set, overriding existing.'),
                            (this.key = new rt(t));
                    }),
                    (t.prototype.setPrivateKey = function (t) {
                        this.setKey(t);
                    }),
                    (t.prototype.setPublicKey = function (t) {
                        this.setKey(t);
                    }),
                    (t.prototype.decrypt = function (t) {
                        try {
                            return this.getKey().decrypt(p(t));
                        } catch (t) {
                            return !1;
                        }
                    }),
                    (t.prototype.encrypt = function (t) {
                        try {
                            return l(this.getKey().encrypt(t));
                        } catch (t) {
                            return !1;
                        }
                    }),
                    (t.prototype.sign = function (t, e, i) {
                        try {
                            return l(this.getKey().sign(t, e, i));
                        } catch (t) {
                            return !1;
                        }
                    }),
                    (t.prototype.verify = function (t, e, i) {
                        try {
                            return this.getKey().verify(t, p(e), i);
                        } catch (t) {
                            return !1;
                        }
                    }),
                    (t.prototype.getKey = function (t) {
                        if (!this.key) {
                            if (((this.key = new rt()), t && '[object Function]' === {}.toString.call(t)))
                                return void this.key.generateAsync(
                                    this.default_key_size,
                                    this.default_public_exponent,
                                    t,
                                );
                            this.key.generate(this.default_key_size, this.default_public_exponent);
                        }
                        return this.key;
                    }),
                    (t.prototype.getPrivateKey = function () {
                        return this.getKey().getPrivateKey();
                    }),
                    (t.prototype.getPrivateKeyB64 = function () {
                        return this.getKey().getPrivateBaseKeyB64();
                    }),
                    (t.prototype.getPublicKey = function () {
                        return this.getKey().getPublicKey();
                    }),
                    (t.prototype.getPublicKeyB64 = function () {
                        return this.getKey().getPublicBaseKeyB64();
                    }),
                    (t.version = '3.2.1'),
                    t
                );
            })();
        },
    ],
    e = {
        d: (t, i) => {
            for (var r in i) e.o(i, r) && !e.o(t, r) && Object.defineProperty(t, r, { enumerable: !0, get: i[r] });
        },
        o: (t, e) => Object.prototype.hasOwnProperty.call(t, e),
    },
    i = {};
t[1](0, i, e);

/* harmony default export */ __webpack_exports__["default"] = (i.default);


/***/ }),

/***/ "./sdk/util/param-util.ts":
/*!********************************!*\
  !*** ./sdk/util/param-util.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1743338__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.checkParams = exports.RULE_SUCCESS = exports.RULE_PARAM_NAME = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
var client_util_1 = __nested_webpack_require_1743338__(/*! ./client-util */ "./sdk/util/client-util.ts");
var RULE_PARAM_NAME;
(function (RULE_PARAM_NAME) {
    RULE_PARAM_NAME["NOT_EMPTY"] = "NOT_EMPTY";
    RULE_PARAM_NAME["ILLEGAL_CHARACTERS"] = "ILLEGAL_CHARACTERS";
    RULE_PARAM_NAME["TYPE_STRING"] = "TYPE_STRING";
    RULE_PARAM_NAME["TYPE_INTEGER"] = "TYPE_INTEGER";
    RULE_PARAM_NAME["TYPE_OBJECT"] = "TYPE_OBJECT";
    RULE_PARAM_NAME["MAX_LENGTH_10"] = "MAX_LENGTH_10";
    RULE_PARAM_NAME["MAX_LENGTH_64"] = "MAX_LENGTH_64";
    RULE_PARAM_NAME["MAX_LENGTH_100"] = "MAX_LENGTH_100";
    RULE_PARAM_NAME["MAX_LENGTH_128"] = "MAX_LENGTH_128";
    RULE_PARAM_NAME["MAX_LENGTH_256"] = "MAX_LENGTH_256";
    RULE_PARAM_NAME["MAX_LENGTH_1024"] = "MAX_LENGTH_1024";
})(RULE_PARAM_NAME = exports.RULE_PARAM_NAME || (exports.RULE_PARAM_NAME = {}));
exports.RULE_SUCCESS = {
    error: {
        code: 0,
        msg: 'suc',
    },
};
var RULE_PARAM = {
    NOT_EMPTY: function (key, value, action, logger, rule) {
        if (value === undefined || value === '' || value === null) {
            logger.error(action + " " + key + " is empty");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    ILLEGAL_CHARACTERS: function (key, value, action, logger, rule) {
        if (!client_util_1.ClientUtil.checkIllegalCharacters(value)) {
            logger.error(action + " " + key + " contains illegal characters");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    TYPE_STRING: function (key, value, action, logger, rule) {
        if (typeof value !== 'string') {
            logger.error(action + " " + key + " must be string");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    TYPE_INTEGER: function (key, value, action, logger, rule) {
        if (!client_util_1.ClientUtil.checkInteger(value, false)) {
            logger.error(action + " " + key + "  must be integer number");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    TYPE_OBJECT: function (key, value, action, logger, rule) {
        if (!value || typeof value !== 'object') {
            logger.error(action + " " + key + "  must be object");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    MAX_LENGTH_10: function (key, value, action, logger, rule) {
        if (value.length > 10) {
            logger.error(action + " " + key + " is too long");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    MAX_LENGTH_64: function (key, value, action, logger, rule) {
        if (value.length > 64) {
            logger.error(action + " " + key + " is too long");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    MAX_LENGTH_100: function (key, value, action, logger, rule) {
        if (value.length > 100) {
            logger.error(action + " " + key + " is too long");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    MAX_LENGTH_128: function (key, value, action, logger, rule) {
        if (value.length > 128) {
            logger.error(action + " " + key + " is too long");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    MAX_LENGTH_256: function (key, value, action, logger, rule) {
        if (value.length > 256) {
            logger.error(action + " " + key + " is too long");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
    MAX_LENGTH_1024: function (key, value, action, logger, rule) {
        if (value.length > 1024) {
            logger.error(action + " " + key + " is too long");
            return rule;
        }
        else {
            return exports.RULE_SUCCESS;
        }
    },
};
function checkParams(sourceMap, option) {
    // ,
    var arrayByKey = [], tempMap = {};
    for (var skey in sourceMap) {
        var order = sourceMap[skey].order;
        tempMap[order] = sourceMap[skey];
        sourceMap[skey].key = skey;
    }
    for (var tkey in tempMap) {
        arrayByKey.push(tempMap[tkey]);
    }
    // 
    for (var i = 0; i < arrayByKey.length; i++) {
        var rules = arrayByKey[i].rules;
        for (var k = 0; k < rules.length; k++) {
            var _a = {
                key: arrayByKey[i].key,
                value: arrayByKey[i].value,
                action: option.action,
                logger: option.logger,
            }, key = _a.key, value = _a.value, action = _a.action, logger = _a.logger;
            var ruleKey = rules[k].name ? '' + rules[k].name : '';
            if (((value === undefined && ruleKey === RULE_PARAM_NAME.NOT_EMPTY) || value !== undefined) &&
                RULE_PARAM[ruleKey]) {
                var excuteRes = RULE_PARAM[ruleKey](key, value, action, logger, rules[k]);
                if (excuteRes != exports.RULE_SUCCESS) {
                    return excuteRes;
                }
            }
        }
    }
    return exports.RULE_SUCCESS;
}
exports.checkParams = checkParams;


/***/ }),

/***/ "./sdk/util/socket-util.ts":
/*!*********************************!*\
  !*** ./sdk/util/socket-util.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_1749175__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ZegoSocketService = void 0;
var zego_entity_1 = __nested_webpack_require_1749175__(/*! ../src/zego.entity */ "./sdk/src/zego.entity.ts");
var zego_externalError_1 = __nested_webpack_require_1749175__(/*! ../src/zego.externalError */ "./sdk/src/zego.externalError.ts");
var ZegoSocketService = /** @class */ (function () {
    function ZegoSocketService(ENV) {
        this.socket = null;
        // private responseRouters: { [index: string]: Function } = {};
        // , 
        this.sendCommandList = new zego_entity_1.LinkedList();
        this.sendCommandMap = {};
        // 
        this.sendDataCheckOnceCount = 100;
        // ,
        this.sendDataDropTimeout = 10 * 1000;
        // 
        this.sendDataCheckInterval = 2000;
        this.ENV = ENV;
    }
    ZegoSocketService.prototype.createSocket = function (server) {
        this.socket = zego_entity_1.createZegoWebSocket(server, this.ENV % 2);
    };
    ZegoSocketService.prototype.closeSocket = function () {
        if (this.socket) {
            this.socket.onclose = null;
            this.socket.onerror = null;
            this.socket.close();
            this.socket = null;
        }
    };
    ZegoSocketService.prototype.isDisConnect = function () {
        return !this.socket || this.socket.readyState !== 1;
    };
    /*
     *    
     *
     */
    ZegoSocketService.prototype.sendMessage = function (header, body, success, error, option) {
        if (success === void 0) { success = null; }
        if (error === void 0) { error = null; }
        if (option === void 0) { option = { timeOut: 6 * 1000 }; }
        var data = {
            header: header,
            body: body,
        };
        var cmdData = {
            data: data,
            seq: header.seq,
            deleted: false,
            sendTime: Date.parse(new Date() + ''),
            timeOut: option.timeOut,
            success: success,
            error: error,
        };
        var cmdDataNode = this.sendCommandList.push(cmdData);
        this.sendCommandMap[cmdData.seq] = cmdDataNode;
        this.socket && this.socket.send(JSON.stringify(data));
        return header.seq;
    };
    ZegoSocketService.prototype.sendPB = function (msg) {
        this.socket && this.socket.send(msg);
        return true;
    };
    // 
    ZegoSocketService.prototype.checkSendMessageList = function (messageList) {
        var head = messageList.getFirst();
        while (head != null) {
            messageList.remove(head);
            if (head._data && head._data.error) {
                setTimeout(function () {
                    head &&
                        head._data &&
                        head._data.error &&
                        head._data.error(zego_externalError_1.errorCodeList.TIMEOUT, head._data.data.header.seq, head._data.data.body.custom_msg);
                }, 0);
            }
            head = messageList.getFirst();
        }
    };
    // ,
    ZegoSocketService.prototype.checkMessageListTimeout = function (messageList, messageMap) {
        var head = messageList.getFirst();
        var timestamp = Date.parse(new Date() + '');
        var checkCount = 0;
        var timeoutMsgCount = 0;
        var dropMsgCount = 0;
        while (head != null) {
            //  
            if (head._data && head._data.sendTime + head._data.timeOut > timestamp) {
                break;
            }
            //  ,
            head._data && delete messageMap[head._data.data.header.seq];
            messageList.remove(head);
            ++timeoutMsgCount;
            //  ,
            if ((head._data && head._data.error == null) ||
                (head._data && head._data.sendTime + this.sendDataDropTimeout < timestamp)) {
                ++dropMsgCount;
            }
            else {
                setTimeout(function () {
                    head &&
                        head._data &&
                        head._data.error &&
                        head._data.error(zego_externalError_1.errorCodeList.TIMEOUT, head._data.data.header.seq, head._data.data.body.custom_msg);
                }, 0);
            }
            ++checkCount;
            if (checkCount >= this.sendDataCheckOnceCount) {
                break;
            }
            head = messageList.getFirst();
        }
        // if (timeoutMsgCount != 0 || dropMsgCount != 0) {
        //     console.error('zb.hb.cmt call success, stat: timeout=', timeoutMsgCount + '', 'drop=', dropMsgCount + '');
        // }
    };
    // ,
    ZegoSocketService.prototype.startCheck = function () {
        var _this = this;
        this.checkMessageListTimeout(this.sendCommandList, this.sendCommandMap);
        this.sendDataCheckTimer = setTimeout(function () {
            _this.startCheck();
        }, this.sendDataCheckInterval);
    };
    // 
    ZegoSocketService.prototype.stopCheck = function () {
        this.checkSendMessageList(this.sendCommandList);
        clearTimeout(this.sendDataCheckTimer);
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ZegoSocketService.prototype.openHandler = function (hander) {
        var _this = this;
        if (this.socket)
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.socket.onopen = function (evt) {
                _this.socket.binaryType = 'arraybuffer';
                _this.responseHandler();
                hander(evt);
            };
    };
    /*
     *    "zb.sc.ws.rph: "ZegoExpressEngine.base.SocketCenter.responseHandler"
     */
    ZegoSocketService.prototype.responseHandler = function () {
        var _this = this;
        if (this.socket)
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.socket.onmessage = function (e) {
                var msg = typeof e.data == 'string'
                    ? JSON.parse(e.data)
                    : //: JSON.parse(String.fromCharCode.apply(null, new Uint8Array(e.data) as any));
                        e.data;
                _this.onMessage(msg);
            };
    };
    /*
     *    "zb.sc.ch": "ZegoExpressEngine.base.SocketCenter.closeHandler"
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ZegoSocketService.prototype.closeHandler = function (handler) {
        if (this.socket)
            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
            this.socket.onclose = function (evt) {
                handler(evt);
            };
    };
    /*
     *    "zb.sc.ws.oe": "ZegoExpressEngine.base.SocketCenter.errorHandler"
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ZegoSocketService.prototype.errorHandler = function (handler) {
        this.socket && (this.socket.onerror = handler);
    };
    //cmd
    ZegoSocketService.prototype.onMessage = function (msg) { };
    return ZegoSocketService;
}());
exports.ZegoSocketService = ZegoSocketService;


/***/ }),

/***/ "./sdk/util/string.ts":
/*!****************************!*\
  !*** ./sdk/util/string.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeString = exports.encodeString = void 0;
var encodeString = function (str) {
    return Uint8Array.from(Array.from(unescape(encodeURIComponent(str))).map(function (val) { return val.charCodeAt(0); }));
};
exports.encodeString = encodeString;
var decodeString = function (u8arr) {
    return decodeURIComponent(escape(String.fromCharCode.apply(String, Array.from(u8arr))));
};
exports.decodeString = decodeString;


/***/ }),

/***/ 0:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
});

/***/ }),

/***/ "../zego_express_web_rtm/dist/live/index.js":
/*!**************************************************!*\
  !*** ../zego_express_web_rtm/dist/live/index.js ***!
  \**************************************************/
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_573__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_573__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_573__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_573__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_573__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_573__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_573__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__nested_webpack_require_573__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __nested_webpack_require_573__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__nested_webpack_require_573__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_573__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_573__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_573__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_573__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_573__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_573__(__nested_webpack_require_573__.s = "./sdk/src/modules/live/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./sdk/src/modules/live/action.ts":
/*!****************************************!*\
  !*** ./sdk/src/modules/live/action.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ZEGO_RTM_ACTION = void 0;
var ZEGO_RTM_ACTION;
(function (ZEGO_RTM_ACTION) {
    ZEGO_RTM_ACTION["LIVE_SEND_SIGNAL"] = "zm.lv.ssg";
    ZEGO_RTM_ACTION["LIVE_RESPOND_JOIN_LIVE"] = "zm.lv.rjl";
    ZEGO_RTM_ACTION["LIVE_PUSH_SIGNAL"] = "zm.lv.pss";
    ZEGO_RTM_ACTION["SERVICE_PUSH"] = "zm.sv.ps";
    ZEGO_RTM_ACTION["SERVICE_SEND"] = "zm.sv.sd";
})(ZEGO_RTM_ACTION = exports.ZEGO_RTM_ACTION || (exports.ZEGO_RTM_ACTION = {}));


/***/ }),

/***/ "./sdk/src/modules/live/content.ts":
/*!*****************************************!*\
  !*** ./sdk/src/modules/live/content.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_5071__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.modulePros = exports.servicePros = exports.rtmPros = void 0;
// @ts-nocheck
var action_1 = __nested_webpack_require_5071__(/*! ./action */ "./sdk/src/modules/live/action.ts");
var error_1 = __nested_webpack_require_5071__(/*! ./error */ "./sdk/src/modules/live/error.ts");
var liveHandler_1 = __nested_webpack_require_5071__(/*! ./liveHandler */ "./sdk/src/modules/live/liveHandler.ts");
function requestJoinLive(destIdName, success, error, resultCallback, roomID) {
    var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
    if (!room) {
        error && error(error_1.errorCodeList.ROOM_NOT_EXIST, 0);
        return false;
    }
    return room.liveHandler.requestJoinLive(destIdName, success, error, resultCallback);
}
function inviteJoinLive(destIdName, success, error, resultCallback, roomID) {
    var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
    if (!room) {
        error && error(error_1.errorCodeList.ROOM_NOT_EXIST, 0);
        return false;
    }
    return room.liveHandler.inviteJoinLive(destIdName, success, error, resultCallback);
}
function endJoinLive(destIdName, success, error, roomID) {
    var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
    if (!room) {
        error && error(error_1.errorCodeList.ROOM_NOT_EXIST, 0);
        return false;
    }
    return room.liveHandler.endJoinLive(destIdName, success, error);
}
function respondJoinLive(requestId, respondResult, success, error, roomID) {
    var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
    if (!room) {
        error && error(error_1.errorCodeList.ROOM_NOT_EXIST, 0);
        return false;
    }
    return room.liveHandler.respondJoinLive(requestId, respondResult, success, error);
}
exports.rtmPros = {
    requestJoinLive: requestJoinLive,
    inviteJoinLive: inviteJoinLive,
    endJoinLive: endJoinLive,
    respondJoinLive: respondJoinLive,
};
function handlePushSignalMsg(msg) {
    var _a;
    var roomID = (_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id;
    var room = this.stateCenter.roomModulesList.find(function (roomModules) { return roomModules.roomID == roomID; });
    if (!room) {
        this.logger.error(action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + ' room no found ignore ' + JSON.stringify(msg));
        return;
    }
    room.liveHandler.handlePushSignalMsg(msg);
}
exports.servicePros = {
    handlePushSignalMsg: handlePushSignalMsg,
};
function initLiveHandler() {
    this.liveHandler = new liveHandler_1.LiveHandler(this.logger, this.stateCenter, this.service, this.liveRoomHandler, this.rtm, this);
}
exports.modulePros = {
    initLiveHandler: initLiveHandler,
};


/***/ }),

/***/ "./sdk/src/modules/live/entity.ts":
/*!****************************************!*\
  !*** ./sdk/src/modules/live/entity.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ENUM_PUSH_SIGNAL_SUB_CMD = exports.ENUM_SIGNAL_SUB_CMD = void 0;
exports.ENUM_SIGNAL_SUB_CMD = {
    none: 0,
    joinLiveRequest: 1001,
    joinLiveResult: 1002,
    joinLiveInvite: 1003,
    joinLiveStop: 1004,
};
exports.ENUM_PUSH_SIGNAL_SUB_CMD = {
    none: 0,
    pushJoinLiveRequest: 11001,
    pushJoinLiveResult: 11002,
    pushJoinLiveInvite: 11003,
    pushJoinLiveStop: 11004,
};


/***/ }),

/***/ "./sdk/src/modules/live/error.ts":
/*!***************************************!*\
  !*** ./sdk/src/modules/live/error.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.errorCodeList = void 0;
exports.errorCodeList = {
    ROOM_NOT_EXIST: {
        code: 1002014,
        msg: 'room not exist',
    },
    ROOM_INNER_ERROR: {
        code: 1002099,
        msg: 'room inner error',
    },
};


/***/ }),

/***/ "./sdk/src/modules/live/index.ts":
/*!***************************************!*\
  !*** ./sdk/src/modules/live/index.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_9500__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//@ts-nocheck
var content_1 = __nested_webpack_require_9500__(/*! ./content */ "./sdk/src/modules/live/content.ts");
exports.default = {
    type: 'live',
    install: function (rtm, liveRoomModule, service, liveRoomHandler) {
        for (var key in content_1.rtmPros) {
            Object.defineProperty(rtm.prototype, key, {
                value: content_1.rtmPros[key],
                writable: false,
            });
        }
        for (var key in content_1.servicePros) {
            Object.defineProperty(service.prototype, key, {
                value: content_1.servicePros[key],
                writable: false,
            });
            Object.defineProperty(liveRoomHandler.prototype, key, {
                value: content_1.servicePros[key],
                writable: false,
            });
        }
        for (var key in content_1.modulePros) {
            Object.defineProperty(liveRoomModule.prototype, key, {
                value: content_1.modulePros[key],
                writable: false,
            });
        }
    },
};


/***/ }),

/***/ "./sdk/src/modules/live/liveHandler.ts":
/*!*********************************************!*\
  !*** ./sdk/src/modules/live/liveHandler.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_10921__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveHandler = void 0;
var entity_1 = __nested_webpack_require_10921__(/*! ./entity */ "./sdk/src/modules/live/entity.ts");
var action_1 = __nested_webpack_require_10921__(/*! ./action */ "./sdk/src/modules/live/action.ts");
var error_1 = __nested_webpack_require_10921__(/*! ./error */ "./sdk/src/modules/live/error.ts");
var LiveHandler = /** @class */ (function () {
    function LiveHandler(logger, stateCenter, service, liveRoomHandler, rtm, room) {
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.service = service;
        this.liveRoomHandler = liveRoomHandler;
        this.rtm = rtm;
        this.room = room;
        this.joinLiveCallbackMap = {};
        this.joinLiveRequestMap = {};
    }
    LiveHandler.prototype.resetLiveHandler = function () {
        // 
        this.joinLiveCallbackMap = {};
        this.joinLiveRequestMap = {};
    };
    LiveHandler.prototype.getSignalCmdContent = function (requestId, dest_id_name, result) {
        var data = {
            request_id: requestId,
            room_id: this.room.roomID,
            from_userid: this.stateCenter.idName,
            from_username: this.stateCenter.nickName,
            to_userid: dest_id_name,
        };
        if (result != undefined) {
            data['result'] = result;
        }
        return JSON.stringify(data);
    };
    LiveHandler.prototype.requestJoinLive = function (destIdName, success, error, resultCallback) {
        var requestId = this.stateCenter.getRequestId();
        var signalCmd = this.getSignalCmdContent(requestId, destIdName);
        if (resultCallback == undefined) {
            return false;
        }
        this.joinLiveCallbackMap[requestId] = resultCallback;
        this.sendSignalCmd(entity_1.ENUM_SIGNAL_SUB_CMD.joinLiveRequest, signalCmd, destIdName, success, error);
        return true;
    };
    //
    LiveHandler.prototype.sendSignalCmd = function (cmd, signalMsg, dest_id_name, success, error) {
        var _this = this;
        if (!this.room.isLogin()) {
            this.logger.error(action_1.ZEGO_RTM_ACTION.LIVE_SEND_SIGNAL + ' state error');
            return;
        }
        var bodyData = {
            sub_cmd: cmd,
            signal_msg: signalMsg,
            dest_id_name: [dest_id_name],
        };
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.sendSignalCmd(bodyData, function (msg) {
            success && success(msg.header.seq);
        }, function (msg) {
            var err = error_1.errorCodeList.ROOM_INNER_ERROR;
            if (!msg.header || !msg.body) {
                msg.code && msg.msg && (err = msg);
                error && error(err, 0);
                return;
            }
            error && error(_this.rtm.getServerError(msg.body.err_code), msg.header.seq);
        }, this.room);
        this.logger.info(action_1.ZEGO_RTM_ACTION.LIVE_SEND_SIGNAL + ' call success' + cmd);
    };
    LiveHandler.prototype.inviteJoinLive = function (destIdName, success, error, resultCallback) {
        var requestId = this.stateCenter.getRequestId();
        var signalCmd = this.getSignalCmdContent(requestId, destIdName);
        if (resultCallback == undefined) {
            return false;
        }
        this.joinLiveCallbackMap[requestId] = resultCallback;
        this.sendSignalCmd(entity_1.ENUM_SIGNAL_SUB_CMD.joinLiveInvite, signalCmd, destIdName, success, error);
        return true;
    };
    LiveHandler.prototype.endJoinLive = function (destIdName, success, error) {
        var requestId = this.stateCenter.getRequestId();
        var signalCmd = this.getSignalCmdContent(requestId, destIdName);
        this.sendSignalCmd(entity_1.ENUM_SIGNAL_SUB_CMD.joinLiveStop, signalCmd, destIdName, success, error);
        return true;
    };
    LiveHandler.prototype.respondJoinLive = function (requestId, respondResult, success, error) {
        var dest_id_name = this.joinLiveRequestMap[requestId];
        if (!dest_id_name) {
            this.logger.info(action_1.ZEGO_RTM_ACTION.LIVE_RESPOND_JOIN_LIVE + ' no dest id name');
            return false;
        }
        var result = 0;
        if (respondResult === true)
            result = 1;
        var signalCmd = this.getSignalCmdContent(requestId, dest_id_name, result);
        this.sendSignalCmd(entity_1.ENUM_SIGNAL_SUB_CMD.joinLiveResult, signalCmd, dest_id_name, success, error);
        delete this.joinLiveRequestMap[requestId];
        return true;
    };
    // push
    LiveHandler.prototype.handlePushSignalMsg = function (msg) {
        var signalMsg = JSON.parse(msg.body.signal_msg);
        this.logger.info(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' hpsm= ', signalMsg);
        switch (msg.body.sub_cmd) {
            case entity_1.ENUM_PUSH_SIGNAL_SUB_CMD.pushJoinLiveRequest:
                this.handlePushJoinLiveRequestMsg(signalMsg);
                break;
            case entity_1.ENUM_PUSH_SIGNAL_SUB_CMD.pushJoinLiveResult:
                this.handlePushJoinLiveResultMsg(signalMsg);
                break;
            case entity_1.ENUM_PUSH_SIGNAL_SUB_CMD.pushJoinLiveInvite:
                this.handlePushJoinLiveInviteMsg(signalMsg);
                break;
            case entity_1.ENUM_PUSH_SIGNAL_SUB_CMD.pushJoinLiveStop:
                this.handlePushJoinLiveStopMsg(signalMsg);
        }
    };
    //push
    LiveHandler.prototype.handlePushJoinLiveRequestMsg = function (signalMsg) {
        var requestId = signalMsg.request_id;
        if (typeof requestId !== 'string') {
            this.logger.error(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' no requestId');
            return;
        }
        var dest_id_name = signalMsg.from_userid;
        if (typeof dest_id_name !== 'string') {
            this.logger.error(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' no from user');
            return;
        }
        this.joinLiveRequestMap[requestId] = dest_id_name;
        this.onRecvJoinLiveRequest(requestId, signalMsg.from_userid, signalMsg.from_username, signalMsg.room_id);
        this.logger.info(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' onRecvJoinLiveRequest ' + dest_id_name);
    };
    LiveHandler.prototype.onRecvJoinLiveRequest = function (requestId, from_userid, from_username, roomid) {
        this.stateCenter.actionListener('recvJoinLiveRequest', requestId, from_userid, from_username, roomid);
    };
    LiveHandler.prototype.handlePushJoinLiveInviteMsg = function (signalMsg) {
        var requestId = signalMsg.request_id;
        if (typeof requestId !== 'string') {
            this.logger.error(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + 'no requestId');
            return;
        }
        var dest_id_name = signalMsg.from_userid;
        if (typeof dest_id_name !== 'string') {
            this.logger.error(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' no from user');
            return;
        }
        this.joinLiveRequestMap[requestId] = dest_id_name;
        this.onRecvInviteJoinLiveRequest(requestId, signalMsg.from_userid, signalMsg.from_username, signalMsg.room_id);
        this.logger.info(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' onRecvInviteJoinLiveRequest ' + dest_id_name);
    };
    LiveHandler.prototype.onRecvInviteJoinLiveRequest = function (requestId, from_userid, from_username, roomid) {
        this.stateCenter.actionListener('recvInviteJoinLiveRequest', requestId, from_userid, from_username, roomid);
    };
    LiveHandler.prototype.handlePushJoinLiveResultMsg = function (signalMsg) {
        var requestId = signalMsg.request_id;
        if (typeof requestId !== 'string') {
            this.logger.error(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' no requestId');
            return;
        }
        var result = signalMsg.result;
        if (result == undefined) {
            this.logger.info(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' no result');
            return;
        }
        var respondResult = result == 1 ? true : false;
        if (this.joinLiveCallbackMap[requestId]) {
            var result_callback = this.joinLiveCallbackMap[requestId];
            if (!result_callback) {
                this.logger.info(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' no callback');
                return;
            }
            this.logger.info(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' joinLiveRequest/invite result ' + respondResult);
            delete this.joinLiveCallbackMap[requestId];
            result_callback(respondResult, signalMsg.from_userid, signalMsg.from_username);
        }
    };
    /*
     *    "zb.lh.hpjlsm": "ZegoExpressEngine.base.LiveHandler.handlePushJoinLiveStopMsg",
     */
    LiveHandler.prototype.handlePushJoinLiveStopMsg = function (signalMsg) {
        var requestId = signalMsg.request_id;
        if (typeof requestId !== 'string') {
            this.logger.error(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' no requestId');
            return;
        }
        this.logger.info(action_1.ZEGO_RTM_ACTION.LIVE_PUSH_SIGNAL + ' onRecvEndJoinLiveCommand ' + signalMsg.from_userid);
        this.onRecvEndJoinLiveCommand(requestId, signalMsg.from_userid, signalMsg.from_username, signalMsg.room_id);
    };
    LiveHandler.prototype.onRecvEndJoinLiveCommand = function (requestId, from_userid, from_username, roomid) {
        this.stateCenter.actionListener('recvEndJoinLiveCommand', requestId, from_userid, from_username, roomid);
    };
    return LiveHandler;
}());
exports.LiveHandler = LiveHandler;


/***/ })

/******/ });
});

/***/ }),

/***/ "../zego_express_web_rtm/dist/message/index.js":
/*!*****************************************************!*\
  !*** ../zego_express_web_rtm/dist/message/index.js ***!
  \*****************************************************/
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_573__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_573__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_573__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_573__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_573__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_573__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_573__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__nested_webpack_require_573__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __nested_webpack_require_573__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__nested_webpack_require_573__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_573__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_573__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_573__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_573__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_573__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_573__(__nested_webpack_require_573__.s = "./sdk/src/modules/message/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};


/***/ }),

/***/ "./sdk/src/modules/message/action.ts":
/*!*******************************************!*\
  !*** ./sdk/src/modules/message/action.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ZEGO_RTM_ACTION = void 0;
var ZEGO_RTM_ACTION;
(function (ZEGO_RTM_ACTION) {
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_SEND_CUSTOM"] = "zm.scc";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_SEND_BCM"] = "zm.sbcm";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_SEND_RLM"] = "zm.srlm";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_SEND_BRM"] = "zm.sbrm";
    ZEGO_RTM_ACTION["ZEGOEXPRESSWEBRTM_SEND_RAM"] = "zm.sram";
    ZEGO_RTM_ACTION["MESSAGE_SEND_RELIABLE"] = "zm.msg.sdr";
    ZEGO_RTM_ACTION["MESSAGE_FETCH_RELIABLE"] = "zm.msg.frm";
    ZEGO_RTM_ACTION["MESSAGE_RELIABLE_RSP"] = "zm.msg.rlr";
    ZEGO_RTM_ACTION["MESSAGE_RELIABLE_PUSH"] = "zm.msg.rps";
    ZEGO_RTM_ACTION["MESSAGE_SEND_ROOM_MSG"] = "zm.msg.srm";
    ZEGO_RTM_ACTION["MESSAGE_SEND_CUSTOM_MSG"] = "zm.msg.scm";
    ZEGO_RTM_ACTION["MESSAGE_SEND_BIG_MSG"] = "zm.msg.sbm";
    ZEGO_RTM_ACTION["MESSAGE_BIG_MSG_PUSH"] = "zm.msg.bps";
    ZEGO_RTM_ACTION["MESSAGE_SEND_RELAY_MSG"] = "zm.msg.slm";
    ZEGO_RTM_ACTION["SERVICE_PUSH"] = "zm.sv.ps";
})(ZEGO_RTM_ACTION = exports.ZEGO_RTM_ACTION || (exports.ZEGO_RTM_ACTION = {}));


/***/ }),

/***/ "./sdk/src/modules/message/content.ts":
/*!********************************************!*\
  !*** ./sdk/src/modules/message/content.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_46099__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.modulePros = exports.initMessageHandler = exports.servicePros = exports.handlePushMsg = exports.handleBigImMsgRsp = exports.handlePushTransMsg = exports.handlePushMergeMsg = exports.handlePushCustomMsg = exports.handlePushRoomMsg = exports.rtmPros = void 0;
// @ts-nocheck
var action_1 = __nested_webpack_require_46099__(/*! ./action */ "./sdk/src/modules/message/action.ts");
var log_event_1 = __nested_webpack_require_46099__(/*! ./log.event */ "./sdk/src/modules/message/log.event.ts");
var entity_1 = __nested_webpack_require_46099__(/*! ./entity */ "./sdk/src/modules/message/entity.ts");
var messageHandler_1 = __nested_webpack_require_46099__(/*! ./messageHandler */ "./sdk/src/modules/message/messageHandler.ts");
var error_1 = __nested_webpack_require_46099__(/*! ./error */ "./sdk/src/modules/message/error.ts");
function _sendBroadcastMessage(roomID, message, category, type) {
    var _this = this;
    if (category === void 0) { category = 1; }
    if (type === void 0) { type = 1; }
    return new Promise(function (resolve, reject) {
        // --log event start
        var reportSeq = _this.getReportSeq();
        _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendRoomMessage.event);
        var _a = _this.proxyRes(_this.dataReport, reportSeq, resolve, reject), interResolve = _a.interResolve, interReject = _a.interReject;
        if (typeof roomID !== 'string' || roomID == '') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_BCM + ' roomid must be string and not empty');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendRoomMessage.error.INPUT_PARAM, ' param roomID error');
            return;
        }
        if (message === undefined || message == '') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_BCM + ' message is empty');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendRoomMessage.error.IM_CONTENT_NULL);
            return;
        }
        if (typeof message !== 'string') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_BCM + ' message must be string');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendRoomMessage.error.INPUT_PARAM, ' param message error');
            return;
        }
        if (message.length > entity_1.MAX_MESSAGE_LENGTH) {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_BCM + ' message too long');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendRoomMessage.error.IM_CONTENT_TOO_LONG);
            return;
        }
        var room = _this.stateCenter.type == 'PUBLIC' ? _this.getRoomModules(roomID) : _this.stateCenter.priModules;
        if (!room) {
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendRoomMessage.error.ROOM_NOT_EXIST);
            return;
        }
        _this.dataReport.addMsgInfo(reportSeq, {
            room_sid: log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendRoomMessage.room_sid(room.sessionID),
        });
        room.messageHandler.sendRoomMsg(category, type, roomID, message, interResolve, interReject);
    });
}
function sendBroadcastMessage(roomID, message) {
    var _this = this;
    return new Promise(function (resolve, reject) {
        _sendBroadcastMessage
            .call(_this, roomID, message)
            .then(function (res) {
            resolve({ errorCode: res.errorCode, messageID: res.messageID, extendedData: res.extendedData });
        })
            .catch(function (err) {
            reject(err);
        });
    });
}
function _sendCustomCommand(roomID, command, toUserList) {
    var _this = this;
    return new Promise(function (resolve, reject) {
        //--- event log start
        var reportSeq = _this.getReportSeq();
        _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendCustomCommand.event);
        var _a = _this.proxyRes(_this.dataReport, reportSeq, resolve, reject), interResolve = _a.interResolve, interReject = _a.interReject;
        //--- event log end
        if (typeof roomID !== 'string' || roomID == '') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_CUSTOM + ' roomid must be string and not empty');
            interReject(error_1.errorCodeList.INPUT_PARAM, ' param roomID error');
            return;
        }
        if (!(toUserList instanceof Array) || toUserList.find(function (user) { return typeof user !== 'string'; })) {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_CUSTOM + ' dstMembers must be string array');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendCustomCommand.error.INPUT_PARAM, ' param toUserList error');
            return;
        }
        if (_this.stateCenter.type === 'PUBLIC' && typeof command !== 'string' && typeof command !== 'object') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_CUSTOM + ' custom content must be a non empty string or object');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendCustomCommand.error.INPUT_PARAM, ' param command error');
            return;
        }
        if (_this.stateCenter.type === 'PRIVATE' && typeof command !== 'string') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_CUSTOM + ' custom content must be a not empty string');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendCustomCommand.error.INPUT_PARAM, ' param command error');
            return;
        }
        if (typeof command === 'string' && command.length > entity_1.MAX_MESSAGE_LENGTH) {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_CUSTOM + ' command too long');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendCustomCommand.error.IM_CONTENT_TOO_LONG);
            return;
        }
        var room = _this.stateCenter.type == 'PUBLIC' ? _this.getRoomModules(roomID) : _this.stateCenter.priModules;
        if (!room) {
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendCustomCommand.error.ROOM_NOT_EXIST);
            return;
        }
        _this.dataReport.addMsgInfo(reportSeq, {
            room_sid: log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendCustomCommand.room_sid(room.sessionID),
        });
        room.messageHandler.sendCustomCommand(toUserList, command, interResolve, interReject);
    });
}
function sendCustomCommand(roomID, command, toUserList) {
    var _this = this;
    return new Promise(function (resolve, reject) {
        _sendCustomCommand
            .call(_this, roomID, command, toUserList)
            .then(function (res) {
            resolve({ errorCode: res.errorCode, extendedData: res.extendedData });
        })
            .catch(function (err) {
            reject(err);
        });
    });
}
function _sendBarrageMessage(roomID, message, category, type) {
    var _this = this;
    if (category === void 0) { category = 1; }
    if (type === void 0) { type = 1; }
    return new Promise(function (resolve, reject) {
        var reportSeq = _this.getReportSeq();
        _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTMLogEvent.kZegoTaskLiveSendRoomBigIM.event);
        var _a = _this.proxyRes(_this.dataReport, reportSeq, resolve, reject), interResolve = _a.interResolve, interReject = _a.interReject;
        if (typeof roomID !== 'string' || roomID == '') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_BRM + 'roomid must be string and not empty');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveSendRoomBigIM.error.INPUT_PARAM, ' param roomID error');
            return;
        }
        if (message === undefined || message == '') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_BRM + ' message is empty');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveSendRoomBigIM.error.IM_CONTENT_NULL);
            return;
        }
        if (typeof message !== 'string') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_BRM + ' message must be string');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveSendRoomBigIM.error.INPUT_PARAM, ' param message error');
            return;
        }
        if (message.length > entity_1.MAX_MESSAGE_LENGTH) {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_BRM + ' message too long');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveSendRoomBigIM.error.IM_CONTENT_TOO_LONG);
            return;
        }
        var room = _this.stateCenter.type == 'PUBLIC' ? _this.getRoomModules(roomID) : _this.stateCenter.priModules;
        if (!room) {
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveSendRoomBigIM.error.ROOM_NOT_EXIST);
            return;
        }
        _this.dataReport.addMsgInfo(reportSeq, {
            room_sid: log_event_1.ZegoRTMLogEvent.kZegoTaskLiveSendRoomBigIM.room_sid(room.sessionID),
        });
        room.messageHandler.sendBigRoomMessage(category, type, roomID, message, interResolve, interReject);
    });
}
function sendBarrageMessage(roomID, message) {
    var _this = this;
    return new Promise(function (resolve, reject) {
        _sendBarrageMessage
            .call(_this, roomID, message)
            .then(function (res) {
            resolve({ errorCode: res.errorCode, messageID: res.messageID, extendedData: res.extendedData });
        })
            .catch(function (err) {
            reject(err);
        });
    });
}
function _setRoomExtraInfo(roomID, type, data) {
    var _this = this;
    return new Promise(function (resolve, reject) {
        // TODO 
        var reportSeq = _this.getReportSeq();
        _this.dataReport.newReport(reportSeq, log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendReliableMessage.event);
        var _a = _this.proxyRes(_this.dataReport, reportSeq, resolve, reject), interResolve = _a.interResolve, interReject = _a.interReject;
        if (typeof roomID !== 'string' || roomID == '') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_BCM + ' roomid must be string and not empty');
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendRoomMessage.error.INPUT_PARAM, ' param roomID error');
            return;
        }
        if (!type || typeof type !== 'string') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_RLM + ' type must be string');
            interReject({ errorCode: log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendReliableMessage.error.INPUT_PARAM.code });
            return;
        }
        if (type.length > entity_1.MAX_TRANS_TYPE_LENGTH) {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_RLM + ' type is too long');
            interReject({ errorCode: log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendReliableMessage.error.INPUT_PARAM.code });
            return;
        }
        if (!data || typeof data !== 'string') {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_RLM + ' data must be string');
            interReject({ errorCode: log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendReliableMessage.error.INPUT_PARAM.code });
            return;
        }
        if (data.length > entity_1.MAX_TRANS_DATA_LENGTH) {
            _this.logger.error(action_1.ZEGO_RTM_ACTION.ZEGOEXPRESSWEBRTM_SEND_RLM + ' type is too long');
            interReject({ errorCode: log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendReliableMessage.error.INPUT_PARAM.code });
            return;
        }
        // const interResolve = (seq: number): void => {
        //     resolve({ errorCode: 0 });
        // };
        var room = _this.stateCenter.type == 'PUBLIC' ? _this.getRoomModules(roomID) : _this.stateCenter.priModules;
        if (!room) {
            interReject(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendReliableMessage.error.ROOM_NOT_EXIST);
            return;
        }
        _this.dataReport.addMsgInfo(reportSeq, {
            room_sid: log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendReliableMessage.room_sid(room.sessionID),
        });
        room.messageHandler.sendReliableMessage(type, data, interResolve, interReject);
    });
}
function setRoomExtraInfo(roomID, type, data) {
    return _setRoomExtraInfo.call(this, roomID, type, data);
}
function sendRelayMessage(type, data, success, error, roomID) {
    var room = this.getRoomModules(roomID) || this.stateCenter.roomModulesList[0];
    if (!room) {
        error && error(error_1.errorCodeList.ROOM_NOT_EXIST, 0);
        return;
    }
    room.messageHandler.sendRelayMessage(type, data, success, error);
}
exports.rtmPros = {
    _sendBroadcastMessage: _sendBroadcastMessage,
    sendBroadcastMessage: sendBroadcastMessage,
    _sendCustomCommand: _sendCustomCommand,
    sendCustomCommand: sendCustomCommand,
    _sendBarrageMessage: _sendBarrageMessage,
    sendBarrageMessage: sendBarrageMessage,
    _setRoomExtraInfo: _setRoomExtraInfo,
    setRoomExtraInfo: setRoomExtraInfo,
    sendRelayMessage: sendRelayMessage,
};
function handlePushRoomMsg(msg) {
    var _a = this.handlePushMsg(msg), room = _a[0], msg = _a[1];
    room.messageHandler.handlePushRoomMsg(msg);
}
exports.handlePushRoomMsg = handlePushRoomMsg;
function handlePushCustomMsg(msg) {
    var _a = this.handlePushMsg(msg), room = _a[0], msg = _a[1];
    room.messageHandler.handlePushCustomMsg(msg);
}
exports.handlePushCustomMsg = handlePushCustomMsg;
function handlePushMergeMsg(msg) {
    var _a;
    var roomID = (_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id;
    var room = this.stateCenter.type == 'PUBLIC' ? this.rtm.getRoomModules(roomID) : this.stateCenter.priModules;
    if (!room) {
        this.logger.error(action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + ' room no found ignore ' + JSON.stringify(msg));
        return;
    }
    room.messageHandler.handlePushMergeMsg(msg);
}
exports.handlePushMergeMsg = handlePushMergeMsg;
function handlePushTransMsg(msg) {
    var _a = this.handlePushMsg(msg), room = _a[0], msg = _a[1];
    room.messageHandler.handlePushTransMsg(msg);
}
exports.handlePushTransMsg = handlePushTransMsg;
function handleBigImMsgRsp(msg) {
    var _a;
    var roomID = (_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id;
    var room = this.stateCenter.type == 'PUBLIC' ? this.rtm.getRoomModules(roomID) : this.stateCenter.priModules;
    if (!room) {
        this.logger.error(action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + ' room no found ignore ' + JSON.stringify(msg));
        return;
    }
    room.messageHandler.handleBigImMsgRsp(msg);
}
exports.handleBigImMsgRsp = handleBigImMsgRsp;
function handlePushMsg(msg) {
    var _a;
    var roomID = (_a = msg === null || msg === void 0 ? void 0 : msg.header) === null || _a === void 0 ? void 0 : _a.room_id;
    var room = this.rtm.getRoomModules(roomID);
    if (!room) {
        this.logger.error(action_1.ZEGO_RTM_ACTION.SERVICE_PUSH + ' room no found ignore ' + JSON.stringify(msg));
        return;
    }
    // if (this.stateCenter.useNetAgent) {
    //     msg.body = msg.msg_body;
    //     delete msg.msg_body;
    // }
    return [room, msg];
}
exports.handlePushMsg = handlePushMsg;
exports.servicePros = {
    handlePushRoomMsg: handlePushRoomMsg,
    handlePushCustomMsg: handlePushCustomMsg,
    handlePushMergeMsg: handlePushMergeMsg,
    handlePushTransMsg: handlePushTransMsg,
    handleBigImMsgRsp: handleBigImMsgRsp,
    handlePushMsg: handlePushMsg,
};
function initMessageHandler() {
    this.messageHandler = new messageHandler_1.MessageHandler(this.logger, this.stateCenter, this.dataReport, this.service, this.liveRoomHandler, this.rtm, this);
}
exports.initMessageHandler = initMessageHandler;
exports.modulePros = {
    initMessageHandler: initMessageHandler,
};


/***/ }),

/***/ "./sdk/src/modules/message/entity.ts":
/*!*******************************************!*\
  !*** ./sdk/src/modules/message/entity.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_MESSAGE_LENGTH = exports.MAX_TRANS_DATA_LENGTH = exports.MAX_TRANS_TYPE_LENGTH = exports.ERROR_CODES = void 0;
exports.ERROR_CODES = {
    FETCH_TRANS_UNKNOWN_CHANNEL: 1000001108,
    FETCH_TRANS_UNKNOWN_TYPE: 1000001109,
    FETCH_TRANS_WRONG_SEQ: 1000001110,
};
exports.MAX_TRANS_TYPE_LENGTH = 128;
exports.MAX_TRANS_DATA_LENGTH = 1024 * 4;
exports.MAX_MESSAGE_LENGTH = 1024;


/***/ }),

/***/ "./sdk/src/modules/message/error.ts":
/*!******************************************!*\
  !*** ./sdk/src/modules/message/error.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.errorCodeList = void 0;
exports.errorCodeList = {
    INPUT_PARAM: {
        code: 1100001,
        msg: 'input parm error.',
    },
    TIMEOUT: {
        code: 1100002,
        msg: 'network timeout.',
    },
    IM_CONTENT_NULL: {
        code: 1009001,
        msg: 'message content is empty',
    },
    IM_CONTENT_TOO_LONG: {
        code: 1009002,
        msg: 'message content is too long',
    },
    IM_SEND_FAILED: {
        code: 1009010,
        msg: 'failed to send message',
    },
    ROOM_NOT_EXIST: {
        code: 1002014,
        msg: 'room not exist',
    },
    ROOM_INNER_ERROR: {
        code: 1002099,
        msg: 'room inner error',
    },
    TRANS_FREQUENTLY: {
        code: 1102022,
        msg: 'trans send frequently',
    },
    FREQ_LIMITED: {
        code: 1109001,
        msg: 'frequency limited.',
    },
};


/***/ }),

/***/ "./sdk/src/modules/message/index.ts":
/*!******************************************!*\
  !*** ./sdk/src/modules/message/index.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_64522__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
//@ts-nocheck
var content_1 = __nested_webpack_require_64522__(/*! ./content */ "./sdk/src/modules/message/content.ts");
exports.default = {
    type: 'message',
    install: function (rtm, liveRoomModule, service, liveRoomHandler, priLiveRoomModule, priService) {
        for (var key in content_1.rtmPros) {
            Object.defineProperty(rtm.prototype, key, {
                value: content_1.rtmPros[key],
                writable: false,
            });
        }
        for (var key in content_1.servicePros) {
            Object.defineProperty(service.prototype, key, {
                value: content_1.servicePros[key],
                writable: false,
            });
            Object.defineProperty(priService.prototype, key, {
                value: content_1.servicePros[key],
                writable: false,
            });
            Object.defineProperty(liveRoomHandler.prototype, key, {
                value: content_1.servicePros[key],
                writable: false,
            });
        }
        for (var key in content_1.modulePros) {
            Object.defineProperty(liveRoomModule.prototype, key, {
                value: content_1.modulePros[key],
                writable: false,
            });
            Object.defineProperty(priLiveRoomModule.prototype, key, {
                value: content_1.modulePros[key],
                writable: false,
            });
        }
    },
};


/***/ }),

/***/ "./sdk/src/modules/message/log.event.ts":
/*!**********************************************!*\
  !*** ./sdk/src/modules/message/log.event.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_66316__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ZegoRTMLogEvent = void 0;
var error_1 = __nested_webpack_require_66316__(/*! ./error */ "./sdk/src/modules/message/error.ts");
var getItem = function (item) { return item; };
exports.ZegoRTMLogEvent = {
    kZegoTaskLiveSendRoomBigIM: {
        event: '/liveroom/send_big_room_message',
        room_sid: getItem,
        error: {
            INPUT_PARAM: error_1.errorCodeList.INPUT_PARAM,
            IM_CONTENT_NULL: error_1.errorCodeList.IM_CONTENT_NULL,
            IM_CONTENT_TOO_LONG: error_1.errorCodeList.IM_CONTENT_TOO_LONG,
            ROOM_NOT_EXIST: error_1.errorCodeList.ROOM_NOT_EXIST,
        },
    },
    kZegoTaskLiveRoomSendCustomCommand: {
        event: '/liveroom/send_custom_command',
        room_sid: getItem,
        error: {
            INPUT_PARAM: error_1.errorCodeList.INPUT_PARAM,
            IM_CONTENT_NULL: error_1.errorCodeList.IM_CONTENT_NULL,
            IM_CONTENT_TOO_LONG: error_1.errorCodeList.IM_CONTENT_TOO_LONG,
            ROOM_NOT_EXIST: error_1.errorCodeList.ROOM_NOT_EXIST,
        },
    },
    kZegoTaskLiveRoomSendRoomMessage: {
        event: '/liveroom/send_room_message',
        room_sid: getItem,
        error: {
            INPUT_PARAM: error_1.errorCodeList.INPUT_PARAM,
            IM_CONTENT_NULL: error_1.errorCodeList.IM_CONTENT_NULL,
            IM_CONTENT_TOO_LONG: error_1.errorCodeList.IM_CONTENT_TOO_LONG,
            ROOM_NOT_EXIST: error_1.errorCodeList.ROOM_NOT_EXIST,
        },
    },
    kZegoTaskLiveRoomSendReliableMessage: {
        event: '/liveroom/send_reliable_message',
        room_sid: getItem,
        error: {
            INPUT_PARAM: error_1.errorCodeList.INPUT_PARAM,
            TRANS_FREQUENTLY: error_1.errorCodeList.TRANS_FREQUENTLY,
            ROOM_NOT_EXIST: error_1.errorCodeList.ROOM_NOT_EXIST,
        },
    },
    kZegoTaskLiveGetRoomBigIM: {
        event: '/liveroom/get_big_room_message',
    },
    kZegoTaskLiveRoomGetRoomMessage: {
        event: '/liveroom/get_room_message',
        room_sid: getItem,
    },
    kZegoTaskLiveRoomGetCustomCommand: {
        event: '/liveroom/get_custom_command',
    },
};


/***/ }),

/***/ "./sdk/src/modules/message/messageHandler.ts":
/*!***************************************************!*\
  !*** ./sdk/src/modules/message/messageHandler.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __nested_webpack_require_68829__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageHandler = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
var error_1 = __nested_webpack_require_68829__(/*! ./error */ "./sdk/src/modules/message/error.ts");
var action_1 = __nested_webpack_require_68829__(/*! ./action */ "./sdk/src/modules/message/action.ts");
var log_event_1 = __nested_webpack_require_68829__(/*! ./log.event */ "./sdk/src/modules/message/log.event.ts");
var entity_1 = __nested_webpack_require_68829__(/*! ./entity */ "./sdk/src/modules/message/entity.ts");
var long_1 = __importDefault(__nested_webpack_require_68829__(/*! long */ "./node_modules/long/src/long.js"));
var MessageHandler = /** @class */ (function () {
    function MessageHandler(logger, stateCenter, dataReport, service, liveRoomHandler, rtm, room) {
        var _this = this;
        this.logger = logger;
        this.stateCenter = stateCenter;
        this.dataReport = dataReport;
        this.service = service;
        this.liveRoomHandler = liveRoomHandler;
        this.rtm = rtm;
        this.room = room;
        this.sendRoomMsgTime = 0; //
        this.sendRoomMsgInterval = 500; //500
        this.bigImCallbackMap = {};
        this.bigImLastTimeIndex = 0;
        this.bigIMmessageList = [];
        this.bigImTimer = null;
        this.relayTimer = null;
        this.serverTimeOffset = 0;
        this.datiTimeWindow = 0;
        this.bigimTimeWindow = 0;
        this.isReliable = false;
        this.transSeqMap = {};
        this.onRecvReliableMessage = function (transResults) {
            var extraInfoList = transResults.map(function (result) {
                return {
                    key: result.trans_type,
                    value: result.trans_data,
                    updateUser: {
                        userID: result.trans_idname,
                        userName: result.trans_nickname,
                    },
                    updateTime: long_1.default.isLong(result.trans_send_time) ? result.trans_send_time.toNumber() : result.trans_send_time,
                };
            });
            _this.stateCenter.actionListener('roomExtraInfoUpdate', _this.room.roomID, extraInfoList);
            transResults.forEach(function (result) {
                _this.stateCenter.actionListener('recvReliableMessage', result.trans_type, result.trans_seq, result.trans_data);
            });
        };
        // ***********************************  end************************************************//
        // *********************************** relay start************************************************//
        this.realyMessageList = [];
    }
    // ***********************************  start************************************************//
    MessageHandler.prototype.loginRsp = function (msg) {
        var _this = this;
        //get time stamp & window
        if (msg.body.ret_timestamp != undefined && typeof msg.body.ret_timestamp == 'string') {
            var serverTime = parseFloat(msg.body.ret_timestamp);
            if (serverTime == 0) {
                this.serverTimeOffset = 0;
            }
            else {
                this.serverTimeOffset = msg.body.ret_timestamp - new Date().getTime();
            }
        }
        if (msg.body.bigim_time_window && typeof msg.body.bigim_time_window == 'number') {
            this.bigimTimeWindow = msg.body.bigim_time_window;
        }
        if (msg.body.dati_time_window && typeof msg.body.dati_time_window == 'number') {
            this.datiTimeWindow = msg.body.dati_time_window;
        }
        // fetch_trans
        if (msg.body.trans_seqs) {
            for (var i = 0; i < msg.body.trans_seqs.length; i++) {
                var trans_channel = msg.body.trans_seqs[i].trans_channel;
                var trans_seq_array = msg.body.trans_seqs[i].trans_seq_array;
                trans_seq_array = trans_seq_array.filter(function (item) {
                    var type = item.trans_type, seq = item.trans_seq;
                    if (!_this.transSeqMap[type] || _this.transSeqMap[type].seq < seq) {
                        return true;
                    }
                    else {
                        return false;
                    }
                });
                trans_seq_array.length > 0 && this.fetchReliableMessage(trans_channel, trans_seq_array);
            }
        }
    };
    MessageHandler.prototype.sendReliableMessage = function (type, data, success, error) {
        var _this = this;
        this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_RELIABLE + ' call');
        if (this.isReliable) {
            this.logger.error(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_RELIABLE + ' send too often');
            error(log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomSendReliableMessage.error.TRANS_FREQUENTLY);
            return;
        }
        if (!this.transSeqMap[type]) {
            this.transSeqMap[type] = {
                seq: 0,
            };
        }
        var body = {
            trans_type: type,
            trans_data: data,
            trans_local_seq: this.transSeqMap[type].seq,
            trans_channel: 'clt',
        };
        this.isReliable = true;
        var sucCallBack = function (msg) {
            //update seq
            _this.transSeqMap[type].seq = msg.body.trans_seq;
            _this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_RELIABLE + ' trans ' + type + ' seq ' + msg.body.trans_seq);
            _this.isReliable = false;
            success({ seq: msg.header.seq, errorCode: 0 });
        };
        var errCallBack = function (msg) {
            var _err = error_1.errorCodeList.ROOM_INNER_ERROR;
            if (msg.body && msg.body.err_code) {
                _err = _this.rtm.getServerError(msg.body.err_code);
                _this.logger.error(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_ROOM_MSG + '  ' + _err.msg);
            }
            else if (msg == error_1.errorCodeList.TIMEOUT) {
                _err = error_1.errorCodeList.IM_SEND_FAILED;
            }
            else {
                _err = msg;
            }
            _this.isReliable = false;
            error(_err);
        };
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.sendReliableMessage(body, sucCallBack, errCallBack, this.room);
    };
    MessageHandler.prototype.fetchReliableMessage = function (trans_channel, fetch_array) {
        var _this = this;
        var data = {
            trans_channel: trans_channel,
            fetch_array: fetch_array,
        };
        var callBack = function (msg) {
            _this.handleFetchTransRsp(msg);
        };
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.fetchReliableMessage(data, callBack, callBack, this.room);
        this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_FETCH_RELIABLE + ' call success');
    };
    //fetch trans 
    MessageHandler.prototype.handleFetchTransRsp = function (msg) {
        if (msg.body && msg.body.err_code != 0) {
            this.logger.error(action_1.ZEGO_RTM_ACTION.MESSAGE_RELIABLE_RSP + ' trans send error ' + msg.body.err_code);
            return;
        }
        if (!msg.header || !msg.body) {
            this.logger.error(action_1.ZEGO_RTM_ACTION.MESSAGE_RELIABLE_RSP + ' trans send error ' + msg);
            return;
        }
        var trans_fetch_results = msg.body.trans_fetch_results;
        var transResults = [];
        if (Array.isArray(trans_fetch_results) && trans_fetch_results.length > 0) {
            for (var i = 0; i < trans_fetch_results.length; i++) {
                var trans_fetch_result = trans_fetch_results[i];
                if (trans_fetch_result.err_code === entity_1.ERROR_CODES.FETCH_TRANS_UNKNOWN_TYPE) {
                    this.logger.warn(action_1.ZEGO_RTM_ACTION.MESSAGE_RELIABLE_RSP +
                        ' fetch trans unknown type ' +
                        trans_fetch_result.err_code);
                    continue;
                }
                var type = trans_fetch_result.trans_type;
                var seq = trans_fetch_result.trans_seq;
                if (trans_fetch_result.err_code === entity_1.ERROR_CODES.FETCH_TRANS_WRONG_SEQ) {
                    this.logger.warn(action_1.ZEGO_RTM_ACTION.MESSAGE_RELIABLE_RSP +
                        ' fetch trans seq is wrong ' +
                        trans_fetch_result.err_code);
                    this.transSeqMap[type] = {
                        seq: seq,
                    };
                    continue;
                }
                if (!this.transSeqMap[type] || this.transSeqMap[type].seq < seq) {
                    this.transSeqMap[type] = {
                        seq: seq,
                    };
                    transResults.push(trans_fetch_result);
                }
                else {
                    this.logger.warn(action_1.ZEGO_RTM_ACTION.MESSAGE_RELIABLE_RSP + ' fetch trans seq wrong');
                }
                transResults.length > 0 && this.onRecvReliableMessage(transResults);
            }
        }
    };
    MessageHandler.prototype.handlePushTransMsg = function (msg) {
        var type = msg.body.trans_type;
        var seq = msg.body.trans_seq;
        if (!this.transSeqMap[type] || this.transSeqMap[type].seq < seq) {
            this.transSeqMap[type] = {
                seq: seq,
            };
            this.onRecvReliableMessage([msg.body]);
        }
        else {
            this.logger.warn(action_1.ZEGO_RTM_ACTION.MESSAGE_RELIABLE_PUSH + ' trans seq wrong');
        }
        this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_RELIABLE_PUSH + ' trans ' + type + ' seq ' + seq);
    };
    // ***********************************  edn************************************************//
    // ***********************************  start************************************************//
    MessageHandler.prototype.sendRoomMsg = function (msg_category, type, room_id, msg_content, success, error) {
        var _this = this;
        // 
        if (!this.room.isLogin()) {
            this.logger.error(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_ROOM_MSG + ' state error');
            return false;
        }
        var timestamp = Date.parse(new Date() + '');
        if (this.sendRoomMsgTime > 0 && this.sendRoomMsgTime + this.sendRoomMsgInterval > timestamp) {
            this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_ROOM_MSG + ' freq error');
            if (error) {
                error(error_1.errorCodeList.FREQ_LIMITED, 0, msg_category, msg_content);
            }
            return false;
        }
        this.sendRoomMsgTime = timestamp;
        var bodyData = {
            msg_category: msg_category,
            msg_type: 1,
            msg_priority: 1,
            msg_content: msg_content,
        };
        var sucCallBack = function (msg) {
            success({ seq: msg.header.seq, errorCode: 0, messageID: msg.body.msg_id });
        };
        var errCallBack = function (msg) {
            var _a;
            var err = error_1.errorCodeList.ROOM_INNER_ERROR;
            var msgID = 0;
            if (!msg.header || !msg.body) {
                msg.code && msg.msg && (err = msg);
                error({ seq: 0, errorCode: err.code, messageID: 0 });
                return;
            }
            _a = [
                _this.rtm.getServerError(_this.stateCenter.type == 'PRIVATE' ? msg.body.code : msg.body.err_code),
                msg.body.msg_id,
            ], err = _a[0], msgID = _a[1];
            _this.logger.error(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_ROOM_MSG + '  ' + err.msg);
            if (err == error_1.errorCodeList.TIMEOUT) {
                err = error_1.errorCodeList.IM_SEND_FAILED;
            }
            error({ seq: msg.header.seq, errorCode: err.code, messageID: msgID });
        };
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.sendRoomMsg(bodyData, sucCallBack, errCallBack, this.room);
        this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_ROOM_MSG + '  call success');
        return true;
    };
    MessageHandler.prototype.handlePushRoomMsg = function (msg) {
        var _this = this;
        var roomSid = '';
        if (this.stateCenter.useNetAgent) {
            roomSid = this.room.roomSessionID;
        }
        else {
            roomSid = msg.header.session_id;
        }
        var seq = this.rtm.getReportSeq();
        this.dataReport.newReport(seq);
        this.dataReport.addMsgInfo(seq, {
            room_sid: log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomGetRoomMessage.room_sid(roomSid),
        });
        var chatData = [];
        if (this.stateCenter.useNetAgent) {
            msg.body.msg_data.forEach(function (data) {
                var chatInfo = {
                    fromUser: {
                        userID: data.id_name,
                        userName: data.nick_name,
                    },
                    message: data.msg_content,
                    sendTime: data.send_time.toNumber(),
                    messageID: data.msg_id.toNumber(),
                };
                chatData.push(chatInfo);
            });
            msg.body.server_msg_id = msg.body.server_msg_id.toNumber();
            msg.body.ret_msg_id = msg.body.ret_msg_id.toNumber();
        }
        else {
            msg.body.chat_data.forEach(function (data) {
                var chatInfo = {
                    fromUser: {
                        userID: data.id_name,
                        userName: data.nick_name,
                    },
                    message: data.msg_content,
                    sendTime: data.send_time,
                    messageID: data.msg_id,
                };
                chatData.push(chatInfo);
                _this.dataReport.addMsgInfo(seq, {
                    from_msg_id: data.id_name,
                });
            });
        }
        this.dataReport.uploadReport(seq, log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomGetRoomMessage.event);
        this.stateCenter.actionListener('IMRecvBroadcastMessage', this.room.roomID, chatData);
        this.stateCenter.actionListener('_recvRoomMsg', msg.body.chat_data, msg.body.server_msg_id, msg.body.ret_msg_id);
    };
    // ***********************************  end************************************************//
    // ***********************************  start************************************************//
    MessageHandler.prototype.sendCustomCommand = function (dstMembers, customContent, success, error) {
        var _this = this;
        if (!this.room.isLogin()) {
            this.logger.error(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_CUSTOM_MSG + ' state error');
            return false;
        }
        var customContent_send = {
            from_userid: this.stateCenter.idName,
            from_username: this.stateCenter.nickName,
            request_id: this.stateCenter.getRequestId(),
            custom_content: customContent || '',
            room_id: this.room.roomID,
        };
        var bodyData = {
            dest_id_name: dstMembers,
            custom_msg: JSON.stringify(customContent_send),
        };
        var sucCallBack = function (msg) {
            success({ seq: msg.header.seq, errorCode: 0 });
        };
        var errCallBack = function (msg) {
            // TODO
            var err = _this.rtm.getServerError(_this.stateCenter.type == 'PRIVATE' ? msg.body.code : msg.body.err_code);
            _this.logger.error(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_CUSTOM_MSG + ' ' + err.msg);
            var _err;
            if (err == error_1.errorCodeList.TIMEOUT) {
                _err = error_1.errorCodeList.IM_SEND_FAILED;
            }
            else {
                _err = err;
            }
            error({ seq: msg.header.seq, errorCode: _err.code });
        };
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.sendCustomCommand(bodyData, sucCallBack, errCallBack, this.room);
        this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_CUSTOM_MSG + ' call success');
        return true;
    };
    MessageHandler.prototype.handlePushCustomMsg = function (msg) {
        var _a;
        var fromUserId, fromUserName, roomId, command;
        var sub_msg = JSON.parse(msg.body.custommsg);
        _a = [
            sub_msg.from_userid,
            sub_msg.from_username,
            sub_msg.room_id,
            sub_msg.custom_content,
        ], fromUserId = _a[0], fromUserName = _a[1], roomId = _a[2], command = _a[3];
        var seq = this.rtm.getReportSeq();
        this.dataReport.newReport(seq);
        this.dataReport.uploadReport(seq, log_event_1.ZegoRTMLogEvent.kZegoTaskLiveRoomGetCustomCommand.event);
        this.stateCenter.actionListener('IMRecvCustomCommand', roomId, { userID: fromUserId, userName: fromUserName }, command);
    };
    // ***********************************  end************************************************//
    // ***********************************  start************************************************//
    MessageHandler.prototype.sendBigRoomMessage = function (category, type, room_id, content, success, error) {
        var _this = this;
        var timeWindow = this.bigimTimeWindow;
        var offset = this.serverTimeOffset;
        var serverTime = new Date().getTime() + offset;
        var clientId = this.rtm.getSeq().toString();
        this.bigImCallbackMap[clientId] = {
            success: success,
            error: error,
        };
        if (timeWindow == 0) {
            var bodyData = {
                msg_category: category,
                msg_type: 1,
                msg_content: content,
                bigmsg_client_id: clientId,
            };
            this.sendBigRoomMessageInternal([bodyData], function (msg) {
                _this.handleBigImMsgRsp(msg);
            }, function (err) {
                error && error(err);
            });
        }
        else {
            var currentIndex = Math.floor(serverTime / timeWindow);
            if (this.bigImLastTimeIndex < currentIndex && this.bigIMmessageList.length == 0) {
                this.bigImLastTimeIndex = currentIndex;
                var oneData = {
                    msg_category: category,
                    msg_type: 1,
                    msg_content: content,
                    bigmsg_client_id: clientId,
                };
                this.sendBigRoomMessageInternal([oneData], function (msg) {
                    _this.handleBigImMsgRsp(msg);
                }, function (err) {
                    error && error(err);
                });
            }
            else {
                this.bigIMmessageList.push({
                    msg_category: category,
                    msg_type: 1,
                    msg_content: content,
                    bigmsg_client_id: clientId,
                });
                if (this.bigIMmessageList.length == 1) {
                    this.setBigImTimer(offset, timeWindow);
                }
            }
        }
    };
    MessageHandler.prototype.sendBigRoomMessageInternal = function (msgs, success, error) {
        var bodyData = {
            msgs: msgs,
        };
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.sendBigRoomMessage(bodyData, function (msg) {
            success(msg);
        }, function (msg) {
            var err = error_1.errorCodeList.ROOM_INNER_ERROR;
            if (!msg.header || !msg.body) {
                msg.code && msg.msg && (err = msg);
                error(err);
            }
            error(err);
        }, this.room);
        this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_BIG_MSG + ' sendBigRoomMessage called');
    };
    MessageHandler.prototype.handleBigImMsgRsp = function (msg) {
        this.bigimTimeWindow = msg.body.bigim_time_window;
        for (var i = 0; i < msg.body.msgs.length; i++) {
            var clientId = msg.body.msgs[i].bigmsg_client_id;
            var msgId = msg.body.msgs[i].bigmsg_id;
            if (this.bigImCallbackMap[clientId]) {
                var success = this.bigImCallbackMap[clientId].success;
                if (success != null) {
                    // success(msg.header.seq, msgId);
                    success({ seq: msg.header.seq, errorCode: 0, messageID: msgId });
                }
                delete this.bigImCallbackMap[clientId];
            }
        }
    };
    MessageHandler.prototype.setBigImTimer = function (offset, timeWindow) {
        var _this = this;
        var serverTimestamp = new Date().getTime() + offset;
        var residue = timeWindow - (serverTimestamp % timeWindow);
        var interval = this.rtm.generateRandumNumber(timeWindow) + residue;
        this.bigImTimer = setTimeout(function () {
            _this.onBigImTimer();
        }, interval);
    };
    MessageHandler.prototype.onBigImTimer = function () {
        var _this = this;
        var serverTimestamp = new Date().getTime() + this.serverTimeOffset;
        this.bigImLastTimeIndex = Math.floor(serverTimestamp / this.bigimTimeWindow);
        var bodyData = [];
        var requestList = [];
        for (var i = 0; i < this.bigIMmessageList.length; i++) {
            if (i >= 20) {
                break;
            }
            var info = this.bigIMmessageList[i];
            bodyData.push({
                msg_category: info.msg_category,
                msg_type: info.msg_type,
                msg_content: info.msg_content,
                bigmsg_client_id: info.bigmsg_client_id,
            });
            requestList.push(info.bigmsg_client_id);
        }
        if (this.bigIMmessageList.length > 20) {
            this.bigIMmessageList.splice(0, 20);
        }
        else {
            this.bigIMmessageList = [];
        }
        this.sendBigRoomMessageInternal(bodyData, function (msg) {
            _this.handleBigImMsgRsp(msg);
        }, function (err, seq) {
            for (var i = 0; i < requestList.length; i++) {
                var clientId = requestList[i];
                var callbackInfo = _this.bigImCallbackMap[clientId];
                if (callbackInfo) {
                    if (callbackInfo.error != null) {
                        callbackInfo.error(err, seq);
                    }
                    delete _this.bigImCallbackMap[clientId];
                }
            }
        });
        this.bigImTimer && clearTimeout(this.bigImTimer);
        this.bigImTimer = null;
        if (this.bigIMmessageList.length > 0) {
            this.setBigImTimer(this.serverTimeOffset, this.bigimTimeWindow);
        }
    };
    MessageHandler.prototype.handlePushMergeMsg = function (msg) {
        for (var i = 0; i < msg.body.messages.length; i++) {
            if (msg.body.messages[i].sub_cmd === 14001 || msg.body.messages[i].sub_cmd === '/lr/push/bigim_chat') {
                this.handlePushBigRooMsg(msg.body.messages[i].msg_body);
            }
        }
    };
    MessageHandler.prototype.handlePushBigRooMsg = function (bodyString) {
        var messageBody;
        //messageBody json
        if (typeof bodyString === 'string') {
            try {
                messageBody = JSON.parse(bodyString);
            }
            catch (e) {
                this.logger.warn(action_1.ZEGO_RTM_ACTION.MESSAGE_BIG_MSG_PUSH + 'parse json error');
                return;
            }
        }
        else {
            messageBody = bodyString;
        }
        if (!messageBody) {
            this.logger.warn(action_1.ZEGO_RTM_ACTION.MESSAGE_BIG_MSG_PUSH + " cann't find message body");
            return;
        }
        var roomId = messageBody.room_id;
        var pushData = [];
        for (var i = 0; i < messageBody.msg_data.length; i++) {
            var message = messageBody.msg_data[i];
            var idName = message.id_name;
            if (idName == this.stateCenter.idName) {
                this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_BIG_MSG_PUSH + ' self message');
                continue;
            }
            pushData.push({
                idName: message.id_name,
                nickName: message.nick_name,
                messageId: message.bigmsg_id,
                category: message.msg_category,
                type: message.msg_type,
                content: message.msg_content,
                time: message.send_time || long_1.default.isLong(message.msg_timestamp) && message.msg_timestamp.toNumber(),
            });
        }
        if (pushData.length == 0) {
            this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_BIG_MSG_PUSH + ' no other pushData except self');
        }
        else {
            this.onRecvBigRoomMessage(pushData, roomId);
        }
        this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_BIG_MSG_PUSH + 'call success');
    };
    MessageHandler.prototype.onRecvBigRoomMessage = function (messageList, roomId) {
        var seq = this.rtm.getReportSeq();
        this.dataReport.newReport(seq);
        var chatData = [];
        messageList.forEach(function (data) {
            var chatInfo = {
                fromUser: {
                    userID: data.idName,
                    userName: data.nickName,
                },
                message: data.content,
                sendTime: data.time,
                messageID: data.messageId,
            };
            chatData.push(chatInfo);
        });
        this.dataReport.uploadReport(seq, log_event_1.ZegoRTMLogEvent.kZegoTaskLiveGetRoomBigIM.event);
        this.stateCenter.actionListener('IMRecvBarrageMessage', roomId, chatData);
        this.stateCenter.actionListener('_recvBigRoomMessage', messageList, roomId);
    };
    MessageHandler.prototype.resetMessageInfo = function () {
        //trans
        this.transSeqMap = {};
        //relay
        this.realyMessageList = [];
        if (this.relayTimer) {
            clearTimeout(this.relayTimer);
            this.relayTimer = null;
        }
        //
        this.bigImLastTimeIndex = 0;
        this.bigIMmessageList = [];
        this.bigImCallbackMap = {};
        if (this.bigImTimer) {
            clearTimeout(this.bigImTimer);
            this.bigImTimer = null;
        }
        this.serverTimeOffset = 0;
        this.datiTimeWindow = 0;
        this.bigimTimeWindow = 0;
    };
    MessageHandler.prototype.sendRelayMessage = function (type, data, success, error) {
        var timeWindow = this.datiTimeWindow;
        var offset = this.serverTimeOffset;
        if (timeWindow > 0) {
            this.realyMessageList.push({
                type: type,
                data: data,
                success: success,
                error: error,
            });
            if (this.realyMessageList.length == 1) {
                this.setRelayTimer(offset, timeWindow);
            }
        }
        else {
            this.sendRelayMessageInternal(type, data, success, error);
        }
    };
    MessageHandler.prototype.sendRelayMessageInternal = function (type, data, success, error) {
        var _this = this;
        this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_RELAY_MSG + ' call');
        var bodyData = {
            relay_type: type,
            relay_data: data,
        };
        var room = this.room;
        var serviceHandler = this.stateCenter.useNetAgent ? this.liveRoomHandler : this.service;
        serviceHandler.sendRelayMessage(bodyData, function (msg) {
            success && success(msg.header.seq, msg.body.relay_result);
        }, function (msg) {
            var err = error_1.errorCodeList.ROOM_INNER_ERROR;
            if (!msg.header || !msg.body) {
                msg.code && msg.msg && (err = msg);
                error && error(err, 0);
                return;
            }
            error && error(_this.rtm.getServerError(msg.body.err_code), msg.header.seq);
        }, room);
    };
    MessageHandler.prototype.setRelayTimer = function (offset, timeWindow) {
        var _this = this;
        var serverTimestamp = new Date().getTime() + offset;
        var residue = timeWindow * 2 - (serverTimestamp % timeWindow);
        var interval = this.rtm.generateRandumNumber(residue);
        this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_RELAY_MSG + ' setTimer ' + interval);
        this.relayTimer = setTimeout(function () {
            _this.onRelayTimer();
        }, interval);
    };
    MessageHandler.prototype.onRelayTimer = function () {
        if (this.realyMessageList.length == 0) {
            this.logger.info(action_1.ZEGO_RTM_ACTION.MESSAGE_SEND_RELAY_MSG + '  no relay data');
            return;
        }
        var relayInfo = this.realyMessageList[0];
        this.sendRelayMessageInternal(relayInfo.type, relayInfo.data, relayInfo.success, relayInfo.error);
        this.relayTimer && clearTimeout(this.relayTimer);
        this.relayTimer = null;
        this.realyMessageList.splice(0, 1);
        if (this.realyMessageList.length > 0) {
            this.setRelayTimer(this.serverTimeOffset, this.datiTimeWindow);
        }
    };
    MessageHandler.prototype.getRoomChatInfo = function (msgID, msgCount, success, error) {
        this.logger.debug('zb.mh.grc call');
        // 
        if (!this.room.isLogin()) {
            this.logger.error('zb.mh.srm no enter room');
            return;
        }
        var bodyData = {
            room_header: {
                room_id: this.room.roomID,
                room_sid: this.room.roomSid || '0',
                room_user_session_id: this.room.roomSessionID || '0',
            },
            // "request_id": this.stateCenter.getRequestId(),
            // "msg_priority": 1,
            msg_id: msgID,
            // "sort_type": sortType,
            msg_count: msgCount,
        };
        var callBack = function (msg, cmdSeq) {
            if (msg.body.code !== 0) {
                error({ errorCode: msg.body.code, extendData: msg.body.message || '' });
            }
            else {
                var chatData = msg.body.msg_data.map(function (data) {
                    return {
                        fromUser: {
                            userID: data.user_id,
                            userName: data.user_name,
                        },
                        message: data.msg_content,
                        sendTime: data.send_time,
                        messageID: data.msg_id,
                    };
                });
                success({ chatData: chatData });
            }
        };
        this.service.sendMessage('zegochat_js.room_im_chat_fetch', bodyData, callBack, callBack);
        this.logger.info('zb.mh.grc call success');
    };
    return MessageHandler;
}());
exports.MessageHandler = MessageHandler;


/***/ })

/******/ });
});

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./sdk/code/zh/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});